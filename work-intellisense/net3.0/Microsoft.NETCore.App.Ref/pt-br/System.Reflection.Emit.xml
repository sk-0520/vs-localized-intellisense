<?xml version="1.0" encoding="utf-8"?>
<doc xmlns:vsli="https://github.com/sk-0520/vs-localized-intellisense/tree/master/schema/2024">
  <assembly>
    <name>System.Reflection.Emit</name>
  </assembly>
  <members>
    <member name="T:System.Reflection.Emit.AssemblyBuilder">
      <summary vsli:raw="Defines and represents a dynamic assembly.">Define e representa um assembly dinâmico.</summary>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.CodeBase">
      <summary vsli:raw="Gets the location of the assembly, as specified originally (such as in an &lt;see cref=&quot;T:System.Reflection.AssemblyName&quot; /&gt; object).">Obtém o local do assembly como especificado originalmente (como em um objeto <see cref="T:System.Reflection.AssemblyName" />).</summary>
      <returns vsli:raw="The location of the assembly, as specified originally.">O local do assembly, conforme especificado originalmente.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported.">Não há suporte para este método atualmente.</exception>
      <exception cref="T:System.Security.SecurityException" vsli:raw="The caller does not have the required permission.">O chamador não tem a permissão necessária.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
      <summary vsli:raw="Defines a dynamic assembly that has the specified name and access rights.">Define um assembly dinâmico que tem o nome e os direitos de acesso especificados.</summary>
      <param name="name" vsli:raw="The name of the assembly.">O nome do assembly.</param>
      <param name="access" vsli:raw="The access rights of the assembly.">Os direitos de acesso do assembly.</param>
      <returns vsli:raw="An object that represents the new assembly.">Um objeto que representa o novo assembly.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
      <summary vsli:raw="Defines a new assembly that has the specified name, access rights, and attributes.">Define um novo assembly que tem o nome, os direitos de acesso e os atributos especificados.</summary>
      <param name="name" vsli:raw="The name of the assembly.">O nome do assembly.</param>
      <param name="access" vsli:raw="The access rights of the assembly.">Os direitos de acesso do assembly.</param>
      <param name="assemblyAttributes" vsli:raw="A collection that contains the attributes of the assembly.">Uma coleção que contém os atributos do assembly.</param>
      <returns vsli:raw="An object that represents the new assembly.">Um objeto que representa o novo assembly.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String)">
      <summary vsli:raw="Defines a named transient dynamic module in this assembly.">Define um módulo dinâmico transitório nomeado nesse assembly.</summary>
      <param name="name" vsli:raw="The name of the dynamic module.">O nome do módulo dinâmico.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Emit.ModuleBuilder&quot; /&gt; representing the defined dynamic module.">Um <see cref="T:System.Reflection.Emit.ModuleBuilder" /> que representa o módulo dinâmico definido.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; begins with white space.&#xA;&#xA; -or-&#xA;&#xA; The length of &lt;paramref name=&quot;name&quot; /&gt; is zero.&#xA;&#xA; -or-&#xA;&#xA; The length of &lt;paramref name=&quot;name&quot; /&gt; is greater than the system-defined maximum length.">
        <paramref name="name" /> começa com um espaço em branco.  

ou - 
O comprimento de <paramref name="name" /> é zero.  

ou - 
O comprimento de <paramref name="name" /> é maior que o comprimento máximo definido pelo sistema.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> é <see langword="null" />.</exception>
      <exception cref="T:System.Security.SecurityException" vsli:raw="The caller does not have the required permission.">O chamador não tem a permissão necessária.</exception>
      <exception cref="T:System.ExecutionEngineException" vsli:raw="The assembly for default symbol writer cannot be loaded.&#xA;&#xA; -or-&#xA;&#xA; The type that implements the default symbol writer interface cannot be found.">Não é possível carregar o assembly para o gravador de símbolo padrão.  

ou -  

 Não foi possível encontrar o tipo que implementa a interface do gravador de símbolo padrão.</exception>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.EntryPoint">
      <summary vsli:raw="Returns the entry point of this assembly.">Retorna o ponto de entrada desse assembly.</summary>
      <returns vsli:raw="The entry point of this assembly.">O ponto de entrada deste assembly.</returns>
      <exception cref="T:System.Security.SecurityException" vsli:raw="The caller does not have the required permission.">O chamador não tem a permissão necessária.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.Equals(System.Object)">
      <summary vsli:raw="Returns a value that indicates whether this instance is equal to the specified object.">Retorna um valor que indica se essa instância é igual ao objeto especificado.</summary>
      <param name="obj" vsli:raw="An object to compare with this instance, or &lt;see langword=&quot;null&quot; /&gt;.">Um objeto a ser comparado com essa instância ou <see langword="null" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;obj&quot; /&gt; equals the type and value of this instance; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se <paramref name="obj" /> for igual ao tipo e ao valor dessa instância, caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.FullName">
      <summary vsli:raw="Gets the display name of the current dynamic assembly.">Obtém o nome de exibição do assembly dinâmico atual.</summary>
      <returns vsli:raw="The display name of the dynamic assembly.">O nome de exibição do assembly dinâmico.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetCustomAttributes(System.Boolean)">
      <summary vsli:raw="Returns all the custom attributes that have been applied to the current &lt;see cref=&quot;T:System.Reflection.Emit.AssemblyBuilder&quot; /&gt;.">Retorna todos os atributos personalizados que foram aplicados ao <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> atual.</summary>
      <param name="inherit" vsli:raw="This argument is ignored for objects of this type.">Este argumento é ignorado para objetos deste tipo.</param>
      <returns vsli:raw="An array that contains the custom attributes; the array is empty if there are no attributes.">Uma matriz que contém os atributos personalizados; a matriz será vazia se não houver nenhum atributo.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary vsli:raw="Returns all the custom attributes that have been applied to the current &lt;see cref=&quot;T:System.Reflection.Emit.AssemblyBuilder&quot; /&gt;, and that derive from a specified attribute type.">Retorna todos os atributos personalizados que foram aplicados ao <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> atual e que derivam de um tipo de atributo especificado.</summary>
      <param name="attributeType" vsli:raw="The base type from which attributes derive.">O tipo base do qual derivam os atributos.</param>
      <param name="inherit" vsli:raw="This argument is ignored for objects of this type.">Este argumento é ignorado para objetos deste tipo.</param>
      <returns vsli:raw="An array that contains the custom attributes that are derived at any level from &lt;paramref name=&quot;attributeType&quot; /&gt;; the array is empty if there are no such attributes.">Uma matriz que contém os atributos personalizados que são derivados em qualquer nível de <paramref name="attributeType" />; a matriz será vazia se não houver nenhum desses atributos.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;attributeType&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="attributeType" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;attributeType&quot; /&gt; is not a &lt;see cref=&quot;T:System.Type&quot; /&gt; object supplied by the runtime. For example, &lt;paramref name=&quot;attributeType&quot; /&gt; is a &lt;see cref=&quot;T:System.Reflection.Emit.TypeBuilder&quot; /&gt; object.">
        <paramref name="attributeType" /> não é um objeto <see cref="T:System.Type" /> fornecido pelo tempo de execução. Por exemplo, <paramref name="attributeType" /> é um objeto <see cref="T:System.Reflection.Emit.TypeBuilder" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetCustomAttributesData">
      <summary vsli:raw="Returns &lt;see cref=&quot;T:System.Reflection.CustomAttributeData&quot; /&gt; objects that contain information about the attributes that have been applied to the current &lt;see cref=&quot;T:System.Reflection.Emit.AssemblyBuilder&quot; /&gt;.">Retorna objetos <see cref="T:System.Reflection.CustomAttributeData" /> que contêm informações sobre os atributos que foram aplicados ao <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> atual.</summary>
      <returns vsli:raw="A generic list of &lt;see cref=&quot;T:System.Reflection.CustomAttributeData&quot; /&gt; objects representing data about the attributes that have been applied to the current module.">Uma lista genérica de objetos <see cref="T:System.Reflection.CustomAttributeData" /> que representam dados sobre os atributos que foram aplicados ao módulo atual.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule(System.String)">
      <summary vsli:raw="Returns the dynamic module with the specified name.">Retorna o módulo dinâmico com o nome especificado.</summary>
      <param name="name" vsli:raw="The name of the requested dynamic module.">O nome do módulo dinâmico solicitado.</param>
      <returns vsli:raw="A ModuleBuilder object representing the requested dynamic module.">Um objeto ModuleBuilder que representa o módulo dinâmico solicitado.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The length of &lt;paramref name=&quot;name&quot; /&gt; is zero.">O comprimento de <paramref name="name" /> é zero.</exception>
      <exception cref="T:System.Security.SecurityException" vsli:raw="The caller does not have the required permission.">O chamador não tem a permissão necessária.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetExportedTypes">
      <summary vsli:raw="Gets the exported types defined in this assembly.">Obtém os tipos exportados definidos neste assembly.</summary>
      <returns vsli:raw="An array of &lt;see cref=&quot;T:System.Type&quot; /&gt; containing the exported types defined in this assembly.">Uma matriz de <see cref="T:System.Type" /> que contém os tipos exportados definidos neste assembly.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not implemented.">Este método não está implementado.</exception>
      <exception cref="T:System.Security.SecurityException" vsli:raw="The caller does not have the required permission.">O chamador não tem a permissão necessária.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetFile(System.String)">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.IO.FileStream&quot; /&gt; for the specified file in the file table of the manifest of this assembly.">Obtém um <see cref="T:System.IO.FileStream" /> para o arquivo especificado na tabela de arquivo do manifesto desse assembly.</summary>
      <param name="name" vsli:raw="The name of the specified file.">O nome do arquivo especificado.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.IO.FileStream&quot; /&gt; for the specified file, or &lt;see langword=&quot;null&quot; /&gt;, if the file is not found.">Um <see cref="T:System.IO.FileStream" /> para o arquivo especificado, ou <see langword="null" /> se o arquivo não for encontrado.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported.">Não há suporte para este método atualmente.</exception>
      <exception cref="T:System.Security.SecurityException" vsli:raw="The caller does not have the required permission.">O chamador não tem a permissão necessária.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetFiles(System.Boolean)">
      <summary vsli:raw="Gets the files in the file table of an assembly manifest, specifying whether to include resource modules.">Obtém os arquivos na tabela de arquivos de um manifesto do assembly, especificando se deseja-se incluir os módulos de recursos.</summary>
      <param name="getResourceModules" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to include resource modules; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para incluir os módulos de recursos; caso contrário, <see langword="false" />.</param>
      <returns vsli:raw="An array of &lt;see cref=&quot;T:System.IO.FileStream&quot; /&gt; objects.">Uma matriz de objetos de <see cref="T:System.IO.FileStream" />.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported.">Não há suporte para este método atualmente.</exception>
      <exception cref="T:System.Security.SecurityException" vsli:raw="The caller does not have the required permission.">O chamador não tem a permissão necessária.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetHashCode">
      <summary vsli:raw="Returns the hash code for this instance.">Retorna o código hash para essa instância.</summary>
      <returns vsli:raw="A 32-bit signed integer hash code.">Um código de hash do inteiro assinado de 32 bits.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetLoadedModules(System.Boolean)">
      <summary vsli:raw="Returns all the loaded modules that are part of this assembly, and optionally includes resource modules.">Retorna todos os módulos carregados que fazem parte desse assembly e, opcionalmente, inclui módulos de recursos.</summary>
      <param name="getResourceModules" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to include resource modules; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para incluir os módulos de recursos; caso contrário, <see langword="false" />.</param>
      <returns vsli:raw="The loaded modules that are part of this assembly.">Os módulos carregados que fazem parte desse assembly.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceInfo(System.String)">
      <summary vsli:raw="Returns information about how the given resource has been persisted.">Retorna informações sobre como o recurso em questão foi persistido.</summary>
      <param name="resourceName" vsli:raw="The name of the resource.">O nome do recurso.</param>
      <returns vsli:raw="&lt;see cref=&quot;T:System.Reflection.ManifestResourceInfo&quot; /&gt; populated with information about the resource's topology, or &lt;see langword=&quot;null&quot; /&gt; if the resource is not found.">
        <see cref="T:System.Reflection.ManifestResourceInfo" /> é preenchido com informações sobre a topologia do recurso ou <see langword="null" />, se o recurso não for encontrado.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported.">Não há suporte para este método atualmente.</exception>
      <exception cref="T:System.Security.SecurityException" vsli:raw="The caller does not have the required permission.">O chamador não tem a permissão necessária.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceNames">
      <summary vsli:raw="Loads the specified manifest resource from this assembly.">Carrega o recurso de manifesto especificado desse assembly.</summary>
      <returns vsli:raw="An array of type &lt;see langword=&quot;String&quot; /&gt; containing the names of all the resources.">Uma matriz do tipo <see langword="String" /> que contém os nomes de todos os recursos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not supported on a dynamic assembly. To get the manifest resource names, use &lt;see cref=&quot;M:System.Reflection.Assembly.GetManifestResourceNames&quot; /&gt;.">Este método não tem suporte em um assembly dinâmico. Para obter os nomes de recurso de manifesto, use <see cref="M:System.Reflection.Assembly.GetManifestResourceNames" />.</exception>
      <exception cref="T:System.Security.SecurityException" vsli:raw="The caller does not have the required permission.">O chamador não tem a permissão necessária.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceStream(System.String)">
      <summary vsli:raw="Loads the specified manifest resource from this assembly.">Carrega o recurso de manifesto especificado desse assembly.</summary>
      <param name="name" vsli:raw="The name of the manifest resource being requested.">O nome do recurso de manifesto solicitado.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.IO.Stream&quot; /&gt; representing this manifest resource.">Um <see cref="T:System.IO.Stream" /> que representa esse recurso de manifesto.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported.">Não há suporte para este método atualmente.</exception>
      <exception cref="T:System.Security.SecurityException" vsli:raw="The caller does not have the required permission.">O chamador não tem a permissão necessária.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceStream(System.Type,System.String)">
      <summary vsli:raw="Loads the specified manifest resource, scoped by the namespace of the specified type, from this assembly.">Carrega o recurso de manifesto especificado, o escopo pelo namespace do tipo especificado, desse assembly.</summary>
      <param name="type" vsli:raw="The type whose namespace is used to scope the manifest resource name.">O tipo cujo namespace é usado para definir o escopo do nome de recurso de manifesto.</param>
      <param name="name" vsli:raw="The name of the manifest resource being requested.">O nome do recurso de manifesto solicitado.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.IO.Stream&quot; /&gt; representing this manifest resource.">Um <see cref="T:System.IO.Stream" /> que representa esse recurso de manifesto.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported.">Não há suporte para este método atualmente.</exception>
      <exception cref="T:System.Security.SecurityException" vsli:raw="The caller does not have the required permission.">O chamador não tem a permissão necessária.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetModule(System.String)">
      <summary vsli:raw="Gets the specified module in this assembly.">Obtém o módulo especificado nesse assembly.</summary>
      <param name="name" vsli:raw="The name of the requested module.">O nome do módulo solicitado.</param>
      <returns vsli:raw="The module being requested, or &lt;see langword=&quot;null&quot; /&gt; if the module is not found.">O módulo que está sendo solicitado ou <see langword="null" />, se o módulo não tiver sido encontrado.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetModules(System.Boolean)">
      <summary vsli:raw="Gets all the modules that are part of this assembly, and optionally includes resource modules.">Obtém todos os módulos que fazem parte desse assembly e, opcionalmente, inclui módulos de recursos.</summary>
      <param name="getResourceModules" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to include resource modules; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para incluir os módulos de recursos; caso contrário, <see langword="false" />.</param>
      <returns vsli:raw="The modules that are part of this assembly.">Os módulos que fazem parte desse assembly.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetName(System.Boolean)">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Reflection.AssemblyName&quot; /&gt; that was specified when the current dynamic assembly was created, and sets the code base as specified.">Obtém o <see cref="T:System.Reflection.AssemblyName" />, que foi especificado quando o assembly dinâmico atual foi criado e define a base de código como especificado.</summary>
      <param name="copiedName" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set the code base to the location of the assembly after it is shadow-copied; &lt;see langword=&quot;false&quot; /&gt; to set the code base to the original location.">
        <see langword="true" /> para definir a base de código para o local do assembly depois que tiver sido feita uma cópia de sombra dele; <see langword="false" /> para definir a base de código com o local original.</param>
      <returns vsli:raw="The name of the dynamic assembly.">O nome do assembly dinâmico.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetReferencedAssemblies">
      <summary vsli:raw="Gets an incomplete list of &lt;see cref=&quot;T:System.Reflection.AssemblyName&quot; /&gt; objects for the assemblies that are referenced by this &lt;see cref=&quot;T:System.Reflection.Emit.AssemblyBuilder&quot; /&gt;.">Obtém uma lista incompleta de objetos <see cref="T:System.Reflection.AssemblyName" /> para os assemblies que são referenciados por este <see cref="T:System.Reflection.Emit.AssemblyBuilder" />.</summary>
      <returns vsli:raw="An array of assembly names for the referenced assemblies. This array is not a complete list.">Uma matriz de nomes de assembly para os assemblies referenciados. Esta matriz não é uma lista completa.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetSatelliteAssembly(System.Globalization.CultureInfo)">
      <summary vsli:raw="Gets the satellite assembly for the specified culture.">Obtém o assembly satélite para a cultura especificada.</summary>
      <param name="culture" vsli:raw="The specified culture.">A cultura especificada.</param>
      <returns vsli:raw="The specified satellite assembly.">O assembly satélite especificado.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;culture&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="culture" /> é <see langword="null" />.</exception>
      <exception cref="T:System.IO.FileNotFoundException" vsli:raw="The assembly cannot be found.">Não foi possível localizar o assembly.</exception>
      <exception cref="T:System.IO.FileLoadException" vsli:raw="The satellite assembly with a matching file name was found, but the &lt;see langword=&quot;CultureInfo&quot; /&gt; did not match the one specified.">O assembly satélite com um nome de arquivo correspondente foi encontrado, mas o <see langword="CultureInfo" /> não correspondia ao especificado.</exception>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The satellite assembly is not a valid assembly.">O assembly satélite não é um assembly válido.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
      <summary vsli:raw="Gets the specified version of the satellite assembly for the specified culture.">Obtém a versão especificada do assembly satélite para a cultura especificada.</summary>
      <param name="culture" vsli:raw="The specified culture.">A cultura especificada.</param>
      <param name="version" vsli:raw="The version of the satellite assembly.">A versão do assembly satélite.</param>
      <returns vsli:raw="The specified satellite assembly.">O assembly satélite especificado.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;culture&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="culture" /> é <see langword="null" />.</exception>
      <exception cref="T:System.IO.FileLoadException" vsli:raw="The satellite assembly with a matching file name was found, but the &lt;see langword=&quot;CultureInfo&quot; /&gt; or the version did not match the one specified.">O assembly satélite com um nome de arquivo correspondente foi encontrado, mas o <see langword="CultureInfo" /> ou a versão não correspondia ao especificado.</exception>
      <exception cref="T:System.IO.FileNotFoundException" vsli:raw="The assembly cannot be found.">Não foi possível localizar o assembly.</exception>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The satellite assembly is not a valid assembly.">O assembly satélite não é um assembly válido.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetType(System.String,System.Boolean,System.Boolean)">
      <summary vsli:raw="Gets the specified type from the types that have been defined and created in the current &lt;see cref=&quot;T:System.Reflection.Emit.AssemblyBuilder&quot; /&gt;.">Obtém o tipo especificado dos tipos que foram definidos e criados no <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> atual.</summary>
      <param name="name" vsli:raw="The name of the type to search for.">O nome do tipo a ser pesquisado.</param>
      <param name="throwOnError" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to throw an exception if the type is not found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para gerar uma exceção se o tipo não for encontrado; caso contrário <see langword="false" />.</param>
      <param name="ignoreCase" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to ignore the case of the type name when searching; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para ignorar maiúsculas e minúsculas do nome do tipo durante a pesquisa; caso contrário, <see langword="false" />.</param>
      <returns vsli:raw="The specified type, or &lt;see langword=&quot;null&quot; /&gt; if the type is not found or has not been created yet.">O tipo especificado, ou <see langword="null" /> se o tipo não for encontrado ou ainda não tiver sido criado.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.GlobalAssemblyCache">
      <summary>Obtém um valor que indica se o assembly foi carregado do cache de assembly global.</summary>
      <returns>Sempre <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.HostContext">
      <summary vsli:raw="Gets the host context where the dynamic assembly is being created.">Obtém o contexto do host em que o assembly dinâmico está sendo criado.</summary>
      <returns vsli:raw="A value that indicates the host context where the dynamic assembly is being created.">Um valor que indica o contexto de host em que o assembly dinâmico está sendo criado.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.ImageRuntimeVersion">
      <summary>Obtém a versão do Common Language Runtime que será salvo no arquivo que contém o manifesto.</summary>
      <returns>Uma cadeia de caracteres que representa a versão de Common Language Runtime.</returns>
      <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.IsDefined(System.Type,System.Boolean)">
      <summary vsli:raw="Returns a value that indicates whether one or more instances of the specified attribute type is applied to this member.">Retorna um valor que indica se uma ou mais instâncias do tipo de atributo especificado será aplicada a esse membro.</summary>
      <param name="attributeType" vsli:raw="The type of attribute to test for.">O tipo de atributo a ser testado.</param>
      <param name="inherit" vsli:raw="This argument is ignored for objects of this type.">Este argumento é ignorado para objetos deste tipo.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if one or more instances of &lt;paramref name=&quot;attributeType&quot; /&gt; is applied to this dynamic assembly; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se uma ou mais instâncias de <paramref name="attributeType" /> for aplicada a este assembly dinâmico; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.IsDynamic">
      <summary vsli:raw="Gets a value that indicates that the current assembly is a dynamic assembly.">Obtém um valor que indica que o assembly atual é um assembly dinâmico.</summary>
      <returns vsli:raw="Always &lt;see langword=&quot;true&quot; /&gt;.">Sempre <see langword="true" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.Location">
      <summary vsli:raw="Gets the location, in codebase format, of the loaded file that contains the manifest if it is not shadow-copied.">Obtém o local, no formato de base de código, do arquivo carregado que contém o manifesto, caso não tenha sido feita cópia de sombra dele.</summary>
      <returns vsli:raw="The location of the loaded file that contains the manifest. If the loaded file has been shadow-copied, the &lt;see langword=&quot;Location&quot; /&gt; is that of the file before being shadow-copied.">A localização do arquivo carregado que contém o manifesto. Se o arquivo carregado tiver sido copiado por sombra, <see langword="Location" /> o será o do arquivo antes de ser copiado por sombra.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported.">Não há suporte para este método atualmente.</exception>
      <exception cref="T:System.Security.SecurityException" vsli:raw="The caller does not have the required permission.">O chamador não tem a permissão necessária.</exception>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.ManifestModule">
      <summary vsli:raw="Gets the module in the current &lt;see cref=&quot;T:System.Reflection.Emit.AssemblyBuilder&quot; /&gt; that contains the assembly manifest.">Obtém o módulo no <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> atual que contém o manifesto do assembly.</summary>
      <returns vsli:raw="The manifest module.">O módulo de manifesto.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.ReflectionOnly">
      <summary vsli:raw="Gets a value indicating whether the dynamic assembly is in the reflection-only context.">Obtém um valor que indica se o assembly dinâmico está no contexto de somente reflexão.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the dynamic assembly is in the reflection-only context; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />Se o assembly dinâmico estiver no contexto somente de reflexão; caso contrário <see langword="false" />,.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary vsli:raw="Set a custom attribute on this assembly using a specified custom attribute blob.">Defina um atributo personalizado neste assembly usando um blob de atributos personalizados especificado.</summary>
      <param name="con" vsli:raw="The constructor for the custom attribute.">O construtor do atributo personalizado.</param>
      <param name="binaryAttribute" vsli:raw="A byte blob representing the attributes.">Um blob de bytes que representa os atributos.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;con&quot; /&gt; or &lt;paramref name=&quot;binaryAttribute&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="con" /> ou <paramref name="binaryAttribute" /> é <see langword="null" />.</exception>
      <exception cref="T:System.Security.SecurityException" vsli:raw="The caller does not have the required permission.">O chamador não tem a permissão necessária.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;con&quot; /&gt; is not a &lt;see langword=&quot;RuntimeConstructorInfo&quot; /&gt; object.">
        <paramref name="con" /> não é um objeto <see langword="RuntimeConstructorInfo" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary vsli:raw="Set a custom attribute on this assembly using a custom attribute builder.">Defina um atributo personalizado neste assembly usando um construtor de atributos personalizados.</summary>
      <param name="customBuilder" vsli:raw="An instance of a helper class to define the custom attribute.">Uma instância de uma classe auxiliar para definir o atributo personalizado.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;con&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="con" /> é <see langword="null" />.</exception>
      <exception cref="T:System.Security.SecurityException" vsli:raw="The caller does not have the required permission.">O chamador não tem a permissão necessária.</exception>
    </member>
    <member name="T:System.Reflection.Emit.AssemblyBuilderAccess">
      <summary vsli:raw="Defines the access modes for a dynamic assembly.">Define os modos de acesso para um assembly dinâmico.</summary>
    </member>
    <member name="F:System.Reflection.Emit.AssemblyBuilderAccess.Run">
      <summary vsli:raw="The dynamic assembly can be executed, but not saved.">O assembly dinâmico pode ser executado, mas não salvo.</summary>
    </member>
    <member name="F:System.Reflection.Emit.AssemblyBuilderAccess.RunAndCollect">
      <summary vsli:raw="The dynamic assembly will be automatically unloaded and its memory reclaimed, when it's no longer accessible.">O assembly dinâmico será descarregado automaticamente e sua memória será recuperada quando ele não estiver mais acessível.</summary>
    </member>
    <member name="T:System.Reflection.Emit.ConstructorBuilder">
      <summary vsli:raw="Defines and represents a constructor of a dynamic class.">Define e representa um construtor de uma classe dinâmica.</summary>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.Attributes">
      <summary vsli:raw="Gets the attributes for this constructor.">Obtém os atributos para esse construtor.</summary>
      <returns vsli:raw="The attributes for this constructor.">Os atributos para este construtor.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.CallingConvention">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Reflection.CallingConventions&quot; /&gt; value that depends on whether the declaring type is generic.">Obtém um valor <see cref="T:System.Reflection.CallingConventions" /> que depende de se o tipo declarativo é genérico.</summary>
      <returns vsli:raw="&lt;see cref=&quot;F:System.Reflection.CallingConventions.HasThis&quot; /&gt; if the declaring type is generic; otherwise, &lt;see cref=&quot;F:System.Reflection.CallingConventions.Standard&quot; /&gt;.">
        <see cref="F:System.Reflection.CallingConventions.HasThis" />Se o tipo declarativo for genérico; caso contrário <see cref="F:System.Reflection.CallingConventions.Standard" />,.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.DeclaringType">
      <summary vsli:raw="Gets a reference to the &lt;see cref=&quot;T:System.Type&quot; /&gt; object for the type that declares this member.">Obtém uma referência para o objeto <see cref="T:System.Type" /> para o tipo que declara esse membro.</summary>
      <returns vsli:raw="The type that declares this member.">O tipo que declara esse membro.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
      <summary vsli:raw="Defines a parameter of this constructor.">Define um parâmetro deste construtor.</summary>
      <param name="iSequence" vsli:raw="The position of the parameter in the parameter list. Parameters are indexed beginning with the number 1 for the first parameter.">A posição do parâmetro na lista de parâmetros. Os parâmetros são indexados começando com o número 1 para o primeiro parâmetro.</param>
      <param name="attributes" vsli:raw="The attributes of the parameter.">Os atributos do parâmetro.</param>
      <param name="strParamName" vsli:raw="The name of the parameter. The name can be the null string.">O nome do parâmetro. O nome pode ser a cadeia de caracteres nula.</param>
      <returns vsli:raw="An object that represents the new parameter of this constructor.">Um objeto que representa o novo parâmetro deste construtor.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;iSequence&quot; /&gt; is less than 0 (zero), or it is greater than the number of parameters of the constructor.">
        <paramref name="iSequence" /> é menor que 0 (zero) ou é maior que o número de parâmetros do construtor.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The containing type has been created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.">O tipo recipiente foi criado usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.GetCustomAttributes(System.Boolean)">
      <summary vsli:raw="Returns all the custom attributes defined for this constructor.">Retorna todos os atributos personalizados definidos para esse construtor.</summary>
      <param name="inherit" vsli:raw="Controls inheritance of custom attributes from base classes. This parameter is ignored.">Controla a herança de atributos personalizados de classes base. Este parâmetro é ignorado.</param>
      <returns vsli:raw="An array of objects representing all the custom attributes of the constructor represented by this &lt;see cref=&quot;T:System.Reflection.Emit.ConstructorBuilder&quot; /&gt; instance.">Uma matriz de objetos que representa todos os atributos personalizados do construtor representados por essa instância <see cref="T:System.Reflection.Emit.ConstructorBuilder" />.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported.">Não há suporte para este método atualmente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary vsli:raw="Returns the custom attributes identified by the given type.">Retorna os atributos personalizados identificados pelo tipo determinado.</summary>
      <param name="attributeType" vsli:raw="The custom attribute type.">O tipo de atributo personalizado.</param>
      <param name="inherit" vsli:raw="Controls inheritance of custom attributes from base classes. This parameter is ignored.">Controla a herança de atributos personalizados de classes base. Este parâmetro é ignorado.</param>
      <returns vsli:raw="An object array that represents the attributes of this constructor.">Uma matriz de objeto que representa os atributos deste construtor.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported.">Não há suporte para este método atualmente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.GetILGenerator">
      <summary vsli:raw="Gets an &lt;see cref=&quot;T:System.Reflection.Emit.ILGenerator&quot; /&gt; for this constructor.">Obtém um <see cref="T:System.Reflection.Emit.ILGenerator" /> para esse construtor.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Reflection.Emit.ILGenerator&quot; /&gt; object for this constructor.">Um objeto <see cref="T:System.Reflection.Emit.ILGenerator" /> para esse construtor.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The constructor is a parameterless constructor.  &#xA;  &#xA; -or-  &#xA;  &#xA; The constructor has &lt;see cref=&quot;T:System.Reflection.MethodAttributes&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.MethodImplAttributes&quot; /&gt; flags indicating that it should not have a method body.">O construtor é um construtor sem parâmetros.  

ou - 
O construtor tem sinalizadores <see cref="T:System.Reflection.MethodAttributes" /> ou <see cref="T:System.Reflection.MethodImplAttributes" /> indicando que ele não deve ter um corpo de método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.GetILGenerator(System.Int32)">
      <summary vsli:raw="Gets an &lt;see cref=&quot;T:System.Reflection.Emit.ILGenerator&quot; /&gt; object, with the specified MSIL stream size, that can be used to build a method body for this constructor.">Obtém um objeto <see cref="T:System.Reflection.Emit.ILGenerator" />, com o tamanho de fluxo MSIL especificado, que pode ser usado para criar um corpo de método para esse construtor.</summary>
      <param name="streamSize" vsli:raw="The size of the MSIL stream, in bytes.">O tamanho do fluxo MSIL, em bytes.</param>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Reflection.Emit.ILGenerator&quot; /&gt; for this constructor.">Um <see cref="T:System.Reflection.Emit.ILGenerator" /> para esse construtor.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The constructor is a parameterless constructor.  &#xA;  &#xA; -or-  &#xA;  &#xA; The constructor has &lt;see cref=&quot;T:System.Reflection.MethodAttributes&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.MethodImplAttributes&quot; /&gt; flags indicating that it should not have a method body.">O construtor é um construtor sem parâmetros.  

ou - 
O construtor tem sinalizadores <see cref="T:System.Reflection.MethodAttributes" /> ou <see cref="T:System.Reflection.MethodImplAttributes" /> indicando que ele não deve ter um corpo de método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.GetMethodImplementationFlags">
      <summary vsli:raw="Returns the method implementation flags for this constructor.">Retorna os sinalizadores de implementação de método para esse construtor.</summary>
      <returns vsli:raw="The method implementation flags for this constructor.">Os sinalizadores de implementação de método para esse construtor.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.GetParameters">
      <summary vsli:raw="Returns the parameters of this constructor.">Retorna os parâmetros desse construtor.</summary>
      <returns vsli:raw="An array that represents the parameters of this constructor.">Uma matriz que representa os parâmetros deste construtor.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt; has not been called on this constructor's type, in the .NET Framework versions 1.0 and 1.1.">
        <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> não foi chamado nesse tipo de construtor, no .NET Framework versões 1.0 e 1.1.</exception>
      <exception cref="T:System.NotSupportedException" vsli:raw="&lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt; has not been called on this constructor's type, in the .NET Framework version 2.0.">
        <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> não foi chamado nesse tipo de construtor, no .NET Framework versão 2.0.</exception>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.InitLocals">
      <summary vsli:raw="Gets or sets whether the local variables in this constructor should be zero-initialized.">Obtém ou define se as variáveis locais neste construtor devem ser inicializadas do zero.</summary>
      <returns vsli:raw="Read/write. Gets or sets whether the local variables in this constructor should be zero-initialized.">Leitura/gravação. Obtém ou define se as variáveis locais neste construtor devem ser inicializadas do zero.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
      <summary vsli:raw="Dynamically invokes the constructor reflected by this instance with the specified arguments, under the constraints of the specified &lt;see langword=&quot;Binder&quot; /&gt;.">Invoca dinamicamente o construtor refletido por esta instância com os argumentos especificados, sob as restrições do <see langword="Binder" /> especificado.</summary>
      <param name="obj" vsli:raw="The object that needs to be reinitialized.">O objeto que precisa ser reiniciado.</param>
      <param name="invokeAttr" vsli:raw="One of the &lt;see langword=&quot;BindingFlags&quot; /&gt; values that specifies the type of binding that is desired.">Um dos valores <see langword="BindingFlags" /> que especifica o tipo de associação desejada.</param>
      <param name="binder" vsli:raw="A &lt;see langword=&quot;Binder&quot; /&gt; that defines a set of properties and enables the binding, coercion of argument types, and invocation of members using reflection. If &lt;paramref name=&quot;binder&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;, then Binder.DefaultBinding is used.">Um <see langword="Binder" /> que define um conjunto de propriedades e permite a associação, coerção de tipos de argumento e invocação de membros usando a reflexão. Se <paramref name="binder" /> for <see langword="null" />, Binder.DefaultBinding será usado.</param>
      <param name="parameters" vsli:raw="An argument list. This is an array of arguments with the same number, order, and type as the parameters of the constructor to be invoked. If there are no parameters, this should be a null reference (&lt;see langword=&quot;Nothing&quot; /&gt; in Visual Basic).">Uma lista de argumentos. Essa é uma matriz de argumentos com o mesmo número, ordem e tipo que os parâmetros do construtor a ser invocado. Se não houver nenhum parâmetro, isso deverá ser uma referência nula (<see langword="Nothing" /> no Visual Basic).</param>
      <param name="culture" vsli:raw="A &lt;see cref=&quot;T:System.Globalization.CultureInfo&quot; /&gt; used to govern the coercion of types. If this is null, the &lt;see cref=&quot;T:System.Globalization.CultureInfo&quot; /&gt; for the current thread is used.">Um <see cref="T:System.Globalization.CultureInfo" /> usado para reger a coerção de tipos. Se isso for nulo, será usado o <see cref="T:System.Globalization.CultureInfo" /> do thread atual.</param>
      <returns vsli:raw="An instance of the class associated with the constructor.">Uma instância da classe associada ao construtor.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported. You can retrieve the constructor using &lt;see cref=&quot;M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])&quot; /&gt; and call &lt;see cref=&quot;M:System.Reflection.ConstructorInfo.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)&quot; /&gt; on the returned &lt;see cref=&quot;T:System.Reflection.ConstructorInfo&quot; /&gt;.">Não há suporte para este método atualmente. Você pode recuperar o construtor usando <see cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> e chamar <see cref="M:System.Reflection.ConstructorInfo.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" /> no <see cref="T:System.Reflection.ConstructorInfo" /> retornado.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
      <summary vsli:raw="Dynamically invokes the constructor represented by this instance on the given object, passing along the specified parameters, and under the constraints of the given binder.">Invoca o construtor dinamicamente representado por esta instância no objeto determinado, passando os parâmetros especificados e sob as restrições do associador determinado.</summary>
      <param name="invokeAttr" vsli:raw="This must be a bit flag from &lt;see cref=&quot;T:System.Reflection.BindingFlags&quot; /&gt;, such as InvokeMethod, NonPublic, and so on.">Isso deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />, tal como InvokeMethod, NonPublic e assim por diante.</param>
      <param name="binder" vsli:raw="An object that enables the binding, coercion of argument types, invocation of members, and retrieval of &lt;see langword=&quot;MemberInfo&quot; /&gt; objects using reflection. If binder is &lt;see langword=&quot;null&quot; /&gt;, the default binder is used. See &lt;see cref=&quot;T:System.Reflection.Binder&quot; /&gt;.">Um objeto que permite a associação, a coerção de tipos de argumento, a invocação de membros e a recuperação de objetos <see langword="MemberInfo" /> usando reflexão. Se o associador for <see langword="null" />, o associador padrão será usado. Consulte <see cref="T:System.Reflection.Binder" />.</param>
      <param name="parameters" vsli:raw="An argument list. This is an array of arguments with the same number, order, and type as the parameters of the constructor to be invoked. If there are no parameters this should be &lt;see langword=&quot;null&quot; /&gt;.">Uma lista de argumentos. Essa é uma matriz de argumentos com o mesmo número, ordem e tipo que os parâmetros do construtor a ser invocado. Se não houver nenhum parâmetro, isso deverá ser <see langword="null" />.</param>
      <param name="culture" vsli:raw="An instance of &lt;see cref=&quot;T:System.Globalization.CultureInfo&quot; /&gt; used to govern the coercion of types. If this is null, the &lt;see cref=&quot;T:System.Globalization.CultureInfo&quot; /&gt; for the current thread is used. (For example, this is necessary to convert a &lt;see cref=&quot;T:System.String&quot; /&gt; that represents 1000 to a &lt;see cref=&quot;T:System.Double&quot; /&gt; value, since 1000 is represented differently by different cultures.)">Uma instância de <see cref="T:System.Globalization.CultureInfo" /> usada para determinar a coerção de tipos. Se isso for nulo, será usado o <see cref="T:System.Globalization.CultureInfo" /> do thread atual. (Por exemplo, isso é necessário para converter um <see cref="T:System.String" /> que representa 1000 para um valor <see cref="T:System.Double" />, uma vez que 1000 é representado de forma diferente por diferentes culturas.)</param>
      <returns vsli:raw="The value returned by the invoked constructor.">O valor retornado pelo construtor invocado.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported. You can retrieve the constructor using &lt;see cref=&quot;M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])&quot; /&gt; and call &lt;see cref=&quot;M:System.Reflection.ConstructorInfo.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)&quot; /&gt; on the returned &lt;see cref=&quot;T:System.Reflection.ConstructorInfo&quot; /&gt;.">Não há suporte para este método atualmente. Você pode recuperar o construtor usando <see cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> e chamar <see cref="M:System.Reflection.ConstructorInfo.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" /> no <see cref="T:System.Reflection.ConstructorInfo" /> retornado.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.IsDefined(System.Type,System.Boolean)">
      <summary vsli:raw="Checks if the specified custom attribute type is defined.">Verifica se o tipo de atributo personalizado especificado é definido.</summary>
      <param name="attributeType" vsli:raw="A custom attribute type.">Um tipo de atributo personalizado.</param>
      <param name="inherit" vsli:raw="Controls inheritance of custom attributes from base classes. This parameter is ignored.">Controla a herança de atributos personalizados de classes base. Este parâmetro é ignorado.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the specified custom attribute type is defined; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o tipo de atributo personalizado especificado estiver definido, caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported. You can retrieve the constructor using &lt;see cref=&quot;M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])&quot; /&gt; and call &lt;see cref=&quot;M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)&quot; /&gt; on the returned &lt;see cref=&quot;T:System.Reflection.ConstructorInfo&quot; /&gt;.">Não há suporte para este método atualmente. Você pode recuperar o construtor usando <see cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> e chamar <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> no <see cref="T:System.Reflection.ConstructorInfo" /> retornado.</exception>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.MethodHandle">
      <summary vsli:raw="Gets the internal handle for the method. Use this handle to access the underlying metadata handle.">Obtém o identificador interno para o método. Use esse identificador para acessar o identificador de metadados subjacente.</summary>
      <returns vsli:raw="The internal handle for the method. Use this handle to access the underlying metadata handle.">O identificador interno do método. Use esse identificador para acessar o identificador de metadados subjacente.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This property is not supported on this class.">Esta propriedade não tem suporte nesta classe.</exception>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.Module">
      <summary vsli:raw="Gets the dynamic module in which this constructor is defined.">Obtém o módulo dinâmico no qual este construtor é definido.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Module&quot; /&gt; object that represents the dynamic module in which this constructor is defined.">Um <see cref="T:System.Reflection.Module" /> objeto que representa o módulo dinâmico no qual esse construtor é definido.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.Name">
      <summary vsli:raw="Retrieves the name of this constructor.">Recupera o nome desse construtor.</summary>
      <returns vsli:raw="The name of this constructor.">O nome deste construtor.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.ReflectedType">
      <summary vsli:raw="Holds a reference to the &lt;see cref=&quot;T:System.Type&quot; /&gt; object from which this object was obtained.">Contém uma referência para o objeto <see cref="T:System.Type" /> do qual esse objeto foi definido.</summary>
      <returns vsli:raw="The &lt;see langword=&quot;Type&quot; /&gt; object from which this object was obtained.">O <see langword="Type" /> objeto do qual esse objeto foi obtido.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary vsli:raw="Set a custom attribute using a specified custom attribute blob.">Define um atributo personalizado usando um blob de atributo personalizado especificado.</summary>
      <param name="con" vsli:raw="The constructor for the custom attribute.">O construtor do atributo personalizado.</param>
      <param name="binaryAttribute" vsli:raw="A byte blob representing the attributes.">Um blob de bytes que representa os atributos.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;con&quot; /&gt; or &lt;paramref name=&quot;binaryAttribute&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="con" /> ou <paramref name="binaryAttribute" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary vsli:raw="Set a custom attribute using a custom attribute builder.">Defina um atributo personalizado usando um construtor de atributos personalizados.</summary>
      <param name="customBuilder" vsli:raw="An instance of a helper class to define the custom attribute.">Uma instância de uma classe auxiliar para definir o atributo personalizado.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;customBuilder&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="customBuilder" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
      <summary vsli:raw="Sets the method implementation flags for this constructor.">Define os sinalizadores de implementação de método para esse construtor.</summary>
      <param name="attributes" vsli:raw="The method implementation flags.">Os sinalizadores de implementação de método.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The containing type has been created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.">O tipo recipiente foi criado usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.ToString">
      <summary vsli:raw="Returns this &lt;see cref=&quot;T:System.Reflection.Emit.ConstructorBuilder&quot; /&gt; instance as a &lt;see cref=&quot;T:System.String&quot; /&gt;.">Retorna essa instância <see cref="T:System.Reflection.Emit.ConstructorBuilder" /> como um <see cref="T:System.String" />.</summary>
      <returns vsli:raw="A string containing the name, attributes, and exceptions of this constructor, followed by the current Microsoft intermediate language (MSIL) stream.">Uma cadeia de caracteres contém o nome, os atributos e as exceções desse construtor, seguidos pelo fluxo do MSIL (Microsoft Intermediate Language) atual.</returns>
    </member>
    <member name="T:System.Reflection.Emit.EnumBuilder">
      <summary vsli:raw="Describes and represents an enumeration type.">Descreve e representa um tipo de enumeração.</summary>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.Assembly">
      <summary vsli:raw="Retrieves the dynamic assembly that contains this enum definition.">Recupera o assembly dinâmico que contém essa definição enum.</summary>
      <returns vsli:raw="Read-only. The dynamic assembly that contains this enum definition.">Somente leitura. O assembly dinâmico que contém essa definição de enumeração.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.AssemblyQualifiedName">
      <summary vsli:raw="Returns the full path of this enum qualified by the display name of the parent assembly.">Retorna o caminho completo dessa enum qualificado pelo nome de exibição do assembly pai.</summary>
      <returns vsli:raw="Read-only. The full path of this enum qualified by the display name of the parent assembly.">Somente leitura. O caminho completo desta enumeração qualificado pelo nome de exibição do assembly pai.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.BaseType">
      <summary vsli:raw="Returns the parent &lt;see cref=&quot;T:System.Type&quot; /&gt; of this type which is always &lt;see cref=&quot;T:System.Enum&quot; /&gt;.">Retorna o <see cref="T:System.Type" /> pai desse tipo, que é sempre <see cref="T:System.Enum" />.</summary>
      <returns vsli:raw="Read-only. The parent &lt;see cref=&quot;T:System.Type&quot; /&gt; of this type.">Somente leitura. O pai <see cref="T:System.Type" /> deste tipo.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.CreateTypeInfo">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Reflection.TypeInfo&quot; /&gt; object that represents this enumeration.">Obtém um objeto <see cref="T:System.Reflection.TypeInfo" /> que representa essa enumeração.</summary>
      <returns vsli:raw="An object that represents this enumeration.">Um objeto que representa essa enumeração.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.DeclaringType">
      <summary vsli:raw="Returns the type that declared this &lt;see cref=&quot;T:System.Reflection.Emit.EnumBuilder&quot; /&gt;.">Retorna o tipo que declarou esse <see cref="T:System.Reflection.Emit.EnumBuilder" />.</summary>
      <returns vsli:raw="Read-only. The type that declared this &lt;see cref=&quot;T:System.Reflection.Emit.EnumBuilder&quot; /&gt;.">Somente leitura. O tipo que declarou isso <see cref="T:System.Reflection.Emit.EnumBuilder" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.DefineLiteral(System.String,System.Object)">
      <summary vsli:raw="Defines the named static field in an enumeration type with the specified constant value.">Define o campo estático chamado em um tipo de enumeração com o valor constante especificado.</summary>
      <param name="literalName" vsli:raw="The name of the static field.">O nome do campo estático.</param>
      <param name="literalValue" vsli:raw="The constant value of the literal.">O valor constante do literal.</param>
      <returns vsli:raw="The defined field.">O campo definido.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.FullName">
      <summary vsli:raw="Returns the full path of this enum.">Retorna o caminho completo dessa enum.</summary>
      <returns vsli:raw="Read-only. The full path of this enum.">Somente leitura. O caminho completo desta enumeração.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetConstructors(System.Reflection.BindingFlags)">
      <summary vsli:raw="Returns an array of &lt;see cref=&quot;T:System.Reflection.ConstructorInfo&quot; /&gt; objects representing the public and non-public constructors defined for this class, as specified.">Retorna uma matriz de objetos <see cref="T:System.Reflection.ConstructorInfo" /> que representam os construtores público e não público definidos para essa classe, conforme especificado.</summary>
      <param name="bindingAttr" vsli:raw="This must be a bit flag from &lt;see cref=&quot;T:System.Reflection.BindingFlags&quot; /&gt; : &lt;see langword=&quot;InvokeMethod&quot; /&gt;, &lt;see langword=&quot;NonPublic&quot; /&gt;, and so on.">Isso deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" /> e assim por diante.</param>
      <returns vsli:raw="Returns an array of &lt;see cref=&quot;T:System.Reflection.ConstructorInfo&quot; /&gt; objects representing the specified constructors defined for this class. If no constructors are defined, an empty array is returned.">Retorna uma matriz de objetos <see cref="T:System.Reflection.ConstructorInfo" /> que representam os construtores especificados definidos para esta classe. Se nenhum construtor for definido, uma matriz vazia será retornada.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported in types that are not complete.">Atualmente, esse método não tem suporte em tipos que não estão completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetCustomAttributes(System.Boolean)">
      <summary vsli:raw="Returns all the custom attributes defined for this constructor.">Retorna todos os atributos personalizados definidos para esse construtor.</summary>
      <param name="inherit" vsli:raw="Specifies whether to search this member's inheritance chain to find the attributes.">Especifica se deve-se pesquisar ou não a cadeia de herança desse membro para localizar os atributos.</param>
      <returns vsli:raw="Returns an array of objects representing all the custom attributes of the constructor represented by this &lt;see cref=&quot;T:System.Reflection.Emit.ConstructorBuilder&quot; /&gt; instance.">Retorna uma matriz de objetos que representa todos os atributos personalizados do construtor representados por essa instância <see cref="T:System.Reflection.Emit.ConstructorBuilder" />.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported in types that are not complete.">Atualmente, esse método não tem suporte em tipos que não estão completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary vsli:raw="Returns the custom attributes identified by the given type.">Retorna os atributos personalizados identificados pelo tipo determinado.</summary>
      <param name="attributeType" vsli:raw="The &lt;see langword=&quot;Type&quot; /&gt; object to which the custom attributes are applied.">O objeto <see langword="Type" /> ao qual os atributos personalizados são aplicados.</param>
      <param name="inherit" vsli:raw="Specifies whether to search this member's inheritance chain to find the attributes.">Especifica se deve-se pesquisar ou não a cadeia de herança desse membro para localizar os atributos.</param>
      <returns vsli:raw="Returns an array of objects representing the attributes of this constructor that are of &lt;see cref=&quot;T:System.Type&quot; /&gt;&lt;paramref name=&quot;attributeType&quot; /&gt;.">Retorna uma matriz de objetos que representa os atributos desse construtor que são de <see cref="T:System.Type" /><paramref name="attributeType" />.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported in types that are not complete.">Atualmente, esse método não tem suporte em tipos que não estão completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetElementType">
      <summary vsli:raw="Calling this method always throws &lt;see cref=&quot;T:System.NotSupportedException&quot; /&gt;.">A chamada desse método sempre lança <see cref="T:System.NotSupportedException" />.</summary>
      <returns vsli:raw="This method is not supported. No value is returned.">Não há suporte para o método. Nenhum valor é retornado.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported.">Não há suporte para este método atualmente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetEnumUnderlyingType">
      <summary vsli:raw="Returns the underlying integer type of the current enumeration, which is set when the enumeration builder is defined.">Retorna o tipo inteiro subjacente da enumeração atual, que é definido quando o construtor de enumeração é definido.</summary>
      <returns vsli:raw="The underlying type.">O tipo subjacente.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
      <summary vsli:raw="Returns the event with the specified name.">Retorna o evento com o nome especificado.</summary>
      <param name="name" vsli:raw="The name of the event to get.">O nome do evento a ser obtido.</param>
      <param name="bindingAttr" vsli:raw="This invocation attribute. This must be a bit flag from &lt;see cref=&quot;T:System.Reflection.BindingFlags&quot; /&gt; : &lt;see langword=&quot;InvokeMethod&quot; /&gt;, &lt;see langword=&quot;NonPublic&quot; /&gt;, and so on.">Esse atributo de invocação. Isso deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" /> e assim por diante.</param>
      <returns vsli:raw="Returns an &lt;see cref=&quot;T:System.Reflection.EventInfo&quot; /&gt; object representing the event declared or inherited by this type with the specified name. If there are no matches, &lt;see langword=&quot;null&quot; /&gt; is returned.">Retorna um objeto <see cref="T:System.Reflection.EventInfo" /> que representa o evento declarado ou herdado por esse tipo com o nome especificado. Se não houver correspondências, <see langword="null" /> será retornado.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported in types that are not complete.">Atualmente, esse método não tem suporte em tipos que não estão completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetEvents">
      <summary vsli:raw="Returns the events for the public events declared or inherited by this type.">Retorna os eventos para os eventos públicos declarados ou herdados por esse tipo.</summary>
      <returns vsli:raw="Returns an array of &lt;see cref=&quot;T:System.Reflection.EventInfo&quot; /&gt; objects representing the public events declared or inherited by this type. An empty array is returned if there are no public events.">Retorna uma matriz de objetos <see cref="T:System.Reflection.EventInfo" /> que representa os eventos públicos declarados ou herdados por esse tipo. Uma matriz vazia será retornada se não houver eventos públicos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported in types that are not complete.">Atualmente, esse método não tem suporte em tipos que não estão completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetEvents(System.Reflection.BindingFlags)">
      <summary vsli:raw="Returns the public and non-public events that are declared by this type.">Retorna os eventos públicos e não públicos que são declarados por esse tipo.</summary>
      <param name="bindingAttr" vsli:raw="This must be a bit flag from &lt;see cref=&quot;T:System.Reflection.BindingFlags&quot; /&gt;, such as &lt;see langword=&quot;InvokeMethod&quot; /&gt;, &lt;see langword=&quot;NonPublic&quot; /&gt;, and so on.">Esse deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />, tal como <see langword="InvokeMethod" />, <see langword="NonPublic" /> e assim por diante.</param>
      <returns vsli:raw="Returns an array of &lt;see cref=&quot;T:System.Reflection.EventInfo&quot; /&gt; objects representing the public and non-public events declared or inherited by this type. An empty array is returned if there are no events, as specified.">Retorna uma matriz de objetos <see cref="T:System.Reflection.EventInfo" /> que representam os eventos públicos e não públicos declarados ou herdados por esse tipo. Se não há eventos, uma matriz vazia é retornada, conforme especificado.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported in types that are not complete.">Atualmente, esse método não tem suporte em tipos que não estão completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetField(System.String,System.Reflection.BindingFlags)">
      <summary vsli:raw="Returns the field specified by the given name.">Retorna o campo especificado pelo nome fornecido.</summary>
      <param name="name" vsli:raw="The name of the field to get.">O nome do campo a ser obtido.</param>
      <param name="bindingAttr" vsli:raw="This must be a bit flag from &lt;see cref=&quot;T:System.Reflection.BindingFlags&quot; /&gt; : &lt;see langword=&quot;InvokeMethod&quot; /&gt;, &lt;see langword=&quot;NonPublic&quot; /&gt;, and so on.">Isso deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" /> e assim por diante.</param>
      <returns vsli:raw="Returns the &lt;see cref=&quot;T:System.Reflection.FieldInfo&quot; /&gt; object representing the field declared or inherited by this type with the specified name and public or non-public modifier. If there are no matches, then null is returned.">Retorna o objeto <see cref="T:System.Reflection.FieldInfo" /> que representa o campo declarado ou herdado por esse tipo com o nome especificado e o modificador público ou não público. Se não houver correspondências, nulo será retornado.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported in types that are not complete.">Atualmente, esse método não tem suporte em tipos que não estão completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetFields(System.Reflection.BindingFlags)">
      <summary vsli:raw="Returns the public and non-public fields that are declared by this type.">Retorna os campos públicos e não públicos que são declarados por esse tipo.</summary>
      <param name="bindingAttr" vsli:raw="This must be a bit flag from &lt;see cref=&quot;T:System.Reflection.BindingFlags&quot; /&gt;, such as InvokeMethod, NonPublic, and so on.">Isso deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />, tal como InvokeMethod, NonPublic e assim por diante.</param>
      <returns vsli:raw="Returns an array of &lt;see cref=&quot;T:System.Reflection.FieldInfo&quot; /&gt; objects representing the public and non-public fields declared or inherited by this type. An empty array is returned if there are no fields, as specified.">Retorna uma matriz de objetos <see cref="T:System.Reflection.FieldInfo" /> que representam os campos públicos e não públicos declarados ou herdados por esse tipo. Se não há campos, uma matriz vazia é retornada, conforme especificado.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported in types that are not complete.">Atualmente, esse método não tem suporte em tipos que não estão completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetInterface(System.String,System.Boolean)">
      <summary vsli:raw="Returns the interface implemented (directly or indirectly) by this type, with the specified fully-qualified name.">Retorna a interface implementada (direta ou indiretamente) por este tipo, com o nome totalmente qualificado especificado.</summary>
      <param name="name" vsli:raw="The name of the interface.">O nome da interface.</param>
      <param name="ignoreCase" vsli:raw="If &lt;see langword=&quot;true&quot; /&gt;, the search is case-insensitive. If &lt;see langword=&quot;false&quot; /&gt;, the search is case-sensitive.">Se <see langword="true" />, a pesquisa não diferenciará maiúsculas de minúsculas. Se <see langword="false" />, a pesquisa diferenciará maiúsculas de minúsculas.</param>
      <returns vsli:raw="Returns a &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the implemented interface. Returns null if no interface matching name is found.">Retorna um objeto <see cref="T:System.Type" /> que representa a interface implementada. Retorna nulo se nenhum nome de interface correspondente for encontrado.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported in types that are not complete.">Atualmente, esse método não tem suporte em tipos que não estão completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetInterfaceMap(System.Type)">
      <summary vsli:raw="Returns an interface mapping for the interface requested.">Retorna um mapeamento de interface para a interface solicitada.</summary>
      <param name="interfaceType" vsli:raw="The type of the interface for which the interface mapping is to be retrieved.">O tipo de interface para a qual o mapeamento da interface deve ser recuperado.</param>
      <returns vsli:raw="The requested interface mapping.">O mapeamento de interface solicitado.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The type does not implement the interface.">O tipo não implementa a interface.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetInterfaces">
      <summary vsli:raw="Returns an array of all the interfaces implemented on this a class and its base classes.">Retorna que uma matriz de todas as interfaces implementadas em uma classe e suas classes base.</summary>
      <returns vsli:raw="Returns an array of &lt;see cref=&quot;T:System.Type&quot; /&gt; objects representing the implemented interfaces. If none are defined, an empty array is returned.">Retorna uma matriz de objetos <see cref="T:System.Type" /> que representam as interfaces implementadas. Se nenhum deles for definido, uma matriz vazia será retornada.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
      <summary vsli:raw="Returns all members with the specified name, type, and binding that are declared or inherited by this type.">Retorna todos os membros com o nome especificado, o tipo e a associação que são declaradas ou herdadas por esse tipo.</summary>
      <param name="name" vsli:raw="The name of the member.">O nome do membro.</param>
      <param name="type" vsli:raw="The type of member that is to be returned.">O tipo do membro que deve ser retornado.</param>
      <param name="bindingAttr" vsli:raw="This must be a bit flag from &lt;see cref=&quot;T:System.Reflection.BindingFlags&quot; /&gt; : &lt;see langword=&quot;InvokeMethod&quot; /&gt;, &lt;see langword=&quot;NonPublic&quot; /&gt;, and so on.">Isso deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" /> e assim por diante.</param>
      <returns vsli:raw="Returns an array of &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; objects representing the public and non-public members defined on this type if &lt;paramref name=&quot;nonPublic&quot; /&gt; is used; otherwise, only the public members are returned.">Retorna uma matriz de <see cref="T:System.Reflection.MemberInfo" /> objetos que representam os membros públicos e não públicos definidos nesse tipo se <paramref name="nonPublic" /> for usado; caso contrário, somente os membros públicos serão retornados.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported in types that are not complete.">Atualmente, esse método não tem suporte em tipos que não estão completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetMembers(System.Reflection.BindingFlags)">
      <summary vsli:raw="Returns the specified members declared or inherited by this type.">Retorna os membros especificados declarados ou herdados por esse tipo.</summary>
      <param name="bindingAttr" vsli:raw="This must be a bit flag from &lt;see cref=&quot;T:System.Reflection.BindingFlags&quot; /&gt; : &lt;see langword=&quot;InvokeMethod&quot; /&gt;, &lt;see langword=&quot;NonPublic&quot; /&gt;, and so on.">Isso deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" /> e assim por diante.</param>
      <returns vsli:raw="Returns an array of &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; objects representing the public and non-public members declared or inherited by this type. An empty array is returned if there are no matching members.">Retorna uma matriz de objetos <see cref="T:System.Reflection.MemberInfo" /> que representam os membros públicos e não públicos declarados ou herdados por esse tipo. Se não houver membros correspondentes, uma matriz vazia será retornada.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported in types that are not complete.">Atualmente, esse método não tem suporte em tipos que não estão completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetMethods(System.Reflection.BindingFlags)">
      <summary vsli:raw="Returns all the public and non-public methods declared or inherited by this type, as specified.">Retorna todos os métodos públicos e não públicos declarados ou herdados por esse tipo, conforme especificado.</summary>
      <param name="bindingAttr" vsli:raw="This must be a bit flag from &lt;see cref=&quot;T:System.Reflection.BindingFlags&quot; /&gt;, such as &lt;see langword=&quot;InvokeMethod&quot; /&gt;, &lt;see langword=&quot;NonPublic&quot; /&gt;, and so on.">Esse deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />, tal como <see langword="InvokeMethod" />, <see langword="NonPublic" /> e assim por diante.</param>
      <returns vsli:raw="Returns an array of &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; objects representing the public and non-public methods defined on this type if &lt;paramref name=&quot;nonPublic&quot; /&gt; is used; otherwise, only the public methods are returned.">Retorna uma matriz de objetos <see cref="T:System.Reflection.MethodInfo" /> que representam os métodos públicos e não públicos definidos neste tipo se <paramref name="nonPublic" /> for usado; caso contrário, somente os métodos públicos serão retornados.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported in types that are not complete.">Atualmente, esse método não tem suporte em tipos que não estão completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
      <summary vsli:raw="Returns the specified nested type that is declared by this type.">Retorna o tipo aninhado especificado que é declarado por esse tipo.</summary>
      <param name="name" vsli:raw="The &lt;see cref=&quot;T:System.String&quot; /&gt; containing the name of the nested type to get.">O <see cref="T:System.String" /> que contém o nome do tipo aninhado a ser obtido.</param>
      <param name="bindingAttr" vsli:raw="A bitmask comprised of one or more &lt;see cref=&quot;T:System.Reflection.BindingFlags&quot; /&gt; that specify how the search is conducted.  &#xA;  &#xA; -or-  &#xA;  &#xA; Zero, to conduct a case-sensitive search for public methods.">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.  

ou - 
Zero, para realizar uma pesquisa que diferencia maiúsculas de minúsculas para métodos públicos.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the nested type that matches the specified requirements, if found; otherwise, &lt;see langword=&quot;null&quot; /&gt;.">Um objeto <see cref="T:System.Type" /> que representa o tipo aninhado que corresponde aos requisitos especificados, se encontrado; caso contrário, <see langword="null" />.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported in types that are not complete.">Atualmente, esse método não tem suporte em tipos que não estão completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
      <summary vsli:raw="Returns the public and non-public nested types that are declared or inherited by this type.">Retorna os tipos aninhados públicos e não públicos que são declarados ou herdados por esse tipo.</summary>
      <param name="bindingAttr" vsli:raw="This must be a bit flag from &lt;see cref=&quot;T:System.Reflection.BindingFlags&quot; /&gt;, such as &lt;see langword=&quot;InvokeMethod&quot; /&gt;, &lt;see langword=&quot;NonPublic&quot; /&gt;, and so on.">Esse deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />, tal como <see langword="InvokeMethod" />, <see langword="NonPublic" /> e assim por diante.</param>
      <returns vsli:raw="An array of &lt;see cref=&quot;T:System.Type&quot; /&gt; objects representing all the types nested within the current &lt;see cref=&quot;T:System.Type&quot; /&gt; that match the specified binding constraints.  &#xA;  &#xA; An empty array of type &lt;see cref=&quot;T:System.Type&quot; /&gt;, if no types are nested within the current &lt;see cref=&quot;T:System.Type&quot; /&gt;, or if none of the nested types match the binding constraints.">Uma matriz de objetos <see cref="T:System.Type" /> que representa todos os tipos aninhados no <see cref="T:System.Type" /> atual que correspondem às restrições de associação especificadas.  
Uma matriz vazia do tipo <see cref="T:System.Type" /> se nenhum tipo estiver aninhado no <see cref="T:System.Type" /> atual ou se nenhum dos tipos aninhados corresponderem às restrições de associação.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported in types that are not complete.">Atualmente, esse método não tem suporte em tipos que não estão completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetProperties(System.Reflection.BindingFlags)">
      <summary vsli:raw="Returns all the public and non-public properties declared or inherited by this type, as specified.">Retorna todas as propriedades públicas e não públicas declaradas ou herdadas por esse tipo, conforme especificado.</summary>
      <param name="bindingAttr" vsli:raw="This invocation attribute. This must be a bit flag from &lt;see cref=&quot;T:System.Reflection.BindingFlags&quot; /&gt; : &lt;see langword=&quot;InvokeMethod&quot; /&gt;, &lt;see langword=&quot;NonPublic&quot; /&gt;, and so on.">Esse atributo de invocação. Isso deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" /> e assim por diante.</param>
      <returns vsli:raw="Returns an array of &lt;see cref=&quot;T:System.Reflection.PropertyInfo&quot; /&gt; objects representing the public and non-public properties defined on this type if &lt;paramref name=&quot;nonPublic&quot; /&gt; is used; otherwise, only the public properties are returned.">Retorna uma matriz de objetos <see cref="T:System.Reflection.PropertyInfo" /> que representam as propriedades públicas e não públicas definidas nesse tipo se <paramref name="nonPublic" /> for usado; caso contrário, somente as propriedades públicas serão retornadas.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported in types that are not complete.">Atualmente, esse método não tem suporte em tipos que não estão completos.</exception>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.GUID">
      <summary vsli:raw="Returns the GUID of this enum.">Retorna o GUID desta enum.</summary>
      <returns vsli:raw="Read-only. The GUID of this enum.">Somente leitura. O GUID desta enumeração.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported in types that are not complete.">Atualmente, esse método não tem suporte em tipos que não estão completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
      <summary vsli:raw="Invokes the specified member. The method that is to be invoked must be accessible and provide the most specific match with the specified argument list, under the constraints of the specified binder and invocation attributes.">Invoca o membro especificado. O método a ser invocado deve ser acessível e fornecer a correspondência mais específica com a lista de argumentos especificada, sob as restrições dos atributos associadores e de invocação especificados.</summary>
      <param name="name" vsli:raw="The name of the member to invoke. This can be a constructor, method, property, or field. A suitable invocation attribute must be specified. Note that it is possible to invoke the default member of a class by passing an empty string as the name of the member.">O nome do membro a ser invocado. Isso pode ser um construtor, um método, uma propriedade ou um campo. É necessário especificar um atributo de invocação adequado. Observe que é possível invocar o membro padrão de uma classe, passando uma cadeia de caracteres vazia como o nome do membro.</param>
      <param name="invokeAttr" vsli:raw="The invocation attribute. This must be a bit flag from &lt;see langword=&quot;BindingFlags&quot; /&gt;.">O atributo de invocação. Isso deve ser um sinalizador de bit de <see langword="BindingFlags" />.</param>
      <param name="binder" vsli:raw="An object that enables the binding, coercion of argument types, invocation of members, and retrieval of &lt;see langword=&quot;MemberInfo&quot; /&gt; objects using reflection. If binder is &lt;see langword=&quot;null&quot; /&gt;, the default binder is used. See &lt;see cref=&quot;T:System.Reflection.Binder&quot; /&gt;.">Um objeto que permite a associação, a coerção de tipos de argumento, a invocação de membros e a recuperação de objetos <see langword="MemberInfo" /> usando reflexão. Se o associador for <see langword="null" />, o associador padrão será usado. Consulte <see cref="T:System.Reflection.Binder" />.</param>
      <param name="target" vsli:raw="The object on which to invoke the specified member. If the member is static, this parameter is ignored.">O objeto no qual invocar o membro especificado. Se o membro é estático, esse parâmetro é ignorado.</param>
      <param name="args" vsli:raw="An argument list. This is an array of objects that contains the number, order, and type of the parameters of the member to be invoked. If there are no parameters this should be null.">Uma lista de argumentos. Essa é uma matriz de objetos que contém o número, a ordem e o tipo dos parâmetros do membro a ser invocado. Se não houver nenhum parâmetro, isso deverá ser nulo.</param>
      <param name="modifiers" vsli:raw="An array of the same length as &lt;paramref name=&quot;args&quot; /&gt; with elements that represent the attributes associated with the arguments of the member to be invoked. A parameter has attributes associated with it in the metadata. They are used by various interoperability services. See the metadata specs for details such as this.">Uma matriz do mesmo comprimento que <paramref name="args" /> com elementos que representam os atributos associados com os argumentos do membro a ser invocado. Um parâmetro com atributos associados a ele nos metadados. Eles são usados por diversos serviços de interoperabilidade. Consulte as especificações de metadados para obter detalhes como esse.</param>
      <param name="culture" vsli:raw="An instance of &lt;see langword=&quot;CultureInfo&quot; /&gt; used to govern the coercion of types. If this is null, the &lt;see langword=&quot;CultureInfo&quot; /&gt; for the current thread is used. (Note that this is necessary to, for example, convert a string that represents 1000 to a double value, since 1000 is represented differently by different cultures.)">Uma instância de <see langword="CultureInfo" /> usada para determinar a coerção de tipos. Se isso for nulo, será usado o <see langword="CultureInfo" /> do thread atual. (Por exemplo, isso é necessário para converter uma cadeia de caracteres que representa 1000 para um valor de tipo double, uma vez que 1000 é representado de forma diferente por diferentes culturas.)</param>
      <param name="namedParameters" vsli:raw="Each parameter in the &lt;paramref name=&quot;namedParameters&quot; /&gt; array gets the value in the corresponding element in the &lt;paramref name=&quot;args&quot; /&gt; array. If the length of &lt;paramref name=&quot;args&quot; /&gt; is greater than the length of &lt;paramref name=&quot;namedParameters&quot; /&gt;, the remaining argument values are passed in order.">Cada parâmetro na matriz <paramref name="namedParameters" /> obtém o valor no elemento correspondente na matriz <paramref name="args" />. Se o comprimento de <paramref name="args" /> for maior que o de <paramref name="namedParameters" />, os valores de argumento restantes serão passados em ordem.</param>
      <returns vsli:raw="Returns the return value of the invoked member.">Retorna o valor retornado do membro invocado.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported in types that are not complete.">Atualmente, esse método não tem suporte em tipos que não estão completos.</exception>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.IsByRefLike" />
    <member name="P:System.Reflection.Emit.EnumBuilder.IsConstructedGenericType">
      <summary vsli:raw="Gets a value that indicates whether this object represents a constructed generic type.">Obtém um valor que indica se este objeto representa um tipo genérico construído.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if this object represents a constructed generic type; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se este objeto representar um tipo genérico construído; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.IsDefined(System.Type,System.Boolean)">
      <summary vsli:raw="Checks if the specified custom attribute type is defined.">Verifica se o tipo de atributo personalizado especificado é definido.</summary>
      <param name="attributeType" vsli:raw="The &lt;see langword=&quot;Type&quot; /&gt; object to which the custom attributes are applied.">O objeto <see langword="Type" /> ao qual os atributos personalizados são aplicados.</param>
      <param name="inherit" vsli:raw="Specifies whether to search this member's inheritance chain to find the attributes.">Especifica se deve-se pesquisar ou não a cadeia de herança desse membro para localizar os atributos.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if one or more instance of &lt;paramref name=&quot;attributeType&quot; /&gt; is defined on this member; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se uma ou mais instâncias de <paramref name="attributeType" /> estão definidas nesse membro; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported in types that are not complete.">Atualmente, esse método não tem suporte em tipos que não estão completos.</exception>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.IsSZArray" />
    <member name="P:System.Reflection.Emit.EnumBuilder.IsTypeDefinition" />
    <member name="P:System.Reflection.Emit.EnumBuilder.IsVariableBoundArray" />
    <member name="M:System.Reflection.Emit.EnumBuilder.MakeArrayType">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing a one-dimensional array of the current type, with a lower bound of zero.">Retorna um objeto <see cref="T:System.Type" /> que representa uma matriz unidimensional do tipo atual, com um limite inferior de zero.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing a one-dimensional array of the current type, with a lower bound of zero.">Um objeto <see cref="T:System.Type" /> que representa uma matriz unidimensional do tipo atual, com um limite inferior de zero.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.MakeArrayType(System.Int32)">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing an array of the current type, with the specified number of dimensions.">Retorna um objeto <see cref="T:System.Type" /> que representa uma matriz do tipo atual, com o número de dimensões especificado.</summary>
      <param name="rank" vsli:raw="The number of dimensions for the array. This number must be less than or equal to 32.">O número de dimensões da matriz. Esse número deve ser menor ou igual a 32.</param>
      <returns vsli:raw="An object representing an array of the current type, with the specified number of dimensions.">Um objeto que representa uma matriz do tipo atual, com o número de dimensões especificado.</returns>
      <exception cref="T:System.IndexOutOfRangeException" vsli:raw="&lt;paramref name=&quot;rank&quot; /&gt; is less than 1.">
        <paramref name="rank" /> é menor que 1.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.MakeByRefType">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents the current type when passed as a ref parameter (ByRef parameter in Visual Basic).">Retorna um objeto <see cref="T:System.Type" /> que representa o tipo atual quando passado como um parâmetro ref (parâmetro ByRef no Visual Basic).</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents the current type when passed as a ref parameter (ByRef parameter in Visual Basic).">Um objeto <see cref="T:System.Type" /> que representa o tipo atual quando passado como um parâmetro ref (parâmetro ByRef no Visual Basic).</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.MakePointerType">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents a pointer to the current type.">Retorna um objeto <see cref="T:System.Type" /> que representa um ponteiro para o tipo atual.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents a pointer to the current type.">Um objeto <see cref="T:System.Type" /> que representa um ponteiro para o tipo atual.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.Module">
      <summary vsli:raw="Retrieves the dynamic module that contains this &lt;see cref=&quot;T:System.Reflection.Emit.EnumBuilder&quot; /&gt; definition.">Recupera o módulo dinâmico que contém essa definição <see cref="T:System.Reflection.Emit.EnumBuilder" />.</summary>
      <returns vsli:raw="Read-only. The dynamic module that contains this &lt;see cref=&quot;T:System.Reflection.Emit.EnumBuilder&quot; /&gt; definition.">Somente leitura. O módulo dinâmico que contém essa <see cref="T:System.Reflection.Emit.EnumBuilder" /> definição.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.Name">
      <summary vsli:raw="Returns the name of this enum.">Retorna o nome dessa enum.</summary>
      <returns vsli:raw="Read-only. The name of this enum.">Somente leitura. O nome desta enumeração.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.Namespace">
      <summary vsli:raw="Returns the namespace of this enum.">Retorna o namespace dessa enum.</summary>
      <returns vsli:raw="Read-only. The namespace of this enum.">Somente leitura. O namespace desta enumeração.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.ReflectedType">
      <summary vsli:raw="Returns the type that was used to obtain this &lt;see cref=&quot;T:System.Reflection.Emit.EnumBuilder&quot; /&gt;.">Retorna o tipo que foi usado para obter esse <see cref="T:System.Reflection.Emit.EnumBuilder" />.</summary>
      <returns vsli:raw="Read-only. The type that was used to obtain this &lt;see cref=&quot;T:System.Reflection.Emit.EnumBuilder&quot; /&gt;.">Somente leitura. O tipo que foi usado para obter isso <see cref="T:System.Reflection.Emit.EnumBuilder" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary vsli:raw="Sets a custom attribute using a specified custom attribute blob.">Define um atributo personalizado usando um blob de atributo personalizado especificado.</summary>
      <param name="con" vsli:raw="The constructor for the custom attribute.">O construtor do atributo personalizado.</param>
      <param name="binaryAttribute" vsli:raw="A byte blob representing the attributes.">Um blob de bytes que representa os atributos.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;con&quot; /&gt; or &lt;paramref name=&quot;binaryAttribute&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="con" /> ou <paramref name="binaryAttribute" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary vsli:raw="Sets a custom attribute using a custom attribute builder.">Define um atributo personalizado usando um construtor de atributos personalizados.</summary>
      <param name="customBuilder" vsli:raw="An instance of a helper class to define the custom attribute.">Uma instância de uma classe auxiliar para definir o atributo personalizado.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;con&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="con" /> é <see langword="null" />.</exception>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.TypeHandle">
      <summary vsli:raw="Retrieves the internal handle for this enum.">Recupera o identificador interno para essa enum.</summary>
      <returns vsli:raw="Read-only. The internal handle for this enum.">Somente leitura. O identificador interno para esta enumeração.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This property is not currently supported.">Não há suporte para esta propriedade atualmente.</exception>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.UnderlyingField">
      <summary vsli:raw="Returns the underlying field for this enum.">Retorna o campo subjacente para essa enum.</summary>
      <returns vsli:raw="Read-only. The underlying field for this enum.">Somente leitura. O campo subjacente para esta enumeração.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.UnderlyingSystemType">
      <summary vsli:raw="Returns the underlying system type for this enum.">Retorna o tipo de sistema subjacente para essa enum.</summary>
      <returns vsli:raw="Read-only. Returns the underlying system type.">Somente leitura. Retorna o tipo de sistema subjacente.</returns>
    </member>
    <member name="T:System.Reflection.Emit.EventBuilder">
      <summary vsli:raw="Defines events for a class.">Define os eventos para uma classe.</summary>
    </member>
    <member name="M:System.Reflection.Emit.EventBuilder.AddOtherMethod(System.Reflection.Emit.MethodBuilder)">
      <summary vsli:raw="Adds one of the &quot;other&quot; methods associated with this event. &quot;Other&quot; methods are methods other than the &quot;on&quot; and &quot;raise&quot; methods associated with an event. This function can be called many times to add as many &quot;other&quot; methods.">Adiciona um dos "outros" métodos associados a esse evento. "Outros" métodos são métodos diferente dos métodos "on" e "raise" associados a um evento. Essa função pode ser chamada várias vezes para adicionar quantos "outros" métodos forem necessários.</summary>
      <param name="mdBuilder" vsli:raw="A &lt;see langword=&quot;MethodBuilder&quot; /&gt; object that represents the other method.">Um objeto <see langword="MethodBuilder" /> que representa o outro método.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;mdBuilder&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="mdBuilder" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt; has been called on the enclosing type.">O <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> foi chamado no tipo de delimitador.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EventBuilder.SetAddOnMethod(System.Reflection.Emit.MethodBuilder)">
      <summary vsli:raw="Sets the method used to subscribe to this event.">Define o método usado para assinar este evento.</summary>
      <param name="mdBuilder" vsli:raw="A &lt;see langword=&quot;MethodBuilder&quot; /&gt; object that represents the method used to subscribe to this event.">Um objeto <see langword="MethodBuilder" /> que representa o método usado para assinar este evento.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;mdBuilder&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="mdBuilder" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt; has been called on the enclosing type.">O <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> foi chamado no tipo de delimitador.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EventBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary vsli:raw="Set a custom attribute using a specified custom attribute blob.">Define um atributo personalizado usando um blob de atributo personalizado especificado.</summary>
      <param name="con" vsli:raw="The constructor for the custom attribute.">O construtor do atributo personalizado.</param>
      <param name="binaryAttribute" vsli:raw="A byte blob representing the attributes.">Um blob de bytes que representa os atributos.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;con&quot; /&gt; or &lt;paramref name=&quot;binaryAttribute&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="con" /> ou <paramref name="binaryAttribute" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt; has been called on the enclosing type.">O <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> foi chamado no tipo de delimitador.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EventBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary vsli:raw="Sets a custom attribute using a custom attribute builder.">Define um atributo personalizado usando um construtor de atributos personalizados.</summary>
      <param name="customBuilder" vsli:raw="An instance of a helper class to describe the custom attribute.">Uma instância de uma classe auxiliar para descrever o atributo personalizado.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;con&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="con" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt; has been called on the enclosing type.">O <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> foi chamado no tipo de delimitador.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EventBuilder.SetRaiseMethod(System.Reflection.Emit.MethodBuilder)">
      <summary vsli:raw="Sets the method used to raise this event.">Define o método usado para acionar este evento.</summary>
      <param name="mdBuilder" vsli:raw="A &lt;see langword=&quot;MethodBuilder&quot; /&gt; object that represents the method used to raise this event.">Um objeto <see langword="MethodBuilder" /> que representa o método usado para acionar este evento.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;mdBuilder&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="mdBuilder" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt; has been called on the enclosing type.">O <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> foi chamado no tipo de delimitador.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EventBuilder.SetRemoveOnMethod(System.Reflection.Emit.MethodBuilder)">
      <summary vsli:raw="Sets the method used to unsubscribe to this event.">Define o método usado para cancelar a assinatura a este evento.</summary>
      <param name="mdBuilder" vsli:raw="A &lt;see langword=&quot;MethodBuilder&quot; /&gt; object that represents the method used to unsubscribe to this event.">Um objeto <see langword="MethodBuilder" /> que representa o método usado para cancelar a assinatura a este evento.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;mdBuilder&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="mdBuilder" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt; has been called on the enclosing type.">O <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> foi chamado no tipo de delimitador.</exception>
    </member>
    <member name="T:System.Reflection.Emit.FieldBuilder">
      <summary vsli:raw="Defines and represents a field. This class cannot be inherited.">Define e representa um campo. Essa classe não pode ser herdada.</summary>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.Attributes">
      <summary vsli:raw="Indicates the attributes of this field. This property is read-only.">Indica os atributos desse campo. Esta propriedade é somente para leitura.</summary>
      <returns vsli:raw="The attributes of this field.">Os atributos deste campo.</returns>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.DeclaringType">
      <summary vsli:raw="Indicates a reference to the &lt;see cref=&quot;T:System.Type&quot; /&gt; object for the type that declares this field. This property is read-only.">Indica uma referência para o objeto <see cref="T:System.Type" /> para o tipo que declara esse membro. Esta propriedade é somente para leitura.</summary>
      <returns vsli:raw="A reference to the &lt;see cref=&quot;T:System.Type&quot; /&gt; object for the type that declares this field.">Uma referência ao <see cref="T:System.Type" /> objeto para o tipo que declara esse campo.</returns>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.FieldHandle">
      <summary vsli:raw="Indicates the internal metadata handle for this field. This property is read-only.">Indica o identificador de metadados internos para esse campo. Esta propriedade é somente para leitura.</summary>
      <returns vsli:raw="The internal metadata handle for this field.">O identificador de metadados interno para este campo.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not supported.">Não há suporte para o método.</exception>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.FieldType">
      <summary vsli:raw="Indicates the &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents the type of this field. This property is read-only.">Indica o objeto <see cref="T:System.Type" /> que representa o tipo desse campo. Esta propriedade é somente para leitura.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents the type of this field.">O <see cref="T:System.Type" /> objeto que representa o tipo desse campo.</returns>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.GetCustomAttributes(System.Boolean)">
      <summary vsli:raw="Returns all the custom attributes defined for this field.">Retorna todos os atributos personalizados definidos para esse campo.</summary>
      <param name="inherit" vsli:raw="Controls inheritance of custom attributes from base classes.">Controla a herança de atributos personalizados de classes base.</param>
      <returns vsli:raw="An array of type &lt;see cref=&quot;T:System.Object&quot; /&gt; representing all the custom attributes of the constructor represented by this &lt;see cref=&quot;T:System.Reflection.Emit.FieldBuilder&quot; /&gt; instance.">Uma matriz de tipo <see cref="T:System.Object" /> que representa todos os atributos personalizados do construtor representados por essa instância de <see cref="T:System.Reflection.Emit.FieldBuilder" />.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not supported.">Não há suporte para o método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary vsli:raw="Returns all the custom attributes defined for this field identified by the given type.">Retorna todos os atributos personalizados definidos para esse campo identificado pelo tipo fornecido.</summary>
      <param name="attributeType" vsli:raw="The custom attribute type.">O tipo de atributo personalizado.</param>
      <param name="inherit" vsli:raw="Controls inheritance of custom attributes from base classes.">Controla a herança de atributos personalizados de classes base.</param>
      <returns vsli:raw="An array of type &lt;see cref=&quot;T:System.Object&quot; /&gt; representing all the custom attributes of the constructor represented by this &lt;see cref=&quot;T:System.Reflection.Emit.FieldBuilder&quot; /&gt; instance.">Uma matriz de tipo <see cref="T:System.Object" /> que representa todos os atributos personalizados do construtor representados por essa instância de <see cref="T:System.Reflection.Emit.FieldBuilder" />.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not supported.">Não há suporte para o método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.GetValue(System.Object)">
      <summary vsli:raw="Retrieves the value of the field supported by the given object.">Recupera o valor do campo com suporte no objeto especificado.</summary>
      <param name="obj" vsli:raw="The object on which to access the field.">O objeto no qual acessar o campo.</param>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Object&quot; /&gt; containing the value of the field reflected by this instance.">Um <see cref="T:System.Object" /> que contém o valor do campo refletido por essa instância.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not supported.">Não há suporte para o método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.IsDefined(System.Type,System.Boolean)">
      <summary vsli:raw="Indicates whether an attribute having the specified type is defined on a field.">Indica se um atributo contendo o tipo especificado é definido em um campo.</summary>
      <param name="attributeType" vsli:raw="The type of the attribute.">O tipo do atributo.</param>
      <param name="inherit" vsli:raw="Controls inheritance of custom attributes from base classes.">Controla a herança de atributos personalizados de classes base.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if one or more instance of &lt;paramref name=&quot;attributeType&quot; /&gt; is defined on this field; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se uma ou mais instâncias de <paramref name="attributeType" /> estão definidas nesse campo; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported. Retrieve the field using &lt;see cref=&quot;M:System.Type.GetField(System.String,System.Reflection.BindingFlags)&quot; /&gt; and call &lt;see cref=&quot;M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)&quot; /&gt; on the returned &lt;see cref=&quot;T:System.Reflection.FieldInfo&quot; /&gt;.">Não há suporte para este método atualmente. Recuperar o campo usando <see cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" /> e chamar <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> no <see cref="T:System.Reflection.FieldInfo" /> retornado.</exception>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.Module">
      <summary vsli:raw="Gets the module in which the type that contains this field is being defined.">Obtém o módulo no qual o tipo que contém esse campo está sendo definido.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Module&quot; /&gt; that represents the dynamic module in which this field is being defined.">Um <see cref="T:System.Reflection.Module" /> que representa o módulo dinâmico no qual esse campo está sendo definido.</returns>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.Name">
      <summary vsli:raw="Indicates the name of this field. This property is read-only.">Indica o nome desse campo. Esta propriedade é somente para leitura.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.String&quot; /&gt; containing the name of this field.">Um <see cref="T:System.String" /> valor que contém o nome deste campo.</returns>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.ReflectedType">
      <summary vsli:raw="Indicates the reference to the &lt;see cref=&quot;T:System.Type&quot; /&gt; object from which this object was obtained. This property is read-only.">Indica a referência para o objeto <see cref="T:System.Type" /> do qual esse objeto foi definido. Esta propriedade é somente para leitura.</summary>
      <returns vsli:raw="A reference to the &lt;see cref=&quot;T:System.Type&quot; /&gt; object from which this instance was obtained.">Uma referência ao <see cref="T:System.Type" /> objeto do qual essa instância foi obtida.</returns>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.SetConstant(System.Object)">
      <summary vsli:raw="Sets the default value of this field.">Define o novo valor padrão desse campo.</summary>
      <param name="defaultValue" vsli:raw="The new default value for this field.">O novo valor padrão desse campo.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The containing type has been created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.">O tipo recipiente foi criado usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The field is not one of the supported types.  &#xA;  &#xA; -or-  &#xA;  &#xA; The type of &lt;paramref name=&quot;defaultValue&quot; /&gt; does not match the type of the field.  &#xA;  &#xA; -or-  &#xA;  &#xA; The field is of type &lt;see cref=&quot;T:System.Object&quot; /&gt; or other reference type, &lt;paramref name=&quot;defaultValue&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt;, and the value cannot be assigned to the reference type.">O campo não é um dos tipos com suporte.  

ou - 
O tipo de <paramref name="defaultValue" /> não coincide ao tipo do campo.  

ou - 
O campo é do tipo <see cref="T:System.Object" /> ou outro tipo de referência, <paramref name="defaultValue" /> não é <see langword="null" /> e o valor não pode ser atribuído ao tipo de referência.</exception>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary vsli:raw="Sets a custom attribute using a specified custom attribute blob.">Define um atributo personalizado usando um blob de atributo personalizado especificado.</summary>
      <param name="con" vsli:raw="The constructor for the custom attribute.">O construtor do atributo personalizado.</param>
      <param name="binaryAttribute" vsli:raw="A byte blob representing the attributes.">Um blob de bytes que representa os atributos.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;con&quot; /&gt; or &lt;paramref name=&quot;binaryAttribute&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="con" /> ou <paramref name="binaryAttribute" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The parent type of this field is complete.">O tipo pai desse campo é concluído.</exception>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary vsli:raw="Sets a custom attribute using a custom attribute builder.">Define um atributo personalizado usando um construtor de atributos personalizados.</summary>
      <param name="customBuilder" vsli:raw="An instance of a helper class to define the custom attribute.">Uma instância de uma classe auxiliar para definir o atributo personalizado.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;con&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="con" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The parent type of this field is complete.">O tipo pai desse campo é concluído.</exception>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.SetOffset(System.Int32)">
      <summary vsli:raw="Specifies the field layout.">Especifica o layout do campo.</summary>
      <param name="iOffset" vsli:raw="The offset of the field within the type containing this field.">O deslocamento do campo dentro do tipo que contém esse campo.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The containing type has been created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.">O tipo recipiente foi criado usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;iOffset&quot; /&gt; is less than zero.">
        <paramref name="iOffset" /> é menor que zero.</exception>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)">
      <summary vsli:raw="Sets the value of the field supported by the given object.">Define o valor do campo com suporte no objeto especificado.</summary>
      <param name="obj" vsli:raw="The object on which to access the field.">O objeto no qual acessar o campo.</param>
      <param name="val" vsli:raw="The value to assign to the field.">O valor a ser atribuído ao campo.</param>
      <param name="invokeAttr" vsli:raw="A member of &lt;see langword=&quot;IBinder&quot; /&gt; that specifies the type of binding that is desired (for example, IBinder.CreateInstance, IBinder.ExactBinding).">Um membro de <see langword="IBinder" /> que especifica o tipo de associação que é desejada (por exemplo, IBinder.CreateInstance, IBinder.ExactBinding).</param>
      <param name="binder" vsli:raw="A set of properties and enabling for binding, coercion of argument types, and invocation of members using reflection. If binder is null, then IBinder.DefaultBinding is used.">Um conjunto de propriedades e permissão para associação e coerção de tipos de argumento, bem como invocação de membros usando reflexão. Se binder for nulo, IBinder.DefaultBinding será usado.</param>
      <param name="culture" vsli:raw="The software preferences of a particular culture.">As preferências de software de uma determinada cultura.</param>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not supported.">Não há suporte para o método.</exception>
    </member>
    <member name="T:System.Reflection.Emit.GenericTypeParameterBuilder">
      <summary vsli:raw="Defines and creates generic type parameters for dynamically defined generic types and methods. This class cannot be inherited.">Define e cria parâmetros de tipo genérico para métodos e tipos genéricos definidos dinamicamente. Essa classe não pode ser herdada.</summary>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.Assembly">
      <summary vsli:raw="Gets an &lt;see cref=&quot;T:System.Reflection.Assembly&quot; /&gt; object representing the dynamic assembly that contains the generic type definition the current type parameter belongs to.">Obtém um objeto <see cref="T:System.Reflection.Assembly" /> que representa o assembly dinâmico que contém a definição de tipo genérico à qual o parâmetro de tipo atual pertence.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Reflection.Assembly&quot; /&gt; object representing the dynamic assembly that contains the generic type definition the current type parameter belongs to.">Um <see cref="T:System.Reflection.Assembly" /> objeto que representa o assembly dinâmico que contém a definição de tipo genérico ao qual o parâmetro de tipo atual pertence.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.AssemblyQualifiedName">
      <summary vsli:raw="Gets &lt;see langword=&quot;null&quot; /&gt; in all cases.">Obtém <see langword="null" /> em todos os casos.</summary>
      <returns vsli:raw="A null reference (&lt;see langword=&quot;Nothing&quot; /&gt; in Visual Basic) in all cases.">Uma referência nula (<see langword="Nothing" /> no Visual Basic) em todos os casos.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.BaseType">
      <summary vsli:raw="Gets the base type constraint of the current generic type parameter.">Obtém a restrição de tipo base do parâmetro de tipo genérico atual.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents the base type constraint of the generic type parameter, or &lt;see langword=&quot;null&quot; /&gt; if the type parameter has no base type constraint.">Um <see cref="T:System.Type" /> objeto que representa a restrição de tipo base do parâmetro de tipo genérico, <see langword="null" /> ou se o parâmetro de tipo não tiver nenhuma restrição de tipo base.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.ContainsGenericParameters">
      <summary vsli:raw="Gets &lt;see langword=&quot;true&quot; /&gt; in all cases.">Obtém <see langword="true" /> em todos os casos.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; in all cases.">
        <see langword="true" /> em todos os casos.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.DeclaringMethod">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the declaring method, if the current &lt;see cref=&quot;T:System.Reflection.Emit.GenericTypeParameterBuilder&quot; /&gt; represents a type parameter of a generic method.">Obtém um <see cref="T:System.Reflection.MethodInfo" /> que representa o método declarativo, se o <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> atual representa um parâmetro de tipo de um método genérico.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the declaring method, if the current &lt;see cref=&quot;T:System.Reflection.Emit.GenericTypeParameterBuilder&quot; /&gt; represents a type parameter of a generic method; otherwise, &lt;see langword=&quot;null&quot; /&gt;.">Um <see cref="T:System.Reflection.MethodInfo" /> que representa o método declarativo, se <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> o atual representa um parâmetro de tipo de um método genérico <see langword="null" />; caso contrário,.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.DeclaringType">
      <summary vsli:raw="Gets the generic type definition or generic method definition to which the generic type parameter belongs.">Obtém a definição de tipo genérico ou definição de método genérico à qual o parâmetro de tipo genérico pertence.</summary>
      <returns vsli:raw="If the type parameter belongs to a generic type, a &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing that generic type; if the type parameter belongs to a generic method, a &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing that type that declared that generic method.">Se o parâmetro de tipo pertencer a um tipo genérico <see cref="T:System.Type" /> , um objeto que representa esse tipo genérico; se o parâmetro de tipo pertencer a <see cref="T:System.Type" /> um método genérico, um objeto representando esse tipo que declarou esse método genérico.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.Equals(System.Object)">
      <summary vsli:raw="Tests whether the given object is an instance of &lt;see langword=&quot;EventToken&quot; /&gt; and is equal to the current instance.">Testa se o objeto fornecido é uma instância de <see langword="EventToken" /> e é igual à instância atual.</summary>
      <param name="o" vsli:raw="The object to be compared with the current instance.">O objeto a ser comparado com a instância atual.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;o&quot; /&gt; is an instance of &lt;see langword=&quot;EventToken&quot; /&gt; and equals the current instance; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se <paramref name="o" /> for uma instância de <see langword="EventToken" /> e igual à instância atual; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.FullName">
      <summary vsli:raw="Gets &lt;see langword=&quot;null&quot; /&gt; in all cases.">Obtém <see langword="null" /> em todos os casos.</summary>
      <returns vsli:raw="A null reference (&lt;see langword=&quot;Nothing&quot; /&gt; in Visual Basic) in all cases.">Uma referência nula (<see langword="Nothing" /> no Visual Basic) em todos os casos.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.GenericParameterAttributes">
      <summary vsli:raw="Gets a combination of &lt;see cref=&quot;T:System.Reflection.GenericParameterAttributes&quot; /&gt; flags that describe the covariance and special constraints of the current generic type parameter.">Obtém uma combinação de <see cref="T:System.Reflection.GenericParameterAttributes" /> sinalizadores que descrevem a covariância e restrições especiais do parâmetro de tipo genérico atual.</summary>
      <returns vsli:raw="A bitwise combination of values that describes the covariance and special constraints of the current generic type parameter.">Uma combinação de bits de valores que descreve a covariância e as restrições especiais do parâmetro de tipo genérico atual.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.GenericParameterPosition">
      <summary vsli:raw="Gets the position of the type parameter in the type parameter list of the generic type or method that declared the parameter.">Obtém a posição do parâmetro de tipo na lista de parâmetros de tipo do método ou tipo genérico que declarou o parâmetro.</summary>
      <returns vsli:raw="The position of the type parameter in the type parameter list of the generic type or method that declared the parameter.">A posição do parâmetro de tipo na lista de parâmetros de tipo do tipo ou método genérico que declarou o parâmetro.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetConstructors(System.Reflection.BindingFlags)">
      <summary vsli:raw="Not supported for incomplete generic type parameters.">Sem suporte para parâmetros de tipo genérico incompletos.</summary>
      <param name="bindingAttr" vsli:raw="Not supported.">Sem suporte.</param>
      <returns vsli:raw="Not supported for incomplete generic type parameters.">Sem suporte para parâmetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases.">Em todos os casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetCustomAttributes(System.Boolean)">
      <summary vsli:raw="Not supported for incomplete generic type parameters.">Sem suporte para parâmetros de tipo genérico incompletos.</summary>
      <param name="inherit" vsli:raw="Specifies whether to search this member's inheritance chain to find the attributes.">Especifica se deve-se pesquisar ou não a cadeia de herança desse membro para localizar os atributos.</param>
      <returns vsli:raw="Not supported for incomplete generic type parameters.">Sem suporte para parâmetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases.">Em todos os casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary vsli:raw="Not supported for incomplete generic type parameters.">Sem suporte para parâmetros de tipo genérico incompletos.</summary>
      <param name="attributeType" vsli:raw="The type of attribute to search for. Only attributes that are assignable to this type are returned.">O tipo de atributo a ser pesquisado. Somente os atributos que podem ser atribuídos a esse tipo são retornados.</param>
      <param name="inherit" vsli:raw="Specifies whether to search this member's inheritance chain to find the attributes.">Especifica se deve-se pesquisar ou não a cadeia de herança desse membro para localizar os atributos.</param>
      <returns vsli:raw="Not supported for incomplete generic type parameters.">Sem suporte para parâmetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases.">Em todos os casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetElementType">
      <summary vsli:raw="Throws a &lt;see cref=&quot;T:System.NotSupportedException&quot; /&gt; in all cases.">Gera um <see cref="T:System.NotSupportedException" /> em todos os casos.</summary>
      <returns vsli:raw="The type referred to by the current array type, pointer type, or &lt;see langword=&quot;ByRef&quot; /&gt; type; or &lt;see langword=&quot;null&quot; /&gt; if the current type is not an array type, is not a pointer type, and is not passed by reference.">O tipo conhecido pelo tipo de matriz atual, tipo de ponteiro ou tipo <see langword="ByRef" /> ou então <see langword="null" />, se o tipo atual não é um tipo de matriz, não é um tipo de ponteiro e não é passado por referência.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases.">Em todos os casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
      <summary vsli:raw="Not supported for incomplete generic type parameters.">Sem suporte para parâmetros de tipo genérico incompletos.</summary>
      <param name="name" vsli:raw="Not supported.">Sem suporte.</param>
      <param name="bindingAttr" vsli:raw="Not supported.">Sem suporte.</param>
      <returns vsli:raw="Not supported for incomplete generic type parameters.">Sem suporte para parâmetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases.">Em todos os casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetEvents">
      <summary vsli:raw="Not supported for incomplete generic type parameters.">Sem suporte para parâmetros de tipo genérico incompletos.</summary>
      <returns vsli:raw="Not supported for incomplete generic type parameters.">Sem suporte para parâmetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases.">Em todos os casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetEvents(System.Reflection.BindingFlags)">
      <summary vsli:raw="Not supported for incomplete generic type parameters.">Sem suporte para parâmetros de tipo genérico incompletos.</summary>
      <param name="bindingAttr" vsli:raw="Not supported.">Sem suporte.</param>
      <returns vsli:raw="Not supported for incomplete generic type parameters.">Sem suporte para parâmetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases.">Em todos os casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetField(System.String,System.Reflection.BindingFlags)">
      <summary vsli:raw="Not supported for incomplete generic type parameters.">Sem suporte para parâmetros de tipo genérico incompletos.</summary>
      <param name="name" vsli:raw="Not supported.">Sem suporte.</param>
      <param name="bindingAttr" vsli:raw="Not supported.">Sem suporte.</param>
      <returns vsli:raw="Not supported for incomplete generic type parameters.">Sem suporte para parâmetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases.">Em todos os casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetFields(System.Reflection.BindingFlags)">
      <summary vsli:raw="Not supported for incomplete generic type parameters.">Sem suporte para parâmetros de tipo genérico incompletos.</summary>
      <param name="bindingAttr" vsli:raw="Not supported.">Sem suporte.</param>
      <returns vsli:raw="Not supported for incomplete generic type parameters.">Sem suporte para parâmetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases.">Em todos os casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetGenericArguments">
      <summary vsli:raw="Not valid for generic type parameters.">Não é válido para parâmetros de tipo genérico.</summary>
      <returns vsli:raw="Not valid for generic type parameters.">Não é válido para parâmetros de tipo genérico.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="In all cases.">Em todos os casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetGenericTypeDefinition">
      <summary vsli:raw="Not valid for generic type parameters.">Não é válido para parâmetros de tipo genérico.</summary>
      <returns vsli:raw="Not valid for generic type parameters.">Não é válido para parâmetros de tipo genérico.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="In all cases.">Em todos os casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetHashCode">
      <summary vsli:raw="Returns a 32-bit integer hash code for the current instance.">Retorna um código hash de inteiro de 32 bits para a instância atual.</summary>
      <returns vsli:raw="A 32-bit integer hash code.">Um código hash de inteiro de 32 bits.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetInterface(System.String,System.Boolean)">
      <summary vsli:raw="Not supported for incomplete generic type parameters.">Sem suporte para parâmetros de tipo genérico incompletos.</summary>
      <param name="name" vsli:raw="The name of the interface.">O nome da interface.</param>
      <param name="ignoreCase" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to search without regard for case; &lt;see langword=&quot;false&quot; /&gt; to make a case-sensitive search.">
        <see langword="true" /> para pesquisar sem levar em consideração maiúsculas e minúsculas; <see langword="false" /> para fazer uma pesquisa diferenciando maiúsculas e minúsculas.</param>
      <returns vsli:raw="Not supported for incomplete generic type parameters.">Sem suporte para parâmetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases.">Em todos os casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetInterfaceMap(System.Type)">
      <summary vsli:raw="Not supported for incomplete generic type parameters.">Sem suporte para parâmetros de tipo genérico incompletos.</summary>
      <param name="interfaceType" vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents the interface type for which the mapping is to be retrieved.">Um objeto <see cref="T:System.Type" /> que representa o tipo de interface para o qual o mapeamento deve ser recuperado.</param>
      <returns vsli:raw="Not supported for incomplete generic type parameters.">Sem suporte para parâmetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases.">Em todos os casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetInterfaces">
      <summary vsli:raw="Not supported for incomplete generic type parameters.">Sem suporte para parâmetros de tipo genérico incompletos.</summary>
      <returns vsli:raw="Not supported for incomplete generic type parameters.">Sem suporte para parâmetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases.">Em todos os casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
      <summary vsli:raw="Not supported for incomplete generic type parameters.">Sem suporte para parâmetros de tipo genérico incompletos.</summary>
      <param name="name" vsli:raw="Not supported.">Sem suporte.</param>
      <param name="type" vsli:raw="Not supported.">Sem suporte.</param>
      <param name="bindingAttr" vsli:raw="Not supported.">Sem suporte.</param>
      <returns vsli:raw="Not supported for incomplete generic type parameters.">Sem suporte para parâmetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases.">Em todos os casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetMembers(System.Reflection.BindingFlags)">
      <summary vsli:raw="Not supported for incomplete generic type parameters.">Sem suporte para parâmetros de tipo genérico incompletos.</summary>
      <param name="bindingAttr" vsli:raw="Not supported.">Sem suporte.</param>
      <returns vsli:raw="Not supported for incomplete generic type parameters.">Sem suporte para parâmetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases.">Em todos os casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetMethods(System.Reflection.BindingFlags)">
      <summary vsli:raw="Not supported for incomplete generic type parameters.">Sem suporte para parâmetros de tipo genérico incompletos.</summary>
      <param name="bindingAttr" vsli:raw="Not supported.">Sem suporte.</param>
      <returns vsli:raw="Not supported for incomplete generic type parameters.">Sem suporte para parâmetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases.">Em todos os casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
      <summary vsli:raw="Not supported for incomplete generic type parameters.">Sem suporte para parâmetros de tipo genérico incompletos.</summary>
      <param name="name" vsli:raw="Not supported.">Sem suporte.</param>
      <param name="bindingAttr" vsli:raw="Not supported.">Sem suporte.</param>
      <returns vsli:raw="Not supported for incomplete generic type parameters.">Sem suporte para parâmetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases.">Em todos os casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
      <summary vsli:raw="Not supported for incomplete generic type parameters.">Sem suporte para parâmetros de tipo genérico incompletos.</summary>
      <param name="bindingAttr" vsli:raw="Not supported.">Sem suporte.</param>
      <returns vsli:raw="Not supported for incomplete generic type parameters.">Sem suporte para parâmetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases.">Em todos os casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetProperties(System.Reflection.BindingFlags)">
      <summary vsli:raw="Not supported for incomplete generic type parameters.">Sem suporte para parâmetros de tipo genérico incompletos.</summary>
      <param name="bindingAttr" vsli:raw="Not supported.">Sem suporte.</param>
      <returns vsli:raw="Not supported for incomplete generic type parameters.">Sem suporte para parâmetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases.">Em todos os casos.</exception>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.GUID">
      <summary vsli:raw="Not supported for incomplete generic type parameters.">Sem suporte para parâmetros de tipo genérico incompletos.</summary>
      <returns vsli:raw="Not supported for incomplete generic type parameters.">Sem suporte para parâmetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases.">Em todos os casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
      <summary vsli:raw="Not supported for incomplete generic type parameters.">Sem suporte para parâmetros de tipo genérico incompletos.</summary>
      <param name="name" vsli:raw="Not supported.">Sem suporte.</param>
      <param name="invokeAttr" vsli:raw="Not supported.">Sem suporte.</param>
      <param name="binder" vsli:raw="Not supported.">Sem suporte.</param>
      <param name="target" vsli:raw="Not supported.">Sem suporte.</param>
      <param name="args" vsli:raw="Not supported.">Sem suporte.</param>
      <param name="modifiers" vsli:raw="Not supported.">Sem suporte.</param>
      <param name="culture" vsli:raw="Not supported.">Sem suporte.</param>
      <param name="namedParameters" vsli:raw="Not supported.">Sem suporte.</param>
      <returns vsli:raw="Not supported for incomplete generic type parameters.">Sem suporte para parâmetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases.">Em todos os casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.IsAssignableFrom(System.Type)">
      <summary vsli:raw="Throws a &lt;see cref=&quot;T:System.NotSupportedException&quot; /&gt; exception in all cases.">Gera uma exceção <see cref="T:System.NotSupportedException" /> em todos os casos.</summary>
      <param name="c" vsli:raw="The object to test.">O objeto a ser testado.</param>
      <returns vsli:raw="Throws a &lt;see cref=&quot;T:System.NotSupportedException&quot; /&gt; exception in all cases.">Gera uma exceção <see cref="T:System.NotSupportedException" /> em todos os casos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases.">Em todos os casos.</exception>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsByRefLike" />
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsConstructedGenericType">
      <summary vsli:raw="Gets a value that indicates whether this object represents a constructed generic type.">Obtém um valor que indica se este objeto representa um tipo genérico construído.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if this object represents a constructed generic type; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se este objeto representar um tipo genérico construído; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.IsDefined(System.Type,System.Boolean)">
      <summary vsli:raw="Not supported for incomplete generic type parameters.">Sem suporte para parâmetros de tipo genérico incompletos.</summary>
      <param name="attributeType" vsli:raw="Not supported.">Sem suporte.</param>
      <param name="inherit" vsli:raw="Not supported.">Sem suporte.</param>
      <returns vsli:raw="Not supported for incomplete generic type parameters.">Sem suporte para parâmetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases.">Em todos os casos.</exception>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsGenericParameter">
      <summary vsli:raw="Gets &lt;see langword=&quot;true&quot; /&gt; in all cases.">Obtém <see langword="true" /> em todos os casos.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; in all cases.">
        <see langword="true" /> em todos os casos.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsGenericType">
      <summary vsli:raw="Returns &lt;see langword=&quot;false&quot; /&gt; in all cases.">Retorna <see langword="false" /> em todos os casos.</summary>
      <returns vsli:raw="&lt;see langword=&quot;false&quot; /&gt; in all cases.">
        <see langword="false" /> em todos os casos.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsGenericTypeDefinition">
      <summary vsli:raw="Gets &lt;see langword=&quot;false&quot; /&gt; in all cases.">Obtém <see langword="false" /> em todos os casos.</summary>
      <returns vsli:raw="&lt;see langword=&quot;false&quot; /&gt; in all cases.">
        <see langword="false" /> em todos os casos.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.IsSubclassOf(System.Type)">
      <summary vsli:raw="Not supported for incomplete generic type parameters.">Sem suporte para parâmetros de tipo genérico incompletos.</summary>
      <param name="c" vsli:raw="Not supported.">Sem suporte.</param>
      <returns vsli:raw="Not supported for incomplete generic type parameters.">Sem suporte para parâmetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases.">Em todos os casos.</exception>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsSZArray" />
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsTypeDefinition" />
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsVariableBoundArray" />
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.MakeArrayType">
      <summary vsli:raw="Returns the type of a one-dimensional array whose element type is the generic type parameter.">Retorna o tipo de uma matriz unidimensional cujo tipo de elemento é o parâmetro de tipo genérico.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents the type of a one-dimensional array whose element type is the generic type parameter.">Um objeto <see cref="T:System.Type" /> que representa o tipo de uma matriz unidimensional cujo tipo de elemento é o parâmetro de tipo genérico.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.MakeArrayType(System.Int32)">
      <summary vsli:raw="Returns the type of an array whose element type is the generic type parameter, with the specified number of dimensions.">Retorna o tipo de uma matriz cujo tipo de elemento é o parâmetro de tipo genérico, com o número de dimensões especificado.</summary>
      <param name="rank" vsli:raw="The number of dimensions for the array.">O número de dimensões da matriz.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents the type of an array whose element type is the generic type parameter, with the specified number of dimensions.">Um objeto <see cref="T:System.Type" /> que representa o tipo de uma matriz cujo tipo de elemento é o parâmetro de tipo genérico, com o número de dimensões especificado.</returns>
      <exception cref="T:System.IndexOutOfRangeException" vsli:raw="&lt;paramref name=&quot;rank&quot; /&gt; is not a valid number of dimensions. For example, its value is less than 1.">
        <paramref name="rank" /> não é um número de dimensões válido. Por exemplo, seu valor é menor que 1.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.MakeByRefType">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents the current generic type parameter when passed as a reference parameter.">Retorna um objeto <see cref="T:System.Type" /> que representa o parâmetro de tipo genérico atual quando passado como um parâmetro de referência.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents the current generic type parameter when passed as a reference parameter.">Um objeto <see cref="T:System.Type" /> que representa o parâmetro de tipo genérico atual quando passado como um parâmetro de referência.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.MakeGenericType(System.Type[])">
      <summary vsli:raw="Not valid for incomplete generic type parameters.">Não é válido para parâmetros de tipo genérico incompletos.</summary>
      <param name="typeArguments" vsli:raw="An array of type arguments.">Uma matriz de argumentos de tipo.</param>
      <returns vsli:raw="This method is invalid for incomplete generic type parameters.">Esse método é inválido para parâmetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="In all cases.">Em todos os casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.MakePointerType">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents a pointer to the current generic type parameter.">Retorna um objeto <see cref="T:System.Type" /> que representa um ponteiro para o parâmetro de tipo genérico atual.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents a pointer to the current generic type parameter.">Um objeto <see cref="T:System.Type" /> que representa um ponteiro para o parâmetro de tipo genérico atual.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.Module">
      <summary vsli:raw="Gets the dynamic module that contains the generic type parameter.">Obtém o módulo dinâmico que contém o parâmetro de tipo genérico.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Module&quot; /&gt; object that represents the dynamic module that contains the generic type parameter.">Um <see cref="T:System.Reflection.Module" /> objeto que representa o módulo dinâmico que contém o parâmetro de tipo genérico.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.Name">
      <summary vsli:raw="Gets the name of the generic type parameter.">Obtém o nome do parâmetro de tipo genérico.</summary>
      <returns vsli:raw="The name of the generic type parameter.">O nome do parâmetro de tipo genérico.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.Namespace">
      <summary vsli:raw="Gets &lt;see langword=&quot;null&quot; /&gt; in all cases.">Obtém <see langword="null" /> em todos os casos.</summary>
      <returns vsli:raw="A null reference (&lt;see langword=&quot;Nothing&quot; /&gt; in Visual Basic) in all cases.">Uma referência nula (<see langword="Nothing" /> no Visual Basic) em todos os casos.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.ReflectedType">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Type&quot; /&gt; object that was used to obtain the &lt;see cref=&quot;T:System.Reflection.Emit.GenericTypeParameterBuilder&quot; /&gt;.">Obtém o objeto <see cref="T:System.Type" /> que foi usado para obter o <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object that was used to obtain the &lt;see cref=&quot;T:System.Reflection.Emit.GenericTypeParameterBuilder&quot; /&gt;.">O <see cref="T:System.Type" /> objeto que foi usado para obter o <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.SetBaseTypeConstraint(System.Type)">
      <summary vsli:raw="Sets the base type that a type must inherit in order to be substituted for the type parameter.">Define o tipo base que um tipo deve herdar para ser substituído pelo parâmetro de tipo.</summary>
      <param name="baseTypeConstraint" vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; that must be inherited by any type that is to be substituted for the type parameter.">O <see cref="T:System.Type" /> que deve ser herdado por qualquer tipo que deve ser substituído pelo parâmetro de tipo.</param>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary vsli:raw="Sets a custom attribute using a specified custom attribute blob.">Define um atributo personalizado usando um blob de atributo personalizado especificado.</summary>
      <param name="con" vsli:raw="The constructor for the custom attribute.">O construtor do atributo personalizado.</param>
      <param name="binaryAttribute" vsli:raw="A byte blob representing the attribute.">Um blob de byte que representa o atributo.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;con&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;binaryAttribute&quot; /&gt; is a null reference.">
        <paramref name="con" /> é <see langword="null" />.  

ou - 
<paramref name="binaryAttribute" /> é uma referência nula.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary vsli:raw="Set a custom attribute using a custom attribute builder.">Defina um atributo personalizado usando um construtor de atributos personalizados.</summary>
      <param name="customBuilder" vsli:raw="An instance of a helper class that defines the custom attribute.">Uma instância de uma classe auxiliar que define o atributo personalizado.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;customBuilder&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="customBuilder" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes(System.Reflection.GenericParameterAttributes)">
      <summary vsli:raw="Sets the variance characteristics and special constraints of the generic parameter, such as the parameterless constructor constraint.">Define as características de variação e restrições especiais do parâmetro genérico, tais como a restrição de construtor sem parâmetros.</summary>
      <param name="genericParameterAttributes" vsli:raw="A bitwise combination of &lt;see cref=&quot;T:System.Reflection.GenericParameterAttributes&quot; /&gt; values that represent the variance characteristics and special constraints of the generic type parameter.">Uma combinação bit a bit de valores <see cref="T:System.Reflection.GenericParameterAttributes" /> que representam as características de variação e restrições especiais do parâmetro de tipo genérico.</param>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.SetInterfaceConstraints(System.Type[])">
      <summary vsli:raw="Sets the interfaces a type must implement in order to be substituted for the type parameter.">Define as interfaces que um tipo deve implementar para ser substituído pelo parâmetro de tipo.</summary>
      <param name="interfaceConstraints" vsli:raw="An array of &lt;see cref=&quot;T:System.Type&quot; /&gt; objects that represent the interfaces a type must implement in order to be substituted for the type parameter.">Uma matriz de objetos <see cref="T:System.Type" /> que representam as interfaces que um tipo deve implementar para ser substituído pelo parâmetro de tipo.</param>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.ToString">
      <summary vsli:raw="Returns a string representation of the current generic type parameter.">Retorna uma representação de cadeia de caracteres do parâmetro de tipo genérico atual.</summary>
      <returns vsli:raw="A string that contains the name of the generic type parameter.">Uma cadeia de caracteres que contém o nome do parâmetro de tipo genérico.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.TypeHandle">
      <summary vsli:raw="Not supported for incomplete generic type parameters.">Sem suporte para parâmetros de tipo genérico incompletos.</summary>
      <returns vsli:raw="Not supported for incomplete generic type parameters.">Sem suporte para parâmetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases.">Em todos os casos.</exception>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.UnderlyingSystemType">
      <summary vsli:raw="Gets the current generic type parameter.">Obtém o parâmetro de tipo genérico atual.</summary>
      <returns vsli:raw="The current &lt;see cref=&quot;T:System.Reflection.Emit.GenericTypeParameterBuilder&quot; /&gt; object.">O objeto <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> atual.</returns>
    </member>
    <member name="T:System.Reflection.Emit.MethodBuilder">
      <summary vsli:raw="Defines and represents a method (or constructor) on a dynamic class.">Define e representa um método (ou construtor) em uma classe dinâmica.</summary>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.Attributes">
      <summary vsli:raw="Retrieves the attributes for this method.">Recupera os atributos para este método.</summary>
      <returns vsli:raw="Read-only. Retrieves the &lt;see langword=&quot;MethodAttributes&quot; /&gt; for this method.">Somente leitura. Recupera o <see langword="MethodAttributes" /> para este método.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.CallingConvention">
      <summary vsli:raw="Returns the calling convention of the method.">Retorna a convenção de chamada do método.</summary>
      <returns vsli:raw="Read-only. The calling convention of the method.">Somente leitura. A convenção de chamada do método.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.ContainsGenericParameters">
      <summary vsli:raw="Not supported for this type.">Não tem suporte para esse tipo.</summary>
      <returns vsli:raw="Not supported.">Sem suporte.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="The invoked method is not supported in the base class.">O método chamado não é suportado na classe base.</exception>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.DeclaringType">
      <summary vsli:raw="Returns the type that declares this method.">Retorna o tipo que declara a este método.</summary>
      <returns vsli:raw="Read-only. The type that declares this method.">Somente leitura. O tipo que declara esse método.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
      <summary vsli:raw="Sets the number of generic type parameters for the current method, specifies their names, and returns an array of &lt;see cref=&quot;T:System.Reflection.Emit.GenericTypeParameterBuilder&quot; /&gt; objects that can be used to define their constraints.">Define o número de parâmetros de tipo genérico para o método atual, especifica seus nomes e retorna uma matriz de objetos <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> que pode ser usada para definir suas restrições.</summary>
      <param name="names" vsli:raw="An array of strings that represent the names of the generic type parameters.">Uma matriz de cadeias de caracteres que representa os nomes dos parâmetros de tipo genérico.</param>
      <returns vsli:raw="An array of &lt;see cref=&quot;T:System.Reflection.Emit.GenericTypeParameterBuilder&quot; /&gt; objects representing the type parameters of the generic method.">Uma matriz de objetos <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> que representam os parâmetros de tipo do método genérico.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Generic type parameters have already been defined for this method.  &#xA;  &#xA; -or-  &#xA;  &#xA; The method has been completed already.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)&quot; /&gt; method has been called for the current method.">Parâmetros de tipo genérico já foram definidos para este método.  

ou - 
O método já foi concluído.  

ou - 
O método <see cref="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)" /> foi chamado para o método atual.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;names&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; An element of &lt;paramref name=&quot;names&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="names" /> é <see langword="null" />.  

ou - 
Um elemento de <paramref name="names" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;names&quot; /&gt; is an empty array.">
        <paramref name="names" /> é uma matriz vazia.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
      <summary vsli:raw="Sets the parameter attributes and the name of a parameter of this method, or of the return value of this method. Returns a ParameterBuilder that can be used to apply custom attributes.">Define os atributos de parâmetro e o nome de um parâmetro deste método, ou do valor retornado deste método. Retorna um ParameterBuilder que pode ser usado para aplicar os atributos personalizados.</summary>
      <param name="position" vsli:raw="The position of the parameter in the parameter list. Parameters are indexed beginning with the number 1 for the first parameter; the number 0 represents the return value of the method.">A posição do parâmetro na lista de parâmetros. Parâmetros são indexados começando com o número 1 para o primeiro parâmetro; o número 0 representa o valor retornado do método.</param>
      <param name="attributes" vsli:raw="The parameter attributes of the parameter.">Os atributos de parâmetro do parâmetro.</param>
      <param name="strParamName" vsli:raw="The name of the parameter. The name can be the null string.">O nome do parâmetro. O nome pode ser a cadeia de caracteres nula.</param>
      <returns vsli:raw="Returns a &lt;see langword=&quot;ParameterBuilder&quot; /&gt; object that represents a parameter of this method or the return value of this method.">Retorna um objeto <see langword="ParameterBuilder" /> que representa um parâmetro deste método ou o valor retornado deste método.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The method has no parameters.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;position&quot; /&gt; is less than zero.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;position&quot; /&gt; is greater than the number of the method's parameters.">O método não tem parâmetros.  

ou - 
<paramref name="position" /> é menor que zero.  

ou - 
<paramref name="position" /> é maior que o número de parâmetros do método.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The containing type was previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; For the current method, the &lt;see cref=&quot;P:System.Reflection.Emit.MethodBuilder.IsGenericMethod&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;, but the &lt;see cref=&quot;P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition&quot; /&gt; property is &lt;see langword=&quot;false&quot; /&gt;.">O tipo recipiente foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  

ou - 
Para o método atual, a propriedade <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> é <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.Equals(System.Object)">
      <summary vsli:raw="Determines whether the given object is equal to this instance.">Determina se o objeto especificado é igual a esta instância.</summary>
      <param name="obj" vsli:raw="The object to compare with this &lt;see langword=&quot;MethodBuilder&quot; /&gt; instance.">O objeto a ser comparado com essa instância <see langword="MethodBuilder" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;obj&quot; /&gt; is an instance of &lt;see langword=&quot;MethodBuilder&quot; /&gt; and is equal to this object; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se <paramref name="obj" /> for uma instância de <see langword="MethodBuilder" /> e for igual a este objeto; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetBaseDefinition">
      <summary vsli:raw="Return the base implementation for a method.">Retorna a implementação de base para um método.</summary>
      <returns vsli:raw="The base implementation of this method.">A implementação de base deste método.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Boolean)">
      <summary vsli:raw="Returns all the custom attributes defined for this method.">Retorna todos os atributos personalizados definidos para esse método.</summary>
      <param name="inherit" vsli:raw="Specifies whether to search this member's inheritance chain to find the custom attributes.">Especifica se deve-se pesquisar na cadeia de herança deste membro para localizar os atributos personalizados.</param>
      <returns vsli:raw="Returns an array of objects representing all the custom attributes of this method.">Retorna uma matriz de objetos que representam todos os atributos personalizados desse método.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported. Retrieve the method using &lt;see cref=&quot;M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])&quot; /&gt; and call &lt;see cref=&quot;M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)&quot; /&gt; on the returned &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt;.">Não há suporte para este método atualmente. Recupere o método usando <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> e chame <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> no <see cref="T:System.Reflection.MethodInfo" /> retornado.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary vsli:raw="Returns the custom attributes identified by the given type.">Retorna os atributos personalizados identificados pelo tipo determinado.</summary>
      <param name="attributeType" vsli:raw="The custom attribute type.">O tipo de atributo personalizado.</param>
      <param name="inherit" vsli:raw="Specifies whether to search this member's inheritance chain to find the custom attributes.">Especifica se deve-se pesquisar na cadeia de herança deste membro para localizar os atributos personalizados.</param>
      <returns vsli:raw="Returns an array of objects representing the attributes of this method that are of type &lt;paramref name=&quot;attributeType&quot; /&gt;.">Retorna uma matriz de objetos que representam os atributos desse método que são do tipo <paramref name="attributeType" />.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported. Retrieve the method using &lt;see cref=&quot;M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])&quot; /&gt; and call &lt;see cref=&quot;M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)&quot; /&gt; on the returned &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt;.">Não há suporte para este método atualmente. Recupere o método usando <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> e chame <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> no <see cref="T:System.Reflection.MethodInfo" /> retornado.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetGenericArguments">
      <summary vsli:raw="Returns an array of &lt;see cref=&quot;T:System.Reflection.Emit.GenericTypeParameterBuilder&quot; /&gt; objects that represent the type parameters of the method, if it is generic.">Retorna uma matriz de objetos <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> que representam os parâmetros de tipo do método, se for genérico.</summary>
      <returns vsli:raw="An array of &lt;see cref=&quot;T:System.Reflection.Emit.GenericTypeParameterBuilder&quot; /&gt; objects representing the type parameters, if the method is generic, or &lt;see langword=&quot;null&quot; /&gt; if the method is not generic.">Uma matriz de objetos <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> que representam os parâmetros de tipo, se o método for genérico ou <see langword="null" />, se o método não for genérico.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition">
      <summary vsli:raw="Returns this method.">Retorna este método.</summary>
      <returns vsli:raw="The current instance of &lt;see cref=&quot;T:System.Reflection.Emit.MethodBuilder&quot; /&gt;.">A instância atual do <see cref="T:System.Reflection.Emit.MethodBuilder" />.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The current method is not generic. That is, the &lt;see cref=&quot;P:System.Reflection.Emit.MethodBuilder.IsGenericMethod&quot; /&gt; property returns &lt;see langword=&quot;false&quot; /&gt;.">O método atual não é genérico. Ou seja, a propriedade <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> do método retorna <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetHashCode">
      <summary vsli:raw="Gets the hash code for this method.">Obtém o código hash para este método.</summary>
      <returns vsli:raw="The hash code for this method.">O código hash para este método.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetILGenerator">
      <summary vsli:raw="Returns an &lt;see langword=&quot;ILGenerator&quot; /&gt; for this method with a default Microsoft intermediate language (MSIL) stream size of 64 bytes.">Retorna um <see langword="ILGenerator" /> para esse método com um tamanho de fluxo MSIL (linguagem intermediária da Microsoft) padrão de 64 bytes.</summary>
      <returns vsli:raw="Returns an &lt;see langword=&quot;ILGenerator&quot; /&gt; object for this method.">Retorna um objeto <see langword="ILGenerator" /> para este método.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method should not have a body because of its &lt;see cref=&quot;T:System.Reflection.MethodAttributes&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.MethodImplAttributes&quot; /&gt; flags, for example because it has the &lt;see cref=&quot;F:System.Reflection.MethodAttributes.PinvokeImpl&quot; /&gt; flag.  &#xA;  &#xA; -or-  &#xA;  &#xA; The method is a generic method, but not a generic method definition. That is, the &lt;see cref=&quot;P:System.Reflection.Emit.MethodBuilder.IsGenericMethod&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;, but the &lt;see cref=&quot;P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition&quot; /&gt; property is &lt;see langword=&quot;false&quot; /&gt;.">O método não deve ter um corpo devido aos seus sinalizadores <see cref="T:System.Reflection.MethodAttributes" /> ou <see cref="T:System.Reflection.MethodImplAttributes" />, por exemplo, porque ele tem o sinalizador <see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" />.  

ou - 
O método é genérico, mas não é uma definição de método genérico. Ou seja, a propriedade <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> é <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetILGenerator(System.Int32)">
      <summary vsli:raw="Returns an &lt;see langword=&quot;ILGenerator&quot; /&gt; for this method with the specified Microsoft intermediate language (MSIL) stream size.">Retorna um <see langword="ILGenerator" /> pra esse método com o tamanho de fluxo MSIL (linguagem intermediária da Microsoft) especificado.</summary>
      <param name="size" vsli:raw="The size of the MSIL stream, in bytes.">O tamanho do fluxo MSIL, em bytes.</param>
      <returns vsli:raw="Returns an &lt;see langword=&quot;ILGenerator&quot; /&gt; object for this method.">Retorna um objeto <see langword="ILGenerator" /> para este método.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method should not have a body because of its &lt;see cref=&quot;T:System.Reflection.MethodAttributes&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.MethodImplAttributes&quot; /&gt; flags, for example because it has the &lt;see cref=&quot;F:System.Reflection.MethodAttributes.PinvokeImpl&quot; /&gt; flag.  &#xA;  &#xA; -or-  &#xA;  &#xA; The method is a generic method, but not a generic method definition. That is, the &lt;see cref=&quot;P:System.Reflection.Emit.MethodBuilder.IsGenericMethod&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;, but the &lt;see cref=&quot;P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition&quot; /&gt; property is &lt;see langword=&quot;false&quot; /&gt;.">O método não deve ter um corpo devido aos seus sinalizadores <see cref="T:System.Reflection.MethodAttributes" /> ou <see cref="T:System.Reflection.MethodImplAttributes" />, por exemplo, porque ele tem o sinalizador <see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" />.  

ou - 
O método é genérico, mas não é uma definição de método genérico. Ou seja, a propriedade <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> é <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags">
      <summary vsli:raw="Returns the implementation flags for the method.">Retorna os sinalizadores de implementação para o método.</summary>
      <returns vsli:raw="Returns the implementation flags for the method.">Retorna os sinalizadores de implementação para o método.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetParameters">
      <summary vsli:raw="Returns the parameters of this method.">Retorna os parâmetros deste método.</summary>
      <returns vsli:raw="An array of &lt;see langword=&quot;ParameterInfo&quot; /&gt; objects that represent the parameters of the method.">Uma matriz de objetos <see langword="ParameterInfo" /> que representam os parâmetros do método.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported. Retrieve the method using &lt;see cref=&quot;M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])&quot; /&gt; and call &lt;see langword=&quot;GetParameters&quot; /&gt; on the returned &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt;.">Não há suporte para este método atualmente. Recupere o método usando <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> e chame <see langword="GetParameters" /> no <see cref="T:System.Reflection.MethodInfo" /> retornado.</exception>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.InitLocals">
      <summary vsli:raw="Gets or sets a Boolean value that specifies whether the local variables in this method are zero initialized. The default value of this property is &lt;see langword=&quot;true&quot; /&gt;.">Obtém ou define um valor booliano que especifica se as variáveis locais nesse método são inicializadas em zero. O valor padrão dessa propriedade é <see langword="true" />.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the local variables in this method should be zero initialized; otherwise &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />Se as variáveis locais nesse método devem ser inicializadas com zero; caso <see langword="false" />contrário.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="For the current method, the &lt;see cref=&quot;P:System.Reflection.Emit.MethodBuilder.IsGenericMethod&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;, but the &lt;see cref=&quot;P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition&quot; /&gt; property is &lt;see langword=&quot;false&quot; /&gt;. (Get or set.)">Para o método atual, a propriedade <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> é <see langword="false" />. (Get ou set.)</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
      <summary vsli:raw="Dynamically invokes the method reflected by this instance on the given object, passing along the specified parameters, and under the constraints of the given binder.">Invoca dinamicamente o método refletido por esta instância no objeto fornecido, passando os parâmetros especificados e sob as restrições do associador determinado.</summary>
      <param name="obj" vsli:raw="The object on which to invoke the specified method. If the method is static, this parameter is ignored.">O objeto no qual invocar o método especificado. Se o método for estático, esse parâmetro será ignorado.</param>
      <param name="invokeAttr" vsli:raw="This must be a bit flag from &lt;see cref=&quot;T:System.Reflection.BindingFlags&quot; /&gt; : &lt;see langword=&quot;InvokeMethod&quot; /&gt;, &lt;see langword=&quot;NonPublic&quot; /&gt;, and so on.">Isso deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" /> e assim por diante.</param>
      <param name="binder" vsli:raw="An object that enables the binding, coercion of argument types, invocation of members, and retrieval of MemberInfo objects via reflection. If binder is &lt;see langword=&quot;null&quot; /&gt;, the default binder is used. For more details, see &lt;see cref=&quot;T:System.Reflection.Binder&quot; /&gt;.">Um objeto que permite a associação, a coerção de tipos de argumentos, a invocação de membros e a recuperação de objetos MemberInfo por meio de reflexão. Se o associador for <see langword="null" />, o associador padrão será usado. Para obter mais detalhes, consulte <see cref="T:System.Reflection.Binder" />.</param>
      <param name="parameters" vsli:raw="An argument list. This is an array of arguments with the same number, order, and type as the parameters of the method to be invoked. If there are no parameters this should be &lt;see langword=&quot;null&quot; /&gt;.">Uma lista de argumentos. Essa é uma matriz de argumentos com o mesmo número, ordem e tipo que os parâmetros do método a ser invocado. Se não houver nenhum parâmetro, isso deverá ser <see langword="null" />.</param>
      <param name="culture" vsli:raw="An instance of &lt;see cref=&quot;T:System.Globalization.CultureInfo&quot; /&gt; used to govern the coercion of types. If this is null, the &lt;see cref=&quot;T:System.Globalization.CultureInfo&quot; /&gt; for the current thread is used. (Note that this is necessary to, for example, convert a &lt;see cref=&quot;T:System.String&quot; /&gt; that represents 1000 to a &lt;see cref=&quot;T:System.Double&quot; /&gt; value, since 1000 is represented differently by different cultures.)">Uma instância de <see cref="T:System.Globalization.CultureInfo" /> usada para determinar a coerção de tipos. Se isso for nulo, será usado o <see cref="T:System.Globalization.CultureInfo" /> do thread atual. (Observe que isso é necessário para, por exemplo, converter um <see cref="T:System.String" /> que represente 1000 para um valor <see cref="T:System.Double" />, desde que 1000 seja representado de maneira diferente por diferentes culturas.)</param>
      <returns vsli:raw="Returns an object containing the return value of the invoked method.">Retorna um objeto que contém o valor retornado do método invocado.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported. Retrieve the method using &lt;see cref=&quot;M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])&quot; /&gt; and call &lt;see cref=&quot;M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])&quot; /&gt; on the returned &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt;.">Não há suporte para este método atualmente. Recupere o método usando <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> e chame <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> no <see cref="T:System.Reflection.MethodInfo" /> retornado.</exception>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.IsConstructedGenericMethod" />
    <member name="M:System.Reflection.Emit.MethodBuilder.IsDefined(System.Type,System.Boolean)">
      <summary vsli:raw="Checks if the specified custom attribute type is defined.">Verifica se o tipo de atributo personalizado especificado é definido.</summary>
      <param name="attributeType" vsli:raw="The custom attribute type.">O tipo de atributo personalizado.</param>
      <param name="inherit" vsli:raw="Specifies whether to search this member's inheritance chain to find the custom attributes.">Especifica se deve-se pesquisar na cadeia de herança deste membro para localizar os atributos personalizados.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the specified custom attribute type is defined; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o tipo de atributo personalizado especificado estiver definido, caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported. Retrieve the method using &lt;see cref=&quot;M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])&quot; /&gt; and call &lt;see cref=&quot;M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)&quot; /&gt; on the returned &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt;.">Não há suporte para este método atualmente. Recupere o método usando <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> e chame <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> no <see cref="T:System.Reflection.MethodInfo" /> retornado.</exception>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod">
      <summary vsli:raw="Gets a value indicating whether the method is a generic method.">Obtém um valor que indica se o método é um método genérico.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the method is generic; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />Se o método for genérico; caso contrário <see langword="false" />,.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition">
      <summary vsli:raw="Gets a value indicating whether the current &lt;see cref=&quot;T:System.Reflection.Emit.MethodBuilder&quot; /&gt; object represents the definition of a generic method.">Obtém um valor que indica se o objeto <see cref="T:System.Reflection.Emit.MethodBuilder" /> atual representa a definição de um método genérico.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current &lt;see cref=&quot;T:System.Reflection.Emit.MethodBuilder&quot; /&gt; object represents the definition of a generic method; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />Se o objeto <see cref="T:System.Reflection.Emit.MethodBuilder" /> atual representar a definição de um método genérico; caso contrário <see langword="false" />,.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.IsSecurityCritical">
      <summary vsli:raw="Throws a &lt;see cref=&quot;T:System.NotSupportedException&quot; /&gt; in all cases.">Gera um <see cref="T:System.NotSupportedException" /> em todos os casos.</summary>
      <returns vsli:raw="Throws a &lt;see cref=&quot;T:System.NotSupportedException&quot; /&gt; in all cases.">Gera um <see cref="T:System.NotSupportedException" /> em todos os casos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases. This property is not supported in dynamic assemblies.">Em todos os casos. Não há suporte para essa propriedade em assemblies dinâmicos.</exception>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.IsSecuritySafeCritical">
      <summary vsli:raw="Throws a &lt;see cref=&quot;T:System.NotSupportedException&quot; /&gt; in all cases.">Gera um <see cref="T:System.NotSupportedException" /> em todos os casos.</summary>
      <returns vsli:raw="Throws a &lt;see cref=&quot;T:System.NotSupportedException&quot; /&gt; in all cases.">Gera um <see cref="T:System.NotSupportedException" /> em todos os casos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases. This property is not supported in dynamic assemblies.">Em todos os casos. Não há suporte para essa propriedade em assemblies dinâmicos.</exception>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.IsSecurityTransparent">
      <summary vsli:raw="Throws a &lt;see cref=&quot;T:System.NotSupportedException&quot; /&gt; in all cases.">Gera um <see cref="T:System.NotSupportedException" /> em todos os casos.</summary>
      <returns vsli:raw="Throws a &lt;see cref=&quot;T:System.NotSupportedException&quot; /&gt; in all cases.">Gera um <see cref="T:System.NotSupportedException" /> em todos os casos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases. This property is not supported in dynamic assemblies.">Em todos os casos. Não há suporte para essa propriedade em assemblies dinâmicos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
      <summary vsli:raw="Returns a generic method constructed from the current generic method definition using the specified generic type arguments.">Retorna um método genérico construído da definição de método genérico atual usando os argumentos de tipo genérico especificados.</summary>
      <param name="typeArguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Type&quot; /&gt; objects that represent the type arguments for the generic method.">Uma matriz de objetos <see cref="T:System.Type" /> que representam os argumentos de tipo para o método genérico.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; representing the generic method constructed from the current generic method definition using the specified generic type arguments.">Um <see cref="T:System.Reflection.MethodInfo" /> que representa o método genérico construído com base na definição de método genérico atual usando os argumentos de tipo genérico especificados.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.MethodHandle">
      <summary vsli:raw="Retrieves the internal handle for the method. Use this handle to access the underlying metadata handle.">Recupera o identificador interno para o método. Use esse identificador para acessar o identificador de metadados subjacente.</summary>
      <returns vsli:raw="Read-only. The internal handle for the method. Use this handle to access the underlying metadata handle.">Somente leitura. O identificador interno do método. Use esse identificador para acessar o identificador de metadados subjacente.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported. Retrieve the method using &lt;see cref=&quot;M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])&quot; /&gt; and call &lt;see cref=&quot;P:System.Reflection.MethodBase.MethodHandle&quot; /&gt; on the returned &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt;.">Não há suporte para este método atualmente. Recupere o método usando <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> e chame <see cref="P:System.Reflection.MethodBase.MethodHandle" /> no <see cref="T:System.Reflection.MethodInfo" /> retornado.</exception>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.Module">
      <summary vsli:raw="Gets the module in which the current method is being defined.">Obtém o módulo no qual o método atual está sendo definido.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Reflection.Module&quot; /&gt; in which the member represented by the current &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; is being defined.">O <see cref="T:System.Reflection.Module" /> no qual o membro representado pelo atual <see cref="T:System.Reflection.MemberInfo" /> está sendo definido.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.Name">
      <summary vsli:raw="Retrieves the name of this method.">Recupera o nome desse método.</summary>
      <returns vsli:raw="Read-only. Retrieves a string containing the simple name of this method.">Somente leitura. Recupera uma cadeia de caracteres que contém o nome simples desse método.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.ReflectedType">
      <summary vsli:raw="Retrieves the class that was used in reflection to obtain this object.">Recupera a classe que foi usada em reflexão para obter esse objeto.</summary>
      <returns vsli:raw="Read-only. The type used to obtain this method.">Somente leitura. O tipo usado para obter esse método.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.ReturnParameter">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Reflection.ParameterInfo&quot; /&gt; object that contains information about the return type of the method, such as whether the return type has custom modifiers.">Obtém um objeto <see cref="T:System.Reflection.ParameterInfo" /> que contém informações sobre o tipo de retorno do método, como se o tipo de retorno tem modificadores personalizados.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.ParameterInfo&quot; /&gt; object that contains information about the return type.">Um objeto <see cref="T:System.Reflection.ParameterInfo" /> que contém informações sobre o tipo de retorno.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The declaring type has not been created.">O tipo de declaração não foi criado.</exception>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.ReturnType">
      <summary vsli:raw="Gets the return type of the method represented by this &lt;see cref=&quot;T:System.Reflection.Emit.MethodBuilder&quot; /&gt;.">Obtém o tipo de retorno do método representado por esse <see cref="T:System.Reflection.Emit.MethodBuilder" />.</summary>
      <returns vsli:raw="The return type of the method.">O tipo de retorno do método.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.ReturnTypeCustomAttributes">
      <summary vsli:raw="Returns the custom attributes of the method's return type.">Retorna os atributos personalizados do tipo de retorno do método.</summary>
      <returns vsli:raw="Read-only. The custom attributes of the method's return type.">Somente leitura. Os atributos personalizados do tipo de retorno do método.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary vsli:raw="Sets a custom attribute using a specified custom attribute blob.">Define um atributo personalizado usando um blob de atributo personalizado especificado.</summary>
      <param name="con" vsli:raw="The constructor for the custom attribute.">O construtor do atributo personalizado.</param>
      <param name="binaryAttribute" vsli:raw="A byte blob representing the attributes.">Um blob de bytes que representa os atributos.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;con&quot; /&gt; or &lt;paramref name=&quot;binaryAttribute&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="con" /> ou <paramref name="binaryAttribute" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="For the current method, the &lt;see cref=&quot;P:System.Reflection.Emit.MethodBuilder.IsGenericMethod&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;, but the &lt;see cref=&quot;P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition&quot; /&gt; property is &lt;see langword=&quot;false&quot; /&gt;.">Para o método atual, a propriedade <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> é <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary vsli:raw="Sets a custom attribute using a custom attribute builder.">Define um atributo personalizado usando um construtor de atributos personalizados.</summary>
      <param name="customBuilder" vsli:raw="An instance of a helper class to describe the custom attribute.">Uma instância de uma classe auxiliar para descrever o atributo personalizado.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;customBuilder&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="customBuilder" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="For the current method, the &lt;see cref=&quot;P:System.Reflection.Emit.MethodBuilder.IsGenericMethod&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;, but the &lt;see cref=&quot;P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition&quot; /&gt; property is &lt;see langword=&quot;false&quot; /&gt;.">Para o método atual, a propriedade <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> é <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
      <summary vsli:raw="Sets the implementation flags for this method.">Define os sinalizadores de implementação para este método.</summary>
      <param name="attributes" vsli:raw="The implementation flags to set.">Os sinalizadores de implementação a definir.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The containing type was previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; For the current method, the &lt;see cref=&quot;P:System.Reflection.Emit.MethodBuilder.IsGenericMethod&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;, but the &lt;see cref=&quot;P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition&quot; /&gt; property is &lt;see langword=&quot;false&quot; /&gt;.">O tipo recipiente foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  

ou - 
Para o método atual, a propriedade <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> é <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
      <summary vsli:raw="Sets the number and types of parameters for a method.">Define o número e tipos de parâmetros para um método.</summary>
      <param name="parameterTypes" vsli:raw="An array of &lt;see cref=&quot;T:System.Type&quot; /&gt; objects representing the parameter types.">Uma matriz de objetos <see cref="T:System.Type" /> que representam os tipos de parâmetro.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The current method is generic, but is not a generic method definition. That is, the &lt;see cref=&quot;P:System.Reflection.Emit.MethodBuilder.IsGenericMethod&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;, but the &lt;see cref=&quot;P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition&quot; /&gt; property is &lt;see langword=&quot;false&quot; /&gt;.">O método atual é genérico, mas não é uma definição de método genérico. Ou seja, a propriedade <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> é <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
      <summary vsli:raw="Sets the return type of the method.">Define o tipo retornado do método.</summary>
      <param name="returnType" vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents the return type of the method.">Um objeto <see cref="T:System.Type" /> que representa o tipo de retorno do método.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The current method is generic, but is not a generic method definition. That is, the &lt;see cref=&quot;P:System.Reflection.Emit.MethodBuilder.IsGenericMethod&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;, but the &lt;see cref=&quot;P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition&quot; /&gt; property is &lt;see langword=&quot;false&quot; /&gt;.">O método atual é genérico, mas não é uma definição de método genérico. Ou seja, a propriedade <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> é <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
      <summary vsli:raw="Sets the method signature, including the return type, the parameter types, and the required and optional custom modifiers of the return type and parameter types.">Define a assinatura do método, incluindo o tipo retornado, os tipos de parâmetro e os modificadores personalizados obrigatórios e opcionais do tipo retornado e dos tipos de parâmetro.</summary>
      <param name="returnType" vsli:raw="The return type of the method.">O tipo de retorno do método.</param>
      <param name="returnTypeRequiredCustomModifiers" vsli:raw="An array of types representing the required custom modifiers, such as &lt;see cref=&quot;T:System.Runtime.CompilerServices.IsConst&quot; /&gt;, for the return type of the method. If the return type has no required custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt;.">Uma matriz de tipos que representam os modificadores personalizados obrigatórios, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />, para o tipo de retorno do método. Se o tipo de retorno não tiver modificadores personalizados obrigatórios, especifique <see langword="null" />.</param>
      <param name="returnTypeOptionalCustomModifiers" vsli:raw="An array of types representing the optional custom modifiers, such as &lt;see cref=&quot;T:System.Runtime.CompilerServices.IsConst&quot; /&gt;, for the return type of the method. If the return type has no optional custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt;.">Uma matriz de tipos que representam os modificadores personalizados opcionais, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />, para o tipo de retorno do método. Se o tipo de retorno não tiver modificadores personalizados opcionais, especifique <see langword="null" />.</param>
      <param name="parameterTypes" vsli:raw="The types of the parameters of the method.">Os tipos dos parâmetros do método.</param>
      <param name="parameterTypeRequiredCustomModifiers" vsli:raw="An array of arrays of types. Each array of types represents the required custom modifiers for the corresponding parameter, such as &lt;see cref=&quot;T:System.Runtime.CompilerServices.IsConst&quot; /&gt;. If a particular parameter has no required custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt; instead of an array of types. If none of the parameters have required custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt; instead of an array of arrays.">Uma matriz de matrizes de tipos. Cada matriz de tipos representa os modificadores personalizados obrigatórios para o parâmetro correspondente, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />. Se um determinado parâmetro tiver não modificadores personalizados obrigatórios, especifique <see langword="null" /> em vez de uma matriz de tipos. Se nenhum dos parâmetros tiver modificadores personalizados obrigatórios, especifique <see langword="null" /> em vez de uma matriz de matrizes.</param>
      <param name="parameterTypeOptionalCustomModifiers" vsli:raw="An array of arrays of types. Each array of types represents the optional custom modifiers for the corresponding parameter, such as &lt;see cref=&quot;T:System.Runtime.CompilerServices.IsConst&quot; /&gt;. If a particular parameter has no optional custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt; instead of an array of types. If none of the parameters have optional custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt; instead of an array of arrays.">Uma matriz de matrizes de tipos. Cada matriz de tipos representa os modificadores personalizados opcionais para o parâmetro correspondente, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />. Se um determinado parâmetro tiver não modificadores personalizados opcionais, especifique <see langword="null" /> em vez de uma matriz de tipos. Se nenhum dos parâmetros tiver modificadores personalizados opcionais, especifique <see langword="null" /> em vez de uma matriz de matrizes.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The current method is generic, but is not a generic method definition. That is, the &lt;see cref=&quot;P:System.Reflection.Emit.MethodBuilder.IsGenericMethod&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;, but the &lt;see cref=&quot;P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition&quot; /&gt; property is &lt;see langword=&quot;false&quot; /&gt;.">O método atual é genérico, mas não é uma definição de método genérico. Ou seja, a propriedade <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> é <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.ToString">
      <summary vsli:raw="Returns this &lt;see langword=&quot;MethodBuilder&quot; /&gt; instance as a string.">Retorna esta instância <see langword="MethodBuilder" /> como uma cadeia de caracteres.</summary>
      <returns vsli:raw="Returns a string containing the name, attributes, method signature, exceptions, and local signature of this method followed by the current Microsoft intermediate language (MSIL) stream.">Retorna uma cadeia de caracteres que contém o nome, os atributos, a assinatura do método, as exceções e a assinatura local desse método seguidos pelo fluxo MSIL (linguagem intermediária da Microsoft) atual.</returns>
    </member>
    <member name="T:System.Reflection.Emit.ModuleBuilder">
      <summary vsli:raw="Defines and represents a module in a dynamic assembly.">Define e representa um módulo em um assembly dinâmico.</summary>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.Assembly">
      <summary vsli:raw="Gets the dynamic assembly that defined this instance of &lt;see cref=&quot;T:System.Reflection.Emit.ModuleBuilder&quot; /&gt;.">Obtém o assembly dinâmico que definiu esta instância do <see cref="T:System.Reflection.Emit.ModuleBuilder" />.</summary>
      <returns vsli:raw="The dynamic assembly that defined the current dynamic module.">O assembly dinâmico que definiu o módulo dinâmico atual.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions">
      <summary vsli:raw="Completes the global function definitions and global data definitions for this dynamic module.">Conclui a definições de função global e dados globais para esse módulo dinâmico.</summary>
      <exception cref="T:System.InvalidOperationException" vsli:raw="This method was called previously.">Esse método foi chamado anteriormente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
      <summary vsli:raw="Defines an enumeration type that is a value type with a single non-static field called &lt;paramref name=&quot;value__&quot; /&gt; of the specified type.">Define um tipo de enumeração que é um tipo de valor com um único campo não estático chamado <paramref name="value__" /> do tipo especificado.</summary>
      <param name="name" vsli:raw="The full path of the enumeration type. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">O caminho completo do tipo de enumeração. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="visibility" vsli:raw="The type attributes for the enumeration. The attributes are any bits defined by &lt;see cref=&quot;F:System.Reflection.TypeAttributes.VisibilityMask&quot; /&gt;.">Os atributos de tipo para a enumeração. Os atributos são quaisquer bits definidos pelo <see cref="F:System.Reflection.TypeAttributes.VisibilityMask" />.</param>
      <param name="underlyingType" vsli:raw="The underlying type for the enumeration. This must be a built-in integer type.">O tipo subjacente para a enumeração. Isso deve ser um tipo inteiro interno.</param>
      <returns vsli:raw="The defined enumeration.">A enumeração definida.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="Attributes other than visibility attributes are provided.  &#xA;  &#xA; -or-  &#xA;  &#xA; An enumeration with the given name exists in the parent assembly of this module.  &#xA;  &#xA; -or-  &#xA;  &#xA; The visibility attributes do not match the scope of the enumeration. For example, &lt;see cref=&quot;F:System.Reflection.TypeAttributes.NestedPublic&quot; /&gt; is specified for &lt;paramref name=&quot;visibility&quot; /&gt;, but the enumeration is not a nested type.">Atributos que não sejam os atributos de visibilidade são fornecidos.  

ou - 
Uma enumeração com o nome especificado existe no assembly pai deste módulo.  

ou - 
Os atributos de visibilidade não coincidem com o escopo da enumeração. Por exemplo, <see cref="F:System.Reflection.TypeAttributes.NestedPublic" /> é especificado para <paramref name="visibility" />, mas a enumeração não é um tipo aninhado.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
      <summary vsli:raw="Defines a global method with the specified name, attributes, calling convention, return type, and parameter types.">Define um método global com o nome, os atributos, a convenção de chamada, o tipo de retorno e os tipos de parâmetro especificados.</summary>
      <param name="name" vsli:raw="The name of the method. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">O nome do método. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="attributes" vsli:raw="The attributes of the method. &lt;paramref name=&quot;attributes&quot; /&gt; must include &lt;see cref=&quot;F:System.Reflection.MethodAttributes.Static&quot; /&gt;.">Os atributos do método. <paramref name="attributes" /> deve incluir <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
      <param name="callingConvention" vsli:raw="The calling convention for the method.">A convenção de chamada para o método.</param>
      <param name="returnType" vsli:raw="The return type of the method.">O tipo de retorno do método.</param>
      <param name="parameterTypes" vsli:raw="The types of the method's parameters.">Os tipos de parâmetros do método.</param>
      <returns vsli:raw="The defined global method.">O método global definido.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The method is not static. That is, &lt;paramref name=&quot;attributes&quot; /&gt; does not include &lt;see cref=&quot;F:System.Reflection.MethodAttributes.Static&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; An element in the &lt;see cref=&quot;T:System.Type&quot; /&gt; array is &lt;see langword=&quot;null&quot; /&gt;.">O método não é estático. Ou seja, <paramref name="attributes" /> não inclui <see cref="F:System.Reflection.MethodAttributes.Static" />.  

ou - 
Um elemento na matriz <see cref="T:System.Type" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions&quot; /&gt; has been previously called.">
        <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> foi chamado anteriormente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
      <summary vsli:raw="Defines a global method with the specified name, attributes, calling convention, return type, custom modifiers for the return type, parameter types, and custom modifiers for the parameter types.">Define um método global com os valores especificado de nome, atributos, convenção de chamada, tipo de retorno, modificadores personalizados para o tipo de retorno, tipos de parâmetro e modificadores personalizados para os tipos de parâmetro.</summary>
      <param name="name" vsli:raw="The name of the method. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded null characters.">O nome do método. <paramref name="name" /> não pode conter caracteres nulos inseridos.</param>
      <param name="attributes" vsli:raw="The attributes of the method. &lt;paramref name=&quot;attributes&quot; /&gt; must include &lt;see cref=&quot;F:System.Reflection.MethodAttributes.Static&quot; /&gt;.">Os atributos do método. <paramref name="attributes" /> deve incluir <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
      <param name="callingConvention" vsli:raw="The calling convention for the method.">A convenção de chamada para o método.</param>
      <param name="returnType" vsli:raw="The return type of the method.">O tipo de retorno do método.</param>
      <param name="requiredReturnTypeCustomModifiers" vsli:raw="An array of types representing the required custom modifiers for the return type, such as &lt;see cref=&quot;T:System.Runtime.CompilerServices.IsConst&quot; /&gt; or &lt;see cref=&quot;T:System.Runtime.CompilerServices.IsBoxed&quot; /&gt;. If the return type has no required custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt;.">Uma matriz de tipos que representa os modificadores personalizados obrigatórios para o tipo de retorno, como <see cref="T:System.Runtime.CompilerServices.IsConst" /> ou <see cref="T:System.Runtime.CompilerServices.IsBoxed" />. Se o tipo de retorno não tiver modificadores personalizados obrigatórios, especifique <see langword="null" />.</param>
      <param name="optionalReturnTypeCustomModifiers" vsli:raw="An array of types representing the optional custom modifiers for the return type, such as &lt;see cref=&quot;T:System.Runtime.CompilerServices.IsConst&quot; /&gt; or &lt;see cref=&quot;T:System.Runtime.CompilerServices.IsBoxed&quot; /&gt;. If the return type has no optional custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt;.">Uma matriz de tipos que representa os modificadores personalizados opcionais para o tipo de retorno, como <see cref="T:System.Runtime.CompilerServices.IsConst" /> ou <see cref="T:System.Runtime.CompilerServices.IsBoxed" />. Se o tipo de retorno não tiver modificadores personalizados opcionais, especifique <see langword="null" />.</param>
      <param name="parameterTypes" vsli:raw="The types of the method's parameters.">Os tipos de parâmetros do método.</param>
      <param name="requiredParameterTypeCustomModifiers" vsli:raw="An array of arrays of types. Each array of types represents the required custom modifiers for the corresponding parameter of the global method. If a particular argument has no required custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt; instead of an array of types. If the global method has no arguments, or if none of the arguments have required custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt; instead of an array of arrays.">Uma matriz de matrizes de tipos. Cada matriz de tipos representa os modificadores personalizados necessários para o parâmetro correspondente do método global. Se um argumento específico não tiver nenhum modificador personalizado obrigatório, especifique <see langword="null" />, em vez de uma matriz de tipos. Se o método global não tiver nenhum argumento ou se nenhum argumento tiver modificadores personalizados obrigatórios, especifique <see langword="null" />, em vez de uma matriz de matrizes.</param>
      <param name="optionalParameterTypeCustomModifiers" vsli:raw="An array of arrays of types. Each array of types represents the optional custom modifiers for the corresponding parameter. If a particular argument has no optional custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt; instead of an array of types. If the global method has no arguments, or if none of the arguments have optional custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt; instead of an array of arrays.">Uma matriz de matrizes de tipos. Cada matriz de tipos representa os modificadores personalizados opcionais para o parâmetro correspondente. Se um argumento específico não tiver nenhum modificador personalizado opcional, especifique <see langword="null" />, em vez de uma matriz de tipos. Se o método global não tiver nenhum argumento ou se nenhum argumento tiver modificadores personalizados opcionais, especifique <see langword="null" />, em vez de uma matriz de matrizes.</param>
      <returns vsli:raw="The defined global method.">O método global definido.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The method is not static. That is, &lt;paramref name=&quot;attributes&quot; /&gt; does not include &lt;see cref=&quot;F:System.Reflection.MethodAttributes.Static&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; An element in the &lt;see cref=&quot;T:System.Type&quot; /&gt; array is &lt;see langword=&quot;null&quot; /&gt;.">O método não é estático. Ou seja, <paramref name="attributes" /> não inclui <see cref="F:System.Reflection.MethodAttributes.Static" />.  

ou - 
Um elemento na matriz <see cref="T:System.Type" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &lt;see cref=&quot;M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions&quot; /&gt; method has been previously called.">O método <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> foi chamado anteriormente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
      <summary vsli:raw="Defines a global method with the specified name, attributes, return type, and parameter types.">Define um método global com o nome, os atributos, o tipo de retorno e os tipos de parâmetro especificados.</summary>
      <param name="name" vsli:raw="The name of the method. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">O nome do método. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="attributes" vsli:raw="The attributes of the method. &lt;paramref name=&quot;attributes&quot; /&gt; must include &lt;see cref=&quot;F:System.Reflection.MethodAttributes.Static&quot; /&gt;.">Os atributos do método. <paramref name="attributes" /> deve incluir <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
      <param name="returnType" vsli:raw="The return type of the method.">O tipo de retorno do método.</param>
      <param name="parameterTypes" vsli:raw="The types of the method's parameters.">Os tipos de parâmetros do método.</param>
      <returns vsli:raw="The defined global method.">O método global definido.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The method is not static. That is, &lt;paramref name=&quot;attributes&quot; /&gt; does not include &lt;see cref=&quot;F:System.Reflection.MethodAttributes.Static&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The length of &lt;paramref name=&quot;name&quot; /&gt; is zero  &#xA;  &#xA; -or-  &#xA;  &#xA; An element in the &lt;see cref=&quot;T:System.Type&quot; /&gt; array is &lt;see langword=&quot;null&quot; /&gt;.">O método não é estático. Ou seja, <paramref name="attributes" /> não inclui <see cref="F:System.Reflection.MethodAttributes.Static" />.  

ou - 
O comprimento de <paramref name="name" /> é zero 
ou - 
Um elemento na matriz <see cref="T:System.Type" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions&quot; /&gt; has been previously called.">
        <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> foi chamado anteriormente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
      <summary vsli:raw="Defines an initialized data field in the .sdata section of the portable executable (PE) file.">Define o campo de dados inicializado na seção .sdata do arquivo PE (executável portátil).</summary>
      <param name="name" vsli:raw="The name used to refer to the data. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">O nome usado para fazer referência aos dados. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="data" vsli:raw="The binary large object (BLOB) of data.">O BLOB (objeto binário grande) de dados.</param>
      <param name="attributes" vsli:raw="The attributes for the field. The default is &lt;see langword=&quot;Static&quot; /&gt;.">Os atributos do campo. O padrão é <see langword="Static" />.</param>
      <returns vsli:raw="A field to reference the data.">Um campo para fazer referência aos dados.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The length of &lt;paramref name=&quot;name&quot; /&gt; is zero.  &#xA;  &#xA; -or-  &#xA;  &#xA; The size of &lt;paramref name=&quot;data&quot; /&gt; is less than or equal to zero or greater than or equal to 0x3f0000.">O comprimento de <paramref name="name" /> é zero.  

ou - 
O tamanho de <paramref name="data" /> é menor ou igual a zero, ou maior ou igual a 0x3f0000.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; or &lt;paramref name=&quot;data&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> ou <paramref name="data" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions&quot; /&gt; has been previously called.">
        <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> foi chamado anteriormente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
      <summary vsli:raw="Defines a &lt;see langword=&quot;PInvoke&quot; /&gt; method with the specified name, the name of the DLL in which the method is defined, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, and the &lt;see langword=&quot;PInvoke&quot; /&gt; flags.">Define um método <see langword="PInvoke" /> com o nome especificado, o nome da DLL em que o método é definido, os atributos do método, a convenção de chamada do método, o tipo de retorno do método, os tipos dos parâmetros do método e os sinalizadores <see langword="PInvoke" />.</summary>
      <param name="name" vsli:raw="The name of the &lt;see langword=&quot;PInvoke&quot; /&gt; method. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">O nome do método <see langword="PInvoke" />. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="dllName" vsli:raw="The name of the DLL in which the &lt;see langword=&quot;PInvoke&quot; /&gt; method is defined.">O nome da DLL na qual o método <see langword="PInvoke" /> é definido.</param>
      <param name="attributes" vsli:raw="The attributes of the method.">Os atributos do método.</param>
      <param name="callingConvention" vsli:raw="The method's calling convention.">A convenção de chamada do método.</param>
      <param name="returnType" vsli:raw="The method's return type.">O tipo de retorno do método.</param>
      <param name="parameterTypes" vsli:raw="The types of the method's parameters.">Os tipos de parâmetros do método.</param>
      <param name="nativeCallConv" vsli:raw="The native calling convention.">A convenção de chamada nativa.</param>
      <param name="nativeCharSet" vsli:raw="The method's native character set.">O conjunto de caracteres nativos do método.</param>
      <returns vsli:raw="The defined &lt;see langword=&quot;PInvoke&quot; /&gt; method.">O método <see langword="PInvoke" /> definido.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The method is not static or if the containing type is an interface.  &#xA;  &#xA; -or-  &#xA;  &#xA; The method is abstract.  &#xA;  &#xA; -or-  &#xA;  &#xA; The method was previously defined.">O método não é estático ou o tipo de conteúdo é uma interface.  

ou -  

 O método é abstrato.  

ou -  

 O método foi definido anteriormente.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; or &lt;paramref name=&quot;dllName&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> ou <paramref name="dllName" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The containing type has been previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;">O tipo recipiente foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /></exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
      <summary vsli:raw="Defines a &lt;see langword=&quot;PInvoke&quot; /&gt; method with the specified name, the name of the DLL in which the method is defined, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, and the &lt;see langword=&quot;PInvoke&quot; /&gt; flags.">Define um método <see langword="PInvoke" /> com o nome especificado, o nome da DLL em que o método é definido, os atributos do método, a convenção de chamada do método, o tipo de retorno do método, os tipos dos parâmetros do método e os sinalizadores <see langword="PInvoke" />.</summary>
      <param name="name" vsli:raw="The name of the &lt;see langword=&quot;PInvoke&quot; /&gt; method. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">O nome do método <see langword="PInvoke" />. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="dllName" vsli:raw="The name of the DLL in which the &lt;see langword=&quot;PInvoke&quot; /&gt; method is defined.">O nome da DLL na qual o método <see langword="PInvoke" /> é definido.</param>
      <param name="entryName" vsli:raw="The name of the entry point in the DLL.">O nome do ponto de entrada na DLL.</param>
      <param name="attributes" vsli:raw="The attributes of the method.">Os atributos do método.</param>
      <param name="callingConvention" vsli:raw="The method's calling convention.">A convenção de chamada do método.</param>
      <param name="returnType" vsli:raw="The method's return type.">O tipo de retorno do método.</param>
      <param name="parameterTypes" vsli:raw="The types of the method's parameters.">Os tipos de parâmetros do método.</param>
      <param name="nativeCallConv" vsli:raw="The native calling convention.">A convenção de chamada nativa.</param>
      <param name="nativeCharSet" vsli:raw="The method's native character set.">O conjunto de caracteres nativos do método.</param>
      <returns vsli:raw="The defined &lt;see langword=&quot;PInvoke&quot; /&gt; method.">O método <see langword="PInvoke" /> definido.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The method is not static or if the containing type is an interface or if the method is abstract of if the method was previously defined.">O método não é estático ou se o tipo de conteúdo é uma interface ou se o método é abstract se o método foi definido anteriormente.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; or &lt;paramref name=&quot;dllName&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> ou <paramref name="dllName" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The containing type has been previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;">O tipo recipiente foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /></exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)">
      <summary vsli:raw="Constructs a &lt;see langword=&quot;TypeBuilder&quot; /&gt; for a private type with the specified name in this module.">Constrói um <see langword="TypeBuilder" /> para um tipo particular com o nome especificado neste módulo.</summary>
      <param name="name" vsli:raw="The full path of the type, including the namespace. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">O caminho completo do tipo, incluindo o namespace. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <returns vsli:raw="A private type with the specified name.">Um tipo particular com o nome especificado.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="A type with the given name exists in the parent assembly of this module.  &#xA;  &#xA; -or-  &#xA;  &#xA; Nested type attributes are set on a type that is not nested.">Existe um tipo com o nome especificado no assembly pai deste módulo.  

ou -  

 Atributos de tipo aninhado são definidos em um tipo que não está aninhado.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)">
      <summary vsli:raw="Constructs a &lt;see langword=&quot;TypeBuilder&quot; /&gt; given the type name and the type attributes.">Constrói um <see langword="TypeBuilder" /> considerando o nome do tipo e os atributos de tipo.</summary>
      <param name="name" vsli:raw="The full path of the type. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">O caminho completo do tipo. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="attr" vsli:raw="The attributes of the defined type.">Os atributos do tipo definido.</param>
      <returns vsli:raw="A &lt;see langword=&quot;TypeBuilder&quot; /&gt; created with all of the requested attributes.">Um <see langword="TypeBuilder" /> criado com todos os atributos solicitados.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="A type with the given name exists in the parent assembly of this module.  &#xA;  &#xA; -or-  &#xA;  &#xA; Nested type attributes are set on a type that is not nested.">Existe um tipo com o nome especificado no assembly pai deste módulo.  

ou -  

 Atributos de tipo aninhado são definidos em um tipo que não está aninhado.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
      <summary vsli:raw="Constructs a &lt;see langword=&quot;TypeBuilder&quot; /&gt; given type name, its attributes, and the type that the defined type extends.">Constrói um <see langword="TypeBuilder" /> dado o nome do tipo, seus atributos e o tipo que o tipo definido estende.</summary>
      <param name="name" vsli:raw="The full path of the type. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">O caminho completo do tipo. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="attr" vsli:raw="The attribute to be associated with the type.">O atributo a ser associado ao tipo.</param>
      <param name="parent" vsli:raw="The type that the defined type extends.">O tipo que o tipo definido estende.</param>
      <returns vsli:raw="A &lt;see langword=&quot;TypeBuilder&quot; /&gt; created with all of the requested attributes.">Um <see langword="TypeBuilder" /> criado com todos os atributos solicitados.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="A type with the given name exists in the parent assembly of this module.  &#xA;  &#xA; -or-  &#xA;  &#xA; Nested type attributes are set on a type that is not nested.">Existe um tipo com o nome especificado no assembly pai deste módulo.  

ou -  

 Atributos de tipo aninhado são definidos em um tipo que não está aninhado.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
      <summary vsli:raw="Constructs a &lt;see langword=&quot;TypeBuilder&quot; /&gt; given the type name, the attributes, the type that the defined type extends, and the total size of the type.">Constrói um <see langword="TypeBuilder" /> dado o nome do tipo, os atributos, o tipo que o tipo definido estende e o tamanho total do tipo.</summary>
      <param name="name" vsli:raw="The full path of the type. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">O caminho completo do tipo. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="attr" vsli:raw="The attributes of the defined type.">Os atributos do tipo definido.</param>
      <param name="parent" vsli:raw="The type that the defined type extends.">O tipo que o tipo definido estende.</param>
      <param name="typesize" vsli:raw="The total size of the type.">O tamanho total do tipo.</param>
      <returns vsli:raw="A &lt;see langword=&quot;TypeBuilder&quot; /&gt; object.">Um objeto <see langword="TypeBuilder" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="A type with the given name exists in the parent assembly of this module.  &#xA;  &#xA; -or-  &#xA;  &#xA; Nested type attributes are set on a type that is not nested.">Existe um tipo com o nome especificado no assembly pai deste módulo.  

ou -  

 Atributos de tipo aninhado são definidos em um tipo que não está aninhado.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
      <summary vsli:raw="Constructs a &lt;see langword=&quot;TypeBuilder&quot; /&gt; given the type name, the attributes, the type that the defined type extends, and the packing size of the type.">Constrói um <see langword="TypeBuilder" /> dado o nome do tipo, os atributos, o tipo que o tipo definido estende e o tamanho de empacotamento do tipo.</summary>
      <param name="name" vsli:raw="The full path of the type. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">O caminho completo do tipo. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="attr" vsli:raw="The attributes of the defined type.">Os atributos do tipo definido.</param>
      <param name="parent" vsli:raw="The type that the defined type extends.">O tipo que o tipo definido estende.</param>
      <param name="packsize" vsli:raw="The packing size of the type.">O tamanho de empacotamento do tipo.</param>
      <returns vsli:raw="A &lt;see langword=&quot;TypeBuilder&quot; /&gt; object.">Um objeto <see langword="TypeBuilder" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="A type with the given name exists in the parent assembly of this module.  &#xA;  &#xA; -or-  &#xA;  &#xA; Nested type attributes are set on a type that is not nested.">Existe um tipo com o nome especificado no assembly pai deste módulo.  

ou -  

 Atributos de tipo aninhado são definidos em um tipo que não está aninhado.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
      <summary vsli:raw="Constructs a &lt;see langword=&quot;TypeBuilder&quot; /&gt; given the type name, attributes, the type that the defined type extends, the packing size of the defined type, and the total size of the defined type.">Constrói um <see langword="TypeBuilder" /> dado o nome do tipo, os atributos, o tipo que o tipo definido estende, o tamanho de empacotamento do tipo definido e o tamanho total do tipo definido.</summary>
      <param name="name" vsli:raw="The full path of the type. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">O caminho completo do tipo. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="attr" vsli:raw="The attributes of the defined type.">Os atributos do tipo definido.</param>
      <param name="parent" vsli:raw="The type that the defined type extends.">O tipo que o tipo definido estende.</param>
      <param name="packingSize" vsli:raw="The packing size of the type.">O tamanho de empacotamento do tipo.</param>
      <param name="typesize" vsli:raw="The total size of the type.">O tamanho total do tipo.</param>
      <returns vsli:raw="A &lt;see langword=&quot;TypeBuilder&quot; /&gt; created with all of the requested attributes.">Um <see langword="TypeBuilder" /> criado com todos os atributos solicitados.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="A type with the given name exists in the parent assembly of this module.  &#xA;  &#xA; -or-  &#xA;  &#xA; Nested type attributes are set on a type that is not nested.">Existe um tipo com o nome especificado no assembly pai deste módulo.  

ou -  

 Atributos de tipo aninhado são definidos em um tipo que não está aninhado.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
      <summary vsli:raw="Constructs a &lt;see langword=&quot;TypeBuilder&quot; /&gt; given the type name, attributes, the type that the defined type extends, and the interfaces that the defined type implements.">Constrói um <see langword="TypeBuilder" /> dado o nome do tipo, os atributos, o tipo que o tipo definido estende e as interfaces que o tipo definido implementa.</summary>
      <param name="name" vsli:raw="The full path of the type. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">O caminho completo do tipo. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="attr" vsli:raw="The attributes to be associated with the type.">Os atributos a serem associado ao tipo.</param>
      <param name="parent" vsli:raw="The type that the defined type extends.">O tipo que o tipo definido estende.</param>
      <param name="interfaces" vsli:raw="The list of interfaces that the type implements.">A lista de interfaces que o tipo implementa.</param>
      <returns vsli:raw="A &lt;see langword=&quot;TypeBuilder&quot; /&gt; created with all of the requested attributes.">Um <see langword="TypeBuilder" /> criado com todos os atributos solicitados.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="A type with the given name exists in the parent assembly of this module.  &#xA;  &#xA; -or-  &#xA;  &#xA; Nested type attributes are set on a type that is not nested.">Existe um tipo com o nome especificado no assembly pai deste módulo.  

ou -  

 Atributos de tipo aninhado são definidos em um tipo que não está aninhado.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
      <summary vsli:raw="Defines an uninitialized data field in the .sdata section of the portable executable (PE) file.">Define o campo de dados não inicializado na seção .sdata do arquivo PE (executável portátil).</summary>
      <param name="name" vsli:raw="The name used to refer to the data. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">O nome usado para fazer referência aos dados. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="size" vsli:raw="The size of the data field.">O tamanho do campo de dados.</param>
      <param name="attributes" vsli:raw="The attributes for the field.">Os atributos do campo.</param>
      <returns vsli:raw="A field to reference the data.">Um campo para fazer referência aos dados.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The length of &lt;paramref name=&quot;name&quot; /&gt; is zero.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;size&quot; /&gt; is less than or equal to zero, or greater than or equal to 0x003f0000.">O comprimento de <paramref name="name" /> é zero.  

ou - 
<paramref name="size" /> é menor que ou igual a zero, ou maior que ou igual a 0x003f0000.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions&quot; /&gt; has been previously called.">
        <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> foi chamado anteriormente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.Equals(System.Object)">
      <summary vsli:raw="Returns a value that indicates whether this instance is equal to the specified object.">Retorna um valor que indica se essa instância é igual ao objeto especificado.</summary>
      <param name="obj" vsli:raw="An object to compare with this instance, or &lt;see langword=&quot;null&quot; /&gt;.">Um objeto a ser comparado com essa instância ou <see langword="null" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;obj&quot; /&gt; equals the type and value of this instance; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se <paramref name="obj" /> for igual ao tipo e ao valor dessa instância, caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.FullyQualifiedName">
      <summary vsli:raw="Gets a &lt;see langword=&quot;String&quot; /&gt; representing the fully qualified name and path to this module.">Obtém uma <see langword="String" /> que representa o nome totalmente qualificado e o caminho para esse módulo.</summary>
      <returns vsli:raw="The fully qualified module name.">O nome do módulo totalmente qualificado.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
      <summary vsli:raw="Returns the named method on an array class.">Retorna o método nomeado em uma classe de matriz.</summary>
      <param name="arrayClass" vsli:raw="An array class.">Uma classe de matriz.</param>
      <param name="methodName" vsli:raw="The name of a method on the array class.">O nome de um método na classe de matriz.</param>
      <param name="callingConvention" vsli:raw="The method's calling convention.">A convenção de chamada do método.</param>
      <param name="returnType" vsli:raw="The return type of the method.">O tipo de retorno do método.</param>
      <param name="parameterTypes" vsli:raw="The types of the method's parameters.">Os tipos de parâmetros do método.</param>
      <returns vsli:raw="The named method on an array class.">O método nomeado em uma classe de matriz.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;arrayClass&quot; /&gt; is not an array.">
        <paramref name="arrayClass" /> não é uma matriz.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;arrayClass&quot; /&gt; or &lt;paramref name=&quot;methodName&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="arrayClass" /> ou <paramref name="methodName" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Boolean)">
      <summary vsli:raw="Returns all the custom attributes that have been applied to the current &lt;see cref=&quot;T:System.Reflection.Emit.ModuleBuilder&quot; /&gt;.">Retorna todos os atributos personalizados que foram aplicados ao <see cref="T:System.Reflection.Emit.ModuleBuilder" /> atual.</summary>
      <param name="inherit" vsli:raw="This argument is ignored for objects of this type.">Este argumento é ignorado para objetos deste tipo.</param>
      <returns vsli:raw="An array that contains the custom attributes; the array is empty if there are no attributes.">Uma matriz que contém os atributos personalizados; a matriz será vazia se não houver nenhum atributo.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary vsli:raw="Returns all the custom attributes that have been applied to the current &lt;see cref=&quot;T:System.Reflection.Emit.ModuleBuilder&quot; /&gt;, and that derive from a specified attribute type.">Retorna todos os atributos personalizados que foram aplicados ao <see cref="T:System.Reflection.Emit.ModuleBuilder" /> atual e que derivam de um tipo de atributo especificado.</summary>
      <param name="attributeType" vsli:raw="The base type from which attributes derive.">O tipo base do qual derivam os atributos.</param>
      <param name="inherit" vsli:raw="This argument is ignored for objects of this type.">Este argumento é ignorado para objetos deste tipo.</param>
      <returns vsli:raw="An array that contains the custom attributes that are derived, at any level, from &lt;paramref name=&quot;attributeType&quot; /&gt;; the array is empty if there are no such attributes.">Uma matriz que contém os atributos personalizados que são derivados em qualquer nível de <paramref name="attributeType" />; a matriz será vazia se não houver nenhum desses atributos.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;attributeType&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="attributeType" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;attributeType&quot; /&gt; is not a &lt;see cref=&quot;T:System.Type&quot; /&gt; object supplied by the runtime. For example, &lt;paramref name=&quot;attributeType&quot; /&gt; is a &lt;see cref=&quot;T:System.Reflection.Emit.TypeBuilder&quot; /&gt; object.">
        <paramref name="attributeType" /> não é um objeto <see cref="T:System.Type" /> fornecido pelo tempo de execução. Por exemplo, <paramref name="attributeType" /> é um objeto <see cref="T:System.Reflection.Emit.TypeBuilder" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributesData">
      <summary vsli:raw="Returns information about the attributes that have been applied to the current &lt;see cref=&quot;T:System.Reflection.Emit.ModuleBuilder&quot; /&gt;, expressed as &lt;see cref=&quot;T:System.Reflection.CustomAttributeData&quot; /&gt; objects.">Retorna informações sobre os atributos que foram aplicados ao <see cref="T:System.Reflection.Emit.ModuleBuilder" /> atual, expressos como objetos <see cref="T:System.Reflection.CustomAttributeData" />.</summary>
      <returns vsli:raw="A generic list of &lt;see cref=&quot;T:System.Reflection.CustomAttributeData&quot; /&gt; objects representing data about the attributes that have been applied to the current module.">Uma lista genérica de objetos <see cref="T:System.Reflection.CustomAttributeData" /> que representam dados sobre os atributos que foram aplicados ao módulo atual.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetField(System.String,System.Reflection.BindingFlags)">
      <summary vsli:raw="Returns a module-level field, defined in the .sdata region of the portable executable (PE) file, that has the specified name and binding attributes.">Retorna um campo no nível de módulo, definido na região de .sdata o arquivo PE (executável portátil), que tem o nome e os atributos de associação especificados.</summary>
      <param name="name" vsli:raw="The field name.">O nome do campo.</param>
      <param name="bindingAttr" vsli:raw="A combination of the &lt;see langword=&quot;BindingFlags&quot; /&gt; bit flags used to control the search.">Uma combinação dos sinalizadores de bit <see langword="BindingFlags" /> usados para controlar a pesquisa.</param>
      <returns vsli:raw="A field that has the specified name and binding attributes, or &lt;see langword=&quot;null&quot; /&gt; if the field does not exist.">Um campo que tem o nome e os atributos de associação especificados ou <see langword="null" />, se o campo não existir.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;name&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">O parâmetro <paramref name="name" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetFields(System.Reflection.BindingFlags)">
      <summary vsli:raw="Returns all fields defined in the .sdata region of the portable executable (PE) file that match the specified binding flags.">Retorna todos os campos definidos na região .sdata do arquivo PE (executável portátil) que correspondem aos sinalizadores de associação especificados.</summary>
      <param name="bindingFlags" vsli:raw="A combination of the &lt;see langword=&quot;BindingFlags&quot; /&gt; bit flags used to control the search.">Uma combinação dos sinalizadores de bit <see langword="BindingFlags" /> usados para controlar a pesquisa.</param>
      <returns vsli:raw="An array of fields that match the specified flags; the array is empty if no such fields exist.">Uma matriz de campos que coincidem com os sinalizadores especificados; a matriz estará vazia se não existirem esses campos.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;name&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">O parâmetro <paramref name="name" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetHashCode">
      <summary vsli:raw="Returns the hash code for this instance.">Retorna o código hash para essa instância.</summary>
      <returns vsli:raw="A 32-bit signed integer hash code.">Um código de hash do inteiro assinado de 32 bits.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetMethods(System.Reflection.BindingFlags)">
      <summary vsli:raw="Returns all the methods that have been defined at the module level for the current &lt;see cref=&quot;T:System.Reflection.Emit.ModuleBuilder&quot; /&gt;, and that match the specified binding flags.">Retorna todos os métodos que foram definidos no nível de módulo para o <see cref="T:System.Reflection.Emit.ModuleBuilder" /> atual e que corresponde aos sinalizadores de associação especificados.</summary>
      <param name="bindingFlags" vsli:raw="A combination of &lt;see langword=&quot;BindingFlags&quot; /&gt; bit flags used to control the search.">Uma combinação de sinalizadores de bit <see langword="BindingFlags" /> usados para controlar a pesquisa.</param>
      <returns vsli:raw="An array that contains all the module-level methods that match &lt;paramref name=&quot;bindingFlags&quot; /&gt;.">Uma matriz que contém todos os métodos de nível de módulo que correspondem a <paramref name="bindingFlags" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)">
      <summary vsli:raw="Gets a pair of values indicating the nature of the code in a module and the platform targeted by the module.">Obtém um par de valores que indica a natureza do código em um módulo e a plataforma de destino do módulo.</summary>
      <param name="peKind" vsli:raw="When this method returns, a combination of the &lt;see cref=&quot;T:System.Reflection.PortableExecutableKinds&quot; /&gt; values indicating the nature of the code in the module.">Quando este método retorna, uma combinação dos valores <see cref="T:System.Reflection.PortableExecutableKinds" /> indicando a natureza do código no módulo.</param>
      <param name="machine" vsli:raw="When this method returns, one of the &lt;see cref=&quot;T:System.Reflection.ImageFileMachine&quot; /&gt; values indicating the platform targeted by the module.">Quando este método retorna, um dos valores <see cref="T:System.Reflection.ImageFileMachine" /> indicando a plataforma de destino no módulo.</param>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String)">
      <summary vsli:raw="Gets the named type defined in the module.">Obtém o tipo nomeado definido no módulo.</summary>
      <param name="className" vsli:raw="The name of the &lt;see cref=&quot;T:System.Type&quot; /&gt; to get.">O nome do <see cref="T:System.Type" /> a obter.</param>
      <returns vsli:raw="The requested type, if the type is defined in this module; otherwise, &lt;see langword=&quot;null&quot; /&gt;.">O tipo solicitado, se o tipo estiver definido neste módulo; caso contrário, <see langword="null" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="Length of &lt;paramref name=&quot;className&quot; /&gt; is zero or is greater than 1023.">O comprimento de <paramref name="className" /> é igual a zero ou maior que 1023.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;className&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="className" /> é <see langword="null" />.</exception>
      <exception cref="T:System.Security.SecurityException" vsli:raw="The requested &lt;see cref=&quot;T:System.Type&quot; /&gt; is non-public and the caller does not have &lt;see cref=&quot;T:System.Security.Permissions.ReflectionPermission&quot; /&gt; to reflect non-public objects outside the current assembly.">O <see cref="T:System.Type" /> solicitado é não público e o chamador não tem <see cref="T:System.Security.Permissions.ReflectionPermission" /> para refletir objetos não públicos fora do assembly atual.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException" vsli:raw="A class initializer is invoked and throws an exception.">Um inicializador de classe é invocado e lança uma exceção.</exception>
      <exception cref="T:System.TypeLoadException" vsli:raw="An error is encountered while loading the &lt;see cref=&quot;T:System.Type&quot; /&gt;.">Um erro é encontrado ao carregar o <see cref="T:System.Type" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)">
      <summary vsli:raw="Gets the named type defined in the module, optionally ignoring the case of the type name.">Obtém o tipo nomeado definido no módulo, opcionalmente ignorando maiúsculas e minúsculas do nome do tipo.</summary>
      <param name="className" vsli:raw="The name of the &lt;see cref=&quot;T:System.Type&quot; /&gt; to get.">O nome do <see cref="T:System.Type" /> a obter.</param>
      <param name="ignoreCase" vsli:raw="If &lt;see langword=&quot;true&quot; /&gt;, the search is case-insensitive. If &lt;see langword=&quot;false&quot; /&gt;, the search is case-sensitive.">Se <see langword="true" />, a pesquisa não diferenciará maiúsculas de minúsculas. Se <see langword="false" />, a pesquisa diferenciará maiúsculas de minúsculas.</param>
      <returns vsli:raw="The requested type, if the type is defined in this module; otherwise, &lt;see langword=&quot;null&quot; /&gt;.">O tipo solicitado, se o tipo estiver definido neste módulo; caso contrário, <see langword="null" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="Length of &lt;paramref name=&quot;className&quot; /&gt; is zero or is greater than 1023.">O comprimento de <paramref name="className" /> é igual a zero ou maior que 1023.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;className&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="className" /> é <see langword="null" />.</exception>
      <exception cref="T:System.Security.SecurityException" vsli:raw="The requested &lt;see cref=&quot;T:System.Type&quot; /&gt; is non-public and the caller does not have &lt;see cref=&quot;T:System.Security.Permissions.ReflectionPermission&quot; /&gt; to reflect non-public objects outside the current assembly.">O <see cref="T:System.Type" /> solicitado é não público e o chamador não tem <see cref="T:System.Security.Permissions.ReflectionPermission" /> para refletir objetos não públicos fora do assembly atual.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException" vsli:raw="A class initializer is invoked and throws an exception.">Um inicializador de classe é invocado e lança uma exceção.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
      <summary vsli:raw="Gets the named type defined in the module, optionally ignoring the case of the type name. Optionally throws an exception if the type is not found.">Obtém o tipo nomeado definido no módulo, opcionalmente ignorando maiúsculas e minúsculas do nome do tipo. Opcionalmente, gerará uma exceção se o tipo não for encontrado.</summary>
      <param name="className" vsli:raw="The name of the &lt;see cref=&quot;T:System.Type&quot; /&gt; to get.">O nome do <see cref="T:System.Type" /> a obter.</param>
      <param name="throwOnError" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to throw an exception if the type cannot be found; &lt;see langword=&quot;false&quot; /&gt; to return &lt;see langword=&quot;null&quot; /&gt;.">
        <see langword="true" /> para gerar uma exceção se não for possível encontrar o tipo; <see langword="false" /> para retornar <see langword="null" />.</param>
      <param name="ignoreCase" vsli:raw="If &lt;see langword=&quot;true&quot; /&gt;, the search is case-insensitive. If &lt;see langword=&quot;false&quot; /&gt;, the search is case-sensitive.">Se <see langword="true" />, a pesquisa não diferenciará maiúsculas de minúsculas. Se <see langword="false" />, a pesquisa diferenciará maiúsculas de minúsculas.</param>
      <returns vsli:raw="The specified type, if the type is declared in this module; otherwise, &lt;see langword=&quot;null&quot; /&gt;.">O tipo especificado, se o tipo for declarado neste módulo; caso contrário, <see langword="null" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="Length of &lt;paramref name=&quot;className&quot; /&gt; is zero or is greater than 1023.">O comprimento de <paramref name="className" /> é igual a zero ou maior que 1023.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;className&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="className" /> é <see langword="null" />.</exception>
      <exception cref="T:System.Security.SecurityException" vsli:raw="The requested &lt;see cref=&quot;T:System.Type&quot; /&gt; is non-public and the caller does not have &lt;see cref=&quot;T:System.Security.Permissions.ReflectionPermission&quot; /&gt; to reflect non-public objects outside the current assembly.">O <see cref="T:System.Type" /> solicitado é não público e o chamador não tem <see cref="T:System.Security.Permissions.ReflectionPermission" /> para refletir objetos não públicos fora do assembly atual.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException" vsli:raw="A class initializer is invoked and throws an exception.">Um inicializador de classe é invocado e lança uma exceção.</exception>
      <exception cref="T:System.TypeLoadException" vsli:raw="&lt;paramref name=&quot;throwOnError&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt; and the specified type is not found.">
        <paramref name="throwOnError" /> é <see langword="true" /> e o tipo especificado não foi encontrado.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetTypes">
      <summary vsli:raw="Returns all the classes defined within this module.">Retorna todas as classes definidas neste módulo.</summary>
      <returns vsli:raw="An array that contains the types defined within the module that is reflected by this instance.">Uma matriz que contém os tipos definidos dentro do módulo que é refletido por esta instância.</returns>
      <exception cref="T:System.Reflection.ReflectionTypeLoadException" vsli:raw="One or more classes in a module could not be loaded.">Uma ou mais classes em um módulo não puderam ser carregadas.</exception>
      <exception cref="T:System.Security.SecurityException" vsli:raw="The caller does not have the required permission.">O chamador não tem a permissão necessária.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.IsDefined(System.Type,System.Boolean)">
      <summary vsli:raw="Returns a value that indicates whether the specified attribute type has been applied to this module.">Retorna um valor que indica se o tipo de atributo especificado foi aplicado a este módulo.</summary>
      <param name="attributeType" vsli:raw="The type of custom attribute to test for.">O tipo de atributo personalizado para o qual testar.</param>
      <param name="inherit" vsli:raw="This argument is ignored for objects of this type.">Este argumento é ignorado para objetos deste tipo.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if one or more instances of &lt;paramref name=&quot;attributeType&quot; /&gt; have been applied to this module; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se uma ou mais instâncias de <paramref name="attributeType" /> tiver sido aplicada a este módulo; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;attributeType&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="attributeType" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;attributeType&quot; /&gt; is not a &lt;see cref=&quot;T:System.Type&quot; /&gt; object supplied by the runtime. For example, &lt;paramref name=&quot;attributeType&quot; /&gt; is a &lt;see cref=&quot;T:System.Reflection.Emit.TypeBuilder&quot; /&gt; object.">
        <paramref name="attributeType" /> não é um objeto <see cref="T:System.Type" /> fornecido pelo tempo de execução. Por exemplo, <paramref name="attributeType" /> é um objeto <see cref="T:System.Reflection.Emit.TypeBuilder" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.IsResource">
      <summary vsli:raw="Gets a value indicating whether the object is a resource.">Obtém um valor que indica se o objeto é um recurso.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the object is a resource; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o objeto for um recurso; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.MDStreamVersion">
      <summary vsli:raw="Gets the metadata stream version.">Obtém a versão de fluxo de metadados.</summary>
      <returns vsli:raw="A 32-bit integer representing the metadata stream version. The high-order two bytes represent the major version number, and the low-order two bytes represent the minor version number.">Um inteiro de 32 bits que representa a versão do fluxo de metadados. Os dois bytes de ordem superior representam o número de versão principal e os dois bytes de ordem inferior representam o número de versão secundária.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.MetadataToken">
      <summary vsli:raw="Gets a token that identifies the current dynamic module in metadata.">Obtém um token que identifica o módulo dinâmico atual nos metadados.</summary>
      <returns vsli:raw="An integer token that identifies the current module in metadata.">Um token de número inteiro que identifica o módulo atual nos metadados.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.ModuleVersionId">
      <summary vsli:raw="Gets a universally unique identifier (UUID) that can be used to distinguish between two versions of a module.">Obtém um UUID (identificador universal exclusivo) que pode ser usado para distinguir entre duas versões de um módulo.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Guid&quot; /&gt; that can be used to distinguish between two versions of a module.">Um <see cref="T:System.Guid" /> que pode ser usado para distinguir entre duas versões de um módulo.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.Name">
      <summary vsli:raw="A string that indicates that this is an in-memory module.">Uma cadeia de caracteres que indica que este é um módulo na memória.</summary>
      <returns vsli:raw="Text that indicates that this is an in-memory module.">Texto que indica que este é um módulo na memória.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
      <summary vsli:raw="Returns the field identified by the specified metadata token, in the context defined by the specified generic type parameters.">Retorna o campo identificado pelo token de metadados especificado, no contexto definido pelos parâmetros de tipo genérico especificados.</summary>
      <param name="metadataToken" vsli:raw="A metadata token that identifies a field in the module.">Um token de metadados que identifica um campo no módulo.</param>
      <param name="genericTypeArguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Type&quot; /&gt; objects representing the generic type arguments of the type where the token is in scope, or &lt;see langword=&quot;null&quot; /&gt; if that type is not generic.">Uma matriz de objetos <see cref="T:System.Type" /> que representam os argumentos de tipo genérico do tipo em que o token está no escopo ou <see langword="null" /> se esse tipo não for genérico.</param>
      <param name="genericMethodArguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Type&quot; /&gt; objects representing the generic type arguments of the method where the token is in scope, or &lt;see langword=&quot;null&quot; /&gt; if that method is not generic.">Uma matriz de objetos <see cref="T:System.Type" /> que representam os argumentos de tipo genérico do método em que o token está no escopo ou <see langword="null" /> se esse método não for genérico.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.FieldInfo&quot; /&gt; object representing the field that is identified by the specified metadata token.">Um objeto <see cref="T:System.Reflection.FieldInfo" /> que representa o campo que é identificado pelo token de metadados especificado.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;metadataToken&quot; /&gt; is not a token for a field in the scope of the current module.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;metadataToken&quot; /&gt; identifies a field whose parent &lt;see langword=&quot;TypeSpec&quot; /&gt; has a signature containing element type &lt;see langword=&quot;var&quot; /&gt; (a type parameter of a generic type) or &lt;see langword=&quot;mvar&quot; /&gt; (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of &lt;paramref name=&quot;genericTypeArguments&quot; /&gt; and &lt;paramref name=&quot;genericMethodArguments&quot; /&gt;.">
        <paramref name="metadataToken" /> não é um token para um campo no escopo do módulo atual.  

ou - 
<paramref name="metadataToken" /> identifica um campo cujo <see langword="TypeSpec" /> pai tem uma assinatura que contém o tipo de elemento <see langword="var" /> (um parâmetro de tipo de um tipo genérico) ou <see langword="mvar" /> (um parâmetro de tipo de um método genérico) e os argumentos de tipo genérico necessários não foram fornecidos para <paramref name="genericTypeArguments" /> ou <paramref name="genericMethodArguments" /> ou ambos.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;metadataToken&quot; /&gt; is not a valid token in the scope of the current module.">
        <paramref name="metadataToken" /> não é um token válido no escopo do módulo atual.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
      <summary vsli:raw="Returns the type or member identified by the specified metadata token, in the context defined by the specified generic type parameters.">Retorna o tipo ou o membro identificado pelo token de metadados especificado, no contexto definido pelos parâmetros de tipo genérico especificados.</summary>
      <param name="metadataToken" vsli:raw="A metadata token that identifies a type or member in the module.">Um token de metadados que identifica um tipo ou membro no módulo.</param>
      <param name="genericTypeArguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Type&quot; /&gt; objects representing the generic type arguments of the type where the token is in scope, or &lt;see langword=&quot;null&quot; /&gt; if that type is not generic.">Uma matriz de objetos <see cref="T:System.Type" /> que representam os argumentos de tipo genérico do tipo em que o token está no escopo ou <see langword="null" /> se esse tipo não for genérico.</param>
      <param name="genericMethodArguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Type&quot; /&gt; objects representing the generic type arguments of the method where the token is in scope, or &lt;see langword=&quot;null&quot; /&gt; if that method is not generic.">Uma matriz de objetos <see cref="T:System.Type" /> que representam os argumentos de tipo genérico do método em que o token está no escopo ou <see langword="null" /> se esse método não for genérico.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; object representing the type or member that is identified by the specified metadata token.">Um objeto <see cref="T:System.Reflection.MemberInfo" /> que representa o tipo ou o membro que é identificado pelo token de metadados especificado.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;metadataToken&quot; /&gt; is not a token for a type or member in the scope of the current module.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;metadataToken&quot; /&gt; is a &lt;see langword=&quot;MethodSpec&quot; /&gt; or &lt;see langword=&quot;TypeSpec&quot; /&gt; whose signature contains element type &lt;see langword=&quot;var&quot; /&gt; (a type parameter of a generic type) or &lt;see langword=&quot;mvar&quot; /&gt; (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of &lt;paramref name=&quot;genericTypeArguments&quot; /&gt; and &lt;paramref name=&quot;genericMethodArguments&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;metadataToken&quot; /&gt; identifies a property or event.">
        <paramref name="metadataToken" /> não é um token para um tipo ou membro no escopo do módulo atual.  

ou - 
<paramref name="metadataToken" /> é um <see langword="MethodSpec" /> ou <see langword="TypeSpec" /> cuja assinatura contém o tipo de elemento <see langword="var" /> (um parâmetro de tipo de um tipo genérico) ou <see langword="mvar" /> (um parâmetro de tipo de um método genérico) e os argumentos de tipo genérico necessários não foram fornecidos para <paramref name="genericTypeArguments" /> ou <paramref name="genericMethodArguments" /> ou ambos.  

ou - 
<paramref name="metadataToken" /> identifica uma propriedade ou evento.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;metadataToken&quot; /&gt; is not a valid token in the scope of the current module.">
        <paramref name="metadataToken" /> não é um token válido no escopo do módulo atual.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
      <summary vsli:raw="Returns the method or constructor identified by the specified metadata token, in the context defined by the specified generic type parameters.">Retorna o método ou o construtor identificado pelo token de metadados especificado, no contexto definido pelos parâmetros de tipo genérico especificados.</summary>
      <param name="metadataToken" vsli:raw="A metadata token that identifies a method or constructor in the module.">Um token de metadados que identifica um método ou um construtor no módulo.</param>
      <param name="genericTypeArguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Type&quot; /&gt; objects representing the generic type arguments of the type where the token is in scope, or &lt;see langword=&quot;null&quot; /&gt; if that type is not generic.">Uma matriz de objetos <see cref="T:System.Type" /> que representam os argumentos de tipo genérico do tipo em que o token está no escopo ou <see langword="null" /> se esse tipo não for genérico.</param>
      <param name="genericMethodArguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Type&quot; /&gt; objects representing the generic type arguments of the method where the token is in scope, or &lt;see langword=&quot;null&quot; /&gt; if that method is not generic.">Uma matriz de objetos <see cref="T:System.Type" /> que representam os argumentos de tipo genérico do método em que o token está no escopo ou <see langword="null" /> se esse método não for genérico.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodBase&quot; /&gt; object representing the method that is identified by the specified metadata token.">Um objeto <see cref="T:System.Reflection.MethodBase" /> que representa o método que é identificado pelo token de metadados especificado.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;metadataToken&quot; /&gt; is not a token for a method or constructor in the scope of the current module.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;metadataToken&quot; /&gt; is a &lt;see langword=&quot;MethodSpec&quot; /&gt; whose signature contains element type &lt;see langword=&quot;var&quot; /&gt; (a type parameter of a generic type) or &lt;see langword=&quot;mvar&quot; /&gt; (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of &lt;paramref name=&quot;genericTypeArguments&quot; /&gt; and &lt;paramref name=&quot;genericMethodArguments&quot; /&gt;.">
        <paramref name="metadataToken" /> não é um token de um método ou construtor no escopo do módulo atual.  

ou - 
<paramref name="metadataToken" /> é um <see langword="MethodSpec" /> cuja assinatura contém o tipo de elemento <see langword="var" /> (um parâmetro de tipo de um tipo genérico) ou <see langword="mvar" /> (um parâmetro de tipo de um método genérico) e os argumentos de tipo genérico necessários não foram fornecidos para <paramref name="genericTypeArguments" /> ou <paramref name="genericMethodArguments" />, ou para ambos.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;metadataToken&quot; /&gt; is not a valid token in the scope of the current module.">
        <paramref name="metadataToken" /> não é um token válido no escopo do módulo atual.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.ResolveSignature(System.Int32)">
      <summary vsli:raw="Returns the signature blob identified by a metadata token.">Retorna o blob de assinatura identificado por um token de metadados.</summary>
      <param name="metadataToken" vsli:raw="A metadata token that identifies a signature in the module.">Um token de metadados que identifica uma assinatura no módulo.</param>
      <returns vsli:raw="An array of bytes representing the signature blob.">Uma matriz de bytes que representa o blob de assinatura.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;metadataToken&quot; /&gt; is not a valid &lt;see langword=&quot;MemberRef&quot; /&gt;, &lt;see langword=&quot;MethodDef&quot; /&gt;, &lt;see langword=&quot;TypeSpec&quot; /&gt;, signature, or &lt;see langword=&quot;FieldDef&quot; /&gt; token in the scope of the current module.">
        <paramref name="metadataToken" /> não é um <see langword="MemberRef" />, <see langword="MethodDef" />, <see langword="TypeSpec" />, assinatura ou token <see langword="FieldDef" /> válido no escopo do módulo atual.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;metadataToken&quot; /&gt; is not a valid token in the scope of the current module.">
        <paramref name="metadataToken" /> não é um token válido no escopo do módulo atual.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.ResolveString(System.Int32)">
      <summary vsli:raw="Returns the string identified by the specified metadata token.">Retorna a cadeia de caracteres identificada pelo token de metadados especificado.</summary>
      <param name="metadataToken" vsli:raw="A metadata token that identifies a string in the string heap of the module.">Um token de metadados que identifica uma cadeia de caracteres no heap de cadeia de caracteres do módulo.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.String&quot; /&gt; containing a string value from the metadata string heap.">Um <see cref="T:System.String" /> que contém um valor de cadeia de caracteres do heap de cadeia de caracteres de metadados.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;metadataToken&quot; /&gt; is not a token for a string in the scope of the current module.">
        <paramref name="metadataToken" /> não é um token para uma cadeia de caracteres no escopo do módulo atual.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;metadataToken&quot; /&gt; is not a valid token in the scope of the current module.">
        <paramref name="metadataToken" /> não é um token válido no escopo do módulo atual.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
      <summary vsli:raw="Returns the type identified by the specified metadata token, in the context defined by the specified generic type parameters.">Retorna o tipo identificado pelo token de metadados especificado no contexto definido pelos parâmetros de tipo genérico especificados.</summary>
      <param name="metadataToken" vsli:raw="A metadata token that identifies a type in the module.">Um token de metadados que identifica um tipo no módulo.</param>
      <param name="genericTypeArguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Type&quot; /&gt; objects representing the generic type arguments of the type where the token is in scope, or &lt;see langword=&quot;null&quot; /&gt; if that type is not generic.">Uma matriz de objetos <see cref="T:System.Type" /> que representam os argumentos de tipo genérico do tipo em que o token está no escopo ou <see langword="null" /> se esse tipo não for genérico.</param>
      <param name="genericMethodArguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Type&quot; /&gt; objects representing the generic type arguments of the method where the token is in scope, or &lt;see langword=&quot;null&quot; /&gt; if that method is not generic.">Uma matriz de objetos <see cref="T:System.Type" /> que representam os argumentos de tipo genérico do método em que o token está no escopo ou <see langword="null" /> se esse método não for genérico.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the type that is identified by the specified metadata token.">Um objeto <see cref="T:System.Type" /> que representa o tipo que é identificado pelo token de metadados especificado.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;metadataToken&quot; /&gt; is not a token for a type in the scope of the current module.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;metadataToken&quot; /&gt; is a &lt;see langword=&quot;TypeSpec&quot; /&gt; whose signature contains element type &lt;see langword=&quot;var&quot; /&gt; (a type parameter of a generic type) or &lt;see langword=&quot;mvar&quot; /&gt; (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of &lt;paramref name=&quot;genericTypeArguments&quot; /&gt; and &lt;paramref name=&quot;genericMethodArguments&quot; /&gt;.">
        <paramref name="metadataToken" /> não é um token para um tipo no escopo do módulo atual.  

ou - 
<paramref name="metadataToken" /> é um <see langword="TypeSpec" /> cuja assinatura contém o tipo de elemento <see langword="var" /> (um parâmetro de tipo de um tipo genérico) ou <see langword="mvar" /> (um parâmetro de tipo de um método genérico) e os argumentos de tipo genérico necessários não foram fornecidos para <paramref name="genericTypeArguments" /> ou <paramref name="genericMethodArguments" />, ou para ambos.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;metadataToken&quot; /&gt; is not a valid token in the scope of the current module.">
        <paramref name="metadataToken" /> não é um token válido no escopo do módulo atual.</exception>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.ScopeName">
      <summary vsli:raw="Gets a string that represents the name of the dynamic module.">Obtém uma cadeia de caracteres que representa o nome do módulo dinâmico.</summary>
      <returns vsli:raw="The name of the dynamic module.">O nome do módulo dinâmico.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary vsli:raw="Applies a custom attribute to this module by using a specified binary large object (BLOB) that represents the attribute.">Aplica um atributo personalizado a esse módulo usando um BLOB (objeto binário grande) especificado que representa o atributo.</summary>
      <param name="con" vsli:raw="The constructor for the custom attribute.">O construtor do atributo personalizado.</param>
      <param name="binaryAttribute" vsli:raw="A byte BLOB representing the attribute.">Um BLOB de Byte que representa o atributo.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;con&quot; /&gt; or &lt;paramref name=&quot;binaryAttribute&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="con" /> ou <paramref name="binaryAttribute" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary vsli:raw="Applies a custom attribute to this module by using a custom attribute builder.">Aplica um atributo personalizado a esse módulo usando um construtor de atributo personalizado.</summary>
      <param name="customBuilder" vsli:raw="An instance of a helper class that specifies the custom attribute to apply.">Uma instância de uma classe auxiliar que especifica o atributo personalizado a aplicar.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;customBuilder&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="customBuilder" /> é <see langword="null" />.</exception>
    </member>
    <member name="T:System.Reflection.Emit.PropertyBuilder">
      <summary vsli:raw="Defines the properties for a type.">Define as propriedades de um tipo.</summary>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.AddOtherMethod(System.Reflection.Emit.MethodBuilder)">
      <summary vsli:raw="Adds one of the other methods associated with this property.">Adiciona um dos outros métodos associados a essa propriedade.</summary>
      <param name="mdBuilder" vsli:raw="A &lt;see langword=&quot;MethodBuilder&quot; /&gt; object that represents the other method.">Um objeto <see langword="MethodBuilder" /> que representa o outro método.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;mdBuilder&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="mdBuilder" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt; has been called on the enclosing type.">O <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> foi chamado no tipo de delimitador.</exception>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.Attributes">
      <summary vsli:raw="Gets the attributes for this property.">Obtém os atributos desta propriedade.</summary>
      <returns vsli:raw="Attributes of this property.">Atributos desta propriedade.</returns>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.CanRead">
      <summary vsli:raw="Gets a value indicating whether the property can be read.">Obtém um valor que indica se a propriedade pode ser lida.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if this property can be read; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se essa propriedade puder ser lida; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.CanWrite">
      <summary vsli:raw="Gets a value indicating whether the property can be written to.">Obtém um valor que indica se a propriedade pode ser usada para gravação.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if this property can be written to; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se essa propriedade puder ser usada para gravação; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.DeclaringType">
      <summary vsli:raw="Gets the class that declares this member.">Obtém a classe que declara esse membro.</summary>
      <returns vsli:raw="The &lt;see langword=&quot;Type&quot; /&gt; object for the class that declares this member.">O objeto <see langword="Type" /> para a classe que declara esse membro.</returns>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetAccessors(System.Boolean)">
      <summary vsli:raw="Returns an array of the public and non-public &lt;see langword=&quot;get&quot; /&gt; and &lt;see langword=&quot;set&quot; /&gt; accessors on this property.">Retorna uma matriz de acessadores <see langword="get" /> e <see langword="set" /> públicos e não públicos nesta propriedade.</summary>
      <param name="nonPublic" vsli:raw="Indicates whether non-public methods should be returned in the &lt;see langword=&quot;MethodInfo&quot; /&gt; array. &lt;see langword=&quot;true&quot; /&gt; if non-public methods are to be included; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Indica se os métodos não públicos devem ser retornados na matriz <see langword="MethodInfo" />. <see langword="true" /> se os métodos não públicos devem ser incluídos; caso contrário, <see langword="false" />.</param>
      <returns vsli:raw="An array of type &lt;see langword=&quot;MethodInfo&quot; /&gt; containing the matching public or non-public accessors, or an empty array if matching accessors do not exist on this property.">Uma matriz do tipo <see langword="MethodInfo" /> que contém os acessadores públicos ou não públicos correspondentes ou uma matriz vazia, se não houver acessadores correspondentes nesta propriedade.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not supported.">Não há suporte para o método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetCustomAttributes(System.Boolean)">
      <summary vsli:raw="Returns an array of all the custom attributes for this property.">Retorna uma matriz de todos os atributos personalizados para essa propriedade.</summary>
      <param name="inherit" vsli:raw="If &lt;see langword=&quot;true&quot; /&gt;, walks up this property's inheritance chain to find the custom attributes.">Se <see langword="true" />, percorrerá a cadeia de herança dessa propriedade para localizar os atributos personalizados</param>
      <returns vsli:raw="An array of all the custom attributes.">Uma matriz de todos os atributos personalizados.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not supported.">Não há suporte para o método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary vsli:raw="Returns an array of custom attributes identified by &lt;see cref=&quot;T:System.Type&quot; /&gt;.">Retorna uma matriz de atributos personalizados identificados por <see cref="T:System.Type" />.</summary>
      <param name="attributeType" vsli:raw="An array of custom attributes identified by type.">Uma matriz de atributos personalizados identificados por tipo.</param>
      <param name="inherit" vsli:raw="If &lt;see langword=&quot;true&quot; /&gt;, walks up this property's inheritance chain to find the custom attributes.">Se <see langword="true" />, percorrerá a cadeia de herança dessa propriedade para localizar os atributos personalizados.</param>
      <returns vsli:raw="An array of custom attributes defined on this reflected member, or &lt;see langword=&quot;null&quot; /&gt; if no attributes are defined on this member.">Uma matriz de atributos personalizados definidos neste membro refletido ou <see langword="null" />, se nenhum atributo estiver definido neste membro.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not supported.">Não há suporte para o método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetGetMethod(System.Boolean)">
      <summary vsli:raw="Returns the public and non-public get accessor for this property.">Retorna o acessador get público e não público para essa propriedade.</summary>
      <param name="nonPublic" vsli:raw="Indicates whether non-public get accessors should be returned. &lt;see langword=&quot;true&quot; /&gt; if non-public methods are to be included; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Indica se os acessadores get não públicos devem ser retornados. <see langword="true" /> se os métodos não públicos devem ser incluídos; caso contrário, <see langword="false" />.</param>
      <returns vsli:raw="A &lt;see langword=&quot;MethodInfo&quot; /&gt; object representing the get accessor for this property, if &lt;paramref name=&quot;nonPublic&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;. Returns &lt;see langword=&quot;null&quot; /&gt; if &lt;paramref name=&quot;nonPublic&quot; /&gt; is &lt;see langword=&quot;false&quot; /&gt; and the get accessor is non-public, or if &lt;paramref name=&quot;nonPublic&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt; but no get accessors exist.">Um objeto <see langword="MethodInfo" /> que representa o acessador get para essa propriedade, se <paramref name="nonPublic" /> for <see langword="true" />. Retorna <see langword="null" /> se <paramref name="nonPublic" /> for <see langword="false" /> e o acessador get não for público ou, se <paramref name="nonPublic" /> for <see langword="true" />, mas nenhum acessador get existir.</returns>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetIndexParameters">
      <summary vsli:raw="Returns an array of all the index parameters for the property.">Retorna uma matriz de todos os parâmetros de índice para a propriedade.</summary>
      <returns vsli:raw="An array of type &lt;see langword=&quot;ParameterInfo&quot; /&gt; containing the parameters for the indexes.">Uma matriz do tipo <see langword="ParameterInfo" /> que contém os parâmetros dos índices.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not supported.">Não há suporte para o método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetSetMethod(System.Boolean)">
      <summary vsli:raw="Returns the set accessor for this property.">Retorna o acessador set para essa propriedade.</summary>
      <param name="nonPublic" vsli:raw="Indicates whether the accessor should be returned if it is non-public. &lt;see langword=&quot;true&quot; /&gt; if non-public methods are to be included; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Indica se o acessador deverá ser retornado se ele não for público. <see langword="true" /> se os métodos não públicos devem ser incluídos; caso contrário, <see langword="false" />.</param>
      <returns vsli:raw="The property's &lt;see langword=&quot;Set&quot; /&gt; method, or &lt;see langword=&quot;null&quot; /&gt;, as shown in the following table.  &#xA;  &#xA; &lt;list type=&quot;table&quot;&gt;&lt;listheader&gt;&lt;term&gt; Value&lt;/term&gt;&lt;description&gt; Condition&lt;/description&gt;&lt;/listheader&gt;&lt;item&gt;&lt;term&gt; A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; object representing the Set method for this property.&lt;/term&gt;&lt;description&gt; The set accessor is public.  &#xA;  &#xA; &lt;paramref name=&quot;nonPublic&quot; /&gt; is true and non-public methods can be returned.&lt;/description&gt;&lt;/item&gt;&lt;item&gt;&lt;term&gt; null&lt;/term&gt;&lt;description&gt;&lt;paramref name=&quot;nonPublic&quot; /&gt; is true, but the property is read-only.  &#xA;  &#xA; &lt;paramref name=&quot;nonPublic&quot; /&gt; is false and the set accessor is non-public.&lt;/description&gt;&lt;/item&gt;&lt;/list&gt;">O método <see langword="Set" /> da propriedade ou <see langword="null" />, conforme mostrado na tabela a seguir.  
  Valor 
  Condição 
  Um objeto <see cref="T:System.Reflection.MethodInfo" /> que representa o método Set para essa propriedade.  

  O acessador set é público.  

 <paramref name="nonPublic" /> é verdadeiro e métodos não públicos podem ser retornados.  

  nulo 
 <paramref name="nonPublic" /> é true, mas a propriedade é somente leitura.  

 <paramref name="nonPublic" /> é false e o conjunto de acessador é não público.</returns>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetValue(System.Object,System.Object[])">
      <summary vsli:raw="Gets the value of the indexed property by calling the property's getter method.">Obtém o valor da propriedade indexada chamando o método getter da propriedade.</summary>
      <param name="obj" vsli:raw="The object whose property value will be returned.">O objeto cujo valor da propriedade será retornado.</param>
      <param name="index" vsli:raw="Optional index values for indexed properties. This value should be &lt;see langword=&quot;null&quot; /&gt; for non-indexed properties.">Valores de índice opcionais para propriedades indexadas. Esse valor deve ser <see langword="null" /> para propriedades não indexadas.</param>
      <returns vsli:raw="The value of the specified indexed property.">O valor da propriedade indexada especificada.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not supported.">Não há suporte para o método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetValue(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
      <summary vsli:raw="Gets the value of a property having the specified binding, index, and &lt;see langword=&quot;CultureInfo&quot; /&gt;.">Obtém o valor de uma propriedade com a associação, o índice e o <see langword="CultureInfo" /> especificados.</summary>
      <param name="obj" vsli:raw="The object whose property value will be returned.">O objeto cujo valor da propriedade será retornado.</param>
      <param name="invokeAttr" vsli:raw="The invocation attribute. This must be a bit flag from &lt;see langword=&quot;BindingFlags&quot; /&gt; : &lt;see langword=&quot;InvokeMethod&quot; /&gt;, &lt;see langword=&quot;CreateInstance&quot; /&gt;, &lt;see langword=&quot;Static&quot; /&gt;, &lt;see langword=&quot;GetField&quot; /&gt;, &lt;see langword=&quot;SetField&quot; /&gt;, &lt;see langword=&quot;GetProperty&quot; /&gt;, or &lt;see langword=&quot;SetProperty&quot; /&gt;. A suitable invocation attribute must be specified. If a static member is to be invoked, the &lt;see langword=&quot;Static&quot; /&gt; flag of &lt;see langword=&quot;BindingFlags&quot; /&gt; must be set.">O atributo de invocação. Isso deve ser um sinalizador de bit de <see langword="BindingFlags" /> : <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="Static" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> ou <see langword="SetProperty" />. É necessário especificar um atributo de invocação adequado. Caso um membro estático deva ser chamado, o sinalizador <see langword="Static" /> de <see langword="BindingFlags" /> deverá ser definido.</param>
      <param name="binder" vsli:raw="An object that enables the binding, coercion of argument types, invocation of members, and retrieval of &lt;see langword=&quot;MemberInfo&quot; /&gt; objects using reflection. If &lt;paramref name=&quot;binder&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;, the default binder is used.">Um objeto que permite a associação, a coerção de tipos de argumento, a invocação de membros e a recuperação de objetos <see langword="MemberInfo" /> usando reflexão. Caso <paramref name="binder" /> seja <see langword="null" />, o associador padrão é usado.</param>
      <param name="index" vsli:raw="Optional index values for indexed properties. This value should be &lt;see langword=&quot;null&quot; /&gt; for non-indexed properties.">Valores de índice opcionais para propriedades indexadas. Esse valor deve ser <see langword="null" /> para propriedades não indexadas.</param>
      <param name="culture" vsli:raw="The &lt;see langword=&quot;CultureInfo&quot; /&gt; object that represents the culture for which the resource is to be localized. Note that if the resource is not localized for this culture, the &lt;see langword=&quot;CultureInfo.Parent&quot; /&gt; method will be called successively in search of a match. If this value is &lt;see langword=&quot;null&quot; /&gt;, the &lt;see langword=&quot;CultureInfo&quot; /&gt; is obtained from the &lt;see langword=&quot;CultureInfo.CurrentUICulture&quot; /&gt; property.">O objeto <see langword="CultureInfo" /> que representa a cultura para qual o recurso deve ser localizado. Observe que se o recurso não estiver localizado para essa cultura, o método <see langword="CultureInfo.Parent" /> será chamado sucessivamente pesquisando uma correspondência. Se esse valor for <see langword="null" />, o <see langword="CultureInfo" /> será obtido da propriedade <see langword="CultureInfo.CurrentUICulture" />.</param>
      <returns vsli:raw="The property value for &lt;paramref name=&quot;obj&quot; /&gt;.">O valor da propriedade <paramref name="obj" />.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not supported.">Não há suporte para o método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.IsDefined(System.Type,System.Boolean)">
      <summary vsli:raw="Indicates whether one or more instance of &lt;paramref name=&quot;attributeType&quot; /&gt; is defined on this property.">Indica se uma ou mais instância de <paramref name="attributeType" /> está definida nessa propriedade.</summary>
      <param name="attributeType" vsli:raw="The &lt;see langword=&quot;Type&quot; /&gt; object to which the custom attributes are applied.">O objeto <see langword="Type" /> ao qual os atributos personalizados são aplicados.</param>
      <param name="inherit" vsli:raw="Specifies whether to walk up this property's inheritance chain to find the custom attributes.">Especifica se deve percorrer cadeia de herança dessa propriedade para localizar os atributos personalizados.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if one or more instance of &lt;paramref name=&quot;attributeType&quot; /&gt; is defined on this property; otherwise &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se um ou mais instância de <paramref name="attributeType" /> estiver definida nessa propriedade; caso contrário <see langword="false" />.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not supported.">Não há suporte para o método.</exception>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.Module">
      <summary vsli:raw="Gets the module in which the type that declares the current property is being defined.">Obtém o módulo no qual o tipo que declara a propriedade atual está sendo definido.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Reflection.Module&quot; /&gt; in which the type that declares the current property is defined.">O <see cref="T:System.Reflection.Module" /> no qual o tipo que declara a propriedade Current é definido.</returns>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.Name">
      <summary vsli:raw="Gets the name of this member.">Obtém o nome desse membro.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.String&quot; /&gt; containing the name of this member.">Um <see cref="T:System.String" /> que contém o nome do computador.</returns>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.PropertyType">
      <summary vsli:raw="Gets the type of the field of this property.">Obtém o tipo do campo dessa propriedade.</summary>
      <returns vsli:raw="The type of this property.">O tipo dessa propriedade.</returns>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.ReflectedType">
      <summary vsli:raw="Gets the class object that was used to obtain this instance of &lt;see langword=&quot;MemberInfo&quot; /&gt;.">Obtém o objeto de classe que foi usado para obter esta instância de <see langword="MemberInfo" />.</summary>
      <returns vsli:raw="The &lt;see langword=&quot;Type&quot; /&gt; object through which this &lt;see langword=&quot;MemberInfo&quot; /&gt; object was obtained.">O objeto <see langword="Type" /> por meio do qual este objeto <see langword="MemberInfo" /> foi obtido.</returns>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetConstant(System.Object)">
      <summary vsli:raw="Sets the default value of this property.">Define o valor padrão dessa propriedade.</summary>
      <param name="defaultValue" vsli:raw="The default value of this property.">O valor padrão dessa propriedade.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt; has been called on the enclosing type.">O <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> foi chamado no tipo de delimitador.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The property is not one of the supported types.  &#xA;  &#xA; -or-  &#xA;  &#xA; The type of &lt;paramref name=&quot;defaultValue&quot; /&gt; does not match the type of the property.  &#xA;  &#xA; -or-  &#xA;  &#xA; The property is of type &lt;see cref=&quot;T:System.Object&quot; /&gt; or other reference type, &lt;paramref name=&quot;defaultValue&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt;, and the value cannot be assigned to the reference type.">A propriedade não é de um dos tipos com suporte.  

ou - 
O tipo de <paramref name="defaultValue" /> não corresponde ao tipo da propriedade.  

ou - 
A propriedade é do tipo <see cref="T:System.Object" /> ou outro tipo de referência, <paramref name="defaultValue" /> não é <see langword="null" /> e o valor não pode ser atribuído ao tipo de referência.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary vsli:raw="Set a custom attribute using a specified custom attribute blob.">Define um atributo personalizado usando um blob de atributo personalizado especificado.</summary>
      <param name="con" vsli:raw="The constructor for the custom attribute.">O construtor do atributo personalizado.</param>
      <param name="binaryAttribute" vsli:raw="A byte blob representing the attributes.">Um blob de bytes que representa os atributos.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;con&quot; /&gt; or &lt;paramref name=&quot;binaryAttribute&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="con" /> ou <paramref name="binaryAttribute" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt; has been called on the enclosing type.">O <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> foi chamado no tipo de delimitador.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary vsli:raw="Set a custom attribute using a custom attribute builder.">Defina um atributo personalizado usando um construtor de atributos personalizados.</summary>
      <param name="customBuilder" vsli:raw="An instance of a helper class to define the custom attribute.">Uma instância de uma classe auxiliar para definir o atributo personalizado.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;customBuilder&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="customBuilder" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="if &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt; has been called on the enclosing type.">Se <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> foi chamado no tipo de delimitador.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetGetMethod(System.Reflection.Emit.MethodBuilder)">
      <summary vsli:raw="Sets the method that gets the property value.">Define o método que obtém o valor da propriedade.</summary>
      <param name="mdBuilder" vsli:raw="A &lt;see langword=&quot;MethodBuilder&quot; /&gt; object that represents the method that gets the property value.">Um objeto <see langword="MethodBuilder" /> que representa o método que obtém o valor da propriedade.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;mdBuilder&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="mdBuilder" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt; has been called on the enclosing type.">O <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> foi chamado no tipo de delimitador.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetSetMethod(System.Reflection.Emit.MethodBuilder)">
      <summary vsli:raw="Sets the method that sets the property value.">Define o método que define o valor da propriedade.</summary>
      <param name="mdBuilder" vsli:raw="A &lt;see langword=&quot;MethodBuilder&quot; /&gt; object that represents the method that sets the property value.">Um objeto <see langword="MethodBuilder" /> que representa o método que define o valor da propriedade.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;mdBuilder&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="mdBuilder" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt; has been called on the enclosing type.">O <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> foi chamado no tipo de delimitador.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetValue(System.Object,System.Object,System.Object[])">
      <summary vsli:raw="Sets the value of the property with optional index values for index properties.">Define o valor da propriedade com valores de índice opcionais para propriedades do índice.</summary>
      <param name="obj" vsli:raw="The object whose property value will be set.">O objeto cujo valor da propriedade será definido.</param>
      <param name="value" vsli:raw="The new value for this property.">O novo valor dessa propriedade.</param>
      <param name="index" vsli:raw="Optional index values for indexed properties. This value should be &lt;see langword=&quot;null&quot; /&gt; for non-indexed properties.">Valores de índice opcionais para propriedades indexadas. Esse valor deve ser <see langword="null" /> para propriedades não indexadas.</param>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not supported.">Não há suporte para o método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
      <summary vsli:raw="Sets the property value for the given object to the given value.">Define o valor da propriedade para o objeto fornecido para o valor fornecido.</summary>
      <param name="obj" vsli:raw="The object whose property value will be returned.">O objeto cujo valor da propriedade será retornado.</param>
      <param name="value" vsli:raw="The new value for this property.">O novo valor dessa propriedade.</param>
      <param name="invokeAttr" vsli:raw="The invocation attribute. This must be a bit flag from &lt;see langword=&quot;BindingFlags&quot; /&gt; : &lt;see langword=&quot;InvokeMethod&quot; /&gt;, &lt;see langword=&quot;CreateInstance&quot; /&gt;, &lt;see langword=&quot;Static&quot; /&gt;, &lt;see langword=&quot;GetField&quot; /&gt;, &lt;see langword=&quot;SetField&quot; /&gt;, &lt;see langword=&quot;GetProperty&quot; /&gt;, or &lt;see langword=&quot;SetProperty&quot; /&gt;. A suitable invocation attribute must be specified. If a static member is to be invoked, the &lt;see langword=&quot;Static&quot; /&gt; flag of &lt;see langword=&quot;BindingFlags&quot; /&gt; must be set.">O atributo de invocação. Isso deve ser um sinalizador de bit de <see langword="BindingFlags" /> : <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="Static" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> ou <see langword="SetProperty" />. É necessário especificar um atributo de invocação adequado. Caso um membro estático deva ser chamado, o sinalizador <see langword="Static" /> de <see langword="BindingFlags" /> deverá ser definido.</param>
      <param name="binder" vsli:raw="An object that enables the binding, coercion of argument types, invocation of members, and retrieval of &lt;see langword=&quot;MemberInfo&quot; /&gt; objects using reflection. If &lt;paramref name=&quot;binder&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;, the default binder is used.">Um objeto que permite a associação, a coerção de tipos de argumento, a invocação de membros e a recuperação de objetos <see langword="MemberInfo" /> usando reflexão. Caso <paramref name="binder" /> seja <see langword="null" />, o associador padrão é usado.</param>
      <param name="index" vsli:raw="Optional index values for indexed properties. This value should be &lt;see langword=&quot;null&quot; /&gt; for non-indexed properties.">Valores de índice opcionais para propriedades indexadas. Esse valor deve ser <see langword="null" /> para propriedades não indexadas.</param>
      <param name="culture" vsli:raw="The &lt;see langword=&quot;CultureInfo&quot; /&gt; object that represents the culture for which the resource is to be localized. Note that if the resource is not localized for this culture, the &lt;see langword=&quot;CultureInfo.Parent&quot; /&gt; method will be called successively in search of a match. If this value is &lt;see langword=&quot;null&quot; /&gt;, the &lt;see langword=&quot;CultureInfo&quot; /&gt; is obtained from the &lt;see langword=&quot;CultureInfo.CurrentUICulture&quot; /&gt; property.">O objeto <see langword="CultureInfo" /> que representa a cultura para qual o recurso deve ser localizado. Observe que se o recurso não estiver localizado para essa cultura, o método <see langword="CultureInfo.Parent" /> será chamado sucessivamente pesquisando uma correspondência. Se esse valor for <see langword="null" />, o <see langword="CultureInfo" /> será obtido da propriedade <see langword="CultureInfo.CurrentUICulture" />.</param>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not supported.">Não há suporte para o método.</exception>
    </member>
    <member name="T:System.Reflection.Emit.TypeBuilder">
      <summary vsli:raw="Defines and creates new instances of classes during run time.">Define e cria novas instâncias de classes no tempo de execução.</summary>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)">
      <summary vsli:raw="Adds an interface that this type implements.">Adiciona uma interface implementada por esse tipo.</summary>
      <param name="interfaceType" vsli:raw="The interface that this type implements.">A interface implementada por esse tipo.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;interfaceType&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="interfaceType" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The type was previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.Assembly">
      <summary vsli:raw="Retrieves the dynamic assembly that contains this type definition.">Recupera o assembly dinâmico que contém essa definição de tipo.</summary>
      <returns vsli:raw="Read-only. Retrieves the dynamic assembly that contains this type definition.">Somente leitura. Recupera o assembly dinâmico que contém essa definição de tipo.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName">
      <summary vsli:raw="Returns the full name of this type qualified by the display name of the assembly.">Retorna o nome completo desse tipo qualificado pelo nome de exibição do assembly.</summary>
      <returns vsli:raw="Read-only. The full name of this type qualified by the display name of the assembly.">Somente leitura. O nome completo desse tipo qualificado pelo nome de exibição do assembly.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.BaseType">
      <summary vsli:raw="Retrieves the base type of this type.">Recupera o tipo base deste tipo.</summary>
      <returns vsli:raw="Read-only. Retrieves the base type of this type.">Somente leitura. Recupera o tipo base deste tipo.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.CreateType">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Type&quot; /&gt; object for the class. After defining fields and methods on the class, &lt;see langword=&quot;CreateType&quot; /&gt; is called in order to load its &lt;see langword=&quot;Type&quot; /&gt; object.">Cria um objeto <see cref="T:System.Type" /> para a classe. Depois de definir campos e métodos na classe, <see langword="CreateType" /> é chamado para carregar seu objeto <see langword="Type" />.</summary>
      <returns vsli:raw="Returns the new &lt;see cref=&quot;T:System.Type&quot; /&gt; object for this class.">Retorna o novo objeto <see cref="T:System.Type" /> dessa classe.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The enclosing type has not been created.  &#xA;  &#xA; -or-  &#xA;  &#xA; This type is non-abstract and contains an abstract method.  &#xA;  &#xA; -or-  &#xA;  &#xA; This type is not an abstract class or an interface and has a method without a method body.">O tipo delimitador não foi criado.  

ou -  

 Esse tipo é não abstrato e contém um método abstrato.  

ou -  

 Esse tipo não é uma classe abstrata nem uma interface e tem um método sem um corpo do método.</exception>
      <exception cref="T:System.NotSupportedException" vsli:raw="The type contains invalid Microsoft intermediate language (MSIL) code.  &#xA;  &#xA; -or-  &#xA;  &#xA; The branch target is specified using a 1-byte offset, but the target is at a distance greater than 127 bytes from the branch.">O tipo contém código MSIL (Microsoft Intermediate Language) inválido.  

ou -  

 O destino da ramificação é especificado usando um deslocamento de 1 byte, mas está em uma distância maior que 127 bytes da ramificação.</exception>
      <exception cref="T:System.TypeLoadException" vsli:raw="The type cannot be loaded. For example, it contains a &lt;see langword=&quot;static&quot; /&gt; method that has the calling convention &lt;see cref=&quot;F:System.Reflection.CallingConventions.HasThis&quot; /&gt;.">O tipo não pode ser carregado. Por exemplo, contém um método <see langword="static" /> com a convenção de chamada <see cref="F:System.Reflection.CallingConventions.HasThis" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.CreateTypeInfo">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Reflection.TypeInfo&quot; /&gt; object that represents this type.">Obtém um objeto <see cref="T:System.Reflection.TypeInfo" /> que representa esse tipo.</summary>
      <returns vsli:raw="An object that represents this type.">Um objeto que representa esse tipo.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.DeclaringMethod">
      <summary vsli:raw="Gets the method that declared the current generic type parameter.">Obtém o método que declarou o parâmetro de tipo genérico atual.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodBase&quot; /&gt; that represents the method that declared the current type, if the current type is a generic type parameter; otherwise, &lt;see langword=&quot;null&quot; /&gt;.">Um <see cref="T:System.Reflection.MethodBase" /> que representa o método que declarou o tipo atual, se o tipo atual for um parâmetro de tipo genérico; caso <see langword="null" />contrário,.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.DeclaringType">
      <summary vsli:raw="Returns the type that declared this type.">Retorna o tipo que declarou esse tipo.</summary>
      <returns vsli:raw="Read-only. The type that declared this type.">Somente leitura. O tipo que declarou este tipo.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
      <summary vsli:raw="Adds a new constructor to the type, with the given attributes and signature.">Adiciona um novo construtor ao tipo, com a assinatura e os atributos determinados.</summary>
      <param name="attributes" vsli:raw="The attributes of the constructor.">Os atributos do construtor.</param>
      <param name="callingConvention" vsli:raw="The calling convention of the constructor.">A convenção de chamada do construtor.</param>
      <param name="parameterTypes" vsli:raw="The parameter types of the constructor.">Os tipos de parâmetro do construtor.</param>
      <returns vsli:raw="The defined constructor.">O construtor definido.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The type was previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
      <summary vsli:raw="Adds a new constructor to the type, with the given attributes, signature, and custom modifiers.">Adiciona um novo construtor ao tipo, com os atributos, a assinatura e os modificadores personalizados determinados.</summary>
      <param name="attributes" vsli:raw="The attributes of the constructor.">Os atributos do construtor.</param>
      <param name="callingConvention" vsli:raw="The calling convention of the constructor.">A convenção de chamada do construtor.</param>
      <param name="parameterTypes" vsli:raw="The parameter types of the constructor.">Os tipos de parâmetro do construtor.</param>
      <param name="requiredCustomModifiers" vsli:raw="An array of arrays of types. Each array of types represents the required custom modifiers for the corresponding parameter, such as &lt;see cref=&quot;T:System.Runtime.CompilerServices.IsConst&quot; /&gt;. If a particular parameter has no required custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt; instead of an array of types. If none of the parameters have required custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt; instead of an array of arrays.">Uma matriz de matrizes de tipos. Cada matriz de tipos representa os modificadores personalizados obrigatórios para o parâmetro correspondente, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />. Se um determinado parâmetro tiver não modificadores personalizados obrigatórios, especifique <see langword="null" /> em vez de uma matriz de tipos. Se nenhum dos parâmetros tiver modificadores personalizados obrigatórios, especifique <see langword="null" /> em vez de uma matriz de matrizes.</param>
      <param name="optionalCustomModifiers" vsli:raw="An array of arrays of types. Each array of types represents the optional custom modifiers for the corresponding parameter, such as &lt;see cref=&quot;T:System.Runtime.CompilerServices.IsConst&quot; /&gt;. If a particular parameter has no optional custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt; instead of an array of types. If none of the parameters have optional custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt; instead of an array of arrays.">Uma matriz de matrizes de tipos. Cada matriz de tipos representa os modificadores personalizados opcionais para o parâmetro correspondente, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />. Se um determinado parâmetro tiver não modificadores personalizados opcionais, especifique <see langword="null" /> em vez de uma matriz de tipos. Se nenhum dos parâmetros tiver modificadores personalizados opcionais, especifique <see langword="null" /> em vez de uma matriz de matrizes.</param>
      <returns vsli:raw="The defined constructor.">O construtor definido.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The size of &lt;paramref name=&quot;requiredCustomModifiers&quot; /&gt; or &lt;paramref name=&quot;optionalCustomModifiers&quot; /&gt; does not equal the size of &lt;paramref name=&quot;parameterTypes&quot; /&gt;.">O tamanho de <paramref name="requiredCustomModifiers" /> ou <paramref name="optionalCustomModifiers" /> não é igual ao tamanho de <paramref name="parameterTypes" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The type was previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; For the current dynamic type, the &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.IsGenericType&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;, but the &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition&quot; /&gt; property is &lt;see langword=&quot;false&quot; /&gt;.">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  

ou - 
Para o tipo dinâmico atual, a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> é <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
      <summary vsli:raw="Defines the parameterless constructor. The constructor defined here will simply call the parameterless constructor of the parent.">Define o construtor sem parâmetros. O construtor definido aqui simplesmente chamará o construtor sem parâmetros do pai.</summary>
      <param name="attributes" vsli:raw="A &lt;see langword=&quot;MethodAttributes&quot; /&gt; object representing the attributes to be applied to the constructor.">Um objeto <see langword="MethodAttributes" /> que representa os atributos a serem aplicados ao construtor.</param>
      <returns vsli:raw="Returns the constructor.">Retorna o construtor.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="The parent type (base type) does not have a parameterless constructor.">O tipo pai (tipo base) não tem um construtor sem parâmetros.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The type was previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; For the current dynamic type, the &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.IsGenericType&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;, but the &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition&quot; /&gt; property is &lt;see langword=&quot;false&quot; /&gt;.">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  

ou - 
Para o tipo dinâmico atual, a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> é <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
      <summary vsli:raw="Adds a new event to the type, with the given name, attributes and event type.">Adiciona um novo evento ao tipo, com o nome, os atributos e o tipo de evento determinados.</summary>
      <param name="name" vsli:raw="The name of the event. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">O nome do evento. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="attributes" vsli:raw="The attributes of the event.">Os atributos do evento.</param>
      <param name="eventtype" vsli:raw="The type of the event.">O tipo do evento.</param>
      <returns vsli:raw="The defined event.">O evento definido.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The length of &lt;paramref name=&quot;name&quot; /&gt; is zero.">O comprimento de <paramref name="name" /> é zero.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;eventtype&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> é <see langword="null" />.  

ou - 
<paramref name="eventtype" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The type was previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
      <summary vsli:raw="Adds a new field to the type, with the given name, attributes, and field type.">Adiciona um novo campo ao tipo, com o nome, os atributos e o tipo de campo determinados.</summary>
      <param name="fieldName" vsli:raw="The name of the field. &lt;paramref name=&quot;fieldName&quot; /&gt; cannot contain embedded nulls.">O nome do campo. <paramref name="fieldName" /> não pode conter nulos inseridos.</param>
      <param name="type" vsli:raw="The type of the field.">O tipo do campo</param>
      <param name="attributes" vsli:raw="The attributes of the field.">Os atributos do campo.</param>
      <returns vsli:raw="The defined field.">O campo definido.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The length of &lt;paramref name=&quot;fieldName&quot; /&gt; is zero.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;type&quot; /&gt; is System.Void.  &#xA;  &#xA; -or-  &#xA;  &#xA; A total size was specified for the parent class of this field.">O comprimento de <paramref name="fieldName" /> é zero.  

ou - 
<paramref name="type" /> é System.Void.  

ou - 
Um tamanho total foi especificado para a classe pai desse campo.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;fieldName&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="fieldName" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The type was previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
      <summary vsli:raw="Adds a new field to the type, with the given name, attributes, field type, and custom modifiers.">Adiciona um novo campo ao tipo, com o nome, os atributos, o tipo de campo e os modificadores personalizados determinados.</summary>
      <param name="fieldName" vsli:raw="The name of the field. &lt;paramref name=&quot;fieldName&quot; /&gt; cannot contain embedded nulls.">O nome do campo. <paramref name="fieldName" /> não pode conter nulos inseridos.</param>
      <param name="type" vsli:raw="The type of the field.">O tipo do campo</param>
      <param name="requiredCustomModifiers" vsli:raw="An array of types representing the required custom modifiers for the field, such as &lt;see cref=&quot;T:Microsoft.VisualC.IsConstModifier&quot; /&gt;.">Uma matriz de tipos que representa os modificadores personalizados obrigatórios para o campo, como <see cref="T:Microsoft.VisualC.IsConstModifier" />.</param>
      <param name="optionalCustomModifiers" vsli:raw="An array of types representing the optional custom modifiers for the field, such as &lt;see cref=&quot;T:Microsoft.VisualC.IsConstModifier&quot; /&gt;.">Uma matriz de tipos que representa os modificadores personalizados opcionais para o campo, como <see cref="T:Microsoft.VisualC.IsConstModifier" />.</param>
      <param name="attributes" vsli:raw="The attributes of the field.">Os atributos do campo.</param>
      <returns vsli:raw="The defined field.">O campo definido.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The length of &lt;paramref name=&quot;fieldName&quot; /&gt; is zero.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;type&quot; /&gt; is System.Void.  &#xA;  &#xA; -or-  &#xA;  &#xA; A total size was specified for the parent class of this field.">O comprimento de <paramref name="fieldName" /> é zero.  

ou - 
<paramref name="type" /> é System.Void.  

ou - 
Um tamanho total foi especificado para a classe pai desse campo.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;fieldName&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="fieldName" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The type was previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
      <summary vsli:raw="Defines the generic type parameters for the current type, specifying their number and their names, and returns an array of &lt;see cref=&quot;T:System.Reflection.Emit.GenericTypeParameterBuilder&quot; /&gt; objects that can be used to set their constraints.">Define os parâmetros de tipo genérico do tipo atual, especificando seus números e nomes, e retorna uma matriz de objetos <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> que podem ser usados para definir suas restrições.</summary>
      <param name="names" vsli:raw="An array of names for the generic type parameters.">Uma matriz de nomes para os parâmetros de tipo genérico.</param>
      <returns vsli:raw="An array of &lt;see cref=&quot;T:System.Reflection.Emit.GenericTypeParameterBuilder&quot; /&gt; objects that can be used to define the constraints of the generic type parameters for the current type.">Uma matriz de objetos <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> que podem ser usados para definir as restrições dos parâmetros de tipo genérico do tipo atual.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Generic type parameters have already been defined for this type.">Os parâmetros de tipo genérico já foram definidos para esse tipo.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;names&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; An element of &lt;paramref name=&quot;names&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="names" /> é <see langword="null" />.  

ou - 
Um elemento de <paramref name="names" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;names&quot; /&gt; is an empty array.">
        <paramref name="names" /> é uma matriz vazia.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
      <summary vsli:raw="Defines initialized data field in the .sdata section of the portable executable (PE) file.">Define o campo de dados inicializado na seção .sdata do arquivo PE (executável portátil).</summary>
      <param name="name" vsli:raw="The name used to refer to the data. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">O nome usado para fazer referência aos dados. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="data" vsli:raw="The blob of data.">O blob de dados.</param>
      <param name="attributes" vsli:raw="The attributes for the field.">Os atributos do campo.</param>
      <returns vsli:raw="A field to reference the data.">Um campo para fazer referência aos dados.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="Length of &lt;paramref name=&quot;name&quot; /&gt; is zero.  &#xA;  &#xA; -or-  &#xA;  &#xA; The size of the data is less than or equal to zero, or greater than or equal to 0x3f0000.">O tamanho de <paramref name="name" /> é zero.  

ou - 
O tamanho dos dados é menor que ou igual a zero, ou maior que ou igual a 0x3f0000.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; or &lt;paramref name=&quot;data&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> ou <paramref name="data" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt; has been previously called.">
        <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> foi chamado anteriormente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
      <summary vsli:raw="Adds a new method to the type, with the specified name and method attributes.">Adiciona um novo método ao tipo, com o nome e os atributos de método especificados.</summary>
      <param name="name" vsli:raw="The name of the method. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">O nome do método. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="attributes" vsli:raw="The attributes of the method.">Os atributos do método.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Emit.MethodBuilder&quot; /&gt; representing the newly defined method.">Um <see cref="T:System.Reflection.Emit.MethodBuilder" /> representando o método recém-definido.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The length of &lt;paramref name=&quot;name&quot; /&gt; is zero.  &#xA;  &#xA; -or-  &#xA;  &#xA; The type of the parent of this method is an interface, and this method is not virtual (&lt;see langword=&quot;Overridable&quot; /&gt; in Visual Basic).">O comprimento de <paramref name="name" /> é zero.  

ou - 
O tipo de pai desse método é uma interface e esse método não é virtual (<see langword="Overridable" /> no Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The type was previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; For the current dynamic type, the &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.IsGenericType&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;, but the &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition&quot; /&gt; property is &lt;see langword=&quot;false&quot; /&gt;.">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  

ou - 
Para o tipo dinâmico atual, a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> é <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
      <summary vsli:raw="Adds a new method to the type, with the specified name, method attributes, and calling convention.">Adiciona um novo método ao tipo, com o nome, os atributos de método e a convenção de chamada especificados.</summary>
      <param name="name" vsli:raw="The name of the method. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">O nome do método. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="attributes" vsli:raw="The attributes of the method.">Os atributos do método.</param>
      <param name="callingConvention" vsli:raw="The calling convention of the method.">A convenção de chamada do método.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Emit.MethodBuilder&quot; /&gt; representing the newly defined method.">Um <see cref="T:System.Reflection.Emit.MethodBuilder" /> representando o método recém-definido.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The length of &lt;paramref name=&quot;name&quot; /&gt; is zero.  &#xA;  &#xA; -or-  &#xA;  &#xA; The type of the parent of this method is an interface and this method is not virtual (&lt;see langword=&quot;Overridable&quot; /&gt; in Visual Basic).">O comprimento de <paramref name="name" /> é zero.  

ou - 
O tipo de pai desse método é uma interface e esse método não é virtual (<see langword="Overridable" /> no Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The type was previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; For the current dynamic type, the &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.IsGenericType&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;, but the &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition&quot; /&gt; property is &lt;see langword=&quot;false&quot; /&gt;.">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  

ou - 
Para o tipo dinâmico atual, a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> é <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
      <summary vsli:raw="Adds a new method to the type, with the specified name, method attributes, calling convention, and method signature.">Adiciona um novo método ao tipo, com o nome, atributos de método, convenção de chamada e assinatura de método especificados.</summary>
      <param name="name" vsli:raw="The name of the method. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">O nome do método. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="attributes" vsli:raw="The attributes of the method.">Os atributos do método.</param>
      <param name="callingConvention" vsli:raw="The calling convention of the method.">A convenção de chamada do método.</param>
      <param name="returnType" vsli:raw="The return type of the method.">O tipo de retorno do método.</param>
      <param name="parameterTypes" vsli:raw="The types of the parameters of the method.">Os tipos dos parâmetros do método.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Emit.MethodBuilder&quot; /&gt; representing the newly defined method.">Um <see cref="T:System.Reflection.Emit.MethodBuilder" /> representando o método recém-definido.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The length of &lt;paramref name=&quot;name&quot; /&gt; is zero.  &#xA;  &#xA; -or-  &#xA;  &#xA; The type of the parent of this method is an interface, and this method is not virtual (&lt;see langword=&quot;Overridable&quot; /&gt; in Visual Basic).">O comprimento de <paramref name="name" /> é zero.  

ou - 
O tipo de pai desse método é uma interface e esse método não é virtual (<see langword="Overridable" /> no Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The type was previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; For the current dynamic type, the &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.IsGenericType&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;, but the &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition&quot; /&gt; property is &lt;see langword=&quot;false&quot; /&gt;.">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  

ou - 
Para o tipo dinâmico atual, a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> é <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
      <summary vsli:raw="Adds a new method to the type, with the specified name, method attributes, calling convention, method signature, and custom modifiers.">Adiciona um novo método ao tipo, com o nome, os atributos de método, a convenção de chamada, a assinatura de método e os modificadores personalizados especificados.</summary>
      <param name="name" vsli:raw="The name of the method. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">O nome do método. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="attributes" vsli:raw="The attributes of the method.">Os atributos do método.</param>
      <param name="callingConvention" vsli:raw="The calling convention of the method.">A convenção de chamada do método.</param>
      <param name="returnType" vsli:raw="The return type of the method.">O tipo de retorno do método.</param>
      <param name="returnTypeRequiredCustomModifiers" vsli:raw="An array of types representing the required custom modifiers, such as &lt;see cref=&quot;T:System.Runtime.CompilerServices.IsConst&quot; /&gt;, for the return type of the method. If the return type has no required custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt;.">Uma matriz de tipos que representam os modificadores personalizados obrigatórios, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />, para o tipo de retorno do método. Se o tipo de retorno não tiver modificadores personalizados obrigatórios, especifique <see langword="null" />.</param>
      <param name="returnTypeOptionalCustomModifiers" vsli:raw="An array of types representing the optional custom modifiers, such as &lt;see cref=&quot;T:System.Runtime.CompilerServices.IsConst&quot; /&gt;, for the return type of the method. If the return type has no optional custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt;.">Uma matriz de tipos que representam os modificadores personalizados opcionais, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />, para o tipo de retorno do método. Se o tipo de retorno não tiver modificadores personalizados opcionais, especifique <see langword="null" />.</param>
      <param name="parameterTypes" vsli:raw="The types of the parameters of the method.">Os tipos dos parâmetros do método.</param>
      <param name="parameterTypeRequiredCustomModifiers" vsli:raw="An array of arrays of types. Each array of types represents the required custom modifiers for the corresponding parameter, such as &lt;see cref=&quot;T:System.Runtime.CompilerServices.IsConst&quot; /&gt;. If a particular parameter has no required custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt; instead of an array of types. If none of the parameters have required custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt; instead of an array of arrays.">Uma matriz de matrizes de tipos. Cada matriz de tipos representa os modificadores personalizados obrigatórios para o parâmetro correspondente, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />. Se um determinado parâmetro tiver não modificadores personalizados obrigatórios, especifique <see langword="null" /> em vez de uma matriz de tipos. Se nenhum dos parâmetros tiver modificadores personalizados obrigatórios, especifique <see langword="null" /> em vez de uma matriz de matrizes.</param>
      <param name="parameterTypeOptionalCustomModifiers" vsli:raw="An array of arrays of types. Each array of types represents the optional custom modifiers for the corresponding parameter, such as &lt;see cref=&quot;T:System.Runtime.CompilerServices.IsConst&quot; /&gt;. If a particular parameter has no optional custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt; instead of an array of types. If none of the parameters have optional custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt; instead of an array of arrays.">Uma matriz de matrizes de tipos. Cada matriz de tipos representa os modificadores personalizados opcionais para o parâmetro correspondente, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />. Se um determinado parâmetro tiver não modificadores personalizados opcionais, especifique <see langword="null" /> em vez de uma matriz de tipos. Se nenhum dos parâmetros tiver modificadores personalizados opcionais, especifique <see langword="null" /> em vez de uma matriz de matrizes.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Emit.MethodBuilder&quot; /&gt; object representing the newly added method.">Um objeto <see cref="T:System.Reflection.Emit.MethodBuilder" /> que representa o método recém-adicionado.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The length of &lt;paramref name=&quot;name&quot; /&gt; is zero.  &#xA;  &#xA; -or-  &#xA;  &#xA; The type of the parent of this method is an interface, and this method is not virtual (&lt;see langword=&quot;Overridable&quot; /&gt; in Visual Basic).  &#xA;  &#xA; -or-  &#xA;  &#xA; The size of &lt;paramref name=&quot;parameterTypeRequiredCustomModifiers&quot; /&gt; or &lt;paramref name=&quot;parameterTypeOptionalCustomModifiers&quot; /&gt; does not equal the size of &lt;paramref name=&quot;parameterTypes&quot; /&gt;.">O comprimento de <paramref name="name" /> é zero.  

ou - 
O tipo de pai desse método é uma interface e esse método não é virtual (<see langword="Overridable" /> no Visual Basic).  

ou - 
O tamanho de <paramref name="parameterTypeRequiredCustomModifiers" /> ou <paramref name="parameterTypeOptionalCustomModifiers" /> não é igual ao tamanho de <paramref name="parameterTypes" />.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The type was previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; For the current dynamic type, the &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.IsGenericType&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;, but the &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition&quot; /&gt; property is &lt;see langword=&quot;false&quot; /&gt;.">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  

ou - 
Para o tipo dinâmico atual, a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> é <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
      <summary vsli:raw="Adds a new method to the type, with the specified name, method attributes, and method signature.">Adiciona um novo método ao tipo, com o nome, os atributos de método e a assinatura de método especificados.</summary>
      <param name="name" vsli:raw="The name of the method. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">O nome do método. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="attributes" vsli:raw="The attributes of the method.">Os atributos do método.</param>
      <param name="returnType" vsli:raw="The return type of the method.">O tipo de retorno do método.</param>
      <param name="parameterTypes" vsli:raw="The types of the parameters of the method.">Os tipos dos parâmetros do método.</param>
      <returns vsli:raw="The defined method.">O método definido.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The length of &lt;paramref name=&quot;name&quot; /&gt; is zero.  &#xA;  &#xA; -or-  &#xA;  &#xA; The type of the parent of this method is an interface, and this method is not virtual (&lt;see langword=&quot;Overridable&quot; /&gt; in Visual Basic).">O comprimento de <paramref name="name" /> é zero.  

ou - 
O tipo de pai desse método é uma interface e esse método não é virtual (<see langword="Overridable" /> no Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The type was previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; For the current dynamic type, the &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.IsGenericType&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;, but the &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition&quot; /&gt; property is &lt;see langword=&quot;false&quot; /&gt;.">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  

ou - 
Para o tipo dinâmico atual, a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> é <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
      <summary vsli:raw="Specifies a given method body that implements a given method declaration, potentially with a different name.">Especifica um corpo de um determinado método que implementa uma declaração do mesmo, possivelmente com um nome diferente.</summary>
      <param name="methodInfoBody" vsli:raw="The method body to be used. This should be a &lt;see langword=&quot;MethodBuilder&quot; /&gt; object.">O corpo do método a ser usado. Isso deve ser um objeto <see langword="MethodBuilder" />.</param>
      <param name="methodInfoDeclaration" vsli:raw="The method whose declaration is to be used.">O método cuja declaração deve ser usada.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;methodInfoBody&quot; /&gt; does not belong to this class.">
        <paramref name="methodInfoBody" /> não pertence a esta classe.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;methodInfoBody&quot; /&gt; or &lt;paramref name=&quot;methodInfoDeclaration&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="methodInfoBody" /> ou <paramref name="methodInfoDeclaration" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The type was previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The declaring type of &lt;paramref name=&quot;methodInfoBody&quot; /&gt; is not the type represented by this &lt;see cref=&quot;T:System.Reflection.Emit.TypeBuilder&quot; /&gt;.">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  

ou - 
O tipo de declaração de <paramref name="methodInfoBody" /> não é do tipo representado por este <see cref="T:System.Reflection.Emit.TypeBuilder" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
      <summary vsli:raw="Defines a nested type, given its name.">Define um tipo aninhado, após ser informado seu nome.</summary>
      <param name="name" vsli:raw="The short name of the type. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">O nome curto do tipo. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <returns vsli:raw="The defined nested type.">O tipo aninhado definido.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="Length of &lt;paramref name=&quot;name&quot; /&gt; is zero or greater than 1023.  &#xA;  &#xA; -or-  &#xA;  &#xA; This operation would create a type with a duplicate &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.FullName&quot; /&gt; in the current assembly.">O comprimento de <paramref name="name" /> é zero ou maior que 1023.  

ou - 
Essa operação criaria um tipo com um <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> duplicado no assembly atual.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
      <summary vsli:raw="Defines a nested type, given its name and attributes.">Define um tipo aninhado, após serem informados seu nome e atributos.</summary>
      <param name="name" vsli:raw="The short name of the type. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">O nome curto do tipo. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="attr" vsli:raw="The attributes of the type.">Os atributos do tipo.</param>
      <returns vsli:raw="The defined nested type.">O tipo aninhado definido.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The nested attribute is not specified.  &#xA;  &#xA; -or-  &#xA;  &#xA; This type is sealed.  &#xA;  &#xA; -or-  &#xA;  &#xA; This type is an array.  &#xA;  &#xA; -or-  &#xA;  &#xA; This type is an interface, but the nested type is not an interface.  &#xA;  &#xA; -or-  &#xA;  &#xA; The length of &lt;paramref name=&quot;name&quot; /&gt; is zero or greater than 1023.  &#xA;  &#xA; -or-  &#xA;  &#xA; This operation would create a type with a duplicate &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.FullName&quot; /&gt; in the current assembly.">O atributo aninhado não é especificado.  

ou - 
Esse tipo está lacrado.  

ou - 
Esse tipo é uma matriz.  

ou - 
Esse tipo é uma interface, mas o tipo aninhado não é uma interface.  

ou - 
O comprimento de <paramref name="name" /> é zero ou maior que 1023.  

ou - 
Essa operação criaria um tipo com um <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> duplicado no assembly atual.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
      <summary vsli:raw="Defines a nested type, given its name, attributes, and the type that it extends.">Define um tipo aninhado, após serem informados seu nome, atributos e o tipo que ele estende.</summary>
      <param name="name" vsli:raw="The short name of the type. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">O nome curto do tipo. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="attr" vsli:raw="The attributes of the type.">Os atributos do tipo.</param>
      <param name="parent" vsli:raw="The type that the nested type extends.">O tipo que o tipo aninhado estende.</param>
      <returns vsli:raw="The defined nested type.">O tipo aninhado definido.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The nested attribute is not specified.  &#xA;  &#xA; -or-  &#xA;  &#xA; This type is sealed.  &#xA;  &#xA; -or-  &#xA;  &#xA; This type is an array.  &#xA;  &#xA; -or-  &#xA;  &#xA; This type is an interface, but the nested type is not an interface.  &#xA;  &#xA; -or-  &#xA;  &#xA; The length of &lt;paramref name=&quot;name&quot; /&gt; is zero or greater than 1023.  &#xA;  &#xA; -or-  &#xA;  &#xA; This operation would create a type with a duplicate &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.FullName&quot; /&gt; in the current assembly.">O atributo aninhado não é especificado.  

ou - 
Esse tipo está lacrado.  

ou - 
Esse tipo é uma matriz.  

ou - 
Esse tipo é uma interface, mas o tipo aninhado não é uma interface.  

ou - 
O comprimento de <paramref name="name" /> é zero ou maior que 1023.  

ou - 
Essa operação criaria um tipo com um <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> duplicado no assembly atual.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
      <summary vsli:raw="Defines a nested type, given its name, attributes, the total size of the type, and the type that it extends.">Define um tipo aninhado, após serem informados seu nome, atributos, tamanho total do tipo e o tipo que ele estende.</summary>
      <param name="name" vsli:raw="The short name of the type. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">O nome curto do tipo. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="attr" vsli:raw="The attributes of the type.">Os atributos do tipo.</param>
      <param name="parent" vsli:raw="The type that the nested type extends.">O tipo que o tipo aninhado estende.</param>
      <param name="typeSize" vsli:raw="The total size of the type.">O tamanho total do tipo.</param>
      <returns vsli:raw="The defined nested type.">O tipo aninhado definido.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The nested attribute is not specified.  &#xA;  &#xA; -or-  &#xA;  &#xA; This type is sealed.  &#xA;  &#xA; -or-  &#xA;  &#xA; This type is an array.  &#xA;  &#xA; -or-  &#xA;  &#xA; This type is an interface, but the nested type is not an interface.  &#xA;  &#xA; -or-  &#xA;  &#xA; The length of &lt;paramref name=&quot;name&quot; /&gt; is zero or greater than 1023.  &#xA;  &#xA; -or-  &#xA;  &#xA; This operation would create a type with a duplicate &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.FullName&quot; /&gt; in the current assembly.">O atributo aninhado não é especificado.  

ou - 
Esse tipo está lacrado.  

ou - 
Esse tipo é uma matriz.  

ou - 
Esse tipo é uma interface, mas o tipo aninhado não é uma interface.  

ou - 
O comprimento de <paramref name="name" /> é zero ou maior que 1023.  

ou - 
Essa operação criaria um tipo com um <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> duplicado no assembly atual.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
      <summary vsli:raw="Defines a nested type, given its name, attributes, the type that it extends, and the packing size.">Define um tipo aninhado, após serem informados seu nome, atributos, tipo que ele estende e tamanho de empacotamento.</summary>
      <param name="name" vsli:raw="The short name of the type. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">O nome curto do tipo. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="attr" vsli:raw="The attributes of the type.">Os atributos do tipo.</param>
      <param name="parent" vsli:raw="The type that the nested type extends.">O tipo que o tipo aninhado estende.</param>
      <param name="packSize" vsli:raw="The packing size of the type.">O tamanho de empacotamento do tipo.</param>
      <returns vsli:raw="The defined nested type.">O tipo aninhado definido.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The nested attribute is not specified.  &#xA;  &#xA; -or-  &#xA;  &#xA; This type is sealed.  &#xA;  &#xA; -or-  &#xA;  &#xA; This type is an array.  &#xA;  &#xA; -or-  &#xA;  &#xA; This type is an interface, but the nested type is not an interface.  &#xA;  &#xA; -or-  &#xA;  &#xA; The length of &lt;paramref name=&quot;name&quot; /&gt; is zero or greater than 1023.  &#xA;  &#xA; -or-  &#xA;  &#xA; This operation would create a type with a duplicate &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.FullName&quot; /&gt; in the current assembly.">O atributo aninhado não é especificado.  

ou - 
Esse tipo está lacrado.  

ou - 
Esse tipo é uma matriz.  

ou - 
Esse tipo é uma interface, mas o tipo aninhado não é uma interface.  

ou - 
O comprimento de <paramref name="name" /> é zero ou maior que 1023.  

ou - 
Essa operação criaria um tipo com um <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> duplicado no assembly atual.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
      <summary vsli:raw="Defines a nested type, given its name, attributes, size, and the type that it extends.">Define um tipo aninhado, após serem informados seu nome, atributos, tamanho e o tipo que ele estende.</summary>
      <param name="name" vsli:raw="The short name of the type. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded null values.">O nome curto do tipo. <paramref name="name" /> não pode conter valores nulos inseridos.</param>
      <param name="attr" vsli:raw="The attributes of the type.">Os atributos do tipo.</param>
      <param name="parent" vsli:raw="The type that the nested type extends.">O tipo que o tipo aninhado estende.</param>
      <param name="packSize" vsli:raw="The packing size of the type.">O tamanho de empacotamento do tipo.</param>
      <param name="typeSize" vsli:raw="The total size of the type.">O tamanho total do tipo.</param>
      <returns vsli:raw="The defined nested type.">O tipo aninhado definido.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
      <summary vsli:raw="Defines a nested type, given its name, attributes, the type that it extends, and the interfaces that it implements.">Define um tipo aninhado, após serem informados seu nome, atributos, tipo que ele estende e as interfaces implementadas por ele.</summary>
      <param name="name" vsli:raw="The short name of the type. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">O nome curto do tipo. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="attr" vsli:raw="The attributes of the type.">Os atributos do tipo.</param>
      <param name="parent" vsli:raw="The type that the nested type extends.">O tipo que o tipo aninhado estende.</param>
      <param name="interfaces" vsli:raw="The interfaces that the nested type implements.">As interface implementadas pelo tipo aninhado.</param>
      <returns vsli:raw="The defined nested type.">O tipo aninhado definido.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The nested attribute is not specified.  &#xA;  &#xA; -or-  &#xA;  &#xA; This type is sealed.  &#xA;  &#xA; -or-  &#xA;  &#xA; This type is an array.  &#xA;  &#xA; -or-  &#xA;  &#xA; This type is an interface, but the nested type is not an interface.  &#xA;  &#xA; -or-  &#xA;  &#xA; The length of &lt;paramref name=&quot;name&quot; /&gt; is zero or greater than 1023.  &#xA;  &#xA; -or-  &#xA;  &#xA; This operation would create a type with a duplicate &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.FullName&quot; /&gt; in the current assembly.">O atributo aninhado não é especificado.  

ou - 
Esse tipo está lacrado.  

ou - 
Esse tipo é uma matriz.  

ou - 
Esse tipo é uma interface, mas o tipo aninhado não é uma interface.  

ou - 
O comprimento de <paramref name="name" /> é zero ou maior que 1023.  

ou - 
Essa operação criaria um tipo com um <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> duplicado no assembly atual.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; An element of the &lt;paramref name=&quot;interfaces&quot; /&gt; array is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> é <see langword="null" />.  

ou - 
Um elemento da matriz <paramref name="interfaces" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
      <summary vsli:raw="Defines a &lt;see langword=&quot;PInvoke&quot; /&gt; method given its name, the name of the DLL in which the method is defined, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, and the &lt;see langword=&quot;PInvoke&quot; /&gt; flags.">Define um método <see langword="PInvoke" /> após serem informados seu nome, o nome da DLL em que o método é definido, os atributos do método, a convenção de chamada do método, o tipo de retorno do método, os tipos dos parâmetros do método e os sinalizadores <see langword="PInvoke" />.</summary>
      <param name="name" vsli:raw="The name of the &lt;see langword=&quot;PInvoke&quot; /&gt; method. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">O nome do método <see langword="PInvoke" />. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="dllName" vsli:raw="The name of the DLL in which the &lt;see langword=&quot;PInvoke&quot; /&gt; method is defined.">O nome da DLL na qual o método <see langword="PInvoke" /> é definido.</param>
      <param name="attributes" vsli:raw="The attributes of the method.">Os atributos do método.</param>
      <param name="callingConvention" vsli:raw="The method's calling convention.">A convenção de chamada do método.</param>
      <param name="returnType" vsli:raw="The method's return type.">O tipo de retorno do método.</param>
      <param name="parameterTypes" vsli:raw="The types of the method's parameters.">Os tipos de parâmetros do método.</param>
      <param name="nativeCallConv" vsli:raw="The native calling convention.">A convenção de chamada nativa.</param>
      <param name="nativeCharSet" vsli:raw="The method's native character set.">O conjunto de caracteres nativos do método.</param>
      <returns vsli:raw="The defined &lt;see langword=&quot;PInvoke&quot; /&gt; method.">O método <see langword="PInvoke" /> definido.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The method is not static.  &#xA;  &#xA; -or-  &#xA;  &#xA; The parent type is an interface.  &#xA;  &#xA; -or-  &#xA;  &#xA; The method is abstract.  &#xA;  &#xA; -or-  &#xA;  &#xA; The method was previously defined.  &#xA;  &#xA; -or-  &#xA;  &#xA; The length of &lt;paramref name=&quot;name&quot; /&gt; or &lt;paramref name=&quot;dllName&quot; /&gt; is zero.">O método não é estático.  

ou - 
O tipo pai é uma interface.  

ou - 
O método é abstrato.  

ou - 
O método foi definido anteriormente.  

ou - 
O comprimento de <paramref name="name" /> ou <paramref name="dllName" /> é zero.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; or &lt;paramref name=&quot;dllName&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> ou <paramref name="dllName" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The containing type has been previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.">O tipo recipiente foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
      <summary vsli:raw="Defines a &lt;see langword=&quot;PInvoke&quot; /&gt; method given its name, the name of the DLL in which the method is defined, the name of the entry point, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, and the &lt;see langword=&quot;PInvoke&quot; /&gt; flags.">Define um método <see langword="PInvoke" /> após serem informados seu nome, o nome da DLL no qual o método é definido, o nome do ponto de entrada, os atributos do método, a convenção de chamada do método, o tipo de retorno do método, os tipos dos parâmetros do método, os sinalizadores <see langword="PInvoke" />.</summary>
      <param name="name" vsli:raw="The name of the &lt;see langword=&quot;PInvoke&quot; /&gt; method. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">O nome do método <see langword="PInvoke" />. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="dllName" vsli:raw="The name of the DLL in which the &lt;see langword=&quot;PInvoke&quot; /&gt; method is defined.">O nome da DLL na qual o método <see langword="PInvoke" /> é definido.</param>
      <param name="entryName" vsli:raw="The name of the entry point in the DLL.">O nome do ponto de entrada na DLL.</param>
      <param name="attributes" vsli:raw="The attributes of the method.">Os atributos do método.</param>
      <param name="callingConvention" vsli:raw="The method's calling convention.">A convenção de chamada do método.</param>
      <param name="returnType" vsli:raw="The method's return type.">O tipo de retorno do método.</param>
      <param name="parameterTypes" vsli:raw="The types of the method's parameters.">Os tipos de parâmetros do método.</param>
      <param name="nativeCallConv" vsli:raw="The native calling convention.">A convenção de chamada nativa.</param>
      <param name="nativeCharSet" vsli:raw="The method's native character set.">O conjunto de caracteres nativos do método.</param>
      <returns vsli:raw="The defined &lt;see langword=&quot;PInvoke&quot; /&gt; method.">O método <see langword="PInvoke" /> definido.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The method is not static.  &#xA;  &#xA; -or-  &#xA;  &#xA; The parent type is an interface.  &#xA;  &#xA; -or-  &#xA;  &#xA; The method is abstract.  &#xA;  &#xA; -or-  &#xA;  &#xA; The method was previously defined.  &#xA;  &#xA; -or-  &#xA;  &#xA; The length of &lt;paramref name=&quot;name&quot; /&gt;, &lt;paramref name=&quot;dllName&quot; /&gt;, or &lt;paramref name=&quot;entryName&quot; /&gt; is zero.">O método não é estático.  

ou - 
O tipo pai é uma interface.  

ou - 
O método é abstrato.  

ou - 
O método foi definido anteriormente.  

ou - 
O comprimento de <paramref name="name" />, <paramref name="dllName" /> ou <paramref name="entryName" /> é zero.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt;, &lt;paramref name=&quot;dllName&quot; /&gt;, or &lt;paramref name=&quot;entryName&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" />, <paramref name="dllName" /> ou <paramref name="entryName" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The containing type has been previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.">O tipo recipiente foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][])">
      <summary>Define um método <see langword="PInvoke" /> após serem informados seu nome, o nome da DLL no qual o método é definido, o nome do ponto de entrada, os atributos do método, a convenção de chamada do método, o tipo de retorno do método, os tipos dos parâmetros do método, os sinalizadores <see langword="PInvoke" /> e os modificadores personalizados para os parâmetros e o tipo de retorno.</summary>
      <param name="name">O nome do método <see langword="PInvoke" />. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="dllName">O nome da DLL na qual o método <see langword="PInvoke" /> é definido.</param>
      <param name="parameterTypeOptionalCustomModifiers">Uma matriz de matrizes de tipos. Cada matriz de tipos representa os modificadores personalizados opcionais para o parâmetro correspondente, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />. Se um determinado parâmetro tiver não modificadores personalizados opcionais, especifique <see langword="null" /> em vez de uma matriz de tipos. Se nenhum dos parâmetros tiver modificadores personalizados opcionais, especifique <see langword="null" /> em vez de uma matriz de matrizes.</param>
      <param name="nativeCallConv">A convenção de chamada nativa.</param>
      <param name="nativeCharSet">O conjunto de caracteres nativos do método.</param>
      <param name="entryName">O nome do ponto de entrada na DLL.</param>
      <param name="attributes">Os atributos do método.</param>
      <param name="callingConvention">A convenção de chamada do método.</param>
      <param name="returnType">O tipo de retorno do método.</param>
      <param name="returnTypeRequiredCustomModifiers">Uma matriz de tipos que representam os modificadores personalizados obrigatórios, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />, para o tipo de retorno do método. Se o tipo de retorno não tiver modificadores personalizados obrigatórios, especifique <see langword="null" />.</param>
      <param name="returnTypeOptionalCustomModifiers">Uma matriz de tipos que representam os modificadores personalizados opcionais, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />, para o tipo de retorno do método. Se o tipo de retorno não tiver modificadores personalizados opcionais, especifique <see langword="null" />.</param>
      <param name="parameterTypes">Os tipos de parâmetros do método.</param>
      <param name="parameterTypeRequiredCustomModifiers">Uma matriz de matrizes de tipos. Cada matriz de tipos representa os modificadores personalizados obrigatórios para o parâmetro correspondente, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />. Se um determinado parâmetro tiver não modificadores personalizados obrigatórios, especifique <see langword="null" /> em vez de uma matriz de tipos. Se nenhum dos parâmetros tiver modificadores personalizados obrigatórios, especifique <see langword="null" /> em vez de uma matriz de matrizes.</param>
      <returns>Um <see cref="T:System.Reflection.Emit.MethodBuilder" /> representando o método <see langword="PInvoke" /> definido.</returns>
      <exception cref="T:System.ArgumentException">O método não é estático.  

ou - 
O tipo pai é uma interface.  

ou - 
O método é abstrato.  

ou - 
O método foi definido anteriormente.  

ou - 
O comprimento de <paramref name="name" />, <paramref name="dllName" /> ou <paramref name="entryName" /> é zero.  

ou - 
O tamanho de <paramref name="parameterTypeRequiredCustomModifiers" /> ou <paramref name="parameterTypeOptionalCustomModifiers" /> não é igual ao tamanho de <paramref name="parameterTypes" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" />, <paramref name="dllName" /> ou <paramref name="entryName" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  

ou - 
Para o tipo dinâmico atual, a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> é <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
      <summary vsli:raw="Adds a new property to the type, with the given name, attributes, calling convention, and property signature.">Adiciona uma nova propriedade ao tipo, com o nome, os atributos, a convenção de chamada e assinatura de propriedade fornecidos.</summary>
      <param name="name" vsli:raw="The name of the property. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">O nome da propriedade. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="attributes" vsli:raw="The attributes of the property.">Os atributos da propriedade.</param>
      <param name="callingConvention" vsli:raw="The calling convention of the property accessors.">A convenção de chamada dos acessadores de propriedade.</param>
      <param name="returnType" vsli:raw="The return type of the property.">O tipo de retorno da propriedade.</param>
      <param name="parameterTypes" vsli:raw="The types of the parameters of the property.">Os tipos dos parâmetros da propriedade.</param>
      <returns vsli:raw="The defined property.">A propriedade definida.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The length of &lt;paramref name=&quot;name&quot; /&gt; is zero.">O comprimento de <paramref name="name" /> é zero.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; Any of the elements of the &lt;paramref name=&quot;parameterTypes&quot; /&gt; array is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> é <see langword="null" />.  

ou - 
Qualquer um dos elementos da matriz de <paramref name="parameterTypes" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The type was previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
      <summary vsli:raw="Adds a new property to the type, with the given name, calling convention, property signature, and custom modifiers.">Adiciona uma nova propriedade ao tipo, com o nome, a convenção de chamada, a assinatura de propriedade e os modificadores personalizados fornecidos.</summary>
      <param name="name" vsli:raw="The name of the property. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">O nome da propriedade. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="attributes" vsli:raw="The attributes of the property.">Os atributos da propriedade.</param>
      <param name="callingConvention" vsli:raw="The calling convention of the property accessors.">A convenção de chamada dos acessadores de propriedade.</param>
      <param name="returnType" vsli:raw="The return type of the property.">O tipo de retorno da propriedade.</param>
      <param name="returnTypeRequiredCustomModifiers" vsli:raw="An array of types representing the required custom modifiers, such as &lt;see cref=&quot;T:System.Runtime.CompilerServices.IsConst&quot; /&gt;, for the return type of the property. If the return type has no required custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt;.">Uma matriz de tipos que representa os modificadores personalizados obrigatórios, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para o tipo de retorno da propriedade. Se o tipo de retorno não tiver modificadores personalizados obrigatórios, especifique <see langword="null" />.</param>
      <param name="returnTypeOptionalCustomModifiers" vsli:raw="An array of types representing the optional custom modifiers, such as &lt;see cref=&quot;T:System.Runtime.CompilerServices.IsConst&quot; /&gt;, for the return type of the property. If the return type has no optional custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt;.">Uma matriz de tipos que representa os modificadores personalizados opcionais, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para o tipo de retorno da propriedade. Se o tipo de retorno não tiver modificadores personalizados opcionais, especifique <see langword="null" />.</param>
      <param name="parameterTypes" vsli:raw="The types of the parameters of the property.">Os tipos dos parâmetros da propriedade.</param>
      <param name="parameterTypeRequiredCustomModifiers" vsli:raw="An array of arrays of types. Each array of types represents the required custom modifiers for the corresponding parameter, such as &lt;see cref=&quot;T:System.Runtime.CompilerServices.IsConst&quot; /&gt;. If a particular parameter has no required custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt; instead of an array of types. If none of the parameters have required custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt; instead of an array of arrays.">Uma matriz de matrizes de tipos. Cada matriz de tipos representa os modificadores personalizados obrigatórios para o parâmetro correspondente, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />. Se um determinado parâmetro tiver não modificadores personalizados obrigatórios, especifique <see langword="null" /> em vez de uma matriz de tipos. Se nenhum dos parâmetros tiver modificadores personalizados obrigatórios, especifique <see langword="null" /> em vez de uma matriz de matrizes.</param>
      <param name="parameterTypeOptionalCustomModifiers" vsli:raw="An array of arrays of types. Each array of types represents the optional custom modifiers for the corresponding parameter, such as &lt;see cref=&quot;T:System.Runtime.CompilerServices.IsConst&quot; /&gt;. If a particular parameter has no optional custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt; instead of an array of types. If none of the parameters have optional custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt; instead of an array of arrays.">Uma matriz de matrizes de tipos. Cada matriz de tipos representa os modificadores personalizados opcionais para o parâmetro correspondente, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />. Se um determinado parâmetro tiver não modificadores personalizados opcionais, especifique <see langword="null" /> em vez de uma matriz de tipos. Se nenhum dos parâmetros tiver modificadores personalizados opcionais, especifique <see langword="null" /> em vez de uma matriz de matrizes.</param>
      <returns vsli:raw="The defined property.">A propriedade definida.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The length of &lt;paramref name=&quot;name&quot; /&gt; is zero.">O comprimento de <paramref name="name" /> é zero.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; Any of the elements of the &lt;paramref name=&quot;parameterTypes&quot; /&gt; array is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> é <see langword="null" />.  

ou - 
Qualquer um dos elementos da matriz de <paramref name="parameterTypes" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The type was previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
      <summary vsli:raw="Adds a new property to the type, with the given name and property signature.">Adiciona uma nova propriedade ao tipo, com o nome e assinatura de propriedade fornecidos.</summary>
      <param name="name" vsli:raw="The name of the property. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">O nome da propriedade. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="attributes" vsli:raw="The attributes of the property.">Os atributos da propriedade.</param>
      <param name="returnType" vsli:raw="The return type of the property.">O tipo de retorno da propriedade.</param>
      <param name="parameterTypes" vsli:raw="The types of the parameters of the property.">Os tipos dos parâmetros da propriedade.</param>
      <returns vsli:raw="The defined property.">A propriedade definida.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The length of &lt;paramref name=&quot;name&quot; /&gt; is zero.">O comprimento de <paramref name="name" /> é zero.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; Any of the elements of the &lt;paramref name=&quot;parameterTypes&quot; /&gt; array is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> é <see langword="null" />.  

ou - 
Qualquer um dos elementos da matriz de <paramref name="parameterTypes" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The type was previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
      <summary vsli:raw="Adds a new property to the type, with the given name, property signature, and custom modifiers.">Adiciona uma nova propriedade ao tipo, com o nome, a assinatura de propriedade e os modificadores personalizado fornecidos.</summary>
      <param name="name" vsli:raw="The name of the property. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">O nome da propriedade. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="attributes" vsli:raw="The attributes of the property.">Os atributos da propriedade.</param>
      <param name="returnType" vsli:raw="The return type of the property.">O tipo de retorno da propriedade.</param>
      <param name="returnTypeRequiredCustomModifiers" vsli:raw="An array of types representing the required custom modifiers, such as &lt;see cref=&quot;T:System.Runtime.CompilerServices.IsConst&quot; /&gt;, for the return type of the property. If the return type has no required custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt;.">Uma matriz de tipos que representa os modificadores personalizados obrigatórios, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para o tipo de retorno da propriedade. Se o tipo de retorno não tiver modificadores personalizados obrigatórios, especifique <see langword="null" />.</param>
      <param name="returnTypeOptionalCustomModifiers" vsli:raw="An array of types representing the optional custom modifiers, such as &lt;see cref=&quot;T:System.Runtime.CompilerServices.IsConst&quot; /&gt;, for the return type of the property. If the return type has no optional custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt;.">Uma matriz de tipos que representa os modificadores personalizados opcionais, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para o tipo de retorno da propriedade. Se o tipo de retorno não tiver modificadores personalizados opcionais, especifique <see langword="null" />.</param>
      <param name="parameterTypes" vsli:raw="The types of the parameters of the property.">Os tipos dos parâmetros da propriedade.</param>
      <param name="parameterTypeRequiredCustomModifiers" vsli:raw="An array of arrays of types. Each array of types represents the required custom modifiers for the corresponding parameter, such as &lt;see cref=&quot;T:System.Runtime.CompilerServices.IsConst&quot; /&gt;. If a particular parameter has no required custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt; instead of an array of types. If none of the parameters have required custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt; instead of an array of arrays.">Uma matriz de matrizes de tipos. Cada matriz de tipos representa os modificadores personalizados obrigatórios para o parâmetro correspondente, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />. Se um determinado parâmetro tiver não modificadores personalizados obrigatórios, especifique <see langword="null" /> em vez de uma matriz de tipos. Se nenhum dos parâmetros tiver modificadores personalizados obrigatórios, especifique <see langword="null" /> em vez de uma matriz de matrizes.</param>
      <param name="parameterTypeOptionalCustomModifiers" vsli:raw="An array of arrays of types. Each array of types represents the optional custom modifiers for the corresponding parameter, such as &lt;see cref=&quot;T:System.Runtime.CompilerServices.IsConst&quot; /&gt;. If a particular parameter has no optional custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt; instead of an array of types. If none of the parameters have optional custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt; instead of an array of arrays.">Uma matriz de matrizes de tipos. Cada matriz de tipos representa os modificadores personalizados opcionais para o parâmetro correspondente, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />. Se um determinado parâmetro tiver não modificadores personalizados opcionais, especifique <see langword="null" /> em vez de uma matriz de tipos. Se nenhum dos parâmetros tiver modificadores personalizados opcionais, especifique <see langword="null" /> em vez de uma matriz de matrizes.</param>
      <returns vsli:raw="The defined property.">A propriedade definida.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The length of &lt;paramref name=&quot;name&quot; /&gt; is zero.">O comprimento de <paramref name="name" /> é zero.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;  &#xA;  &#xA; -or-  &#xA;  &#xA; Any of the elements of the &lt;paramref name=&quot;parameterTypes&quot; /&gt; array is &lt;see langword=&quot;null&quot; /&gt;">
        <paramref name="name" /> é <see langword="null" />  

ou - 
Qualquer um dos elementos da matriz de <paramref name="parameterTypes" /> é <see langword="null" /></exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The type was previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer">
      <summary vsli:raw="Defines the initializer for this type.">Define o inicializador desse tipo.</summary>
      <returns vsli:raw="Returns a type initializer.">Retorna um inicializador de tipo.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The containing type has been previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.">O tipo recipiente foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
      <summary vsli:raw="Defines an uninitialized data field in the &lt;see langword=&quot;.sdata&quot; /&gt; section of the portable executable (PE) file.">Define um campo de dados não inicializado na seção <see langword=".sdata" /> do arquivo PE (executável portátil).</summary>
      <param name="name" vsli:raw="The name used to refer to the data. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">O nome usado para fazer referência aos dados. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="size" vsli:raw="The size of the data field.">O tamanho do campo de dados.</param>
      <param name="attributes" vsli:raw="The attributes for the field.">Os atributos do campo.</param>
      <returns vsli:raw="A field to reference the data.">Um campo para fazer referência aos dados.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="Length of &lt;paramref name=&quot;name&quot; /&gt; is zero.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;size&quot; /&gt; is less than or equal to zero, or greater than or equal to 0x003f0000.">O tamanho de <paramref name="name" /> é zero.  

ou - 
<paramref name="size" /> é menor que ou igual a zero, ou maior que ou igual a 0x003f0000.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The type was previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.FullName">
      <summary vsli:raw="Retrieves the full path of this type.">Recupera o caminho completo desse tipo.</summary>
      <returns vsli:raw="Read-only. Retrieves the full path of this type.">Somente leitura. Recupera o caminho completo desse tipo.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.GenericParameterAttributes">
      <summary vsli:raw="Gets a value that indicates the covariance and special constraints of the current generic type parameter.">Obtém um valor que indica a covariância e as restrições especiais do parâmetro de tipo genérico atual.</summary>
      <returns vsli:raw="A bitwise combination of &lt;see cref=&quot;T:System.Reflection.GenericParameterAttributes&quot; /&gt; values that describes the covariance and special constraints of the current generic type parameter.">Uma combinação bit a bit de valores <see cref="T:System.Reflection.GenericParameterAttributes" /> que descrevem a covariância e restrições especiais do parâmetro de tipo genérico atual.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.GenericParameterPosition">
      <summary vsli:raw="Gets the position of a type parameter in the type parameter list of the generic type that declared the parameter.">Obtém a posição de um parâmetro de tipo na lista de parâmetros de tipo do tipo genérico declarado no parâmetro.</summary>
      <returns vsli:raw="If the current &lt;see cref=&quot;T:System.Reflection.Emit.TypeBuilder&quot; /&gt; object represents a generic type parameter, the position of the type parameter in the type parameter list of the generic type that declared the parameter; otherwise, undefined.">Se o objeto <see cref="T:System.Reflection.Emit.TypeBuilder" /> atual representar um parâmetro de tipo genérico, a posição do parâmetro de tipo na lista de parâmetros de tipo do tipo genérico que declarou o parâmetro; caso contrário, indefinido.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
      <summary vsli:raw="Returns the constructor of the specified constructed generic type that corresponds to the specified constructor of the generic type definition.">Retorna o construtor do tipo genérico construído especificado que corresponde ao construtor especificado da definição de tipo genérico.</summary>
      <param name="type" vsli:raw="The constructed generic type whose constructor is returned.">O tipo genérico construído cujo construtor será retornado.</param>
      <param name="constructor" vsli:raw="A constructor on the generic type definition of &lt;paramref name=&quot;type&quot; /&gt;, which specifies which constructor of &lt;paramref name=&quot;type&quot; /&gt; to return.">Um construtor na definição de tipo genérico de <paramref name="type" />, que especifica qual construtor de <paramref name="type" /> será retornado.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.ConstructorInfo&quot; /&gt; object that represents the constructor of &lt;paramref name=&quot;type&quot; /&gt; corresponding to &lt;paramref name=&quot;constructor&quot; /&gt;, which specifies a constructor belonging to the generic type definition of &lt;paramref name=&quot;type&quot; /&gt;.">Um objeto <see cref="T:System.Reflection.ConstructorInfo" /> que representa o construtor de <paramref name="type" /> correspondente a <paramref name="constructor" />, que especifica um construtor pertencente à definição de tipo genérico de <paramref name="type" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;type&quot; /&gt; does not represent a generic type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;type&quot; /&gt; is not of type &lt;see cref=&quot;T:System.Reflection.Emit.TypeBuilder&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The declaring type of &lt;paramref name=&quot;constructor&quot; /&gt; is not a generic type definition.  &#xA;  &#xA; -or-  &#xA;  &#xA; The declaring type of &lt;paramref name=&quot;constructor&quot; /&gt; is not the generic type definition of &lt;paramref name=&quot;type&quot; /&gt;.">
        <paramref name="type" /> não representa um tipo genérico.  

ou - 
<paramref name="type" /> não é do tipo <see cref="T:System.Reflection.Emit.TypeBuilder" />.  

ou - 
O tipo declarativo de <paramref name="constructor" /> não é uma definição de tipo genérico.  

ou - 
O tipo declarativo de <paramref name="constructor" /> não é a definição de tipo genérico de <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)">
      <summary vsli:raw="Returns an array of &lt;see cref=&quot;T:System.Reflection.ConstructorInfo&quot; /&gt; objects representing the public and non-public constructors defined for this class, as specified.">Retorna uma matriz de objetos <see cref="T:System.Reflection.ConstructorInfo" /> que representam os construtores público e não público definidos para essa classe, conforme especificado.</summary>
      <param name="bindingAttr" vsli:raw="This must be a bit flag from &lt;see cref=&quot;T:System.Reflection.BindingFlags&quot; /&gt; as in &lt;see langword=&quot;InvokeMethod&quot; /&gt;, &lt;see langword=&quot;NonPublic&quot; /&gt;, and so on.">Esse deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />, tal como em <see langword="InvokeMethod" />, <see langword="NonPublic" /> e assim por diante.</param>
      <returns vsli:raw="Returns an array of &lt;see cref=&quot;T:System.Reflection.ConstructorInfo&quot; /&gt; objects representing the specified constructors defined for this class. If no constructors are defined, an empty array is returned.">Retorna uma matriz de objetos <see cref="T:System.Reflection.ConstructorInfo" /> que representam os construtores especificados definidos para esta classe. Se nenhum construtor for definido, uma matriz vazia será retornada.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not implemented for incomplete types.">Esse método não está implementado para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)">
      <summary vsli:raw="Returns all the custom attributes defined for this type.">Retorna todos os atributos personalizados definidos para esse tipo.</summary>
      <param name="inherit" vsli:raw="Specifies whether to search this member's inheritance chain to find the attributes.">Especifica se deve-se pesquisar ou não a cadeia de herança desse membro para localizar os atributos.</param>
      <returns vsli:raw="Returns an array of objects representing all the custom attributes of this type.">Retorna uma matriz de objetos que representa todos os atributos personalizados desse tipo.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported for incomplete types. Retrieve the type using &lt;see cref=&quot;M:System.Type.GetType&quot; /&gt; and call &lt;see cref=&quot;M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)&quot; /&gt; on the returned &lt;see cref=&quot;T:System.Type&quot; /&gt;.">Não há suporte para tipos incompletos nesse método atualmente. Recupere o tipo usando <see cref="M:System.Type.GetType" /> e chame <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> no <see cref="T:System.Type" /> retornado.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary vsli:raw="Returns all the custom attributes of the current type that are assignable to a specified type.">Retorna todos os atributos personalizados do tipo atual que podem ser atribuídos a um tipo especificado.</summary>
      <param name="attributeType" vsli:raw="The type of attribute to search for. Only attributes that are assignable to this type are returned.">O tipo de atributo a ser pesquisado. Somente os atributos que podem ser atribuídos a esse tipo são retornados.</param>
      <param name="inherit" vsli:raw="Specifies whether to search this member's inheritance chain to find the attributes.">Especifica se deve-se pesquisar ou não a cadeia de herança desse membro para localizar os atributos.</param>
      <returns vsli:raw="An array of custom attributes defined on the current type.">Uma matriz de atributos personalizados definida no tipo atual.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported for incomplete types. Retrieve the type using &lt;see cref=&quot;M:System.Type.GetType&quot; /&gt; and call &lt;see cref=&quot;M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)&quot; /&gt; on the returned &lt;see cref=&quot;T:System.Type&quot; /&gt;.">Não há suporte para tipos incompletos nesse método atualmente. Recupere o tipo usando <see cref="M:System.Type.GetType" /> e chame <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> no <see cref="T:System.Type" /> retornado.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;attributeType&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="attributeType" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The type must be a type provided by the underlying runtime system.">O tipo deve ser um tipo fornecido pelo sistema de tempo de execução subjacente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetElementType">
      <summary vsli:raw="Calling this method always throws &lt;see cref=&quot;T:System.NotSupportedException&quot; /&gt;.">A chamada desse método sempre lança <see cref="T:System.NotSupportedException" />.</summary>
      <returns vsli:raw="This method is not supported. No value is returned.">Não há suporte para o método. Nenhum valor é retornado.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not supported.">Não há suporte para o método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
      <summary vsli:raw="Returns the event with the specified name.">Retorna o evento com o nome especificado.</summary>
      <param name="name" vsli:raw="The name of the event to search for.">O nome do evento a ser pesquisado.</param>
      <param name="bindingAttr" vsli:raw="A bitwise combination of &lt;see cref=&quot;T:System.Reflection.BindingFlags&quot; /&gt; values that limits the search.">Uma combinação bit a bit de valores <see cref="T:System.Reflection.BindingFlags" /> que limita a pesquisa.</param>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Reflection.EventInfo&quot; /&gt; object representing the event declared or inherited by this type with the specified name, or &lt;see langword=&quot;null&quot; /&gt; if there are no matches.">Um objeto <see cref="T:System.Reflection.EventInfo" /> que representa o evento declarado ou herdado por esse tipo com o nome especificado ou <see langword="null" /> se não houver correspondências.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not implemented for incomplete types.">Esse método não está implementado para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetEvents">
      <summary vsli:raw="Returns the public events declared or inherited by this type.">Retorna os eventos públicos declarados ou herdados por esse tipo.</summary>
      <returns vsli:raw="Returns an array of &lt;see cref=&quot;T:System.Reflection.EventInfo&quot; /&gt; objects representing the public events declared or inherited by this type. An empty array is returned if there are no public events.">Retorna uma matriz de objetos <see cref="T:System.Reflection.EventInfo" /> que representa os eventos públicos declarados ou herdados por esse tipo. Uma matriz vazia será retornada se não houver eventos públicos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not implemented for incomplete types.">Esse método não está implementado para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)">
      <summary vsli:raw="Returns the public and non-public events that are declared by this type.">Retorna os eventos públicos e não públicos que são declarados por esse tipo.</summary>
      <param name="bindingAttr" vsli:raw="A bitwise combination of &lt;see cref=&quot;T:System.Reflection.BindingFlags&quot; /&gt; values that limits the search.">Uma combinação bit a bit de valores <see cref="T:System.Reflection.BindingFlags" /> que limita a pesquisa.</param>
      <returns vsli:raw="Returns an array of &lt;see cref=&quot;T:System.Reflection.EventInfo&quot; /&gt; objects representing the events declared or inherited by this type that match the specified binding flags. An empty array is returned if there are no matching events.">Retorna uma matriz de objetos <see cref="T:System.Reflection.EventInfo" /> que representa os eventos declarados ou herdados por esse tipo que correspondem aos sinalizadores de associação especificados. Uma matriz vazia será retornada se não houver eventos correspondentes.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not implemented for incomplete types.">Esse método não está implementado para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)">
      <summary vsli:raw="Returns the field specified by the given name.">Retorna o campo especificado pelo nome fornecido.</summary>
      <param name="name" vsli:raw="The name of the field to get.">O nome do campo a ser obtido.</param>
      <param name="bindingAttr" vsli:raw="This must be a bit flag from &lt;see cref=&quot;T:System.Reflection.BindingFlags&quot; /&gt; as in &lt;see langword=&quot;InvokeMethod&quot; /&gt;, &lt;see langword=&quot;NonPublic&quot; /&gt;, and so on.">Esse deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />, tal como em <see langword="InvokeMethod" />, <see langword="NonPublic" /> e assim por diante.</param>
      <returns vsli:raw="Returns the &lt;see cref=&quot;T:System.Reflection.FieldInfo&quot; /&gt; object representing the field declared or inherited by this type with the specified name and public or non-public modifier. If there are no matches then &lt;see langword=&quot;null&quot; /&gt; is returned.">Retorna o objeto <see cref="T:System.Reflection.FieldInfo" /> que representa o campo declarado ou herdado por esse tipo com o nome especificado e o modificador público ou não público. Se não houver correspondências, <see langword="null" /> será retornado.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not implemented for incomplete types.">Esse método não está implementado para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
      <summary vsli:raw="Returns the field of the specified constructed generic type that corresponds to the specified field of the generic type definition.">Retorna o campo de tipo genérico construído especificado que corresponde ao campo especificado da definição de tipo genérico.</summary>
      <param name="type" vsli:raw="The constructed generic type whose field is returned.">O tipo genérico construído cujo campo será retornado.</param>
      <param name="field" vsli:raw="A field on the generic type definition of &lt;paramref name=&quot;type&quot; /&gt;, which specifies which field of &lt;paramref name=&quot;type&quot; /&gt; to return.">Um campo na definição de tipo genérico de <paramref name="type" />, que especifica qual campo de <paramref name="type" /> será retornado.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.FieldInfo&quot; /&gt; object that represents the field of &lt;paramref name=&quot;type&quot; /&gt; corresponding to &lt;paramref name=&quot;field&quot; /&gt;, which specifies a field belonging to the generic type definition of &lt;paramref name=&quot;type&quot; /&gt;.">Um objeto <see cref="T:System.Reflection.FieldInfo" /> que representa o campo de <paramref name="type" /> correspondente a <paramref name="field" />, que especifica um campo pertencente à definição de tipo genérico de <paramref name="type" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;type&quot; /&gt; does not represent a generic type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;type&quot; /&gt; is not of type &lt;see cref=&quot;T:System.Reflection.Emit.TypeBuilder&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The declaring type of &lt;paramref name=&quot;field&quot; /&gt; is not a generic type definition.  &#xA;  &#xA; -or-  &#xA;  &#xA; The declaring type of &lt;paramref name=&quot;field&quot; /&gt; is not the generic type definition of &lt;paramref name=&quot;type&quot; /&gt;.">
        <paramref name="type" /> não representa um tipo genérico.  

ou - 
<paramref name="type" /> não é do tipo <see cref="T:System.Reflection.Emit.TypeBuilder" />.  

ou - 
O tipo declarativo de <paramref name="field" /> não é uma definição de tipo genérico.  

ou - 
O tipo declarativo de <paramref name="field" /> não é a definição de tipo genérico de <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)">
      <summary vsli:raw="Returns the public and non-public fields that are declared by this type.">Retorna os campos públicos e não públicos que são declarados por esse tipo.</summary>
      <param name="bindingAttr" vsli:raw="This must be a bit flag from &lt;see cref=&quot;T:System.Reflection.BindingFlags&quot; /&gt; : &lt;see langword=&quot;InvokeMethod&quot; /&gt;, &lt;see langword=&quot;NonPublic&quot; /&gt;, and so on.">Isso deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" /> e assim por diante.</param>
      <returns vsli:raw="Returns an array of &lt;see cref=&quot;T:System.Reflection.FieldInfo&quot; /&gt; objects representing the public and non-public fields declared or inherited by this type. An empty array is returned if there are no fields, as specified.">Retorna uma matriz de objetos <see cref="T:System.Reflection.FieldInfo" /> que representam os campos públicos e não públicos declarados ou herdados por esse tipo. Se não há campos, uma matriz vazia é retornada, conforme especificado.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not implemented for incomplete types.">Esse método não está implementado para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments">
      <summary vsli:raw="Returns an array of &lt;see cref=&quot;T:System.Type&quot; /&gt; objects representing the type arguments of a generic type or the type parameters of a generic type definition.">Retorna uma matriz de objetos <see cref="T:System.Type" /> que representam os argumentos de tipo de um tipo genérico ou os parâmetros de tipo de uma definição de tipo genérico.</summary>
      <returns vsli:raw="An array of &lt;see cref=&quot;T:System.Type&quot; /&gt; objects. The elements of the array represent the type arguments of a generic type or the type parameters of a generic type definition.">Uma matriz de objetos de <see cref="T:System.Type" />. Os elementos da matriz representam os argumentos de tipo de um tipo genérico ou os parâmetros de tipo de uma definição de tipo genérico.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents a generic type definition from which the current type can be obtained.">Retorna um objeto <see cref="T:System.Type" /> que representa uma definição de tipo genérico da qual o tipo atual pode ser obtido.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing a generic type definition from which the current type can be obtained.">Um objeto <see cref="T:System.Type" /> que representa uma definição de tipo genérico da qual o tipo atual pode ser obtido.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The current type is not generic. That is, &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.IsGenericType&quot; /&gt; returns &lt;see langword=&quot;false&quot; /&gt;.">O tipo atual não é genérico. Ou seja, <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> retorna <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)">
      <summary vsli:raw="Returns the interface implemented (directly or indirectly) by this class with the fully qualified name matching the given interface name.">Retorna a interface implementada (direta ou indiretamente) por essa classe com o nome totalmente qualificado correspondente ao nome de interface fornecido.</summary>
      <param name="name" vsli:raw="The name of the interface.">O nome da interface.</param>
      <param name="ignoreCase" vsli:raw="If &lt;see langword=&quot;true&quot; /&gt;, the search is case-insensitive. If &lt;see langword=&quot;false&quot; /&gt;, the search is case-sensitive.">Se <see langword="true" />, a pesquisa não diferenciará maiúsculas de minúsculas. Se <see langword="false" />, a pesquisa diferenciará maiúsculas de minúsculas.</param>
      <returns vsli:raw="Returns a &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the implemented interface. Returns null if no interface matching name is found.">Retorna um objeto <see cref="T:System.Type" /> que representa a interface implementada. Retorna nulo se nenhum nome de interface correspondente for encontrado.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not implemented for incomplete types.">Esse método não está implementado para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)">
      <summary vsli:raw="Returns an interface mapping for the requested interface.">Retorna um mapeamento de interface para a interface solicitada.</summary>
      <param name="interfaceType" vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; of the interface for which the mapping is to be retrieved.">O <see cref="T:System.Type" /> da interface para a qual o mapeamento deve ser recuperado.</param>
      <returns vsli:raw="Returns the requested interface mapping.">Retorna o mapeamento de interface solicitado.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not implemented for incomplete types.">Esse método não está implementado para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetInterfaces">
      <summary vsli:raw="Returns an array of all the interfaces implemented on this type and its base types.">Retorna uma matriz de todas as interfaces implementadas nesse tipo e seus tipos base.</summary>
      <returns vsli:raw="Returns an array of &lt;see cref=&quot;T:System.Type&quot; /&gt; objects representing the implemented interfaces. If none are defined, an empty array is returned.">Retorna uma matriz de objetos <see cref="T:System.Type" /> que representam as interfaces implementadas. Se nenhum deles for definido, uma matriz vazia será retornada.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
      <summary vsli:raw="Returns all the public and non-public members declared or inherited by this type, as specified.">Retorna todos os membros públicos e não públicos declarados ou herdados por esse tipo, conforme especificado.</summary>
      <param name="name" vsli:raw="The name of the member.">O nome do membro.</param>
      <param name="type" vsli:raw="The type of the member to return.">O tipo do membro a se retornar.</param>
      <param name="bindingAttr" vsli:raw="This must be a bit flag from &lt;see cref=&quot;T:System.Reflection.BindingFlags&quot; /&gt;, as in &lt;see langword=&quot;InvokeMethod&quot; /&gt;, &lt;see langword=&quot;NonPublic&quot; /&gt;, and so on.">Esse deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />, tal como em <see langword="InvokeMethod" />, <see langword="NonPublic" /> e assim por diante.</param>
      <returns vsli:raw="Returns an array of &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; objects representing the public and non-public members defined on this type if &lt;paramref name=&quot;nonPublic&quot; /&gt; is used; otherwise, only the public members are returned.">Retorna uma matriz de <see cref="T:System.Reflection.MemberInfo" /> objetos que representam os membros públicos e não públicos definidos nesse tipo se <paramref name="nonPublic" /> for usado; caso contrário, somente os membros públicos serão retornados.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not implemented for incomplete types.">Esse método não está implementado para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)">
      <summary vsli:raw="Returns the members for the public and non-public members declared or inherited by this type.">Retorna os membros dos membros públicos e não públicos declarados ou herdados por esse tipo.</summary>
      <param name="bindingAttr" vsli:raw="This must be a bit flag from &lt;see cref=&quot;T:System.Reflection.BindingFlags&quot; /&gt;, such as &lt;see langword=&quot;InvokeMethod&quot; /&gt;, &lt;see langword=&quot;NonPublic&quot; /&gt;, and so on.">Esse deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />, tal como <see langword="InvokeMethod" />, <see langword="NonPublic" /> e assim por diante.</param>
      <returns vsli:raw="Returns an array of &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; objects representing the public and non-public members declared or inherited by this type. An empty array is returned if there are no matching members.">Retorna uma matriz de objetos <see cref="T:System.Reflection.MemberInfo" /> que representam os membros públicos e não públicos declarados ou herdados por esse tipo. Se não houver membros correspondentes, uma matriz vazia será retornada.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not implemented for incomplete types.">Esse método não está implementado para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
      <summary vsli:raw="Returns the method of the specified constructed generic type that corresponds to the specified method of the generic type definition.">Retorna o método do tipo genérico construído especificado que corresponde ao método especificado da definição de tipo genérico.</summary>
      <param name="type" vsli:raw="The constructed generic type whose method is returned.">O tipo genérico construído cujo método será retornado.</param>
      <param name="method" vsli:raw="A method on the generic type definition of &lt;paramref name=&quot;type&quot; /&gt;, which specifies which method of &lt;paramref name=&quot;type&quot; /&gt; to return.">Um método na definição de tipo genérico de <paramref name="type" /> que especifica qual método de <paramref name="type" /> será retornado.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; object that represents the method of &lt;paramref name=&quot;type&quot; /&gt; corresponding to &lt;paramref name=&quot;method&quot; /&gt;, which specifies a method belonging to the generic type definition of &lt;paramref name=&quot;type&quot; /&gt;.">Um objeto <see cref="T:System.Reflection.MethodInfo" /> que representa o método de <paramref name="type" /> correspondente a <paramref name="method" />, que especifica um método pertencente à definição de tipo genérico de <paramref name="type" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is a generic method that is not a generic method definition.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;type&quot; /&gt; does not represent a generic type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;type&quot; /&gt; is not of type &lt;see cref=&quot;T:System.Reflection.Emit.TypeBuilder&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The declaring type of &lt;paramref name=&quot;method&quot; /&gt; is not a generic type definition.  &#xA;  &#xA; -or-  &#xA;  &#xA; The declaring type of &lt;paramref name=&quot;method&quot; /&gt; is not the generic type definition of &lt;paramref name=&quot;type&quot; /&gt;.">
        <paramref name="method" /> é um método genérico que não é uma definição de método genérico.  

ou - 
<paramref name="type" /> não representa um tipo genérico.  

ou - 
<paramref name="type" /> não é do tipo <see cref="T:System.Reflection.Emit.TypeBuilder" />.  

ou - 
O tipo declarativo de <paramref name="method" /> não é uma definição de tipo genérico.  

ou - 
O tipo declarativo de <paramref name="method" /> não é a definição de tipo genérico de <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)">
      <summary vsli:raw="Returns all the public and non-public methods declared or inherited by this type, as specified.">Retorna todos os métodos públicos e não públicos declarados ou herdados por esse tipo, conforme especificado.</summary>
      <param name="bindingAttr" vsli:raw="This must be a bit flag from &lt;see cref=&quot;T:System.Reflection.BindingFlags&quot; /&gt; as in &lt;see langword=&quot;InvokeMethod&quot; /&gt;, &lt;see langword=&quot;NonPublic&quot; /&gt;, and so on.">Esse deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />, tal como em <see langword="InvokeMethod" />, <see langword="NonPublic" /> e assim por diante.</param>
      <returns vsli:raw="Returns an array of &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; objects representing the public and non-public methods defined on this type if &lt;paramref name=&quot;nonPublic&quot; /&gt; is used; otherwise, only the public methods are returned.">Retorna uma matriz de objetos <see cref="T:System.Reflection.MethodInfo" /> que representam os métodos públicos e não públicos definidos neste tipo se <paramref name="nonPublic" /> for usado; caso contrário, somente os métodos públicos serão retornados.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not implemented for incomplete types.">Esse método não está implementado para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
      <summary vsli:raw="Returns the public and non-public nested types that are declared by this type.">Retorna os tipos aninhados públicos e não públicos declarados por esse tipo.</summary>
      <param name="name" vsli:raw="The &lt;see cref=&quot;T:System.String&quot; /&gt; containing the name of the nested type to get.">O <see cref="T:System.String" /> que contém o nome do tipo aninhado a ser obtido.</param>
      <param name="bindingAttr" vsli:raw="A bitmask comprised of one or more &lt;see cref=&quot;T:System.Reflection.BindingFlags&quot; /&gt; that specify how the search is conducted.  &#xA;  &#xA; -or-  &#xA;  &#xA; Zero, to conduct a case-sensitive search for public methods.">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.  

ou - 
Zero, para realizar uma pesquisa que diferencia maiúsculas de minúsculas para métodos públicos.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the nested type that matches the specified requirements, if found; otherwise, &lt;see langword=&quot;null&quot; /&gt;.">Um objeto <see cref="T:System.Type" /> que representa o tipo aninhado que corresponde aos requisitos especificados, se encontrado; caso contrário, <see langword="null" />.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not implemented for incomplete types.">Esse método não está implementado para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
      <summary vsli:raw="Returns the public and non-public nested types that are declared or inherited by this type.">Retorna os tipos aninhados públicos e não públicos que são declarados ou herdados por esse tipo.</summary>
      <param name="bindingAttr" vsli:raw="This must be a bit flag from &lt;see cref=&quot;T:System.Reflection.BindingFlags&quot; /&gt;, as in &lt;see langword=&quot;InvokeMethod&quot; /&gt;, &lt;see langword=&quot;NonPublic&quot; /&gt;, and so on.">Esse deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />, tal como em <see langword="InvokeMethod" />, <see langword="NonPublic" /> e assim por diante.</param>
      <returns vsli:raw="An array of &lt;see cref=&quot;T:System.Type&quot; /&gt; objects representing all the types nested within the current &lt;see cref=&quot;T:System.Type&quot; /&gt; that match the specified binding constraints.  &#xA;  &#xA; An empty array of type &lt;see cref=&quot;T:System.Type&quot; /&gt;, if no types are nested within the current &lt;see cref=&quot;T:System.Type&quot; /&gt;, or if none of the nested types match the binding constraints.">Uma matriz de objetos <see cref="T:System.Type" /> que representa todos os tipos aninhados no <see cref="T:System.Type" /> atual que correspondem às restrições de associação especificadas.  
Uma matriz vazia do tipo <see cref="T:System.Type" /> se nenhum tipo estiver aninhado no <see cref="T:System.Type" /> atual ou se nenhum dos tipos aninhados corresponderem às restrições de associação.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not implemented for incomplete types.">Esse método não está implementado para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)">
      <summary vsli:raw="Returns all the public and non-public properties declared or inherited by this type, as specified.">Retorna todas as propriedades públicas e não públicas declaradas ou herdadas por esse tipo, conforme especificado.</summary>
      <param name="bindingAttr" vsli:raw="This invocation attribute. This must be a bit flag from &lt;see cref=&quot;T:System.Reflection.BindingFlags&quot; /&gt; : &lt;see langword=&quot;InvokeMethod&quot; /&gt;, &lt;see langword=&quot;NonPublic&quot; /&gt;, and so on.">Esse atributo de invocação. Isso deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" /> e assim por diante.</param>
      <returns vsli:raw="Returns an array of &lt;see langword=&quot;PropertyInfo&quot; /&gt; objects representing the public and non-public properties defined on this type if &lt;paramref name=&quot;nonPublic&quot; /&gt; is used; otherwise, only the public properties are returned.">Retorna uma matriz de objetos <see langword="PropertyInfo" /> que representam as propriedades públicas e não públicas definidas nesse tipo se <paramref name="nonPublic" /> for usado; caso contrário, somente as propriedades públicas serão retornadas.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not implemented for incomplete types.">Esse método não está implementado para tipos incompletos.</exception>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.GUID">
      <summary vsli:raw="Retrieves the GUID of this type.">Recupera o GUID desse tipo.</summary>
      <returns vsli:raw="Read-only. Retrieves the GUID of this type.">Somente leitura. Recupera o GUID deste tipo</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported for incomplete types.">Não há suporte para tipos incompletos nesse método atualmente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
      <summary vsli:raw="Invokes the specified member. The method that is to be invoked must be accessible and provide the most specific match with the specified argument list, under the constraints of the specified binder and invocation attributes.">Invoca o membro especificado. O método a ser invocado deve ser acessível e fornecer a correspondência mais específica com a lista de argumentos especificada, sob as restrições dos atributos associadores e de invocação especificados.</summary>
      <param name="name" vsli:raw="The name of the member to invoke. This can be a constructor, method, property, or field. A suitable invocation attribute must be specified. Note that it is possible to invoke the default member of a class by passing an empty string as the name of the member.">O nome do membro a ser invocado. Isso pode ser um construtor, um método, uma propriedade ou um campo. É necessário especificar um atributo de invocação adequado. Observe que é possível invocar o membro padrão de uma classe, passando uma cadeia de caracteres vazia como o nome do membro.</param>
      <param name="invokeAttr" vsli:raw="The invocation attribute. This must be a bit flag from &lt;see langword=&quot;BindingFlags&quot; /&gt;.">O atributo de invocação. Isso deve ser um sinalizador de bit de <see langword="BindingFlags" />.</param>
      <param name="binder" vsli:raw="An object that enables the binding, coercion of argument types, invocation of members, and retrieval of &lt;see langword=&quot;MemberInfo&quot; /&gt; objects using reflection. If binder is &lt;see langword=&quot;null&quot; /&gt;, the default binder is used. See &lt;see cref=&quot;T:System.Reflection.Binder&quot; /&gt;.">Um objeto que permite a associação, a coerção de tipos de argumento, a invocação de membros e a recuperação de objetos <see langword="MemberInfo" /> usando reflexão. Se o associador for <see langword="null" />, o associador padrão será usado. Consulte <see cref="T:System.Reflection.Binder" />.</param>
      <param name="target" vsli:raw="The object on which to invoke the specified member. If the member is static, this parameter is ignored.">O objeto no qual invocar o membro especificado. Se o membro é estático, esse parâmetro é ignorado.</param>
      <param name="args" vsli:raw="An argument list. This is an array of Objects that contains the number, order, and type of the parameters of the member to be invoked. If there are no parameters this should be null.">Uma lista de argumentos. Essa é uma matriz de objetos que contém o número, a ordem e o tipo dos parâmetros do membro a ser invocado. Se não houver nenhum parâmetro, isso deverá ser nulo.</param>
      <param name="modifiers" vsli:raw="An array of the same length as &lt;paramref name=&quot;args&quot; /&gt; with elements that represent the attributes associated with the arguments of the member to be invoked. A parameter has attributes associated with it in the metadata. They are used by various interoperability services. See the metadata specs for more details.">Uma matriz do mesmo comprimento que <paramref name="args" /> com elementos que representam os atributos associados com os argumentos do membro a ser invocado. Um parâmetro com atributos associados a ele nos metadados. Eles são usados por diversos serviços de interoperabilidade. Consulte as especificações de metadados para obter mais detalhes.</param>
      <param name="culture" vsli:raw="An instance of &lt;see langword=&quot;CultureInfo&quot; /&gt; used to govern the coercion of types. If this is null, the &lt;see langword=&quot;CultureInfo&quot; /&gt; for the current thread is used. (Note that this is necessary to, for example, convert a String that represents 1000 to a Double value, since 1000 is represented differently by different cultures.)">Uma instância de <see langword="CultureInfo" /> usada para determinar a coerção de tipos. Se isso for nulo, será usado o <see langword="CultureInfo" /> do thread atual. (Por exemplo, isso é necessário para converter uma cadeia de caracteres que representa 1000 para um valor de tipo double, uma vez que 1000 é representado de forma diferente por diferentes culturas.)</param>
      <param name="namedParameters" vsli:raw="Each parameter in the &lt;paramref name=&quot;namedParameters&quot; /&gt; array gets the value in the corresponding element in the &lt;paramref name=&quot;args&quot; /&gt; array. If the length of &lt;paramref name=&quot;args&quot; /&gt; is greater than the length of &lt;paramref name=&quot;namedParameters&quot; /&gt;, the remaining argument values are passed in order.">Cada parâmetro na matriz <paramref name="namedParameters" /> obtém o valor no elemento correspondente na matriz <paramref name="args" />. Se o comprimento de <paramref name="args" /> for maior que o de <paramref name="namedParameters" />, os valores de argumento restantes serão passados em ordem.</param>
      <returns vsli:raw="Returns the return value of the invoked member.">Retorna o valor retornado do membro invocado.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported for incomplete types.">Não há suporte para tipos incompletos nesse método atualmente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Type)">
      <summary vsli:raw="Gets a value that indicates whether a specified &lt;see cref=&quot;T:System.Type&quot; /&gt; can be assigned to this object.">Obtém um valor que indica se um <see cref="T:System.Type" /> especificado pode ser atribuído a esse objeto.</summary>
      <param name="c" vsli:raw="The object to test.">O objeto a ser testado.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;paramref name=&quot;c&quot; /&gt; parameter and the current type represent the same type, or if the current type is in the inheritance hierarchy of &lt;paramref name=&quot;c&quot; /&gt;, or if the current type is an interface that &lt;paramref name=&quot;c&quot; /&gt; supports. &lt;see langword=&quot;false&quot; /&gt; if none of these conditions are valid, or if &lt;paramref name=&quot;c&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <see langword="true" /> se o parâmetro <paramref name="c" /> e o tipo atual representarem o mesmo tipo, se o tipo atual estiver na hierarquia de herança de <paramref name="c" /> ou se o tipo atual for uma interface à qual <paramref name="c" /> dá suporte. <see langword="false" /> se nenhuma dessas condições for válida ou se <paramref name="c" /> for <see langword="null" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsByRefLike" />
    <member name="P:System.Reflection.Emit.TypeBuilder.IsConstructedGenericType">
      <summary vsli:raw="Gets a value that indicates whether this object represents a constructed generic type.">Obtém um valor que indica se este objeto representa um tipo genérico construído.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if this object represents a constructed generic type; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se este objeto representar um tipo genérico construído; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.IsCreated">
      <summary vsli:raw="Returns a value that indicates whether the current dynamic type has been created.">Retorna um valor que indica se o tipo dinâmico atual foi criado.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt; method has been called; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o método <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> tiver sido chamado; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
      <summary vsli:raw="Determines whether a custom attribute is applied to the current type.">Determina se um atributo personalizado é aplicado ou tipo atual.</summary>
      <param name="attributeType" vsli:raw="The type of attribute to search for. Only attributes that are assignable to this type are returned.">O tipo de atributo a ser pesquisado. Somente os atributos que podem ser atribuídos a esse tipo são retornados.</param>
      <param name="inherit" vsli:raw="Specifies whether to search this member's inheritance chain to find the attributes.">Especifica se deve-se pesquisar ou não a cadeia de herança desse membro para localizar os atributos.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if one or more instances of &lt;paramref name=&quot;attributeType&quot; /&gt;, or an attribute derived from &lt;paramref name=&quot;attributeType&quot; /&gt;, is defined on this type; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se uma ou mais instâncias de <paramref name="attributeType" /> ou um atributo derivado de <paramref name="attributeType" /> forem definidos nesse tipo; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported for incomplete types. Retrieve the type using &lt;see cref=&quot;M:System.Type.GetType&quot; /&gt; and call &lt;see cref=&quot;M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)&quot; /&gt; on the returned &lt;see cref=&quot;T:System.Type&quot; /&gt;.">Não há suporte para tipos incompletos nesse método atualmente. Recupere o tipo usando <see cref="M:System.Type.GetType" /> e chame <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> no <see cref="T:System.Type" /> retornado.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;attributeType&quot; /&gt; is not defined.">
        <paramref name="attributeType" /> não está definido.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;attributeType&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="attributeType" /> é <see langword="null" />.</exception>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsGenericParameter">
      <summary vsli:raw="Gets a value indicating whether the current type is a generic type parameter.">Obtém um valor que indica se o tipo atual é um parâmetro de tipo genérico.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current &lt;see cref=&quot;T:System.Reflection.Emit.TypeBuilder&quot; /&gt; object represents a generic type parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />Se o objeto <see cref="T:System.Reflection.Emit.TypeBuilder" /> atual representa um parâmetro de tipo genérico; caso <see langword="false" />contrário,.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsGenericType">
      <summary vsli:raw="Gets a value indicating whether the current type is a generic type.">Obtém um valor que indica se o tipo atual é um tipo genérico.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the type represented by the current &lt;see cref=&quot;T:System.Reflection.Emit.TypeBuilder&quot; /&gt; object is generic; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />Se o tipo representado pelo objeto atual <see cref="T:System.Reflection.Emit.TypeBuilder" /> for genérico; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition">
      <summary vsli:raw="Gets a value indicating whether the current &lt;see cref=&quot;T:System.Reflection.Emit.TypeBuilder&quot; /&gt; represents a generic type definition from which other generic types can be constructed.">Obtém um valor que indica se o <see cref="T:System.Reflection.Emit.TypeBuilder" /> atual representa uma definição de tipo genérico, da qual outros tipos genéricos podem ser construídos.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if this &lt;see cref=&quot;T:System.Reflection.Emit.TypeBuilder&quot; /&gt; object represents a generic type definition; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />Se esse <see cref="T:System.Reflection.Emit.TypeBuilder" /> objeto representar uma definição de tipo genérico; caso <see langword="false" />contrário,.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
      <summary vsli:raw="Gets a value that indicates whether the current type is security-critical or security-safe-critical, and therefore can perform critical operations.">Obtém um valor que indica se o tipo atual é crítico para segurança ou crítico para segurança e disponível no código transparente e, portanto, pode executar operações críticas.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current type is security-critical or security-safe-critical; &lt;see langword=&quot;false&quot; /&gt; if it is transparent.">
        <see langword="true" />Se o tipo atual for Security-Critical ou Security-Safe-Critical; <see langword="false" /> se for transparente.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="The current dynamic type has not been created by calling the &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt; method.">O tipo dinâmico atual não foi criado chamando o método <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
      <summary vsli:raw="Gets a value that indicates whether the current type is security-safe-critical; that is, whether it can perform critical operations and can be accessed by transparent code.">Obtém um valor que indica se o tipo atual é crítico para segurança e disponível no código transparente, ou seja, se pode executar operações críticas e ser acessado por código transparente.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current type is security-safe-critical; &lt;see langword=&quot;false&quot; /&gt; if it is security-critical or transparent.">
        <see langword="true" />Se o tipo atual for segurança-seguro-crítico; <see langword="false" /> se for de segurança crítica ou transparente.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="The current dynamic type has not been created by calling the &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt; method.">O tipo dinâmico atual não foi criado chamando o método <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
      <summary vsli:raw="Gets a value that indicates whether the current type is transparent, and therefore cannot perform critical operations.">Obtém um valor que indica se o tipo atual é transparente e, portanto, não pode executar operações críticas.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the type is security-transparent; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />Se o tipo for de segurança transparente; caso contrário <see langword="false" />,.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="The current dynamic type has not been created by calling the &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt; method.">O tipo dinâmico atual não foi criado chamando o método <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.IsSubclassOf(System.Type)">
      <summary vsli:raw="Determines whether this type is derived from a specified type.">Determina se esse tipo é derivado de um tipo especificado.</summary>
      <param name="c" vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; that is to be checked.">Um <see cref="T:System.Type" /> que será verificado.</param>
      <returns vsli:raw="Read-only. Returns &lt;see langword=&quot;true&quot; /&gt; if this type is the same as the type &lt;paramref name=&quot;c&quot; /&gt;, or is a subtype of type &lt;paramref name=&quot;c&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Somente leitura. Retorna <see langword="true" /> se esse tipo for igual ao tipo <paramref name="c" /> ou um subtipo do tipo <paramref name="c" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsSZArray" />
    <member name="P:System.Reflection.Emit.TypeBuilder.IsTypeDefinition" />
    <member name="P:System.Reflection.Emit.TypeBuilder.IsVariableBoundArray" />
    <member name="M:System.Reflection.Emit.TypeBuilder.MakeArrayType">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents a one-dimensional array of the current type, with a lower bound of zero.">Retorna um objeto <see cref="T:System.Type" /> que representa uma matriz unidimensional do tipo atual, com um limite inferior de zero.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing a one-dimensional array type whose element type is the current type, with a lower bound of zero.">Um objeto <see cref="T:System.Type" /> que representa uma matriz unidimensional do tipo cujo tipo de elemento é o tipo atual, com um limite inferior de zero.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents an array of the current type, with the specified number of dimensions.">Retorna um objeto <see cref="T:System.Type" /> que representa uma matriz do tipo atual, com o número de dimensões especificado.</summary>
      <param name="rank" vsli:raw="The number of dimensions for the array.">O número de dimensões da matriz.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents a one-dimensional array of the current type.">Um objeto <see cref="T:System.Type" /> que representa uma matriz unidimensional do tipo atual.</returns>
      <exception cref="T:System.IndexOutOfRangeException" vsli:raw="&lt;paramref name=&quot;rank&quot; /&gt; is not a valid array dimension.">
        <paramref name="rank" /> não é uma dimensão de matriz válida.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.MakeByRefType">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents the current type when passed as a &lt;see langword=&quot;ref&quot; /&gt; parameter (&lt;see langword=&quot;ByRef&quot; /&gt; in Visual Basic).">Retorna um objeto <see cref="T:System.Type" /> que representa o tipo atual quando passado como um parâmetro <see langword="ref" /> (<see langword="ByRef" /> no Visual Basic).</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents the current type when passed as a &lt;see langword=&quot;ref&quot; /&gt; parameter (&lt;see langword=&quot;ByRef&quot; /&gt; in Visual Basic).">Um objeto <see cref="T:System.Type" /> que representa o tipo atual quando passado como um parâmetro <see langword="ref" /> (<see langword="ByRef" /> no Visual Basic).</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
      <summary vsli:raw="Substitutes the elements of an array of types for the type parameters of the current generic type definition, and returns the resulting constructed type.">Substitui os elementos de uma matriz de tipos pelos parâmetros de tipo da definição de tipo genérico atual e retorna o tipo construído resultante.</summary>
      <param name="typeArguments" vsli:raw="An array of types to be substituted for the type parameters of the current generic type definition.">Uma matriz de tipos a serem substituídos pelos parâmetros da definição de tipo genérico atual.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; representing the constructed type formed by substituting the elements of &lt;paramref name=&quot;typeArguments&quot; /&gt; for the type parameters of the current generic type.">Um <see cref="T:System.Type" /> representando o tipo construído formado substituindo os elementos do <paramref name="typeArguments" /> pelos parâmetros de tipo do tipo genérico atual.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The current type does not represent the definition of a generic type. That is, &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition&quot; /&gt; returns &lt;see langword=&quot;false&quot; /&gt;.">O tipo atual não representa a definição de um tipo genérico. Ou seja, <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> retorna <see langword="false" />.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;typeArguments&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; Any element of &lt;paramref name=&quot;typeArguments&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="typeArguments" /> é <see langword="null" />.  

ou - 
Qualquer elemento de <paramref name="typeArguments" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;see cref=&quot;P:System.Type.Module&quot; /&gt; property of any element of &lt;paramref name=&quot;typeArguments&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Reflection.Module.Assembly&quot; /&gt; property of the module of any element of &lt;paramref name=&quot;typeArguments&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">A propriedade <see cref="P:System.Type.Module" /> de qualquer elemento de <paramref name="typeArguments" /> é <see langword="null" />.  

ou - 
A propriedade <see cref="P:System.Reflection.Module.Assembly" /> do módulo de qualquer elemento de <paramref name="typeArguments" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.MakePointerType">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents the type of an unmanaged pointer to the current type.">Retorna um objeto <see cref="T:System.Type" /> que representa o tipo de um ponteiro não gerenciado para o tipo atual.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents the type of an unmanaged pointer to the current type.">Um objeto <see cref="T:System.Type" /> que representa o tipo de um ponteiro não gerenciado para o tipo atual.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.Module">
      <summary vsli:raw="Retrieves the dynamic module that contains this type definition.">Recupera o módulo dinâmico que contém essa definição de tipo.</summary>
      <returns vsli:raw="Read-only. Retrieves the dynamic module that contains this type definition.">Somente leitura. Recupera o módulo dinâmico que contém essa definição de tipo.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.Name">
      <summary vsli:raw="Retrieves the name of this type.">Recupera o nome desse tipo.</summary>
      <returns vsli:raw="Read-only. Retrieves the &lt;see cref=&quot;T:System.String&quot; /&gt; name of this type.">Somente leitura. Recupera o <see cref="T:System.String" /> nome deste tipo.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.Namespace">
      <summary vsli:raw="Retrieves the namespace where this &lt;see langword=&quot;TypeBuilder&quot; /&gt; is defined.">Recupera o namespace em que esse <see langword="TypeBuilder" /> é definido.</summary>
      <returns vsli:raw="Read-only. Retrieves the namespace where this &lt;see langword=&quot;TypeBuilder&quot; /&gt; is defined.">Somente leitura. Recupera o namespace em que esse <see langword="TypeBuilder" /> é definido.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.PackingSize">
      <summary vsli:raw="Retrieves the packing size of this type.">Recupera o tamanho de empacotamento desse tipo.</summary>
      <returns vsli:raw="Read-only. Retrieves the packing size of this type.">Somente leitura. Recupera o tamanho de empacotamento desse tipo.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.ReflectedType">
      <summary vsli:raw="Returns the type that was used to obtain this type.">Retorna o tipo usado para obter esse tipo.</summary>
      <returns vsli:raw="Read-only. The type that was used to obtain this type.">Somente leitura. O tipo que foi usado para obter esse tipo.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary vsli:raw="Sets a custom attribute using a specified custom attribute blob.">Define um atributo personalizado usando um blob de atributo personalizado especificado.</summary>
      <param name="con" vsli:raw="The constructor for the custom attribute.">O construtor do atributo personalizado.</param>
      <param name="binaryAttribute" vsli:raw="A byte blob representing the attributes.">Um blob de bytes que representa os atributos.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;con&quot; /&gt; or &lt;paramref name=&quot;binaryAttribute&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="con" /> ou <paramref name="binaryAttribute" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="For the current dynamic type, the &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.IsGenericType&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;, but the &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition&quot; /&gt; property is &lt;see langword=&quot;false&quot; /&gt;.">Para o tipo dinâmico atual, a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> é <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary vsli:raw="Set a custom attribute using a custom attribute builder.">Defina um atributo personalizado usando um construtor de atributos personalizados.</summary>
      <param name="customBuilder" vsli:raw="An instance of a helper class to define the custom attribute.">Uma instância de uma classe auxiliar para definir o atributo personalizado.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;customBuilder&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="customBuilder" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="For the current dynamic type, the &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.IsGenericType&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;, but the &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition&quot; /&gt; property is &lt;see langword=&quot;false&quot; /&gt;.">Para o tipo dinâmico atual, a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> é <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
      <summary vsli:raw="Sets the base type of the type currently under construction.">Define o tipo base do tipo em construção atualmente.</summary>
      <param name="parent" vsli:raw="The new base type.">O novo tipo base.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The type was previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;parent&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;, and the current instance represents an interface whose attributes do not include &lt;see cref=&quot;F:System.Reflection.TypeAttributes.Abstract&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; For the current dynamic type, the &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.IsGenericType&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;, but the &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition&quot; /&gt; property is &lt;see langword=&quot;false&quot; /&gt;.">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  

ou - 
<paramref name="parent" /> é <see langword="null" /> e a instância atual representa uma interface cujos atributos não incluem <see cref="F:System.Reflection.TypeAttributes.Abstract" />.  

ou - 
Para o tipo dinâmico atual, a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> é <see langword="false" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;parent&quot; /&gt; is an interface. This exception condition is new in the .NET Framework version 2.0.">
        <paramref name="parent" /> é uma interface. Essa condição de exceção é nova na versão 2.0 do .NET Framework.</exception>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.Size">
      <summary vsli:raw="Retrieves the total size of a type.">Recupera o tamanho total de um tipo.</summary>
      <returns vsli:raw="Read-only. Retrieves this type's total size.">Somente leitura. Recupera o tamanho total deste tipo.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.ToString">
      <summary vsli:raw="Returns the name of the type excluding the namespace.">Retorna o nome do tipo excluindo o namespace.</summary>
      <returns vsli:raw="Read-only. The name of the type excluding the namespace.">Somente leitura. O nome do tipo excluindo o namespace.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.TypeHandle">
      <summary vsli:raw="Not supported in dynamic modules.">Não tem suporte em módulos dinâmicos.</summary>
      <returns vsli:raw="Read-only.">Somente leitura.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="Not supported in dynamic modules.">Não tem suporte em módulos dinâmicos.</exception>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.UnderlyingSystemType">
      <summary vsli:raw="Returns the underlying system type for this &lt;see langword=&quot;TypeBuilder&quot; /&gt;.">Retorna o tipo de sistema subjacente para esse <see langword="TypeBuilder" />.</summary>
      <returns vsli:raw="Read-only. Returns the underlying system type.">Somente leitura. Retorna o tipo de sistema subjacente.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="This type is an enumeration, but there is no underlying system type.">Esse tipo é uma enumeração, mas não há um tipo de sistema subjacente.</exception>
    </member>
    <member name="F:System.Reflection.Emit.TypeBuilder.UnspecifiedTypeSize">
      <summary vsli:raw="Represents that total size for the type is not specified.">Representa a não especificação do tamanho total do tipo.</summary>
    </member>
  </members>
</doc>