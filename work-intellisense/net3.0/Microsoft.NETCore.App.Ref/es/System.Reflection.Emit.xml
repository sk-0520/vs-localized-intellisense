<?xml version="1.0" encoding="utf-8"?>
<doc xmlns:vsli="https://github.com/sk-0520/vs-localized-intellisense/tree/master/schema/2024">
  <assembly>
    <name>System.Reflection.Emit</name>
  </assembly>
  <members>
    <member name="T:System.Reflection.Emit.AssemblyBuilder">
      <summary vsli:raw="Defines and represents a dynamic assembly.">Define y representa un ensamblado dinámico.</summary>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.CodeBase">
      <summary vsli:raw="Gets the location of the assembly, as specified originally (such as in an &lt;see cref=&quot;T:System.Reflection.AssemblyName&quot; /&gt; object).">Obtiene la ubicación del ensamblado tal y como se especificó originalmente (como en un objeto <see cref="T:System.Reflection.AssemblyName" />).</summary>
      <returns vsli:raw="The location of the assembly, as specified originally.">Ubicación del ensamblado tal y como se especificó originalmente.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported.">Este método no se admite actualmente.</exception>
      <exception cref="T:System.Security.SecurityException" vsli:raw="The caller does not have the required permission.">El llamador no dispone del permiso requerido.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
      <summary vsli:raw="Defines a dynamic assembly that has the specified name and access rights.">Define un ensamblado dinámico que tiene los derechos de acceso y nombre especificados.</summary>
      <param name="name" vsli:raw="The name of the assembly.">Nombre del ensamblado.</param>
      <param name="access" vsli:raw="The access rights of the assembly.">Derechos de acceso del ensamblado.</param>
      <returns vsli:raw="An object that represents the new assembly.">Un objeto que representa el nuevo ensamblado.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
      <summary vsli:raw="Defines a new assembly that has the specified name, access rights, and attributes.">Define un nuevo ensamblado que tiene el nombre, los derechos de acceso y los atributos especificados.</summary>
      <param name="name" vsli:raw="The name of the assembly.">Nombre del ensamblado.</param>
      <param name="access" vsli:raw="The access rights of the assembly.">Derechos de acceso del ensamblado.</param>
      <param name="assemblyAttributes" vsli:raw="A collection that contains the attributes of the assembly.">Colección que contiene los atributos del ensamblado.</param>
      <returns vsli:raw="An object that represents the new assembly.">Un objeto que representa el nuevo ensamblado.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String)">
      <summary vsli:raw="Defines a named transient dynamic module in this assembly.">Define un módulo dinámico transitorio con nombre en este ensamblado.</summary>
      <param name="name" vsli:raw="The name of the dynamic module.">Nombre del módulo dinámico.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Emit.ModuleBuilder&quot; /&gt; representing the defined dynamic module.">
        <see cref="T:System.Reflection.Emit.ModuleBuilder" /> que representa el módulo dinámico definido.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; begins with white space.&#xA;&#xA; -or-&#xA;&#xA; The length of &lt;paramref name=&quot;name&quot; /&gt; is zero.&#xA;&#xA; -or-&#xA;&#xA; The length of &lt;paramref name=&quot;name&quot; /&gt; is greater than the system-defined maximum length.">
        <paramref name="name" /> empieza por un espacio en blanco.  
o bien 
La longitud de <paramref name="name" /> es cero.  
o bien 
La longitud de <paramref name="name" /> es superior a la longitud máxima definida por el sistema.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Security.SecurityException" vsli:raw="The caller does not have the required permission.">El llamador no dispone del permiso requerido.</exception>
      <exception cref="T:System.ExecutionEngineException" vsli:raw="The assembly for default symbol writer cannot be loaded.&#xA;&#xA; -or-&#xA;&#xA; The type that implements the default symbol writer interface cannot be found.">No se puede cargar el ensamblado para el sistema de escritura de símbolos predeterminado.  
 o bien  
 No se encuentra el tipo que implementa la interfaz del sistema de escritura de símbolos predeterminado.</exception>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.EntryPoint">
      <summary vsli:raw="Returns the entry point of this assembly.">Devuelve el punto de entrada de este ensamblado.</summary>
      <returns vsli:raw="The entry point of this assembly.">Punto de entrada de este ensamblado.</returns>
      <exception cref="T:System.Security.SecurityException" vsli:raw="The caller does not have the required permission.">El llamador no dispone del permiso requerido.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.Equals(System.Object)">
      <summary vsli:raw="Returns a value that indicates whether this instance is equal to the specified object.">Devuelve un valor que indica si esta instancia es igual que el objeto especificado.</summary>
      <param name="obj" vsli:raw="An object to compare with this instance, or &lt;see langword=&quot;null&quot; /&gt;.">Objeto que se va a comparar con esta instancia o <see langword="null" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;obj&quot; /&gt; equals the type and value of this instance; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si <paramref name="obj" /> es igual al tipo y valor de esta instancia; en caso contrario, es <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.FullName">
      <summary vsli:raw="Gets the display name of the current dynamic assembly.">Obtiene el nombre para mostrar del ensamblado dinámico actual.</summary>
      <returns vsli:raw="The display name of the dynamic assembly.">Nombre para mostrar del ensamblado dinámico.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetCustomAttributes(System.Boolean)">
      <summary vsli:raw="Returns all the custom attributes that have been applied to the current &lt;see cref=&quot;T:System.Reflection.Emit.AssemblyBuilder&quot; /&gt;.">Devuelve todos los atributos personalizados que se aplicaron al <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> actual.</summary>
      <param name="inherit" vsli:raw="This argument is ignored for objects of this type.">Se omite este argumento para los objetos de este tipo.</param>
      <returns vsli:raw="An array that contains the custom attributes; the array is empty if there are no attributes.">Matriz que contiene los atributos personalizados; la matriz está vacía si no hay ningún atributo.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary vsli:raw="Returns all the custom attributes that have been applied to the current &lt;see cref=&quot;T:System.Reflection.Emit.AssemblyBuilder&quot; /&gt;, and that derive from a specified attribute type.">Devuelve todos los atributos personalizados que se aplicaron al <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> actual y que derivan de un tipo de atributo especificado.</summary>
      <param name="attributeType" vsli:raw="The base type from which attributes derive.">Tipo base del que derivan los atributos.</param>
      <param name="inherit" vsli:raw="This argument is ignored for objects of this type.">Se omite este argumento para los objetos de este tipo.</param>
      <returns vsli:raw="An array that contains the custom attributes that are derived at any level from &lt;paramref name=&quot;attributeType&quot; /&gt;; the array is empty if there are no such attributes.">Matriz que contiene los atributos personalizados que se derivan en cualquier nivel de <paramref name="attributeType" />; la matriz está vacía si no hay ninguno de esos atributos.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;attributeType&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="attributeType" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;attributeType&quot; /&gt; is not a &lt;see cref=&quot;T:System.Type&quot; /&gt; object supplied by the runtime. For example, &lt;paramref name=&quot;attributeType&quot; /&gt; is a &lt;see cref=&quot;T:System.Reflection.Emit.TypeBuilder&quot; /&gt; object.">
        <paramref name="attributeType" /> no es un objeto <see cref="T:System.Type" /> proporcionado por el tiempo de ejecución. Por ejemplo, <paramref name="attributeType" /> es un objeto <see cref="T:System.Reflection.Emit.TypeBuilder" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetCustomAttributesData">
      <summary vsli:raw="Returns &lt;see cref=&quot;T:System.Reflection.CustomAttributeData&quot; /&gt; objects that contain information about the attributes that have been applied to the current &lt;see cref=&quot;T:System.Reflection.Emit.AssemblyBuilder&quot; /&gt;.">Devuelve objetos <see cref="T:System.Reflection.CustomAttributeData" /> que contienen información sobre los atributos que se han aplicado a la clase <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> actual.</summary>
      <returns vsli:raw="A generic list of &lt;see cref=&quot;T:System.Reflection.CustomAttributeData&quot; /&gt; objects representing data about the attributes that have been applied to the current module.">Lista genérica de objetos <see cref="T:System.Reflection.CustomAttributeData" /> que representan datos sobre los atributos que se aplicaron al módulo actual.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule(System.String)">
      <summary vsli:raw="Returns the dynamic module with the specified name.">Devuelve el módulo dinámico con el nombre especificado.</summary>
      <param name="name" vsli:raw="The name of the requested dynamic module.">Nombre del módulo dinámico solicitado.</param>
      <returns vsli:raw="A ModuleBuilder object representing the requested dynamic module.">Objeto ModuleBuilder que representa el módulo dinámico solicitado.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The length of &lt;paramref name=&quot;name&quot; /&gt; is zero.">La longitud de <paramref name="name" /> es cero.</exception>
      <exception cref="T:System.Security.SecurityException" vsli:raw="The caller does not have the required permission.">El llamador no dispone del permiso requerido.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetExportedTypes">
      <summary vsli:raw="Gets the exported types defined in this assembly.">Obtiene los tipos exportados definidos en este ensamblado.</summary>
      <returns vsli:raw="An array of &lt;see cref=&quot;T:System.Type&quot; /&gt; containing the exported types defined in this assembly.">Matriz de <see cref="T:System.Type" /> que contiene los tipos exportados definidos en este ensamblado.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not implemented.">Este método no se implementa.</exception>
      <exception cref="T:System.Security.SecurityException" vsli:raw="The caller does not have the required permission.">El llamador no dispone del permiso requerido.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetFile(System.String)">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.IO.FileStream&quot; /&gt; for the specified file in the file table of the manifest of this assembly.">Obtiene un objeto <see cref="T:System.IO.FileStream" /> para el archivo especificado en la tabla de archivos del manifiesto de este ensamblado.</summary>
      <param name="name" vsli:raw="The name of the specified file.">Nombre del archivo especificado.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.IO.FileStream&quot; /&gt; for the specified file, or &lt;see langword=&quot;null&quot; /&gt;, if the file is not found.">
        <see cref="T:System.IO.FileStream" /> para el archivo especificado, o <see langword="null" /> si no se encuentra el archivo.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported.">Este método no se admite actualmente.</exception>
      <exception cref="T:System.Security.SecurityException" vsli:raw="The caller does not have the required permission.">El llamador no dispone del permiso requerido.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetFiles(System.Boolean)">
      <summary vsli:raw="Gets the files in the file table of an assembly manifest, specifying whether to include resource modules.">Obtiene los archivos en la tabla de archivos del manifiesto del ensamblado, especificando si deben incluirse módulos de recursos.</summary>
      <param name="getResourceModules" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to include resource modules; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para incluir módulos de recursos; en caso contrario, <see langword="false" />.</param>
      <returns vsli:raw="An array of &lt;see cref=&quot;T:System.IO.FileStream&quot; /&gt; objects.">Matriz de objetos <see cref="T:System.IO.FileStream" />.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported.">Este método no se admite actualmente.</exception>
      <exception cref="T:System.Security.SecurityException" vsli:raw="The caller does not have the required permission.">El llamador no dispone del permiso requerido.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetHashCode">
      <summary vsli:raw="Returns the hash code for this instance.">Devuelve el código hash de esta instancia.</summary>
      <returns vsli:raw="A 32-bit signed integer hash code.">Código hash de un entero de 32 bits con signo.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetLoadedModules(System.Boolean)">
      <summary vsli:raw="Returns all the loaded modules that are part of this assembly, and optionally includes resource modules.">Devuelve todos los módulos cargados que forman parte de este ensamblado y, opcionalmente, incluye módulos de recursos.</summary>
      <param name="getResourceModules" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to include resource modules; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para incluir módulos de recursos; en caso contrario, <see langword="false" />.</param>
      <returns vsli:raw="The loaded modules that are part of this assembly.">Módulos cargados que forman parte de este ensamblado.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceInfo(System.String)">
      <summary vsli:raw="Returns information about how the given resource has been persisted.">Devuelve información sobre cómo el recurso dado ha persistido.</summary>
      <param name="resourceName" vsli:raw="The name of the resource.">Nombre del recurso.</param>
      <returns vsli:raw="&lt;see cref=&quot;T:System.Reflection.ManifestResourceInfo&quot; /&gt; populated with information about the resource's topology, or &lt;see langword=&quot;null&quot; /&gt; if the resource is not found.">
        <see cref="T:System.Reflection.ManifestResourceInfo" /> se llena con información sobre la topología del recurso o <see langword="null" /> si no se encuentra el recurso en cuestión.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported.">Este método no se admite actualmente.</exception>
      <exception cref="T:System.Security.SecurityException" vsli:raw="The caller does not have the required permission.">El llamador no dispone del permiso requerido.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceNames">
      <summary vsli:raw="Loads the specified manifest resource from this assembly.">Carga el recurso del manifiesto especificado a partir de este ensamblado.</summary>
      <returns vsli:raw="An array of type &lt;see langword=&quot;String&quot; /&gt; containing the names of all the resources.">Matriz de tipo <see langword="String" /> que contiene los nombres de todos los recursos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not supported on a dynamic assembly. To get the manifest resource names, use &lt;see cref=&quot;M:System.Reflection.Assembly.GetManifestResourceNames&quot; /&gt;.">Este método no se admite en un ensamblado dinámico. Para obtener los nombre de los recursos del manifiesto, utilice el método <see cref="M:System.Reflection.Assembly.GetManifestResourceNames" />.</exception>
      <exception cref="T:System.Security.SecurityException" vsli:raw="The caller does not have the required permission.">El llamador no dispone del permiso requerido.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceStream(System.String)">
      <summary vsli:raw="Loads the specified manifest resource from this assembly.">Carga el recurso del manifiesto especificado a partir de este ensamblado.</summary>
      <param name="name" vsli:raw="The name of the manifest resource being requested.">Nombre del recurso del manifiesto que se solicita.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.IO.Stream&quot; /&gt; representing this manifest resource.">
        <see cref="T:System.IO.Stream" /> representa al recurso de este manifiesto.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported.">Este método no se admite actualmente.</exception>
      <exception cref="T:System.Security.SecurityException" vsli:raw="The caller does not have the required permission.">El llamador no dispone del permiso requerido.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceStream(System.Type,System.String)">
      <summary vsli:raw="Loads the specified manifest resource, scoped by the namespace of the specified type, from this assembly.">Carga el recurso del manifiesto especificado según el espacio de nombres del tipo especificado a partir de este ensamblado.</summary>
      <param name="type" vsli:raw="The type whose namespace is used to scope the manifest resource name.">Tipo cuyo espacio de nombres se utiliza para establecer el nombre de recurso del manifiesto.</param>
      <param name="name" vsli:raw="The name of the manifest resource being requested.">Nombre del recurso del manifiesto que se solicita.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.IO.Stream&quot; /&gt; representing this manifest resource.">
        <see cref="T:System.IO.Stream" /> representa al recurso de este manifiesto.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported.">Este método no se admite actualmente.</exception>
      <exception cref="T:System.Security.SecurityException" vsli:raw="The caller does not have the required permission.">El llamador no dispone del permiso requerido.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetModule(System.String)">
      <summary vsli:raw="Gets the specified module in this assembly.">Obtiene el módulo especificado en este ensamblado.</summary>
      <param name="name" vsli:raw="The name of the requested module.">Nombre del módulo solicitado.</param>
      <returns vsli:raw="The module being requested, or &lt;see langword=&quot;null&quot; /&gt; if the module is not found.">Módulo que se solicita o <see langword="null" /> si no se encuentra el módulo.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetModules(System.Boolean)">
      <summary vsli:raw="Gets all the modules that are part of this assembly, and optionally includes resource modules.">Obtiene todos los módulos que forman parte de este ensamblado y, opcionalmente, incluye módulos de recursos.</summary>
      <param name="getResourceModules" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to include resource modules; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para incluir módulos de recursos; en caso contrario, <see langword="false" />.</param>
      <returns vsli:raw="The modules that are part of this assembly.">Módulos que forman parte de este ensamblado.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetName(System.Boolean)">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Reflection.AssemblyName&quot; /&gt; that was specified when the current dynamic assembly was created, and sets the code base as specified.">Obtiene el objeto <see cref="T:System.Reflection.AssemblyName" /> que se especificó cuando se creó el ensamblado dinámico actual, y establece el código base tal y como se especifica.</summary>
      <param name="copiedName" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set the code base to the location of the assembly after it is shadow-copied; &lt;see langword=&quot;false&quot; /&gt; to set the code base to the original location.">Es <see langword="true" /> para establecer el código base en la ubicación del ensamblado después de realizar una copia sombra; es <see langword="false" /> para establecer el código base en la ubicación original.</param>
      <returns vsli:raw="The name of the dynamic assembly.">Nombre del ensamblado dinámico.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetReferencedAssemblies">
      <summary vsli:raw="Gets an incomplete list of &lt;see cref=&quot;T:System.Reflection.AssemblyName&quot; /&gt; objects for the assemblies that are referenced by this &lt;see cref=&quot;T:System.Reflection.Emit.AssemblyBuilder&quot; /&gt;.">Obtiene una lista incompleta de objetos <see cref="T:System.Reflection.AssemblyName" /> para los ensamblados a los que hace referencia esta clase <see cref="T:System.Reflection.Emit.AssemblyBuilder" />.</summary>
      <returns vsli:raw="An array of assembly names for the referenced assemblies. This array is not a complete list.">Matriz de nombres de ensamblado para los ensamblados a los que se hace referencia. Esta matriz no es una lista completa.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetSatelliteAssembly(System.Globalization.CultureInfo)">
      <summary vsli:raw="Gets the satellite assembly for the specified culture.">Obtiene el ensamblado satélite para la referencia cultural especificada.</summary>
      <param name="culture" vsli:raw="The specified culture.">Referencia cultural especificada.</param>
      <returns vsli:raw="The specified satellite assembly.">Ensamblado satélite especificado.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;culture&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="culture" /> es <see langword="null" />.</exception>
      <exception cref="T:System.IO.FileNotFoundException" vsli:raw="The assembly cannot be found.">No se encuentra el ensamblado.</exception>
      <exception cref="T:System.IO.FileLoadException" vsli:raw="The satellite assembly with a matching file name was found, but the &lt;see langword=&quot;CultureInfo&quot; /&gt; did not match the one specified.">Se encontró un ensamblado satélite con un nombre de archivo coincidente, pero la <see langword="CultureInfo" /> no coincidía con la especificada.</exception>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The satellite assembly is not a valid assembly.">El ensamblado satélite no es un ensamblado válido.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
      <summary vsli:raw="Gets the specified version of the satellite assembly for the specified culture.">Obtiene la versión especificada del ensamblado satélite para la referencia cultural especificada.</summary>
      <param name="culture" vsli:raw="The specified culture.">Referencia cultural especificada.</param>
      <param name="version" vsli:raw="The version of the satellite assembly.">Versión del ensamblado satélite.</param>
      <returns vsli:raw="The specified satellite assembly.">Ensamblado satélite especificado.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;culture&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="culture" /> es <see langword="null" />.</exception>
      <exception cref="T:System.IO.FileLoadException" vsli:raw="The satellite assembly with a matching file name was found, but the &lt;see langword=&quot;CultureInfo&quot; /&gt; or the version did not match the one specified.">Se encontró un ensamblado satélite con un nombre de archivo coincidente, pero la <see langword="CultureInfo" /> o la versión no coincidía con la especificada.</exception>
      <exception cref="T:System.IO.FileNotFoundException" vsli:raw="The assembly cannot be found.">No se encuentra el ensamblado.</exception>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The satellite assembly is not a valid assembly.">El ensamblado satélite no es un ensamblado válido.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetType(System.String,System.Boolean,System.Boolean)">
      <summary vsli:raw="Gets the specified type from the types that have been defined and created in the current &lt;see cref=&quot;T:System.Reflection.Emit.AssemblyBuilder&quot; /&gt;.">Obtiene el tipo especificado de los tipos que se han definido y creado en la clase <see cref="T:System.Reflection.Emit.AssemblyBuilder" />actual.</summary>
      <param name="name" vsli:raw="The name of the type to search for.">Nombre del tipo que se va a buscar.</param>
      <param name="throwOnError" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to throw an exception if the type is not found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para producir una excepción si no se encuentra el tipo; de lo contrario, <see langword="false" />.</param>
      <param name="ignoreCase" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to ignore the case of the type name when searching; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para no distinguir entre mayúsculas y minúsculas en el nombre del tipo durante la búsqueda; de lo contrario, <see langword="false" />.</param>
      <returns vsli:raw="The specified type, or &lt;see langword=&quot;null&quot; /&gt; if the type is not found or has not been created yet.">Tipo especificado, o <see langword="null" /> si el tipo no se encuentra o no se ha creado todavía.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.GlobalAssemblyCache">
      <summary>Obtiene un valor que indica si el ensamblado se ha cargado desde la memoria caché global de ensamblados.</summary>
      <returns>Siempre es <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.HostContext">
      <summary vsli:raw="Gets the host context where the dynamic assembly is being created.">Obtiene el contexto del host donde se está creando el ensamblado dinámico.</summary>
      <returns vsli:raw="A value that indicates the host context where the dynamic assembly is being created.">Valor que indica el contexto del host donde se está creando el ensamblado dinámico.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.ImageRuntimeVersion">
      <summary>Obtiene la versión de Common Language Runtime que se guardará en el archivo que contiene el manifiesto.</summary>
      <returns>Cadena que representa la versión de Common Language Runtime.</returns>
      <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.IsDefined(System.Type,System.Boolean)">
      <summary vsli:raw="Returns a value that indicates whether one or more instances of the specified attribute type is applied to this member.">Devuelve un valor que indica si se aplican una o más instancias del tipo de atributo especificado a este miembro.</summary>
      <param name="attributeType" vsli:raw="The type of attribute to test for.">Tipo de atributo que se va a probar.</param>
      <param name="inherit" vsli:raw="This argument is ignored for objects of this type.">Se omite este argumento para los objetos de este tipo.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if one or more instances of &lt;paramref name=&quot;attributeType&quot; /&gt; is applied to this dynamic assembly; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si se aplican una o más instancias de <paramref name="attributeType" /> a este ensamblado dinámico; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.IsDynamic">
      <summary vsli:raw="Gets a value that indicates that the current assembly is a dynamic assembly.">Obtiene un valor que indica que el ensamblado actual es un ensamblado dinámico.</summary>
      <returns vsli:raw="Always &lt;see langword=&quot;true&quot; /&gt;.">Siempre es <see langword="true" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.Location">
      <summary vsli:raw="Gets the location, in codebase format, of the loaded file that contains the manifest if it is not shadow-copied.">Obtiene la ubicación, en formato de código base, del archivo cargado que contiene el manifiesto si no se ha realizado copia de seguridad.</summary>
      <returns vsli:raw="The location of the loaded file that contains the manifest. If the loaded file has been shadow-copied, the &lt;see langword=&quot;Location&quot; /&gt; is that of the file before being shadow-copied.">Ubicación del archivo cargado que contiene el manifiesto. Si se ha realizado una copia de seguridad del archivo cargado, la <see langword="Location" /> es la ubicación del archivo antes de que se hiciera la copia de seguridad.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported.">Este método no se admite actualmente.</exception>
      <exception cref="T:System.Security.SecurityException" vsli:raw="The caller does not have the required permission.">El llamador no dispone del permiso requerido.</exception>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.ManifestModule">
      <summary vsli:raw="Gets the module in the current &lt;see cref=&quot;T:System.Reflection.Emit.AssemblyBuilder&quot; /&gt; that contains the assembly manifest.">Obtiene el módulo de la clase <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> actual que contiene el manifiesto del ensamblado.</summary>
      <returns vsli:raw="The manifest module.">Módulo de manifiesto.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.ReflectionOnly">
      <summary vsli:raw="Gets a value indicating whether the dynamic assembly is in the reflection-only context.">Obtiene un valor que indica si el ensamblado dinámico está en el contexto de sólo reflexión.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the dynamic assembly is in the reflection-only context; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el ensamblado dinámico está en el contexto de sólo reflexión; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary vsli:raw="Set a custom attribute on this assembly using a specified custom attribute blob.">Establezca un atributo personalizado en este ensamblado mediante el objeto binario especificado de atributo personalizado.</summary>
      <param name="con" vsli:raw="The constructor for the custom attribute.">Constructor para el atributo personalizado.</param>
      <param name="binaryAttribute" vsli:raw="A byte blob representing the attributes.">Blob de bytes que representa los atributos.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;con&quot; /&gt; or &lt;paramref name=&quot;binaryAttribute&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="con" /> o <paramref name="binaryAttribute" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Security.SecurityException" vsli:raw="The caller does not have the required permission.">El llamador no dispone del permiso requerido.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;con&quot; /&gt; is not a &lt;see langword=&quot;RuntimeConstructorInfo&quot; /&gt; object.">
        <paramref name="con" /> no es un objeto <see langword="RuntimeConstructorInfo" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary vsli:raw="Set a custom attribute on this assembly using a custom attribute builder.">Establezca un atributo personalizado en este ensamblado mediante un generador de atributos personalizados.</summary>
      <param name="customBuilder" vsli:raw="An instance of a helper class to define the custom attribute.">Instancia de una clase del asistente para definir el atributo personalizado.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;con&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="con" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Security.SecurityException" vsli:raw="The caller does not have the required permission.">El llamador no dispone del permiso requerido.</exception>
    </member>
    <member name="T:System.Reflection.Emit.AssemblyBuilderAccess">
      <summary vsli:raw="Defines the access modes for a dynamic assembly.">Define los modos de acceso de un ensamblado dinámico.</summary>
    </member>
    <member name="F:System.Reflection.Emit.AssemblyBuilderAccess.Run">
      <summary vsli:raw="The dynamic assembly can be executed, but not saved.">El ensamblado dinámico se puede ejecutar, pero no guardar.</summary>
    </member>
    <member name="F:System.Reflection.Emit.AssemblyBuilderAccess.RunAndCollect">
      <summary vsli:raw="The dynamic assembly will be automatically unloaded and its memory reclaimed, when it's no longer accessible.">Cuando ya no es accesible, el ensamblado dinámico se descarga automáticamente y su memoria se reclama.</summary>
    </member>
    <member name="T:System.Reflection.Emit.ConstructorBuilder">
      <summary vsli:raw="Defines and represents a constructor of a dynamic class.">Define y representa a un constructor de una clase dinámica.</summary>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.Attributes">
      <summary vsli:raw="Gets the attributes for this constructor.">Obtiene los atributos de este constructor.</summary>
      <returns vsli:raw="The attributes for this constructor.">Atributos de este constructor.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.CallingConvention">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Reflection.CallingConventions&quot; /&gt; value that depends on whether the declaring type is generic.">Obtiene un valor de <see cref="T:System.Reflection.CallingConventions" /> que depende de que el tipo declarativo sea genérico.</summary>
      <returns vsli:raw="&lt;see cref=&quot;F:System.Reflection.CallingConventions.HasThis&quot; /&gt; if the declaring type is generic; otherwise, &lt;see cref=&quot;F:System.Reflection.CallingConventions.Standard&quot; /&gt;.">
        <see cref="F:System.Reflection.CallingConventions.HasThis" /> si el tipo declarativo es genérico; en caso contrario, <see cref="F:System.Reflection.CallingConventions.Standard" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.DeclaringType">
      <summary vsli:raw="Gets a reference to the &lt;see cref=&quot;T:System.Type&quot; /&gt; object for the type that declares this member.">Obtiene una referencia al objeto <see cref="T:System.Type" /> para el tipo que declara este miembro.</summary>
      <returns vsli:raw="The type that declares this member.">Tipo que declara este miembro.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
      <summary vsli:raw="Defines a parameter of this constructor.">Define un parámetro de este constructor.</summary>
      <param name="iSequence" vsli:raw="The position of the parameter in the parameter list. Parameters are indexed beginning with the number 1 for the first parameter.">Posición del parámetro en la lista de parámetros. Los parámetros se indizan empezando por el número 1 en el primer parámetro.</param>
      <param name="attributes" vsli:raw="The attributes of the parameter.">Atributos del parámetro.</param>
      <param name="strParamName" vsli:raw="The name of the parameter. The name can be the null string.">Nombre del parámetro. El nombre puede ser una cadena nula.</param>
      <returns vsli:raw="An object that represents the new parameter of this constructor.">Objeto que representa el nuevo parámetro de este constructor.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;iSequence&quot; /&gt; is less than 0 (zero), or it is greater than the number of parameters of the constructor.">
        <paramref name="iSequence" /> es menor o igual que 0 (cero), o mayor que el número de parámetros del constructor.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The containing type has been created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.">Tipo contenedor que se ha creado mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.GetCustomAttributes(System.Boolean)">
      <summary vsli:raw="Returns all the custom attributes defined for this constructor.">Devuelve todos los atributos personalizados definidos para este constructor.</summary>
      <param name="inherit" vsli:raw="Controls inheritance of custom attributes from base classes. This parameter is ignored.">Controla la herencia de atributos personalizados de las clases base. Este parámetro se ignora.</param>
      <returns vsli:raw="An array of objects representing all the custom attributes of the constructor represented by this &lt;see cref=&quot;T:System.Reflection.Emit.ConstructorBuilder&quot; /&gt; instance.">Matriz de objetos que representa todos los atributos personalizados del constructor que representa esta instancia de <see cref="T:System.Reflection.Emit.ConstructorBuilder" />.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported.">Este método no se admite actualmente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary vsli:raw="Returns the custom attributes identified by the given type.">Devuelve los atributos personalizados identificados por el tipo dado.</summary>
      <param name="attributeType" vsli:raw="The custom attribute type.">Tipo de atributo personalizado.</param>
      <param name="inherit" vsli:raw="Controls inheritance of custom attributes from base classes. This parameter is ignored.">Controla la herencia de atributos personalizados de las clases base. Este parámetro se ignora.</param>
      <returns vsli:raw="An object array that represents the attributes of this constructor.">Matriz de objetos que representa los atributos de este constructor.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported.">Este método no se admite actualmente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.GetILGenerator">
      <summary vsli:raw="Gets an &lt;see cref=&quot;T:System.Reflection.Emit.ILGenerator&quot; /&gt; for this constructor.">Obtiene un objeto <see cref="T:System.Reflection.Emit.ILGenerator" /> para este constructor.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Reflection.Emit.ILGenerator&quot; /&gt; object for this constructor.">Objeto <see cref="T:System.Reflection.Emit.ILGenerator" /> para este constructor.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The constructor is a parameterless constructor.  &#xA;  &#xA; -or-  &#xA;  &#xA; The constructor has &lt;see cref=&quot;T:System.Reflection.MethodAttributes&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.MethodImplAttributes&quot; /&gt; flags indicating that it should not have a method body.">El constructor no tiene parámetros.  
o bien 
El constructor tiene marcas <see cref="T:System.Reflection.MethodAttributes" /> o <see cref="T:System.Reflection.MethodImplAttributes" /> que señalan que no debe tener un cuerpo de método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.GetILGenerator(System.Int32)">
      <summary vsli:raw="Gets an &lt;see cref=&quot;T:System.Reflection.Emit.ILGenerator&quot; /&gt; object, with the specified MSIL stream size, that can be used to build a method body for this constructor.">Obtiene un objeto <see cref="T:System.Reflection.Emit.ILGenerator" />, con el tamaño de la secuencia de MSIL especificado, que se puede utilizar para crear un cuerpo de método para este constructor.</summary>
      <param name="streamSize" vsli:raw="The size of the MSIL stream, in bytes.">Tamaño de la secuencia de MSIL, en bytes.</param>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Reflection.Emit.ILGenerator&quot; /&gt; for this constructor.">Un objeto <see cref="T:System.Reflection.Emit.ILGenerator" /> para este constructor.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The constructor is a parameterless constructor.  &#xA;  &#xA; -or-  &#xA;  &#xA; The constructor has &lt;see cref=&quot;T:System.Reflection.MethodAttributes&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.MethodImplAttributes&quot; /&gt; flags indicating that it should not have a method body.">El constructor no tiene parámetros.  
O bien 
El constructor tiene marcas <see cref="T:System.Reflection.MethodAttributes" /> o <see cref="T:System.Reflection.MethodImplAttributes" /> que señalan que no debe tener un cuerpo de método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.GetMethodImplementationFlags">
      <summary vsli:raw="Returns the method implementation flags for this constructor.">Devuelve las marcas de implementación de método de este constructor.</summary>
      <returns vsli:raw="The method implementation flags for this constructor.">Marcas de implementación de método de este constructor.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.GetParameters">
      <summary vsli:raw="Returns the parameters of this constructor.">Devuelve los parámetros de este constructor.</summary>
      <returns vsli:raw="An array that represents the parameters of this constructor.">Matriz que representa los parámetros de este constructor.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt; has not been called on this constructor's type, in the .NET Framework versions 1.0 and 1.1.">No se ha llamado al método <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> en el tipo de este constructor, en .NET Framework versiones 1.0 y 1.1.</exception>
      <exception cref="T:System.NotSupportedException" vsli:raw="&lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt; has not been called on this constructor's type, in the .NET Framework version 2.0.">No se ha llamado al método <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> en el tipo de este constructor, en .NET Framework versión 2.0.</exception>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.InitLocals">
      <summary vsli:raw="Gets or sets whether the local variables in this constructor should be zero-initialized.">Obtiene o establece si las variables locales de este constructor deben inicializarse en cero.</summary>
      <returns vsli:raw="Read/write. Gets or sets whether the local variables in this constructor should be zero-initialized.">Lectura y escritura. Obtiene o establece si las variables locales de este constructor deben inicializarse en cero.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
      <summary vsli:raw="Dynamically invokes the constructor reflected by this instance with the specified arguments, under the constraints of the specified &lt;see langword=&quot;Binder&quot; /&gt;.">Se invoca dinámicamente al constructor reflejado por esta instancia con los argumentos especificados considerando las restricciones del <see langword="Binder" /> especificado.</summary>
      <param name="obj" vsli:raw="The object that needs to be reinitialized.">Objeto que necesita reinicializarse.</param>
      <param name="invokeAttr" vsli:raw="One of the &lt;see langword=&quot;BindingFlags&quot; /&gt; values that specifies the type of binding that is desired.">Uno de los valores <see langword="BindingFlags" /> que especifica el tipo de enlace deseado.</param>
      <param name="binder" vsli:raw="A &lt;see langword=&quot;Binder&quot; /&gt; that defines a set of properties and enables the binding, coercion of argument types, and invocation of members using reflection. If &lt;paramref name=&quot;binder&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;, then Binder.DefaultBinding is used.">
        <see langword="Binder" /> que define un conjunto de propiedades y permite el enlace, la conversión de tipos de argumentos y la invocación de miembros mediante la reflexión. Si <paramref name="binder" /> es <see langword="null" />, se usa Binder.DefaultBinding.</param>
      <param name="parameters" vsli:raw="An argument list. This is an array of arguments with the same number, order, and type as the parameters of the constructor to be invoked. If there are no parameters, this should be a null reference (&lt;see langword=&quot;Nothing&quot; /&gt; in Visual Basic).">Lista de argumentos. Esta matriz de argumentos tiene el mismo número, orden y tipo que los parámetros del constructor al que se va a invocar. Si no hay ningún parámetro, debe ser una referencia nula (<see langword="Nothing" /> en Visual Basic).</param>
      <param name="culture" vsli:raw="A &lt;see cref=&quot;T:System.Globalization.CultureInfo&quot; /&gt; used to govern the coercion of types. If this is null, the &lt;see cref=&quot;T:System.Globalization.CultureInfo&quot; /&gt; for the current thread is used.">
        <see cref="T:System.Globalization.CultureInfo" /> que se usa para regir la conversión de tipos. Si es null, se utiliza <see cref="T:System.Globalization.CultureInfo" /> para el subproceso actual.</param>
      <returns vsli:raw="An instance of the class associated with the constructor.">Instancia de la clase asociada al constructor.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported. You can retrieve the constructor using &lt;see cref=&quot;M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])&quot; /&gt; and call &lt;see cref=&quot;M:System.Reflection.ConstructorInfo.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)&quot; /&gt; on the returned &lt;see cref=&quot;T:System.Reflection.ConstructorInfo&quot; /&gt;.">Este método no se admite actualmente. Se puede recuperar el constructor utilizando <see cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />, y llamar al método <see cref="M:System.Reflection.ConstructorInfo.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" /> en la clase <see cref="T:System.Reflection.ConstructorInfo" /> devuelta.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
      <summary vsli:raw="Dynamically invokes the constructor represented by this instance on the given object, passing along the specified parameters, and under the constraints of the given binder.">Invoca dinámicamente al constructor representado por esta instancia en el objeto dado, pasando los parámetros especificados y considerando las restricciones del enlazador facilitado.</summary>
      <param name="invokeAttr" vsli:raw="This must be a bit flag from &lt;see cref=&quot;T:System.Reflection.BindingFlags&quot; /&gt;, such as InvokeMethod, NonPublic, and so on.">Debe ser una marca de bits de <see cref="T:System.Reflection.BindingFlags" /> como por ejemplo, InvokeMethod, NonPublic y así sucesivamente.</param>
      <param name="binder" vsli:raw="An object that enables the binding, coercion of argument types, invocation of members, and retrieval of &lt;see langword=&quot;MemberInfo&quot; /&gt; objects using reflection. If binder is &lt;see langword=&quot;null&quot; /&gt;, the default binder is used. See &lt;see cref=&quot;T:System.Reflection.Binder&quot; /&gt;.">Objeto que permite el enlace, la conversión de tipos de argumentos, la invocación de miembros y la recuperación de objetos <see langword="MemberInfo" /> mediante la reflexión. Si el enlazador es <see langword="null" />, se usará el enlazador predeterminado. Vea <see cref="T:System.Reflection.Binder" />.</param>
      <param name="parameters" vsli:raw="An argument list. This is an array of arguments with the same number, order, and type as the parameters of the constructor to be invoked. If there are no parameters this should be &lt;see langword=&quot;null&quot; /&gt;.">Lista de argumentos. Esta matriz de argumentos tiene el mismo número, orden y tipo que los parámetros del constructor al que se va a invocar. Si no hay ningún parámetro, deberá ser <see langword="null" />.</param>
      <param name="culture" vsli:raw="An instance of &lt;see cref=&quot;T:System.Globalization.CultureInfo&quot; /&gt; used to govern the coercion of types. If this is null, the &lt;see cref=&quot;T:System.Globalization.CultureInfo&quot; /&gt; for the current thread is used. (For example, this is necessary to convert a &lt;see cref=&quot;T:System.String&quot; /&gt; that represents 1000 to a &lt;see cref=&quot;T:System.Double&quot; /&gt; value, since 1000 is represented differently by different cultures.)">Instancia de <see cref="T:System.Globalization.CultureInfo" /> usada para regir la conversión de tipos. Si es null, se utiliza <see cref="T:System.Globalization.CultureInfo" /> para el subproceso actual. Esto es necesario, por ejemplo, para convertir un objeto <see cref="T:System.String" /> que representa 1000 en un valor <see cref="T:System.Double" />, ya que 1000 se representa de manera diferente según las distintas referencias culturales.</param>
      <returns vsli:raw="The value returned by the invoked constructor.">Valor devuelto por el constructor invocado.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported. You can retrieve the constructor using &lt;see cref=&quot;M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])&quot; /&gt; and call &lt;see cref=&quot;M:System.Reflection.ConstructorInfo.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)&quot; /&gt; on the returned &lt;see cref=&quot;T:System.Reflection.ConstructorInfo&quot; /&gt;.">Este método no se admite actualmente. Se puede recuperar el constructor utilizando <see cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />, y llamar al método <see cref="M:System.Reflection.ConstructorInfo.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" /> en la clase <see cref="T:System.Reflection.ConstructorInfo" /> devuelta.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.IsDefined(System.Type,System.Boolean)">
      <summary vsli:raw="Checks if the specified custom attribute type is defined.">Comprueba si se ha definido el tipo de atributo personalizado especificado.</summary>
      <param name="attributeType" vsli:raw="A custom attribute type.">Tipo de atributo personalizado.</param>
      <param name="inherit" vsli:raw="Controls inheritance of custom attributes from base classes. This parameter is ignored.">Controla la herencia de atributos personalizados de las clases base. Este parámetro se ignora.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the specified custom attribute type is defined; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si está definido el tipo de atributo personalizado especificado, en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported. You can retrieve the constructor using &lt;see cref=&quot;M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])&quot; /&gt; and call &lt;see cref=&quot;M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)&quot; /&gt; on the returned &lt;see cref=&quot;T:System.Reflection.ConstructorInfo&quot; /&gt;.">Este método no se admite actualmente. Se puede recuperar el constructor utilizando <see cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />, y llamar al método <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> en la clase <see cref="T:System.Reflection.ConstructorInfo" /> devuelta.</exception>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.MethodHandle">
      <summary vsli:raw="Gets the internal handle for the method. Use this handle to access the underlying metadata handle.">Obtiene el identificador interno para el método. Utilice este identificador para tener acceso al identificador de metadatos subyacente.</summary>
      <returns vsli:raw="The internal handle for the method. Use this handle to access the underlying metadata handle.">Identificador interno para el método. Utilice este identificador para tener acceso al identificador de metadatos subyacente.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This property is not supported on this class.">Esta propiedad no es compatible con esta clase.</exception>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.Module">
      <summary vsli:raw="Gets the dynamic module in which this constructor is defined.">Obtiene el módulo dinámico en el que se define este constructor.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Module&quot; /&gt; object that represents the dynamic module in which this constructor is defined.">Un objeto <see cref="T:System.Reflection.Module" /> que representa el módulo dinámico en el que se define este constructor.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.Name">
      <summary vsli:raw="Retrieves the name of this constructor.">Recupera el nombre de este constructor.</summary>
      <returns vsli:raw="The name of this constructor.">Nombre de este constructor.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.ReflectedType">
      <summary vsli:raw="Holds a reference to the &lt;see cref=&quot;T:System.Type&quot; /&gt; object from which this object was obtained.">Contiene una referencia al objeto <see cref="T:System.Type" /> a partir de la cual se obtuvo el objeto en cuestión.</summary>
      <returns vsli:raw="The &lt;see langword=&quot;Type&quot; /&gt; object from which this object was obtained.">
        <see langword="Type" /> Objeto del que se obtuvo este objeto.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary vsli:raw="Set a custom attribute using a specified custom attribute blob.">Establezca un atributo personalizado mediante el objeto binario de atributo personalizado especificado.</summary>
      <param name="con" vsli:raw="The constructor for the custom attribute.">Constructor para el atributo personalizado.</param>
      <param name="binaryAttribute" vsli:raw="A byte blob representing the attributes.">Blob de bytes que representa los atributos.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;con&quot; /&gt; or &lt;paramref name=&quot;binaryAttribute&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="con" /> o <paramref name="binaryAttribute" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary vsli:raw="Set a custom attribute using a custom attribute builder.">Establece un atributo personalizado mediante un generador de atributos personalizado.</summary>
      <param name="customBuilder" vsli:raw="An instance of a helper class to define the custom attribute.">Instancia de una clase del asistente para definir el atributo personalizado.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;customBuilder&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="customBuilder" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
      <summary vsli:raw="Sets the method implementation flags for this constructor.">Establece las marcas de implementación de métodos para este constructor.</summary>
      <param name="attributes" vsli:raw="The method implementation flags.">Marcas de implementación de método.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The containing type has been created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.">Tipo contenedor que se ha creado mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.ToString">
      <summary vsli:raw="Returns this &lt;see cref=&quot;T:System.Reflection.Emit.ConstructorBuilder&quot; /&gt; instance as a &lt;see cref=&quot;T:System.String&quot; /&gt;.">Devuelve la instancia <see cref="T:System.Reflection.Emit.ConstructorBuilder" /> como <see cref="T:System.String" />.</summary>
      <returns vsli:raw="A string containing the name, attributes, and exceptions of this constructor, followed by the current Microsoft intermediate language (MSIL) stream.">Cadena que contiene el nombre, los atributos y las excepciones de este constructor, seguidos de la secuencia actual del Lenguaje Intermedio de Microsoft (MSIL).</returns>
    </member>
    <member name="T:System.Reflection.Emit.EnumBuilder">
      <summary vsli:raw="Describes and represents an enumeration type.">Describe y representa un tipo de enumeración.</summary>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.Assembly">
      <summary vsli:raw="Retrieves the dynamic assembly that contains this enum definition.">Recupera el ensamblado dinámico que contiene la definición de esta enumeración.</summary>
      <returns vsli:raw="Read-only. The dynamic assembly that contains this enum definition.">Sólo lectura. Ensamblado dinámico que contiene la definición de esta enumeración.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.AssemblyQualifiedName">
      <summary vsli:raw="Returns the full path of this enum qualified by the display name of the parent assembly.">Devuelve la ruta de acceso completa de esta enumeración calificada por el nombre para mostrar del ensamblado principal.</summary>
      <returns vsli:raw="Read-only. The full path of this enum qualified by the display name of the parent assembly.">Sólo lectura. Ruta de acceso completa de esta enumeración calificada por el nombre para mostrar del ensamblado principal.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.BaseType">
      <summary vsli:raw="Returns the parent &lt;see cref=&quot;T:System.Type&quot; /&gt; of this type which is always &lt;see cref=&quot;T:System.Enum&quot; /&gt;.">Devuelve el <see cref="T:System.Type" /> principal de este tipo que siempre es <see cref="T:System.Enum" />.</summary>
      <returns vsli:raw="Read-only. The parent &lt;see cref=&quot;T:System.Type&quot; /&gt; of this type.">Sólo lectura. Devuelve el <see cref="T:System.Type" /> principal de este tipo.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.CreateTypeInfo">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Reflection.TypeInfo&quot; /&gt; object that represents this enumeration.">Obtiene un objeto <see cref="T:System.Reflection.TypeInfo" /> que representa esta enumeración.</summary>
      <returns vsli:raw="An object that represents this enumeration.">Objeto que representa esta enumeración.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.DeclaringType">
      <summary vsli:raw="Returns the type that declared this &lt;see cref=&quot;T:System.Reflection.Emit.EnumBuilder&quot; /&gt;.">Devuelve el tipo que declara este objeto <see cref="T:System.Reflection.Emit.EnumBuilder" />.</summary>
      <returns vsli:raw="Read-only. The type that declared this &lt;see cref=&quot;T:System.Reflection.Emit.EnumBuilder&quot; /&gt;.">Sólo lectura. Tipo que declara este <see cref="T:System.Reflection.Emit.EnumBuilder" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.DefineLiteral(System.String,System.Object)">
      <summary vsli:raw="Defines the named static field in an enumeration type with the specified constant value.">Define el campo estático con nombre de un tipo de enumeración con el valor constante especificado.</summary>
      <param name="literalName" vsli:raw="The name of the static field.">Nombre del campo estático.</param>
      <param name="literalValue" vsli:raw="The constant value of the literal.">Constante del valor del literal.</param>
      <returns vsli:raw="The defined field.">Campo definido.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.FullName">
      <summary vsli:raw="Returns the full path of this enum.">Devuelve la ruta de acceso completa de esta enumeración.</summary>
      <returns vsli:raw="Read-only. The full path of this enum.">Sólo lectura. Ruta de acceso completa de esta enumeración.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetConstructors(System.Reflection.BindingFlags)">
      <summary vsli:raw="Returns an array of &lt;see cref=&quot;T:System.Reflection.ConstructorInfo&quot; /&gt; objects representing the public and non-public constructors defined for this class, as specified.">Devuelve una matriz de <see cref="T:System.Reflection.ConstructorInfo" /> objetos que representan los constructores públicos y no públicos definidos para esta clase, tal como se especifica.</summary>
      <param name="bindingAttr" vsli:raw="This must be a bit flag from &lt;see cref=&quot;T:System.Reflection.BindingFlags&quot; /&gt; : &lt;see langword=&quot;InvokeMethod&quot; /&gt;, &lt;see langword=&quot;NonPublic&quot; /&gt;, and so on.">Debe ser un indicador de bits de <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
      <returns vsli:raw="Returns an array of &lt;see cref=&quot;T:System.Reflection.ConstructorInfo&quot; /&gt; objects representing the specified constructors defined for this class. If no constructors are defined, an empty array is returned.">Devuelve una matriz de <see cref="T:System.Reflection.ConstructorInfo" /> objetos que representan los constructores especificados definidos para esta clase. Si no se definen constructores, se devuelve una matriz vacía.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported in types that are not complete.">Actualmente, este método no es compatible con los tipos que no están completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetCustomAttributes(System.Boolean)">
      <summary vsli:raw="Returns all the custom attributes defined for this constructor.">Devuelve todos los atributos personalizados definidos para este constructor.</summary>
      <param name="inherit" vsli:raw="Specifies whether to search this member's inheritance chain to find the attributes.">Especifica si se debe buscar la cadena de herencia de este miembro para encontrar los atributos.</param>
      <returns vsli:raw="Returns an array of objects representing all the custom attributes of the constructor represented by this &lt;see cref=&quot;T:System.Reflection.Emit.ConstructorBuilder&quot; /&gt; instance.">Devuelve una matriz de objetos que representa a todos los atributos personalizados del constructor representado mediante la instancia <see cref="T:System.Reflection.Emit.ConstructorBuilder" />.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported in types that are not complete.">Actualmente, este método no es compatible con los tipos que no están completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary vsli:raw="Returns the custom attributes identified by the given type.">Devuelve los atributos personalizados identificados por el tipo dado.</summary>
      <param name="attributeType" vsli:raw="The &lt;see langword=&quot;Type&quot; /&gt; object to which the custom attributes are applied.">Objeto <see langword="Type" /> al que se aplican los atributos personalizados.</param>
      <param name="inherit" vsli:raw="Specifies whether to search this member's inheritance chain to find the attributes.">Especifica si se debe buscar la cadena de herencia de este miembro para encontrar los atributos.</param>
      <returns vsli:raw="Returns an array of objects representing the attributes of this constructor that are of &lt;see cref=&quot;T:System.Type&quot; /&gt;&lt;paramref name=&quot;attributeType&quot; /&gt;.">Devuelve una matriz de objetos que representan los atributos de este constructor, que son de <see cref="T:System.Type" /><paramref name="attributeType" />.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported in types that are not complete.">Actualmente, este método no es compatible con los tipos que no están completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetElementType">
      <summary vsli:raw="Calling this method always throws &lt;see cref=&quot;T:System.NotSupportedException&quot; /&gt;.">Cuando se llama a este método, siempre se produce <see cref="T:System.NotSupportedException" />.</summary>
      <returns vsli:raw="This method is not supported. No value is returned.">No se admite este método. No se devuelve ningún valor.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported.">Este método no se admite actualmente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetEnumUnderlyingType">
      <summary vsli:raw="Returns the underlying integer type of the current enumeration, which is set when the enumeration builder is defined.">Devuelve el tipo entero subyacente de la enumeración actual, que se establece cuando se define el generador de enumeraciones.</summary>
      <returns vsli:raw="The underlying type.">Tipo subyacente.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
      <summary vsli:raw="Returns the event with the specified name.">Devuelve el evento con el nombre especificado.</summary>
      <param name="name" vsli:raw="The name of the event to get.">Nombre del evento que se va a obtener.</param>
      <param name="bindingAttr" vsli:raw="This invocation attribute. This must be a bit flag from &lt;see cref=&quot;T:System.Reflection.BindingFlags&quot; /&gt; : &lt;see langword=&quot;InvokeMethod&quot; /&gt;, &lt;see langword=&quot;NonPublic&quot; /&gt;, and so on.">Este atributo de invocación. Debe ser un indicador de bits de <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
      <returns vsli:raw="Returns an &lt;see cref=&quot;T:System.Reflection.EventInfo&quot; /&gt; object representing the event declared or inherited by this type with the specified name. If there are no matches, &lt;see langword=&quot;null&quot; /&gt; is returned.">Devuelve un objeto <see cref="T:System.Reflection.EventInfo" /> que representa al evento declarado o heredado por este tipo con el nombre especificado. Si no coincide, se devuelve <see langword="null" />.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported in types that are not complete.">Actualmente, este método no es compatible con los tipos que no están completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetEvents">
      <summary vsli:raw="Returns the events for the public events declared or inherited by this type.">Devuelve los eventos de los eventos públicos declarados o heredados por este tipo.</summary>
      <returns vsli:raw="Returns an array of &lt;see cref=&quot;T:System.Reflection.EventInfo&quot; /&gt; objects representing the public events declared or inherited by this type. An empty array is returned if there are no public events.">Devuelve una matriz de objetos <see cref="T:System.Reflection.EventInfo" /> que representan los eventos públicos declarados o heredados por este tipo. Se devuelve una matriz vacía si no hay eventos públicos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported in types that are not complete.">Actualmente, este método no es compatible con los tipos que no están completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetEvents(System.Reflection.BindingFlags)">
      <summary vsli:raw="Returns the public and non-public events that are declared by this type.">Devuelve los eventos públicos y no públicos declarados por este tipo.</summary>
      <param name="bindingAttr" vsli:raw="This must be a bit flag from &lt;see cref=&quot;T:System.Reflection.BindingFlags&quot; /&gt;, such as &lt;see langword=&quot;InvokeMethod&quot; /&gt;, &lt;see langword=&quot;NonPublic&quot; /&gt;, and so on.">Debe ser una marca de bits de <see cref="T:System.Reflection.BindingFlags" />, como <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
      <returns vsli:raw="Returns an array of &lt;see cref=&quot;T:System.Reflection.EventInfo&quot; /&gt; objects representing the public and non-public events declared or inherited by this type. An empty array is returned if there are no events, as specified.">Devuelve una matriz de objetos <see cref="T:System.Reflection.EventInfo" /> que representa a los eventos públicos y no públicos declarados o heredados por este tipo. Si no hay eventos públicos devuelve una matriz vacía, tal como se especifica.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported in types that are not complete.">Actualmente, este método no es compatible con los tipos que no están completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetField(System.String,System.Reflection.BindingFlags)">
      <summary vsli:raw="Returns the field specified by the given name.">Devuelve el campo especificado por el nombre facilitado.</summary>
      <param name="name" vsli:raw="The name of the field to get.">Nombre del campo que se va a obtener.</param>
      <param name="bindingAttr" vsli:raw="This must be a bit flag from &lt;see cref=&quot;T:System.Reflection.BindingFlags&quot; /&gt; : &lt;see langword=&quot;InvokeMethod&quot; /&gt;, &lt;see langword=&quot;NonPublic&quot; /&gt;, and so on.">Debe ser un indicador de bits de <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
      <returns vsli:raw="Returns the &lt;see cref=&quot;T:System.Reflection.FieldInfo&quot; /&gt; object representing the field declared or inherited by this type with the specified name and public or non-public modifier. If there are no matches, then null is returned.">Devuelve el objeto <see cref="T:System.Reflection.FieldInfo" /> que representa el campo declarado o heredado por este tipo con el nombre especificado y el modificador público o no público. Si no coincide, entonces se devolverá null.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported in types that are not complete.">Actualmente, este método no es compatible con los tipos que no están completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetFields(System.Reflection.BindingFlags)">
      <summary vsli:raw="Returns the public and non-public fields that are declared by this type.">Devuelve los campos públicos y no públicos declarados por este tipo.</summary>
      <param name="bindingAttr" vsli:raw="This must be a bit flag from &lt;see cref=&quot;T:System.Reflection.BindingFlags&quot; /&gt;, such as InvokeMethod, NonPublic, and so on.">Debe ser una marca de bits de <see cref="T:System.Reflection.BindingFlags" /> como por ejemplo, InvokeMethod, NonPublic y así sucesivamente.</param>
      <returns vsli:raw="Returns an array of &lt;see cref=&quot;T:System.Reflection.FieldInfo&quot; /&gt; objects representing the public and non-public fields declared or inherited by this type. An empty array is returned if there are no fields, as specified.">Devuelve una matriz de <see cref="T:System.Reflection.FieldInfo" /> objetos que representan los campos públicos y no públicos declarados o heredados por este tipo. Se devuelve una matriz vacía si no hay ningún campo,  como se especifica.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported in types that are not complete.">Actualmente, este método no es compatible con los tipos que no están completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetInterface(System.String,System.Boolean)">
      <summary vsli:raw="Returns the interface implemented (directly or indirectly) by this type, with the specified fully-qualified name.">Devuelve la interfaz implementada (directa o indirectamente) por este tipo, con el nombre completo especificado.</summary>
      <param name="name" vsli:raw="The name of the interface.">Nombre de la interfaz.</param>
      <param name="ignoreCase" vsli:raw="If &lt;see langword=&quot;true&quot; /&gt;, the search is case-insensitive. If &lt;see langword=&quot;false&quot; /&gt;, the search is case-sensitive.">Si <see langword="true" />, la búsqueda no distingue entre mayúsculas y minúsculas. Si <see langword="false" />, la búsqueda distingue entre mayúsculas y minúsculas.</param>
      <returns vsli:raw="Returns a &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the implemented interface. Returns null if no interface matching name is found.">Devuelve un objeto <see cref="T:System.Type" /> que representa las interfaz implementada. Devuelve null si no se encuentra ningún nombre de interfaz coincidente.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported in types that are not complete.">Actualmente, este método no es compatible con los tipos que no están completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetInterfaceMap(System.Type)">
      <summary vsli:raw="Returns an interface mapping for the interface requested.">Devuelve una asignación de interfaz para la interfaz solicitada.</summary>
      <param name="interfaceType" vsli:raw="The type of the interface for which the interface mapping is to be retrieved.">El tipo de la interfaz para la que se va a recuperar la asignación de interfaz.</param>
      <returns vsli:raw="The requested interface mapping.">Asignación de interfaz solicitada.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The type does not implement the interface.">El tipo no implementa la interfaz.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetInterfaces">
      <summary vsli:raw="Returns an array of all the interfaces implemented on this a class and its base classes.">Devuelve una matriz de todas las interfaces implementadas en esta clase y sus clases base.</summary>
      <returns vsli:raw="Returns an array of &lt;see cref=&quot;T:System.Type&quot; /&gt; objects representing the implemented interfaces. If none are defined, an empty array is returned.">Devuelve una matriz de objetos <see cref="T:System.Type" /> que representan las interfaces implementadas. Si no hay ninguna definida, se devuelve una matriz vacía.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
      <summary vsli:raw="Returns all members with the specified name, type, and binding that are declared or inherited by this type.">Devuelve todos los miembros con el nombre, tipo y enlace especificados que este tipo declare o herede.</summary>
      <param name="name" vsli:raw="The name of the member.">Nombre del miembro.</param>
      <param name="type" vsli:raw="The type of member that is to be returned.">Tipo de miembro que se va a devolver.</param>
      <param name="bindingAttr" vsli:raw="This must be a bit flag from &lt;see cref=&quot;T:System.Reflection.BindingFlags&quot; /&gt; : &lt;see langword=&quot;InvokeMethod&quot; /&gt;, &lt;see langword=&quot;NonPublic&quot; /&gt;, and so on.">Debe ser un indicador de bits de <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
      <returns vsli:raw="Returns an array of &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; objects representing the public and non-public members defined on this type if &lt;paramref name=&quot;nonPublic&quot; /&gt; is used; otherwise, only the public members are returned.">Devuelve una matriz de <see cref="T:System.Reflection.MemberInfo" /> objetos que representan los miembros públicos y no públicos definidos en este tipo si <paramref name="nonPublic" /> se usa; en caso contrario, se devuelven solo los miembros públicos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported in types that are not complete.">Actualmente, este método no es compatible con los tipos que no están completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetMembers(System.Reflection.BindingFlags)">
      <summary vsli:raw="Returns the specified members declared or inherited by this type.">Devuelve los miembros especificados que este tipo declare o herede.</summary>
      <param name="bindingAttr" vsli:raw="This must be a bit flag from &lt;see cref=&quot;T:System.Reflection.BindingFlags&quot; /&gt; : &lt;see langword=&quot;InvokeMethod&quot; /&gt;, &lt;see langword=&quot;NonPublic&quot; /&gt;, and so on.">Debe ser un indicador de bits de <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
      <returns vsli:raw="Returns an array of &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; objects representing the public and non-public members declared or inherited by this type. An empty array is returned if there are no matching members.">Devuelve una matriz de objetos <see cref="T:System.Reflection.MemberInfo" /> que representa los miembros públicos y no públicos declarados o heredados por este tipo. Se devuelve una matriz vacía si no hay ningún miembro coincidente.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported in types that are not complete.">Actualmente, este método no es compatible con los tipos que no están completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetMethods(System.Reflection.BindingFlags)">
      <summary vsli:raw="Returns all the public and non-public methods declared or inherited by this type, as specified.">Devuelve todos los métodos públicos y no públicos declarados o heredados por este tipo, tal como se especifica.</summary>
      <param name="bindingAttr" vsli:raw="This must be a bit flag from &lt;see cref=&quot;T:System.Reflection.BindingFlags&quot; /&gt;, such as &lt;see langword=&quot;InvokeMethod&quot; /&gt;, &lt;see langword=&quot;NonPublic&quot; /&gt;, and so on.">Debe ser una marca de bits de <see cref="T:System.Reflection.BindingFlags" />, como <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
      <returns vsli:raw="Returns an array of &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; objects representing the public and non-public methods defined on this type if &lt;paramref name=&quot;nonPublic&quot; /&gt; is used; otherwise, only the public methods are returned.">Devuelve una matriz de <see cref="T:System.Reflection.MethodInfo" /> objetos que representan los métodos públicos y no públicos definidos en este tipo si <paramref name="nonPublic" /> se usa; en caso contrario, se devuelven solo los métodos públicos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported in types that are not complete.">Actualmente, este método no es compatible con los tipos que no están completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
      <summary vsli:raw="Returns the specified nested type that is declared by this type.">Devuelve el tipo anidado especificado que este tipo declare.</summary>
      <param name="name" vsli:raw="The &lt;see cref=&quot;T:System.String&quot; /&gt; containing the name of the nested type to get.">
        <see cref="T:System.String" /> que contiene el nombre del tipo anidado que se va a obtener.</param>
      <param name="bindingAttr" vsli:raw="A bitmask comprised of one or more &lt;see cref=&quot;T:System.Reflection.BindingFlags&quot; /&gt; that specify how the search is conducted.  &#xA;  &#xA; -or-  &#xA;  &#xA; Zero, to conduct a case-sensitive search for public methods.">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.  
O bien 
Cero, para realizar una búsqueda de los métodos públicos que distinga entre mayúsculas y minúsculas.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the nested type that matches the specified requirements, if found; otherwise, &lt;see langword=&quot;null&quot; /&gt;.">Objeto <see cref="T:System.Type" /> que representa el tipo anidado que cumple los requisitos especificados, si se encuentra; en caso contrario, <see langword="null" />.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported in types that are not complete.">Actualmente, este método no es compatible con los tipos que no están completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
      <summary vsli:raw="Returns the public and non-public nested types that are declared or inherited by this type.">Devuelve los tipos anidados públicos y no públicos declarados o heredados por este tipo.</summary>
      <param name="bindingAttr" vsli:raw="This must be a bit flag from &lt;see cref=&quot;T:System.Reflection.BindingFlags&quot; /&gt;, such as &lt;see langword=&quot;InvokeMethod&quot; /&gt;, &lt;see langword=&quot;NonPublic&quot; /&gt;, and so on.">Debe ser una marca de bits de <see cref="T:System.Reflection.BindingFlags" />, como <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
      <returns vsli:raw="An array of &lt;see cref=&quot;T:System.Type&quot; /&gt; objects representing all the types nested within the current &lt;see cref=&quot;T:System.Type&quot; /&gt; that match the specified binding constraints.  &#xA;  &#xA; An empty array of type &lt;see cref=&quot;T:System.Type&quot; /&gt;, if no types are nested within the current &lt;see cref=&quot;T:System.Type&quot; /&gt;, or if none of the nested types match the binding constraints.">Matriz de objetos <see cref="T:System.Type" /> que representa a todos los tipos anidados del objeto <see cref="T:System.Type" /> actual que coinciden con las restricciones de enlace especificadas.  
Matriz vacía de tipo <see cref="T:System.Type" />, si no hay tipos anidados dentro del actual <see cref="T:System.Type" />, o si ninguno de los tipos anidados coincide con las limitaciones de enlace.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported in types that are not complete.">Actualmente, este método no es compatible con los tipos que no están completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetProperties(System.Reflection.BindingFlags)">
      <summary vsli:raw="Returns all the public and non-public properties declared or inherited by this type, as specified.">Devuelve todas las propiedades públicas y no públicas declaradas o heredadas por este tipo, como se especifica.</summary>
      <param name="bindingAttr" vsli:raw="This invocation attribute. This must be a bit flag from &lt;see cref=&quot;T:System.Reflection.BindingFlags&quot; /&gt; : &lt;see langword=&quot;InvokeMethod&quot; /&gt;, &lt;see langword=&quot;NonPublic&quot; /&gt;, and so on.">Este atributo de invocación. Debe ser un indicador de bits de <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
      <returns vsli:raw="Returns an array of &lt;see cref=&quot;T:System.Reflection.PropertyInfo&quot; /&gt; objects representing the public and non-public properties defined on this type if &lt;paramref name=&quot;nonPublic&quot; /&gt; is used; otherwise, only the public properties are returned.">Devuelve una matriz de objetos <see cref="T:System.Reflection.PropertyInfo" /> que representan las propiedades públicas y no públicas definidas en este tipo si se usa <paramref name="nonPublic" />; en caso contrario, solo se devuelven las propiedades públicas.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported in types that are not complete.">Actualmente, este método no es compatible con los tipos que no están completos.</exception>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.GUID">
      <summary vsli:raw="Returns the GUID of this enum.">Devuelve el GUID de esta enumeración.</summary>
      <returns vsli:raw="Read-only. The GUID of this enum.">Sólo lectura. GUID de esta enumeración.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported in types that are not complete.">Actualmente, este método no es compatible con los tipos que no están completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
      <summary vsli:raw="Invokes the specified member. The method that is to be invoked must be accessible and provide the most specific match with the specified argument list, under the constraints of the specified binder and invocation attributes.">Invoca el miembro especificado. El método que se va a invocar debe ser accesible y proporcionar la coincidencia más específica con la lista de argumentos dada, bajo las restricciones del enlazador y los atributos de invocación indicados.</summary>
      <param name="name" vsli:raw="The name of the member to invoke. This can be a constructor, method, property, or field. A suitable invocation attribute must be specified. Note that it is possible to invoke the default member of a class by passing an empty string as the name of the member.">Nombre del miembro que se va a invocar. Puede ser un constructor, un método, una propiedad o un campo. Debe especificarse un atributo de invocación apropiado. Tenga en cuenta que es posible invocar al miembro predeterminado de una clase pasando una cadena vacía como el nombre del miembro.</param>
      <param name="invokeAttr" vsli:raw="The invocation attribute. This must be a bit flag from &lt;see langword=&quot;BindingFlags&quot; /&gt;.">Atributo de invocación. Debe ser un indicador de bits de <see langword="BindingFlags" />.</param>
      <param name="binder" vsli:raw="An object that enables the binding, coercion of argument types, invocation of members, and retrieval of &lt;see langword=&quot;MemberInfo&quot; /&gt; objects using reflection. If binder is &lt;see langword=&quot;null&quot; /&gt;, the default binder is used. See &lt;see cref=&quot;T:System.Reflection.Binder&quot; /&gt;.">Objeto que permite el enlace, la conversión de tipos de argumentos, la invocación de miembros y la recuperación de objetos <see langword="MemberInfo" /> mediante la reflexión. Si el enlazador es <see langword="null" />, se usará el enlazador predeterminado. Vea <see cref="T:System.Reflection.Binder" />.</param>
      <param name="target" vsli:raw="The object on which to invoke the specified member. If the member is static, this parameter is ignored.">Objeto donde debe invocarse al miembro especificado. Si el miembro es estático, se ignora este parámetro.</param>
      <param name="args" vsli:raw="An argument list. This is an array of objects that contains the number, order, and type of the parameters of the member to be invoked. If there are no parameters this should be null.">Lista de argumentos. Esta matriz de objetos contiene el número, orden y tipo de los parámetros del miembro al que se va a invocar. Si no hay ningún parámetro, este valor debe ser null.</param>
      <param name="modifiers" vsli:raw="An array of the same length as &lt;paramref name=&quot;args&quot; /&gt; with elements that represent the attributes associated with the arguments of the member to be invoked. A parameter has attributes associated with it in the metadata. They are used by various interoperability services. See the metadata specs for details such as this.">Matriz de la misma longitud que <paramref name="args" /> con elementos que representan los atributos asociados a los argumentos del miembro que se va a invocar. Un parámetro tiene atributos asociados a él en los metadatos. Los usan varios servicios de interoperabilidad. Vea las especificaciones de metadatos con el fin de obtener información de este tipo.</param>
      <param name="culture" vsli:raw="An instance of &lt;see langword=&quot;CultureInfo&quot; /&gt; used to govern the coercion of types. If this is null, the &lt;see langword=&quot;CultureInfo&quot; /&gt; for the current thread is used. (Note that this is necessary to, for example, convert a string that represents 1000 to a double value, since 1000 is represented differently by different cultures.)">Instancia de <see langword="CultureInfo" /> usada para regir la conversión de tipos. Si es null, se utiliza <see langword="CultureInfo" /> para el subproceso actual. (Observe que esto es necesario, por ejemplo, para convertir una cadena que representa 1000 en un valor doble, ya que 1000 se representa de forma diferente en distintas referencias culturales).</param>
      <param name="namedParameters" vsli:raw="Each parameter in the &lt;paramref name=&quot;namedParameters&quot; /&gt; array gets the value in the corresponding element in the &lt;paramref name=&quot;args&quot; /&gt; array. If the length of &lt;paramref name=&quot;args&quot; /&gt; is greater than the length of &lt;paramref name=&quot;namedParameters&quot; /&gt;, the remaining argument values are passed in order.">Cada parámetro de la matriz <paramref name="namedParameters" /> obtiene el valor del elemento correspondiente en la matriz <paramref name="args" />. Si la longitud de <paramref name="args" /> es mayor que la longitud de <paramref name="namedParameters" />, los valores de argumento restantes se pasan por orden.</param>
      <returns vsli:raw="Returns the return value of the invoked member.">Devuelve el valor devuelto del miembro invocado.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported in types that are not complete.">Actualmente, este método no es compatible con los tipos que no están completos.</exception>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.IsByRefLike" />
    <member name="P:System.Reflection.Emit.EnumBuilder.IsConstructedGenericType">
      <summary vsli:raw="Gets a value that indicates whether this object represents a constructed generic type.">Obtiene un valor que indica si este objeto representa un tipo genérico construido.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if this object represents a constructed generic type; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si este objeto representa una definición de tipo genérico construido; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.IsDefined(System.Type,System.Boolean)">
      <summary vsli:raw="Checks if the specified custom attribute type is defined.">Comprueba si se ha definido el tipo de atributo personalizado especificado.</summary>
      <param name="attributeType" vsli:raw="The &lt;see langword=&quot;Type&quot; /&gt; object to which the custom attributes are applied.">Objeto <see langword="Type" /> al que se aplican los atributos personalizados.</param>
      <param name="inherit" vsli:raw="Specifies whether to search this member's inheritance chain to find the attributes.">Especifica si se debe buscar la cadena de herencia de este miembro para encontrar los atributos.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if one or more instance of &lt;paramref name=&quot;attributeType&quot; /&gt; is defined on this member; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si hay definidas una o más instancias de <paramref name="attributeType" /> en este miembro; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported in types that are not complete.">Actualmente, este método no es compatible con los tipos que no están completos.</exception>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.IsSZArray" />
    <member name="P:System.Reflection.Emit.EnumBuilder.IsTypeDefinition" />
    <member name="P:System.Reflection.Emit.EnumBuilder.IsVariableBoundArray" />
    <member name="M:System.Reflection.Emit.EnumBuilder.MakeArrayType">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing a one-dimensional array of the current type, with a lower bound of zero.">Devuelve un objeto <see cref="T:System.Type" /> que representa una matriz unidimensional del tipo actual, con un límite inferior de cero.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing a one-dimensional array of the current type, with a lower bound of zero.">Objeto <see cref="T:System.Type" /> que representa una matriz unidimensional del tipo actual, con un límite inferior de cero.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.MakeArrayType(System.Int32)">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing an array of the current type, with the specified number of dimensions.">Devuelve un objeto <see cref="T:System.Type" /> que representa una matriz del tipo actual, con el número de dimensiones especificado.</summary>
      <param name="rank" vsli:raw="The number of dimensions for the array. This number must be less than or equal to 32.">Número de dimensiones de la matriz. Este número debe ser menor o igual que 32.</param>
      <returns vsli:raw="An object representing an array of the current type, with the specified number of dimensions.">Objeto que representa una matriz del tipo actual, con el número de dimensiones especificado.</returns>
      <exception cref="T:System.IndexOutOfRangeException" vsli:raw="&lt;paramref name=&quot;rank&quot; /&gt; is less than 1.">
        <paramref name="rank" /> es menor que 1.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.MakeByRefType">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents the current type when passed as a ref parameter (ByRef parameter in Visual Basic).">Devuelve un objeto <see cref="T:System.Type" /> que representa el tipo actual cuando se pasa como un parámetro ref (parámetro ByRef en Visual Basic).</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents the current type when passed as a ref parameter (ByRef parameter in Visual Basic).">Objeto <see cref="T:System.Type" /> que representa el tipo actual cuando se pasa como un parámetro ref (parámetro ByRef en Visual Basic).</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.MakePointerType">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents a pointer to the current type.">Devuelve un objeto <see cref="T:System.Type" /> que representa un puntero al tipo actual.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents a pointer to the current type.">Objeto <see cref="T:System.Type" /> que representa un puntero al tipo actual.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.Module">
      <summary vsli:raw="Retrieves the dynamic module that contains this &lt;see cref=&quot;T:System.Reflection.Emit.EnumBuilder&quot; /&gt; definition.">Recupera el módulo dinámico que contiene la definición de este objeto <see cref="T:System.Reflection.Emit.EnumBuilder" />.</summary>
      <returns vsli:raw="Read-only. The dynamic module that contains this &lt;see cref=&quot;T:System.Reflection.Emit.EnumBuilder&quot; /&gt; definition.">Sólo lectura. Módulo dinámico que contiene la definición de este <see cref="T:System.Reflection.Emit.EnumBuilder" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.Name">
      <summary vsli:raw="Returns the name of this enum.">Devuelve el nombre de esta enumeración.</summary>
      <returns vsli:raw="Read-only. The name of this enum.">Sólo lectura. Nombre de esta enumeración.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.Namespace">
      <summary vsli:raw="Returns the namespace of this enum.">Devuelve el espacio de nombres de esta enumeración.</summary>
      <returns vsli:raw="Read-only. The namespace of this enum.">Sólo lectura. Espacio de nombres de esta enumeración.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.ReflectedType">
      <summary vsli:raw="Returns the type that was used to obtain this &lt;see cref=&quot;T:System.Reflection.Emit.EnumBuilder&quot; /&gt;.">Devuelve el tipo que se utilizó para obtener este objeto <see cref="T:System.Reflection.Emit.EnumBuilder" />.</summary>
      <returns vsli:raw="Read-only. The type that was used to obtain this &lt;see cref=&quot;T:System.Reflection.Emit.EnumBuilder&quot; /&gt;.">Sólo lectura. Tipo que se utilizó para obtener este objeto <see cref="T:System.Reflection.Emit.EnumBuilder" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary vsli:raw="Sets a custom attribute using a specified custom attribute blob.">Establece un atributo personalizado mediante un blob de atributo personalizado especificado.</summary>
      <param name="con" vsli:raw="The constructor for the custom attribute.">Constructor para el atributo personalizado.</param>
      <param name="binaryAttribute" vsli:raw="A byte blob representing the attributes.">Blob de bytes que representa los atributos.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;con&quot; /&gt; or &lt;paramref name=&quot;binaryAttribute&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="con" /> o <paramref name="binaryAttribute" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary vsli:raw="Sets a custom attribute using a custom attribute builder.">Establece un atributo personalizado mediante un generador de atributos personalizados.</summary>
      <param name="customBuilder" vsli:raw="An instance of a helper class to define the custom attribute.">Instancia de una clase del asistente para definir el atributo personalizado.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;con&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="con" /> es <see langword="null" />.</exception>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.TypeHandle">
      <summary vsli:raw="Retrieves the internal handle for this enum.">Recupera el identificador interno de esta enumeración.</summary>
      <returns vsli:raw="Read-only. The internal handle for this enum.">Sólo lectura. Identificador interno de esta enumeración.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This property is not currently supported.">Actualmente, esta propiedad no es compatible.</exception>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.UnderlyingField">
      <summary vsli:raw="Returns the underlying field for this enum.">Devuelve el campo subyacente de esta enumeración.</summary>
      <returns vsli:raw="Read-only. The underlying field for this enum.">Sólo lectura. Campo subyacente de esta enumeración.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.UnderlyingSystemType">
      <summary vsli:raw="Returns the underlying system type for this enum.">Devuelve el tipo de sistema subyacente de esta enumeración.</summary>
      <returns vsli:raw="Read-only. Returns the underlying system type.">Sólo lectura. Devuelve el tipo de sistema subyacente.</returns>
    </member>
    <member name="T:System.Reflection.Emit.EventBuilder">
      <summary vsli:raw="Defines events for a class.">Define los eventos para una clase.</summary>
    </member>
    <member name="M:System.Reflection.Emit.EventBuilder.AddOtherMethod(System.Reflection.Emit.MethodBuilder)">
      <summary vsli:raw="Adds one of the &quot;other&quot; methods associated with this event. &quot;Other&quot; methods are methods other than the &quot;on&quot; and &quot;raise&quot; methods associated with an event. This function can be called many times to add as many &quot;other&quot; methods.">Agrega alguno de los "otros" métodos asociados a este evento. Cuando se habla de "otros" métodos, se hace referencia a métodos distintos de los métodos "on" y "raise" que están asociados a un evento. Se puede llamar a esta función numerosas veces para agregar todos los "otros" métodos que se desee.</summary>
      <param name="mdBuilder" vsli:raw="A &lt;see langword=&quot;MethodBuilder&quot; /&gt; object that represents the other method.">Objeto <see langword="MethodBuilder" /> que representa el otro método.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;mdBuilder&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="mdBuilder" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt; has been called on the enclosing type.">Se ha llamado a <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> en el tipo envolvente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EventBuilder.SetAddOnMethod(System.Reflection.Emit.MethodBuilder)">
      <summary vsli:raw="Sets the method used to subscribe to this event.">Establece el método que se utiliza para suscribirse a este evento.</summary>
      <param name="mdBuilder" vsli:raw="A &lt;see langword=&quot;MethodBuilder&quot; /&gt; object that represents the method used to subscribe to this event.">Objeto <see langword="MethodBuilder" /> que representa al método utilizado para suscribirse a este evento.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;mdBuilder&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="mdBuilder" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt; has been called on the enclosing type.">Se ha llamado a <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> en el tipo envolvente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EventBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary vsli:raw="Set a custom attribute using a specified custom attribute blob.">Establezca un atributo personalizado mediante el objeto binario de atributo personalizado especificado.</summary>
      <param name="con" vsli:raw="The constructor for the custom attribute.">Constructor para el atributo personalizado.</param>
      <param name="binaryAttribute" vsli:raw="A byte blob representing the attributes.">Blob de bytes que representa los atributos.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;con&quot; /&gt; or &lt;paramref name=&quot;binaryAttribute&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="con" /> o <paramref name="binaryAttribute" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt; has been called on the enclosing type.">Se ha llamado a <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> en el tipo envolvente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EventBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary vsli:raw="Sets a custom attribute using a custom attribute builder.">Establece un atributo personalizado mediante un generador de atributos personalizados.</summary>
      <param name="customBuilder" vsli:raw="An instance of a helper class to describe the custom attribute.">Instancia de una clase del asistente para describir el atributo personalizado.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;con&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="con" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt; has been called on the enclosing type.">Se ha llamado a <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> en el tipo envolvente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EventBuilder.SetRaiseMethod(System.Reflection.Emit.MethodBuilder)">
      <summary vsli:raw="Sets the method used to raise this event.">Establece el método que se utiliza para generar este evento.</summary>
      <param name="mdBuilder" vsli:raw="A &lt;see langword=&quot;MethodBuilder&quot; /&gt; object that represents the method used to raise this event.">Objeto <see langword="MethodBuilder" /> que representa al método utilizado para generar este evento.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;mdBuilder&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="mdBuilder" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt; has been called on the enclosing type.">Se ha llamado a <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> en el tipo envolvente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EventBuilder.SetRemoveOnMethod(System.Reflection.Emit.MethodBuilder)">
      <summary vsli:raw="Sets the method used to unsubscribe to this event.">Establece el método que se utiliza para cancelar la suscripción a este evento.</summary>
      <param name="mdBuilder" vsli:raw="A &lt;see langword=&quot;MethodBuilder&quot; /&gt; object that represents the method used to unsubscribe to this event.">Objeto <see langword="MethodBuilder" /> que representa al método utilizado para cancelar la suscripción a este evento.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;mdBuilder&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="mdBuilder" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt; has been called on the enclosing type.">Se ha llamado a <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> en el tipo envolvente.</exception>
    </member>
    <member name="T:System.Reflection.Emit.FieldBuilder">
      <summary vsli:raw="Defines and represents a field. This class cannot be inherited.">Define y representa a un campo. Esta clase no puede heredarse.</summary>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.Attributes">
      <summary vsli:raw="Indicates the attributes of this field. This property is read-only.">Indica los atributos de este campo. Esta propiedad es de sólo lectura.</summary>
      <returns vsli:raw="The attributes of this field.">Atributos de este campo.</returns>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.DeclaringType">
      <summary vsli:raw="Indicates a reference to the &lt;see cref=&quot;T:System.Type&quot; /&gt; object for the type that declares this field. This property is read-only.">Indica una referencia al objeto <see cref="T:System.Type" /> para el tipo que declara este campo. Esta propiedad es de sólo lectura.</summary>
      <returns vsli:raw="A reference to the &lt;see cref=&quot;T:System.Type&quot; /&gt; object for the type that declares this field.">Referencia al objeto <see cref="T:System.Type" /> para el tipo que declara este campo.</returns>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.FieldHandle">
      <summary vsli:raw="Indicates the internal metadata handle for this field. This property is read-only.">Indica el identificador interno de metadatos para este campo. Esta propiedad es de sólo lectura.</summary>
      <returns vsli:raw="The internal metadata handle for this field.">Identificador interno de metadatos para este campo.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not supported.">No se admite este método.</exception>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.FieldType">
      <summary vsli:raw="Indicates the &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents the type of this field. This property is read-only.">Indica el objeto <see cref="T:System.Type" /> que representa al tipo de este campo. Esta propiedad es de sólo lectura.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents the type of this field.">Objeto <see cref="T:System.Type" /> que representa al tipo de este campo.</returns>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.GetCustomAttributes(System.Boolean)">
      <summary vsli:raw="Returns all the custom attributes defined for this field.">Devuelve los atributos personalizados definidos para este campo.</summary>
      <param name="inherit" vsli:raw="Controls inheritance of custom attributes from base classes.">Controla la herencia de atributos personalizados de las clases base.</param>
      <returns vsli:raw="An array of type &lt;see cref=&quot;T:System.Object&quot; /&gt; representing all the custom attributes of the constructor represented by this &lt;see cref=&quot;T:System.Reflection.Emit.FieldBuilder&quot; /&gt; instance.">Matriz de tipo <see cref="T:System.Object" /> que representa a todos los atributos personalizados del constructor representado mediante la instancia <see cref="T:System.Reflection.Emit.FieldBuilder" />.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not supported.">No se admite este método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary vsli:raw="Returns all the custom attributes defined for this field identified by the given type.">Devuelve todos los atributos personalizados definidos para este campo identificado por el tipo dado.</summary>
      <param name="attributeType" vsli:raw="The custom attribute type.">Tipo de atributo personalizado.</param>
      <param name="inherit" vsli:raw="Controls inheritance of custom attributes from base classes.">Controla la herencia de atributos personalizados de las clases base.</param>
      <returns vsli:raw="An array of type &lt;see cref=&quot;T:System.Object&quot; /&gt; representing all the custom attributes of the constructor represented by this &lt;see cref=&quot;T:System.Reflection.Emit.FieldBuilder&quot; /&gt; instance.">Matriz de tipo <see cref="T:System.Object" /> que representa a todos los atributos personalizados del constructor representado mediante la instancia <see cref="T:System.Reflection.Emit.FieldBuilder" />.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not supported.">No se admite este método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.GetValue(System.Object)">
      <summary vsli:raw="Retrieves the value of the field supported by the given object.">Recupera el valor del campo compatible con el objeto dado.</summary>
      <param name="obj" vsli:raw="The object on which to access the field.">Objeto desde el que obtener acceso al campo.</param>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Object&quot; /&gt; containing the value of the field reflected by this instance.">
        <see cref="T:System.Object" /> que contiene el valor del campo reflejado por esta instancia.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not supported.">No se admite este método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.IsDefined(System.Type,System.Boolean)">
      <summary vsli:raw="Indicates whether an attribute having the specified type is defined on a field.">Indica si un atributo que tenga el tipo especificado, aparece definido en un campo.</summary>
      <param name="attributeType" vsli:raw="The type of the attribute.">Tipo del atributo.</param>
      <param name="inherit" vsli:raw="Controls inheritance of custom attributes from base classes.">Controla la herencia de atributos personalizados de las clases base.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if one or more instance of &lt;paramref name=&quot;attributeType&quot; /&gt; is defined on this field; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si hay definidas una o más instancias de <paramref name="attributeType" /> en este campo; en cualquier otro caso, <see langword="false" />.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported. Retrieve the field using &lt;see cref=&quot;M:System.Type.GetField(System.String,System.Reflection.BindingFlags)&quot; /&gt; and call &lt;see cref=&quot;M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)&quot; /&gt; on the returned &lt;see cref=&quot;T:System.Reflection.FieldInfo&quot; /&gt;.">Este método no se admite actualmente. Recupera el campo mediante <see cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" /> y llama a <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> en el <see cref="T:System.Reflection.FieldInfo" /> devuelto.</exception>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.Module">
      <summary vsli:raw="Gets the module in which the type that contains this field is being defined.">Obtiene el módulo en el que se define el tipo que contiene este campo.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Module&quot; /&gt; that represents the dynamic module in which this field is being defined.">Clase <see cref="T:System.Reflection.Module" /> que representa el módulo dinámico en el que se define este campo.</returns>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.Name">
      <summary vsli:raw="Indicates the name of this field. This property is read-only.">Indica el nombre de este campo. Esta propiedad es de sólo lectura.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.String&quot; /&gt; containing the name of this field.">
        <see cref="T:System.String" /> que contiene el nombre de este campo.</returns>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.ReflectedType">
      <summary vsli:raw="Indicates the reference to the &lt;see cref=&quot;T:System.Type&quot; /&gt; object from which this object was obtained. This property is read-only.">Indica la referencia al objeto <see cref="T:System.Type" /> del que se obtuvo este objeto. Esta propiedad es de sólo lectura.</summary>
      <returns vsli:raw="A reference to the &lt;see cref=&quot;T:System.Type&quot; /&gt; object from which this instance was obtained.">Referencia al objeto <see cref="T:System.Type" /> a partir del que se obtuvo esta instancia.</returns>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.SetConstant(System.Object)">
      <summary vsli:raw="Sets the default value of this field.">Establece el valor predeterminado de este campo.</summary>
      <param name="defaultValue" vsli:raw="The new default value for this field.">Nuevo valor predeterminado para este campo.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The containing type has been created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.">Tipo contenedor que se ha creado mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The field is not one of the supported types.  &#xA;  &#xA; -or-  &#xA;  &#xA; The type of &lt;paramref name=&quot;defaultValue&quot; /&gt; does not match the type of the field.  &#xA;  &#xA; -or-  &#xA;  &#xA; The field is of type &lt;see cref=&quot;T:System.Object&quot; /&gt; or other reference type, &lt;paramref name=&quot;defaultValue&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt;, and the value cannot be assigned to the reference type.">El campo no es ninguno de los tipos admitidos.  
o bien 
El tipo de <paramref name="defaultValue" /> no coincide con el tipo del campo.  
O bien 
El campo es de tipo <see cref="T:System.Object" /> o de otro tipo de referencia, el valor de <paramref name="defaultValue" /> no es <see langword="null" /> y el valor no se puede asignar al tipo de referencia.</exception>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary vsli:raw="Sets a custom attribute using a specified custom attribute blob.">Establece un atributo personalizado mediante un blob de atributo personalizado especificado.</summary>
      <param name="con" vsli:raw="The constructor for the custom attribute.">Constructor para el atributo personalizado.</param>
      <param name="binaryAttribute" vsli:raw="A byte blob representing the attributes.">Blob de bytes que representa los atributos.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;con&quot; /&gt; or &lt;paramref name=&quot;binaryAttribute&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="con" /> o <paramref name="binaryAttribute" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The parent type of this field is complete.">El tipo principal de este campo está completo.</exception>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary vsli:raw="Sets a custom attribute using a custom attribute builder.">Establece un atributo personalizado mediante un generador de atributos personalizados.</summary>
      <param name="customBuilder" vsli:raw="An instance of a helper class to define the custom attribute.">Instancia de una clase del asistente para definir el atributo personalizado.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;con&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="con" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The parent type of this field is complete.">El tipo principal de este campo está completo.</exception>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.SetOffset(System.Int32)">
      <summary vsli:raw="Specifies the field layout.">Especifica el diseño del campo.</summary>
      <param name="iOffset" vsli:raw="The offset of the field within the type containing this field.">Desplazamiento del campo dentro del tipo que contiene a este campo.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The containing type has been created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.">Tipo contenedor que se ha creado mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;iOffset&quot; /&gt; is less than zero.">
        <paramref name="iOffset" /> es menor que cero.</exception>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)">
      <summary vsli:raw="Sets the value of the field supported by the given object.">Establece el valor del campo admitido por el objeto determinado.</summary>
      <param name="obj" vsli:raw="The object on which to access the field.">Objeto desde el que obtener acceso al campo.</param>
      <param name="val" vsli:raw="The value to assign to the field.">Valor que se va a asignar al campo.</param>
      <param name="invokeAttr" vsli:raw="A member of &lt;see langword=&quot;IBinder&quot; /&gt; that specifies the type of binding that is desired (for example, IBinder.CreateInstance, IBinder.ExactBinding).">Miembro de <see langword="IBinder" /> que especifica el tipo de enlace deseado (por ejemplo, IBinder.CreateInstance, IBinder.ExactBinding).</param>
      <param name="binder" vsli:raw="A set of properties and enabling for binding, coercion of argument types, and invocation of members using reflection. If binder is null, then IBinder.DefaultBinding is used.">Conjunto de propiedades que habilitan el enlace, la conversión de tipos de argumentos y las invocaciones a miembros mediante Reflection. Si el enlazador es null, se utilizará IBinder.DefaultBinding.</param>
      <param name="culture" vsli:raw="The software preferences of a particular culture.">Preferencias de software de una referencia cultural determinada.</param>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not supported.">No se admite este método.</exception>
    </member>
    <member name="T:System.Reflection.Emit.GenericTypeParameterBuilder">
      <summary vsli:raw="Defines and creates generic type parameters for dynamically defined generic types and methods. This class cannot be inherited.">Define y crea parámetros de tipo genérico para los métodos y tipos genéricos definidos dinámicamente. Esta clase no puede heredarse.</summary>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.Assembly">
      <summary vsli:raw="Gets an &lt;see cref=&quot;T:System.Reflection.Assembly&quot; /&gt; object representing the dynamic assembly that contains the generic type definition the current type parameter belongs to.">Obtiene un objeto <see cref="T:System.Reflection.Assembly" /> que representa al ensamblado dinámico que contiene la definición de tipo genérico a que pertenece el parámetro de tipo actual.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Reflection.Assembly&quot; /&gt; object representing the dynamic assembly that contains the generic type definition the current type parameter belongs to.">Un objeto <see cref="T:System.Reflection.Assembly" /> que representa el ensamblado dinámico que contiene la definición de tipo genérico a que pertenece el parámetro de tipo actual.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.AssemblyQualifiedName">
      <summary vsli:raw="Gets &lt;see langword=&quot;null&quot; /&gt; in all cases.">Obtiene <see langword="null" /> en todos los casos.</summary>
      <returns vsli:raw="A null reference (&lt;see langword=&quot;Nothing&quot; /&gt; in Visual Basic) in all cases.">Referencia nula (<see langword="Nothing" /> en Visual Basic) en todos los casos.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.BaseType">
      <summary vsli:raw="Gets the base type constraint of the current generic type parameter.">Obtiene la restricción de tipo base del parámetro de tipo genérico actual.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents the base type constraint of the generic type parameter, or &lt;see langword=&quot;null&quot; /&gt; if the type parameter has no base type constraint.">Un objeto <see cref="T:System.Type" /> que representa la restricción de tipo base del parámetro de tipo genérico, o <see langword="null" /> si el parámetro de tipo no tiene ninguna restricción de tipo base.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.ContainsGenericParameters">
      <summary vsli:raw="Gets &lt;see langword=&quot;true&quot; /&gt; in all cases.">Obtiene <see langword="true" /> en todos los casos.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; in all cases.">
        <see langword="true" /> en todos los casos.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.DeclaringMethod">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the declaring method, if the current &lt;see cref=&quot;T:System.Reflection.Emit.GenericTypeParameterBuilder&quot; /&gt; represents a type parameter of a generic method.">Obtiene un objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método declarativo si el objeto <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> actual representa un parámetro de tipo de un método genérico.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the declaring method, if the current &lt;see cref=&quot;T:System.Reflection.Emit.GenericTypeParameterBuilder&quot; /&gt; represents a type parameter of a generic method; otherwise, &lt;see langword=&quot;null&quot; /&gt;.">Un objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método declarativo si el objeto <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> actual representa un parámetro de tipo de un método genérico; en caso contrario, es <see langword="null" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.DeclaringType">
      <summary vsli:raw="Gets the generic type definition or generic method definition to which the generic type parameter belongs.">Obtiene la definición de tipo genérico o la definición de método genérico a la que pertenece el parámetro de tipo genérico.</summary>
      <returns vsli:raw="If the type parameter belongs to a generic type, a &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing that generic type; if the type parameter belongs to a generic method, a &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing that type that declared that generic method.">Si el parámetro de tipo pertenece a un tipo genérico, un objeto <see cref="T:System.Type" /> que representa ese tipo genérico; si el parámetro de tipo pertenece a un método genérico, un objeto <see cref="T:System.Type" /> que representa ese tipo que declaró ese método genérico.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.Equals(System.Object)">
      <summary vsli:raw="Tests whether the given object is an instance of &lt;see langword=&quot;EventToken&quot; /&gt; and is equal to the current instance.">Comprueba si el objeto determinado es una instancia de <see langword="EventToken" /> y es igual a la instancia actual.</summary>
      <param name="o" vsli:raw="The object to be compared with the current instance.">Objeto que se va a comparar con la instancia actual.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;o&quot; /&gt; is an instance of &lt;see langword=&quot;EventToken&quot; /&gt; and equals the current instance; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si <paramref name="o" /> es una instancia de <see langword="EventToken" /> y es igual a la instancia actual; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.FullName">
      <summary vsli:raw="Gets &lt;see langword=&quot;null&quot; /&gt; in all cases.">Obtiene <see langword="null" /> en todos los casos.</summary>
      <returns vsli:raw="A null reference (&lt;see langword=&quot;Nothing&quot; /&gt; in Visual Basic) in all cases.">Referencia nula (<see langword="Nothing" /> en Visual Basic) en todos los casos.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.GenericParameterAttributes">
      <summary vsli:raw="Gets a combination of &lt;see cref=&quot;T:System.Reflection.GenericParameterAttributes&quot; /&gt; flags that describe the covariance and special constraints of the current generic type parameter.">Obtiene una combinación de marcas <see cref="T:System.Reflection.GenericParameterAttributes" /> que describen la covarianza y las restricciones especiales del parámetro de tipo genérico actual.</summary>
      <returns vsli:raw="A bitwise combination of values that describes the covariance and special constraints of the current generic type parameter.">Combinación bit a bit de valores que describe la covarianza y las restricciones especiales del parámetro de tipo genérico actual.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.GenericParameterPosition">
      <summary vsli:raw="Gets the position of the type parameter in the type parameter list of the generic type or method that declared the parameter.">Obtiene la posición del parámetro de tipo en la lista de parámetros de tipo del método o tipo genérico que declaró el parámetro.</summary>
      <returns vsli:raw="The position of the type parameter in the type parameter list of the generic type or method that declared the parameter.">La posición del parámetro de tipo en la lista de parámetros de tipo del método o tipo genérico que declaró el parámetro.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetConstructors(System.Reflection.BindingFlags)">
      <summary vsli:raw="Not supported for incomplete generic type parameters.">No se admite para parámetros de tipo genérico incompletos.</summary>
      <param name="bindingAttr" vsli:raw="Not supported.">No se admite.</param>
      <returns vsli:raw="Not supported for incomplete generic type parameters.">No se admite para parámetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases.">En todos los casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetCustomAttributes(System.Boolean)">
      <summary vsli:raw="Not supported for incomplete generic type parameters.">No se admite para parámetros de tipo genérico incompletos.</summary>
      <param name="inherit" vsli:raw="Specifies whether to search this member's inheritance chain to find the attributes.">Especifica si se debe buscar la cadena de herencia de este miembro para encontrar los atributos.</param>
      <returns vsli:raw="Not supported for incomplete generic type parameters.">No se admite para parámetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases.">En todos los casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary vsli:raw="Not supported for incomplete generic type parameters.">No se admite para parámetros de tipo genérico incompletos.</summary>
      <param name="attributeType" vsli:raw="The type of attribute to search for. Only attributes that are assignable to this type are returned.">El tipo de atributo que se va a buscar. Solo se devuelven los atributos que son asignables a este tipo.</param>
      <param name="inherit" vsli:raw="Specifies whether to search this member's inheritance chain to find the attributes.">Especifica si se debe buscar la cadena de herencia de este miembro para encontrar los atributos.</param>
      <returns vsli:raw="Not supported for incomplete generic type parameters.">No se admite para parámetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases.">En todos los casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetElementType">
      <summary vsli:raw="Throws a &lt;see cref=&quot;T:System.NotSupportedException&quot; /&gt; in all cases.">Devuelve <see cref="T:System.NotSupportedException" /> en todos los casos</summary>
      <returns vsli:raw="The type referred to by the current array type, pointer type, or &lt;see langword=&quot;ByRef&quot; /&gt; type; or &lt;see langword=&quot;null&quot; /&gt; if the current type is not an array type, is not a pointer type, and is not passed by reference.">Tipo al que hace referencia el tipo de matriz actual, tipo de puntero o tipo <see langword="ByRef" />; o <see langword="null" /> si el tipo actual no es un tipo de matriz, no es un tipo de puntero y no se pasa por referencia.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases.">En todos los casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
      <summary vsli:raw="Not supported for incomplete generic type parameters.">No se admite para parámetros de tipo genérico incompletos.</summary>
      <param name="name" vsli:raw="Not supported.">No se admite.</param>
      <param name="bindingAttr" vsli:raw="Not supported.">No se admite.</param>
      <returns vsli:raw="Not supported for incomplete generic type parameters.">No se admite para parámetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases.">En todos los casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetEvents">
      <summary vsli:raw="Not supported for incomplete generic type parameters.">No se admite para parámetros de tipo genérico incompletos.</summary>
      <returns vsli:raw="Not supported for incomplete generic type parameters.">No se admite para parámetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases.">En todos los casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetEvents(System.Reflection.BindingFlags)">
      <summary vsli:raw="Not supported for incomplete generic type parameters.">No se admite para parámetros de tipo genérico incompletos.</summary>
      <param name="bindingAttr" vsli:raw="Not supported.">No se admite.</param>
      <returns vsli:raw="Not supported for incomplete generic type parameters.">No se admite para parámetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases.">En todos los casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetField(System.String,System.Reflection.BindingFlags)">
      <summary vsli:raw="Not supported for incomplete generic type parameters.">No se admite para parámetros de tipo genérico incompletos.</summary>
      <param name="name" vsli:raw="Not supported.">No se admite.</param>
      <param name="bindingAttr" vsli:raw="Not supported.">No se admite.</param>
      <returns vsli:raw="Not supported for incomplete generic type parameters.">No se admite para parámetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases.">En todos los casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetFields(System.Reflection.BindingFlags)">
      <summary vsli:raw="Not supported for incomplete generic type parameters.">No se admite para parámetros de tipo genérico incompletos.</summary>
      <param name="bindingAttr" vsli:raw="Not supported.">No se admite.</param>
      <returns vsli:raw="Not supported for incomplete generic type parameters.">No se admite para parámetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases.">En todos los casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetGenericArguments">
      <summary vsli:raw="Not valid for generic type parameters.">No válido para parámetros de tipo genérico.</summary>
      <returns vsli:raw="Not valid for generic type parameters.">No válido para parámetros de tipo genérico.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="In all cases.">En todos los casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetGenericTypeDefinition">
      <summary vsli:raw="Not valid for generic type parameters.">No válido para parámetros de tipo genérico.</summary>
      <returns vsli:raw="Not valid for generic type parameters.">No válido para parámetros de tipo genérico.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="In all cases.">En todos los casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetHashCode">
      <summary vsli:raw="Returns a 32-bit integer hash code for the current instance.">Devuelve un código hash entero de 32 bits para la instancia actual.</summary>
      <returns vsli:raw="A 32-bit integer hash code.">Código hash de un entero de 32 bits.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetInterface(System.String,System.Boolean)">
      <summary vsli:raw="Not supported for incomplete generic type parameters.">No se admite para parámetros de tipo genérico incompletos.</summary>
      <param name="name" vsli:raw="The name of the interface.">Nombre de la interfaz.</param>
      <param name="ignoreCase" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to search without regard for case; &lt;see langword=&quot;false&quot; /&gt; to make a case-sensitive search.">
        <see langword="true" /> para buscar sin considerar la grafía; <see langword="false" /> para realizar una búsqueda con distinción entre mayúsculas y minúsculas.</param>
      <returns vsli:raw="Not supported for incomplete generic type parameters.">No se admite para parámetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases.">En todos los casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetInterfaceMap(System.Type)">
      <summary vsli:raw="Not supported for incomplete generic type parameters.">No se admite para parámetros de tipo genérico incompletos.</summary>
      <param name="interfaceType" vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents the interface type for which the mapping is to be retrieved.">Objeto <see cref="T:System.Type" /> que representa el tipo de interfaz para el que se va a recuperar la asignación.</param>
      <returns vsli:raw="Not supported for incomplete generic type parameters.">No se admite para parámetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases.">En todos los casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetInterfaces">
      <summary vsli:raw="Not supported for incomplete generic type parameters.">No se admite para parámetros de tipo genérico incompletos.</summary>
      <returns vsli:raw="Not supported for incomplete generic type parameters.">No se admite para parámetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases.">En todos los casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
      <summary vsli:raw="Not supported for incomplete generic type parameters.">No se admite para parámetros de tipo genérico incompletos.</summary>
      <param name="name" vsli:raw="Not supported.">No se admite.</param>
      <param name="type" vsli:raw="Not supported.">No se admite.</param>
      <param name="bindingAttr" vsli:raw="Not supported.">No se admite.</param>
      <returns vsli:raw="Not supported for incomplete generic type parameters.">No se admite para parámetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases.">En todos los casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetMembers(System.Reflection.BindingFlags)">
      <summary vsli:raw="Not supported for incomplete generic type parameters.">No se admite para parámetros de tipo genérico incompletos.</summary>
      <param name="bindingAttr" vsli:raw="Not supported.">No se admite.</param>
      <returns vsli:raw="Not supported for incomplete generic type parameters.">No se admite para parámetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases.">En todos los casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetMethods(System.Reflection.BindingFlags)">
      <summary vsli:raw="Not supported for incomplete generic type parameters.">No se admite para parámetros de tipo genérico incompletos.</summary>
      <param name="bindingAttr" vsli:raw="Not supported.">No se admite.</param>
      <returns vsli:raw="Not supported for incomplete generic type parameters.">No se admite para parámetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases.">En todos los casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
      <summary vsli:raw="Not supported for incomplete generic type parameters.">No se admite para parámetros de tipo genérico incompletos.</summary>
      <param name="name" vsli:raw="Not supported.">No se admite.</param>
      <param name="bindingAttr" vsli:raw="Not supported.">No se admite.</param>
      <returns vsli:raw="Not supported for incomplete generic type parameters.">No se admite para parámetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases.">En todos los casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
      <summary vsli:raw="Not supported for incomplete generic type parameters.">No se admite para parámetros de tipo genérico incompletos.</summary>
      <param name="bindingAttr" vsli:raw="Not supported.">No se admite.</param>
      <returns vsli:raw="Not supported for incomplete generic type parameters.">No se admite para parámetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases.">En todos los casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetProperties(System.Reflection.BindingFlags)">
      <summary vsli:raw="Not supported for incomplete generic type parameters.">No se admite para parámetros de tipo genérico incompletos.</summary>
      <param name="bindingAttr" vsli:raw="Not supported.">No se admite.</param>
      <returns vsli:raw="Not supported for incomplete generic type parameters.">No se admite para parámetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases.">En todos los casos.</exception>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.GUID">
      <summary vsli:raw="Not supported for incomplete generic type parameters.">No se admite para parámetros de tipo genérico incompletos.</summary>
      <returns vsli:raw="Not supported for incomplete generic type parameters.">No se admite para parámetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases.">En todos los casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
      <summary vsli:raw="Not supported for incomplete generic type parameters.">No se admite para parámetros de tipo genérico incompletos.</summary>
      <param name="name" vsli:raw="Not supported.">No se admite.</param>
      <param name="invokeAttr" vsli:raw="Not supported.">No se admite.</param>
      <param name="binder" vsli:raw="Not supported.">No se admite.</param>
      <param name="target" vsli:raw="Not supported.">No se admite.</param>
      <param name="args" vsli:raw="Not supported.">No se admite.</param>
      <param name="modifiers" vsli:raw="Not supported.">No se admite.</param>
      <param name="culture" vsli:raw="Not supported.">No se admite.</param>
      <param name="namedParameters" vsli:raw="Not supported.">No se admite.</param>
      <returns vsli:raw="Not supported for incomplete generic type parameters.">No se admite para parámetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases.">En todos los casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.IsAssignableFrom(System.Type)">
      <summary vsli:raw="Throws a &lt;see cref=&quot;T:System.NotSupportedException&quot; /&gt; exception in all cases.">Produce una excepción <see cref="T:System.NotSupportedException" /> en todos los casos.</summary>
      <param name="c" vsli:raw="The object to test.">El objeto que se va a probar.</param>
      <returns vsli:raw="Throws a &lt;see cref=&quot;T:System.NotSupportedException&quot; /&gt; exception in all cases.">Produce una excepción <see cref="T:System.NotSupportedException" /> en todos los casos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases.">En todos los casos.</exception>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsByRefLike" />
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsConstructedGenericType">
      <summary vsli:raw="Gets a value that indicates whether this object represents a constructed generic type.">Obtiene un valor que indica si este objeto representa un tipo genérico construido.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if this object represents a constructed generic type; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si este objeto representa una definición de tipo genérico construido; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.IsDefined(System.Type,System.Boolean)">
      <summary vsli:raw="Not supported for incomplete generic type parameters.">No se admite para parámetros de tipo genérico incompletos.</summary>
      <param name="attributeType" vsli:raw="Not supported.">No se admite.</param>
      <param name="inherit" vsli:raw="Not supported.">No se admite.</param>
      <returns vsli:raw="Not supported for incomplete generic type parameters.">No se admite para parámetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases.">En todos los casos.</exception>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsGenericParameter">
      <summary vsli:raw="Gets &lt;see langword=&quot;true&quot; /&gt; in all cases.">Obtiene <see langword="true" /> en todos los casos.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; in all cases.">
        <see langword="true" /> en todos los casos.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsGenericType">
      <summary vsli:raw="Returns &lt;see langword=&quot;false&quot; /&gt; in all cases.">Devuelve <see langword="false" /> en todos los casos</summary>
      <returns vsli:raw="&lt;see langword=&quot;false&quot; /&gt; in all cases.">
        <see langword="false" /> en todos los casos.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsGenericTypeDefinition">
      <summary vsli:raw="Gets &lt;see langword=&quot;false&quot; /&gt; in all cases.">Obtiene <see langword="false" /> en todos los casos.</summary>
      <returns vsli:raw="&lt;see langword=&quot;false&quot; /&gt; in all cases.">
        <see langword="false" /> en todos los casos.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.IsSubclassOf(System.Type)">
      <summary vsli:raw="Not supported for incomplete generic type parameters.">No se admite para parámetros de tipo genérico incompletos.</summary>
      <param name="c" vsli:raw="Not supported.">No se admite.</param>
      <returns vsli:raw="Not supported for incomplete generic type parameters.">No se admite para parámetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases.">En todos los casos.</exception>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsSZArray" />
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsTypeDefinition" />
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsVariableBoundArray" />
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.MakeArrayType">
      <summary vsli:raw="Returns the type of a one-dimensional array whose element type is the generic type parameter.">Devuelve el tipo de una matriz unidimensional cuyo tipo de elemento es el parámetro de tipo genérico.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents the type of a one-dimensional array whose element type is the generic type parameter.">Un objeto <see cref="T:System.Type" /> que representa el tipo de una matriz unidimensional cuyo tipo de elemento es el parámetro de tipo genérico.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.MakeArrayType(System.Int32)">
      <summary vsli:raw="Returns the type of an array whose element type is the generic type parameter, with the specified number of dimensions.">Devuelve el tipo de una matriz cuyo tipo de elemento es el parámetro de tipo genérico, con el número de dimensiones especificado.</summary>
      <param name="rank" vsli:raw="The number of dimensions for the array.">Número de dimensiones de la matriz.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents the type of an array whose element type is the generic type parameter, with the specified number of dimensions.">Un objeto <see cref="T:System.Type" /> que representa el tipo de una matriz cuyo tipo de elemento es el parámetro de tipo genérico, con el número de dimensiones especificado.</returns>
      <exception cref="T:System.IndexOutOfRangeException" vsli:raw="&lt;paramref name=&quot;rank&quot; /&gt; is not a valid number of dimensions. For example, its value is less than 1.">
        <paramref name="rank" /> no es un número de dimensiones válido. Por ejemplo, su valor es menor que 1.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.MakeByRefType">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents the current generic type parameter when passed as a reference parameter.">Devuelve un objeto <see cref="T:System.Type" /> que representa el parámetro de tipo genérico actual cuando se pasa como parámetro de referencia.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents the current generic type parameter when passed as a reference parameter.">Un objeto <see cref="T:System.Type" /> que representa el parámetro de tipo genérico actual cuando se pasa como parámetro de referencia.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.MakeGenericType(System.Type[])">
      <summary vsli:raw="Not valid for incomplete generic type parameters.">No válido para parámetros de tipo genérico incompletos.</summary>
      <param name="typeArguments" vsli:raw="An array of type arguments.">Matriz de argumentos de tipo.</param>
      <returns vsli:raw="This method is invalid for incomplete generic type parameters.">Este método no es válido para parámetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="In all cases.">En todos los casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.MakePointerType">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents a pointer to the current generic type parameter.">Devuelve un objeto <see cref="T:System.Type" /> que representa un puntero al parámetro de tipo genérico actual.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents a pointer to the current generic type parameter.">Un objeto <see cref="T:System.Type" /> que representa un puntero al parámetro de tipo genérico actual.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.Module">
      <summary vsli:raw="Gets the dynamic module that contains the generic type parameter.">Obtiene el módulo dinámico que contiene el parámetro de tipo genérico.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Module&quot; /&gt; object that represents the dynamic module that contains the generic type parameter.">Un objeto <see cref="T:System.Reflection.Module" /> que representa el módulo dinámico que contiene el parámetro de tipo genérico.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.Name">
      <summary vsli:raw="Gets the name of the generic type parameter.">Obtiene el nombre del parámetro de tipo genérico.</summary>
      <returns vsli:raw="The name of the generic type parameter.">Nombre del parámetro de tipo genérico.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.Namespace">
      <summary vsli:raw="Gets &lt;see langword=&quot;null&quot; /&gt; in all cases.">Obtiene <see langword="null" /> en todos los casos.</summary>
      <returns vsli:raw="A null reference (&lt;see langword=&quot;Nothing&quot; /&gt; in Visual Basic) in all cases.">Referencia nula (<see langword="Nothing" /> en Visual Basic) en todos los casos.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.ReflectedType">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Type&quot; /&gt; object that was used to obtain the &lt;see cref=&quot;T:System.Reflection.Emit.GenericTypeParameterBuilder&quot; /&gt;.">Obtiene el objeto <see cref="T:System.Type" /> utilizado para obtener el objeto <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object that was used to obtain the &lt;see cref=&quot;T:System.Reflection.Emit.GenericTypeParameterBuilder&quot; /&gt;.">El objeto <see cref="T:System.Type" /> utilizado para obtener el objeto <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.SetBaseTypeConstraint(System.Type)">
      <summary vsli:raw="Sets the base type that a type must inherit in order to be substituted for the type parameter.">Establece el tipo base que debe heredar un tipo con el fin de ser sustituido para el parámetro de tipo.</summary>
      <param name="baseTypeConstraint" vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; that must be inherited by any type that is to be substituted for the type parameter.">
        <see cref="T:System.Type" /> que debe heredar cualquier tipo que es sustituido para el parámetro de tipo.</param>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary vsli:raw="Sets a custom attribute using a specified custom attribute blob.">Establece un atributo personalizado mediante un blob de atributo personalizado especificado.</summary>
      <param name="con" vsli:raw="The constructor for the custom attribute.">Constructor para el atributo personalizado.</param>
      <param name="binaryAttribute" vsli:raw="A byte blob representing the attribute.">Objeto binario de bytes que representa el atributo.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;con&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;binaryAttribute&quot; /&gt; is a null reference.">
        <paramref name="con" /> es <see langword="null" />.  
O bien 
 <paramref name="binaryAttribute" /> es una referencia nula.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary vsli:raw="Set a custom attribute using a custom attribute builder.">Establece un atributo personalizado mediante un generador de atributos personalizado.</summary>
      <param name="customBuilder" vsli:raw="An instance of a helper class that defines the custom attribute.">Instancia de una clase del asistente que define el atributo personalizado.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;customBuilder&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="customBuilder" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes(System.Reflection.GenericParameterAttributes)">
      <summary vsli:raw="Sets the variance characteristics and special constraints of the generic parameter, such as the parameterless constructor constraint.">Establece las características de varianza y las restricciones especiales del parámetro genérico, como la restricción de constructor sin parámetros.</summary>
      <param name="genericParameterAttributes" vsli:raw="A bitwise combination of &lt;see cref=&quot;T:System.Reflection.GenericParameterAttributes&quot; /&gt; values that represent the variance characteristics and special constraints of the generic type parameter.">Una combinación bit a bit de valores de <see cref="T:System.Reflection.GenericParameterAttributes" /> que representan las características de varianza y las restricciones especiales del parámetro de tipo genérico.</param>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.SetInterfaceConstraints(System.Type[])">
      <summary vsli:raw="Sets the interfaces a type must implement in order to be substituted for the type parameter.">Establece las interfaces que un tipo debe implementar con el fin de ser sustituido para el parámetro de tipo.</summary>
      <param name="interfaceConstraints" vsli:raw="An array of &lt;see cref=&quot;T:System.Type&quot; /&gt; objects that represent the interfaces a type must implement in order to be substituted for the type parameter.">Una matriz de objetos <see cref="T:System.Type" /> que representan las interfaces que un tipo debe implementar con el fin de ser sustituido para el parámetro de tipo.</param>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.ToString">
      <summary vsli:raw="Returns a string representation of the current generic type parameter.">Devuelve una representación de cadena del parámetro de tipo genérico actual.</summary>
      <returns vsli:raw="A string that contains the name of the generic type parameter.">Una cadena que contiene el nombre del parámetro de tipo genérico.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.TypeHandle">
      <summary vsli:raw="Not supported for incomplete generic type parameters.">No se admite para parámetros de tipo genérico incompletos.</summary>
      <returns vsli:raw="Not supported for incomplete generic type parameters.">No se admite para parámetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases.">En todos los casos.</exception>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.UnderlyingSystemType">
      <summary vsli:raw="Gets the current generic type parameter.">Obtiene el parámetro de tipo genérico actual.</summary>
      <returns vsli:raw="The current &lt;see cref=&quot;T:System.Reflection.Emit.GenericTypeParameterBuilder&quot; /&gt; object.">Objeto <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> actual.</returns>
    </member>
    <member name="T:System.Reflection.Emit.MethodBuilder">
      <summary vsli:raw="Defines and represents a method (or constructor) on a dynamic class.">Define y representa a un método (o constructor) de una clase dinámica.</summary>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.Attributes">
      <summary vsli:raw="Retrieves the attributes for this method.">Recupera los atributos para este método.</summary>
      <returns vsli:raw="Read-only. Retrieves the &lt;see langword=&quot;MethodAttributes&quot; /&gt; for this method.">Sólo lectura. Recupera los <see langword="MethodAttributes" /> para este método.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.CallingConvention">
      <summary vsli:raw="Returns the calling convention of the method.">Devuelve la convención de llamadas del método.</summary>
      <returns vsli:raw="Read-only. The calling convention of the method.">Sólo lectura. Convención de llamada del método.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.ContainsGenericParameters">
      <summary vsli:raw="Not supported for this type.">No es compatible con este tipo.</summary>
      <returns vsli:raw="Not supported.">No se admite.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="The invoked method is not supported in the base class.">El método invocado no se admite en la clase base.</exception>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.DeclaringType">
      <summary vsli:raw="Returns the type that declares this method.">Devuelve el tipo que declara este método.</summary>
      <returns vsli:raw="Read-only. The type that declares this method.">Sólo lectura. Tipo que declara este método.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
      <summary vsli:raw="Sets the number of generic type parameters for the current method, specifies their names, and returns an array of &lt;see cref=&quot;T:System.Reflection.Emit.GenericTypeParameterBuilder&quot; /&gt; objects that can be used to define their constraints.">Establece el número de parámetros de tipo genérico del método actual, especifica sus nombres y devuelve una matriz de objetos <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> que se pueden utilizar para definir sus restricciones.</summary>
      <param name="names" vsli:raw="An array of strings that represent the names of the generic type parameters.">Matriz de cadenas que representan los nombres de los parámetros de tipo genérico.</param>
      <returns vsli:raw="An array of &lt;see cref=&quot;T:System.Reflection.Emit.GenericTypeParameterBuilder&quot; /&gt; objects representing the type parameters of the generic method.">Una matriz de objetos <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> que representan los parámetros de tipo del método genérico.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Generic type parameters have already been defined for this method.  &#xA;  &#xA; -or-  &#xA;  &#xA; The method has been completed already.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)&quot; /&gt; method has been called for the current method.">Los parámetros de tipo genérico ya se han definido para este método.  
o bien 
Ya ha finalizado el método.  
o bien 
El método actual ha llamado al método <see cref="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)" />.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;names&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; An element of &lt;paramref name=&quot;names&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="names" /> es <see langword="null" />.  
o bien 
Un elemento de <paramref name="names" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;names&quot; /&gt; is an empty array.">
        <paramref name="names" /> es una matriz vacía.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
      <summary vsli:raw="Sets the parameter attributes and the name of a parameter of this method, or of the return value of this method. Returns a ParameterBuilder that can be used to apply custom attributes.">Establece los atributos de parámetro y el nombre de un parámetro de este método, o del valor devuelto de este método. Devuelve un ParameterBuilder, que se puede usar para aplicar atributos personalizados.</summary>
      <param name="position" vsli:raw="The position of the parameter in the parameter list. Parameters are indexed beginning with the number 1 for the first parameter; the number 0 represents the return value of the method.">Posición del parámetro en la lista de parámetros. Los parámetros se indizan empezando por el número 1 para el primer parámetro; el número 0 representa el valor devuelto del método.</param>
      <param name="attributes" vsli:raw="The parameter attributes of the parameter.">Atributos del parámetro.</param>
      <param name="strParamName" vsli:raw="The name of the parameter. The name can be the null string.">Nombre del parámetro. El nombre puede ser una cadena nula.</param>
      <returns vsli:raw="Returns a &lt;see langword=&quot;ParameterBuilder&quot; /&gt; object that represents a parameter of this method or the return value of this method.">Devuelve un objeto <see langword="ParameterBuilder" /> que representa un parámetro de este método o el valor devuelto del mismo.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The method has no parameters.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;position&quot; /&gt; is less than zero.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;position&quot; /&gt; is greater than the number of the method's parameters.">El método no tiene parámetros.  
o bien 
 <paramref name="position" /> es menor que cero.  
O bien 
 <paramref name="position" /> es mayor que el número de parámetros del método.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The containing type was previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; For the current method, the &lt;see cref=&quot;P:System.Reflection.Emit.MethodBuilder.IsGenericMethod&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;, but the &lt;see cref=&quot;P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition&quot; /&gt; property is &lt;see langword=&quot;false&quot; /&gt;.">El tipo contenedor se creó anteriormente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
o bien 
Para el método actual, la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> es <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.Equals(System.Object)">
      <summary vsli:raw="Determines whether the given object is equal to this instance.">Determina si el objeto dado es igual a esta instancia.</summary>
      <param name="obj" vsli:raw="The object to compare with this &lt;see langword=&quot;MethodBuilder&quot; /&gt; instance.">Objeto que se va a comparar con la instancia <see langword="MethodBuilder" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;obj&quot; /&gt; is an instance of &lt;see langword=&quot;MethodBuilder&quot; /&gt; and is equal to this object; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si <paramref name="obj" /> es una instancia de <see langword="MethodBuilder" /> y es igual a este objeto; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetBaseDefinition">
      <summary vsli:raw="Return the base implementation for a method.">Devuelve la implementación base para un método.</summary>
      <returns vsli:raw="The base implementation of this method.">Implementación base de este método.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Boolean)">
      <summary vsli:raw="Returns all the custom attributes defined for this method.">Devuelve los atributos personalizados definidos para este método.</summary>
      <param name="inherit" vsli:raw="Specifies whether to search this member's inheritance chain to find the custom attributes.">Especifica si se debe buscar la cadena de herencia de este miembro con el fin de encontrar los atributos personalizados.</param>
      <returns vsli:raw="Returns an array of objects representing all the custom attributes of this method.">Devuelve una matriz de objetos que representa a todos los atributos personalizados de este método.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported. Retrieve the method using &lt;see cref=&quot;M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])&quot; /&gt; and call &lt;see cref=&quot;M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)&quot; /&gt; on the returned &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt;.">Este método no se admite actualmente. Recupere el método mediante <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> y llame a <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> en el objeto <see cref="T:System.Reflection.MethodInfo" /> devuelto.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary vsli:raw="Returns the custom attributes identified by the given type.">Devuelve los atributos personalizados identificados por el tipo dado.</summary>
      <param name="attributeType" vsli:raw="The custom attribute type.">Tipo de atributo personalizado.</param>
      <param name="inherit" vsli:raw="Specifies whether to search this member's inheritance chain to find the custom attributes.">Especifica si se debe buscar la cadena de herencia de este miembro con el fin de encontrar los atributos personalizados.</param>
      <returns vsli:raw="Returns an array of objects representing the attributes of this method that are of type &lt;paramref name=&quot;attributeType&quot; /&gt;.">Devuelve una matriz de objetos que representan los atributos de este método que son del tipo <paramref name="attributeType" />.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported. Retrieve the method using &lt;see cref=&quot;M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])&quot; /&gt; and call &lt;see cref=&quot;M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)&quot; /&gt; on the returned &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt;.">Este método no se admite actualmente. Recupere el método mediante <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> y llame a <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> en el objeto <see cref="T:System.Reflection.MethodInfo" /> devuelto.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetGenericArguments">
      <summary vsli:raw="Returns an array of &lt;see cref=&quot;T:System.Reflection.Emit.GenericTypeParameterBuilder&quot; /&gt; objects that represent the type parameters of the method, if it is generic.">Devuelve una matriz de objetos <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> que representan los parámetros de tipo del método si es genérico.</summary>
      <returns vsli:raw="An array of &lt;see cref=&quot;T:System.Reflection.Emit.GenericTypeParameterBuilder&quot; /&gt; objects representing the type parameters, if the method is generic, or &lt;see langword=&quot;null&quot; /&gt; if the method is not generic.">Una matriz de objetos <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> que representan los parámetros de tipo si el método es genérico, o bien, <see langword="null" /> si el método no es genérico.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition">
      <summary vsli:raw="Returns this method.">Devuelve este método.</summary>
      <returns vsli:raw="The current instance of &lt;see cref=&quot;T:System.Reflection.Emit.MethodBuilder&quot; /&gt;.">La actual instancia de <see cref="T:System.Reflection.Emit.MethodBuilder" />.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The current method is not generic. That is, the &lt;see cref=&quot;P:System.Reflection.Emit.MethodBuilder.IsGenericMethod&quot; /&gt; property returns &lt;see langword=&quot;false&quot; /&gt;.">El método actual no es genérico. Es decir, la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> devuelve <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetHashCode">
      <summary vsli:raw="Gets the hash code for this method.">Obtiene el código hash para este método.</summary>
      <returns vsli:raw="The hash code for this method.">Código hash para este método.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetILGenerator">
      <summary vsli:raw="Returns an &lt;see langword=&quot;ILGenerator&quot; /&gt; for this method with a default Microsoft intermediate language (MSIL) stream size of 64 bytes.">Devuelve un <see langword="ILGenerator" /> para este método con un tamaño predeterminado de secuencia de Lenguaje intermedio de Microsoft (MSIL) de 64 bytes.</summary>
      <returns vsli:raw="Returns an &lt;see langword=&quot;ILGenerator&quot; /&gt; object for this method.">Devuelve un objeto <see langword="ILGenerator" /> para este método.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method should not have a body because of its &lt;see cref=&quot;T:System.Reflection.MethodAttributes&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.MethodImplAttributes&quot; /&gt; flags, for example because it has the &lt;see cref=&quot;F:System.Reflection.MethodAttributes.PinvokeImpl&quot; /&gt; flag.  &#xA;  &#xA; -or-  &#xA;  &#xA; The method is a generic method, but not a generic method definition. That is, the &lt;see cref=&quot;P:System.Reflection.Emit.MethodBuilder.IsGenericMethod&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;, but the &lt;see cref=&quot;P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition&quot; /&gt; property is &lt;see langword=&quot;false&quot; /&gt;.">El método no debe tener un cuerpo debido a sus marcas de <see cref="T:System.Reflection.MethodAttributes" /> o <see cref="T:System.Reflection.MethodImplAttributes" />; por ejemplo, porque tiene la marca de <see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" />.  
O bien 
El método es un método genérico, pero no una definición de método genérico. Es decir, el valor de la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> es <see langword="true" />, pero el valor de la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> es <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetILGenerator(System.Int32)">
      <summary vsli:raw="Returns an &lt;see langword=&quot;ILGenerator&quot; /&gt; for this method with the specified Microsoft intermediate language (MSIL) stream size.">Devuelve un <see langword="ILGenerator" /> para este método con el tamaño de secuencia de Lenguaje intermedio de Microsoft (MSIL) especificado.</summary>
      <param name="size" vsli:raw="The size of the MSIL stream, in bytes.">Tamaño de la secuencia de MSIL, en bytes.</param>
      <returns vsli:raw="Returns an &lt;see langword=&quot;ILGenerator&quot; /&gt; object for this method.">Devuelve un objeto <see langword="ILGenerator" /> para este método.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method should not have a body because of its &lt;see cref=&quot;T:System.Reflection.MethodAttributes&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.MethodImplAttributes&quot; /&gt; flags, for example because it has the &lt;see cref=&quot;F:System.Reflection.MethodAttributes.PinvokeImpl&quot; /&gt; flag.  &#xA;  &#xA; -or-  &#xA;  &#xA; The method is a generic method, but not a generic method definition. That is, the &lt;see cref=&quot;P:System.Reflection.Emit.MethodBuilder.IsGenericMethod&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;, but the &lt;see cref=&quot;P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition&quot; /&gt; property is &lt;see langword=&quot;false&quot; /&gt;.">El método no debe tener un cuerpo debido a sus marcas de <see cref="T:System.Reflection.MethodAttributes" /> o <see cref="T:System.Reflection.MethodImplAttributes" />; por ejemplo, porque tiene la marca de <see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" />.  
o bien 
El método es un método genérico, pero no una definición de método genérico. Es decir, el valor de la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> es <see langword="true" />, pero el valor de la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> es <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags">
      <summary vsli:raw="Returns the implementation flags for the method.">Devuelve las marcas de implementación para el método.</summary>
      <returns vsli:raw="Returns the implementation flags for the method.">Devuelve las marcas de implementación para el método.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetParameters">
      <summary vsli:raw="Returns the parameters of this method.">Devuelve los parámetros de este método.</summary>
      <returns vsli:raw="An array of &lt;see langword=&quot;ParameterInfo&quot; /&gt; objects that represent the parameters of the method.">Matriz de objetos <see langword="ParameterInfo" /> que representa a los parámetros de este método.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported. Retrieve the method using &lt;see cref=&quot;M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])&quot; /&gt; and call &lt;see langword=&quot;GetParameters&quot; /&gt; on the returned &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt;.">Este método no se admite actualmente. Recupere el método mediante <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> y llame a <see langword="GetParameters" /> en el objeto <see cref="T:System.Reflection.MethodInfo" /> devuelto.</exception>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.InitLocals">
      <summary vsli:raw="Gets or sets a Boolean value that specifies whether the local variables in this method are zero initialized. The default value of this property is &lt;see langword=&quot;true&quot; /&gt;.">Obtiene o establece un valor booleano que especifica si las variables locales de este método se inicializan en cero. El valor predeterminado de esta propiedad es <see langword="true" />.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the local variables in this method should be zero initialized; otherwise &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si las variables locales de este método deben inicializarse en cero; de lo contrario, es <see langword="false" />.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="For the current method, the &lt;see cref=&quot;P:System.Reflection.Emit.MethodBuilder.IsGenericMethod&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;, but the &lt;see cref=&quot;P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition&quot; /&gt; property is &lt;see langword=&quot;false&quot; /&gt;. (Get or set.)">Para el método actual, la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> es <see langword="false" />. (Get o set.)</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
      <summary vsli:raw="Dynamically invokes the method reflected by this instance on the given object, passing along the specified parameters, and under the constraints of the given binder.">Invoca dinámicamente al método que refleja esta instancia sobre el objeto dado, pasando los parámetros especificados y considerando las restricciones del enlazador dado.</summary>
      <param name="obj" vsli:raw="The object on which to invoke the specified method. If the method is static, this parameter is ignored.">Objeto donde debe invocarse al método especificado. Si el miembro es estático, se omite este parámetro.</param>
      <param name="invokeAttr" vsli:raw="This must be a bit flag from &lt;see cref=&quot;T:System.Reflection.BindingFlags&quot; /&gt; : &lt;see langword=&quot;InvokeMethod&quot; /&gt;, &lt;see langword=&quot;NonPublic&quot; /&gt;, and so on.">Debe ser un indicador de bits de <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
      <param name="binder" vsli:raw="An object that enables the binding, coercion of argument types, invocation of members, and retrieval of MemberInfo objects via reflection. If binder is &lt;see langword=&quot;null&quot; /&gt;, the default binder is used. For more details, see &lt;see cref=&quot;T:System.Reflection.Binder&quot; /&gt;.">Objeto que permite el enlace, la conversión de tipos de argumentos, la invocación de miembros y la recuperación de objetos MemberInfo mediante reflexión. Si el enlazador es <see langword="null" />, se usará el enlazador predeterminado. Para obtener más información, vea <see cref="T:System.Reflection.Binder" />.</param>
      <param name="parameters" vsli:raw="An argument list. This is an array of arguments with the same number, order, and type as the parameters of the method to be invoked. If there are no parameters this should be &lt;see langword=&quot;null&quot; /&gt;.">Lista de argumentos. Esta matriz de argumentos tiene el mismo número, orden y tipo que los parámetros del método al que se va a invocar. Si no hay ningún parámetro, este debería ser <see langword="null" />.</param>
      <param name="culture" vsli:raw="An instance of &lt;see cref=&quot;T:System.Globalization.CultureInfo&quot; /&gt; used to govern the coercion of types. If this is null, the &lt;see cref=&quot;T:System.Globalization.CultureInfo&quot; /&gt; for the current thread is used. (Note that this is necessary to, for example, convert a &lt;see cref=&quot;T:System.String&quot; /&gt; that represents 1000 to a &lt;see cref=&quot;T:System.Double&quot; /&gt; value, since 1000 is represented differently by different cultures.)">Instancia de <see cref="T:System.Globalization.CultureInfo" /> usada para regir la conversión de tipos. Si es null, se utiliza <see cref="T:System.Globalization.CultureInfo" /> para el subproceso actual. (Hay que tener en cuenta que esto es necesario, por ejemplo, a la hora de convertir <see cref="T:System.String" /> que representa a 1000 en un valor <see cref="T:System.Double" />, ya que 1000 aparece representado de forma diferente en distintas referencias culturales).</param>
      <returns vsli:raw="Returns an object containing the return value of the invoked method.">Devuelve un objeto que contiene el valor devuelto del método invocado.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported. Retrieve the method using &lt;see cref=&quot;M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])&quot; /&gt; and call &lt;see cref=&quot;M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])&quot; /&gt; on the returned &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt;.">Este método no se admite actualmente. Recupere el método mediante <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> y llame a <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> en el objeto <see cref="T:System.Reflection.MethodInfo" /> devuelto.</exception>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.IsConstructedGenericMethod" />
    <member name="M:System.Reflection.Emit.MethodBuilder.IsDefined(System.Type,System.Boolean)">
      <summary vsli:raw="Checks if the specified custom attribute type is defined.">Comprueba si se ha definido el tipo de atributo personalizado especificado.</summary>
      <param name="attributeType" vsli:raw="The custom attribute type.">Tipo de atributo personalizado.</param>
      <param name="inherit" vsli:raw="Specifies whether to search this member's inheritance chain to find the custom attributes.">Especifica si se debe buscar la cadena de herencia de este miembro con el fin de encontrar los atributos personalizados.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the specified custom attribute type is defined; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si está definido el tipo de atributo personalizado especificado, en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported. Retrieve the method using &lt;see cref=&quot;M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])&quot; /&gt; and call &lt;see cref=&quot;M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)&quot; /&gt; on the returned &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt;.">Este método no se admite actualmente. Recupere el método mediante <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> y llame a <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> en el objeto <see cref="T:System.Reflection.MethodInfo" /> devuelto.</exception>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod">
      <summary vsli:raw="Gets a value indicating whether the method is a generic method.">Obtiene un valor que indica si el método es un método genérico.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the method is generic; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si el método es genérico; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition">
      <summary vsli:raw="Gets a value indicating whether the current &lt;see cref=&quot;T:System.Reflection.Emit.MethodBuilder&quot; /&gt; object represents the definition of a generic method.">Obtiene un valor que indica si el actual objeto <see cref="T:System.Reflection.Emit.MethodBuilder" /> representa la definición de un método genérico.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current &lt;see cref=&quot;T:System.Reflection.Emit.MethodBuilder&quot; /&gt; object represents the definition of a generic method; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si el actual objeto <see cref="T:System.Reflection.Emit.MethodBuilder" /> representa la definición de un método genérico; en caso contrario, es <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.IsSecurityCritical">
      <summary vsli:raw="Throws a &lt;see cref=&quot;T:System.NotSupportedException&quot; /&gt; in all cases.">Devuelve <see cref="T:System.NotSupportedException" /> en todos los casos</summary>
      <returns vsli:raw="Throws a &lt;see cref=&quot;T:System.NotSupportedException&quot; /&gt; in all cases.">Devuelve <see cref="T:System.NotSupportedException" /> en todos los casos</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases. This property is not supported in dynamic assemblies.">En todos los casos. Esta propiedad no se admite en ensamblados dinámicos.</exception>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.IsSecuritySafeCritical">
      <summary vsli:raw="Throws a &lt;see cref=&quot;T:System.NotSupportedException&quot; /&gt; in all cases.">Devuelve <see cref="T:System.NotSupportedException" /> en todos los casos</summary>
      <returns vsli:raw="Throws a &lt;see cref=&quot;T:System.NotSupportedException&quot; /&gt; in all cases.">Devuelve <see cref="T:System.NotSupportedException" /> en todos los casos</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases. This property is not supported in dynamic assemblies.">En todos los casos. Esta propiedad no se admite en ensamblados dinámicos.</exception>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.IsSecurityTransparent">
      <summary vsli:raw="Throws a &lt;see cref=&quot;T:System.NotSupportedException&quot; /&gt; in all cases.">Devuelve <see cref="T:System.NotSupportedException" /> en todos los casos</summary>
      <returns vsli:raw="Throws a &lt;see cref=&quot;T:System.NotSupportedException&quot; /&gt; in all cases.">Devuelve <see cref="T:System.NotSupportedException" /> en todos los casos</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="In all cases. This property is not supported in dynamic assemblies.">En todos los casos. Esta propiedad no se admite en ensamblados dinámicos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
      <summary vsli:raw="Returns a generic method constructed from the current generic method definition using the specified generic type arguments.">Devuelve un método genérico construido a partir de la actual definición de método genérico utilizando los argumentos de tipo genérico especificados.</summary>
      <param name="typeArguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Type&quot; /&gt; objects that represent the type arguments for the generic method.">Matriz de objetos <see cref="T:System.Type" /> que representan los argumentos de tipo del método genérico.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; representing the generic method constructed from the current generic method definition using the specified generic type arguments.">Un objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método genérico construido a partir de la actual definición de método genérico utilizando los argumentos de tipo genérico especificados.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.MethodHandle">
      <summary vsli:raw="Retrieves the internal handle for the method. Use this handle to access the underlying metadata handle.">Recupera el identificador interno para el método. Utilice este identificador para tener acceso al identificador de metadatos subyacente.</summary>
      <returns vsli:raw="Read-only. The internal handle for the method. Use this handle to access the underlying metadata handle.">Sólo lectura. Identificador interno para el método. Utilice este identificador para tener acceso al identificador de metadatos subyacente.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported. Retrieve the method using &lt;see cref=&quot;M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])&quot; /&gt; and call &lt;see cref=&quot;P:System.Reflection.MethodBase.MethodHandle&quot; /&gt; on the returned &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt;.">Este método no se admite actualmente. Recupere el método mediante <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> y llame a <see cref="P:System.Reflection.MethodBase.MethodHandle" /> en el objeto <see cref="T:System.Reflection.MethodInfo" /> devuelto.</exception>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.Module">
      <summary vsli:raw="Gets the module in which the current method is being defined.">Obtiene el módulo en el que se define el método actual.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Reflection.Module&quot; /&gt; in which the member represented by the current &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; is being defined.">
        <see cref="T:System.Reflection.Module" /> en el que se define el miembro representado por el actual objeto <see cref="T:System.Reflection.MemberInfo" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.Name">
      <summary vsli:raw="Retrieves the name of this method.">Recupera el nombre de este método.</summary>
      <returns vsli:raw="Read-only. Retrieves a string containing the simple name of this method.">Sólo lectura. Recupera una cadena que contiene el nombre sencillo de este método.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.ReflectedType">
      <summary vsli:raw="Retrieves the class that was used in reflection to obtain this object.">Recupera la clase utilizada en la reflexión para obtener este objeto.</summary>
      <returns vsli:raw="Read-only. The type used to obtain this method.">Sólo lectura. Tipo utilizado para obtener este método.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.ReturnParameter">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Reflection.ParameterInfo&quot; /&gt; object that contains information about the return type of the method, such as whether the return type has custom modifiers.">Obtiene un objeto <see cref="T:System.Reflection.ParameterInfo" /> que contiene información sobre el tipo de valor devuelto del método como, por ejemplo, cuando el tipo de valor devuelto tiene modificadores personalizados.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.ParameterInfo&quot; /&gt; object that contains information about the return type.">Un objeto <see cref="T:System.Reflection.ParameterInfo" /> que contiene información sobre el tipo de valor devuelto.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The declaring type has not been created.">No se ha creado el tipo que declara.</exception>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.ReturnType">
      <summary vsli:raw="Gets the return type of the method represented by this &lt;see cref=&quot;T:System.Reflection.Emit.MethodBuilder&quot; /&gt;.">Obtiene el tipo de valor devuelto del método representado por <see cref="T:System.Reflection.Emit.MethodBuilder" />.</summary>
      <returns vsli:raw="The return type of the method.">Tipo devuelto del método.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.ReturnTypeCustomAttributes">
      <summary vsli:raw="Returns the custom attributes of the method's return type.">Devuelve los atributos personalizados del tipo de valor devuelto por el método.</summary>
      <returns vsli:raw="Read-only. The custom attributes of the method's return type.">Sólo lectura. Atributos personalizados del tipo de valor devuelto por el método.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary vsli:raw="Sets a custom attribute using a specified custom attribute blob.">Establece un atributo personalizado mediante un blob de atributo personalizado especificado.</summary>
      <param name="con" vsli:raw="The constructor for the custom attribute.">Constructor para el atributo personalizado.</param>
      <param name="binaryAttribute" vsli:raw="A byte blob representing the attributes.">Blob de bytes que representa los atributos.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;con&quot; /&gt; or &lt;paramref name=&quot;binaryAttribute&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="con" /> o <paramref name="binaryAttribute" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="For the current method, the &lt;see cref=&quot;P:System.Reflection.Emit.MethodBuilder.IsGenericMethod&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;, but the &lt;see cref=&quot;P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition&quot; /&gt; property is &lt;see langword=&quot;false&quot; /&gt;.">Para el método actual, la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> es <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary vsli:raw="Sets a custom attribute using a custom attribute builder.">Establece un atributo personalizado mediante un generador de atributos personalizados.</summary>
      <param name="customBuilder" vsli:raw="An instance of a helper class to describe the custom attribute.">Instancia de una clase del asistente para describir el atributo personalizado.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;customBuilder&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="customBuilder" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="For the current method, the &lt;see cref=&quot;P:System.Reflection.Emit.MethodBuilder.IsGenericMethod&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;, but the &lt;see cref=&quot;P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition&quot; /&gt; property is &lt;see langword=&quot;false&quot; /&gt;.">Para el método actual, la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> es <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
      <summary vsli:raw="Sets the implementation flags for this method.">Establece las marcas de implementación para este método.</summary>
      <param name="attributes" vsli:raw="The implementation flags to set.">Marcas de implementación que hay que establecer.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The containing type was previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; For the current method, the &lt;see cref=&quot;P:System.Reflection.Emit.MethodBuilder.IsGenericMethod&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;, but the &lt;see cref=&quot;P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition&quot; /&gt; property is &lt;see langword=&quot;false&quot; /&gt;.">El tipo contenedor se creó anteriormente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
o bien 
Para el método actual, la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> es <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
      <summary vsli:raw="Sets the number and types of parameters for a method.">Establece el número y los tipos de parámetros de un método.</summary>
      <param name="parameterTypes" vsli:raw="An array of &lt;see cref=&quot;T:System.Type&quot; /&gt; objects representing the parameter types.">Matriz de objetos <see cref="T:System.Type" /> que representan los tipos de parámetros.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The current method is generic, but is not a generic method definition. That is, the &lt;see cref=&quot;P:System.Reflection.Emit.MethodBuilder.IsGenericMethod&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;, but the &lt;see cref=&quot;P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition&quot; /&gt; property is &lt;see langword=&quot;false&quot; /&gt;.">El método actual es genérico, pero no es una definición de método genérico. Es decir, el valor de la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> es <see langword="true" />, pero el valor de la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> es <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
      <summary vsli:raw="Sets the return type of the method.">Establece el tipo de valor devuelto del método.</summary>
      <param name="returnType" vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents the return type of the method.">Objeto <see cref="T:System.Type" /> que representa el tipo de valor devuelto del método.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The current method is generic, but is not a generic method definition. That is, the &lt;see cref=&quot;P:System.Reflection.Emit.MethodBuilder.IsGenericMethod&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;, but the &lt;see cref=&quot;P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition&quot; /&gt; property is &lt;see langword=&quot;false&quot; /&gt;.">El método actual es genérico, pero no es una definición de método genérico. Es decir, el valor de la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> es <see langword="true" />, pero el valor de la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> es <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
      <summary vsli:raw="Sets the method signature, including the return type, the parameter types, and the required and optional custom modifiers of the return type and parameter types.">Establece la firma del método, incluidos el tipo de valor devuelto, los tipos de parámetro así como los modificadores personalizados necesarios y opcionales del tipo de valor devuelto y de los tipos de parámetro.</summary>
      <param name="returnType" vsli:raw="The return type of the method.">Tipo devuelto del método.</param>
      <param name="returnTypeRequiredCustomModifiers" vsli:raw="An array of types representing the required custom modifiers, such as &lt;see cref=&quot;T:System.Runtime.CompilerServices.IsConst&quot; /&gt;, for the return type of the method. If the return type has no required custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt;.">Matriz de los tipos que representan los modificadores personalizados necesarios, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para el tipo devuelto del método. Si el tipo de valor devuelto no tiene ningún modificador personalizado requerido, especifique <see langword="null" />.</param>
      <param name="returnTypeOptionalCustomModifiers" vsli:raw="An array of types representing the optional custom modifiers, such as &lt;see cref=&quot;T:System.Runtime.CompilerServices.IsConst&quot; /&gt;, for the return type of the method. If the return type has no optional custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt;.">Matriz de los tipos que representan los modificadores personalizados opcionales, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para el tipo devuelto del método. Si el tipo de valor devuelto no tiene ningún modificador personalizados opcional, especifique <see langword="null" />.</param>
      <param name="parameterTypes" vsli:raw="The types of the parameters of the method.">Tipos de los parámetros del método.</param>
      <param name="parameterTypeRequiredCustomModifiers" vsli:raw="An array of arrays of types. Each array of types represents the required custom modifiers for the corresponding parameter, such as &lt;see cref=&quot;T:System.Runtime.CompilerServices.IsConst&quot; /&gt;. If a particular parameter has no required custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt; instead of an array of types. If none of the parameters have required custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt; instead of an array of arrays.">Matriz de matrices de tipos. Cada matriz de tipos representa los modificadores personalizados obligatorios para el parámetro correspondiente, como <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un parámetro concreto no tiene modificadores personalizados necesarios, especifique <see langword="null" /> en lugar de una matriz de tipos. Si ninguno de los parámetros tiene modificadores personalizados necesarios, especifique <see langword="null" /> en lugar de una matriz de matrices.</param>
      <param name="parameterTypeOptionalCustomModifiers" vsli:raw="An array of arrays of types. Each array of types represents the optional custom modifiers for the corresponding parameter, such as &lt;see cref=&quot;T:System.Runtime.CompilerServices.IsConst&quot; /&gt;. If a particular parameter has no optional custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt; instead of an array of types. If none of the parameters have optional custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt; instead of an array of arrays.">Matriz de matrices de tipos. Cada matriz de tipos representa los modificadores personalizados opcionales para el parámetro correspondiente, como <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un parámetro concreto no tiene modificadores personalizados opcionales, especifique <see langword="null" /> en lugar de una matriz de tipos. Si ninguno de los parámetros tiene modificadores personalizados opcionales, especifique <see langword="null" /> en lugar de una matriz de matrices.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The current method is generic, but is not a generic method definition. That is, the &lt;see cref=&quot;P:System.Reflection.Emit.MethodBuilder.IsGenericMethod&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;, but the &lt;see cref=&quot;P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition&quot; /&gt; property is &lt;see langword=&quot;false&quot; /&gt;.">El método actual es genérico, pero no es una definición de método genérico. Es decir, el valor de la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> es <see langword="true" />, pero el valor de la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> es <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.ToString">
      <summary vsli:raw="Returns this &lt;see langword=&quot;MethodBuilder&quot; /&gt; instance as a string.">Devuelve la instancia <see langword="MethodBuilder" /> como una cadena.</summary>
      <returns vsli:raw="Returns a string containing the name, attributes, method signature, exceptions, and local signature of this method followed by the current Microsoft intermediate language (MSIL) stream.">Devuelve una cadena con el nombre, atributos, firma del método, excepciones y firma local de este método, seguido de una secuencia actual en Lenguaje intermedio de Microsoft (MSIL).</returns>
    </member>
    <member name="T:System.Reflection.Emit.ModuleBuilder">
      <summary vsli:raw="Defines and represents a module in a dynamic assembly.">Define y representa un módulo en un ensamblado dinámico.</summary>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.Assembly">
      <summary vsli:raw="Gets the dynamic assembly that defined this instance of &lt;see cref=&quot;T:System.Reflection.Emit.ModuleBuilder&quot; /&gt;.">Obtiene el ensamblado dinámico que definió esta instancia de <see cref="T:System.Reflection.Emit.ModuleBuilder" />.</summary>
      <returns vsli:raw="The dynamic assembly that defined the current dynamic module.">Ensamblado dinámico que definió el módulo dinámico actual.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions">
      <summary vsli:raw="Completes the global function definitions and global data definitions for this dynamic module.">Finaliza las definiciones de funciones globales y las definiciones de datos globales para este módulo dinámico.</summary>
      <exception cref="T:System.InvalidOperationException" vsli:raw="This method was called previously.">Se ha llamado anteriormente a este método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
      <summary vsli:raw="Defines an enumeration type that is a value type with a single non-static field called &lt;paramref name=&quot;value__&quot; /&gt; of the specified type.">Define un tipo de enumeración que consiste en un tipo de valor con un único campo no estático denominado <paramref name="value__" /> del tipo especificado.</summary>
      <param name="name" vsli:raw="The full path of the enumeration type. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">Ruta de acceso completa del tipo de enumeración. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="visibility" vsli:raw="The type attributes for the enumeration. The attributes are any bits defined by &lt;see cref=&quot;F:System.Reflection.TypeAttributes.VisibilityMask&quot; /&gt;.">Atributos de tipo de la enumeración. Los atributos son los bits definidos por <see cref="F:System.Reflection.TypeAttributes.VisibilityMask" />.</param>
      <param name="underlyingType" vsli:raw="The underlying type for the enumeration. This must be a built-in integer type.">Tipo subyacente de la enumeración. Debe ser un tipo entero integrado.</param>
      <returns vsli:raw="The defined enumeration.">Enumeración que se ha definido.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="Attributes other than visibility attributes are provided.  &#xA;  &#xA; -or-  &#xA;  &#xA; An enumeration with the given name exists in the parent assembly of this module.  &#xA;  &#xA; -or-  &#xA;  &#xA; The visibility attributes do not match the scope of the enumeration. For example, &lt;see cref=&quot;F:System.Reflection.TypeAttributes.NestedPublic&quot; /&gt; is specified for &lt;paramref name=&quot;visibility&quot; /&gt;, but the enumeration is not a nested type.">Se proporcionan atributos que no son de visibilidad.  
O bien 
Ya existe una enumeración con el nombre especificado en el ensamblado principal de este módulo.  
O bien 
Los atributos de visibilidad no coinciden con el ámbito de la enumeración. Por ejemplo, se especifica <see cref="F:System.Reflection.TypeAttributes.NestedPublic" /> para <paramref name="visibility" /> pero la enumeración no es un tipo anidado.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
      <summary vsli:raw="Defines a global method with the specified name, attributes, calling convention, return type, and parameter types.">Define un método global con el nombre, los atributos, la convención de llamada, el tipo de valor devuelto y los tipos de parámetro especificados.</summary>
      <param name="name" vsli:raw="The name of the method. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">Nombre del método. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="attributes" vsli:raw="The attributes of the method. &lt;paramref name=&quot;attributes&quot; /&gt; must include &lt;see cref=&quot;F:System.Reflection.MethodAttributes.Static&quot; /&gt;.">Atributos del método. <paramref name="attributes" /> debe incluir <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
      <param name="callingConvention" vsli:raw="The calling convention for the method.">Convención de llamada del método.</param>
      <param name="returnType" vsli:raw="The return type of the method.">Tipo devuelto del método.</param>
      <param name="parameterTypes" vsli:raw="The types of the method's parameters.">Tipos de los parámetros del método.</param>
      <returns vsli:raw="The defined global method.">Método global que se ha definido.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The method is not static. That is, &lt;paramref name=&quot;attributes&quot; /&gt; does not include &lt;see cref=&quot;F:System.Reflection.MethodAttributes.Static&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; An element in the &lt;see cref=&quot;T:System.Type&quot; /&gt; array is &lt;see langword=&quot;null&quot; /&gt;.">El método no es estático. Es decir, <paramref name="attributes" /> no incluye <see cref="F:System.Reflection.MethodAttributes.Static" />.  
o bien 
Un elemento de la matriz <see cref="T:System.Type" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions&quot; /&gt; has been previously called.">Se llamó anteriormente a <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
      <summary vsli:raw="Defines a global method with the specified name, attributes, calling convention, return type, custom modifiers for the return type, parameter types, and custom modifiers for the parameter types.">Define un método global con el nombre, los atributos, la convención de llamada, el tipo de valor devuelto, los modificadores personalizados del tipo de valor devuelto, los tipos de parámetro y los modificadores personalizados de los tipos de parámetro que se hayan especificado.</summary>
      <param name="name" vsli:raw="The name of the method. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded null characters.">Nombre del método. <paramref name="name" /> no puede contener caracteres null insertados.</param>
      <param name="attributes" vsli:raw="The attributes of the method. &lt;paramref name=&quot;attributes&quot; /&gt; must include &lt;see cref=&quot;F:System.Reflection.MethodAttributes.Static&quot; /&gt;.">Atributos del método. <paramref name="attributes" /> debe incluir <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
      <param name="callingConvention" vsli:raw="The calling convention for the method.">Convención de llamada del método.</param>
      <param name="returnType" vsli:raw="The return type of the method.">Tipo devuelto del método.</param>
      <param name="requiredReturnTypeCustomModifiers" vsli:raw="An array of types representing the required custom modifiers for the return type, such as &lt;see cref=&quot;T:System.Runtime.CompilerServices.IsConst&quot; /&gt; or &lt;see cref=&quot;T:System.Runtime.CompilerServices.IsBoxed&quot; /&gt;. If the return type has no required custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt;.">Matriz de tipos que representa los modificadores personalizados obligatorios para el tipo de valor devuelto, como <see cref="T:System.Runtime.CompilerServices.IsConst" /> o <see cref="T:System.Runtime.CompilerServices.IsBoxed" />. Si el tipo de valor devuelto no tiene ningún modificador personalizado requerido, especifique <see langword="null" />.</param>
      <param name="optionalReturnTypeCustomModifiers" vsli:raw="An array of types representing the optional custom modifiers for the return type, such as &lt;see cref=&quot;T:System.Runtime.CompilerServices.IsConst&quot; /&gt; or &lt;see cref=&quot;T:System.Runtime.CompilerServices.IsBoxed&quot; /&gt;. If the return type has no optional custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt;.">Matriz de tipos que representa los modificadores personalizados opcionales para el tipo de valor devuelto, como <see cref="T:System.Runtime.CompilerServices.IsConst" /> o <see cref="T:System.Runtime.CompilerServices.IsBoxed" />. Si el tipo de valor devuelto no tiene ningún modificador personalizados opcional, especifique <see langword="null" />.</param>
      <param name="parameterTypes" vsli:raw="The types of the method's parameters.">Tipos de los parámetros del método.</param>
      <param name="requiredParameterTypeCustomModifiers" vsli:raw="An array of arrays of types. Each array of types represents the required custom modifiers for the corresponding parameter of the global method. If a particular argument has no required custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt; instead of an array of types. If the global method has no arguments, or if none of the arguments have required custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt; instead of an array of arrays.">Matriz de matrices de tipos. Cada matriz de tipos representa los modificadores personalizados obligatorios para el parámetro correspondiente del método global. Si un argumento concreto no tiene modificadores personalizados obligatorios, especifique <see langword="null" /> en lugar de una matriz de tipos. Si el método global no tiene ningún argumento, o si ninguno de los argumentos tiene modificadores personalizados obligatorios, especifique <see langword="null" /> en lugar de una matriz de matrices.</param>
      <param name="optionalParameterTypeCustomModifiers" vsli:raw="An array of arrays of types. Each array of types represents the optional custom modifiers for the corresponding parameter. If a particular argument has no optional custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt; instead of an array of types. If the global method has no arguments, or if none of the arguments have optional custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt; instead of an array of arrays.">Matriz de matrices de tipos. Cada matriz de tipos representa los modificadores personalizados opcionales para el parámetro correspondiente. Si un argumento concreto no tiene modificadores personalizados opcionales, especifique <see langword="null" /> en lugar de una matriz de tipos. Si el método global no tiene ningún argumento, o si ninguno de los argumentos tiene modificadores personalizados opcionales, especifique <see langword="null" /> en lugar de una matriz de matrices.</param>
      <returns vsli:raw="The defined global method.">Método global que se ha definido.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The method is not static. That is, &lt;paramref name=&quot;attributes&quot; /&gt; does not include &lt;see cref=&quot;F:System.Reflection.MethodAttributes.Static&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; An element in the &lt;see cref=&quot;T:System.Type&quot; /&gt; array is &lt;see langword=&quot;null&quot; /&gt;.">El método no es estático. Es decir, <paramref name="attributes" /> no incluye <see cref="F:System.Reflection.MethodAttributes.Static" />.  
O bien 
Un elemento de la matriz <see cref="T:System.Type" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &lt;see cref=&quot;M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions&quot; /&gt; method has been previously called.">Se ha llamado previamente al método <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
      <summary vsli:raw="Defines a global method with the specified name, attributes, return type, and parameter types.">Define un método global con el nombre, los atributos, el tipo de valor devuelto y los tipos de parámetro especificados.</summary>
      <param name="name" vsli:raw="The name of the method. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">Nombre del método. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="attributes" vsli:raw="The attributes of the method. &lt;paramref name=&quot;attributes&quot; /&gt; must include &lt;see cref=&quot;F:System.Reflection.MethodAttributes.Static&quot; /&gt;.">Atributos del método. <paramref name="attributes" /> debe incluir <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
      <param name="returnType" vsli:raw="The return type of the method.">Tipo devuelto del método.</param>
      <param name="parameterTypes" vsli:raw="The types of the method's parameters.">Tipos de los parámetros del método.</param>
      <returns vsli:raw="The defined global method.">Método global que se ha definido.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The method is not static. That is, &lt;paramref name=&quot;attributes&quot; /&gt; does not include &lt;see cref=&quot;F:System.Reflection.MethodAttributes.Static&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The length of &lt;paramref name=&quot;name&quot; /&gt; is zero  &#xA;  &#xA; -or-  &#xA;  &#xA; An element in the &lt;see cref=&quot;T:System.Type&quot; /&gt; array is &lt;see langword=&quot;null&quot; /&gt;.">El método no es estático. Es decir, <paramref name="attributes" /> no incluye <see cref="F:System.Reflection.MethodAttributes.Static" />.  
O bien 
La longitud de <paramref name="name" /> es cero. 
o bien 
Un elemento de la matriz <see cref="T:System.Type" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions&quot; /&gt; has been previously called.">Se llamó anteriormente a <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
      <summary vsli:raw="Defines an initialized data field in the .sdata section of the portable executable (PE) file.">Define un campo de datos inicializado en la sección .sdata del archivo portable ejecutable (PE).</summary>
      <param name="name" vsli:raw="The name used to refer to the data. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">El nombre que se usa para hacer referencia a los datos. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="data" vsli:raw="The binary large object (BLOB) of data.">Objeto binario grande (BLOB) de datos.</param>
      <param name="attributes" vsli:raw="The attributes for the field. The default is &lt;see langword=&quot;Static&quot; /&gt;.">Los atributos para este campo. De manera predeterminada, es <see langword="Static" />.</param>
      <returns vsli:raw="A field to reference the data.">Campo para hacer referencia a los datos.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The length of &lt;paramref name=&quot;name&quot; /&gt; is zero.  &#xA;  &#xA; -or-  &#xA;  &#xA; The size of &lt;paramref name=&quot;data&quot; /&gt; is less than or equal to zero or greater than or equal to 0x3f0000.">La longitud de <paramref name="name" /> es cero.  
o bien 
El tamaño de <paramref name="data" /> es menor o igual que cero o mayor o igual que 0x3f0000.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; or &lt;paramref name=&quot;data&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> o <paramref name="data" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions&quot; /&gt; has been previously called.">Se llamó anteriormente a <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
      <summary vsli:raw="Defines a &lt;see langword=&quot;PInvoke&quot; /&gt; method with the specified name, the name of the DLL in which the method is defined, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, and the &lt;see langword=&quot;PInvoke&quot; /&gt; flags.">Define un método <see langword="PInvoke" /> con el nombre especificado, el nombre de la DLL en la que se define el método, los atributos del método, la convención de llamada del método, el tipo de valor devuelto del método, los tipos de los parámetros del método y las marcas de <see langword="PInvoke" />.</summary>
      <param name="name" vsli:raw="The name of the &lt;see langword=&quot;PInvoke&quot; /&gt; method. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">Nombre del método <see langword="PInvoke" />. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="dllName" vsli:raw="The name of the DLL in which the &lt;see langword=&quot;PInvoke&quot; /&gt; method is defined.">Nombre de la DLL en la que está definido el método <see langword="PInvoke" />.</param>
      <param name="attributes" vsli:raw="The attributes of the method.">Atributos del método.</param>
      <param name="callingConvention" vsli:raw="The method's calling convention.">Convención de llamada del método.</param>
      <param name="returnType" vsli:raw="The method's return type.">Tipo de valor devuelto del método.</param>
      <param name="parameterTypes" vsli:raw="The types of the method's parameters.">Tipos de los parámetros del método.</param>
      <param name="nativeCallConv" vsli:raw="The native calling convention.">Convención de llamada nativa.</param>
      <param name="nativeCharSet" vsli:raw="The method's native character set.">Juego de caracteres nativo del método.</param>
      <returns vsli:raw="The defined &lt;see langword=&quot;PInvoke&quot; /&gt; method.">Método <see langword="PInvoke" /> definido.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The method is not static or if the containing type is an interface.  &#xA;  &#xA; -or-  &#xA;  &#xA; The method is abstract.  &#xA;  &#xA; -or-  &#xA;  &#xA; The method was previously defined.">El método no es estático o si el tipo contenedor es una interfaz.  
 o bien  
 Método abstracto.  
 O bien  
 El método se definió anteriormente.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; or &lt;paramref name=&quot;dllName&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> o <paramref name="dllName" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The containing type has been previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;">El tipo contenedor se ha creado previamente con <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
      <summary vsli:raw="Defines a &lt;see langword=&quot;PInvoke&quot; /&gt; method with the specified name, the name of the DLL in which the method is defined, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, and the &lt;see langword=&quot;PInvoke&quot; /&gt; flags.">Define un método <see langword="PInvoke" /> con el nombre especificado, el nombre de la DLL en la que se define el método, los atributos del método, la convención de llamada del método, el tipo de valor devuelto del método, los tipos de los parámetros del método y las marcas de <see langword="PInvoke" />.</summary>
      <param name="name" vsli:raw="The name of the &lt;see langword=&quot;PInvoke&quot; /&gt; method. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">Nombre del método <see langword="PInvoke" />. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="dllName" vsli:raw="The name of the DLL in which the &lt;see langword=&quot;PInvoke&quot; /&gt; method is defined.">Nombre de la DLL en la que está definido el método <see langword="PInvoke" />.</param>
      <param name="entryName" vsli:raw="The name of the entry point in the DLL.">El nombre del punto de entrada del archivo DLL.</param>
      <param name="attributes" vsli:raw="The attributes of the method.">Atributos del método.</param>
      <param name="callingConvention" vsli:raw="The method's calling convention.">Convención de llamada del método.</param>
      <param name="returnType" vsli:raw="The method's return type.">Tipo de valor devuelto del método.</param>
      <param name="parameterTypes" vsli:raw="The types of the method's parameters.">Tipos de los parámetros del método.</param>
      <param name="nativeCallConv" vsli:raw="The native calling convention.">Convención de llamada nativa.</param>
      <param name="nativeCharSet" vsli:raw="The method's native character set.">Juego de caracteres nativo del método.</param>
      <returns vsli:raw="The defined &lt;see langword=&quot;PInvoke&quot; /&gt; method.">Método <see langword="PInvoke" /> definido.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The method is not static or if the containing type is an interface or if the method is abstract of if the method was previously defined.">El método no es estático o si el tipo contenedor es una interfaz o si el método es abstracto o si el método se ha definido previamente.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; or &lt;paramref name=&quot;dllName&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> o <paramref name="dllName" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The containing type has been previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;">El tipo contenedor se ha creado previamente con <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)">
      <summary vsli:raw="Constructs a &lt;see langword=&quot;TypeBuilder&quot; /&gt; for a private type with the specified name in this module.">Crea un <see langword="TypeBuilder" /> para un tipo privado con el nombre especificado en este módulo.</summary>
      <param name="name" vsli:raw="The full path of the type, including the namespace. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">Ruta de acceso completa del tipo, incluido el espacio de nombres. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <returns vsli:raw="A private type with the specified name.">Tipo privado con el nombre especificado.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="A type with the given name exists in the parent assembly of this module.  &#xA;  &#xA; -or-  &#xA;  &#xA; Nested type attributes are set on a type that is not nested.">Existe un tipo con el nombre especificado en el ensamblado principal de este módulo.  
 o bien  
 Los atributos de tipo anidado se han establecido en un tipo que no está anidado.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)">
      <summary vsli:raw="Constructs a &lt;see langword=&quot;TypeBuilder&quot; /&gt; given the type name and the type attributes.">Construye un <see langword="TypeBuilder" /> a partir del nombre de tipo y los atributos de tipo especificados.</summary>
      <param name="name" vsli:raw="The full path of the type. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">Ruta de acceso completa del tipo. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="attr" vsli:raw="The attributes of the defined type.">Atributos del tipo definido.</param>
      <returns vsli:raw="A &lt;see langword=&quot;TypeBuilder&quot; /&gt; created with all of the requested attributes.">Objeto <see langword="TypeBuilder" /> creado con todos los atributos solicitados.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="A type with the given name exists in the parent assembly of this module.  &#xA;  &#xA; -or-  &#xA;  &#xA; Nested type attributes are set on a type that is not nested.">Existe un tipo con el nombre especificado en el ensamblado principal de este módulo.  
 o bien  
 Los atributos de tipo anidado se han establecido en un tipo que no está anidado.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
      <summary vsli:raw="Constructs a &lt;see langword=&quot;TypeBuilder&quot; /&gt; given type name, its attributes, and the type that the defined type extends.">Construye un <see langword="TypeBuilder" /> a partir del nombre de tipo, sus atributos y el tipo que extiende el tipo definido.</summary>
      <param name="name" vsli:raw="The full path of the type. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">Ruta de acceso completa del tipo. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="attr" vsli:raw="The attribute to be associated with the type.">Atributo que se va a asociar al tipo.</param>
      <param name="parent" vsli:raw="The type that the defined type extends.">Tipo que extiende el tipo definido.</param>
      <returns vsli:raw="A &lt;see langword=&quot;TypeBuilder&quot; /&gt; created with all of the requested attributes.">Objeto <see langword="TypeBuilder" /> creado con todos los atributos solicitados.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="A type with the given name exists in the parent assembly of this module.  &#xA;  &#xA; -or-  &#xA;  &#xA; Nested type attributes are set on a type that is not nested.">Existe un tipo con el nombre especificado en el ensamblado principal de este módulo.  
 O bien  
 Los atributos de tipo anidado se han establecido en un tipo que no está anidado.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
      <summary vsli:raw="Constructs a &lt;see langword=&quot;TypeBuilder&quot; /&gt; given the type name, the attributes, the type that the defined type extends, and the total size of the type.">Construye un <see langword="TypeBuilder" /> a partir del nombre de tipo, los atributos, el tipo que extiende el tipo definido y el tamaño total del tipo.</summary>
      <param name="name" vsli:raw="The full path of the type. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">Ruta de acceso completa del tipo. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="attr" vsli:raw="The attributes of the defined type.">Atributos del tipo definido.</param>
      <param name="parent" vsli:raw="The type that the defined type extends.">Tipo que extiende el tipo definido.</param>
      <param name="typesize" vsli:raw="The total size of the type.">Tamaño total del tipo.</param>
      <returns vsli:raw="A &lt;see langword=&quot;TypeBuilder&quot; /&gt; object.">Objeto <see langword="TypeBuilder" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="A type with the given name exists in the parent assembly of this module.  &#xA;  &#xA; -or-  &#xA;  &#xA; Nested type attributes are set on a type that is not nested.">Existe un tipo con el nombre especificado en el ensamblado principal de este módulo.  
 O bien  
 Los atributos de tipo anidado se han establecido en un tipo que no está anidado.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
      <summary vsli:raw="Constructs a &lt;see langword=&quot;TypeBuilder&quot; /&gt; given the type name, the attributes, the type that the defined type extends, and the packing size of the type.">Construye un <see langword="TypeBuilder" /> a partir del nombre de tipo, los atributos, el tipo que extiende el tipo definido y el tamaño de empaquetado del tipo.</summary>
      <param name="name" vsli:raw="The full path of the type. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">Ruta de acceso completa del tipo. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="attr" vsli:raw="The attributes of the defined type.">Atributos del tipo definido.</param>
      <param name="parent" vsli:raw="The type that the defined type extends.">Tipo que extiende el tipo definido.</param>
      <param name="packsize" vsli:raw="The packing size of the type.">Tamaño de empaquetado del tipo.</param>
      <returns vsli:raw="A &lt;see langword=&quot;TypeBuilder&quot; /&gt; object.">Objeto <see langword="TypeBuilder" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="A type with the given name exists in the parent assembly of this module.  &#xA;  &#xA; -or-  &#xA;  &#xA; Nested type attributes are set on a type that is not nested.">Existe un tipo con el nombre especificado en el ensamblado principal de este módulo.  
 O bien  
 Los atributos de tipo anidado se han establecido en un tipo que no está anidado.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
      <summary vsli:raw="Constructs a &lt;see langword=&quot;TypeBuilder&quot; /&gt; given the type name, attributes, the type that the defined type extends, the packing size of the defined type, and the total size of the defined type.">Construye un <see langword="TypeBuilder" /> a partir del nombre de tipo, los atributos, el tipo que extiende el tipo definido, el tamaño de empaquetado del tipo definido y el tamaño total del tipo definido.</summary>
      <param name="name" vsli:raw="The full path of the type. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">Ruta de acceso completa del tipo. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="attr" vsli:raw="The attributes of the defined type.">Atributos del tipo definido.</param>
      <param name="parent" vsli:raw="The type that the defined type extends.">Tipo que extiende el tipo definido.</param>
      <param name="packingSize" vsli:raw="The packing size of the type.">Tamaño de empaquetado del tipo.</param>
      <param name="typesize" vsli:raw="The total size of the type.">Tamaño total del tipo.</param>
      <returns vsli:raw="A &lt;see langword=&quot;TypeBuilder&quot; /&gt; created with all of the requested attributes.">Objeto <see langword="TypeBuilder" /> creado con todos los atributos solicitados.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="A type with the given name exists in the parent assembly of this module.  &#xA;  &#xA; -or-  &#xA;  &#xA; Nested type attributes are set on a type that is not nested.">Existe un tipo con el nombre especificado en el ensamblado principal de este módulo.  
 o bien  
 Los atributos de tipo anidado se han establecido en un tipo que no está anidado.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
      <summary vsli:raw="Constructs a &lt;see langword=&quot;TypeBuilder&quot; /&gt; given the type name, attributes, the type that the defined type extends, and the interfaces that the defined type implements.">Construye un <see langword="TypeBuilder" /> a partir del nombre de tipo, los atributos, el tipo que extiende el tipo definido y las interfaces que implementa el tipo definido.</summary>
      <param name="name" vsli:raw="The full path of the type. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">Ruta de acceso completa del tipo. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="attr" vsli:raw="The attributes to be associated with the type.">Atributos que se van a asociar al tipo.</param>
      <param name="parent" vsli:raw="The type that the defined type extends.">Tipo que extiende el tipo definido.</param>
      <param name="interfaces" vsli:raw="The list of interfaces that the type implements.">Lista de interfaces que implementa el tipo.</param>
      <returns vsli:raw="A &lt;see langword=&quot;TypeBuilder&quot; /&gt; created with all of the requested attributes.">Objeto <see langword="TypeBuilder" /> creado con todos los atributos solicitados.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="A type with the given name exists in the parent assembly of this module.  &#xA;  &#xA; -or-  &#xA;  &#xA; Nested type attributes are set on a type that is not nested.">Existe un tipo con el nombre especificado en el ensamblado principal de este módulo.  
 O bien  
 Los atributos de tipo anidado se han establecido en un tipo que no está anidado.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
      <summary vsli:raw="Defines an uninitialized data field in the .sdata section of the portable executable (PE) file.">Define un campo de datos sin inicializar en la sección .sdata del archivo portable ejecutable (PE).</summary>
      <param name="name" vsli:raw="The name used to refer to the data. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">El nombre que se usa para hacer referencia a los datos. <paramref name="name" /> no puede contener valores null insertados.</param>
      <param name="size" vsli:raw="The size of the data field.">Tamaño del campo de datos.</param>
      <param name="attributes" vsli:raw="The attributes for the field.">Los atributos para este campo.</param>
      <returns vsli:raw="A field to reference the data.">Campo para hacer referencia a los datos.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The length of &lt;paramref name=&quot;name&quot; /&gt; is zero.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;size&quot; /&gt; is less than or equal to zero, or greater than or equal to 0x003f0000.">La longitud de <paramref name="name" /> es cero.  
O bien 
 <paramref name="size" /> es menor o igual que cero, o mayor o igual que 0x003f0000.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions&quot; /&gt; has been previously called.">Se llamó anteriormente a <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.Equals(System.Object)">
      <summary vsli:raw="Returns a value that indicates whether this instance is equal to the specified object.">Devuelve un valor que indica si esta instancia es igual que el objeto especificado.</summary>
      <param name="obj" vsli:raw="An object to compare with this instance, or &lt;see langword=&quot;null&quot; /&gt;.">Objeto que se va a comparar con esta instancia o <see langword="null" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;obj&quot; /&gt; equals the type and value of this instance; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si <paramref name="obj" /> es igual al tipo y valor de esta instancia; en caso contrario, es <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.FullyQualifiedName">
      <summary vsli:raw="Gets a &lt;see langword=&quot;String&quot; /&gt; representing the fully qualified name and path to this module.">Obtiene un valor de tipo <see langword="String" /> que representa el nombre completo de este módulo y su ruta de acceso.</summary>
      <returns vsli:raw="The fully qualified module name.">Nombre completo del módulo.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
      <summary vsli:raw="Returns the named method on an array class.">Devuelve el método con nombre en una clase de matriz.</summary>
      <param name="arrayClass" vsli:raw="An array class.">Clase de matriz.</param>
      <param name="methodName" vsli:raw="The name of a method on the array class.">Nombre de un método en la clase de matriz.</param>
      <param name="callingConvention" vsli:raw="The method's calling convention.">Convención de llamada del método.</param>
      <param name="returnType" vsli:raw="The return type of the method.">Tipo devuelto del método.</param>
      <param name="parameterTypes" vsli:raw="The types of the method's parameters.">Tipos de los parámetros del método.</param>
      <returns vsli:raw="The named method on an array class.">Método con nombre en una clase de matriz.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;arrayClass&quot; /&gt; is not an array.">
        <paramref name="arrayClass" /> no es una matriz.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;arrayClass&quot; /&gt; or &lt;paramref name=&quot;methodName&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="arrayClass" /> o <paramref name="methodName" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Boolean)">
      <summary vsli:raw="Returns all the custom attributes that have been applied to the current &lt;see cref=&quot;T:System.Reflection.Emit.ModuleBuilder&quot; /&gt;.">Devuelve todos los atributos personalizados que se aplicaron al <see cref="T:System.Reflection.Emit.ModuleBuilder" /> actual.</summary>
      <param name="inherit" vsli:raw="This argument is ignored for objects of this type.">Se omite este argumento para los objetos de este tipo.</param>
      <returns vsli:raw="An array that contains the custom attributes; the array is empty if there are no attributes.">Matriz que contiene los atributos personalizados; la matriz está vacía si no hay ningún atributo.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary vsli:raw="Returns all the custom attributes that have been applied to the current &lt;see cref=&quot;T:System.Reflection.Emit.ModuleBuilder&quot; /&gt;, and that derive from a specified attribute type.">Devuelve todos los atributos personalizados que se aplicaron al <see cref="T:System.Reflection.Emit.ModuleBuilder" /> actual y que derivan de un tipo de atributo especificado.</summary>
      <param name="attributeType" vsli:raw="The base type from which attributes derive.">Tipo base del que derivan los atributos.</param>
      <param name="inherit" vsli:raw="This argument is ignored for objects of this type.">Se omite este argumento para los objetos de este tipo.</param>
      <returns vsli:raw="An array that contains the custom attributes that are derived, at any level, from &lt;paramref name=&quot;attributeType&quot; /&gt;; the array is empty if there are no such attributes.">Matriz que contiene los atributos personalizados que se derivan, en cualquier nivel, de <paramref name="attributeType" />; la matriz está vacía si no hay ningún atributo.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;attributeType&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="attributeType" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;attributeType&quot; /&gt; is not a &lt;see cref=&quot;T:System.Type&quot; /&gt; object supplied by the runtime. For example, &lt;paramref name=&quot;attributeType&quot; /&gt; is a &lt;see cref=&quot;T:System.Reflection.Emit.TypeBuilder&quot; /&gt; object.">
        <paramref name="attributeType" /> no es un objeto <see cref="T:System.Type" /> proporcionado por el tiempo de ejecución. Por ejemplo, <paramref name="attributeType" /> es un objeto <see cref="T:System.Reflection.Emit.TypeBuilder" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributesData">
      <summary vsli:raw="Returns information about the attributes that have been applied to the current &lt;see cref=&quot;T:System.Reflection.Emit.ModuleBuilder&quot; /&gt;, expressed as &lt;see cref=&quot;T:System.Reflection.CustomAttributeData&quot; /&gt; objects.">Devuelve información sobre los atributos que se han aplicado al <see cref="T:System.Reflection.Emit.ModuleBuilder" /> actual, expresado como objetos <see cref="T:System.Reflection.CustomAttributeData" />.</summary>
      <returns vsli:raw="A generic list of &lt;see cref=&quot;T:System.Reflection.CustomAttributeData&quot; /&gt; objects representing data about the attributes that have been applied to the current module.">Lista genérica de objetos <see cref="T:System.Reflection.CustomAttributeData" /> que representan datos sobre los atributos que se aplicaron al módulo actual.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetField(System.String,System.Reflection.BindingFlags)">
      <summary vsli:raw="Returns a module-level field, defined in the .sdata region of the portable executable (PE) file, that has the specified name and binding attributes.">Devuelve un campo de nivel de módulo, definido en la región .sdata del archivo portable ejecutable (PE), que tiene el nombre y los atributos de enlace especificados.</summary>
      <param name="name" vsli:raw="The field name.">Nombre de campo.</param>
      <param name="bindingAttr" vsli:raw="A combination of the &lt;see langword=&quot;BindingFlags&quot; /&gt; bit flags used to control the search.">Combinación de las marcas de bits <see langword="BindingFlags" /> utilizadas para controlar la búsqueda.</param>
      <returns vsli:raw="A field that has the specified name and binding attributes, or &lt;see langword=&quot;null&quot; /&gt; if the field does not exist.">Campo que tiene el nombre y los atributos de enlace especificados, o <see langword="null" /> si el campo no existe.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;name&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">El parámetro <paramref name="name" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetFields(System.Reflection.BindingFlags)">
      <summary vsli:raw="Returns all fields defined in the .sdata region of the portable executable (PE) file that match the specified binding flags.">Devuelve todos los campos definidos en la región .sdata del archivo portable ejecutable (PE) que coinciden con las marcas de enlace especificadas.</summary>
      <param name="bindingFlags" vsli:raw="A combination of the &lt;see langword=&quot;BindingFlags&quot; /&gt; bit flags used to control the search.">Combinación de las marcas de bits <see langword="BindingFlags" /> utilizadas para controlar la búsqueda.</param>
      <returns vsli:raw="An array of fields that match the specified flags; the array is empty if no such fields exist.">Matriz de campos que coinciden con las marcas especificadas; la matriz está vacía si no existe ninguno de esos campos.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;name&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">El parámetro <paramref name="name" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetHashCode">
      <summary vsli:raw="Returns the hash code for this instance.">Devuelve el código hash de esta instancia.</summary>
      <returns vsli:raw="A 32-bit signed integer hash code.">Código hash de un entero de 32 bits con signo.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetMethods(System.Reflection.BindingFlags)">
      <summary vsli:raw="Returns all the methods that have been defined at the module level for the current &lt;see cref=&quot;T:System.Reflection.Emit.ModuleBuilder&quot; /&gt;, and that match the specified binding flags.">Devuelve todos los métodos definidos en el nivel de módulo para la clase <see cref="T:System.Reflection.Emit.ModuleBuilder" /> actual y que coinciden con las marcas de enlace especificadas.</summary>
      <param name="bindingFlags" vsli:raw="A combination of &lt;see langword=&quot;BindingFlags&quot; /&gt; bit flags used to control the search.">Combinación de marcas de bits <see langword="BindingFlags" /> utilizadas para controlar la búsqueda.</param>
      <returns vsli:raw="An array that contains all the module-level methods that match &lt;paramref name=&quot;bindingFlags&quot; /&gt;.">Matriz que contiene todos los métodos de nivel de módulo que coinciden con <paramref name="bindingFlags" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)">
      <summary vsli:raw="Gets a pair of values indicating the nature of the code in a module and the platform targeted by the module.">Obtiene un par de valores que indican la naturaleza del código en un módulo y la plataforma de destino del módulo.</summary>
      <param name="peKind" vsli:raw="When this method returns, a combination of the &lt;see cref=&quot;T:System.Reflection.PortableExecutableKinds&quot; /&gt; values indicating the nature of the code in the module.">El resultado de este método contiene una combinación de los valores <see cref="T:System.Reflection.PortableExecutableKinds" /> que indican la naturaleza del código en el módulo.</param>
      <param name="machine" vsli:raw="When this method returns, one of the &lt;see cref=&quot;T:System.Reflection.ImageFileMachine&quot; /&gt; values indicating the platform targeted by the module.">El resultado de este método contiene uno de los valores de <see cref="T:System.Reflection.ImageFileMachine" /> que indican la plataforma destino del módulo.</param>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String)">
      <summary vsli:raw="Gets the named type defined in the module.">Obtiene el tipo con nombre definido en el módulo.</summary>
      <param name="className" vsli:raw="The name of the &lt;see cref=&quot;T:System.Type&quot; /&gt; to get.">Nombre del objeto <see cref="T:System.Type" /> que se va a obtener.</param>
      <returns vsli:raw="The requested type, if the type is defined in this module; otherwise, &lt;see langword=&quot;null&quot; /&gt;.">Devuelve el tipo solicitado si está definido en este módulo; de lo contrario, devuelve <see langword="null" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="Length of &lt;paramref name=&quot;className&quot; /&gt; is zero or is greater than 1023.">La longitud de <paramref name="className" /> es cero o es mayor que 1023.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;className&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="className" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Security.SecurityException" vsli:raw="The requested &lt;see cref=&quot;T:System.Type&quot; /&gt; is non-public and the caller does not have &lt;see cref=&quot;T:System.Security.Permissions.ReflectionPermission&quot; /&gt; to reflect non-public objects outside the current assembly.">El <see cref="T:System.Type" /> solicitado no es público y el llamador no tiene <see cref="T:System.Security.Permissions.ReflectionPermission" /> para reflejar objetos no públicos fuera del ensamblado actual.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException" vsli:raw="A class initializer is invoked and throws an exception.">Se invoca un inicializador de clase y genera una excepción.</exception>
      <exception cref="T:System.TypeLoadException" vsli:raw="An error is encountered while loading the &lt;see cref=&quot;T:System.Type&quot; /&gt;.">Se ha producido un error al cargar <see cref="T:System.Type" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)">
      <summary vsli:raw="Gets the named type defined in the module, optionally ignoring the case of the type name.">Obtiene el tipo con nombre definido en el módulo, con la opción de pasar por alto el uso de mayúsculas y minúsculas en el nombre de tipo.</summary>
      <param name="className" vsli:raw="The name of the &lt;see cref=&quot;T:System.Type&quot; /&gt; to get.">Nombre del objeto <see cref="T:System.Type" /> que se va a obtener.</param>
      <param name="ignoreCase" vsli:raw="If &lt;see langword=&quot;true&quot; /&gt;, the search is case-insensitive. If &lt;see langword=&quot;false&quot; /&gt;, the search is case-sensitive.">Si <see langword="true" />, la búsqueda no distingue entre mayúsculas y minúsculas. Si <see langword="false" />, la búsqueda distingue entre mayúsculas y minúsculas.</param>
      <returns vsli:raw="The requested type, if the type is defined in this module; otherwise, &lt;see langword=&quot;null&quot; /&gt;.">Devuelve el tipo solicitado si está definido en este módulo; de lo contrario, devuelve <see langword="null" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="Length of &lt;paramref name=&quot;className&quot; /&gt; is zero or is greater than 1023.">La longitud de <paramref name="className" /> es cero o es mayor que 1023.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;className&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="className" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Security.SecurityException" vsli:raw="The requested &lt;see cref=&quot;T:System.Type&quot; /&gt; is non-public and the caller does not have &lt;see cref=&quot;T:System.Security.Permissions.ReflectionPermission&quot; /&gt; to reflect non-public objects outside the current assembly.">El <see cref="T:System.Type" /> solicitado no es público y el llamador no tiene <see cref="T:System.Security.Permissions.ReflectionPermission" /> para reflejar objetos no públicos fuera del ensamblado actual.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException" vsli:raw="A class initializer is invoked and throws an exception.">Se invoca un inicializador de clase y genera una excepción.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
      <summary vsli:raw="Gets the named type defined in the module, optionally ignoring the case of the type name. Optionally throws an exception if the type is not found.">Obtiene el tipo con nombre definido en el módulo, con la opción de pasar por alto el uso de mayúsculas y minúsculas en el nombre de tipo. De manera opcional, se produce una excepción si no se encuentra el tipo.</summary>
      <param name="className" vsli:raw="The name of the &lt;see cref=&quot;T:System.Type&quot; /&gt; to get.">Nombre del objeto <see cref="T:System.Type" /> que se va a obtener.</param>
      <param name="throwOnError" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to throw an exception if the type cannot be found; &lt;see langword=&quot;false&quot; /&gt; to return &lt;see langword=&quot;null&quot; /&gt;.">Es <see langword="true" /> para producir una excepción si no se puede encontrar el tipo; es <see langword="false" /> para devolver <see langword="null" />.</param>
      <param name="ignoreCase" vsli:raw="If &lt;see langword=&quot;true&quot; /&gt;, the search is case-insensitive. If &lt;see langword=&quot;false&quot; /&gt;, the search is case-sensitive.">Si <see langword="true" />, la búsqueda no distingue entre mayúsculas y minúsculas. Si <see langword="false" />, la búsqueda distingue entre mayúsculas y minúsculas.</param>
      <returns vsli:raw="The specified type, if the type is declared in this module; otherwise, &lt;see langword=&quot;null&quot; /&gt;.">Devuelve el tipo especificado si está declarado en este módulo; de lo contrario, devuelve <see langword="null" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="Length of &lt;paramref name=&quot;className&quot; /&gt; is zero or is greater than 1023.">La longitud de <paramref name="className" /> es cero o es mayor que 1023.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;className&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="className" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Security.SecurityException" vsli:raw="The requested &lt;see cref=&quot;T:System.Type&quot; /&gt; is non-public and the caller does not have &lt;see cref=&quot;T:System.Security.Permissions.ReflectionPermission&quot; /&gt; to reflect non-public objects outside the current assembly.">El <see cref="T:System.Type" /> solicitado no es público y el llamador no tiene <see cref="T:System.Security.Permissions.ReflectionPermission" /> para reflejar objetos no públicos fuera del ensamblado actual.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException" vsli:raw="A class initializer is invoked and throws an exception.">Se invoca un inicializador de clase y genera una excepción.</exception>
      <exception cref="T:System.TypeLoadException" vsli:raw="&lt;paramref name=&quot;throwOnError&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt; and the specified type is not found.">El valor de <paramref name="throwOnError" /> es <see langword="true" /> y no se encuentra el tipo especificado.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetTypes">
      <summary vsli:raw="Returns all the classes defined within this module.">Devuelve todas las clases definidas en este módulo.</summary>
      <returns vsli:raw="An array that contains the types defined within the module that is reflected by this instance.">Matriz que contiene los tipos definidos en el módulo reflejado por esta instancia.</returns>
      <exception cref="T:System.Reflection.ReflectionTypeLoadException" vsli:raw="One or more classes in a module could not be loaded.">No se pudieron cargar una o más clases en un módulo.</exception>
      <exception cref="T:System.Security.SecurityException" vsli:raw="The caller does not have the required permission.">El llamador no dispone del permiso requerido.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.IsDefined(System.Type,System.Boolean)">
      <summary vsli:raw="Returns a value that indicates whether the specified attribute type has been applied to this module.">Devuelve un valor que indica si el tipo de atributo especificado se ha aplicado a este módulo.</summary>
      <param name="attributeType" vsli:raw="The type of custom attribute to test for.">Tipo de atributo personalizado que se va a probar.</param>
      <param name="inherit" vsli:raw="This argument is ignored for objects of this type.">Se omite este argumento para los objetos de este tipo.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if one or more instances of &lt;paramref name=&quot;attributeType&quot; /&gt; have been applied to this module; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si se han aplicado una o varias instancias de <paramref name="attributeType" /> a este módulo; de lo contrario, es <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;attributeType&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="attributeType" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;attributeType&quot; /&gt; is not a &lt;see cref=&quot;T:System.Type&quot; /&gt; object supplied by the runtime. For example, &lt;paramref name=&quot;attributeType&quot; /&gt; is a &lt;see cref=&quot;T:System.Reflection.Emit.TypeBuilder&quot; /&gt; object.">
        <paramref name="attributeType" /> no es un objeto <see cref="T:System.Type" /> proporcionado por el tiempo de ejecución. Por ejemplo, <paramref name="attributeType" /> es un objeto <see cref="T:System.Reflection.Emit.TypeBuilder" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.IsResource">
      <summary vsli:raw="Gets a value indicating whether the object is a resource.">Obtiene un valor que indica si el objeto es un recurso.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the object is a resource; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si el objeto es un recurso; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.MDStreamVersion">
      <summary vsli:raw="Gets the metadata stream version.">Obtiene la versión del flujo de metadatos.</summary>
      <returns vsli:raw="A 32-bit integer representing the metadata stream version. The high-order two bytes represent the major version number, and the low-order two bytes represent the minor version number.">Entero de 32 bits que representa la versión del flujo de metadatos. Los dos bytes de orden superior representan el número de versión principal, mientras que los dos bytes de orden inferior representan el número de versión secundaria.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.MetadataToken">
      <summary vsli:raw="Gets a token that identifies the current dynamic module in metadata.">Obtiene un token que identifica el módulo dinámico actual en los metadatos.</summary>
      <returns vsli:raw="An integer token that identifies the current module in metadata.">Token entero que identifica el módulo actual en los metadatos.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.ModuleVersionId">
      <summary vsli:raw="Gets a universally unique identifier (UUID) that can be used to distinguish between two versions of a module.">Obtiene un identificador único universal (UUID) que puede utilizarse para distinguir entre dos versiones de un módulo.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Guid&quot; /&gt; that can be used to distinguish between two versions of a module.">
        <see cref="T:System.Guid" /> que se puede utilizar para distinguir entre dos versiones de un módulo.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.Name">
      <summary vsli:raw="A string that indicates that this is an in-memory module.">Cadena que indica que se trata de un módulo en memoria.</summary>
      <returns vsli:raw="Text that indicates that this is an in-memory module.">Texto que indica que se trata de un módulo en memoria.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
      <summary vsli:raw="Returns the field identified by the specified metadata token, in the context defined by the specified generic type parameters.">Devuelve el campo identificado por el token de metadatos especificado, en el contexto definido por los parámetros de tipo genérico especificados.</summary>
      <param name="metadataToken" vsli:raw="A metadata token that identifies a field in the module.">Token de metadatos que identifica un campo del módulo.</param>
      <param name="genericTypeArguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Type&quot; /&gt; objects representing the generic type arguments of the type where the token is in scope, or &lt;see langword=&quot;null&quot; /&gt; if that type is not generic.">Matriz de objetos <see cref="T:System.Type" /> que representan los argumentos de tipo genérico del tipo en cuyo ámbito se encuentra el token; o es <see langword="null" /> si dicho tipo no es genérico.</param>
      <param name="genericMethodArguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Type&quot; /&gt; objects representing the generic type arguments of the method where the token is in scope, or &lt;see langword=&quot;null&quot; /&gt; if that method is not generic.">Matriz de objetos <see cref="T:System.Type" /> que representan los argumentos de tipo genérico del método en cuyo ámbito se encuentra el token; o es <see langword="null" /> si dicho método no es genérico.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.FieldInfo&quot; /&gt; object representing the field that is identified by the specified metadata token.">Objeto <see cref="T:System.Reflection.FieldInfo" /> que representa el campo identificado por el token de metadatos especificado.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;metadataToken&quot; /&gt; is not a token for a field in the scope of the current module.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;metadataToken&quot; /&gt; identifies a field whose parent &lt;see langword=&quot;TypeSpec&quot; /&gt; has a signature containing element type &lt;see langword=&quot;var&quot; /&gt; (a type parameter of a generic type) or &lt;see langword=&quot;mvar&quot; /&gt; (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of &lt;paramref name=&quot;genericTypeArguments&quot; /&gt; and &lt;paramref name=&quot;genericMethodArguments&quot; /&gt;.">
        <paramref name="metadataToken" /> no es un token válido para un campo en el ámbito del módulo actual.  
o bien 
 <paramref name="metadataToken" /> identifica un campo cuyo <see langword="TypeSpec" /> primario tiene una firma que contiene el tipo de elemento <see langword="var" /> (un parámetro de tipo de un tipo genérico) o <see langword="mvar" /> (un parámetro de tipo de un método genérico) y no se proporcionaron los argumentos de tipo genérico necesarios para uno o ambos parámetros <paramref name="genericTypeArguments" /> y <paramref name="genericMethodArguments" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;metadataToken&quot; /&gt; is not a valid token in the scope of the current module.">
        <paramref name="metadataToken" /> no es un token válido en el ámbito del módulo actual.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
      <summary vsli:raw="Returns the type or member identified by the specified metadata token, in the context defined by the specified generic type parameters.">Devuelve el tipo o miembro identificado por el token de metadatos especificado, en el contexto definido por los parámetros de tipo genérico especificados.</summary>
      <param name="metadataToken" vsli:raw="A metadata token that identifies a type or member in the module.">Token de metadatos que identifica un tipo o integrante del módulo.</param>
      <param name="genericTypeArguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Type&quot; /&gt; objects representing the generic type arguments of the type where the token is in scope, or &lt;see langword=&quot;null&quot; /&gt; if that type is not generic.">Matriz de objetos <see cref="T:System.Type" /> que representan los argumentos de tipo genérico del tipo en cuyo ámbito se encuentra el token; o es <see langword="null" /> si dicho tipo no es genérico.</param>
      <param name="genericMethodArguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Type&quot; /&gt; objects representing the generic type arguments of the method where the token is in scope, or &lt;see langword=&quot;null&quot; /&gt; if that method is not generic.">Matriz de objetos <see cref="T:System.Type" /> que representan los argumentos de tipo genérico del método en cuyo ámbito se encuentra el token; o es <see langword="null" /> si dicho método no es genérico.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; object representing the type or member that is identified by the specified metadata token.">Objeto <see cref="T:System.Reflection.MemberInfo" /> que representa el tipo o integrante identificado por el token de metadatos especificado.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;metadataToken&quot; /&gt; is not a token for a type or member in the scope of the current module.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;metadataToken&quot; /&gt; is a &lt;see langword=&quot;MethodSpec&quot; /&gt; or &lt;see langword=&quot;TypeSpec&quot; /&gt; whose signature contains element type &lt;see langword=&quot;var&quot; /&gt; (a type parameter of a generic type) or &lt;see langword=&quot;mvar&quot; /&gt; (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of &lt;paramref name=&quot;genericTypeArguments&quot; /&gt; and &lt;paramref name=&quot;genericMethodArguments&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;metadataToken&quot; /&gt; identifies a property or event.">
        <paramref name="metadataToken" /> no es un token para un tipo o integrante en el ámbito del módulo actual.  
o bien 
 <paramref name="metadataToken" /> es un <see langword="MethodSpec" /> o <see langword="TypeSpec" /> cuya firma contiene el tipo de elemento <see langword="var" /> (un parámetro de tipo de un tipo genérico) o <see langword="mvar" /> (un parámetro de tipo de un método genérico) y no se proporcionaron los argumentos de tipo genérico necesarios para uno o ambos parámetros <paramref name="genericTypeArguments" /> y <paramref name="genericMethodArguments" />.  
o bien 
 <paramref name="metadataToken" /> identifica una propiedad o evento.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;metadataToken&quot; /&gt; is not a valid token in the scope of the current module.">
        <paramref name="metadataToken" /> no es un token válido en el ámbito del módulo actual.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
      <summary vsli:raw="Returns the method or constructor identified by the specified metadata token, in the context defined by the specified generic type parameters.">Devuelve el método o constructor identificado por el token de metadatos especificado, en el contexto definido por los parámetros de tipo genérico especificados.</summary>
      <param name="metadataToken" vsli:raw="A metadata token that identifies a method or constructor in the module.">Token de metadatos que identifica un método o constructor en el módulo.</param>
      <param name="genericTypeArguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Type&quot; /&gt; objects representing the generic type arguments of the type where the token is in scope, or &lt;see langword=&quot;null&quot; /&gt; if that type is not generic.">Matriz de objetos <see cref="T:System.Type" /> que representan los argumentos de tipo genérico del tipo en cuyo ámbito se encuentra el token; o es <see langword="null" /> si dicho tipo no es genérico.</param>
      <param name="genericMethodArguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Type&quot; /&gt; objects representing the generic type arguments of the method where the token is in scope, or &lt;see langword=&quot;null&quot; /&gt; if that method is not generic.">Matriz de objetos <see cref="T:System.Type" /> que representan los argumentos de tipo genérico del método en cuyo ámbito se encuentra el token; o es <see langword="null" /> si dicho método no es genérico.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodBase&quot; /&gt; object representing the method that is identified by the specified metadata token.">Objeto <see cref="T:System.Reflection.MethodBase" /> que representa el método identificado por el token de metadatos especificado.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;metadataToken&quot; /&gt; is not a token for a method or constructor in the scope of the current module.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;metadataToken&quot; /&gt; is a &lt;see langword=&quot;MethodSpec&quot; /&gt; whose signature contains element type &lt;see langword=&quot;var&quot; /&gt; (a type parameter of a generic type) or &lt;see langword=&quot;mvar&quot; /&gt; (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of &lt;paramref name=&quot;genericTypeArguments&quot; /&gt; and &lt;paramref name=&quot;genericMethodArguments&quot; /&gt;.">
        <paramref name="metadataToken" /> no es un token para un método o constructor en el ámbito del módulo actual.  
O bien 
 <paramref name="metadataToken" /> es un <see langword="MethodSpec" /> cuya firma contiene el tipo de elemento <see langword="var" /> (un parámetro de tipo de un tipo genérico) o <see langword="mvar" /> (un parámetro de tipo de un método genérico) y no se proporcionaron los argumentos de tipo genérico necesarios para uno o ambos parámetros <paramref name="genericTypeArguments" /> y <paramref name="genericMethodArguments" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;metadataToken&quot; /&gt; is not a valid token in the scope of the current module.">
        <paramref name="metadataToken" /> no es un token válido en el ámbito del módulo actual.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.ResolveSignature(System.Int32)">
      <summary vsli:raw="Returns the signature blob identified by a metadata token.">Devuelve el objeto binario de firma identificado por un token de metadatos.</summary>
      <param name="metadataToken" vsli:raw="A metadata token that identifies a signature in the module.">Token de metadatos que identifica una firma en el módulo.</param>
      <returns vsli:raw="An array of bytes representing the signature blob.">Una matriz de bytes que representan el objeto binario de firma.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;metadataToken&quot; /&gt; is not a valid &lt;see langword=&quot;MemberRef&quot; /&gt;, &lt;see langword=&quot;MethodDef&quot; /&gt;, &lt;see langword=&quot;TypeSpec&quot; /&gt;, signature, or &lt;see langword=&quot;FieldDef&quot; /&gt; token in the scope of the current module.">
        <paramref name="metadataToken" /> no es un token <see langword="MemberRef" />, <see langword="MethodDef" />, <see langword="TypeSpec" />, de firma o <see langword="FieldDef" /> válido en el ámbito del módulo actual.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;metadataToken&quot; /&gt; is not a valid token in the scope of the current module.">
        <paramref name="metadataToken" /> no es un token válido en el ámbito del módulo actual.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.ResolveString(System.Int32)">
      <summary vsli:raw="Returns the string identified by the specified metadata token.">Devuelve la cadena identificada por el token de metadatos especificado.</summary>
      <param name="metadataToken" vsli:raw="A metadata token that identifies a string in the string heap of the module.">Token de metadatos que identifica una cadena en el montón de cadena del módulo.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.String&quot; /&gt; containing a string value from the metadata string heap.">
        <see cref="T:System.String" /> que contiene un valor de cadena del montón de cadena de metadatos.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;metadataToken&quot; /&gt; is not a token for a string in the scope of the current module.">
        <paramref name="metadataToken" /> no es un token de una cadena en el ámbito del módulo actual.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;metadataToken&quot; /&gt; is not a valid token in the scope of the current module.">
        <paramref name="metadataToken" /> no es un token válido en el ámbito del módulo actual.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
      <summary vsli:raw="Returns the type identified by the specified metadata token, in the context defined by the specified generic type parameters.">Devuelve el campo identificado por el token de metadatos especificado, en el contexto definido por los parámetros de tipo genérico especificados.</summary>
      <param name="metadataToken" vsli:raw="A metadata token that identifies a type in the module.">Token de metadatos que identifica un tipo en el módulo.</param>
      <param name="genericTypeArguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Type&quot; /&gt; objects representing the generic type arguments of the type where the token is in scope, or &lt;see langword=&quot;null&quot; /&gt; if that type is not generic.">Matriz de objetos <see cref="T:System.Type" /> que representan los argumentos de tipo genérico del tipo en cuyo ámbito se encuentra el token; o es <see langword="null" /> si dicho tipo no es genérico.</param>
      <param name="genericMethodArguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Type&quot; /&gt; objects representing the generic type arguments of the method where the token is in scope, or &lt;see langword=&quot;null&quot; /&gt; if that method is not generic.">Matriz de objetos <see cref="T:System.Type" /> que representan los argumentos de tipo genérico del método en cuyo ámbito se encuentra el token; o es <see langword="null" /> si dicho método no es genérico.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the type that is identified by the specified metadata token.">Objeto <see cref="T:System.Type" /> que representa el tipo identificado por el token de metadatos especificado.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;metadataToken&quot; /&gt; is not a token for a type in the scope of the current module.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;metadataToken&quot; /&gt; is a &lt;see langword=&quot;TypeSpec&quot; /&gt; whose signature contains element type &lt;see langword=&quot;var&quot; /&gt; (a type parameter of a generic type) or &lt;see langword=&quot;mvar&quot; /&gt; (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of &lt;paramref name=&quot;genericTypeArguments&quot; /&gt; and &lt;paramref name=&quot;genericMethodArguments&quot; /&gt;.">
        <paramref name="metadataToken" /> no es un token válido para un tipo en el ámbito del módulo actual.  
O bien 
 <paramref name="metadataToken" /> es un <see langword="TypeSpec" /> cuya firma contiene el tipo de elemento <see langword="var" /> (un parámetro de tipo de un tipo genérico) o <see langword="mvar" /> (un parámetro de tipo de un método genérico) y no se proporcionaron los argumentos de tipo genérico necesarios para uno o ambos parámetros <paramref name="genericTypeArguments" /> y <paramref name="genericMethodArguments" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;metadataToken&quot; /&gt; is not a valid token in the scope of the current module.">
        <paramref name="metadataToken" /> no es un token válido en el ámbito del módulo actual.</exception>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.ScopeName">
      <summary vsli:raw="Gets a string that represents the name of the dynamic module.">Obtiene una cadena que representa el nombre del módulo dinámico.</summary>
      <returns vsli:raw="The name of the dynamic module.">Nombre del módulo dinámico.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary vsli:raw="Applies a custom attribute to this module by using a specified binary large object (BLOB) that represents the attribute.">Aplica un atributo personalizado a este módulo utilizando el objeto binario grande (BLOB) especificado que representa el atributo.</summary>
      <param name="con" vsli:raw="The constructor for the custom attribute.">Constructor para el atributo personalizado.</param>
      <param name="binaryAttribute" vsli:raw="A byte BLOB representing the attribute.">BLOB de bytes que representa el atributo.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;con&quot; /&gt; or &lt;paramref name=&quot;binaryAttribute&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="con" /> o <paramref name="binaryAttribute" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary vsli:raw="Applies a custom attribute to this module by using a custom attribute builder.">Aplica un atributo personalizado a este módulo utilizando un generador de atributos personalizados.</summary>
      <param name="customBuilder" vsli:raw="An instance of a helper class that specifies the custom attribute to apply.">Instancia de una clase del asistente que especifica el atributo personalizado que se va a aplicar.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;customBuilder&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="customBuilder" /> es <see langword="null" />.</exception>
    </member>
    <member name="T:System.Reflection.Emit.PropertyBuilder">
      <summary vsli:raw="Defines the properties for a type.">Define las propiedades de un tipo.</summary>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.AddOtherMethod(System.Reflection.Emit.MethodBuilder)">
      <summary vsli:raw="Adds one of the other methods associated with this property.">Agrega uno de los otros métodos asociados a esta propiedad.</summary>
      <param name="mdBuilder" vsli:raw="A &lt;see langword=&quot;MethodBuilder&quot; /&gt; object that represents the other method.">Objeto <see langword="MethodBuilder" /> que representa el otro método.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;mdBuilder&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="mdBuilder" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt; has been called on the enclosing type.">Se ha llamado a <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> en el tipo envolvente.</exception>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.Attributes">
      <summary vsli:raw="Gets the attributes for this property.">Obtiene los atributos de esta propiedad.</summary>
      <returns vsli:raw="Attributes of this property.">Atributos de esta propiedad.</returns>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.CanRead">
      <summary vsli:raw="Gets a value indicating whether the property can be read.">Obtiene un valor que indica si se puede leer la propiedad.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if this property can be read; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si se puede leer esta propiedad; en caso contrario, es <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.CanWrite">
      <summary vsli:raw="Gets a value indicating whether the property can be written to.">Obtiene un valor que indica si se puede escribir en la propiedad.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if this property can be written to; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si se puede escribir en esta propiedad; en caso contrario, es <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.DeclaringType">
      <summary vsli:raw="Gets the class that declares this member.">Obtiene la clase que declara este miembro.</summary>
      <returns vsli:raw="The &lt;see langword=&quot;Type&quot; /&gt; object for the class that declares this member.">Objeto <see langword="Type" /> de la clase que declara este miembro.</returns>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetAccessors(System.Boolean)">
      <summary vsli:raw="Returns an array of the public and non-public &lt;see langword=&quot;get&quot; /&gt; and &lt;see langword=&quot;set&quot; /&gt; accessors on this property.">Devuelve una matriz de los descriptores de acceso <see langword="get" /> y <see langword="set" /> públicos y no públicos en esta propiedad.</summary>
      <param name="nonPublic" vsli:raw="Indicates whether non-public methods should be returned in the &lt;see langword=&quot;MethodInfo&quot; /&gt; array. &lt;see langword=&quot;true&quot; /&gt; if non-public methods are to be included; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Indica si se deben devolver métodos que no sean públicos en la matriz <see langword="MethodInfo" />. <see langword="true" /> si se van a incluir métodos que no son públicos; en caso contrario, es <see langword="false" />.</param>
      <returns vsli:raw="An array of type &lt;see langword=&quot;MethodInfo&quot; /&gt; containing the matching public or non-public accessors, or an empty array if matching accessors do not exist on this property.">Matriz de tipo <see langword="MethodInfo" /> que contiene los descriptores de acceso públicos y no públicos coincidentes, o una matriz vacía si no existen descriptores de acceso coincidentes en esta propiedad.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not supported.">No se admite este método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetCustomAttributes(System.Boolean)">
      <summary vsli:raw="Returns an array of all the custom attributes for this property.">Devuelve una matriz de todos los atributos personalizados de esta propiedad.</summary>
      <param name="inherit" vsli:raw="If &lt;see langword=&quot;true&quot; /&gt;, walks up this property's inheritance chain to find the custom attributes.">Si es <see langword="true" />, asciende por la cadena de herencia de esta propiedad para buscar los atributos personalizados.</param>
      <returns vsli:raw="An array of all the custom attributes.">Matriz de todos los atributos personalizados.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not supported.">No se admite este método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary vsli:raw="Returns an array of custom attributes identified by &lt;see cref=&quot;T:System.Type&quot; /&gt;.">Devuelve una matriz de atributos personalizados identificados por <see cref="T:System.Type" />.</summary>
      <param name="attributeType" vsli:raw="An array of custom attributes identified by type.">Matriz de atributos personalizados identificados según el tipo.</param>
      <param name="inherit" vsli:raw="If &lt;see langword=&quot;true&quot; /&gt;, walks up this property's inheritance chain to find the custom attributes.">Si es <see langword="true" />, asciende por la cadena de herencia de esta propiedad para buscar los atributos personalizados.</param>
      <returns vsli:raw="An array of custom attributes defined on this reflected member, or &lt;see langword=&quot;null&quot; /&gt; if no attributes are defined on this member.">Matriz de atributos personalizados definidos en este miembro reflejado, o <see langword="null" /> si no hay atributos definidos en este miembro.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not supported.">No se admite este método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetGetMethod(System.Boolean)">
      <summary vsli:raw="Returns the public and non-public get accessor for this property.">Devuelve el descriptor de acceso get público y no público de esta propiedad.</summary>
      <param name="nonPublic" vsli:raw="Indicates whether non-public get accessors should be returned. &lt;see langword=&quot;true&quot; /&gt; if non-public methods are to be included; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Indica si se deben devolver descriptores de acceso get que no sean públicos. <see langword="true" /> si se van a incluir métodos que no son públicos; en caso contrario, es <see langword="false" />.</param>
      <returns vsli:raw="A &lt;see langword=&quot;MethodInfo&quot; /&gt; object representing the get accessor for this property, if &lt;paramref name=&quot;nonPublic&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;. Returns &lt;see langword=&quot;null&quot; /&gt; if &lt;paramref name=&quot;nonPublic&quot; /&gt; is &lt;see langword=&quot;false&quot; /&gt; and the get accessor is non-public, or if &lt;paramref name=&quot;nonPublic&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt; but no get accessors exist.">Objeto <see langword="MethodInfo" /> que representa el descriptor de acceso get de esta propiedad si <paramref name="nonPublic" /> es <see langword="true" />. Devuelve <see langword="null" /> si <paramref name="nonPublic" /> es <see langword="false" /> y el descriptor de acceso get no es público, o si <paramref name="nonPublic" /> es <see langword="true" /> pero no existe ningún descriptor de acceso get.</returns>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetIndexParameters">
      <summary vsli:raw="Returns an array of all the index parameters for the property.">Devuelve una matriz de todos los parámetros de índice de la propiedad.</summary>
      <returns vsli:raw="An array of type &lt;see langword=&quot;ParameterInfo&quot; /&gt; containing the parameters for the indexes.">Matriz de tipo <see langword="ParameterInfo" /> que contiene los parámetros de los índices.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not supported.">No se admite este método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetSetMethod(System.Boolean)">
      <summary vsli:raw="Returns the set accessor for this property.">Devuelve el descriptor de acceso establecido de esta propiedad.</summary>
      <param name="nonPublic" vsli:raw="Indicates whether the accessor should be returned if it is non-public. &lt;see langword=&quot;true&quot; /&gt; if non-public methods are to be included; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Indica si se debe devolver el descriptor de acceso si es no público. <see langword="true" /> si se van a incluir métodos que no son públicos; en caso contrario, es <see langword="false" />.</param>
      <returns vsli:raw="The property's &lt;see langword=&quot;Set&quot; /&gt; method, or &lt;see langword=&quot;null&quot; /&gt;, as shown in the following table.  &#xA;  &#xA; &lt;list type=&quot;table&quot;&gt;&lt;listheader&gt;&lt;term&gt; Value&lt;/term&gt;&lt;description&gt; Condition&lt;/description&gt;&lt;/listheader&gt;&lt;item&gt;&lt;term&gt; A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; object representing the Set method for this property.&lt;/term&gt;&lt;description&gt; The set accessor is public.  &#xA;  &#xA; &lt;paramref name=&quot;nonPublic&quot; /&gt; is true and non-public methods can be returned.&lt;/description&gt;&lt;/item&gt;&lt;item&gt;&lt;term&gt; null&lt;/term&gt;&lt;description&gt;&lt;paramref name=&quot;nonPublic&quot; /&gt; is true, but the property is read-only.  &#xA;  &#xA; &lt;paramref name=&quot;nonPublic&quot; /&gt; is false and the set accessor is non-public.&lt;/description&gt;&lt;/item&gt;&lt;/list&gt;">Método <see langword="Set" /> de la propiedad, o <see langword="null" />, como se muestra en la tabla siguiente.  
  Valor 
  Condición 
  Objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método Set de esta propiedad.  

  El descriptor de acceso set es público.  

 <paramref name="nonPublic" /> es true y se pueden devolver métodos no públicos.  

  nulo 
 <paramref name="nonPublic" /> es true, pero la propiedad es de sólo lectura.  

 <paramref name="nonPublic" /> es falso y el descriptor de acceso establecido no es público.</returns>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetValue(System.Object,System.Object[])">
      <summary vsli:raw="Gets the value of the indexed property by calling the property's getter method.">Obtiene el valor de la propiedad indizada llamando al método Get de la propiedad.</summary>
      <param name="obj" vsli:raw="The object whose property value will be returned.">Objeto cuyo valor de propiedad se va a devolver.</param>
      <param name="index" vsli:raw="Optional index values for indexed properties. This value should be &lt;see langword=&quot;null&quot; /&gt; for non-indexed properties.">Valores de índice opcionales para propiedades indizadas. Este valor debe ser <see langword="null" /> para propiedades no indizadas.</param>
      <returns vsli:raw="The value of the specified indexed property.">Valor de la propiedad indizada especificada.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not supported.">No se admite este método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetValue(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
      <summary vsli:raw="Gets the value of a property having the specified binding, index, and &lt;see langword=&quot;CultureInfo&quot; /&gt;.">Obtiene el valor de una propiedad con el enlace, índice y <see langword="CultureInfo" /> especificados.</summary>
      <param name="obj" vsli:raw="The object whose property value will be returned.">Objeto cuyo valor de propiedad se va a devolver.</param>
      <param name="invokeAttr" vsli:raw="The invocation attribute. This must be a bit flag from &lt;see langword=&quot;BindingFlags&quot; /&gt; : &lt;see langword=&quot;InvokeMethod&quot; /&gt;, &lt;see langword=&quot;CreateInstance&quot; /&gt;, &lt;see langword=&quot;Static&quot; /&gt;, &lt;see langword=&quot;GetField&quot; /&gt;, &lt;see langword=&quot;SetField&quot; /&gt;, &lt;see langword=&quot;GetProperty&quot; /&gt;, or &lt;see langword=&quot;SetProperty&quot; /&gt;. A suitable invocation attribute must be specified. If a static member is to be invoked, the &lt;see langword=&quot;Static&quot; /&gt; flag of &lt;see langword=&quot;BindingFlags&quot; /&gt; must be set.">Atributo de invocación. Debe ser un marcador de bits de <see langword="BindingFlags" />: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="Static" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> o <see langword="SetProperty" />. Debe especificarse un atributo de invocación apropiado. Si se va a invocar un miembro estático, se debe establecer la marca <see langword="Static" /> de <see langword="BindingFlags" />.</param>
      <param name="binder" vsli:raw="An object that enables the binding, coercion of argument types, invocation of members, and retrieval of &lt;see langword=&quot;MemberInfo&quot; /&gt; objects using reflection. If &lt;paramref name=&quot;binder&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;, the default binder is used.">Objeto que permite el enlace, la conversión de tipos de argumentos, la invocación de miembros y la recuperación de objetos <see langword="MemberInfo" /> mediante la reflexión. Si <paramref name="binder" /> es <see langword="null" />, se usa el enlazador predeterminado.</param>
      <param name="index" vsli:raw="Optional index values for indexed properties. This value should be &lt;see langword=&quot;null&quot; /&gt; for non-indexed properties.">Valores de índice opcionales para propiedades indizadas. Este valor debe ser <see langword="null" /> para propiedades no indizadas.</param>
      <param name="culture" vsli:raw="The &lt;see langword=&quot;CultureInfo&quot; /&gt; object that represents the culture for which the resource is to be localized. Note that if the resource is not localized for this culture, the &lt;see langword=&quot;CultureInfo.Parent&quot; /&gt; method will be called successively in search of a match. If this value is &lt;see langword=&quot;null&quot; /&gt;, the &lt;see langword=&quot;CultureInfo&quot; /&gt; is obtained from the &lt;see langword=&quot;CultureInfo.CurrentUICulture&quot; /&gt; property.">Objeto <see langword="CultureInfo" /> que representa la referencia cultural para la que se va a buscar el recurso. Observe que si no se encuentra el recurso correspondiente a esta referencia cultural, se llamará sucesivamente al método <see langword="CultureInfo.Parent" /> para buscar una coincidencia. Si este valor es <see langword="null" />, <see langword="CultureInfo" /> se obtiene a partir de la propiedad <see langword="CultureInfo.CurrentUICulture" />.</param>
      <returns vsli:raw="The property value for &lt;paramref name=&quot;obj&quot; /&gt;.">Valor de propiedad de <paramref name="obj" />.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not supported.">No se admite este método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.IsDefined(System.Type,System.Boolean)">
      <summary vsli:raw="Indicates whether one or more instance of &lt;paramref name=&quot;attributeType&quot; /&gt; is defined on this property.">Indica si se han definido una o varias instancias de <paramref name="attributeType" /> en esta propiedad.</summary>
      <param name="attributeType" vsli:raw="The &lt;see langword=&quot;Type&quot; /&gt; object to which the custom attributes are applied.">Objeto <see langword="Type" /> al que se aplican los atributos personalizados.</param>
      <param name="inherit" vsli:raw="Specifies whether to walk up this property's inheritance chain to find the custom attributes.">Especifica si se va ascender por la cadena de herencia de esta propiedad para buscar los atributos personalizados.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if one or more instance of &lt;paramref name=&quot;attributeType&quot; /&gt; is defined on this property; otherwise &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si se han definido una o varias instancias de <paramref name="attributeType" /> en esta propiedad; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not supported.">No se admite este método.</exception>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.Module">
      <summary vsli:raw="Gets the module in which the type that declares the current property is being defined.">Obtiene el módulo en el que se está definiendo el tipo que declara la propiedad actual.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Reflection.Module&quot; /&gt; in which the type that declares the current property is defined.">Clase <see cref="T:System.Reflection.Module" /> en la que se define el tipo que declara la propiedad actual.</returns>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.Name">
      <summary vsli:raw="Gets the name of this member.">Obtiene el nombre de este miembro.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.String&quot; /&gt; containing the name of this member.">
        <see cref="T:System.String" /> que contiene el nombre de este miembro.</returns>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.PropertyType">
      <summary vsli:raw="Gets the type of the field of this property.">Obtiene el tipo del campo de esta propiedad.</summary>
      <returns vsli:raw="The type of this property.">Tipo de esta propiedad.</returns>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.ReflectedType">
      <summary vsli:raw="Gets the class object that was used to obtain this instance of &lt;see langword=&quot;MemberInfo&quot; /&gt;.">Obtiene el objeto de la clase utilizado para obtener esta instancia de <see langword="MemberInfo" />.</summary>
      <returns vsli:raw="The &lt;see langword=&quot;Type&quot; /&gt; object through which this &lt;see langword=&quot;MemberInfo&quot; /&gt; object was obtained.">Objeto <see langword="Type" /> a través del cual se obtuvo este objeto <see langword="MemberInfo" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetConstant(System.Object)">
      <summary vsli:raw="Sets the default value of this property.">Establece el valor predeterminado de esta propiedad.</summary>
      <param name="defaultValue" vsli:raw="The default value of this property.">Valor predeterminado de esta propiedad.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt; has been called on the enclosing type.">Se ha llamado a <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> en el tipo envolvente.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The property is not one of the supported types.  &#xA;  &#xA; -or-  &#xA;  &#xA; The type of &lt;paramref name=&quot;defaultValue&quot; /&gt; does not match the type of the property.  &#xA;  &#xA; -or-  &#xA;  &#xA; The property is of type &lt;see cref=&quot;T:System.Object&quot; /&gt; or other reference type, &lt;paramref name=&quot;defaultValue&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt;, and the value cannot be assigned to the reference type.">La propiedad no es uno de los tipos admitidos.  
o bien 
El tipo de <paramref name="defaultValue" /> no coincide con el tipo de la propiedad.  
o bien 
La propiedad es de tipo <see cref="T:System.Object" /> o de otro tipo de referencia, el valor de <paramref name="defaultValue" /> no es <see langword="null" /> y el valor no se puede asignar al tipo de referencia.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary vsli:raw="Set a custom attribute using a specified custom attribute blob.">Establezca un atributo personalizado mediante el objeto binario de atributo personalizado especificado.</summary>
      <param name="con" vsli:raw="The constructor for the custom attribute.">Constructor para el atributo personalizado.</param>
      <param name="binaryAttribute" vsli:raw="A byte blob representing the attributes.">Blob de bytes que representa los atributos.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;con&quot; /&gt; or &lt;paramref name=&quot;binaryAttribute&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="con" /> o <paramref name="binaryAttribute" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt; has been called on the enclosing type.">Se ha llamado a <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> en el tipo envolvente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary vsli:raw="Set a custom attribute using a custom attribute builder.">Establece un atributo personalizado mediante un generador de atributos personalizado.</summary>
      <param name="customBuilder" vsli:raw="An instance of a helper class to define the custom attribute.">Instancia de una clase del asistente para definir el atributo personalizado.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;customBuilder&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="customBuilder" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="if &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt; has been called on the enclosing type.">si se ha llamado a <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> en el tipo envolvente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetGetMethod(System.Reflection.Emit.MethodBuilder)">
      <summary vsli:raw="Sets the method that gets the property value.">Establece el método que obtiene el valor de propiedad.</summary>
      <param name="mdBuilder" vsli:raw="A &lt;see langword=&quot;MethodBuilder&quot; /&gt; object that represents the method that gets the property value.">Objeto <see langword="MethodBuilder" /> que representa el método que obtiene el valor de propiedad.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;mdBuilder&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="mdBuilder" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt; has been called on the enclosing type.">Se ha llamado a <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> en el tipo envolvente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetSetMethod(System.Reflection.Emit.MethodBuilder)">
      <summary vsli:raw="Sets the method that sets the property value.">Establece el método que define el valor de propiedad.</summary>
      <param name="mdBuilder" vsli:raw="A &lt;see langword=&quot;MethodBuilder&quot; /&gt; object that represents the method that sets the property value.">Objeto <see langword="MethodBuilder" /> que representa el método que establece el valor de propiedad.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;mdBuilder&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="mdBuilder" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt; has been called on the enclosing type.">Se ha llamado a <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> en el tipo envolvente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetValue(System.Object,System.Object,System.Object[])">
      <summary vsli:raw="Sets the value of the property with optional index values for index properties.">Establece el valor de la propiedad con valores de índice opcionales para propiedades indizadas.</summary>
      <param name="obj" vsli:raw="The object whose property value will be set.">Objeto cuyo valor de propiedad se va a establecer.</param>
      <param name="value" vsli:raw="The new value for this property.">Nuevo valor de esta propiedad.</param>
      <param name="index" vsli:raw="Optional index values for indexed properties. This value should be &lt;see langword=&quot;null&quot; /&gt; for non-indexed properties.">Valores de índice opcionales para propiedades indizadas. Este valor debe ser <see langword="null" /> para propiedades no indizadas.</param>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not supported.">No se admite este método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
      <summary vsli:raw="Sets the property value for the given object to the given value.">Establece el valor de propiedad del objeto especificado en el valor indicado.</summary>
      <param name="obj" vsli:raw="The object whose property value will be returned.">Objeto cuyo valor de propiedad se va a devolver.</param>
      <param name="value" vsli:raw="The new value for this property.">Nuevo valor de esta propiedad.</param>
      <param name="invokeAttr" vsli:raw="The invocation attribute. This must be a bit flag from &lt;see langword=&quot;BindingFlags&quot; /&gt; : &lt;see langword=&quot;InvokeMethod&quot; /&gt;, &lt;see langword=&quot;CreateInstance&quot; /&gt;, &lt;see langword=&quot;Static&quot; /&gt;, &lt;see langword=&quot;GetField&quot; /&gt;, &lt;see langword=&quot;SetField&quot; /&gt;, &lt;see langword=&quot;GetProperty&quot; /&gt;, or &lt;see langword=&quot;SetProperty&quot; /&gt;. A suitable invocation attribute must be specified. If a static member is to be invoked, the &lt;see langword=&quot;Static&quot; /&gt; flag of &lt;see langword=&quot;BindingFlags&quot; /&gt; must be set.">Atributo de invocación. Debe ser un marcador de bits de <see langword="BindingFlags" />: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="Static" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> o <see langword="SetProperty" />. Debe especificarse un atributo de invocación apropiado. Si se va a invocar un miembro estático, se debe establecer la marca <see langword="Static" /> de <see langword="BindingFlags" />.</param>
      <param name="binder" vsli:raw="An object that enables the binding, coercion of argument types, invocation of members, and retrieval of &lt;see langword=&quot;MemberInfo&quot; /&gt; objects using reflection. If &lt;paramref name=&quot;binder&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;, the default binder is used.">Objeto que permite el enlace, la conversión de tipos de argumentos, la invocación de miembros y la recuperación de objetos <see langword="MemberInfo" /> mediante la reflexión. Si <paramref name="binder" /> es <see langword="null" />, se usa el enlazador predeterminado.</param>
      <param name="index" vsli:raw="Optional index values for indexed properties. This value should be &lt;see langword=&quot;null&quot; /&gt; for non-indexed properties.">Valores de índice opcionales para propiedades indizadas. Este valor debe ser <see langword="null" /> para propiedades no indizadas.</param>
      <param name="culture" vsli:raw="The &lt;see langword=&quot;CultureInfo&quot; /&gt; object that represents the culture for which the resource is to be localized. Note that if the resource is not localized for this culture, the &lt;see langword=&quot;CultureInfo.Parent&quot; /&gt; method will be called successively in search of a match. If this value is &lt;see langword=&quot;null&quot; /&gt;, the &lt;see langword=&quot;CultureInfo&quot; /&gt; is obtained from the &lt;see langword=&quot;CultureInfo.CurrentUICulture&quot; /&gt; property.">Objeto <see langword="CultureInfo" /> que representa la referencia cultural para la que se va a buscar el recurso. Observe que si no se encuentra el recurso correspondiente a esta referencia cultural, se llamará sucesivamente al método <see langword="CultureInfo.Parent" /> para buscar una coincidencia. Si este valor es <see langword="null" />, <see langword="CultureInfo" /> se obtiene a partir de la propiedad <see langword="CultureInfo.CurrentUICulture" />.</param>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not supported.">No se admite este método.</exception>
    </member>
    <member name="T:System.Reflection.Emit.TypeBuilder">
      <summary vsli:raw="Defines and creates new instances of classes during run time.">Define y crea nuevas instancias de clases en tiempo de ejecución.</summary>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)">
      <summary vsli:raw="Adds an interface that this type implements.">Agrega una interfaz que implementa este tipo.</summary>
      <param name="interfaceType" vsli:raw="The interface that this type implements.">La interfaz que implementa este tipo.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;interfaceType&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="interfaceType" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The type was previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.Assembly">
      <summary vsli:raw="Retrieves the dynamic assembly that contains this type definition.">Recupera el ensamblado dinámico que contiene esta definición de tipo.</summary>
      <returns vsli:raw="Read-only. Retrieves the dynamic assembly that contains this type definition.">Sólo lectura. Recupera el ensamblado dinámico que contiene esta definición de tipo.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName">
      <summary vsli:raw="Returns the full name of this type qualified by the display name of the assembly.">Devuelve el nombre completo del tipo calificado por el nombre para mostrar del ensamblado.</summary>
      <returns vsli:raw="Read-only. The full name of this type qualified by the display name of the assembly.">Sólo lectura. Nombre completo del tipo calificado por el nombre para mostrar del ensamblado.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.BaseType">
      <summary vsli:raw="Retrieves the base type of this type.">Recupera el tipo base de este tipo.</summary>
      <returns vsli:raw="Read-only. Retrieves the base type of this type.">Sólo lectura. Recupera el tipo base de este tipo.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.CreateType">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Type&quot; /&gt; object for the class. After defining fields and methods on the class, &lt;see langword=&quot;CreateType&quot; /&gt; is called in order to load its &lt;see langword=&quot;Type&quot; /&gt; object.">Crea un objeto <see cref="T:System.Type" /> para esta clase. Después de definir los campos y métodos en la clase, se llama a <see langword="CreateType" /> para cargar su objeto <see langword="Type" />.</summary>
      <returns vsli:raw="Returns the new &lt;see cref=&quot;T:System.Type&quot; /&gt; object for this class.">Devuelve el nuevo objeto <see cref="T:System.Type" /> para esta clase.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The enclosing type has not been created.  &#xA;  &#xA; -or-  &#xA;  &#xA; This type is non-abstract and contains an abstract method.  &#xA;  &#xA; -or-  &#xA;  &#xA; This type is not an abstract class or an interface and has a method without a method body.">No se ha creado el tipo envolvente.  
 o bien  
 Este tipo no es abstracto y contiene un método abstracto.  
 O bien  
 Este tipo no es una clase o interfaz abstracta y tiene un método sin cuerpo de método.</exception>
      <exception cref="T:System.NotSupportedException" vsli:raw="The type contains invalid Microsoft intermediate language (MSIL) code.  &#xA;  &#xA; -or-  &#xA;  &#xA; The branch target is specified using a 1-byte offset, but the target is at a distance greater than 127 bytes from the branch.">El tipo contiene código de Lenguaje Intermedio de Microsoft (MSIL) no válido.  
 O bien  
 El destino de bifurcación se especifica con un desplazamiento de 1 byte, pero el destino está a una distancia superior a 127 bytes de la bifurcación.</exception>
      <exception cref="T:System.TypeLoadException" vsli:raw="The type cannot be loaded. For example, it contains a &lt;see langword=&quot;static&quot; /&gt; method that has the calling convention &lt;see cref=&quot;F:System.Reflection.CallingConventions.HasThis&quot; /&gt;.">No se puede cargar el tipo. Por ejemplo, contiene un método <see langword="static" /> con la convención de llamada <see cref="F:System.Reflection.CallingConventions.HasThis" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.CreateTypeInfo">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Reflection.TypeInfo&quot; /&gt; object that represents this type.">Obtiene un objeto <see cref="T:System.Reflection.TypeInfo" /> que representa este tipo.</summary>
      <returns vsli:raw="An object that represents this type.">Un objeto que representa este tipo.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.DeclaringMethod">
      <summary vsli:raw="Gets the method that declared the current generic type parameter.">Obtiene el método que declaró el parámetro de tipo genérico actual.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodBase&quot; /&gt; that represents the method that declared the current type, if the current type is a generic type parameter; otherwise, &lt;see langword=&quot;null&quot; /&gt;.">Un <see cref="T:System.Reflection.MethodBase" /> que representa el método que declaró el tipo actual, si el tipo actual es un parámetro de tipo genérico; de lo contrario, <see langword="null" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.DeclaringType">
      <summary vsli:raw="Returns the type that declared this type.">Devuelve el tipo que declaró este tipo.</summary>
      <returns vsli:raw="Read-only. The type that declared this type.">Sólo lectura. Tipo que declaró este tipo.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
      <summary vsli:raw="Adds a new constructor to the type, with the given attributes and signature.">Agrega un nuevo constructor al tipo, con los atributos y firma especificados.</summary>
      <param name="attributes" vsli:raw="The attributes of the constructor.">Atributos del constructor.</param>
      <param name="callingConvention" vsli:raw="The calling convention of the constructor.">Convención de llamada del constructor.</param>
      <param name="parameterTypes" vsli:raw="The parameter types of the constructor.">Tipos de parámetro del constructor.</param>
      <returns vsli:raw="The defined constructor.">El constructor definido.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The type was previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
      <summary vsli:raw="Adds a new constructor to the type, with the given attributes, signature, and custom modifiers.">Agrega un nuevo constructor al tipo, con los atributos, la firma y los modificadores personalizados especificados.</summary>
      <param name="attributes" vsli:raw="The attributes of the constructor.">Atributos del constructor.</param>
      <param name="callingConvention" vsli:raw="The calling convention of the constructor.">Convención de llamada del constructor.</param>
      <param name="parameterTypes" vsli:raw="The parameter types of the constructor.">Tipos de parámetro del constructor.</param>
      <param name="requiredCustomModifiers" vsli:raw="An array of arrays of types. Each array of types represents the required custom modifiers for the corresponding parameter, such as &lt;see cref=&quot;T:System.Runtime.CompilerServices.IsConst&quot; /&gt;. If a particular parameter has no required custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt; instead of an array of types. If none of the parameters have required custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt; instead of an array of arrays.">Matriz de matrices de tipos. Cada matriz de tipos representa los modificadores personalizados obligatorios para el parámetro correspondiente, como <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un parámetro concreto no tiene modificadores personalizados necesarios, especifique <see langword="null" /> en lugar de una matriz de tipos. Si ninguno de los parámetros tiene modificadores personalizados necesarios, especifique <see langword="null" /> en lugar de una matriz de matrices.</param>
      <param name="optionalCustomModifiers" vsli:raw="An array of arrays of types. Each array of types represents the optional custom modifiers for the corresponding parameter, such as &lt;see cref=&quot;T:System.Runtime.CompilerServices.IsConst&quot; /&gt;. If a particular parameter has no optional custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt; instead of an array of types. If none of the parameters have optional custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt; instead of an array of arrays.">Matriz de matrices de tipos. Cada matriz de tipos representa los modificadores personalizados opcionales para el parámetro correspondiente, como <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un parámetro concreto no tiene modificadores personalizados opcionales, especifique <see langword="null" /> en lugar de una matriz de tipos. Si ninguno de los parámetros tiene modificadores personalizados opcionales, especifique <see langword="null" /> en lugar de una matriz de matrices.</param>
      <returns vsli:raw="The defined constructor.">El constructor definido.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The size of &lt;paramref name=&quot;requiredCustomModifiers&quot; /&gt; or &lt;paramref name=&quot;optionalCustomModifiers&quot; /&gt; does not equal the size of &lt;paramref name=&quot;parameterTypes&quot; /&gt;.">El tamaño de <paramref name="requiredCustomModifiers" /> o <paramref name="optionalCustomModifiers" /> no es igual al tamaño de <paramref name="parameterTypes" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The type was previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; For the current dynamic type, the &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.IsGenericType&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;, but the &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition&quot; /&gt; property is &lt;see langword=&quot;false&quot; /&gt;.">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
O bien 
Para el tipo dinámico actual, la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> es <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
      <summary vsli:raw="Defines the parameterless constructor. The constructor defined here will simply call the parameterless constructor of the parent.">Define el constructor sin parámetros. El constructor que se define aquí simplemente llamará al constructor sin parámetros del elemento primario.</summary>
      <param name="attributes" vsli:raw="A &lt;see langword=&quot;MethodAttributes&quot; /&gt; object representing the attributes to be applied to the constructor.">Un objeto <see langword="MethodAttributes" /> que representa los atributos que se aplicarán al constructor.</param>
      <returns vsli:raw="Returns the constructor.">Devuelve el constructor.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="The parent type (base type) does not have a parameterless constructor.">El tipo de elemento primario (tipo base) no tiene un constructor sin parámetros.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The type was previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; For the current dynamic type, the &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.IsGenericType&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;, but the &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition&quot; /&gt; property is &lt;see langword=&quot;false&quot; /&gt;.">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
o bien 
Para el tipo dinámico actual, la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> es <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
      <summary vsli:raw="Adds a new event to the type, with the given name, attributes and event type.">Agrega un nuevo evento al tipo, con el nombre, los atributos y el tipo de evento especificados.</summary>
      <param name="name" vsli:raw="The name of the event. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">Nombre del evento. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="attributes" vsli:raw="The attributes of the event.">Atributos del evento.</param>
      <param name="eventtype" vsli:raw="The type of the event.">Tipo del evento.</param>
      <returns vsli:raw="The defined event.">Evento definido.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The length of &lt;paramref name=&quot;name&quot; /&gt; is zero.">La longitud de <paramref name="name" /> es cero.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;eventtype&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> es <see langword="null" />.  
O bien 
 <paramref name="eventtype" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The type was previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
      <summary vsli:raw="Adds a new field to the type, with the given name, attributes, and field type.">Agrega un nuevo campo al tipo, con el nombre, los atributos y el tipo de campo especificados.</summary>
      <param name="fieldName" vsli:raw="The name of the field. &lt;paramref name=&quot;fieldName&quot; /&gt; cannot contain embedded nulls.">Nombre del campo. <paramref name="fieldName" /> no puede contener valores null incrustados.</param>
      <param name="type" vsli:raw="The type of the field.">Tipo del campo.</param>
      <param name="attributes" vsli:raw="The attributes of the field.">Atributos del campo.</param>
      <returns vsli:raw="The defined field.">Campo definido.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The length of &lt;paramref name=&quot;fieldName&quot; /&gt; is zero.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;type&quot; /&gt; is System.Void.  &#xA;  &#xA; -or-  &#xA;  &#xA; A total size was specified for the parent class of this field.">La longitud de <paramref name="fieldName" /> es cero.  
o bien 
 <paramref name="type" /> es System.Void.  
o bien 
Se especificó un tamaño total de la clase primaria de este campo.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;fieldName&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="fieldName" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The type was previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
      <summary vsli:raw="Adds a new field to the type, with the given name, attributes, field type, and custom modifiers.">Agrega un nuevo campo al tipo, con el nombre, los atributos, el tipo de campo y os modificadores personalizados especificados.</summary>
      <param name="fieldName" vsli:raw="The name of the field. &lt;paramref name=&quot;fieldName&quot; /&gt; cannot contain embedded nulls.">Nombre del campo. <paramref name="fieldName" /> no puede contener valores null incrustados.</param>
      <param name="type" vsli:raw="The type of the field.">Tipo del campo.</param>
      <param name="requiredCustomModifiers" vsli:raw="An array of types representing the required custom modifiers for the field, such as &lt;see cref=&quot;T:Microsoft.VisualC.IsConstModifier&quot; /&gt;.">Matriz de tipos que representan los modificadores personalizados necesarios para el campo, como <see cref="T:Microsoft.VisualC.IsConstModifier" />.</param>
      <param name="optionalCustomModifiers" vsli:raw="An array of types representing the optional custom modifiers for the field, such as &lt;see cref=&quot;T:Microsoft.VisualC.IsConstModifier&quot; /&gt;.">Matriz de tipos que representan los modificadores personalizados opcionales para el campo, como <see cref="T:Microsoft.VisualC.IsConstModifier" />.</param>
      <param name="attributes" vsli:raw="The attributes of the field.">Atributos del campo.</param>
      <returns vsli:raw="The defined field.">Campo definido.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The length of &lt;paramref name=&quot;fieldName&quot; /&gt; is zero.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;type&quot; /&gt; is System.Void.  &#xA;  &#xA; -or-  &#xA;  &#xA; A total size was specified for the parent class of this field.">La longitud de <paramref name="fieldName" /> es cero.  
o bien 
 <paramref name="type" /> es System.Void.  
o bien 
Se especificó un tamaño total de la clase primaria de este campo.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;fieldName&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="fieldName" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The type was previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
      <summary vsli:raw="Defines the generic type parameters for the current type, specifying their number and their names, and returns an array of &lt;see cref=&quot;T:System.Reflection.Emit.GenericTypeParameterBuilder&quot; /&gt; objects that can be used to set their constraints.">Define los parámetros de tipo genérico para el tipo actual, especificando su número y sus nombres y devuelve una matriz de <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> objetos que pueden usarse para establecer sus restricciones.</summary>
      <param name="names" vsli:raw="An array of names for the generic type parameters.">Una matriz de nombres para los parámetros de tipo genérico.</param>
      <returns vsli:raw="An array of &lt;see cref=&quot;T:System.Reflection.Emit.GenericTypeParameterBuilder&quot; /&gt; objects that can be used to define the constraints of the generic type parameters for the current type.">Una matriz de <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> objetos que pueden usarse para definir las restricciones de los parámetros de tipo genérico para el tipo actual.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Generic type parameters have already been defined for this type.">Los parámetros de tipo genérico ya se han definido para este tipo.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;names&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; An element of &lt;paramref name=&quot;names&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="names" /> es <see langword="null" />.  
o bien 
Un elemento de <paramref name="names" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;names&quot; /&gt; is an empty array.">
        <paramref name="names" /> es una matriz vacía.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
      <summary vsli:raw="Defines initialized data field in the .sdata section of the portable executable (PE) file.">Define el campo de datos inicializado en la sección .sdata del archivo ejecutable portable (PE).</summary>
      <param name="name" vsli:raw="The name used to refer to the data. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">El nombre que se usa para hacer referencia a los datos. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="data" vsli:raw="The blob of data.">El blob de datos.</param>
      <param name="attributes" vsli:raw="The attributes for the field.">Los atributos para este campo.</param>
      <returns vsli:raw="A field to reference the data.">Campo para hacer referencia a los datos.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="Length of &lt;paramref name=&quot;name&quot; /&gt; is zero.  &#xA;  &#xA; -or-  &#xA;  &#xA; The size of the data is less than or equal to zero, or greater than or equal to 0x3f0000.">La longitud de <paramref name="name" /> es cero.  
o bien 
El tamaño de los datos es menor o igual que cero, o mayor o igual que 0x3f0000.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; or &lt;paramref name=&quot;data&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> o <paramref name="data" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt; has been previously called.">Se llamó anteriormente a <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
      <summary vsli:raw="Adds a new method to the type, with the specified name and method attributes.">Agrega un nuevo método al tipo, con el nombre especificado y los atributos de método.</summary>
      <param name="name" vsli:raw="The name of the method. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">Nombre del método. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="attributes" vsli:raw="The attributes of the method.">Atributos del método.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Emit.MethodBuilder&quot; /&gt; representing the newly defined method.">
        <see cref="T:System.Reflection.Emit.MethodBuilder" /> que representa el método recién definido.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The length of &lt;paramref name=&quot;name&quot; /&gt; is zero.  &#xA;  &#xA; -or-  &#xA;  &#xA; The type of the parent of this method is an interface, and this method is not virtual (&lt;see langword=&quot;Overridable&quot; /&gt; in Visual Basic).">La longitud de <paramref name="name" /> es cero.  
O bien 
El tipo del elemento principal de este método es una interfaz y este método no es virtual (<see langword="Overridable" /> en Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The type was previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; For the current dynamic type, the &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.IsGenericType&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;, but the &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition&quot; /&gt; property is &lt;see langword=&quot;false&quot; /&gt;.">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
o bien 
Para el tipo dinámico actual, la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> es <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
      <summary vsli:raw="Adds a new method to the type, with the specified name, method attributes, and calling convention.">Agrega un nuevo método al tipo, con el nombre especificado, los atributos de método y la convención de llamada.</summary>
      <param name="name" vsli:raw="The name of the method. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">Nombre del método. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="attributes" vsli:raw="The attributes of the method.">Atributos del método.</param>
      <param name="callingConvention" vsli:raw="The calling convention of the method.">Convención de llamada del método.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Emit.MethodBuilder&quot; /&gt; representing the newly defined method.">
        <see cref="T:System.Reflection.Emit.MethodBuilder" /> que representa el método recién definido.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The length of &lt;paramref name=&quot;name&quot; /&gt; is zero.  &#xA;  &#xA; -or-  &#xA;  &#xA; The type of the parent of this method is an interface and this method is not virtual (&lt;see langword=&quot;Overridable&quot; /&gt; in Visual Basic).">La longitud de <paramref name="name" /> es cero.  
O bien 
El tipo del elemento principal de este método es una interfaz y este método no es virtual (<see langword="Overridable" /> en Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The type was previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; For the current dynamic type, the &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.IsGenericType&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;, but the &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition&quot; /&gt; property is &lt;see langword=&quot;false&quot; /&gt;.">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
O bien 
Para el tipo dinámico actual, la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> es <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
      <summary vsli:raw="Adds a new method to the type, with the specified name, method attributes, calling convention, and method signature.">Agrega un nuevo método al tipo, con el nombre especificado, los atributos de método, la convención de llamada y la firma del método.</summary>
      <param name="name" vsli:raw="The name of the method. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">Nombre del método. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="attributes" vsli:raw="The attributes of the method.">Atributos del método.</param>
      <param name="callingConvention" vsli:raw="The calling convention of the method.">Convención de llamada del método.</param>
      <param name="returnType" vsli:raw="The return type of the method.">Tipo devuelto del método.</param>
      <param name="parameterTypes" vsli:raw="The types of the parameters of the method.">Tipos de los parámetros del método.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Emit.MethodBuilder&quot; /&gt; representing the newly defined method.">
        <see cref="T:System.Reflection.Emit.MethodBuilder" /> que representa el método recién definido.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The length of &lt;paramref name=&quot;name&quot; /&gt; is zero.  &#xA;  &#xA; -or-  &#xA;  &#xA; The type of the parent of this method is an interface, and this method is not virtual (&lt;see langword=&quot;Overridable&quot; /&gt; in Visual Basic).">La longitud de <paramref name="name" /> es cero.  
o bien 
El tipo del elemento principal de este método es una interfaz y este método no es virtual (<see langword="Overridable" /> en Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The type was previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; For the current dynamic type, the &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.IsGenericType&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;, but the &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition&quot; /&gt; property is &lt;see langword=&quot;false&quot; /&gt;.">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
O bien 
Para el tipo dinámico actual, la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> es <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
      <summary vsli:raw="Adds a new method to the type, with the specified name, method attributes, calling convention, method signature, and custom modifiers.">Agrega un nuevo método al tipo, con el nombre especificado, los atributos de método, la convención de llamada, la firma del método y los modificadores personalizados.</summary>
      <param name="name" vsli:raw="The name of the method. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">Nombre del método. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="attributes" vsli:raw="The attributes of the method.">Atributos del método.</param>
      <param name="callingConvention" vsli:raw="The calling convention of the method.">Convención de llamada del método.</param>
      <param name="returnType" vsli:raw="The return type of the method.">Tipo devuelto del método.</param>
      <param name="returnTypeRequiredCustomModifiers" vsli:raw="An array of types representing the required custom modifiers, such as &lt;see cref=&quot;T:System.Runtime.CompilerServices.IsConst&quot; /&gt;, for the return type of the method. If the return type has no required custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt;.">Matriz de los tipos que representan los modificadores personalizados necesarios, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para el tipo devuelto del método. Si el tipo de valor devuelto no tiene ningún modificador personalizado requerido, especifique <see langword="null" />.</param>
      <param name="returnTypeOptionalCustomModifiers" vsli:raw="An array of types representing the optional custom modifiers, such as &lt;see cref=&quot;T:System.Runtime.CompilerServices.IsConst&quot; /&gt;, for the return type of the method. If the return type has no optional custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt;.">Matriz de los tipos que representan los modificadores personalizados opcionales, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para el tipo devuelto del método. Si el tipo de valor devuelto no tiene ningún modificador personalizados opcional, especifique <see langword="null" />.</param>
      <param name="parameterTypes" vsli:raw="The types of the parameters of the method.">Tipos de los parámetros del método.</param>
      <param name="parameterTypeRequiredCustomModifiers" vsli:raw="An array of arrays of types. Each array of types represents the required custom modifiers for the corresponding parameter, such as &lt;see cref=&quot;T:System.Runtime.CompilerServices.IsConst&quot; /&gt;. If a particular parameter has no required custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt; instead of an array of types. If none of the parameters have required custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt; instead of an array of arrays.">Matriz de matrices de tipos. Cada matriz de tipos representa los modificadores personalizados obligatorios para el parámetro correspondiente, como <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un parámetro concreto no tiene modificadores personalizados necesarios, especifique <see langword="null" /> en lugar de una matriz de tipos. Si ninguno de los parámetros tiene modificadores personalizados necesarios, especifique <see langword="null" /> en lugar de una matriz de matrices.</param>
      <param name="parameterTypeOptionalCustomModifiers" vsli:raw="An array of arrays of types. Each array of types represents the optional custom modifiers for the corresponding parameter, such as &lt;see cref=&quot;T:System.Runtime.CompilerServices.IsConst&quot; /&gt;. If a particular parameter has no optional custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt; instead of an array of types. If none of the parameters have optional custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt; instead of an array of arrays.">Matriz de matrices de tipos. Cada matriz de tipos representa los modificadores personalizados opcionales para el parámetro correspondiente, como <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un parámetro concreto no tiene modificadores personalizados opcionales, especifique <see langword="null" /> en lugar de una matriz de tipos. Si ninguno de los parámetros tiene modificadores personalizados opcionales, especifique <see langword="null" /> en lugar de una matriz de matrices.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Emit.MethodBuilder&quot; /&gt; object representing the newly added method.">Un objeto <see cref="T:System.Reflection.Emit.MethodBuilder" /> que representa el método recién agregado.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The length of &lt;paramref name=&quot;name&quot; /&gt; is zero.  &#xA;  &#xA; -or-  &#xA;  &#xA; The type of the parent of this method is an interface, and this method is not virtual (&lt;see langword=&quot;Overridable&quot; /&gt; in Visual Basic).  &#xA;  &#xA; -or-  &#xA;  &#xA; The size of &lt;paramref name=&quot;parameterTypeRequiredCustomModifiers&quot; /&gt; or &lt;paramref name=&quot;parameterTypeOptionalCustomModifiers&quot; /&gt; does not equal the size of &lt;paramref name=&quot;parameterTypes&quot; /&gt;.">La longitud de <paramref name="name" /> es cero.  
o bien 
El tipo del elemento principal de este método es una interfaz y este método no es virtual (<see langword="Overridable" /> en Visual Basic).  
O bien 
El tamaño de <paramref name="parameterTypeRequiredCustomModifiers" /> o <paramref name="parameterTypeOptionalCustomModifiers" /> no es igual al tamaño de <paramref name="parameterTypes" />.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The type was previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; For the current dynamic type, the &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.IsGenericType&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;, but the &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition&quot; /&gt; property is &lt;see langword=&quot;false&quot; /&gt;.">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
o bien 
Para el tipo dinámico actual, la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> es <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
      <summary vsli:raw="Adds a new method to the type, with the specified name, method attributes, and method signature.">Agrega un nuevo método al tipo, con el nombre especificado, los atributos de método y la firma del método.</summary>
      <param name="name" vsli:raw="The name of the method. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">Nombre del método. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="attributes" vsli:raw="The attributes of the method.">Atributos del método.</param>
      <param name="returnType" vsli:raw="The return type of the method.">Tipo devuelto del método.</param>
      <param name="parameterTypes" vsli:raw="The types of the parameters of the method.">Tipos de los parámetros del método.</param>
      <returns vsli:raw="The defined method.">Método definido.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The length of &lt;paramref name=&quot;name&quot; /&gt; is zero.  &#xA;  &#xA; -or-  &#xA;  &#xA; The type of the parent of this method is an interface, and this method is not virtual (&lt;see langword=&quot;Overridable&quot; /&gt; in Visual Basic).">La longitud de <paramref name="name" /> es cero.  
O bien 
El tipo del elemento principal de este método es una interfaz y este método no es virtual (<see langword="Overridable" /> en Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The type was previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; For the current dynamic type, the &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.IsGenericType&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;, but the &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition&quot; /&gt; property is &lt;see langword=&quot;false&quot; /&gt;.">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
o bien 
Para el tipo dinámico actual, la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> es <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
      <summary vsli:raw="Specifies a given method body that implements a given method declaration, potentially with a different name.">Especifica un cuerpo de método determinado que implementa una declaración de método concreta, posiblemente con otro nombre.</summary>
      <param name="methodInfoBody" vsli:raw="The method body to be used. This should be a &lt;see langword=&quot;MethodBuilder&quot; /&gt; object.">Cuerpo del método que se va a usar. Debería ser un objeto <see langword="MethodBuilder" /> .</param>
      <param name="methodInfoDeclaration" vsli:raw="The method whose declaration is to be used.">Método cuya declaración se va a usar.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;methodInfoBody&quot; /&gt; does not belong to this class.">
        <paramref name="methodInfoBody" /> no pertenece a esta clase.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;methodInfoBody&quot; /&gt; or &lt;paramref name=&quot;methodInfoDeclaration&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="methodInfoBody" /> o <paramref name="methodInfoDeclaration" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The type was previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The declaring type of &lt;paramref name=&quot;methodInfoBody&quot; /&gt; is not the type represented by this &lt;see cref=&quot;T:System.Reflection.Emit.TypeBuilder&quot; /&gt;.">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
O bien 
El tipo declarativo de <paramref name="methodInfoBody" /> no es del tipo representado por este <see cref="T:System.Reflection.Emit.TypeBuilder" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
      <summary vsli:raw="Defines a nested type, given its name.">Define un tipo anidado, dado su nombre.</summary>
      <param name="name" vsli:raw="The short name of the type. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">Nombre corto del tipo. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <returns vsli:raw="The defined nested type.">El tipo anidado definido.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="Length of &lt;paramref name=&quot;name&quot; /&gt; is zero or greater than 1023.  &#xA;  &#xA; -or-  &#xA;  &#xA; This operation would create a type with a duplicate &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.FullName&quot; /&gt; in the current assembly.">La longitud de <paramref name="name" /> es cero o mayor que 1023.  
O bien 
Esta operación crearía un tipo con un valor de <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> duplicado en el ensamblado actual.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
      <summary vsli:raw="Defines a nested type, given its name and attributes.">Define un tipo anidado, dado su nombre y atributos.</summary>
      <param name="name" vsli:raw="The short name of the type. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">Nombre corto del tipo. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="attr" vsli:raw="The attributes of the type.">Atributos del tipo.</param>
      <returns vsli:raw="The defined nested type.">El tipo anidado definido.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The nested attribute is not specified.  &#xA;  &#xA; -or-  &#xA;  &#xA; This type is sealed.  &#xA;  &#xA; -or-  &#xA;  &#xA; This type is an array.  &#xA;  &#xA; -or-  &#xA;  &#xA; This type is an interface, but the nested type is not an interface.  &#xA;  &#xA; -or-  &#xA;  &#xA; The length of &lt;paramref name=&quot;name&quot; /&gt; is zero or greater than 1023.  &#xA;  &#xA; -or-  &#xA;  &#xA; This operation would create a type with a duplicate &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.FullName&quot; /&gt; in the current assembly.">No se especificó el atributo anidado.  
O bien 
Este tipo está sellado.  
o bien 
Este tipo es una matriz.  
O bien 
Este tipo es una interfaz, pero el tipo anidado no es una interfaz.  
O bien 
La longitud de <paramref name="name" /> es cero o mayor que 1023.  
o bien 
Esta operación crearía un tipo con un valor de <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> duplicado en el ensamblado actual.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
      <summary vsli:raw="Defines a nested type, given its name, attributes, and the type that it extends.">Define un tipo anidado, dado su nombre, sus atributos y el tipo que extiende.</summary>
      <param name="name" vsli:raw="The short name of the type. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">Nombre corto del tipo. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="attr" vsli:raw="The attributes of the type.">Atributos del tipo.</param>
      <param name="parent" vsli:raw="The type that the nested type extends.">El tipo que extiende el tipo anidado.</param>
      <returns vsli:raw="The defined nested type.">El tipo anidado definido.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The nested attribute is not specified.  &#xA;  &#xA; -or-  &#xA;  &#xA; This type is sealed.  &#xA;  &#xA; -or-  &#xA;  &#xA; This type is an array.  &#xA;  &#xA; -or-  &#xA;  &#xA; This type is an interface, but the nested type is not an interface.  &#xA;  &#xA; -or-  &#xA;  &#xA; The length of &lt;paramref name=&quot;name&quot; /&gt; is zero or greater than 1023.  &#xA;  &#xA; -or-  &#xA;  &#xA; This operation would create a type with a duplicate &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.FullName&quot; /&gt; in the current assembly.">No se especificó el atributo anidado.  
O bien 
Este tipo está sellado.  
o bien 
Este tipo es una matriz.  
o bien 
Este tipo es una interfaz, pero el tipo anidado no es una interfaz.  
o bien 
La longitud de <paramref name="name" /> es cero o mayor que 1023.  
O bien 
Esta operación crearía un tipo con un valor de <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> duplicado en el ensamblado actual.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
      <summary vsli:raw="Defines a nested type, given its name, attributes, the total size of the type, and the type that it extends.">Define un tipo anidado, dados su nombre, sus atributos, el tamaño total del tipo y el tipo que extiende.</summary>
      <param name="name" vsli:raw="The short name of the type. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">Nombre corto del tipo. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="attr" vsli:raw="The attributes of the type.">Atributos del tipo.</param>
      <param name="parent" vsli:raw="The type that the nested type extends.">El tipo que extiende el tipo anidado.</param>
      <param name="typeSize" vsli:raw="The total size of the type.">Tamaño total del tipo.</param>
      <returns vsli:raw="The defined nested type.">El tipo anidado definido.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The nested attribute is not specified.  &#xA;  &#xA; -or-  &#xA;  &#xA; This type is sealed.  &#xA;  &#xA; -or-  &#xA;  &#xA; This type is an array.  &#xA;  &#xA; -or-  &#xA;  &#xA; This type is an interface, but the nested type is not an interface.  &#xA;  &#xA; -or-  &#xA;  &#xA; The length of &lt;paramref name=&quot;name&quot; /&gt; is zero or greater than 1023.  &#xA;  &#xA; -or-  &#xA;  &#xA; This operation would create a type with a duplicate &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.FullName&quot; /&gt; in the current assembly.">No se especificó el atributo anidado.  
o bien 
Este tipo está sellado.  
o bien 
Este tipo es una matriz.  
O bien 
Este tipo es una interfaz, pero el tipo anidado no es una interfaz.  
O bien 
La longitud de <paramref name="name" /> es cero o mayor que 1023.  
o bien 
Esta operación crearía un tipo con un valor de <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> duplicado en el ensamblado actual.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
      <summary vsli:raw="Defines a nested type, given its name, attributes, the type that it extends, and the packing size.">Define un tipo anidado, dado su nombre, sus atributos, el tipo que extiende y el tamaño de empaquetado.</summary>
      <param name="name" vsli:raw="The short name of the type. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">Nombre corto del tipo. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="attr" vsli:raw="The attributes of the type.">Atributos del tipo.</param>
      <param name="parent" vsli:raw="The type that the nested type extends.">El tipo que extiende el tipo anidado.</param>
      <param name="packSize" vsli:raw="The packing size of the type.">Tamaño de empaquetado del tipo.</param>
      <returns vsli:raw="The defined nested type.">El tipo anidado definido.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The nested attribute is not specified.  &#xA;  &#xA; -or-  &#xA;  &#xA; This type is sealed.  &#xA;  &#xA; -or-  &#xA;  &#xA; This type is an array.  &#xA;  &#xA; -or-  &#xA;  &#xA; This type is an interface, but the nested type is not an interface.  &#xA;  &#xA; -or-  &#xA;  &#xA; The length of &lt;paramref name=&quot;name&quot; /&gt; is zero or greater than 1023.  &#xA;  &#xA; -or-  &#xA;  &#xA; This operation would create a type with a duplicate &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.FullName&quot; /&gt; in the current assembly.">No se especificó el atributo anidado.  
o bien 
Este tipo está sellado.  
O bien 
Este tipo es una matriz.  
O bien 
Este tipo es una interfaz, pero el tipo anidado no es una interfaz.  
O bien 
La longitud de <paramref name="name" /> es cero o mayor que 1023.  
O bien 
Esta operación crearía un tipo con un valor de <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> duplicado en el ensamblado actual.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
      <summary vsli:raw="Defines a nested type, given its name, attributes, size, and the type that it extends.">Define un tipo anidado, dado su nombre, atributos, tamaño y el tipo que extiende.</summary>
      <param name="name" vsli:raw="The short name of the type. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded null values.">Nombre corto del tipo. <paramref name="name" /> no puede contener valores null insertados.</param>
      <param name="attr" vsli:raw="The attributes of the type.">Atributos del tipo.</param>
      <param name="parent" vsli:raw="The type that the nested type extends.">El tipo que extiende el tipo anidado.</param>
      <param name="packSize" vsli:raw="The packing size of the type.">Tamaño de empaquetado del tipo.</param>
      <param name="typeSize" vsli:raw="The total size of the type.">Tamaño total del tipo.</param>
      <returns vsli:raw="The defined nested type.">El tipo anidado definido.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
      <summary vsli:raw="Defines a nested type, given its name, attributes, the type that it extends, and the interfaces that it implements.">Define un tipo anidado, dados su nombre, sus atributos, el tipo que extiende y las interfaces que implementa.</summary>
      <param name="name" vsli:raw="The short name of the type. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">Nombre corto del tipo. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="attr" vsli:raw="The attributes of the type.">Atributos del tipo.</param>
      <param name="parent" vsli:raw="The type that the nested type extends.">El tipo que extiende el tipo anidado.</param>
      <param name="interfaces" vsli:raw="The interfaces that the nested type implements.">Las interfaces que implementa el tipo anidado.</param>
      <returns vsli:raw="The defined nested type.">El tipo anidado definido.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The nested attribute is not specified.  &#xA;  &#xA; -or-  &#xA;  &#xA; This type is sealed.  &#xA;  &#xA; -or-  &#xA;  &#xA; This type is an array.  &#xA;  &#xA; -or-  &#xA;  &#xA; This type is an interface, but the nested type is not an interface.  &#xA;  &#xA; -or-  &#xA;  &#xA; The length of &lt;paramref name=&quot;name&quot; /&gt; is zero or greater than 1023.  &#xA;  &#xA; -or-  &#xA;  &#xA; This operation would create a type with a duplicate &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.FullName&quot; /&gt; in the current assembly.">No se especificó el atributo anidado.  
O bien 
Este tipo está sellado.  
O bien 
Este tipo es una matriz.  
o bien 
Este tipo es una interfaz, pero el tipo anidado no es una interfaz.  
O bien 
La longitud de <paramref name="name" /> es cero o mayor que 1023.  
O bien 
Esta operación crearía un tipo con un valor de <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> duplicado en el ensamblado actual.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; An element of the &lt;paramref name=&quot;interfaces&quot; /&gt; array is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> es <see langword="null" />.  
O bien 
Un elemento de la matriz <paramref name="interfaces" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
      <summary vsli:raw="Defines a &lt;see langword=&quot;PInvoke&quot; /&gt; method given its name, the name of the DLL in which the method is defined, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, and the &lt;see langword=&quot;PInvoke&quot; /&gt; flags.">Define un método <see langword="PInvoke" /> dado su nombre, el nombre de la DLL en la que se define el método, los atributos del método, la convención de llamada del método, el tipo devuelto del método, los tipos de parámetros del método y las marcas <see langword="PInvoke" />.</summary>
      <param name="name" vsli:raw="The name of the &lt;see langword=&quot;PInvoke&quot; /&gt; method. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">Nombre del método <see langword="PInvoke" />. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="dllName" vsli:raw="The name of the DLL in which the &lt;see langword=&quot;PInvoke&quot; /&gt; method is defined.">Nombre de la DLL en la que está definido el método <see langword="PInvoke" />.</param>
      <param name="attributes" vsli:raw="The attributes of the method.">Atributos del método.</param>
      <param name="callingConvention" vsli:raw="The method's calling convention.">Convención de llamada del método.</param>
      <param name="returnType" vsli:raw="The method's return type.">Tipo de valor devuelto del método.</param>
      <param name="parameterTypes" vsli:raw="The types of the method's parameters.">Tipos de los parámetros del método.</param>
      <param name="nativeCallConv" vsli:raw="The native calling convention.">Convención de llamada nativa.</param>
      <param name="nativeCharSet" vsli:raw="The method's native character set.">Juego de caracteres nativo del método.</param>
      <returns vsli:raw="The defined &lt;see langword=&quot;PInvoke&quot; /&gt; method.">Método <see langword="PInvoke" /> definido.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The method is not static.  &#xA;  &#xA; -or-  &#xA;  &#xA; The parent type is an interface.  &#xA;  &#xA; -or-  &#xA;  &#xA; The method is abstract.  &#xA;  &#xA; -or-  &#xA;  &#xA; The method was previously defined.  &#xA;  &#xA; -or-  &#xA;  &#xA; The length of &lt;paramref name=&quot;name&quot; /&gt; or &lt;paramref name=&quot;dllName&quot; /&gt; is zero.">El método no es estático.  
o bien 
El tipo principal es una interfaz.  
O bien 
Método abstracto.  
o bien 
El método se definió anteriormente.  
o bien 
La longitud de <paramref name="name" /> o <paramref name="dllName" /> es cero.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; or &lt;paramref name=&quot;dllName&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> o <paramref name="dllName" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The containing type has been previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.">Tipo contenedor que se ha creado anteriormente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
      <summary vsli:raw="Defines a &lt;see langword=&quot;PInvoke&quot; /&gt; method given its name, the name of the DLL in which the method is defined, the name of the entry point, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, and the &lt;see langword=&quot;PInvoke&quot; /&gt; flags.">Define un método <see langword="PInvoke" /> dado su nombre, el nombre de la DLL en la que se define el método, el nombre del punto de entrada, los atributos del método, la convención de llamada del método, el tipo devuelto del método, los tipos de parámetros del método y las marcas <see langword="PInvoke" />.</summary>
      <param name="name" vsli:raw="The name of the &lt;see langword=&quot;PInvoke&quot; /&gt; method. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">Nombre del método <see langword="PInvoke" />. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="dllName" vsli:raw="The name of the DLL in which the &lt;see langword=&quot;PInvoke&quot; /&gt; method is defined.">Nombre de la DLL en la que está definido el método <see langword="PInvoke" />.</param>
      <param name="entryName" vsli:raw="The name of the entry point in the DLL.">El nombre del punto de entrada del archivo DLL.</param>
      <param name="attributes" vsli:raw="The attributes of the method.">Atributos del método.</param>
      <param name="callingConvention" vsli:raw="The method's calling convention.">Convención de llamada del método.</param>
      <param name="returnType" vsli:raw="The method's return type.">Tipo de valor devuelto del método.</param>
      <param name="parameterTypes" vsli:raw="The types of the method's parameters.">Tipos de los parámetros del método.</param>
      <param name="nativeCallConv" vsli:raw="The native calling convention.">Convención de llamada nativa.</param>
      <param name="nativeCharSet" vsli:raw="The method's native character set.">Juego de caracteres nativo del método.</param>
      <returns vsli:raw="The defined &lt;see langword=&quot;PInvoke&quot; /&gt; method.">Método <see langword="PInvoke" /> definido.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The method is not static.  &#xA;  &#xA; -or-  &#xA;  &#xA; The parent type is an interface.  &#xA;  &#xA; -or-  &#xA;  &#xA; The method is abstract.  &#xA;  &#xA; -or-  &#xA;  &#xA; The method was previously defined.  &#xA;  &#xA; -or-  &#xA;  &#xA; The length of &lt;paramref name=&quot;name&quot; /&gt;, &lt;paramref name=&quot;dllName&quot; /&gt;, or &lt;paramref name=&quot;entryName&quot; /&gt; is zero.">El método no es estático.  
o bien 
El tipo principal es una interfaz.  
O bien 
Método abstracto.  
o bien 
El método se definió anteriormente.  
o bien 
La longitud de <paramref name="name" />, <paramref name="dllName" /> o <paramref name="entryName" /> es cero.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt;, &lt;paramref name=&quot;dllName&quot; /&gt;, or &lt;paramref name=&quot;entryName&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" />, <paramref name="dllName" /> o <paramref name="entryName" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The containing type has been previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.">Tipo contenedor que se ha creado anteriormente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][])">
      <summary>Define un método <see langword="PInvoke" /> dado su nombre, el nombre de la DLL en la que se define el método, el nombre del punto de entrada, los atributos del método, la convención de llamada del método, el tipo devuelto del método, los tipos de parámetros del método, las marcas <see langword="PInvoke" /> y los modificadores personalizados para los parámetros y el tipo de valor devuelto.</summary>
      <param name="name">Nombre del método <see langword="PInvoke" />. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="dllName">Nombre de la DLL en la que está definido el método <see langword="PInvoke" />.</param>
      <param name="parameterTypeOptionalCustomModifiers">Matriz de matrices de tipos. Cada matriz de tipos representa los modificadores personalizados opcionales para el parámetro correspondiente, como <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un parámetro concreto no tiene modificadores personalizados opcionales, especifique <see langword="null" /> en lugar de una matriz de tipos. Si ninguno de los parámetros tiene modificadores personalizados opcionales, especifique <see langword="null" /> en lugar de una matriz de matrices.</param>
      <param name="nativeCallConv">Convención de llamada nativa.</param>
      <param name="nativeCharSet">Juego de caracteres nativo del método.</param>
      <param name="entryName">El nombre del punto de entrada del archivo DLL.</param>
      <param name="attributes">Atributos del método.</param>
      <param name="callingConvention">Convención de llamada del método.</param>
      <param name="returnType">Tipo de valor devuelto del método.</param>
      <param name="returnTypeRequiredCustomModifiers">Matriz de los tipos que representan los modificadores personalizados necesarios, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para el tipo devuelto del método. Si el tipo de valor devuelto no tiene ningún modificador personalizado requerido, especifique <see langword="null" />.</param>
      <param name="returnTypeOptionalCustomModifiers">Matriz de los tipos que representan los modificadores personalizados opcionales, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para el tipo devuelto del método. Si el tipo de valor devuelto no tiene ningún modificador personalizados opcional, especifique <see langword="null" />.</param>
      <param name="parameterTypes">Tipos de los parámetros del método.</param>
      <param name="parameterTypeRequiredCustomModifiers">Matriz de matrices de tipos. Cada matriz de tipos representa los modificadores personalizados obligatorios para el parámetro correspondiente, como <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un parámetro concreto no tiene modificadores personalizados necesarios, especifique <see langword="null" /> en lugar de una matriz de tipos. Si ninguno de los parámetros tiene modificadores personalizados necesarios, especifique <see langword="null" /> en lugar de una matriz de matrices.</param>
      <returns>
        <see cref="T:System.Reflection.Emit.MethodBuilder" /> que representa el método <see langword="PInvoke" /> definido.</returns>
      <exception cref="T:System.ArgumentException">El método no es estático.  
o bien 
El tipo principal es una interfaz.  
o bien 
Método abstracto.  
o bien 
El método se definió anteriormente.  
o bien 
La longitud de <paramref name="name" />, <paramref name="dllName" />o <paramref name="entryName" /> es cero.  
o bien 
El tamaño de <paramref name="parameterTypeRequiredCustomModifiers" /> o <paramref name="parameterTypeOptionalCustomModifiers" /> no es igual al tamaño de <paramref name="parameterTypes" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" />, <paramref name="dllName" /> o <paramref name="entryName" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
o bien 
Para el tipo dinámico actual, la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> es <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
      <summary vsli:raw="Adds a new property to the type, with the given name, attributes, calling convention, and property signature.">Agrega una nueva propiedad al tipo, con el nombre, atributos, convención de llamada y firma de la propiedad especificados.</summary>
      <param name="name" vsli:raw="The name of the property. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">Nombre de la propiedad. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="attributes" vsli:raw="The attributes of the property.">Atributos de la propiedad.</param>
      <param name="callingConvention" vsli:raw="The calling convention of the property accessors.">Convención de llamada de los descriptores de acceso de la propiedad.</param>
      <param name="returnType" vsli:raw="The return type of the property.">Tipo de valor devuelto de la propiedad.</param>
      <param name="parameterTypes" vsli:raw="The types of the parameters of the property.">Tipos de los parámetros de la propiedad.</param>
      <returns vsli:raw="The defined property.">Propiedad definida.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The length of &lt;paramref name=&quot;name&quot; /&gt; is zero.">La longitud de <paramref name="name" /> es cero.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; Any of the elements of the &lt;paramref name=&quot;parameterTypes&quot; /&gt; array is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> es <see langword="null" />.  
O bien 
Cualquiera de los elementos de la matriz <paramref name="parameterTypes" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The type was previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
      <summary vsli:raw="Adds a new property to the type, with the given name, calling convention, property signature, and custom modifiers.">Agrega una nueva propiedad al tipo, con el nombre proporcionado, la convención de llamada, la firma de la propiedad y los modificadores personalizados.</summary>
      <param name="name" vsli:raw="The name of the property. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">Nombre de la propiedad. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="attributes" vsli:raw="The attributes of the property.">Atributos de la propiedad.</param>
      <param name="callingConvention" vsli:raw="The calling convention of the property accessors.">Convención de llamada de los descriptores de acceso de la propiedad.</param>
      <param name="returnType" vsli:raw="The return type of the property.">Tipo de valor devuelto de la propiedad.</param>
      <param name="returnTypeRequiredCustomModifiers" vsli:raw="An array of types representing the required custom modifiers, such as &lt;see cref=&quot;T:System.Runtime.CompilerServices.IsConst&quot; /&gt;, for the return type of the property. If the return type has no required custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt;.">Matriz de tipos que representan los modificadores personalizados necesarios, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para el tipo devuelto de la propiedad. Si el tipo de valor devuelto no tiene ningún modificador personalizado requerido, especifique <see langword="null" />.</param>
      <param name="returnTypeOptionalCustomModifiers" vsli:raw="An array of types representing the optional custom modifiers, such as &lt;see cref=&quot;T:System.Runtime.CompilerServices.IsConst&quot; /&gt;, for the return type of the property. If the return type has no optional custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt;.">Matriz de los tipos que representan los modificadores personalizados opcionales, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para el tipo devuelto de la propiedad. Si el tipo de valor devuelto no tiene ningún modificador personalizados opcional, especifique <see langword="null" />.</param>
      <param name="parameterTypes" vsli:raw="The types of the parameters of the property.">Tipos de los parámetros de la propiedad.</param>
      <param name="parameterTypeRequiredCustomModifiers" vsli:raw="An array of arrays of types. Each array of types represents the required custom modifiers for the corresponding parameter, such as &lt;see cref=&quot;T:System.Runtime.CompilerServices.IsConst&quot; /&gt;. If a particular parameter has no required custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt; instead of an array of types. If none of the parameters have required custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt; instead of an array of arrays.">Matriz de matrices de tipos. Cada matriz de tipos representa los modificadores personalizados obligatorios para el parámetro correspondiente, como <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un parámetro concreto no tiene modificadores personalizados necesarios, especifique <see langword="null" /> en lugar de una matriz de tipos. Si ninguno de los parámetros tiene modificadores personalizados necesarios, especifique <see langword="null" /> en lugar de una matriz de matrices.</param>
      <param name="parameterTypeOptionalCustomModifiers" vsli:raw="An array of arrays of types. Each array of types represents the optional custom modifiers for the corresponding parameter, such as &lt;see cref=&quot;T:System.Runtime.CompilerServices.IsConst&quot; /&gt;. If a particular parameter has no optional custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt; instead of an array of types. If none of the parameters have optional custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt; instead of an array of arrays.">Matriz de matrices de tipos. Cada matriz de tipos representa los modificadores personalizados opcionales para el parámetro correspondiente, como <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un parámetro concreto no tiene modificadores personalizados opcionales, especifique <see langword="null" /> en lugar de una matriz de tipos. Si ninguno de los parámetros tiene modificadores personalizados opcionales, especifique <see langword="null" /> en lugar de una matriz de matrices.</param>
      <returns vsli:raw="The defined property.">Propiedad definida.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The length of &lt;paramref name=&quot;name&quot; /&gt; is zero.">La longitud de <paramref name="name" /> es cero.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; Any of the elements of the &lt;paramref name=&quot;parameterTypes&quot; /&gt; array is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> es <see langword="null" />.  
O bien 
Cualquiera de los elementos de la matriz <paramref name="parameterTypes" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The type was previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
      <summary vsli:raw="Adds a new property to the type, with the given name and property signature.">Agrega una nueva propiedad al tipo, con el nombre proporcionado y la firma de la propiedad.</summary>
      <param name="name" vsli:raw="The name of the property. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">Nombre de la propiedad. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="attributes" vsli:raw="The attributes of the property.">Atributos de la propiedad.</param>
      <param name="returnType" vsli:raw="The return type of the property.">Tipo de valor devuelto de la propiedad.</param>
      <param name="parameterTypes" vsli:raw="The types of the parameters of the property.">Tipos de los parámetros de la propiedad.</param>
      <returns vsli:raw="The defined property.">Propiedad definida.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The length of &lt;paramref name=&quot;name&quot; /&gt; is zero.">La longitud de <paramref name="name" /> es cero.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; Any of the elements of the &lt;paramref name=&quot;parameterTypes&quot; /&gt; array is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> es <see langword="null" />.  
o bien 
Cualquiera de los elementos de la matriz <paramref name="parameterTypes" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The type was previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
      <summary vsli:raw="Adds a new property to the type, with the given name, property signature, and custom modifiers.">Agrega una nueva propiedad al tipo, con el nombre proporcionado, la firma de la propiedad y los modificadores especificados.</summary>
      <param name="name" vsli:raw="The name of the property. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">Nombre de la propiedad. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="attributes" vsli:raw="The attributes of the property.">Atributos de la propiedad.</param>
      <param name="returnType" vsli:raw="The return type of the property.">Tipo de valor devuelto de la propiedad.</param>
      <param name="returnTypeRequiredCustomModifiers" vsli:raw="An array of types representing the required custom modifiers, such as &lt;see cref=&quot;T:System.Runtime.CompilerServices.IsConst&quot; /&gt;, for the return type of the property. If the return type has no required custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt;.">Matriz de tipos que representan los modificadores personalizados necesarios, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para el tipo devuelto de la propiedad. Si el tipo de valor devuelto no tiene ningún modificador personalizado requerido, especifique <see langword="null" />.</param>
      <param name="returnTypeOptionalCustomModifiers" vsli:raw="An array of types representing the optional custom modifiers, such as &lt;see cref=&quot;T:System.Runtime.CompilerServices.IsConst&quot; /&gt;, for the return type of the property. If the return type has no optional custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt;.">Matriz de los tipos que representan los modificadores personalizados opcionales, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para el tipo devuelto de la propiedad. Si el tipo de valor devuelto no tiene ningún modificador personalizados opcional, especifique <see langword="null" />.</param>
      <param name="parameterTypes" vsli:raw="The types of the parameters of the property.">Tipos de los parámetros de la propiedad.</param>
      <param name="parameterTypeRequiredCustomModifiers" vsli:raw="An array of arrays of types. Each array of types represents the required custom modifiers for the corresponding parameter, such as &lt;see cref=&quot;T:System.Runtime.CompilerServices.IsConst&quot; /&gt;. If a particular parameter has no required custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt; instead of an array of types. If none of the parameters have required custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt; instead of an array of arrays.">Matriz de matrices de tipos. Cada matriz de tipos representa los modificadores personalizados obligatorios para el parámetro correspondiente, como <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un parámetro concreto no tiene modificadores personalizados necesarios, especifique <see langword="null" /> en lugar de una matriz de tipos. Si ninguno de los parámetros tiene modificadores personalizados necesarios, especifique <see langword="null" /> en lugar de una matriz de matrices.</param>
      <param name="parameterTypeOptionalCustomModifiers" vsli:raw="An array of arrays of types. Each array of types represents the optional custom modifiers for the corresponding parameter, such as &lt;see cref=&quot;T:System.Runtime.CompilerServices.IsConst&quot; /&gt;. If a particular parameter has no optional custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt; instead of an array of types. If none of the parameters have optional custom modifiers, specify &lt;see langword=&quot;null&quot; /&gt; instead of an array of arrays.">Matriz de matrices de tipos. Cada matriz de tipos representa los modificadores personalizados opcionales para el parámetro correspondiente, como <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un parámetro concreto no tiene modificadores personalizados opcionales, especifique <see langword="null" /> en lugar de una matriz de tipos. Si ninguno de los parámetros tiene modificadores personalizados opcionales, especifique <see langword="null" /> en lugar de una matriz de matrices.</param>
      <returns vsli:raw="The defined property.">Propiedad definida.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The length of &lt;paramref name=&quot;name&quot; /&gt; is zero.">La longitud de <paramref name="name" /> es cero.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;  &#xA;  &#xA; -or-  &#xA;  &#xA; Any of the elements of the &lt;paramref name=&quot;parameterTypes&quot; /&gt; array is &lt;see langword=&quot;null&quot; /&gt;">
        <paramref name="name" /> es <see langword="null" />  
o bien 
Cualquiera de los elementos de la matriz <paramref name="parameterTypes" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The type was previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer">
      <summary vsli:raw="Defines the initializer for this type.">Define el inicializador para este tipo.</summary>
      <returns vsli:raw="Returns a type initializer.">Devuelve un inicializador de tipo.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The containing type has been previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.">Tipo contenedor que se ha creado anteriormente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
      <summary vsli:raw="Defines an uninitialized data field in the &lt;see langword=&quot;.sdata&quot; /&gt; section of the portable executable (PE) file.">Define un campo de datos inicializado en la sección <see langword=".sdata" /> del archivo portable ejecutable (PE).</summary>
      <param name="name" vsli:raw="The name used to refer to the data. &lt;paramref name=&quot;name&quot; /&gt; cannot contain embedded nulls.">El nombre que se usa para hacer referencia a los datos. <paramref name="name" /> no puede contener valores null insertados.</param>
      <param name="size" vsli:raw="The size of the data field.">Tamaño del campo de datos.</param>
      <param name="attributes" vsli:raw="The attributes for the field.">Los atributos para este campo.</param>
      <returns vsli:raw="A field to reference the data.">Campo para hacer referencia a los datos.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="Length of &lt;paramref name=&quot;name&quot; /&gt; is zero.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;size&quot; /&gt; is less than or equal to zero, or greater than or equal to 0x003f0000.">La longitud de <paramref name="name" /> es cero.  
o bien 
 <paramref name="size" /> es menor o igual que cero, o mayor o igual que 0x003f0000.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The type was previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.FullName">
      <summary vsli:raw="Retrieves the full path of this type.">Recupera la ruta de acceso completa de este tipo.</summary>
      <returns vsli:raw="Read-only. Retrieves the full path of this type.">Sólo lectura. Recupera la ruta de acceso completa de este tipo.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.GenericParameterAttributes">
      <summary vsli:raw="Gets a value that indicates the covariance and special constraints of the current generic type parameter.">Obtiene un valor que indica la covarianza y las restricciones especiales del parámetro de tipo genérico actual.</summary>
      <returns vsli:raw="A bitwise combination of &lt;see cref=&quot;T:System.Reflection.GenericParameterAttributes&quot; /&gt; values that describes the covariance and special constraints of the current generic type parameter.">Combinación bit a bit de valores de <see cref="T:System.Reflection.GenericParameterAttributes" /> que describe la covarianza y las restricciones especiales del parámetro de tipo genérico actual.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.GenericParameterPosition">
      <summary vsli:raw="Gets the position of a type parameter in the type parameter list of the generic type that declared the parameter.">Obtiene la posición de un parámetro de tipo en la lista de parámetros de tipo del tipo genérico que declaró el parámetro.</summary>
      <returns vsli:raw="If the current &lt;see cref=&quot;T:System.Reflection.Emit.TypeBuilder&quot; /&gt; object represents a generic type parameter, the position of the type parameter in the type parameter list of the generic type that declared the parameter; otherwise, undefined.">Si el objeto <see cref="T:System.Reflection.Emit.TypeBuilder" /> actual representa un parámetro de tipo genérico, la posición del parámetro de tipo en la lista de parámetros de tipo del tipo genérico que declaró el parámetro; en otro caso, sin definir.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
      <summary vsli:raw="Returns the constructor of the specified constructed generic type that corresponds to the specified constructor of the generic type definition.">Devuelve el constructor del tipo genérico construido especificado que corresponde al constructor especificado de la definición de tipo genérico.</summary>
      <param name="type" vsli:raw="The constructed generic type whose constructor is returned.">Tipo genérico construido cuyo constructor se devuelve.</param>
      <param name="constructor" vsli:raw="A constructor on the generic type definition of &lt;paramref name=&quot;type&quot; /&gt;, which specifies which constructor of &lt;paramref name=&quot;type&quot; /&gt; to return.">Constructor de la definición de tipo genérico de <paramref name="type" />, que especifica qué constructor de <paramref name="type" /> devolver.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.ConstructorInfo&quot; /&gt; object that represents the constructor of &lt;paramref name=&quot;type&quot; /&gt; corresponding to &lt;paramref name=&quot;constructor&quot; /&gt;, which specifies a constructor belonging to the generic type definition of &lt;paramref name=&quot;type&quot; /&gt;.">Objeto <see cref="T:System.Reflection.ConstructorInfo" /> que representa el constructor de <paramref name="type" /> correspondiente a <paramref name="constructor" />, que especifica un constructor perteneciente a la definición de tipo genérico de <paramref name="type" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;type&quot; /&gt; does not represent a generic type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;type&quot; /&gt; is not of type &lt;see cref=&quot;T:System.Reflection.Emit.TypeBuilder&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The declaring type of &lt;paramref name=&quot;constructor&quot; /&gt; is not a generic type definition.  &#xA;  &#xA; -or-  &#xA;  &#xA; The declaring type of &lt;paramref name=&quot;constructor&quot; /&gt; is not the generic type definition of &lt;paramref name=&quot;type&quot; /&gt;.">
        <paramref name="type" /> no representa un tipo genérico.  
o bien 
 <paramref name="type" /> no es del tipo <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
O bien 
El tipo declarativo de <paramref name="constructor" /> no es una definición de tipo genérico.  
o bien 
El tipo declarativo de <paramref name="constructor" /> no es una definición de tipo genérico de <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)">
      <summary vsli:raw="Returns an array of &lt;see cref=&quot;T:System.Reflection.ConstructorInfo&quot; /&gt; objects representing the public and non-public constructors defined for this class, as specified.">Devuelve una matriz de <see cref="T:System.Reflection.ConstructorInfo" /> objetos que representan los constructores públicos y no públicos definidos para esta clase, tal como se especifica.</summary>
      <param name="bindingAttr" vsli:raw="This must be a bit flag from &lt;see cref=&quot;T:System.Reflection.BindingFlags&quot; /&gt; as in &lt;see langword=&quot;InvokeMethod&quot; /&gt;, &lt;see langword=&quot;NonPublic&quot; /&gt;, and so on.">Debe ser un indicador de bits de <see cref="T:System.Reflection.BindingFlags" />, como en <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
      <returns vsli:raw="Returns an array of &lt;see cref=&quot;T:System.Reflection.ConstructorInfo&quot; /&gt; objects representing the specified constructors defined for this class. If no constructors are defined, an empty array is returned.">Devuelve una matriz de <see cref="T:System.Reflection.ConstructorInfo" /> objetos que representan los constructores especificados definidos para esta clase. Si no se definen constructores, se devuelve una matriz vacía.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not implemented for incomplete types.">Este método no se implementa para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)">
      <summary vsli:raw="Returns all the custom attributes defined for this type.">Devuelve todos los atributos personalizados definidos para este tipo.</summary>
      <param name="inherit" vsli:raw="Specifies whether to search this member's inheritance chain to find the attributes.">Especifica si se debe buscar la cadena de herencia de este miembro para encontrar los atributos.</param>
      <returns vsli:raw="Returns an array of objects representing all the custom attributes of this type.">Devuelve una matriz de objetos que representan todos los atributos personalizados de este tipo.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported for incomplete types. Retrieve the type using &lt;see cref=&quot;M:System.Type.GetType&quot; /&gt; and call &lt;see cref=&quot;M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)&quot; /&gt; on the returned &lt;see cref=&quot;T:System.Type&quot; /&gt;.">Este método no se admite actualmente para tipos incompletos. Recupere el tipo mediante <see cref="M:System.Type.GetType" /> y llame a <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> en el <see cref="T:System.Type" /> devuelto.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary vsli:raw="Returns all the custom attributes of the current type that are assignable to a specified type.">Devuelve todos los atributos personalizados del tipo actual que se pueden asignar a un tipo especificado.</summary>
      <param name="attributeType" vsli:raw="The type of attribute to search for. Only attributes that are assignable to this type are returned.">El tipo de atributo que se va a buscar. Solo se devuelven los atributos que son asignables a este tipo.</param>
      <param name="inherit" vsli:raw="Specifies whether to search this member's inheritance chain to find the attributes.">Especifica si se debe buscar la cadena de herencia de este miembro para encontrar los atributos.</param>
      <returns vsli:raw="An array of custom attributes defined on the current type.">Una matriz de atributos personalizados definidos en el tipo actual.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported for incomplete types. Retrieve the type using &lt;see cref=&quot;M:System.Type.GetType&quot; /&gt; and call &lt;see cref=&quot;M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)&quot; /&gt; on the returned &lt;see cref=&quot;T:System.Type&quot; /&gt;.">Este método no se admite actualmente para tipos incompletos. Recupere el tipo mediante <see cref="M:System.Type.GetType" /> y llame a <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> en el <see cref="T:System.Type" />devuelto.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;attributeType&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="attributeType" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The type must be a type provided by the underlying runtime system.">El tipo debe ser un tipo proporcionado por el sistema en tiempo de ejecución subyacente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetElementType">
      <summary vsli:raw="Calling this method always throws &lt;see cref=&quot;T:System.NotSupportedException&quot; /&gt;.">Cuando se llama a este método, siempre se produce <see cref="T:System.NotSupportedException" />.</summary>
      <returns vsli:raw="This method is not supported. No value is returned.">No se admite este método. No se devuelve ningún valor.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not supported.">No se admite este método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
      <summary vsli:raw="Returns the event with the specified name.">Devuelve el evento con el nombre especificado.</summary>
      <param name="name" vsli:raw="The name of the event to search for.">Nombre del evento que se va a buscar.</param>
      <param name="bindingAttr" vsli:raw="A bitwise combination of &lt;see cref=&quot;T:System.Reflection.BindingFlags&quot; /&gt; values that limits the search.">Combinación bit a bit de valores <see cref="T:System.Reflection.BindingFlags" /> que limita la búsqueda.</param>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Reflection.EventInfo&quot; /&gt; object representing the event declared or inherited by this type with the specified name, or &lt;see langword=&quot;null&quot; /&gt; if there are no matches.">Objeto <see cref="T:System.Reflection.EventInfo" /> que representa el evento declarado o heredado por este tipo con el nombre especificado, o <see langword="null" /> si no hay ninguna coincidencia.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not implemented for incomplete types.">Este método no se implementa para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetEvents">
      <summary vsli:raw="Returns the public events declared or inherited by this type.">Devuelve los eventos públicos declarados o heredados por este tipo.</summary>
      <returns vsli:raw="Returns an array of &lt;see cref=&quot;T:System.Reflection.EventInfo&quot; /&gt; objects representing the public events declared or inherited by this type. An empty array is returned if there are no public events.">Devuelve una matriz de objetos <see cref="T:System.Reflection.EventInfo" /> que representan los eventos públicos declarados o heredados por este tipo. Se devuelve una matriz vacía si no hay eventos públicos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not implemented for incomplete types.">Este método no se implementa para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)">
      <summary vsli:raw="Returns the public and non-public events that are declared by this type.">Devuelve los eventos públicos y no públicos declarados por este tipo.</summary>
      <param name="bindingAttr" vsli:raw="A bitwise combination of &lt;see cref=&quot;T:System.Reflection.BindingFlags&quot; /&gt; values that limits the search.">Combinación bit a bit de valores <see cref="T:System.Reflection.BindingFlags" /> que limita la búsqueda.</param>
      <returns vsli:raw="Returns an array of &lt;see cref=&quot;T:System.Reflection.EventInfo&quot; /&gt; objects representing the events declared or inherited by this type that match the specified binding flags. An empty array is returned if there are no matching events.">Devuelve una matriz de <see cref="T:System.Reflection.EventInfo" /> objetos que representan los eventos declarados o heredados por este tipo que coinciden con los marcadores de enlace especificados. Se devuelve una matriz vacía si no hay eventos coincidentes.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not implemented for incomplete types.">Este método no se implementa para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)">
      <summary vsli:raw="Returns the field specified by the given name.">Devuelve el campo especificado por el nombre facilitado.</summary>
      <param name="name" vsli:raw="The name of the field to get.">Nombre del campo que se va a obtener.</param>
      <param name="bindingAttr" vsli:raw="This must be a bit flag from &lt;see cref=&quot;T:System.Reflection.BindingFlags&quot; /&gt; as in &lt;see langword=&quot;InvokeMethod&quot; /&gt;, &lt;see langword=&quot;NonPublic&quot; /&gt;, and so on.">Debe ser un indicador de bits de <see cref="T:System.Reflection.BindingFlags" />, como en <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
      <returns vsli:raw="Returns the &lt;see cref=&quot;T:System.Reflection.FieldInfo&quot; /&gt; object representing the field declared or inherited by this type with the specified name and public or non-public modifier. If there are no matches then &lt;see langword=&quot;null&quot; /&gt; is returned.">Devuelve el objeto <see cref="T:System.Reflection.FieldInfo" /> que representa el campo declarado o heredado por este tipo con el nombre especificado y el modificador público o no público. Si no existen coincidencias, se devuelve <see langword="null" />.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not implemented for incomplete types.">Este método no se implementa para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
      <summary vsli:raw="Returns the field of the specified constructed generic type that corresponds to the specified field of the generic type definition.">Devuelve el campo del tipo genérico construido especificado que corresponde al campo especificado de la definición de tipo genérico.</summary>
      <param name="type" vsli:raw="The constructed generic type whose field is returned.">Tipo genérico construido cuyo campo se devuelve.</param>
      <param name="field" vsli:raw="A field on the generic type definition of &lt;paramref name=&quot;type&quot; /&gt;, which specifies which field of &lt;paramref name=&quot;type&quot; /&gt; to return.">Campo de la definición de tipo genérico de <paramref name="type" />, que especifica qué campo de <paramref name="type" /> se va a devolver.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.FieldInfo&quot; /&gt; object that represents the field of &lt;paramref name=&quot;type&quot; /&gt; corresponding to &lt;paramref name=&quot;field&quot; /&gt;, which specifies a field belonging to the generic type definition of &lt;paramref name=&quot;type&quot; /&gt;.">Objeto <see cref="T:System.Reflection.FieldInfo" /> que representa el campo de <paramref name="type" /> correspondiente a <paramref name="field" />, que especifica un campo perteneciente a la definición de tipo genérico de <paramref name="type" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;type&quot; /&gt; does not represent a generic type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;type&quot; /&gt; is not of type &lt;see cref=&quot;T:System.Reflection.Emit.TypeBuilder&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The declaring type of &lt;paramref name=&quot;field&quot; /&gt; is not a generic type definition.  &#xA;  &#xA; -or-  &#xA;  &#xA; The declaring type of &lt;paramref name=&quot;field&quot; /&gt; is not the generic type definition of &lt;paramref name=&quot;type&quot; /&gt;.">
        <paramref name="type" /> no representa un tipo genérico.  
o bien 
 <paramref name="type" /> no es del tipo <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
O bien 
El tipo declarativo de <paramref name="field" /> no es una definición de tipo genérico.  
O bien 
El tipo declarativo de <paramref name="field" /> no es una definición de tipo genérico de <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)">
      <summary vsli:raw="Returns the public and non-public fields that are declared by this type.">Devuelve los campos públicos y no públicos declarados por este tipo.</summary>
      <param name="bindingAttr" vsli:raw="This must be a bit flag from &lt;see cref=&quot;T:System.Reflection.BindingFlags&quot; /&gt; : &lt;see langword=&quot;InvokeMethod&quot; /&gt;, &lt;see langword=&quot;NonPublic&quot; /&gt;, and so on.">Debe ser un indicador de bits de <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
      <returns vsli:raw="Returns an array of &lt;see cref=&quot;T:System.Reflection.FieldInfo&quot; /&gt; objects representing the public and non-public fields declared or inherited by this type. An empty array is returned if there are no fields, as specified.">Devuelve una matriz de <see cref="T:System.Reflection.FieldInfo" /> objetos que representan los campos públicos y no públicos declarados o heredados por este tipo. Se devuelve una matriz vacía si no hay ningún campo,  como se especifica.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not implemented for incomplete types.">Este método no se implementa para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments">
      <summary vsli:raw="Returns an array of &lt;see cref=&quot;T:System.Type&quot; /&gt; objects representing the type arguments of a generic type or the type parameters of a generic type definition.">Devuelve una matriz de objetos <see cref="T:System.Type" /> que representan los argumentos de tipo de un tipo genérico o los parámetros de tipo de una definición de tipo genérico.</summary>
      <returns vsli:raw="An array of &lt;see cref=&quot;T:System.Type&quot; /&gt; objects. The elements of the array represent the type arguments of a generic type or the type parameters of a generic type definition.">Matriz de objetos <see cref="T:System.Type" />. Los elementos de la matriz representan los argumentos de tipo de un tipo genérico o los parámetros de tipo de una definición de tipo genérico.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents a generic type definition from which the current type can be obtained.">Devuelve un objeto <see cref="T:System.Type" /> que representa una definición de tipo genérico a partir de la cual se puede obtener el tipo actual.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing a generic type definition from which the current type can be obtained.">Objeto <see cref="T:System.Type" /> que representa una definición de tipo genérico a partir de la cual se puede obtener el tipo actual.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The current type is not generic. That is, &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.IsGenericType&quot; /&gt; returns &lt;see langword=&quot;false&quot; /&gt;.">El tipo actual no es genérico. Es decir, <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> devuelve <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)">
      <summary vsli:raw="Returns the interface implemented (directly or indirectly) by this class with the fully qualified name matching the given interface name.">Devuelve la interfaz implementada por esta clase (directa o indirectamente) con el nombre completo que coincide con el nombre de la interfaz dada.</summary>
      <param name="name" vsli:raw="The name of the interface.">Nombre de la interfaz.</param>
      <param name="ignoreCase" vsli:raw="If &lt;see langword=&quot;true&quot; /&gt;, the search is case-insensitive. If &lt;see langword=&quot;false&quot; /&gt;, the search is case-sensitive.">Si <see langword="true" />, la búsqueda no distingue entre mayúsculas y minúsculas. Si <see langword="false" />, la búsqueda distingue entre mayúsculas y minúsculas.</param>
      <returns vsli:raw="Returns a &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the implemented interface. Returns null if no interface matching name is found.">Devuelve un objeto <see cref="T:System.Type" /> que representa las interfaz implementada. Devuelve null si no se encuentra ningún nombre de interfaz coincidente.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not implemented for incomplete types.">Este método no se implementa para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)">
      <summary vsli:raw="Returns an interface mapping for the requested interface.">Devuelve una asignación de interfaz para la interfaz solicitada.</summary>
      <param name="interfaceType" vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; of the interface for which the mapping is to be retrieved.">
        <see cref="T:System.Type" /> de interfaz para la que se debe recuperar la asignación.</param>
      <returns vsli:raw="Returns the requested interface mapping.">Devuelve la asignación de interfaz solicitada.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not implemented for incomplete types.">Este método no se implementa para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetInterfaces">
      <summary vsli:raw="Returns an array of all the interfaces implemented on this type and its base types.">Devuelve una matriz de todas las interfaces implementadas en este tipo y sus tipos base.</summary>
      <returns vsli:raw="Returns an array of &lt;see cref=&quot;T:System.Type&quot; /&gt; objects representing the implemented interfaces. If none are defined, an empty array is returned.">Devuelve una matriz de objetos <see cref="T:System.Type" /> que representan las interfaces implementadas. Si no hay ninguna definida, se devuelve una matriz vacía.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
      <summary vsli:raw="Returns all the public and non-public members declared or inherited by this type, as specified.">Devuelve todos los miembros públicos y no públicos declarados o heredados por este tipo, tal como se especifica.</summary>
      <param name="name" vsli:raw="The name of the member.">Nombre del miembro.</param>
      <param name="type" vsli:raw="The type of the member to return.">Tipo del miembro que se va a devolver.</param>
      <param name="bindingAttr" vsli:raw="This must be a bit flag from &lt;see cref=&quot;T:System.Reflection.BindingFlags&quot; /&gt;, as in &lt;see langword=&quot;InvokeMethod&quot; /&gt;, &lt;see langword=&quot;NonPublic&quot; /&gt;, and so on.">Debe ser un indicador de bits de <see cref="T:System.Reflection.BindingFlags" />, como en <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
      <returns vsli:raw="Returns an array of &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; objects representing the public and non-public members defined on this type if &lt;paramref name=&quot;nonPublic&quot; /&gt; is used; otherwise, only the public members are returned.">Devuelve una matriz de <see cref="T:System.Reflection.MemberInfo" /> objetos que representan los miembros públicos y no públicos definidos en este tipo si <paramref name="nonPublic" /> se usa; en caso contrario, se devuelven solo los miembros públicos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not implemented for incomplete types.">Este método no se implementa para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)">
      <summary vsli:raw="Returns the members for the public and non-public members declared or inherited by this type.">Devuelve los miembros para los miembros públicos y no públicos declarados o heredados por este tipo.</summary>
      <param name="bindingAttr" vsli:raw="This must be a bit flag from &lt;see cref=&quot;T:System.Reflection.BindingFlags&quot; /&gt;, such as &lt;see langword=&quot;InvokeMethod&quot; /&gt;, &lt;see langword=&quot;NonPublic&quot; /&gt;, and so on.">Debe ser una marca de bits de <see cref="T:System.Reflection.BindingFlags" />, como <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
      <returns vsli:raw="Returns an array of &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; objects representing the public and non-public members declared or inherited by this type. An empty array is returned if there are no matching members.">Devuelve una matriz de objetos <see cref="T:System.Reflection.MemberInfo" /> que representa los miembros públicos y no públicos declarados o heredados por este tipo. Se devuelve una matriz vacía si no hay ningún miembro coincidente.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not implemented for incomplete types.">Este método no se implementa para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
      <summary vsli:raw="Returns the method of the specified constructed generic type that corresponds to the specified method of the generic type definition.">Devuelve el método del tipo genérico construido especificado que corresponde al método especificado de la definición de tipo genérico.</summary>
      <param name="type" vsli:raw="The constructed generic type whose method is returned.">Tipo genérico construido cuyo método se devuelve.</param>
      <param name="method" vsli:raw="A method on the generic type definition of &lt;paramref name=&quot;type&quot; /&gt;, which specifies which method of &lt;paramref name=&quot;type&quot; /&gt; to return.">Método de la definición de tipo genérico de <paramref name="type" />, que especifica qué método de <paramref name="type" /> devolver.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; object that represents the method of &lt;paramref name=&quot;type&quot; /&gt; corresponding to &lt;paramref name=&quot;method&quot; /&gt;, which specifies a method belonging to the generic type definition of &lt;paramref name=&quot;type&quot; /&gt;.">Objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método de <paramref name="type" /> correspondiente a <paramref name="method" />, que especifica un método perteneciente a la definición de tipo genérico de <paramref name="type" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is a generic method that is not a generic method definition.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;type&quot; /&gt; does not represent a generic type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;type&quot; /&gt; is not of type &lt;see cref=&quot;T:System.Reflection.Emit.TypeBuilder&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The declaring type of &lt;paramref name=&quot;method&quot; /&gt; is not a generic type definition.  &#xA;  &#xA; -or-  &#xA;  &#xA; The declaring type of &lt;paramref name=&quot;method&quot; /&gt; is not the generic type definition of &lt;paramref name=&quot;type&quot; /&gt;.">
        <paramref name="method" /> es un método genérico que no es una definición de método genérico.  
o bien 
 <paramref name="type" /> no representa un tipo genérico.  
o bien 
 <paramref name="type" /> no es del tipo <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
O bien 
El tipo declarativo de <paramref name="method" /> no es una definición de tipo genérico.  
O bien 
El tipo declarativo de <paramref name="method" /> no es una definición de tipo genérico de <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)">
      <summary vsli:raw="Returns all the public and non-public methods declared or inherited by this type, as specified.">Devuelve todos los métodos públicos y no públicos declarados o heredados por este tipo, tal como se especifica.</summary>
      <param name="bindingAttr" vsli:raw="This must be a bit flag from &lt;see cref=&quot;T:System.Reflection.BindingFlags&quot; /&gt; as in &lt;see langword=&quot;InvokeMethod&quot; /&gt;, &lt;see langword=&quot;NonPublic&quot; /&gt;, and so on.">Debe ser un indicador de bits de <see cref="T:System.Reflection.BindingFlags" />, como en <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
      <returns vsli:raw="Returns an array of &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; objects representing the public and non-public methods defined on this type if &lt;paramref name=&quot;nonPublic&quot; /&gt; is used; otherwise, only the public methods are returned.">Devuelve una matriz de <see cref="T:System.Reflection.MethodInfo" /> objetos que representan los métodos públicos y no públicos definidos en este tipo si <paramref name="nonPublic" /> se usa; en caso contrario, se devuelven solo los métodos públicos.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not implemented for incomplete types.">Este método no se implementa para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
      <summary vsli:raw="Returns the public and non-public nested types that are declared by this type.">Devuelve los tipos anidados públicos y no públicos declarados por este tipo.</summary>
      <param name="name" vsli:raw="The &lt;see cref=&quot;T:System.String&quot; /&gt; containing the name of the nested type to get.">
        <see cref="T:System.String" /> que contiene el nombre del tipo anidado que se va a obtener.</param>
      <param name="bindingAttr" vsli:raw="A bitmask comprised of one or more &lt;see cref=&quot;T:System.Reflection.BindingFlags&quot; /&gt; that specify how the search is conducted.  &#xA;  &#xA; -or-  &#xA;  &#xA; Zero, to conduct a case-sensitive search for public methods.">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.  
O bien 
Cero, para realizar una búsqueda de los métodos públicos que distinga entre mayúsculas y minúsculas.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the nested type that matches the specified requirements, if found; otherwise, &lt;see langword=&quot;null&quot; /&gt;.">Objeto <see cref="T:System.Type" /> que representa el tipo anidado que cumple los requisitos especificados, si se encuentra; en caso contrario, <see langword="null" />.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not implemented for incomplete types.">Este método no se implementa para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
      <summary vsli:raw="Returns the public and non-public nested types that are declared or inherited by this type.">Devuelve los tipos anidados públicos y no públicos declarados o heredados por este tipo.</summary>
      <param name="bindingAttr" vsli:raw="This must be a bit flag from &lt;see cref=&quot;T:System.Reflection.BindingFlags&quot; /&gt;, as in &lt;see langword=&quot;InvokeMethod&quot; /&gt;, &lt;see langword=&quot;NonPublic&quot; /&gt;, and so on.">Debe ser un indicador de bits de <see cref="T:System.Reflection.BindingFlags" />, como en <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
      <returns vsli:raw="An array of &lt;see cref=&quot;T:System.Type&quot; /&gt; objects representing all the types nested within the current &lt;see cref=&quot;T:System.Type&quot; /&gt; that match the specified binding constraints.  &#xA;  &#xA; An empty array of type &lt;see cref=&quot;T:System.Type&quot; /&gt;, if no types are nested within the current &lt;see cref=&quot;T:System.Type&quot; /&gt;, or if none of the nested types match the binding constraints.">Matriz de objetos <see cref="T:System.Type" /> que representa a todos los tipos anidados del objeto <see cref="T:System.Type" /> actual que coinciden con las restricciones de enlace especificadas.  
Matriz vacía de tipo <see cref="T:System.Type" />, si no hay tipos anidados dentro del actual <see cref="T:System.Type" />, o si ninguno de los tipos anidados coincide con las limitaciones de enlace.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not implemented for incomplete types.">Este método no se implementa para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)">
      <summary vsli:raw="Returns all the public and non-public properties declared or inherited by this type, as specified.">Devuelve todas las propiedades públicas y no públicas declaradas o heredadas por este tipo, como se especifica.</summary>
      <param name="bindingAttr" vsli:raw="This invocation attribute. This must be a bit flag from &lt;see cref=&quot;T:System.Reflection.BindingFlags&quot; /&gt; : &lt;see langword=&quot;InvokeMethod&quot; /&gt;, &lt;see langword=&quot;NonPublic&quot; /&gt;, and so on.">Este atributo de invocación. Debe ser un indicador de bits de <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
      <returns vsli:raw="Returns an array of &lt;see langword=&quot;PropertyInfo&quot; /&gt; objects representing the public and non-public properties defined on this type if &lt;paramref name=&quot;nonPublic&quot; /&gt; is used; otherwise, only the public properties are returned.">Devuelve una matriz de objetos <see langword="PropertyInfo" /> que representan las propiedades públicas y no públicas definidas en este tipo si se usa <paramref name="nonPublic" />; en caso contrario, solo se devuelven las propiedades públicas.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not implemented for incomplete types.">Este método no se implementa para tipos incompletos.</exception>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.GUID">
      <summary vsli:raw="Retrieves the GUID of this type.">Recupera el GUID de este tipo.</summary>
      <returns vsli:raw="Read-only. Retrieves the GUID of this type.">Sólo lectura. Recupera el GUID de este tipo.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported for incomplete types.">Este método no se admite actualmente para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
      <summary vsli:raw="Invokes the specified member. The method that is to be invoked must be accessible and provide the most specific match with the specified argument list, under the constraints of the specified binder and invocation attributes.">Invoca el miembro especificado. El método que se va a invocar debe ser accesible y proporcionar la coincidencia más específica con la lista de argumentos dada, bajo las restricciones del enlazador y los atributos de invocación indicados.</summary>
      <param name="name" vsli:raw="The name of the member to invoke. This can be a constructor, method, property, or field. A suitable invocation attribute must be specified. Note that it is possible to invoke the default member of a class by passing an empty string as the name of the member.">Nombre del miembro que se va a invocar. Puede ser un constructor, un método, una propiedad o un campo. Debe especificarse un atributo de invocación apropiado. Tenga en cuenta que es posible invocar al miembro predeterminado de una clase pasando una cadena vacía como el nombre del miembro.</param>
      <param name="invokeAttr" vsli:raw="The invocation attribute. This must be a bit flag from &lt;see langword=&quot;BindingFlags&quot; /&gt;.">Atributo de invocación. Debe ser un indicador de bits de <see langword="BindingFlags" />.</param>
      <param name="binder" vsli:raw="An object that enables the binding, coercion of argument types, invocation of members, and retrieval of &lt;see langword=&quot;MemberInfo&quot; /&gt; objects using reflection. If binder is &lt;see langword=&quot;null&quot; /&gt;, the default binder is used. See &lt;see cref=&quot;T:System.Reflection.Binder&quot; /&gt;.">Objeto que permite el enlace, la conversión de tipos de argumentos, la invocación de miembros y la recuperación de objetos <see langword="MemberInfo" /> mediante la reflexión. Si el enlazador es <see langword="null" />, se usará el enlazador predeterminado. Vea <see cref="T:System.Reflection.Binder" />.</param>
      <param name="target" vsli:raw="The object on which to invoke the specified member. If the member is static, this parameter is ignored.">Objeto donde debe invocarse al miembro especificado. Si el miembro es estático, se ignora este parámetro.</param>
      <param name="args" vsli:raw="An argument list. This is an array of Objects that contains the number, order, and type of the parameters of the member to be invoked. If there are no parameters this should be null.">Lista de argumentos. Se trata de una matriz de objetos que contiene el número, orden y tipo de los parámetros del miembro que se va a invocar. Si no hay ningún parámetro, este valor debe ser null.</param>
      <param name="modifiers" vsli:raw="An array of the same length as &lt;paramref name=&quot;args&quot; /&gt; with elements that represent the attributes associated with the arguments of the member to be invoked. A parameter has attributes associated with it in the metadata. They are used by various interoperability services. See the metadata specs for more details.">Matriz de la misma longitud que <paramref name="args" /> con elementos que representan los atributos asociados a los argumentos del miembro que se va a invocar. Un parámetro tiene atributos asociados a él en los metadatos. Los usan varios servicios de interoperabilidad. Consulte las especificaciones de metadatos para obtener más detalles.</param>
      <param name="culture" vsli:raw="An instance of &lt;see langword=&quot;CultureInfo&quot; /&gt; used to govern the coercion of types. If this is null, the &lt;see langword=&quot;CultureInfo&quot; /&gt; for the current thread is used. (Note that this is necessary to, for example, convert a String that represents 1000 to a Double value, since 1000 is represented differently by different cultures.)">Instancia de <see langword="CultureInfo" /> usada para regir la conversión de tipos. Si es null, se utiliza <see langword="CultureInfo" /> para el subproceso actual. (Por ejemplo, esto es necesario para convertir un tipo String que representa 1000 en un valor Double, dado que 1000 se representa de manera diferente según la referencia cultural).</param>
      <param name="namedParameters" vsli:raw="Each parameter in the &lt;paramref name=&quot;namedParameters&quot; /&gt; array gets the value in the corresponding element in the &lt;paramref name=&quot;args&quot; /&gt; array. If the length of &lt;paramref name=&quot;args&quot; /&gt; is greater than the length of &lt;paramref name=&quot;namedParameters&quot; /&gt;, the remaining argument values are passed in order.">Cada parámetro de la matriz <paramref name="namedParameters" /> obtiene el valor del elemento correspondiente en la matriz <paramref name="args" />. Si la longitud de <paramref name="args" /> es mayor que la longitud de <paramref name="namedParameters" />, los valores de argumento restantes se pasan por orden.</param>
      <returns vsli:raw="Returns the return value of the invoked member.">Devuelve el valor devuelto del miembro invocado.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported for incomplete types.">Este método no se admite actualmente para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Type)">
      <summary vsli:raw="Gets a value that indicates whether a specified &lt;see cref=&quot;T:System.Type&quot; /&gt; can be assigned to this object.">Obtiene un valor que indica si se puede asignar a este objeto un <see cref="T:System.Type" /> especificado a este objeto.</summary>
      <param name="c" vsli:raw="The object to test.">El objeto que se va a probar.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;paramref name=&quot;c&quot; /&gt; parameter and the current type represent the same type, or if the current type is in the inheritance hierarchy of &lt;paramref name=&quot;c&quot; /&gt;, or if the current type is an interface that &lt;paramref name=&quot;c&quot; /&gt; supports. &lt;see langword=&quot;false&quot; /&gt; if none of these conditions are valid, or if &lt;paramref name=&quot;c&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <see langword="true" /> si el parámetro <paramref name="c" /> y el tipo actual representan el mismo tipo o si el tipo actual está en la jerarquía de herencia de <paramref name="c" />, o bien si el tipo actual es una interfaz que <paramref name="c" /> admite. Es <see langword="false" /> si ninguna de estas condiciones es válida o si <paramref name="c" /> es <see langword="null" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsByRefLike" />
    <member name="P:System.Reflection.Emit.TypeBuilder.IsConstructedGenericType">
      <summary vsli:raw="Gets a value that indicates whether this object represents a constructed generic type.">Obtiene un valor que indica si este objeto representa un tipo genérico construido.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if this object represents a constructed generic type; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si este objeto representa una definición de tipo genérico construido; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.IsCreated">
      <summary vsli:raw="Returns a value that indicates whether the current dynamic type has been created.">Devuelve un valor que indica si se ha creado el tipo dinámico actual.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt; method has been called; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si se ha llamado al método <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
      <summary vsli:raw="Determines whether a custom attribute is applied to the current type.">Determina si un atributo personalizado se aplica al tipo actual.</summary>
      <param name="attributeType" vsli:raw="The type of attribute to search for. Only attributes that are assignable to this type are returned.">El tipo de atributo que se va a buscar. Solo se devuelven los atributos que son asignables a este tipo.</param>
      <param name="inherit" vsli:raw="Specifies whether to search this member's inheritance chain to find the attributes.">Especifica si se debe buscar la cadena de herencia de este miembro para encontrar los atributos.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if one or more instances of &lt;paramref name=&quot;attributeType&quot; /&gt;, or an attribute derived from &lt;paramref name=&quot;attributeType&quot; /&gt;, is defined on this type; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si una o más instancias de <paramref name="attributeType" /> o un atributo derivado de <paramref name="attributeType" /> se definen en este tipo; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="This method is not currently supported for incomplete types. Retrieve the type using &lt;see cref=&quot;M:System.Type.GetType&quot; /&gt; and call &lt;see cref=&quot;M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)&quot; /&gt; on the returned &lt;see cref=&quot;T:System.Type&quot; /&gt;.">Este método no se admite actualmente para tipos incompletos. Recupere el tipo mediante <see cref="M:System.Type.GetType" /> y llame a <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> en el <see cref="T:System.Type" /> devuelto.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;attributeType&quot; /&gt; is not defined.">
        <paramref name="attributeType" /> no está definido.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;attributeType&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="attributeType" /> es <see langword="null" />.</exception>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsGenericParameter">
      <summary vsli:raw="Gets a value indicating whether the current type is a generic type parameter.">Obtiene un valor que indica si el tipo actual es un parámetro de tipo genérico.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current &lt;see cref=&quot;T:System.Reflection.Emit.TypeBuilder&quot; /&gt; object represents a generic type parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el objeto <see cref="T:System.Reflection.Emit.TypeBuilder" /> actual representa un parámetro de tipo genérico; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsGenericType">
      <summary vsli:raw="Gets a value indicating whether the current type is a generic type.">Obtiene un valor que indica si el tipo actual es genérico.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the type represented by the current &lt;see cref=&quot;T:System.Reflection.Emit.TypeBuilder&quot; /&gt; object is generic; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el tipo representado por el objeto <see cref="T:System.Reflection.Emit.TypeBuilder" /> actual es genérico; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition">
      <summary vsli:raw="Gets a value indicating whether the current &lt;see cref=&quot;T:System.Reflection.Emit.TypeBuilder&quot; /&gt; represents a generic type definition from which other generic types can be constructed.">Obtiene un valor que indica si el objeto <see cref="T:System.Reflection.Emit.TypeBuilder" /> actual representa una definición de tipo genérico a partir de la cual se pueden construir otros tipos genéricos.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if this &lt;see cref=&quot;T:System.Reflection.Emit.TypeBuilder&quot; /&gt; object represents a generic type definition; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si este objeto <see cref="T:System.Reflection.Emit.TypeBuilder" /> representa una definición de tipo genérico; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
      <summary vsli:raw="Gets a value that indicates whether the current type is security-critical or security-safe-critical, and therefore can perform critical operations.">Obtiene un valor que indica si el tipo actual es crítico para la seguridad o crítico para la seguridad y disponible desde código transparente y, por tanto, puede realizar operaciones críticas.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current type is security-critical or security-safe-critical; &lt;see langword=&quot;false&quot; /&gt; if it is transparent.">
        <see langword="true" /> si el tipo actual es crítico para la seguridad o crítico para la seguridad y disponible desde código transparente; <see langword="false" /> si es transparente.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="The current dynamic type has not been created by calling the &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt; method.">No se creó el tipo dinámico actual mediante una llamada al método <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
      <summary vsli:raw="Gets a value that indicates whether the current type is security-safe-critical; that is, whether it can perform critical operations and can be accessed by transparent code.">Obtiene un valor que indica si el tipo actual es crítico para la seguridad y disponible desde código transparente; es decir, si puede realizar operaciones críticas y está disponible desde código transparente.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current type is security-safe-critical; &lt;see langword=&quot;false&quot; /&gt; if it is security-critical or transparent.">
        <see langword="true" /> si el tipo actual es crítico para la seguridad y disponible desde código transparente; <see langword="false" /> si es crítico para la seguridad o transparente.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="The current dynamic type has not been created by calling the &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt; method.">No se creó el tipo dinámico actual mediante una llamada al método <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
      <summary vsli:raw="Gets a value that indicates whether the current type is transparent, and therefore cannot perform critical operations.">Obtiene un valor que indica si el tipo actual es transparente y, por tanto, no puede realizar operaciones críticas.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the type is security-transparent; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el tipo es transparente en seguridad; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="The current dynamic type has not been created by calling the &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt; method.">No se creó el tipo dinámico actual mediante una llamada al método <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.IsSubclassOf(System.Type)">
      <summary vsli:raw="Determines whether this type is derived from a specified type.">Determina si este tipo se deriva de un tipo especificado.</summary>
      <param name="c" vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; that is to be checked.">
        <see cref="T:System.Type" /> que se protegerá.</param>
      <returns vsli:raw="Read-only. Returns &lt;see langword=&quot;true&quot; /&gt; if this type is the same as the type &lt;paramref name=&quot;c&quot; /&gt;, or is a subtype of type &lt;paramref name=&quot;c&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Sólo lectura. Devuelve <see langword="true" /> si este tipo es el mismo que el tipo <paramref name="c" />, o es un subtipo del tipo <paramref name="c" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsSZArray" />
    <member name="P:System.Reflection.Emit.TypeBuilder.IsTypeDefinition" />
    <member name="P:System.Reflection.Emit.TypeBuilder.IsVariableBoundArray" />
    <member name="M:System.Reflection.Emit.TypeBuilder.MakeArrayType">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents a one-dimensional array of the current type, with a lower bound of zero.">Devuelve un objeto <see cref="T:System.Type" /> que representa una matriz unidimensional del tipo actual, con un límite inferior de cero.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing a one-dimensional array type whose element type is the current type, with a lower bound of zero.">Un objeto <see cref="T:System.Type" /> que representa un tipo de matriz unidimensional cuyo tipo de elemento es el actual, con un límite inferior de cero.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents an array of the current type, with the specified number of dimensions.">Devuelve un objeto <see cref="T:System.Type" /> que representa una matriz del tipo actual, con el número de dimensiones especificado.</summary>
      <param name="rank" vsli:raw="The number of dimensions for the array.">Número de dimensiones de la matriz.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents a one-dimensional array of the current type.">Objeto <see cref="T:System.Type" /> que representa una matriz unidimensional del tipo actual.</returns>
      <exception cref="T:System.IndexOutOfRangeException" vsli:raw="&lt;paramref name=&quot;rank&quot; /&gt; is not a valid array dimension.">
        <paramref name="rank" /> no es una dimensión de matriz válida.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.MakeByRefType">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents the current type when passed as a &lt;see langword=&quot;ref&quot; /&gt; parameter (&lt;see langword=&quot;ByRef&quot; /&gt; in Visual Basic).">Devuelve un objeto <see cref="T:System.Type" /> que representa el tipo actual cuando se pasa como un parámetro <see langword="ref" /> (<see langword="ByRef" /> en Visual Basic).</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents the current type when passed as a &lt;see langword=&quot;ref&quot; /&gt; parameter (&lt;see langword=&quot;ByRef&quot; /&gt; in Visual Basic).">Objeto <see cref="T:System.Type" /> que representa el tipo actual cuando se pasa como un parámetro <see langword="ref" /> (<see langword="ByRef" /> en Visual Basic).</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
      <summary vsli:raw="Substitutes the elements of an array of types for the type parameters of the current generic type definition, and returns the resulting constructed type.">Sustituye los elementos de una matriz de tipos por los parámetros de tipo de la definición de tipo genérico actual y devuelve el tipo construido resultante.</summary>
      <param name="typeArguments" vsli:raw="An array of types to be substituted for the type parameters of the current generic type definition.">Matriz de tipos que se va a sustituir por los parámetros de la definición del tipo genérico actual.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; representing the constructed type formed by substituting the elements of &lt;paramref name=&quot;typeArguments&quot; /&gt; for the type parameters of the current generic type.">Objeto <see cref="T:System.Type" /> que representa el tipo construido formado al sustituir los elementos de <paramref name="typeArguments" /> por los parámetros del tipo genérico actual.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The current type does not represent the definition of a generic type. That is, &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition&quot; /&gt; returns &lt;see langword=&quot;false&quot; /&gt;.">El tipo actual no representa la definición de un tipo genérico. Es decir, <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> devuelve <see langword="false" />.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;typeArguments&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; Any element of &lt;paramref name=&quot;typeArguments&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="typeArguments" /> es <see langword="null" />.  
O bien 
Cualquier elemento de <paramref name="typeArguments" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;see cref=&quot;P:System.Type.Module&quot; /&gt; property of any element of &lt;paramref name=&quot;typeArguments&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Reflection.Module.Assembly&quot; /&gt; property of the module of any element of &lt;paramref name=&quot;typeArguments&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">La propiedad <see cref="P:System.Type.Module" /> de cualquier elemento de <paramref name="typeArguments" /> es <see langword="null" />.  
o bien 
La propiedad <see cref="P:System.Reflection.Module.Assembly" /> del módulo de cualquier elemento de <paramref name="typeArguments" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.MakePointerType">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents the type of an unmanaged pointer to the current type.">Devuelve un objeto <see cref="T:System.Type" /> que representa el tipo de puntero no administrado para el tipo actual.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents the type of an unmanaged pointer to the current type.">Objeto <see cref="T:System.Type" /> que representa el tipo de puntero no administrado para el tipo actual.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.Module">
      <summary vsli:raw="Retrieves the dynamic module that contains this type definition.">Recupera el módulo dinámico que contiene esta definición de tipo.</summary>
      <returns vsli:raw="Read-only. Retrieves the dynamic module that contains this type definition.">Sólo lectura. Recupera el módulo dinámico que contiene esta definición de tipo.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.Name">
      <summary vsli:raw="Retrieves the name of this type.">Recupera el nombre de este tipo.</summary>
      <returns vsli:raw="Read-only. Retrieves the &lt;see cref=&quot;T:System.String&quot; /&gt; name of this type.">Sólo lectura. Recupera el nombre <see cref="T:System.String" /> de este tipo.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.Namespace">
      <summary vsli:raw="Retrieves the namespace where this &lt;see langword=&quot;TypeBuilder&quot; /&gt; is defined.">Recupera el espacio de nombres donde se define este <see langword="TypeBuilder" />.</summary>
      <returns vsli:raw="Read-only. Retrieves the namespace where this &lt;see langword=&quot;TypeBuilder&quot; /&gt; is defined.">Sólo lectura. Recupera el espacio de nombres donde se define este <see langword="TypeBuilder" /> .</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.PackingSize">
      <summary vsli:raw="Retrieves the packing size of this type.">Recupera el tamaño del empaquetado de este tipo.</summary>
      <returns vsli:raw="Read-only. Retrieves the packing size of this type.">Sólo lectura. Recupera el tamaño del empaquetado de este tipo.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.ReflectedType">
      <summary vsli:raw="Returns the type that was used to obtain this type.">Devuelve el tipo que se utilizó para obtener este tipo.</summary>
      <returns vsli:raw="Read-only. The type that was used to obtain this type.">Sólo lectura. Tipo que se usó para obtener este tipo.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary vsli:raw="Sets a custom attribute using a specified custom attribute blob.">Establece un atributo personalizado mediante un blob de atributo personalizado especificado.</summary>
      <param name="con" vsli:raw="The constructor for the custom attribute.">Constructor para el atributo personalizado.</param>
      <param name="binaryAttribute" vsli:raw="A byte blob representing the attributes.">Blob de bytes que representa los atributos.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;con&quot; /&gt; or &lt;paramref name=&quot;binaryAttribute&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="con" /> o <paramref name="binaryAttribute" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="For the current dynamic type, the &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.IsGenericType&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;, but the &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition&quot; /&gt; property is &lt;see langword=&quot;false&quot; /&gt;.">Para el tipo dinámico actual, la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> es <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary vsli:raw="Set a custom attribute using a custom attribute builder.">Establece un atributo personalizado mediante un generador de atributos personalizado.</summary>
      <param name="customBuilder" vsli:raw="An instance of a helper class to define the custom attribute.">Instancia de una clase del asistente para definir el atributo personalizado.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;customBuilder&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="customBuilder" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="For the current dynamic type, the &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.IsGenericType&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;, but the &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition&quot; /&gt; property is &lt;see langword=&quot;false&quot; /&gt;.">Para el tipo dinámico actual, la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> es <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
      <summary vsli:raw="Sets the base type of the type currently under construction.">Establece el tipo base del tipo actualmente en construcción.</summary>
      <param name="parent" vsli:raw="The new base type.">Nuevo tipo base.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The type was previously created using &lt;see cref=&quot;M:System.Reflection.Emit.TypeBuilder.CreateType&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;parent&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;, and the current instance represents an interface whose attributes do not include &lt;see cref=&quot;F:System.Reflection.TypeAttributes.Abstract&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; For the current dynamic type, the &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.IsGenericType&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;, but the &lt;see cref=&quot;P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition&quot; /&gt; property is &lt;see langword=&quot;false&quot; /&gt;.">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
O bien 
 <paramref name="parent" /> es <see langword="null" /> y la instancia actual representa una interfaz cuyos atributos no incluyen <see cref="F:System.Reflection.TypeAttributes.Abstract" />.  
o bien 
Para el tipo dinámico actual, la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> es <see langword="false" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;parent&quot; /&gt; is an interface. This exception condition is new in the .NET Framework version 2.0.">
        <paramref name="parent" /> es una interfaz. Esta condición de excepción es nueva en la versión 2.0 de .NET Framework.</exception>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.Size">
      <summary vsli:raw="Retrieves the total size of a type.">Recupera el tamaño total de un tipo.</summary>
      <returns vsli:raw="Read-only. Retrieves this type's total size.">Sólo lectura. Recupera el tamaño total de este tipo.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.ToString">
      <summary vsli:raw="Returns the name of the type excluding the namespace.">Devuelve el nombre del tipo, excluido el espacio de nombres.</summary>
      <returns vsli:raw="Read-only. The name of the type excluding the namespace.">Sólo lectura. Nombre del tipo, excluido el espacio de nombres.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.TypeHandle">
      <summary vsli:raw="Not supported in dynamic modules.">No se admite en módulos dinámicos.</summary>
      <returns vsli:raw="Read-only.">Sólo lectura.</returns>
      <exception cref="T:System.NotSupportedException" vsli:raw="Not supported in dynamic modules.">No se admite en módulos dinámicos.</exception>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.UnderlyingSystemType">
      <summary vsli:raw="Returns the underlying system type for this &lt;see langword=&quot;TypeBuilder&quot; /&gt;.">Devuelve el tipo de sistema subyacente para esta <see langword="TypeBuilder" />.</summary>
      <returns vsli:raw="Read-only. Returns the underlying system type.">Sólo lectura. Devuelve el tipo de sistema subyacente.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="This type is an enumeration, but there is no underlying system type.">Este tipo es una enumeración, pero no hay ningún tipo de sistema subyacente.</exception>
    </member>
    <member name="F:System.Reflection.Emit.TypeBuilder.UnspecifiedTypeSize">
      <summary vsli:raw="Represents that total size for the type is not specified.">Representa que no se especifica el tamaño total del tipo.</summary>
    </member>
  </members>
</doc>