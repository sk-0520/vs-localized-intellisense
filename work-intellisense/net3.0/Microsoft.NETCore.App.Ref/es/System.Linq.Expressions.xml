<?xml version="1.0" encoding="utf-8"?>
<doc xmlns:vsli="https://github.com/sk-0520/vs-localized-intellisense/tree/master/schema/2024">
  <assembly>
    <name>System.Linq.Expressions</name>
  </assembly>
  <members>
    <member name="T:System.Dynamic.BinaryOperationBinder">
      <summary vsli:raw="Represents the binary dynamic operation at the call site, providing the binding semantic and the details about the operation.">Representa la operación binaria dinámica en el sitio de la llamada, que proporciona la semántica de los enlaces y los detalles sobre la operación.</summary>
    </member>
    <member name="M:System.Dynamic.BinaryOperationBinder.#ctor(System.Linq.Expressions.ExpressionType)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Dynamic.BinaryOperationBinder&quot; /&gt; class.">Inicializa una nueva instancia de la clase <see cref="T:System.Dynamic.BinaryOperationBinder" />.</summary>
      <param name="operation" vsli:raw="The binary operation kind.">Tipo de operación binaria.</param>
    </member>
    <member name="M:System.Dynamic.BinaryOperationBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic binary operation.">Realiza el enlace de la operación binaria dinámica.</summary>
      <param name="target" vsli:raw="The target of the dynamic operation.">Destino de la operación dinámica.</param>
      <param name="args" vsli:raw="An array of arguments of the dynamic operation.">Matriz de argumentos de la operación dinámica.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.BinaryOperationBinder.FallbackBinaryOperation(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="Performs the binding of the binary dynamic operation if the target dynamic object cannot bind.">Realiza el enlace de la operación binaria dinámica si no puede enlazarse el objeto dinámico de destino.</summary>
      <param name="target" vsli:raw="The target of the dynamic binary operation.">Destino de la operación binaria dinámica.</param>
      <param name="arg" vsli:raw="The right hand side operand of the dynamic binary operation.">Operando del lado derecho de la operación binaria dinámica.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.BinaryOperationBinder.FallbackBinaryOperation(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="When overridden in the derived class, performs the binding of the binary dynamic operation if the target dynamic object cannot bind.">Cuando se reemplaza en la clase derivada, realiza el enlace de la operación binaria dinámica si el objeto dinámico de destino no se puede enlazar.</summary>
      <param name="target" vsli:raw="The target of the dynamic binary operation.">Destino de la operación binaria dinámica.</param>
      <param name="arg" vsli:raw="The right hand side operand of the dynamic binary operation.">Operando del lado derecho de la operación binaria dinámica.</param>
      <param name="errorSuggestion" vsli:raw="The binding result if the binding fails, or null.">Resultado cuando el enlace produce un error, o NULL.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="P:System.Dynamic.BinaryOperationBinder.Operation">
      <summary vsli:raw="The binary operation kind.">Tipo de operación binaria.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; object representing the kind of binary operation.">Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa el tipo de operación binaria.</returns>
    </member>
    <member name="P:System.Dynamic.BinaryOperationBinder.ReturnType">
      <summary vsli:raw="The result type of the operation.">El tipo de resultado de la operación.</summary>
      <returns vsli:raw="The result type of the operation.">El tipo de resultado de la operación.</returns>
    </member>
    <member name="T:System.Dynamic.BindingRestrictions">
      <summary vsli:raw="Represents a set of binding restrictions on the &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; under which the dynamic binding is valid.">Representa un conjunto de restricciones de enlace en la clase <see cref="T:System.Dynamic.DynamicMetaObject" /> bajo la que el enlace dinámico es válido.</summary>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.Combine(System.Collections.Generic.IList{System.Dynamic.DynamicMetaObject})">
      <summary vsli:raw="Combines binding restrictions from the list of &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; instances into one set of restrictions.">Combina las restricciones de enlace de la lista de instancias de <see cref="T:System.Dynamic.DynamicMetaObject" /> en un conjunto de restricciones.</summary>
      <param name="contributingObjects" vsli:raw="The list of &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; instances from which to combine restrictions.">Lista de instancias de <see cref="T:System.Dynamic.DynamicMetaObject" /> a partir de la que se combinan las restricciones.</param>
      <returns vsli:raw="The new set of binding restrictions.">Nuevo conjunto de restricciones de enlace.</returns>
    </member>
    <member name="F:System.Dynamic.BindingRestrictions.Empty">
      <summary vsli:raw="Represents an empty set of binding restrictions. This field is read only.">Representa un conjunto vacío de restricciones de enlace. Este campo es de solo lectura.</summary>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.GetExpressionRestriction(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates the binding restriction that checks the expression for arbitrary immutable properties.">Crea la restricción obligatoria que comprueba la expresión en busca de propiedades inmutables arbitrarias.</summary>
      <param name="expression" vsli:raw="The expression representing the restrictions.">Expresión que representa las restricciones.</param>
      <returns vsli:raw="The new binding restrictions.">Nuevas restricciones de enlace.</returns>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.GetInstanceRestriction(System.Linq.Expressions.Expression,System.Object)">
      <summary vsli:raw="Creates the binding restriction that checks the expression for object instance identity.">Crea la restricción de enlace que comprueba la expresión en busca de la identidad de instancias de objeto.</summary>
      <param name="expression" vsli:raw="The expression to test.">Expresión que se va a comprobar.</param>
      <param name="instance" vsli:raw="The exact object instance to test.">Instancia de objeto exacta que se va a comprobar.</param>
      <returns vsli:raw="The new binding restrictions.">Nuevas restricciones de enlace.</returns>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.GetTypeRestriction(System.Linq.Expressions.Expression,System.Type)">
      <summary vsli:raw="Creates the binding restriction that check the expression for runtime type identity.">Crea la restricción de enlace que comprueba la expresión en busca de la identidad de tipos en tiempo de ejecución.</summary>
      <param name="expression" vsli:raw="The expression to test.">Expresión que se va a comprobar.</param>
      <param name="type" vsli:raw="The exact type to test.">Tipo exacto que se va a comprobar.</param>
      <returns vsli:raw="The new binding restrictions.">Nuevas restricciones de enlace.</returns>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.Merge(System.Dynamic.BindingRestrictions)">
      <summary vsli:raw="Merges the set of binding restrictions with the current binding restrictions.">Combina el conjunto de restricciones de enlace con las restricciones de enlace actuales.</summary>
      <param name="restrictions" vsli:raw="The set of restrictions with which to merge the current binding restrictions.">Conjunto de restricciones de enlace con el que se combinan las restricciones de enlace actuales.</param>
      <returns vsli:raw="The new set of binding restrictions.">Nuevo conjunto de restricciones de enlace.</returns>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.ToExpression">
      <summary vsli:raw="Creates the &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; representing the binding restrictions.">Crea el objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa las restricciones de enlace.</summary>
      <returns vsli:raw="The expression tree representing the restrictions.">Árbol de expresión que representa las restricciones.</returns>
    </member>
    <member name="T:System.Dynamic.CallInfo">
      <summary vsli:raw="Describes arguments in the dynamic binding process.">Describe los argumentos del proceso de enlace dinámico.</summary>
    </member>
    <member name="M:System.Dynamic.CallInfo.#ctor(System.Int32,System.Collections.Generic.IEnumerable{System.String})">
      <summary vsli:raw="Creates a new CallInfo that represents arguments in the dynamic binding process.">Crea una nueva clase CallInfo que representa los argumentos del proceso de enlace dinámico.</summary>
      <param name="argCount" vsli:raw="The number of arguments.">Número de argumentos.</param>
      <param name="argNames" vsli:raw="The argument names.">Nombres de argumento.</param>
    </member>
    <member name="M:System.Dynamic.CallInfo.#ctor(System.Int32,System.String[])">
      <summary vsli:raw="Creates a new &lt;c&gt;PositionalArgumentInfo&lt;/c&gt;.">Crea un nuevo elemento <c>PositionalArgumentInfo</c>.</summary>
      <param name="argCount" vsli:raw="The number of arguments.">Número de argumentos.</param>
      <param name="argNames" vsli:raw="The argument names.">Nombres de argumento.</param>
    </member>
    <member name="P:System.Dynamic.CallInfo.ArgumentCount">
      <summary vsli:raw="The number of arguments.">Número de argumentos.</summary>
      <returns vsli:raw="The number of arguments.">Número de argumentos.</returns>
    </member>
    <member name="P:System.Dynamic.CallInfo.ArgumentNames">
      <summary vsli:raw="The argument names.">Nombres de argumento.</summary>
      <returns vsli:raw="The read-only collection of argument names.">Colección de solo lectura de nombres de argumento.</returns>
    </member>
    <member name="M:System.Dynamic.CallInfo.Equals(System.Object)">
      <summary vsli:raw="Determines whether the specified CallInfo instance is considered equal to the current.">Determina si la instancia de CallInfo especificada se considera igual que la actual.</summary>
      <param name="obj" vsli:raw="The instance of &lt;see cref=&quot;T:System.Dynamic.CallInfo&quot; /&gt; to compare with the current instance.">Instancia de <see cref="T:System.Dynamic.CallInfo" /> que se va a comparar con la instancia actual.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the specified instance is equal to the current one otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es true si la instancia especificada es igual que la actual; de lo contrario, es false.</returns>
    </member>
    <member name="M:System.Dynamic.CallInfo.GetHashCode">
      <summary vsli:raw="Serves as a hash function for the current &lt;see cref=&quot;T:System.Dynamic.CallInfo&quot; /&gt;.">Sirve como función hash para el objeto <see cref="T:System.Dynamic.CallInfo" /> actual.</summary>
      <returns vsli:raw="A hash code for the current &lt;see cref=&quot;T:System.Dynamic.CallInfo&quot; /&gt;.">Código hash para el objeto <see cref="T:System.Dynamic.CallInfo" /> actual.</returns>
    </member>
    <member name="T:System.Dynamic.ConvertBinder">
      <summary vsli:raw="Represents the convert dynamic operation at the call site, providing the binding semantic and the details about the operation.">Representa la operación de conversión dinámica en el sitio de la llamada, que proporciona la semántica de los enlaces y los detalles sobre la operación.</summary>
    </member>
    <member name="M:System.Dynamic.ConvertBinder.#ctor(System.Type,System.Boolean)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Dynamic.ConvertBinder&quot; /&gt;.">Inicializa una nueva instancia de <see cref="T:System.Dynamic.ConvertBinder" />.</summary>
      <param name="type" vsli:raw="The type to convert to.">Tipo al que se va a convertir.</param>
      <param name="explicit" vsli:raw="Is true if the conversion should consider explicit conversions; otherwise, false.">Es true si la conversión debe considerar las conversiones explícitas; de lo contrario, es false.</param>
    </member>
    <member name="M:System.Dynamic.ConvertBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic convert operation.">Realiza el enlace de la operación de conversión dinámica.</summary>
      <param name="target" vsli:raw="The target of the dynamic convert operation.">Destino de la operación de conversión dinámica.</param>
      <param name="args" vsli:raw="An array of arguments of the dynamic convert operation.">Matriz de argumentos de la operación de conversión dinámica.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="P:System.Dynamic.ConvertBinder.Explicit">
      <summary vsli:raw="Gets the value indicating if the conversion should consider explicit conversions.">Obtiene el valor que indica si la conversión debe considerar las conversiones explícitas.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if there is an explicit conversion; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />Si hay una conversión explícita; en caso <see langword="false" />contrario,.</returns>
    </member>
    <member name="M:System.Dynamic.ConvertBinder.FallbackConvert(System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="Performs the binding of the dynamic convert operation if the target dynamic object cannot bind.">Realiza el enlace de la operación de conversión dinámica si no se puede enlazar el objeto dinámico de destino.</summary>
      <param name="target" vsli:raw="The target of the dynamic convert operation.">Destino de la operación de conversión dinámica.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.ConvertBinder.FallbackConvert(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="When overridden in the derived class, performs the binding of the dynamic convert operation if the target dynamic object cannot bind.">Cuando se reemplaza en la clase derivada, realiza el enlace de la operación de conversión dinámica si el objeto dinámico de destino no se puede enlazar.</summary>
      <param name="target" vsli:raw="The target of the dynamic convert operation.">Destino de la operación de conversión dinámica.</param>
      <param name="errorSuggestion" vsli:raw="The binding result to use if binding fails, or null.">Resultado del enlace que se va a usar cuando el enlace produzca un error, o NULL.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="P:System.Dynamic.ConvertBinder.ReturnType">
      <summary vsli:raw="The result type of the operation.">El tipo de resultado de la operación.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the result type of the operation.">Objeto <see cref="T:System.Type" /> que representa el tipo de resultado de la operación.</returns>
    </member>
    <member name="P:System.Dynamic.ConvertBinder.Type">
      <summary vsli:raw="The type to convert to.">Tipo al que se va a convertir.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents the type to convert to.">Objeto <see cref="T:System.Type" /> que representa el tipo en el que se va a convertir.</returns>
    </member>
    <member name="T:System.Dynamic.CreateInstanceBinder">
      <summary vsli:raw="Represents the dynamic create operation at the call site, providing the binding semantic and the details about the operation.">Representa la operación de creación dinámica en el sitio de la llamada, que proporciona la semántica de los enlaces y los detalles sobre la operación.</summary>
    </member>
    <member name="M:System.Dynamic.CreateInstanceBinder.#ctor(System.Dynamic.CallInfo)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Dynamic.CreateInstanceBinder&quot; /&gt;.">Inicializa una nueva instancia de <see cref="T:System.Dynamic.CreateInstanceBinder" />.</summary>
      <param name="callInfo" vsli:raw="The signature of the arguments at the call site.">Firma de los argumentos en el sitio de llamada.</param>
    </member>
    <member name="M:System.Dynamic.CreateInstanceBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic create operation.">Realiza el enlace de la operación de creación dinámica.</summary>
      <param name="target" vsli:raw="The target of the dynamic create operation.">Destino de la operación de creación dinámica.</param>
      <param name="args" vsli:raw="An array of arguments of the dynamic create operation.">Matriz de argumentos de la operación de creación dinámica.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="P:System.Dynamic.CreateInstanceBinder.CallInfo">
      <summary vsli:raw="Gets the signature of the arguments at the call site.">Obtiene la firma de los argumentos en el sitio de llamada.</summary>
      <returns vsli:raw="The signature of the arguments at the call site.">Firma de los argumentos en el sitio de llamada.</returns>
    </member>
    <member name="M:System.Dynamic.CreateInstanceBinder.FallbackCreateInstance(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic create operation if the target dynamic object cannot bind.">Realiza el enlace de la operación de creación dinámica si el objeto dinámico de destino no se puede enlazar.</summary>
      <param name="target" vsli:raw="The target of the dynamic create operation.">Destino de la operación de creación dinámica.</param>
      <param name="args" vsli:raw="The arguments of the dynamic create operation.">Argumentos de la operación de creación dinámica.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.CreateInstanceBinder.FallbackCreateInstance(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="When overridden in the derived class, performs the binding of the dynamic create operation if the target dynamic object cannot bind.">Cuando se reemplaza en la clase derivada, realiza el enlace de la operación de creación dinámica si el objeto dinámico de destino no se puede enlazar.</summary>
      <param name="target" vsli:raw="The target of the dynamic create operation.">Destino de la operación de creación dinámica.</param>
      <param name="args" vsli:raw="The arguments of the dynamic create operation.">Argumentos de la operación de creación dinámica.</param>
      <param name="errorSuggestion" vsli:raw="The binding result to use if binding fails, or null.">Resultado del enlace que se va a usar cuando el enlace produzca un error, o NULL.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="P:System.Dynamic.CreateInstanceBinder.ReturnType">
      <summary vsli:raw="The result type of the operation.">El tipo de resultado de la operación.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the result type of the operation.">Objeto <see cref="T:System.Type" /> que representa el tipo de resultado de la operación.</returns>
    </member>
    <member name="T:System.Dynamic.DeleteIndexBinder">
      <summary vsli:raw="Represents the dynamic delete index operation at the call site, providing the binding semantic and the details about the operation.">Representa la operación de eliminación de índice dinámica en el sitio de llamada, proporcionando la semántica del enlace y los detalles sobre la operación.</summary>
    </member>
    <member name="M:System.Dynamic.DeleteIndexBinder.#ctor(System.Dynamic.CallInfo)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Dynamic.DeleteIndexBinder&quot; /&gt;.">Inicializa una nueva instancia de <see cref="T:System.Dynamic.DeleteIndexBinder" />.</summary>
      <param name="callInfo" vsli:raw="The signature of the arguments at the call site.">Firma de los argumentos en el sitio de llamada.</param>
    </member>
    <member name="M:System.Dynamic.DeleteIndexBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic delete index operation.">Realiza el enlace de la operación de eliminación de índice dinámica.</summary>
      <param name="target" vsli:raw="The target of the dynamic delete index operation.">Destino de la operación de eliminación de índice dinámica.</param>
      <param name="args" vsli:raw="An array of arguments of the dynamic delete index operation.">Matriz de argumentos de la operación de eliminación de índice dinámica.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="P:System.Dynamic.DeleteIndexBinder.CallInfo">
      <summary vsli:raw="Gets the signature of the arguments at the call site.">Obtiene la firma de los argumentos en el sitio de llamada.</summary>
      <returns vsli:raw="The signature of the arguments at the call site.">Firma de los argumentos en el sitio de llamada.</returns>
    </member>
    <member name="M:System.Dynamic.DeleteIndexBinder.FallbackDeleteIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic delete index operation if the target dynamic object cannot bind.">Realiza el enlace de la operación de eliminación de índice dinámica si el objeto dinámico de destino no se puede enlazar.</summary>
      <param name="target" vsli:raw="The target of the dynamic delete index operation.">Destino de la operación de eliminación de índice dinámica.</param>
      <param name="indexes" vsli:raw="The arguments of the dynamic delete index operation.">Argumentos de la operación de eliminación de índice dinámica.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.DeleteIndexBinder.FallbackDeleteIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="When overridden in the derived class, performs the binding of the dynamic delete index operation if the target dynamic object cannot bind.">Cuando se reemplaza en la clase derivada, realiza el enlace de la operación de eliminación de índice dinámica si el objeto dinámico de destino no se puede enlazar.</summary>
      <param name="target" vsli:raw="The target of the dynamic delete index operation.">Destino de la operación de eliminación de índice dinámica.</param>
      <param name="indexes" vsli:raw="The arguments of the dynamic delete index operation.">Argumentos de la operación de eliminación de índice dinámica.</param>
      <param name="errorSuggestion" vsli:raw="The binding result to use if binding fails, or null.">Resultado del enlace que se va a usar cuando el enlace produzca un error, o NULL.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="P:System.Dynamic.DeleteIndexBinder.ReturnType">
      <summary vsli:raw="The result type of the operation.">El tipo de resultado de la operación.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the result type of the operation.">Objeto <see cref="T:System.Type" /> que representa el tipo de resultado de la operación.</returns>
    </member>
    <member name="T:System.Dynamic.DeleteMemberBinder">
      <summary vsli:raw="Represents the dynamic delete member operation at the call site, providing the binding semantic and the details about the operation.">Representa la operación de eliminación de miembros dinámica en el sitio de llamada, y proporciona la semántica del enlace y los detalles sobre la operación.</summary>
    </member>
    <member name="M:System.Dynamic.DeleteMemberBinder.#ctor(System.String,System.Boolean)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Dynamic.DeleteIndexBinder&quot; /&gt;.">Inicializa una nueva instancia de <see cref="T:System.Dynamic.DeleteIndexBinder" />.</summary>
      <param name="name" vsli:raw="The name of the member to delete.">Nombre del miembro que se va a eliminar.</param>
      <param name="ignoreCase" vsli:raw="Is true if the name should be matched ignoring case; false otherwise.">Es true si no se debe distinguir entre mayúsculas y minúsculas en la comparación; de lo contrario, es false.</param>
    </member>
    <member name="M:System.Dynamic.DeleteMemberBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic delete member operation.">Realiza el enlace de la operación de eliminación de miembros dinámica.</summary>
      <param name="target" vsli:raw="The target of the dynamic delete member operation.">Destino de la operación de eliminación de miembros dinámica.</param>
      <param name="args" vsli:raw="An array of arguments of the dynamic delete member operation.">Una matriz de argumentos de la operación de eliminación de miembros dinámica.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.DeleteMemberBinder.FallbackDeleteMember(System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="Performs the binding of the dynamic delete member operation if the target dynamic object cannot bind.">Realiza el enlace de la operación de eliminación de miembros dinámica si no puede enlazarse el objeto dinámico de destino.</summary>
      <param name="target" vsli:raw="The target of the dynamic delete member operation.">Destino de la operación de eliminación de miembros dinámica.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.DeleteMemberBinder.FallbackDeleteMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="When overridden in the derived class, performs the binding of the dynamic delete member operation if the target dynamic object cannot bind.">Cuando se reemplaza en la clase derivada, realiza el enlace de la operación de eliminación de miembros dinámica si el objeto dinámico de destino no se puede enlazar.</summary>
      <param name="target" vsli:raw="The target of the dynamic delete member operation.">Destino de la operación de eliminación de miembros dinámica.</param>
      <param name="errorSuggestion" vsli:raw="The binding result to use if binding fails, or null.">Resultado del enlace que se va a usar cuando el enlace produzca un error, o NULL.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="P:System.Dynamic.DeleteMemberBinder.IgnoreCase">
      <summary vsli:raw="Gets the value indicating if the string comparison should ignore the case of the member name.">Obtiene el valor que indica si la comparación de cadena no debe distinguir entre mayúsculas y minúsculas en el nombre del miembro.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the string comparison should ignore case; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />Si la comparación de cadenas debe omitir mayúsculas y minúsculas; en caso <see langword="false" />contrario,.</returns>
    </member>
    <member name="P:System.Dynamic.DeleteMemberBinder.Name">
      <summary vsli:raw="Gets the name of the member to delete.">Obtiene el nombre del miembro que se va a eliminar.</summary>
      <returns vsli:raw="The name of the member to delete.">Nombre del miembro que se va a eliminar.</returns>
    </member>
    <member name="P:System.Dynamic.DeleteMemberBinder.ReturnType">
      <summary vsli:raw="The result type of the operation.">El tipo de resultado de la operación.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the result type of the operation.">Objeto <see cref="T:System.Type" /> que representa el tipo de resultado de la operación.</returns>
    </member>
    <member name="T:System.Dynamic.DynamicMetaObject">
      <summary vsli:raw="Represents the dynamic binding and a binding logic of an object participating in the dynamic binding.">Representa el enlace dinámico y una lógica de enlace de un objeto que participa en el enlace dinámico.</summary>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.#ctor(System.Linq.Expressions.Expression,System.Dynamic.BindingRestrictions)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; class.">Inicializa una nueva instancia de la clase <see cref="T:System.Dynamic.DynamicMetaObject" />.</summary>
      <param name="expression" vsli:raw="The expression representing this &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; during the dynamic binding process.">Expresión que representa este objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> durante el proceso de enlace dinámico.</param>
      <param name="restrictions" vsli:raw="The set of binding restrictions under which the binding is valid.">Conjunto de restricciones de enlace en las que el enlace es válido.</param>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.#ctor(System.Linq.Expressions.Expression,System.Dynamic.BindingRestrictions,System.Object)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; class.">Inicializa una nueva instancia de la clase <see cref="T:System.Dynamic.DynamicMetaObject" />.</summary>
      <param name="expression" vsli:raw="The expression representing this &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; during the dynamic binding process.">Expresión que representa este objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> durante el proceso de enlace dinámico.</param>
      <param name="restrictions" vsli:raw="The set of binding restrictions under which the binding is valid.">Conjunto de restricciones de enlace en las que el enlace es válido.</param>
      <param name="value" vsli:raw="The runtime value represented by the &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt;.">Valor en tiempo de ejecución representado por el parámetro <see cref="T:System.Dynamic.DynamicMetaObject" />.</param>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="Performs the binding of the dynamic binary operation.">Realiza el enlace de la operación binaria dinámica.</summary>
      <param name="binder" vsli:raw="An instance of the &lt;see cref=&quot;T:System.Dynamic.BinaryOperationBinder&quot; /&gt; that represents the details of the dynamic operation.">Instancia de la clase <see cref="T:System.Dynamic.BinaryOperationBinder" /> que representa los detalles de la operación dinámica.</param>
      <param name="arg" vsli:raw="An instance of the &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the right hand side of the binary operation.">Una instancia de <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el lado derecho de la operación binaria.</param>
      <returns vsli:raw="The new &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">Nuevo objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindConvert(System.Dynamic.ConvertBinder)">
      <summary vsli:raw="Performs the binding of the dynamic conversion operation.">Realiza el enlace de la operación de conversión dinámica.</summary>
      <param name="binder" vsli:raw="An instance of the &lt;see cref=&quot;T:System.Dynamic.ConvertBinder&quot; /&gt; that represents the details of the dynamic operation.">Instancia de la clase <see cref="T:System.Dynamic.ConvertBinder" /> que representa los detalles de la operación dinámica.</param>
      <returns vsli:raw="The new &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">Nuevo objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindCreateInstance(System.Dynamic.CreateInstanceBinder,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic create instance operation.">Realiza el enlace de la operación de creación de instancias dinámica.</summary>
      <param name="binder" vsli:raw="An instance of the &lt;see cref=&quot;T:System.Dynamic.CreateInstanceBinder&quot; /&gt; that represents the details of the dynamic operation.">Instancia de la clase <see cref="T:System.Dynamic.CreateInstanceBinder" /> que representa los detalles de la operación dinámica.</param>
      <param name="args" vsli:raw="An array of &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; instances - arguments to the create instance operation.">Una matriz de instancias de <see cref="T:System.Dynamic.DynamicMetaObject" />: argumentos para crear la operación de creación de instancias.</param>
      <returns vsli:raw="The new &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">Nuevo objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic delete index operation.">Realiza el enlace de la operación de eliminación de índice dinámica.</summary>
      <param name="binder" vsli:raw="An instance of the &lt;see cref=&quot;T:System.Dynamic.DeleteIndexBinder&quot; /&gt; that represents the details of the dynamic operation.">Instancia de la clase <see cref="T:System.Dynamic.DeleteIndexBinder" /> que representa los detalles de la operación dinámica.</param>
      <param name="indexes" vsli:raw="An array of &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; instances - indexes for the delete index operation.">Una matriz de instancias de <see cref="T:System.Dynamic.DynamicMetaObject" />: índices para la operación de eliminación de índice.</param>
      <returns vsli:raw="The new &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">Nuevo objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindDeleteMember(System.Dynamic.DeleteMemberBinder)">
      <summary vsli:raw="Performs the binding of the dynamic delete member operation.">Realiza el enlace de la operación de eliminación de miembros dinámica.</summary>
      <param name="binder" vsli:raw="An instance of the &lt;see cref=&quot;T:System.Dynamic.DeleteMemberBinder&quot; /&gt; that represents the details of the dynamic operation.">Instancia de la clase <see cref="T:System.Dynamic.DeleteMemberBinder" /> que representa los detalles de la operación dinámica.</param>
      <returns vsli:raw="The new &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">Nuevo objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindGetIndex(System.Dynamic.GetIndexBinder,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic get index operation.">Realiza el enlace de la operación de obtención de índice dinámica.</summary>
      <param name="binder" vsli:raw="An instance of the &lt;see cref=&quot;T:System.Dynamic.GetIndexBinder&quot; /&gt; that represents the details of the dynamic operation.">Instancia de la clase <see cref="T:System.Dynamic.GetIndexBinder" /> que representa los detalles de la operación dinámica.</param>
      <param name="indexes" vsli:raw="An array of &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; instances - indexes for the get index operation.">Una matriz de instancias de <see cref="T:System.Dynamic.DynamicMetaObject" />: índices para la operación de obtención de índice.</param>
      <returns vsli:raw="The new &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">Nuevo objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindGetMember(System.Dynamic.GetMemberBinder)">
      <summary vsli:raw="Performs the binding of the dynamic get member operation.">Realiza el enlace de la operación de obtención de miembros dinámica.</summary>
      <param name="binder" vsli:raw="An instance of the &lt;see cref=&quot;T:System.Dynamic.GetMemberBinder&quot; /&gt; that represents the details of the dynamic operation.">Instancia de la clase <see cref="T:System.Dynamic.GetMemberBinder" /> que representa los detalles de la operación dinámica.</param>
      <returns vsli:raw="The new &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">Nuevo objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindInvoke(System.Dynamic.InvokeBinder,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic invoke operation.">Realiza el enlace de la operación de invocación dinámica.</summary>
      <param name="binder" vsli:raw="An instance of the &lt;see cref=&quot;T:System.Dynamic.InvokeBinder&quot; /&gt; that represents the details of the dynamic operation.">Instancia de la clase <see cref="T:System.Dynamic.InvokeBinder" /> que representa los detalles de la operación dinámica.</param>
      <param name="args" vsli:raw="An array of &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; instances - arguments to the invoke operation.">Matriz de instancias de <see cref="T:System.Dynamic.DynamicMetaObject" />: argumentos para la operación de invocación.</param>
      <returns vsli:raw="The new &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">Nuevo objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindInvokeMember(System.Dynamic.InvokeMemberBinder,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic invoke member operation.">Realiza el enlace de la operación de invocación de miembros dinámica.</summary>
      <param name="binder" vsli:raw="An instance of the &lt;see cref=&quot;T:System.Dynamic.InvokeMemberBinder&quot; /&gt; that represents the details of the dynamic operation.">Instancia de la clase <see cref="T:System.Dynamic.InvokeMemberBinder" /> que representa los detalles de la operación dinámica.</param>
      <param name="args" vsli:raw="An array of &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; instances - arguments to the invoke member operation.">Matriz de instancias de <see cref="T:System.Dynamic.DynamicMetaObject" />: argumentos para la operación de invocación de miembros.</param>
      <returns vsli:raw="The new &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">Nuevo objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindSetIndex(System.Dynamic.SetIndexBinder,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="Performs the binding of the dynamic set index operation.">Realiza el enlace de la operación de establecimiento de índice dinámica.</summary>
      <param name="binder" vsli:raw="An instance of the &lt;see cref=&quot;T:System.Dynamic.SetIndexBinder&quot; /&gt; that represents the details of the dynamic operation.">Instancia de la clase <see cref="T:System.Dynamic.SetIndexBinder" /> que representa los detalles de la operación dinámica.</param>
      <param name="indexes" vsli:raw="An array of &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; instances - indexes for the set index operation.">Una matriz de instancias de <see cref="T:System.Dynamic.DynamicMetaObject" />: índices para la operación de establecimiento de índice.</param>
      <param name="value" vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the value for the set index operation.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el valor para la operación de establecimiento de índice.</param>
      <returns vsli:raw="The new &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">Nuevo objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindSetMember(System.Dynamic.SetMemberBinder,System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="Performs the binding of the dynamic set member operation.">Realiza el enlace de la operación de establecimiento de miembros dinámica.</summary>
      <param name="binder" vsli:raw="An instance of the &lt;see cref=&quot;T:System.Dynamic.SetMemberBinder&quot; /&gt; that represents the details of the dynamic operation.">Instancia de la clase <see cref="T:System.Dynamic.SetMemberBinder" /> que representa los detalles de la operación dinámica.</param>
      <param name="value" vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the value for the set member operation.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el valor para la operación de establecimiento de miembros.</param>
      <returns vsli:raw="The new &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">Nuevo objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindUnaryOperation(System.Dynamic.UnaryOperationBinder)">
      <summary vsli:raw="Performs the binding of the dynamic unary operation.">Realiza el enlace de la operación unaria dinámica.</summary>
      <param name="binder" vsli:raw="An instance of the &lt;see cref=&quot;T:System.Dynamic.UnaryOperationBinder&quot; /&gt; that represents the details of the dynamic operation.">Instancia de la clase <see cref="T:System.Dynamic.UnaryOperationBinder" /> que representa los detalles de la operación dinámica.</param>
      <returns vsli:raw="The new &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">Nuevo objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.Create(System.Object,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a meta-object for the specified object.">Crea un metaobjeto para el objeto especificado.</summary>
      <param name="value" vsli:raw="The object to get a meta-object for.">Objeto para el que se va a obtener un metaobjeto.</param>
      <param name="expression" vsli:raw="The expression representing this &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; during the dynamic binding process.">Expresión que representa este objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> durante el proceso de enlace dinámico.</param>
      <returns vsli:raw="If the given object implements &lt;see cref=&quot;T:System.Dynamic.IDynamicMetaObjectProvider&quot; /&gt; and is not a remote object from outside the current AppDomain, returns the object's specific meta-object returned by &lt;see cref=&quot;M:System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(System.Linq.Expressions.Expression)&quot; /&gt;. Otherwise a plain new meta-object with no restrictions is created and returned.">Si el objeto especificado implementa <see cref="T:System.Dynamic.IDynamicMetaObjectProvider" /> y no es un objeto remoto de fuera del AppDomain actual, devuelve el metaobjeto específico del objeto devuelto por el método <see cref="M:System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(System.Linq.Expressions.Expression)" />. De lo contrario, se crea y se devuelve un nuevo metaobjeto sin formato y sin restricciones.</returns>
    </member>
    <member name="F:System.Dynamic.DynamicMetaObject.EmptyMetaObjects">
      <summary vsli:raw="Represents an empty array of type &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt;. This field is read only.">Representa una matriz vacía de tipo <see cref="T:System.Dynamic.DynamicMetaObject" />. Este campo es de solo lectura.</summary>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.Expression">
      <summary vsli:raw="The expression representing the &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; during the dynamic binding process.">Expresión que representa el objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> durante el proceso de enlace dinámico.</summary>
      <returns vsli:raw="The expression representing the &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; during the dynamic binding process.">Expresión que representa el objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> durante el proceso de enlace dinámico.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.GetDynamicMemberNames">
      <summary vsli:raw="Returns the enumeration of all dynamic member names.">Devuelve la enumeración de todos los nombres de miembro dinámicos.</summary>
      <returns vsli:raw="The list of dynamic member names.">Lista de nombres de miembro dinámicos.</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.HasValue">
      <summary vsli:raw="Gets a value indicating whether the &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; has the runtime value.">Obtiene un valor que indica si <see cref="T:System.Dynamic.DynamicMetaObject" /> tiene el valor en tiempo de ejecución.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; has the runtime value; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />Si tiene el valor en tiempo de ejecución; en caso contrario, <see langword="false" />. <see cref="T:System.Dynamic.DynamicMetaObject" /></returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.LimitType">
      <summary vsli:raw="Gets the limit type of the &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt;.">Obtiene el tipo de límite del objeto <see cref="T:System.Dynamic.DynamicMetaObject" />.</summary>
      <returns vsli:raw="&lt;see cref=&quot;P:System.Dynamic.DynamicMetaObject.RuntimeType&quot; /&gt; if runtime value is available, a type of the &lt;see cref=&quot;P:System.Dynamic.DynamicMetaObject.Expression&quot; /&gt; otherwise.">
        <see cref="P:System.Dynamic.DynamicMetaObject.RuntimeType" /> si el valor en tiempo de ejecución está disponible; de lo contrario, un tipo de la propiedad <see cref="P:System.Dynamic.DynamicMetaObject.Expression" />.</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.Restrictions">
      <summary vsli:raw="The set of binding restrictions under which the binding is valid.">Conjunto de restricciones de enlace en las que el enlace es válido.</summary>
      <returns vsli:raw="The set of binding restrictions.">Conjunto de restricciones de enlace.</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.RuntimeType">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Type&quot; /&gt; of the runtime value or null if the &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; has no value associated with it.">Obtiene el objeto <see cref="T:System.Type" /> del valor en tiempo de ejecución, o NULL si <see cref="T:System.Dynamic.DynamicMetaObject" /> no tiene ningún valor asociado.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; of the runtime value or null.">
        <see cref="T:System.Type" /> del valor en tiempo de ejecución o NULL.</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.Value">
      <summary vsli:raw="The runtime value represented by this &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt;.">Valor en tiempo de ejecución representado por el objeto <see cref="T:System.Dynamic.DynamicMetaObject" />.</summary>
      <returns vsli:raw="The runtime value represented by this &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt;.">Valor en tiempo de ejecución representado por el objeto <see cref="T:System.Dynamic.DynamicMetaObject" />.</returns>
    </member>
    <member name="T:System.Dynamic.DynamicMetaObjectBinder">
      <summary vsli:raw="The dynamic call site binder that participates in the &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; binding protocol.">Enlazador de sitio de llamada dinámico que participa en el protocolo de enlace <see cref="T:System.Dynamic.DynamicMetaObject" />.</summary>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObjectBinder&quot; /&gt; class.">Inicializa una nueva instancia de la clase <see cref="T:System.Dynamic.DynamicMetaObjectBinder" />.</summary>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="When overridden in the derived class, performs the binding of the dynamic operation.">Cuando se reemplaza en la clase derivada, realiza el enlace de la operación dinámica.</summary>
      <param name="target" vsli:raw="The target of the dynamic operation.">Destino de la operación dinámica.</param>
      <param name="args" vsli:raw="An array of arguments of the dynamic operation.">Matriz de argumentos de la operación dinámica.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.Bind(System.Object[],System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.LabelTarget)">
      <summary vsli:raw="Performs the runtime binding of the dynamic operation on a set of arguments.">Realiza el enlace en tiempo de ejecución de la operación dinámica sobre un conjunto de argumentos.</summary>
      <param name="args" vsli:raw="An array of arguments to the dynamic operation.">Matriz de argumentos de la operación dinámica.</param>
      <param name="parameters" vsli:raw="The array of &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; instances that represent the parameters of the call site in the binding process.">Matriz de instancias de <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representan los parámetros del sitio de llamada en el proceso de enlace.</param>
      <param name="returnLabel" vsli:raw="A LabelTarget used to return the result of the dynamic binding.">Objeto LabelTarget utilizado para devolver el resultado del enlace dinámico.</param>
      <returns vsli:raw="An Expression that performs tests on the dynamic operation arguments, and performs the dynamic operation if the tests are valid. If the tests fail on subsequent occurrences of the dynamic operation, Bind will be called again to produce a new &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; for the new argument types.">Expresión que realiza pruebas sobre los argumentos de la operación dinámica y realiza la operación dinámica si las pruebas son válidas. Si se produce un error en las pruebas en las repeticiones subsiguientes de la operación dinámica, se llamará de nuevo a Bind para generar una nueva clase <see cref="T:System.Linq.Expressions.Expression" /> para los nuevos tipos de argumento.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.Defer(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Defers the binding of the operation until later time when the runtime values of all dynamic operation arguments have been computed.">Aplaza el enlace de la operación hasta más tarde, cuando se hayan calculado los valores en tiempo de ejecución de todos los argumentos de la operación dinámica.</summary>
      <param name="target" vsli:raw="The target of the dynamic operation.">Destino de la operación dinámica.</param>
      <param name="args" vsli:raw="An array of arguments of the dynamic operation.">Matriz de argumentos de la operación dinámica.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.Defer(System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Defers the binding of the operation until later time when the runtime values of all dynamic operation arguments have been computed.">Aplaza el enlace de la operación hasta más tarde, cuando se hayan calculado los valores en tiempo de ejecución de todos los argumentos de la operación dinámica.</summary>
      <param name="args" vsli:raw="An array of arguments of the dynamic operation.">Matriz de argumentos de la operación dinámica.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.GetUpdateExpression(System.Type)">
      <summary vsli:raw="Gets an expression that will cause the binding to be updated. It indicates that the expression's binding is no longer valid. This is typically used when the &quot;version&quot; of a dynamic object has changed.">Obtiene una expresión que provocará la actualización del enlace. Indica que el enlace de la expresión ya no es válido. Normalmente se utiliza cuando la "versión" de un objeto dinámico ha cambiado.</summary>
      <param name="type" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of the resulting expression; any type is allowed.">Propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de la expresión resultante; se permite cualquier tipo.</param>
      <returns vsli:raw="The update expression.">Expresión de actualización.</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObjectBinder.ReturnType">
      <summary vsli:raw="The result type of the operation.">El tipo de resultado de la operación.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the result type of the operation.">Objeto <see cref="T:System.Type" /> que representa el tipo de resultado de la operación.</returns>
    </member>
    <member name="T:System.Dynamic.DynamicObject">
      <summary vsli:raw="Provides a base class for specifying dynamic behavior at run time. This class must be inherited from; you cannot instantiate it directly.">Proporciona una clase base para especificar el comportamiento dinámico en tiempo de ejecución. Esta clase debe heredarse; no pueden crearse instancias de la misma directamente.</summary>
    </member>
    <member name="M:System.Dynamic.DynamicObject.#ctor">
      <summary vsli:raw="Enables derived types to initialize a new instance of the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; type.">Permite a los tipos derivados inicializar una nueva instancia del tipo <see cref="T:System.Dynamic.DynamicObject" />.</summary>
    </member>
    <member name="M:System.Dynamic.DynamicObject.GetDynamicMemberNames">
      <summary vsli:raw="Returns the enumeration of all dynamic member names.">Devuelve la enumeración de todos los nombres de miembro dinámicos.</summary>
      <returns vsli:raw="A sequence that contains dynamic member names.">Secuencia que contiene nombres de miembros dinámicos.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.GetMetaObject(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Provides a &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; that dispatches to the dynamic virtual methods. The object can be encapsulated inside another &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; to provide custom behavior for individual actions. This method supports the Dynamic Language Runtime infrastructure for language implementers and it is not intended to be used directly from your code.">Proporciona un objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> que envía a los métodos virtuales dinámicos. El objeto se puede encapsular dentro de otro objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> para proporcionar un comportamiento personalizado para acciones individuales. Este método admite la infraestructura de Dynamic Language Runtime para los implementadores de lenguaje y no está pensado para que se use directamente en el código.</summary>
      <param name="parameter" vsli:raw="The expression that represents &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; to dispatch to the dynamic virtual methods.">Expresión que representa el objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> que se va a enviar a los métodos virtuales dinámicos.</param>
      <returns vsli:raw="An object of the &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; type.">Objeto de tipo <see cref="T:System.Dynamic.DynamicMetaObject" />.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
      <summary vsli:raw="Provides implementation for binary operations. Classes derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class can override this method to specify dynamic behavior for operations such as addition and multiplication.">Proporciona la implementación de operaciones binarias. Las clases derivadas de la clase <see cref="T:System.Dynamic.DynamicObject" /> pueden invalidar este método para especificar un comportamiento dinámico para operaciones como la suma o la multiplicación.</summary>
      <param name="binder" vsli:raw="Provides information about the binary operation. The &lt;c&gt;binder.Operation&lt;/c&gt; property returns an &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; object. For example, for the &lt;c&gt;sum = first + second&lt;/c&gt; statement, where &lt;c&gt;first&lt;/c&gt; and &lt;c&gt;second&lt;/c&gt; are derived from the &lt;see langword=&quot;DynamicObject&quot; /&gt; class, &lt;c&gt;binder.Operation&lt;/c&gt; returns &lt;c&gt;ExpressionType.Add&lt;/c&gt;.">Proporciona información sobre la operación binaria. La propiedad <c>binder.Operation</c> devuelve un objeto <see cref="T:System.Linq.Expressions.ExpressionType" />. Por ejemplo, para la instrucción <c>sum = first + second</c>, donde <c>first</c> y <c>second</c> se derivan de la clase <see langword="DynamicObject" />, <c>binder.Operation</c> devuelve <c>ExpressionType.Add</c>.</param>
      <param name="arg" vsli:raw="The right operand for the binary operation. For example, for the &lt;c&gt;sum = first + second&lt;/c&gt; statement, where &lt;c&gt;first&lt;/c&gt; and &lt;c&gt;second&lt;/c&gt; are derived from the &lt;see langword=&quot;DynamicObject&quot; /&gt; class, &lt;paramref name=&quot;arg&quot; /&gt; is equal to &lt;c&gt;second&lt;/c&gt;.">Operando derecho de la operación binaria. Por ejemplo, para la instrucción <c>sum = first + second</c>, donde <c>first</c> y <c>second</c> se derivan de la clase <see langword="DynamicObject" />, <paramref name="arg" /> es igual a <c>second</c>.</param>
      <param name="result" vsli:raw="The result of the binary operation.">Resultado de la operación binaria.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operation is successful; otherwise, &lt;see langword=&quot;false&quot; /&gt;. If this method returns &lt;see langword=&quot;false&quot; /&gt;, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.)">
        <see langword="true" /> si la operación es correcta; de lo contrario, <see langword="false" />. Si este método devuelve <see langword="false" />, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento. (En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
      <summary vsli:raw="Provides implementation for type conversion operations. Classes derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class can override this method to specify dynamic behavior for operations that convert an object from one type to another.">Proporciona la implementación de las operaciones de conversión de tipos. Las clases derivadas de la clase <see cref="T:System.Dynamic.DynamicObject" /> pueden invalidar este método para especificar el comportamiento dinámico de las operaciones que convierten un objeto de un tipo a otro.</summary>
      <param name="binder" vsli:raw="Provides information about the conversion operation. The &lt;c&gt;binder.Type&lt;/c&gt; property provides the type to which the object must be converted. For example, for the statement &lt;c&gt;(String)sampleObject&lt;/c&gt; in C# (&lt;c&gt;CType(sampleObject, Type)&lt;/c&gt; in Visual Basic), where &lt;c&gt;sampleObject&lt;/c&gt; is an instance of the class derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class, &lt;c&gt;binder.Type&lt;/c&gt; returns the &lt;see cref=&quot;T:System.String&quot; /&gt; type. The &lt;c&gt;binder.Explicit&lt;/c&gt; property provides information about the kind of conversion that occurs. It returns &lt;see langword=&quot;true&quot; /&gt; for explicit conversion and &lt;see langword=&quot;false&quot; /&gt; for implicit conversion.">Proporciona información sobre la operación de conversión. La propiedad <c>binder.Type</c> proporciona el tipo en el que se debe convertir el objeto. Por ejemplo, para la instrucción <c>(String)sampleObject</c> en C# (<c>CType(sampleObject, Type)</c> en Visual Basic), donde <c>sampleObject</c> es una instancia de la clase derivada de la clase <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Type</c> devuelve el tipo <see cref="T:System.String" />. La propiedad <c>binder.Explicit</c> proporciona información sobre el tipo de conversión que se produce. Devuelve <see langword="true" /> para la conversión explícita y <see langword="false" /> para la conversión implícita.</param>
      <param name="result" vsli:raw="The result of the type conversion operation.">Resultado de la operación de conversión de tipos.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operation is successful; otherwise, &lt;see langword=&quot;false&quot; /&gt;. If this method returns &lt;see langword=&quot;false&quot; /&gt;, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.)">
        <see langword="true" /> si la operación es correcta; de lo contrario, <see langword="false" />. Si este método devuelve <see langword="false" />, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento. (En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)">
      <summary vsli:raw="Provides the implementation for operations that initialize a new instance of a dynamic object. This method is not intended for use in C# or Visual Basic.">Proporciona la implementación de las operaciones que inicializan una nueva instancia de un objeto dinámico. Este método no está pensado para su uso en C# o Visual Basic.</summary>
      <param name="binder" vsli:raw="Provides information about the initialization operation.">Proporciona información sobre la operación de inicialización.</param>
      <param name="args" vsli:raw="The arguments that are passed to the object during initialization. For example, for the &lt;c&gt;new SampleType(100)&lt;/c&gt; operation, where &lt;c&gt;SampleType&lt;/c&gt; is the type derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class, &lt;c&gt;args[0]&lt;/c&gt; is equal to 100.">Argumentos que se pasan al objeto durante la inicialización. Por ejemplo, para la operación <c>new SampleType(100)</c>, donde <c>SampleType</c> es el tipo derivado de la clase <see cref="T:System.Dynamic.DynamicObject" />, <c>args[0]</c> es igual que 100.</param>
      <param name="result" vsli:raw="The result of the initialization.">Resultado de la inicialización.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operation is successful; otherwise, &lt;see langword=&quot;false&quot; /&gt;. If this method returns &lt;see langword=&quot;false&quot; /&gt;, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.)">
        <see langword="true" /> si la operación es correcta; de lo contrario, <see langword="false" />. Si este método devuelve <see langword="false" />, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento. (En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Object[])">
      <summary vsli:raw="Provides the implementation for operations that delete an object by index. This method is not intended for use in C# or Visual Basic.">Proporciona la implementación de las operaciones que eliminan un objeto por índice. Este método no está pensado para su uso en C# o Visual Basic.</summary>
      <param name="binder" vsli:raw="Provides information about the deletion.">Proporciona información sobre la eliminación.</param>
      <param name="indexes" vsli:raw="The indexes to be deleted.">Índices que se van a eliminar.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operation is successful; otherwise, &lt;see langword=&quot;false&quot; /&gt;. If this method returns &lt;see langword=&quot;false&quot; /&gt;, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.)">
        <see langword="true" /> si la operación es correcta; de lo contrario, <see langword="false" />. Si este método devuelve <see langword="false" />, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento. (En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryDeleteMember(System.Dynamic.DeleteMemberBinder)">
      <summary vsli:raw="Provides the implementation for operations that delete an object member. This method is not intended for use in C# or Visual Basic.">Proporciona la implementación de las operaciones que eliminan un miembro de objeto. Este método no está pensado para su uso en C# o Visual Basic.</summary>
      <param name="binder" vsli:raw="Provides information about the deletion.">Proporciona información sobre la eliminación.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operation is successful; otherwise, &lt;see langword=&quot;false&quot; /&gt;. If this method returns &lt;see langword=&quot;false&quot; /&gt;, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.)">
        <see langword="true" /> si la operación es correcta; de lo contrario, <see langword="false" />. Si este método devuelve <see langword="false" />, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento. (En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)">
      <summary vsli:raw="Provides the implementation for operations that get a value by index. Classes derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class can override this method to specify dynamic behavior for indexing operations.">Proporciona la implementación de las operaciones que obtienen un valor por índice. Las clases derivadas de la clase <see cref="T:System.Dynamic.DynamicObject" /> pueden invalidar este método para especificar un comportamiento dinámico para las operaciones de indización.</summary>
      <param name="binder" vsli:raw="Provides information about the operation.">Proporciona información sobre la operación.</param>
      <param name="indexes" vsli:raw="The indexes that are used in the operation. For example, for the &lt;c&gt;sampleObject[3]&lt;/c&gt; operation in C# (&lt;c&gt;sampleObject(3)&lt;/c&gt; in Visual Basic), where &lt;c&gt;sampleObject&lt;/c&gt; is derived from the &lt;see langword=&quot;DynamicObject&quot; /&gt; class, &lt;c&gt;indexes[0]&lt;/c&gt; is equal to 3.">Índices que se usan en la operación. Por ejemplo, para la operación <c>sampleObject[3]</c> en C# (<c>sampleObject(3)</c> en Visual Basic), donde <c>sampleObject</c> se deriva de la clase <see langword="DynamicObject" />, <c>indexes[0]</c> es igual que 3.</param>
      <param name="result" vsli:raw="The result of the index operation.">Resultado de la operación de índice.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operation is successful; otherwise, &lt;see langword=&quot;false&quot; /&gt;. If this method returns &lt;see langword=&quot;false&quot; /&gt;, the run-time binder of the language determines the behavior. (In most cases, a run-time exception is thrown.)">
        <see langword="true" /> si la operación es correcta; de lo contrario, <see langword="false" />. Si este método devuelve <see langword="false" />, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento. (En la mayoría de los casos, se inicia una excepción en tiempo de ejecución).</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
      <summary vsli:raw="Provides the implementation for operations that get member values. Classes derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class can override this method to specify dynamic behavior for operations such as getting a value for a property.">Proporciona la implementación de las operaciones que obtienen valores de miembro. Las clases derivadas de la clase <see cref="T:System.Dynamic.DynamicObject" /> pueden invalidar este método para especificar un comportamiento dinámico para operaciones como obtener el valor de una propiedad.</summary>
      <param name="binder" vsli:raw="Provides information about the object that called the dynamic operation. The &lt;c&gt;binder.Name&lt;/c&gt; property provides the name of the member on which the dynamic operation is performed. For example, for the &lt;c&gt;Console.WriteLine(sampleObject.SampleProperty)&lt;/c&gt; statement, where &lt;c&gt;sampleObject&lt;/c&gt; is an instance of the class derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class, &lt;c&gt;binder.Name&lt;/c&gt; returns &quot;SampleProperty&quot;. The &lt;c&gt;binder.IgnoreCase&lt;/c&gt; property specifies whether the member name is case-sensitive.">Proporciona información sobre el objeto que llamó a la operación dinámica. La propiedad <c>binder.Name</c> proporciona el nombre del miembro en el que se realiza la operación dinámica. Por ejemplo, para la instrucción <c>Console.WriteLine(sampleObject.SampleProperty)</c>, donde <c>sampleObject</c> es una instancia de la clase derivada de la clase <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Name</c> devuelve "SampleProperty". La propiedad <c>binder.IgnoreCase</c> especifica si el nombre de miembro distingue mayúsculas de minúsculas.</param>
      <param name="result" vsli:raw="The result of the get operation. For example, if the method is called for a property, you can assign the property value to &lt;paramref name=&quot;result&quot; /&gt;.">Resultado de la operación Get. Por ejemplo, si se llama al método para una propiedad, se puede asignar el valor de la propiedad a <paramref name="result" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operation is successful; otherwise, &lt;see langword=&quot;false&quot; /&gt;. If this method returns &lt;see langword=&quot;false&quot; /&gt;, the run-time binder of the language determines the behavior. (In most cases, a run-time exception is thrown.)">
        <see langword="true" /> si la operación es correcta; de lo contrario, <see langword="false" />. Si este método devuelve <see langword="false" />, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento. (En la mayoría de los casos, se inicia una excepción en tiempo de ejecución).</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
      <summary vsli:raw="Provides the implementation for operations that invoke an object. Classes derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class can override this method to specify dynamic behavior for operations such as invoking an object or a delegate.">Proporciona la implementación para las operaciones que invocan un objeto. Las clases derivadas de la clase <see cref="T:System.Dynamic.DynamicObject" /> pueden invalidar este método para especificar un comportamiento dinámico para operaciones como invocar un objeto o un delegado.</summary>
      <param name="binder" vsli:raw="Provides information about the invoke operation.">Proporciona información sobre la operación de invocación.</param>
      <param name="args" vsli:raw="The arguments that are passed to the object during the invoke operation. For example, for the &lt;c&gt;sampleObject(100)&lt;/c&gt; operation, where &lt;c&gt;sampleObject&lt;/c&gt; is derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class, &lt;c&gt;args[0]&lt;/c&gt; is equal to 100.">Argumentos que se pasan al objeto durante la operación de invocación. Por ejemplo, para la operación <c>sampleObject(100)</c>, donde <c>sampleObject</c> se deriva de la clase <see cref="T:System.Dynamic.DynamicObject" />, <c>args[0]</c> es igual que 100.</param>
      <param name="result" vsli:raw="The result of the object invocation.">Resultado de la invocación de objeto.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operation is successful; otherwise, &lt;see langword=&quot;false&quot; /&gt;. If this method returns &lt;see langword=&quot;false&quot; /&gt;, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.">
        <see langword="true" /> si la operación es correcta; de lo contrario, <see langword="false" />. Si este método devuelve <see langword="false" />, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento. (En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
      <summary vsli:raw="Provides the implementation for operations that invoke a member. Classes derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class can override this method to specify dynamic behavior for operations such as calling a method.">Proporciona la implementación de las operaciones que invocan un miembro. Las clases derivadas de la clase <see cref="T:System.Dynamic.DynamicObject" /> pueden invalidar este método para especificar un comportamiento dinámico para operaciones como llamar a un método.</summary>
      <param name="binder" vsli:raw="Provides information about the dynamic operation. The &lt;c&gt;binder.Name&lt;/c&gt; property provides the name of the member on which the dynamic operation is performed. For example, for the statement &lt;c&gt;sampleObject.SampleMethod(100)&lt;/c&gt;, where &lt;c&gt;sampleObject&lt;/c&gt; is an instance of the class derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class, &lt;c&gt;binder.Name&lt;/c&gt; returns &quot;SampleMethod&quot;. The &lt;c&gt;binder.IgnoreCase&lt;/c&gt; property specifies whether the member name is case-sensitive.">Proporciona información sobre la operación dinámica. La propiedad <c>binder.Name</c> proporciona el nombre del miembro en el que se realiza la operación dinámica. Por ejemplo, para la instrucción <c>sampleObject.SampleMethod(100)</c>, donde <c>sampleObject</c> es una instancia de la clase derivada de la clase <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Name</c> devuelve "SampleMethod". La propiedad <c>binder.IgnoreCase</c> especifica si el nombre de miembro distingue mayúsculas de minúsculas.</param>
      <param name="args" vsli:raw="The arguments that are passed to the object member during the invoke operation. For example, for the statement &lt;c&gt;sampleObject.SampleMethod(100)&lt;/c&gt;, where &lt;c&gt;sampleObject&lt;/c&gt; is derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class, &lt;c&gt;args[0]&lt;/c&gt; is equal to 100.">Argumentos que se pasan al miembro de objeto durante la operación de invocación. Por ejemplo, para la instrucción <c>sampleObject.SampleMethod(100)</c>, donde <c>sampleObject</c> se deriva de la clase <see cref="T:System.Dynamic.DynamicObject" />, <c>args[0]</c> es igual que 100.</param>
      <param name="result" vsli:raw="The result of the member invocation.">Resultado de la invocación del miembro.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operation is successful; otherwise, &lt;see langword=&quot;false&quot; /&gt;. If this method returns &lt;see langword=&quot;false&quot; /&gt;, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.)">
        <see langword="true" /> si la operación es correcta; de lo contrario, <see langword="false" />. Si este método devuelve <see langword="false" />, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento. (En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
      <summary vsli:raw="Provides the implementation for operations that set a value by index. Classes derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class can override this method to specify dynamic behavior for operations that access objects by a specified index.">Proporciona la implementación de las operaciones que establecen un valor por índice. Las clases derivadas de la clase <see cref="T:System.Dynamic.DynamicObject" /> pueden invalidar este método para especificar el comportamiento dinámico de las operaciones que tienen acceso a los objetos por un índice especificado.</summary>
      <param name="binder" vsli:raw="Provides information about the operation.">Proporciona información sobre la operación.</param>
      <param name="indexes" vsli:raw="The indexes that are used in the operation. For example, for the &lt;c&gt;sampleObject[3] = 10&lt;/c&gt; operation in C# (&lt;c&gt;sampleObject(3) = 10&lt;/c&gt; in Visual Basic), where &lt;c&gt;sampleObject&lt;/c&gt; is derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class, &lt;c&gt;indexes[0]&lt;/c&gt; is equal to 3.">Índices que se usan en la operación. Por ejemplo, para la operación <c>sampleObject[3] = 10</c> en C# (<c>sampleObject(3) = 10</c> en Visual Basic), donde <c>sampleObject</c> se deriva de la clase <see cref="T:System.Dynamic.DynamicObject" />, <c>indexes[0]</c> es igual que 3.</param>
      <param name="value" vsli:raw="The value to set to the object that has the specified index. For example, for the &lt;c&gt;sampleObject[3] = 10&lt;/c&gt; operation in C# (&lt;c&gt;sampleObject(3) = 10&lt;/c&gt; in Visual Basic), where &lt;c&gt;sampleObject&lt;/c&gt; is derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class, &lt;paramref name=&quot;value&quot; /&gt; is equal to 10.">Valor que se establece en el objeto que tiene el índice especificado. Por ejemplo, para la operación <c>sampleObject[3] = 10</c> en C# (<c>sampleObject(3) = 10</c> en Visual Basic), donde <c>sampleObject</c> se deriva de la clase <see cref="T:System.Dynamic.DynamicObject" />, <paramref name="value" /> es igual a 10.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operation is successful; otherwise, &lt;see langword=&quot;false&quot; /&gt;. If this method returns &lt;see langword=&quot;false&quot; /&gt;, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.">
        <see langword="true" /> si la operación es correcta; de lo contrario, <see langword="false" />. Si este método devuelve <see langword="false" />, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento. (En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
      <summary vsli:raw="Provides the implementation for operations that set member values. Classes derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class can override this method to specify dynamic behavior for operations such as setting a value for a property.">Proporciona la implementación de las operaciones que establecen valores de miembro. Las clases derivadas de la clase <see cref="T:System.Dynamic.DynamicObject" /> pueden invalidar este método para especificar un comportamiento dinámico para operaciones como establecer el valor de una propiedad.</summary>
      <param name="binder" vsli:raw="Provides information about the object that called the dynamic operation. The &lt;c&gt;binder.Name&lt;/c&gt; property provides the name of the member to which the value is being assigned. For example, for the statement &lt;c&gt;sampleObject.SampleProperty = &quot;Test&quot;&lt;/c&gt;, where &lt;c&gt;sampleObject&lt;/c&gt; is an instance of the class derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class, &lt;c&gt;binder.Name&lt;/c&gt; returns &quot;SampleProperty&quot;. The &lt;c&gt;binder.IgnoreCase&lt;/c&gt; property specifies whether the member name is case-sensitive.">Proporciona información sobre el objeto que llamó a la operación dinámica. La propiedad <c>binder.Name</c> proporciona el nombre del miembro al que se asigna el valor. Por ejemplo, para la instrucción <c>sampleObject.SampleProperty = "Test"</c>, donde <c>sampleObject</c> es una instancia de la clase derivada de la clase <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Name</c> devuelve "SampleProperty". La propiedad <c>binder.IgnoreCase</c> especifica si el nombre de miembro distingue mayúsculas de minúsculas.</param>
      <param name="value" vsli:raw="The value to set to the member. For example, for &lt;c&gt;sampleObject.SampleProperty = &quot;Test&quot;&lt;/c&gt;, where &lt;c&gt;sampleObject&lt;/c&gt; is an instance of the class derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class, the &lt;paramref name=&quot;value&quot; /&gt; is &quot;Test&quot;.">Valor que se va a establecer para el miembro. Por ejemplo, para <c>sampleObject.SampleProperty = "Test"</c>, donde <c>sampleObject</c> es una instancia de la clase derivada de la clase <see cref="T:System.Dynamic.DynamicObject" />, <paramref name="value" /> es "Test".</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operation is successful; otherwise, &lt;see langword=&quot;false&quot; /&gt;. If this method returns &lt;see langword=&quot;false&quot; /&gt;, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.)">
        <see langword="true" /> si la operación es correcta; de lo contrario, <see langword="false" />. Si este método devuelve <see langword="false" />, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento. (En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
      <summary vsli:raw="Provides implementation for unary operations. Classes derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class can override this method to specify dynamic behavior for operations such as negation, increment, or decrement.">Proporciona la implementación de operaciones unarias. Las clases derivadas de la clase <see cref="T:System.Dynamic.DynamicObject" /> pueden invalidar este método para especificar el comportamiento dinámico de operaciones como negación, incremento o decremento.</summary>
      <param name="binder" vsli:raw="Provides information about the unary operation. The &lt;c&gt;binder.Operation&lt;/c&gt; property returns an &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; object. For example, for the &lt;c&gt;negativeNumber = -number&lt;/c&gt; statement, where &lt;c&gt;number&lt;/c&gt; is derived from the &lt;see langword=&quot;DynamicObject&quot; /&gt; class, &lt;c&gt;binder.Operation&lt;/c&gt; returns &quot;Negate&quot;.">Proporciona información sobre la operación unaria. La propiedad <c>binder.Operation</c> devuelve un objeto <see cref="T:System.Linq.Expressions.ExpressionType" />. Por ejemplo, para la instrucción <c>negativeNumber = -number</c>, donde <c>number</c> se deriva de la clase <see langword="DynamicObject" />, <c>binder.Operation</c> devuelve "Negate".</param>
      <param name="result" vsli:raw="The result of the unary operation.">Resultado de la operación unaria.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operation is successful; otherwise, &lt;see langword=&quot;false&quot; /&gt;. If this method returns &lt;see langword=&quot;false&quot; /&gt;, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.)">
        <see langword="true" /> si la operación es correcta; de lo contrario, <see langword="false" />. Si este método devuelve <see langword="false" />, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento. (En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</returns>
    </member>
    <member name="T:System.Dynamic.ExpandoObject">
      <summary vsli:raw="Represents an object whose members can be dynamically added and removed at run time.">Representa un objeto cuyos miembros se pueden agregar y quitar de forma dinámica en tiempo de ejecución.</summary>
    </member>
    <member name="M:System.Dynamic.ExpandoObject.#ctor">
      <summary vsli:raw="Initializes a new &lt;see langword=&quot;ExpandoObject&quot; /&gt; that does not have members.">Inicializa un nuevo <see langword="ExpandoObject" /> que no tiene miembros.</summary>
    </member>
    <member name="M:System.Dynamic.ExpandoObject.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Devuelve un enumerador que procesa una iteración en la colección.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; that can be used to iterate through the collection.">
        <see cref="T:System.Collections.IEnumerator" /> que se puede utilizar para recorrer en iteración la colección.</returns>
    </member>
    <member name="E:System.Dynamic.ExpandoObject.System#ComponentModel#INotifyPropertyChanged#PropertyChanged">
      <summary vsli:raw="Occurs when a property value changes.">Tiene lugar cuando cambia un valor de propiedad.</summary>
    </member>
    <member name="M:System.Dynamic.ExpandoObject.System#Dynamic#IDynamicMetaObjectProvider#GetMetaObject(System.Linq.Expressions.Expression)">
      <summary vsli:raw="The provided MetaObject will dispatch to the dynamic virtual methods. The object can be encapsulated inside another MetaObject to provide custom behavior for individual actions.">El MetaObject proporcionado se enviará a los métodos virtuales dinámicos. El objeto se puede encapsular dentro de otro MetaObject para proporcionar el comportamiento personalizado para acciones individuales.</summary>
      <param name="parameter" vsli:raw="The expression that represents the MetaObject to dispatch to the Dynamic virtual methods.">Expresión que representa el MetaObject que se va a enviar a los métodos virtuales dinámicos.</param>
      <returns vsli:raw="The object of the &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; type.">Objeto del tipo <see cref="T:System.Dynamic.DynamicMetaObject" />.</returns>
    </member>
    <member name="T:System.Dynamic.GetIndexBinder">
      <summary vsli:raw="Represents the dynamic get index operation at the call site, providing the binding semantic and the details about the operation.">Representa la operación de obtención de índice dinámica en el sitio de llamada y proporciona la semántica del enlace y los detalles sobre la operación.</summary>
    </member>
    <member name="M:System.Dynamic.GetIndexBinder.#ctor(System.Dynamic.CallInfo)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Dynamic.GetIndexBinder&quot; /&gt;.">Inicializa una nueva instancia de <see cref="T:System.Dynamic.GetIndexBinder" />.</summary>
      <param name="callInfo" vsli:raw="The signature of the arguments at the call site.">Firma de los argumentos en el sitio de llamada.</param>
    </member>
    <member name="M:System.Dynamic.GetIndexBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic get index operation.">Realiza el enlace de la operación de obtención de índice dinámica.</summary>
      <param name="target" vsli:raw="The target of the dynamic get index operation.">Destino de la operación de obtención de índice dinámica.</param>
      <param name="args" vsli:raw="An array of arguments of the dynamic get index operation.">Una matriz de argumentos de la operación de obtención de índice dinámica.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="P:System.Dynamic.GetIndexBinder.CallInfo">
      <summary vsli:raw="Gets the signature of the arguments at the call site.">Obtiene la firma de los argumentos en el sitio de llamada.</summary>
      <returns vsli:raw="The signature of the arguments at the call site.">Firma de los argumentos en el sitio de llamada.</returns>
    </member>
    <member name="M:System.Dynamic.GetIndexBinder.FallbackGetIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic get index operation if the target dynamic object cannot bind.">Realiza el enlace de la operación de obtención de índice dinámica si no puede enlazarse el objeto dinámico de destino.</summary>
      <param name="target" vsli:raw="The target of the dynamic get index operation.">Destino de la operación de obtención de índice dinámica.</param>
      <param name="indexes" vsli:raw="The arguments of the dynamic get index operation.">Argumentos de la operación de obtención de índice dinámica.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.GetIndexBinder.FallbackGetIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="When overridden in the derived class, performs the binding of the dynamic get index operation if the target dynamic object cannot bind.">Cuando se reemplaza en la clase derivada, realiza el enlace de la operación de obtención de índice dinámica si el objeto dinámico de destino no se puede enlazar.</summary>
      <param name="target" vsli:raw="The target of the dynamic get index operation.">Destino de la operación de obtención de índice dinámica.</param>
      <param name="indexes" vsli:raw="The arguments of the dynamic get index operation.">Argumentos de la operación de obtención de índice dinámica.</param>
      <param name="errorSuggestion" vsli:raw="The binding result to use if binding fails, or null.">Resultado del enlace que se va a usar cuando el enlace produzca un error, o NULL.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="P:System.Dynamic.GetIndexBinder.ReturnType">
      <summary vsli:raw="The result type of the operation.">El tipo de resultado de la operación.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the result type of the operation.">Objeto <see cref="T:System.Type" /> que representa el tipo de resultado de la operación.</returns>
    </member>
    <member name="T:System.Dynamic.GetMemberBinder">
      <summary vsli:raw="Represents the dynamic get member operation at the call site, providing the binding semantic and the details about the operation.">Representa la operación de obtención de miembros dinámica en el sitio de llamada, y proporciona la semántica del enlace y los detalles sobre la operación.</summary>
    </member>
    <member name="M:System.Dynamic.GetMemberBinder.#ctor(System.String,System.Boolean)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Dynamic.GetMemberBinder&quot; /&gt;.">Inicializa una nueva instancia de <see cref="T:System.Dynamic.GetMemberBinder" />.</summary>
      <param name="name" vsli:raw="The name of the member to obtain.">Nombre del miembro que se va a obtener.</param>
      <param name="ignoreCase" vsli:raw="Is true if the name should be matched ignoring case; false otherwise.">Es true si no se debe distinguir entre mayúsculas y minúsculas en la comparación; de lo contrario, es false.</param>
    </member>
    <member name="M:System.Dynamic.GetMemberBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic get member operation.">Realiza el enlace de la operación de obtención de miembros dinámica.</summary>
      <param name="target" vsli:raw="The target of the dynamic get member operation.">Destino de la operación de obtención de miembros dinámica.</param>
      <param name="args" vsli:raw="An array of arguments of the dynamic get member operation.">Una matriz de argumentos de la operación de obtención de miembros dinámica.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.GetMemberBinder.FallbackGetMember(System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="Performs the binding of the dynamic get member operation if the target dynamic object cannot bind.">Realiza el enlace de la operación de obtención de miembros dinámica si no puede enlazarse el objeto dinámico de destino.</summary>
      <param name="target" vsli:raw="The target of the dynamic get member operation.">Destino de la operación de obtención de miembros dinámica.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.GetMemberBinder.FallbackGetMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="When overridden in the derived class, performs the binding of the dynamic get member operation if the target dynamic object cannot bind.">Cuando se reemplaza en la clase derivada, realiza el enlace de la operación de obtención de miembros dinámica si el objeto dinámico de destino no se puede enlazar.</summary>
      <param name="target" vsli:raw="The target of the dynamic get member operation.">Destino de la operación de obtención de miembros dinámica.</param>
      <param name="errorSuggestion" vsli:raw="The binding result to use if binding fails, or null.">Resultado del enlace que se va a usar cuando el enlace produzca un error, o NULL.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="P:System.Dynamic.GetMemberBinder.IgnoreCase">
      <summary vsli:raw="Gets the value indicating if the string comparison should ignore the case of the member name.">Obtiene el valor que indica si la comparación de cadena no debe distinguir entre mayúsculas y minúsculas en el nombre del miembro.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if case is ignored; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />Si se omite el uso de mayúsculas y minúsculas; en caso <see langword="false" />contrario,.</returns>
    </member>
    <member name="P:System.Dynamic.GetMemberBinder.Name">
      <summary vsli:raw="Gets the name of the member to obtain.">Obtiene el nombre del miembro que se va a obtener.</summary>
      <returns vsli:raw="The name of the member to obtain.">Nombre del miembro que se va a obtener.</returns>
    </member>
    <member name="P:System.Dynamic.GetMemberBinder.ReturnType">
      <summary vsli:raw="The result type of the operation.">El tipo de resultado de la operación.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the result type of the operation.">Objeto <see cref="T:System.Type" /> que representa el tipo de resultado de la operación.</returns>
    </member>
    <member name="T:System.Dynamic.IDynamicMetaObjectProvider">
      <summary vsli:raw="Represents a dynamic object, that can have its operations bound at runtime.">Representa un objeto dinámico cuyas operaciones pueden enlazarse en tiempo de ejecución.</summary>
    </member>
    <member name="M:System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Returns the &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; responsible for binding operations performed on this object.">Devuelve la clase <see cref="T:System.Dynamic.DynamicMetaObject" /> responsable de las operaciones de enlace realizadas en este objeto.</summary>
      <param name="parameter" vsli:raw="The expression tree representation of the runtime value.">Representación de árbol de expresión del valor en tiempo de ejecución.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; to bind this object.">Clase <see cref="T:System.Dynamic.DynamicMetaObject" /> que se va a enlazar al objeto.</returns>
    </member>
    <member name="T:System.Dynamic.IInvokeOnGetBinder">
      <summary vsli:raw="Represents information about a dynamic get member operation that indicates if the get member should invoke properties when they perform the get operation.">Representa información sobre una operación de obtención de miembros dinámica que indica si la obtención de miembros debe invocar propiedades cuando se realiza la operación Get.</summary>
    </member>
    <member name="P:System.Dynamic.IInvokeOnGetBinder.InvokeOnGet">
      <summary vsli:raw="Gets the value indicating if this get member operation should invoke properties when they perform the get operation. The default value when this interface is not present is true.">Obtiene el valor que indica si esta operación de obtención de miembros debe invocar propiedades cuando se realiza la operación Get. El valor predeterminado cuando esta interfaz no está presente es true.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if this get member operation should invoke properties when they perform the get operation; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />Si esta operación de obtención de miembros debe invocar propiedades al realizar la operación Get; en caso <see langword="false" />contrario,.</returns>
    </member>
    <member name="T:System.Dynamic.InvokeBinder">
      <summary vsli:raw="Represents the invoke dynamic operation at the call site, providing the binding semantic and the details about the operation.">Representa la operación de invocación de miembros dinámica en el sitio de llamada, y proporciona la semántica del enlace y los detalles sobre la operación.</summary>
    </member>
    <member name="M:System.Dynamic.InvokeBinder.#ctor(System.Dynamic.CallInfo)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Dynamic.InvokeBinder&quot; /&gt;.">Inicializa una nueva instancia de <see cref="T:System.Dynamic.InvokeBinder" />.</summary>
      <param name="callInfo" vsli:raw="The signature of the arguments at the call site.">Firma de los argumentos en el sitio de llamada.</param>
    </member>
    <member name="M:System.Dynamic.InvokeBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic invoke operation.">Realiza el enlace de la operación de invocación dinámica.</summary>
      <param name="target" vsli:raw="The target of the dynamic invoke operation.">Destino de la operación de invocación dinámica.</param>
      <param name="args" vsli:raw="An array of arguments of the dynamic invoke operation.">Una matriz de argumentos de la operación de invocación dinámica.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="P:System.Dynamic.InvokeBinder.CallInfo">
      <summary vsli:raw="Gets the signature of the arguments at the call site.">Obtiene la firma de los argumentos en el sitio de llamada.</summary>
      <returns vsli:raw="The signature of the arguments at the call site.">Firma de los argumentos en el sitio de llamada.</returns>
    </member>
    <member name="M:System.Dynamic.InvokeBinder.FallbackInvoke(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic invoke operation if the target dynamic object cannot bind.">Realiza el enlace de la operación de invocación dinámica si no puede enlazarse el objeto dinámico de destino.</summary>
      <param name="target" vsli:raw="The target of the dynamic invoke operation.">Destino de la operación de invocación dinámica.</param>
      <param name="args" vsli:raw="The arguments of the dynamic invoke operation.">Argumentos de la operación de invocación dinámica.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.InvokeBinder.FallbackInvoke(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="Performs the binding of the dynamic invoke operation if the target dynamic object cannot bind.">Realiza el enlace de la operación de invocación dinámica si no puede enlazarse el objeto dinámico de destino.</summary>
      <param name="target" vsli:raw="The target of the dynamic invoke operation.">Destino de la operación de invocación dinámica.</param>
      <param name="args" vsli:raw="The arguments of the dynamic invoke operation.">Argumentos de la operación de invocación dinámica.</param>
      <param name="errorSuggestion" vsli:raw="The binding result to use if binding fails, or null.">Resultado del enlace que se va a usar cuando el enlace produzca un error, o NULL.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="P:System.Dynamic.InvokeBinder.ReturnType">
      <summary vsli:raw="The result type of the operation.">El tipo de resultado de la operación.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the result type of the operation.">Objeto <see cref="T:System.Type" /> que representa el tipo de resultado de la operación.</returns>
    </member>
    <member name="T:System.Dynamic.InvokeMemberBinder">
      <summary vsli:raw="Represents the invoke member dynamic operation at the call site, providing the binding semantic and the details about the operation.">Representa la operación de invocación de miembros dinámica en el sitio de llamada, y proporciona la semántica del enlace y los detalles sobre la operación.</summary>
    </member>
    <member name="M:System.Dynamic.InvokeMemberBinder.#ctor(System.String,System.Boolean,System.Dynamic.CallInfo)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Dynamic.InvokeMemberBinder&quot; /&gt;.">Inicializa una nueva instancia de <see cref="T:System.Dynamic.InvokeMemberBinder" />.</summary>
      <param name="name" vsli:raw="The name of the member to invoke.">Nombre del miembro que se va a invocar.</param>
      <param name="ignoreCase" vsli:raw="true if the name should be matched ignoring case; false otherwise.">true si no se debe distinguir entre mayúsculas y minúsculas en la comparación; de lo contrario, false.</param>
      <param name="callInfo" vsli:raw="The signature of the arguments at the call site.">Firma de los argumentos en el sitio de llamada.</param>
    </member>
    <member name="M:System.Dynamic.InvokeMemberBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic invoke member operation.">Realiza el enlace de la operación de invocación de miembros dinámica.</summary>
      <param name="target" vsli:raw="The target of the dynamic invoke member operation.">Destino de la operación de invocación de miembros dinámica.</param>
      <param name="args" vsli:raw="An array of arguments of the dynamic invoke member operation.">Una matriz de argumentos de la operación de invocación de miembros dinámica.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="P:System.Dynamic.InvokeMemberBinder.CallInfo">
      <summary vsli:raw="Gets the signature of the arguments at the call site.">Obtiene la firma de los argumentos en el sitio de llamada.</summary>
      <returns vsli:raw="The signature of the arguments at the call site.">Firma de los argumentos en el sitio de llamada.</returns>
    </member>
    <member name="M:System.Dynamic.InvokeMemberBinder.FallbackInvoke(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="When overridden in the derived class, performs the binding of the dynamic invoke operation if the target dynamic object cannot bind.">Cuando se reemplaza en la clase derivada, realiza el enlace de la operación de invocación dinámica si el objeto dinámico de destino no se puede enlazar.</summary>
      <param name="target" vsli:raw="The target of the dynamic invoke operation.">Destino de la operación de invocación dinámica.</param>
      <param name="args" vsli:raw="The arguments of the dynamic invoke operation.">Argumentos de la operación de invocación dinámica.</param>
      <param name="errorSuggestion" vsli:raw="The binding result to use if binding fails, or null.">Resultado del enlace que se va a usar cuando el enlace produzca un error, o NULL.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.InvokeMemberBinder.FallbackInvokeMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic invoke member operation if the target dynamic object cannot bind.">Realiza el enlace de la operación de invocación de miembros dinámica si no puede enlazarse el objeto dinámico de destino.</summary>
      <param name="target" vsli:raw="The target of the dynamic invoke member operation.">Destino de la operación de invocación de miembros dinámica.</param>
      <param name="args" vsli:raw="The arguments of the dynamic invoke member operation.">Argumentos de la operación de invocación de miembros dinámica.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.InvokeMemberBinder.FallbackInvokeMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="When overridden in the derived class, performs the binding of the dynamic invoke member operation if the target dynamic object cannot bind.">Cuando se reemplaza en la clase derivada, realiza el enlace de la operación de invocación de miembros dinámica si el objeto dinámico de destino no se puede enlazar.</summary>
      <param name="target" vsli:raw="The target of the dynamic invoke member operation.">Destino de la operación de invocación de miembros dinámica.</param>
      <param name="args" vsli:raw="The arguments of the dynamic invoke member operation.">Argumentos de la operación de invocación de miembros dinámica.</param>
      <param name="errorSuggestion" vsli:raw="The binding result to use if binding fails, or null.">Resultado del enlace que se va a usar cuando el enlace produzca un error, o NULL.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="P:System.Dynamic.InvokeMemberBinder.IgnoreCase">
      <summary vsli:raw="Gets the value indicating if the string comparison should ignore the case of the member name.">Obtiene el valor que indica si la comparación de cadena no debe distinguir entre mayúsculas y minúsculas en el nombre del miembro.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if case is ignored; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />Si se omite el uso de mayúsculas y minúsculas; en caso <see langword="false" />contrario,.</returns>
    </member>
    <member name="P:System.Dynamic.InvokeMemberBinder.Name">
      <summary vsli:raw="Gets the name of the member to invoke.">Obtiene el nombre del miembro que se va a invocar.</summary>
      <returns vsli:raw="The name of the member to invoke.">Nombre del miembro que se va a invocar.</returns>
    </member>
    <member name="P:System.Dynamic.InvokeMemberBinder.ReturnType">
      <summary vsli:raw="The result type of the operation.">El tipo de resultado de la operación.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the result type of the operation.">Objeto <see cref="T:System.Type" /> que representa el tipo de resultado de la operación.</returns>
    </member>
    <member name="T:System.Dynamic.SetIndexBinder">
      <summary vsli:raw="Represents the dynamic set index operation at the call site, providing the binding semantic and the details about the operation.">Representa la operación de establecimiento de índice dinámica en el sitio de llamada, proporcionando la semántica del enlace y los detalles sobre la operación.</summary>
    </member>
    <member name="M:System.Dynamic.SetIndexBinder.#ctor(System.Dynamic.CallInfo)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Dynamic.SetIndexBinder&quot; /&gt;.">Inicializa una nueva instancia de <see cref="T:System.Dynamic.SetIndexBinder" />.</summary>
      <param name="callInfo" vsli:raw="The signature of the arguments at the call site.">Firma de los argumentos en el sitio de llamada.</param>
    </member>
    <member name="M:System.Dynamic.SetIndexBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic set index operation.">Realiza el enlace de la operación de establecimiento de índice dinámica.</summary>
      <param name="target" vsli:raw="The target of the dynamic set index operation.">Destino de la operación de establecimiento de índice dinámica.</param>
      <param name="args" vsli:raw="An array of arguments of the dynamic set index operation.">Matriz de argumentos de la operación de establecimiento de índice dinámica.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="P:System.Dynamic.SetIndexBinder.CallInfo">
      <summary vsli:raw="Gets the signature of the arguments at the call site.">Obtiene la firma de los argumentos en el sitio de llamada.</summary>
      <returns vsli:raw="The signature of the arguments at the call site.">Firma de los argumentos en el sitio de llamada.</returns>
    </member>
    <member name="M:System.Dynamic.SetIndexBinder.FallbackSetIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="Performs the binding of the dynamic set index operation if the target dynamic object cannot bind.">Realiza el enlace de la operación de establecimiento de índice dinámica si el objeto dinámico de destino no se puede enlazar.</summary>
      <param name="target" vsli:raw="The target of the dynamic set index operation.">Destino de la operación de establecimiento de índice dinámica.</param>
      <param name="indexes" vsli:raw="The arguments of the dynamic set index operation.">Argumentos de la operación de establecimiento de índice dinámica.</param>
      <param name="value" vsli:raw="The value to set to the collection.">Valor que se va a establecer para la colección.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.SetIndexBinder.FallbackSetIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="When overridden in the derived class, performs the binding of the dynamic set index operation if the target dynamic object cannot bind.">Cuando se reemplaza en la clase derivada, realiza el enlace de la operación de establecimiento de índice dinámica si el objeto dinámico de destino no se puede enlazar.</summary>
      <param name="target" vsli:raw="The target of the dynamic set index operation.">Destino de la operación de establecimiento de índice dinámica.</param>
      <param name="indexes" vsli:raw="The arguments of the dynamic set index operation.">Argumentos de la operación de establecimiento de índice dinámica.</param>
      <param name="value" vsli:raw="The value to set to the collection.">Valor que se va a establecer para la colección.</param>
      <param name="errorSuggestion" vsli:raw="The binding result to use if binding fails, or null.">Resultado del enlace que se va a usar cuando el enlace produzca un error, o NULL.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="P:System.Dynamic.SetIndexBinder.ReturnType">
      <summary vsli:raw="The result type of the operation.">El tipo de resultado de la operación.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the result type of the operation.">Objeto <see cref="T:System.Type" /> que representa el tipo de resultado de la operación.</returns>
    </member>
    <member name="T:System.Dynamic.SetMemberBinder">
      <summary vsli:raw="Represents the dynamic set member operation at the call site, providing the binding semantic and the details about the operation.">Representa la operación de configuración dinámica de miembros en el sitio de la llamada, que proporciona la semántica de los enlaces y los detalles sobre la operación.</summary>
    </member>
    <member name="M:System.Dynamic.SetMemberBinder.#ctor(System.String,System.Boolean)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Dynamic.SetMemberBinder&quot; /&gt;.">Inicializa una nueva instancia de <see cref="T:System.Dynamic.SetMemberBinder" />.</summary>
      <param name="name" vsli:raw="The name of the member to obtain.">Nombre del miembro que se va a obtener.</param>
      <param name="ignoreCase" vsli:raw="Is true if the name should be matched ignoring case; false otherwise.">Es true si no se debe distinguir entre mayúsculas y minúsculas en la comparación; de lo contrario, es false.</param>
    </member>
    <member name="M:System.Dynamic.SetMemberBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic set member operation.">Realiza el enlace de la operación de establecimiento de miembros dinámica.</summary>
      <param name="target" vsli:raw="The target of the dynamic set member operation.">Destino de la operación de establecimiento de miembros dinámica.</param>
      <param name="args" vsli:raw="An array of arguments of the dynamic set member operation.">Una matriz de argumentos de la operación de establecimiento de miembros dinámica.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.SetMemberBinder.FallbackSetMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="Performs the binding of the dynamic set member operation if the target dynamic object cannot bind.">Realiza el enlace de la operación de establecimiento de miembros dinámica si no puede enlazarse el objeto dinámico de destino.</summary>
      <param name="target" vsli:raw="The target of the dynamic set member operation.">Destino de la operación de establecimiento de miembros dinámica.</param>
      <param name="value" vsli:raw="The value to set to the member.">Valor que se va a establecer para el miembro.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.SetMemberBinder.FallbackSetMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="Performs the binding of the dynamic set member operation if the target dynamic object cannot bind.">Realiza el enlace de la operación de establecimiento de miembros dinámica si no puede enlazarse el objeto dinámico de destino.</summary>
      <param name="target" vsli:raw="The target of the dynamic set member operation.">Destino de la operación de establecimiento de miembros dinámica.</param>
      <param name="value" vsli:raw="The value to set to the member.">Valor que se va a establecer para el miembro.</param>
      <param name="errorSuggestion" vsli:raw="The binding result to use if binding fails, or null.">Resultado de enlace que se usa si se produce un error de enlace, o null.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="P:System.Dynamic.SetMemberBinder.IgnoreCase">
      <summary vsli:raw="Gets the value indicating if the string comparison should ignore the case of the member name.">Obtiene el valor que indica si la comparación de cadena no debe distinguir entre mayúsculas y minúsculas en el nombre del miembro.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if case is ignored; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />Si se omite el uso de mayúsculas y minúsculas; en caso <see langword="false" />contrario,.</returns>
    </member>
    <member name="P:System.Dynamic.SetMemberBinder.Name">
      <summary vsli:raw="Gets the name of the member to obtain.">Obtiene el nombre del miembro que se va a obtener.</summary>
      <returns vsli:raw="The name of the member to obtain.">Nombre del miembro que se va a obtener.</returns>
    </member>
    <member name="P:System.Dynamic.SetMemberBinder.ReturnType">
      <summary vsli:raw="The result type of the operation.">El tipo de resultado de la operación.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the result type of the operation.">Objeto <see cref="T:System.Type" /> que representa el tipo de resultado de la operación.</returns>
    </member>
    <member name="T:System.Dynamic.UnaryOperationBinder">
      <summary vsli:raw="Represents the unary dynamic operation at the call site, providing the binding semantic and the details about the operation.">Representa la operación unaria dinámica en el sitio de llamada, y proporciona la semántica del enlace y los detalles sobre la operación.</summary>
    </member>
    <member name="M:System.Dynamic.UnaryOperationBinder.#ctor(System.Linq.Expressions.ExpressionType)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Dynamic.BinaryOperationBinder&quot; /&gt; class.">Inicializa una nueva instancia de la clase <see cref="T:System.Dynamic.BinaryOperationBinder" />.</summary>
      <param name="operation" vsli:raw="The unary operation kind.">Tipo de operación unaria.</param>
    </member>
    <member name="M:System.Dynamic.UnaryOperationBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic unary operation.">Realiza el enlace de la operación unaria dinámica.</summary>
      <param name="target" vsli:raw="The target of the dynamic operation.">Destino de la operación dinámica.</param>
      <param name="args" vsli:raw="An array of arguments of the dynamic operation.">Matriz de argumentos de la operación dinámica.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.UnaryOperationBinder.FallbackUnaryOperation(System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="Performs the binding of the unary dynamic operation if the target dynamic object cannot bind.">Realiza el enlace de la operación unaria dinámica si no puede enlazarse el objeto dinámico de destino.</summary>
      <param name="target" vsli:raw="The target of the dynamic unary operation.">Destino de la operación unaria dinámica.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.UnaryOperationBinder.FallbackUnaryOperation(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="Performs the binding of the unary dynamic operation if the target dynamic object cannot bind.">Realiza el enlace de la operación unaria dinámica si no puede enlazarse el objeto dinámico de destino.</summary>
      <param name="target" vsli:raw="The target of the dynamic unary operation.">Destino de la operación unaria dinámica.</param>
      <param name="errorSuggestion" vsli:raw="The binding result in case the binding fails, or null.">Resultado en caso de que el enlace produzca un error, o NULL.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="P:System.Dynamic.UnaryOperationBinder.Operation">
      <summary vsli:raw="The unary operation kind.">Tipo de operación unaria.</summary>
      <returns vsli:raw="The object of the &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that represents the unary operation kind.">Objeto de la clase <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa el tipo de operación unaria.</returns>
    </member>
    <member name="P:System.Dynamic.UnaryOperationBinder.ReturnType">
      <summary vsli:raw="The result type of the operation.">El tipo de resultado de la operación.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the result type of the operation.">Objeto <see cref="T:System.Type" /> que representa el tipo de resultado de la operación.</returns>
    </member>
    <member name="T:System.Linq.Expressions.BinaryExpression">
      <summary vsli:raw="Represents an expression that has a binary operator.">Representa una expresión que tiene un operador binario.</summary>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary vsli:raw="Dispatches to the specific visit method for this node type. For example, &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; calls the &lt;see cref=&quot;M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)&quot; /&gt;.">Envía la expresión al método de visita específico de este tipo de nodo. Por ejemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama a <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor" vsli:raw="The visitor to visit this node with.">Visitante con el que se va a visitar este nodo.</param>
      <returns vsli:raw="The result of visiting this node.">Resultado de visitar este nodo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.CanReduce">
      <summary vsli:raw="Gets a value that indicates whether the expression tree node can be reduced.">Obtiene un valor que indica si el nodo del árbol de expresión se puede reducir.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the expression tree node can be reduced; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />es si se puede reducir el nodo de árbol de expresión; en caso <see langword="false" />contrario,.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Conversion">
      <summary vsli:raw="Gets the type conversion function that is used by a coalescing or compound assignment operation.">Obtiene la función de conversión de tipos utilizada por una operación de uso combinado o una operación de asignación compuesta.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; that represents a type conversion function.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> que representa una función de conversión de tipos.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.IsLifted">
      <summary vsli:raw="Gets a value that indicates whether the expression tree node represents a lifted call to an operator.">Obtiene un valor que indica si el nodo del árbol de expresión representa una llamada elevada a un operador.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the node represents a lifted call; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si el nodo representa una llamada elevada; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull">
      <summary vsli:raw="Gets a value that indicates whether the expression tree node represents a lifted call to an operator whose return type is lifted to a nullable type.">Obtiene un valor que indica si el nodo del árbol de expresión representa una llamada elevada a un operador cuyo tipo de valor devuelto se eleva a un tipo que acepta valores null.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operator's return type is lifted to a nullable type; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si el tipo de valor devuelto del operador se eleva a un tipo que acepta valores null; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Left">
      <summary vsli:raw="Gets the left operand of the binary operation.">Obtiene el operando izquierdo de la operación binaria.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the left operand of the binary operation.">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando izquierdo de la operación binaria.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Method">
      <summary vsli:raw="Gets the implementing method for the binary operation.">Obtiene el método de implementación para la operación binaria.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the implementing method.">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Reduce">
      <summary vsli:raw="Reduces the binary expression node to a simpler expression.">Reduce el nodo de expresión binario a una expresión más sencilla.</summary>
      <returns vsli:raw="The reduced expression.">Expresión reducida.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Right">
      <summary vsli:raw="Gets the right operand of the binary operation.">Obtiene el operando derecho de la operación binaria.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the right operand of the binary operation.">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando derecho de la operación binaria.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Update(System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="left" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property of the result.">La propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> del resultado.</param>
      <param name="conversion" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; property of the result.">La propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> del resultado.</param>
      <param name="right" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property of the result.">La propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> del resultado.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="T:System.Linq.Expressions.BlockExpression">
      <summary vsli:raw="Represents a block that contains a sequence of expressions where variables can be defined.">Representa un bloque que contiene una secuencia de expresiones en la que se pueden definir variables.</summary>
    </member>
    <member name="M:System.Linq.Expressions.BlockExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary vsli:raw="Dispatches to the specific visit method for this node type. For example, &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; calls the &lt;see cref=&quot;M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)&quot; /&gt;.">Envía la expresión al método de visita específico de este tipo de nodo. Por ejemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama a <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor" vsli:raw="The visitor to visit this node with.">Visitante con el que se va a visitar este nodo.</param>
      <returns vsli:raw="The result of visiting this node.">Resultado de visitar este nodo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Expressions">
      <summary vsli:raw="Gets the expressions in this block.">Obtiene las expresiones de este bloque.</summary>
      <returns vsli:raw="The read-only collection containing all the expressions in this block.">Colección de solo lectura que contiene todas las expresiones de este bloque.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.NodeType">
      <summary vsli:raw="Returns the node type of this expression. Extension nodes should return &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Extension&quot; /&gt; when overriding this method.">Devuelve el tipo de nodo de esta expresión. Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> al reemplazar este método.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; of the expression.">Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Result">
      <summary vsli:raw="Gets the last expression in this block.">Obtiene la última expresión de este bloque.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; object representing the last expression in this block.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa la última expresión de este bloque.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.BlockExpression.Type&quot; /&gt; that represents the static type of the expression.">
        <see cref="P:System.Linq.Expressions.BlockExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BlockExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="variables" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.BlockExpression.Variables&quot; /&gt; property of the result.">La propiedad <see cref="P:System.Linq.Expressions.BlockExpression.Variables" /> del resultado.</param>
      <param name="expressions" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.BlockExpression.Expressions&quot; /&gt; property of the result.">La propiedad <see cref="P:System.Linq.Expressions.BlockExpression.Expressions" /> del resultado.</param>
      <returns vsli:raw="This expression if no children changed, or an expression with the updated children.">Esta expresión, si no se ha cambiado ningún elemento secundario, o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Variables">
      <summary vsli:raw="Gets the variables defined in this block.">Obtiene las variables definidas en este bloque.</summary>
      <returns vsli:raw="The read-only collection containing all the variables defined in this block.">Colección de solo lectura que contiene todas las variables definidas en este bloque.</returns>
    </member>
    <member name="T:System.Linq.Expressions.CatchBlock">
      <summary vsli:raw="Represents a catch statement in a try block.">Representa una instrucción catch de un bloque try.</summary>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Body">
      <summary vsli:raw="Gets the body of the catch block.">Obtiene el cuerpo del bloque catch.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; object representing the catch body.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuerpo de catch.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Filter">
      <summary vsli:raw="Gets the body of the &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt; filter.">Obtiene el cuerpo del filtro <see cref="T:System.Linq.Expressions.CatchBlock" />.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; object representing the body of the &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt; filter.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuerpo del filtro <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Test">
      <summary vsli:raw="Gets the type of &lt;see cref=&quot;T:System.Exception&quot; /&gt; this handler catches.">Obtiene el tipo de <see cref="T:System.Exception" /> que este controlador captura.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the type of &lt;see cref=&quot;T:System.Exception&quot; /&gt; this handler catches.">Objeto <see cref="T:System.Type" /> que representa el tipo de <see cref="T:System.Exception" /> que este controlador captura.</returns>
    </member>
    <member name="M:System.Linq.Expressions.CatchBlock.ToString">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.String&quot; /&gt; that represents the current &lt;see cref=&quot;T:System.Object&quot; /&gt;.">Devuelve una clase <see cref="T:System.String" /> que representa la clase <see cref="T:System.Object" /> actual.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.String&quot; /&gt; that represents the current &lt;see cref=&quot;T:System.Object&quot; /&gt;.">Una clase <see cref="T:System.String" /> que representa la clase <see cref="T:System.Object" /> actual.</returns>
    </member>
    <member name="M:System.Linq.Expressions.CatchBlock.Update(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="variable" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.CatchBlock.Variable&quot; /&gt; property of the result.">La propiedad <see cref="P:System.Linq.Expressions.CatchBlock.Variable" /> del resultado.</param>
      <param name="filter" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.CatchBlock.Filter&quot; /&gt; property of the result.">La propiedad <see cref="P:System.Linq.Expressions.CatchBlock.Filter" /> del resultado.</param>
      <param name="body" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.CatchBlock.Body&quot; /&gt; property of the result.">La propiedad <see cref="P:System.Linq.Expressions.CatchBlock.Body" /> del resultado.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Variable">
      <summary vsli:raw="Gets a reference to the &lt;see cref=&quot;T:System.Exception&quot; /&gt; object caught by this handler.">Obtiene una referencia al objeto <see cref="T:System.Exception" /> capturado por este controlador.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; object representing a reference to the &lt;see cref=&quot;T:System.Exception&quot; /&gt; object caught by this handler.">Objeto <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representa una referencia al objeto <see cref="T:System.Exception" /> capturado por este controlador.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ConditionalExpression">
      <summary vsli:raw="Represents an expression that has a conditional operator.">Representa una expresión que tiene un operador condicional.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ConditionalExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary vsli:raw="Dispatches to the specific visit method for this node type. For example, &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; calls the &lt;see cref=&quot;M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)&quot; /&gt;.">Envía la expresión al método de visita específico de este tipo de nodo. Por ejemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama a <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor" vsli:raw="The visitor to visit this node with.">Visitante con el que se va a visitar este nodo.</param>
      <returns vsli:raw="The result of visiting this node.">Resultado de visitar este nodo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.IfFalse">
      <summary vsli:raw="Gets the expression to execute if the test evaluates to &lt;see langword=&quot;false&quot; /&gt;.">Obtiene la expresión que se va a ejecutar si la prueba se evalúa como <see langword="false" />.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the expression to execute if the test is &lt;see langword=&quot;false&quot; /&gt;.">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa la expresión que se va a ejecutar si la prueba se evalúa como <see langword="false" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.IfTrue">
      <summary vsli:raw="Gets the expression to execute if the test evaluates to &lt;see langword=&quot;true&quot; /&gt;.">Obtiene la expresión que se va a ejecutar si la prueba se evalúa como <see langword="true" />.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the expression to execute if the test is &lt;see langword=&quot;true&quot; /&gt;.">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa la expresión que se va a ejecutar si la prueba se evalúa como <see langword="true" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.NodeType">
      <summary vsli:raw="Returns the node type of this expression. Extension nodes should return &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Extension&quot; /&gt; when overriding this method.">Devuelve el tipo de nodo de esta expresión. Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> al reemplazar este método.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; of the expression.">Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.Test">
      <summary vsli:raw="Gets the test of the conditional operation.">Obtiene la prueba de la operación condicional.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the test of the conditional operation.">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa la prueba de la operación condicional.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.Type&quot; /&gt; that represents the static type of the expression.">
        <see cref="P:System.Linq.Expressions.ConditionalExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ConditionalExpression.Update(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="test" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.Test&quot; /&gt; property of the result.">La propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> del resultado.</param>
      <param name="ifTrue" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfTrue&quot; /&gt; property of the result.">La propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> del resultado.</param>
      <param name="ifFalse" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfFalse&quot; /&gt; property of the result.">La propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> del resultado.</param>
      <returns vsli:raw="This expression if no children changed, or an expression with the updated children.">Esta expresión, si no se ha cambiado ningún elemento secundario, o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ConstantExpression">
      <summary vsli:raw="Represents an expression that has a constant value.">Representa una expresión que tiene un valor constante.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ConstantExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary vsli:raw="Dispatches to the specific visit method for this node type. For example, &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; calls the &lt;see cref=&quot;M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)&quot; /&gt;.">Envía la expresión al método de visita específico de este tipo de nodo. Por ejemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama a <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor" vsli:raw="The visitor to visit this node with.">Visitante con el que se va a visitar este nodo.</param>
      <returns vsli:raw="The result of visiting this node.">Resultado de visitar este nodo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.NodeType">
      <summary vsli:raw="Returns the node type of this Expression. Extension nodes should return &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Extension&quot; /&gt; when overriding this method.">Devuelve el tipo de nodo de esta expresión. Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> al reemplazar este método.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; of the expression.">Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.ConstantExpression.Type&quot; /&gt; that represents the static type of the expression.">
        <see cref="P:System.Linq.Expressions.ConstantExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.Value">
      <summary vsli:raw="Gets the value of the constant expression.">Obtiene el valor de la expresión constante.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Object&quot; /&gt; equal to the value of the represented expression.">
        <see cref="T:System.Object" /> igual al valor de la expresión representada.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DebugInfoExpression">
      <summary vsli:raw="Emits or clears a sequence point for debug information. This allows the debugger to highlight the correct source code when debugging.">Emite o borra un punto de secuencia para obtener información de depuración. Esto permite al depurador resaltar el código fuente correcto al depurar.</summary>
    </member>
    <member name="M:System.Linq.Expressions.DebugInfoExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary vsli:raw="Dispatches to the specific visit method for this node type. For example, &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; calls the &lt;see cref=&quot;M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)&quot; /&gt;.">Envía la expresión al método de visita específico de este tipo de nodo. Por ejemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama a <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor" vsli:raw="The visitor to visit this node with.">Visitante con el que se va a visitar este nodo.</param>
      <returns vsli:raw="The result of visiting this node.">Resultado de visitar este nodo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.Document">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Linq.Expressions.SymbolDocumentInfo&quot; /&gt; that represents the source file.">Obtiene la clase <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que representa el archivo de código fuente.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.SymbolDocumentInfo&quot; /&gt; that represents the source file.">
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que representa el archivo de origen.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.EndColumn">
      <summary vsli:raw="Gets the end column of this &lt;see cref=&quot;T:System.Linq.Expressions.DebugInfoExpression&quot; /&gt;.">Obtiene la columna final de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns vsli:raw="The number of the end column of the code that was used to generate the wrapped expression.">Número de la columna final del código que se utilizó para generar la expresión ajustada.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.EndLine">
      <summary vsli:raw="Gets the end line of this &lt;see cref=&quot;T:System.Linq.Expressions.DebugInfoExpression&quot; /&gt;.">Obtiene la línea final de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns vsli:raw="The number of the end line of the code that was used to generate the wrapped expression.">Número de la línea final del código que se utilizó para generar la expresión ajustada.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.IsClear">
      <summary vsli:raw="Gets the value to indicate if the &lt;see cref=&quot;T:System.Linq.Expressions.DebugInfoExpression&quot; /&gt; is for clearing a sequence point.">Obtiene el valor para indicar si <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> se utiliza para borrar un punto de secuencia.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Linq.Expressions.DebugInfoExpression&quot; /&gt; is for clearing a sequence point; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />es si se va a borrar un punto de secuencia; <see langword="false" />en caso contrario, es. <see cref="T:System.Linq.Expressions.DebugInfoExpression" /></returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.NodeType">
      <summary vsli:raw="Returns the node type of this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Devuelve el tipo de nodo de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that represents this expression.">Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.StartColumn">
      <summary vsli:raw="Gets the start column of this &lt;see cref=&quot;T:System.Linq.Expressions.DebugInfoExpression&quot; /&gt;.">Obtiene la columna inicial de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns vsli:raw="The number of the start column of the code that was used to generate the wrapped expression.">Número de la columna inicial del código que se utilizó para generar la expresión ajustada.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.StartLine">
      <summary vsli:raw="Gets the start line of this &lt;see cref=&quot;T:System.Linq.Expressions.DebugInfoExpression&quot; /&gt;.">Obtiene la línea inicial de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns vsli:raw="The number of the start line of the code that was used to generate the wrapped expression.">Número de la línea inicial del código que se utilizó para generar la expresión ajustada.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.DebugInfoExpression.Type&quot; /&gt; that represents the static type of the expression.">
        <see cref="P:System.Linq.Expressions.DebugInfoExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DefaultExpression">
      <summary vsli:raw="Represents the default value of a type or an empty expression.">Representa el valor predeterminado de un tipo o una expresión vacía.</summary>
    </member>
    <member name="P:System.Linq.Expressions.DefaultExpression.NodeType">
      <summary vsli:raw="Returns the node type of this expression. Extension nodes should return &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Extension&quot; /&gt; when overriding this method.">Devuelve el tipo de nodo de esta expresión. Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> al reemplazar este método.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; of the expression.">Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DefaultExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.DefaultExpression.Type&quot; /&gt; that represents the static type of the expression.">
        <see cref="P:System.Linq.Expressions.DefaultExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DynamicExpression">
      <summary vsli:raw="Represents a dynamic operation.">Representa una operación dinámica.</summary>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary vsli:raw="Dispatches to the specific visit method for this node type. For example, &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; calls the &lt;see cref=&quot;M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)&quot; /&gt;.">Envía la expresión al método de visita específico de este tipo de nodo. Por ejemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama a <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor" vsli:raw="The visitor to visit this node with.">Visitante con el que se va a visitar este nodo.</param>
      <returns vsli:raw="The result of visiting this node.">Resultado de visitar este nodo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.Arguments">
      <summary vsli:raw="Gets the arguments to the dynamic operation.">Obtiene los argumentos de la operación dinámica.</summary>
      <returns vsli:raw="The read-only collections containing the arguments to the dynamic operation.">Colecciones de solo lectura que contienen los argumentos de la operación dinámica.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.Binder">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;, which determines the run-time behavior of the dynamic site.">Obtiene el <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />, que determina el comportamiento en tiempo de ejecución del sitio dinámico.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;, which determines the run-time behavior of the dynamic site.">
        <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />, que determina el comportamiento en tiempo de ejecución del sitio dinámico.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.DelegateType">
      <summary vsli:raw="Gets the type of the delegate used by the &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSite&quot; /&gt;.">Obtiene el tipo del delegado utilizado por la clase <see cref="T:System.Runtime.CompilerServices.CallSite" />.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the type of the delegate used by the &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSite&quot; /&gt;.">Objeto <see cref="T:System.Type" /> que representa el tipo del delegado utilizado por la clase <see cref="T:System.Runtime.CompilerServices.CallSite" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;.">Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado.</summary>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="returnType" vsli:raw="The result type of the dynamic expression.">Tipo de resultado de la expresión dinámica.</param>
      <param name="arguments" vsli:raw="The arguments to the dynamic operation.">Argumentos de la operación dinámica.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt;,  and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> están establecidas en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;.">Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado.</summary>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="returnType" vsli:raw="The result type of the dynamic expression.">Tipo de resultado de la expresión dinámica.</param>
      <param name="arg0" vsli:raw="The first argument to the dynamic operation.">Primer argumento de la operación dinámica.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt;,  and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> están establecidas en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;.">Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado.</summary>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="returnType" vsli:raw="The result type of the dynamic expression.">Tipo de resultado de la expresión dinámica.</param>
      <param name="arg0" vsli:raw="The first argument to the dynamic operation.">Primer argumento de la operación dinámica.</param>
      <param name="arg1" vsli:raw="The second argument to the dynamic operation.">Segundo argumento de la operación dinámica.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt;, and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> están establecidas en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;.">Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado.</summary>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="returnType" vsli:raw="The result type of the dynamic expression.">Tipo de resultado de la expresión dinámica.</param>
      <param name="arg0" vsli:raw="The first argument to the dynamic operation.">Primer argumento de la operación dinámica.</param>
      <param name="arg1" vsli:raw="The second argument to the dynamic operation.">Segundo argumento de la operación dinámica.</param>
      <param name="arg2" vsli:raw="The third argument to the dynamic operation.">Tercer argumento de la operación dinámica.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt;, and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> están establecidas en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;.">Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado.</summary>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="returnType" vsli:raw="The result type of the dynamic expression.">Tipo de resultado de la expresión dinámica.</param>
      <param name="arg0" vsli:raw="The first argument to the dynamic operation.">Primer argumento de la operación dinámica.</param>
      <param name="arg1" vsli:raw="The second argument to the dynamic operation.">Segundo argumento de la operación dinámica.</param>
      <param name="arg2" vsli:raw="The third argument to the dynamic operation.">Tercer argumento de la operación dinámica.</param>
      <param name="arg3" vsli:raw="The fourth argument to the dynamic operation.">Cuarto argumento de la operación dinámica.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt;, and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> están establecidas en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;.">Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado.</summary>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="returnType" vsli:raw="The result type of the dynamic expression.">Tipo de resultado de la expresión dinámica.</param>
      <param name="arguments" vsli:raw="The arguments to the dynamic operation.">Argumentos de la operación dinámica.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt;, and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> están establecidas en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;.">Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado.</summary>
      <param name="delegateType" vsli:raw="The type of the delegate used by the &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSite&quot; /&gt;.">Tipo de delegado usado por <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="arguments" vsli:raw="The arguments to the dynamic operation.">Argumentos de la operación dinámica.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt;, and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.DelegateType&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt; and one argument.">Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado y un argumento.</summary>
      <param name="delegateType" vsli:raw="The type of the delegate used by the &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSite&quot; /&gt;.">Tipo de delegado usado por <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="arg0" vsli:raw="The argument to the dynamic operation.">Argumento de la operación dinámica.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt;, and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.DelegateType&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt; and two arguments.">Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado y dos argumentos.</summary>
      <param name="delegateType" vsli:raw="The type of the delegate used by the &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSite&quot; /&gt;.">Tipo de delegado usado por <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="arg0" vsli:raw="The first argument to the dynamic operation.">Primer argumento de la operación dinámica.</param>
      <param name="arg1" vsli:raw="The second argument to the dynamic operation.">Segundo argumento de la operación dinámica.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt;, and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.DelegateType&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt; and three arguments.">Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado y tres argumentos.</summary>
      <param name="delegateType" vsli:raw="The type of the delegate used by the &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSite&quot; /&gt;.">Tipo de delegado usado por <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="arg0" vsli:raw="The first argument to the dynamic operation.">Primer argumento de la operación dinámica.</param>
      <param name="arg1" vsli:raw="The second argument to the dynamic operation.">Segundo argumento de la operación dinámica.</param>
      <param name="arg2" vsli:raw="The third argument to the dynamic operation.">Tercer argumento de la operación dinámica.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt;, and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.DelegateType&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt; and four arguments.">Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado y cuatro argumentos.</summary>
      <param name="delegateType" vsli:raw="The type of the delegate used by the &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSite&quot; /&gt;.">Tipo de delegado usado por <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="arg0" vsli:raw="The first argument to the dynamic operation.">Primer argumento de la operación dinámica.</param>
      <param name="arg1" vsli:raw="The second argument to the dynamic operation.">Segundo argumento de la operación dinámica.</param>
      <param name="arg2" vsli:raw="The third argument to the dynamic operation.">Tercer argumento de la operación dinámica.</param>
      <param name="arg3" vsli:raw="The fourth argument to the dynamic operation.">Cuarto argumento de la operación dinámica.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt;, and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.DelegateType&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;.">Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado.</summary>
      <param name="delegateType" vsli:raw="The type of the delegate used by the &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSite&quot; /&gt;.">Tipo de delegado usado por <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="arguments" vsli:raw="The arguments to the dynamic operation.">Argumentos de la operación dinámica.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt;, and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.DelegateType&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.NodeType">
      <summary vsli:raw="Returns the node type of this expression. Extension nodes should return &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Extension&quot; /&gt; when overriding this method.">Devuelve el tipo de nodo de esta expresión. Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> al reemplazar este método.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; of the expression.">Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount">
      <summary vsli:raw="Returns the number of arguments to the expression tree node. You should not use this member. It is only public due to assembly refactoring, and it is used internally for performance optimizations.">Devuelve el número de argumentos al nodo de árbol de expresión. No debe usar este miembro. Solo es público debido a la refactorización del ensamblado y se usa internamente para optimizaciones de rendimiento.</summary>
      <returns vsli:raw="Returns &lt;see cref=&quot;T:System.Int32&quot; /&gt;.">Devuelva <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)">
      <summary vsli:raw="Returns the argument at index, throwing if index is out of bounds. You should not use this member. It is only public due to assembly refactoring, and it is used internally for performance optimizations.">Devuelve el argumento en el índice, indicando si el índice está fuera de los límites. No debe usar este miembro. Solo es público debido a la refactorización del ensamblado y se usa internamente para optimizaciones de rendimiento.</summary>
      <param name="index" vsli:raw="The index of the argument.">Índice del argumento.</param>
      <returns vsli:raw="Returns &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Devuelva <see cref="T:System.Linq.Expressions.Expression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.System#Linq#Expressions#IDynamicExpression#CreateCallSite">
      <summary vsli:raw="Optionally creates the CallSite and returns the CallSite for the DynamicExpression's polymorphic inline cache. You should not use this member. It is only public due to assembly refactoring, and it is used internally for performance optimizations.">Opcionalmente, crea el elemento CallSite y devuelve el de la caché insertada polimórfica de DynamicExpression. No debe usar este miembro. Solo es público debido a la refactorización del ensamblado y se usa internamente para optimizaciones de rendimiento.</summary>
      <returns vsli:raw="Returns &lt;see cref=&quot;T:System.Object&quot; /&gt;.">Devuelva <see cref="T:System.Object" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.System#Linq#Expressions#IDynamicExpression#Rewrite(System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Rewrite this node replacing the dynamic expression's arguments with the provided values. The number of &lt;paramref name=&quot;args&quot; /&gt; needs to match the number of the current expression. You should not use this type. It is only public due to assembly refactoring, and it is used internally for performance optimizations. This helper method allows re-writing of nodes to be independent of the specific implementation class deriving from DynamicExpression that is being used at the call site.">Vuelva a escribir este nodo y reemplace los argumentos de la expresión dinámica por los valores proporcionados. El número de <paramref name="args" /> debe coincidir con el número de la expresión actual. No se debe usar este tipo. Solo es público debido a la refactorización del ensamblado y se usa internamente para optimizaciones de rendimiento. Este método auxiliar permite volver a escribir los nodos de modo que sean independientes de la clase de implementación específica que deriva del elemento DynamicExpression que se usa en el sitio de llamada.</summary>
      <param name="args" vsli:raw="The arguments.">Los argumentos.</param>
      <returns vsli:raw="Returns &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;, the rewritten expression.">Devuelve <see cref="T:System.Linq.Expressions.Expression" />, la expresión reescrita.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Type&quot; /&gt; that represents the static type of the expression.">
        <see cref="P:System.Linq.Expressions.DynamicExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Compares the value sent to the parameter, &lt;paramref name=&quot;arguments&quot; /&gt;, to the &lt;see langword=&quot;Arguments&quot; /&gt; property of the current instance of &lt;see langword=&quot;DynamicExpression&quot; /&gt;. If the values of the parameter and the property are equal, the current instance is returned. If they are not equal, a new &lt;see langword=&quot;DynamicExpression&quot; /&gt; instance is returned that is identical to the current instance except that the &lt;see langword=&quot;Arguments&quot; /&gt; property is set to the value of parameter &lt;paramref name=&quot;arguments&quot; /&gt;.">Compara el valor enviado al parámetro, <paramref name="arguments" />, con la propiedad <see langword="Arguments" /> de la misma instancia de <see langword="DynamicExpression" />. Si los valores del parámetro y de la propiedad son iguales, se devuelve la instancia actual. Si no son iguales, se devuelve una nueva instancia de <see langword="DynamicExpression" /> que es idéntica a la instancia actual a menos que la propiedad <see langword="Arguments" /> se establezca en el valor de parámetro <paramref name="arguments" />.</summary>
      <param name="arguments" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; property of the result.">La propiedad <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> del resultado.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DynamicExpressionVisitor">
      <summary vsli:raw="Represents a visitor or rewriter for dynamic expression trees.">Representa un visitante o un objeto de reescritura de árboles de expresión dinámicos.</summary>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpressionVisitor.#ctor">
      <summary vsli:raw="Initializes a new instance of &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpressionVisitor&quot; /&gt;.">Inicializa una nueva instancia de la clase <see cref="T:System.Linq.Expressions.DynamicExpressionVisitor" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpressionVisitor.VisitDynamic(System.Linq.Expressions.DynamicExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt;.">Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.DynamicExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expresión que se va a visitar.</param>
      <returns vsli:raw="Returns &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;, the modified expression, if it or any subexpression is modified; otherwise, returns the original expression.">Devuelve <see cref="T:System.Linq.Expressions.Expression" />, la expresión modificada si se modifica esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ElementInit">
      <summary vsli:raw="Represents an initializer for a single element of an &lt;see cref=&quot;T:System.Collections.IEnumerable&quot; /&gt; collection.">Representa un inicializador para un elemento único de una colección <see cref="T:System.Collections.IEnumerable" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.AddMethod">
      <summary vsli:raw="Gets the instance method that is used to add an element to an &lt;see cref=&quot;T:System.Collections.IEnumerable&quot; /&gt; collection.">Obtiene el método de instancia que se usa para agregar un elemento a una colección <see cref="T:System.Collections.IEnumerable" />.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents an instance method that adds an element to a collection.">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de instancia que agrega un elemento a una colección.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.Arguments">
      <summary vsli:raw="Gets the collection of arguments that are passed to a method that adds an element to an &lt;see cref=&quot;T:System.Collections.IEnumerable&quot; /&gt; collection.">Obtiene la colección de argumentos que se pasan a un método que agrega un elemento a una colección <see cref="T:System.Collections.IEnumerable" />.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Collections.ObjectModel.ReadOnlyCollection`1&quot; /&gt; of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects that represent the arguments for a method that adds an element to a collection.">
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los argumentos de un método que agrega un elemento a una colección.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.System#Linq#Expressions#IArgumentProvider#ArgumentCount">
      <summary vsli:raw="Returns the number of arguments to the expression tree node.  You should not use this member.  It is only public due to assembly refactoring, and it is used internally for performance optimizations.">Devuelve el número de argumentos al nodo de árbol de expresión.  No debe usar este miembro.  Solo es público debido a la refactorización del ensamblado y se usa internamente para optimizaciones de rendimiento.</summary>
      <returns vsli:raw="Returns &lt;see cref=&quot;T:System.Int32&quot; /&gt;.">Devuelva <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ElementInit.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)">
      <summary vsli:raw="Returns the argument at index, throwing if index is out of bounds.  You should not use this member.  It is only public due to assembly refactoring, and it is used internally for performance optimizations.">Devuelve el argumento en el índice, indicando si el índice está fuera de los límites.  No debe usar este miembro.  Solo es público debido a la refactorización del ensamblado y se usa internamente para optimizaciones de rendimiento.</summary>
      <param name="index" vsli:raw="The index of the argument.">Índice del argumento.</param>
      <returns vsli:raw="Returns &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Devuelva <see cref="T:System.Linq.Expressions.Expression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ElementInit.ToString">
      <summary vsli:raw="Returns a textual representation of an &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt; object.">Devuelve una representación textual de un objeto <see cref="T:System.Linq.Expressions.ElementInit" />.</summary>
      <returns vsli:raw="A textual representation of the &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt; object.">Representación textual del objeto <see cref="T:System.Linq.Expressions.ElementInit" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ElementInit.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="arguments" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.ElementInit.Arguments&quot; /&gt; property of the result.">La propiedad <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> del resultado.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="T:System.Linq.Expressions.Expression">
      <summary vsli:raw="Provides the base class from which the classes that represent expression tree nodes are derived. It also contains &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic) factory methods to create the various node types. This is an &lt;see langword=&quot;abstract&quot; /&gt; class.">Proporciona la clase base de la que se derivan las clases que representan los nodos de árbol de expresión. También contiene métodos de generador <see langword="static" /> (<see langword="Shared" /> en Visual Basic) para crear los diversos tipos de nodo. Esta es una clase <see langword="abstract" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.Expression.#ctor">
      <summary vsli:raw="Constructs a new instance of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Crea una nueva instancia de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.Expression.#ctor(System.Linq.Expressions.ExpressionType,System.Type)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; class.">Inicializa una nueva instancia de la clase <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <param name="nodeType" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; to set as the node type.">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> que se va a establecer como tipo de nodo.</param>
      <param name="type" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; of this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> de este <see cref="T:System.Linq.Expressions.Expression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary vsli:raw="Dispatches to the specific visit method for this node type. For example, &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; calls the &lt;see cref=&quot;M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)&quot; /&gt;.">Envía la expresión al método de visita específico de este tipo de nodo. Por ejemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama a <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor" vsli:raw="The visitor to visit this node with.">Visitante con el que se va a visitar este nodo.</param>
      <returns vsli:raw="The result of visiting this node.">Resultado de visitar este nodo.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an arithmetic addition operation that does not have overflow checking.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de suma aritmética sin comprobación de desbordamiento.</summary>
      <param name="left" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Add&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The addition operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">No hay ningún operador de suma definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an arithmetic addition operation that does not have overflow checking. The implementing method can be specified.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de suma aritmética sin comprobación de desbordamiento. Se puede especificar el método de implementación.</summary>
      <param name="left" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Add&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the addition operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> es <see langword="null" /> y el operador de adición no está definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an addition assignment operation that does not have overflow checking.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de suma que no tiene comprobación de desbordamiento.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.AddAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an addition assignment operation that does not have overflow checking.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de suma que no tiene comprobación de desbordamiento.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.AddAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an addition assignment operation that does not have overflow checking.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de suma que no tiene comprobación de desbordamiento.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.AddAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an addition assignment operation that has overflow checking.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de suma que tiene comprobación de desbordamiento.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.AddAssignChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an addition assignment operation that has overflow checking.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de suma que tiene comprobación de desbordamiento.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.AddAssignChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an addition assignment operation that has overflow checking.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de suma que tiene comprobación de desbordamiento.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.AddAssignChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an arithmetic addition operation that has overflow checking.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de suma aritmética con comprobación de desbordamiento.</summary>
      <param name="left" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.AddChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The addition operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">No hay ningún operador de suma definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an arithmetic addition operation that has overflow checking. The implementing method can be specified.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de suma aritmética con comprobación de desbordamiento. Se puede especificar el método de implementación.</summary>
      <param name="left" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.AddChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the addition operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> es <see langword="null" /> y el operador de adición no está definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise &lt;see langword=&quot;AND&quot; /&gt; operation.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación <see langword="AND" /> bit a bit.</summary>
      <param name="left" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.And&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.And" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The bitwise &lt;see langword=&quot;AND&quot; /&gt; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">No hay ningún operador <see langword="AND" /> bit a bit definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise &lt;see langword=&quot;AND&quot; /&gt; operation. The implementing method can be specified.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación <see langword="AND" /> bit a bit. Se puede especificar el método de implementación.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.And&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.And" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the bitwise &lt;see langword=&quot;AND&quot; /&gt; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> es <see langword="null" /> y el operador <see langword="AND" /> bit a bit no está definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a conditional &lt;see langword=&quot;AND&quot; /&gt; operation that evaluates the second operand only if the first operand evaluates to &lt;see langword=&quot;true&quot; /&gt;.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación <see langword="AND" /> condicional que evalúa el segundo operando únicamente si el primer operando se evalúa como <see langword="true" />.</summary>
      <param name="left" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.AndAlso&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The bitwise &lt;see langword=&quot;AND&quot; /&gt; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type are not the same Boolean type.">No hay ningún operador <see langword="AND" /> bit a bit definido para <paramref name="left" />.Type y <paramref name="right" />.Type.  
o bien 
 <paramref name="left" />.Type y <paramref name="right" />.Type no son del mismo tipo booleano.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a conditional &lt;see langword=&quot;AND&quot; /&gt; operation that evaluates the second operand only if the first operand is resolved to true. The implementing method can be specified.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación <see langword="AND" /> condicional que evalúa el segundo operando solo si el primer operando se resuelve como true. Se puede especificar el método de implementación.</summary>
      <param name="left" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.AndAlso&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the bitwise &lt;see langword=&quot;AND&quot; /&gt; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type are not the same Boolean type.">
        <paramref name="method" /> es <see langword="null" /> y el operador <see langword="AND" /> bit a bit no está definido para <paramref name="left" />.Type y <paramref name="right" />.Type.  
O bien 
 <paramref name="method" /> es <see langword="null" /> y <paramref name="left" />.Type y <paramref name="right" />.Type no son del mismo tipo booleano.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise AND assignment operation.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación AND bit a bit.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.AndAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise AND assignment operation.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación AND bit a bit.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.AndAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise AND assignment operation.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación AND bit a bit.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.AndAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Linq.Expressions.IndexExpression&quot; /&gt; to access a multidimensional array.">Crea un objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> para obtener acceso a una matriz multidimensional.</summary>
      <param name="array" vsli:raw="An expression that represents the multidimensional array.">Expresión que representa la matriz multidimensional.</param>
      <param name="indexes" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; containing expressions used to index the array.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene expresiones usadas para indexar la matriz.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.IndexExpression&quot; /&gt;.">Objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Linq.Expressions.IndexExpression&quot; /&gt; to access an array.">Crea un objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> para obtener acceso a una matriz.</summary>
      <param name="array" vsli:raw="An expression representing the array to index.">Expresión que representa la matriz para indizar.</param>
      <param name="indexes" vsli:raw="An array that contains expressions used to index the array.">Matriz que contiene expresiones usadas para indizar la matriz.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.IndexExpression&quot; /&gt;.">Objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that represents applying an array index operator to an array of rank more than one.">Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa la aplicación de un operador de índice de matriz a una matriz cuyo rango es mayor que uno.</summary>
      <param name="array" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />.</param>
      <param name="indexes" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Arguments&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Call&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Arguments&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt; or &lt;paramref name=&quot;indexes&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="array" /> o <paramref name="indexes" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt;.Type does not represent an array type.  &#xA;  &#xA; -or-  &#xA;  &#xA; The rank of &lt;paramref name=&quot;array&quot; /&gt;.Type does not match the number of elements in &lt;paramref name=&quot;indexes&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of one or more elements of &lt;paramref name=&quot;indexes&quot; /&gt; does not represent the &lt;see cref=&quot;T:System.Int32&quot; /&gt; type.">
        <paramref name="array" />.Type no representa un tipo de matriz.  
O bien 
El rango de <paramref name="array" />.Type no coincide con el número de elementos en <paramref name="indexes" />.  
o bien 
La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de uno o varios elementos de <paramref name="indexes" /> no representa el tipo <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents applying an array index operator to an array of rank one.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa la aplicación de un operador de índice de matriz a una matriz de rango uno.</summary>
      <param name="array" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="index" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ArrayIndex&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ArrayIndex" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt; or &lt;paramref name=&quot;index&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="array" /> o <paramref name="index" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt;.Type does not represent an array type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;array&quot; /&gt;.Type represents an array type whose rank is not 1.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;index&quot; /&gt;.Type does not represent the &lt;see cref=&quot;T:System.Int32&quot; /&gt; type.">
        <paramref name="array" />.Type no representa un tipo de matriz.  
o bien 
 <paramref name="array" />.Type representa un tipo de matriz cuyo rango no es 1.  
o bien 
 <paramref name="index" />.Type no representa el tipo <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that represents applying an array index operator to a multidimensional array.">Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa la aplicación de un operador de índice de matriz a una matriz multidimensional.</summary>
      <param name="array" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; instances - indexes for the array index operation.">Matriz de instancias o índices <see cref="T:System.Linq.Expressions.Expression" /> para la operación de índice de matriz.</param>
      <param name="indexes" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Arguments&quot; /&gt; collection.">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Call&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Arguments&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt; or &lt;paramref name=&quot;indexes&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="array" /> o <paramref name="indexes" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt;.Type does not represent an array type.  &#xA;  &#xA; -or-  &#xA;  &#xA; The rank of &lt;paramref name=&quot;array&quot; /&gt;.Type does not match the number of elements in &lt;paramref name=&quot;indexes&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of one or more elements of &lt;paramref name=&quot;indexes&quot; /&gt; does not represent the &lt;see cref=&quot;T:System.Int32&quot; /&gt; type.">
        <paramref name="array" />.Type no representa un tipo de matriz.  
O bien 
El rango de <paramref name="array" />.Type no coincide con el número de elementos en <paramref name="indexes" />.  
O bien 
La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de uno o varios elementos de <paramref name="indexes" /> no representa el tipo <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayLength(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents an expression for obtaining the length of a one-dimensional array.">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una expresión para obtener la longitud de una matriz unidimensional.</summary>
      <param name="array" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ArrayLength&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property equal to &lt;paramref name=&quot;array&quot; /&gt;.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ArrayLength" /> y cuya propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> es <paramref name="array" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="array" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt;.Type does not represent an array type.">
        <paramref name="array" />.Type no representa un tipo de matriz.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Assign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an assignment operation.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Assign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Assign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MemberInfo,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberAssignment&quot; /&gt; that represents the initialization of a field or property.">Crea un objeto <see cref="T:System.Linq.Expressions.MemberAssignment" /> que representa la inicialización de un campo o una propiedad.</summary>
      <param name="member" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MemberInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MemberAssignment.Expression&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberAssignment&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.BindingType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.MemberBindingType.Assignment&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MemberAssignment.Expression&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.MemberAssignment" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> y <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;member&quot; /&gt; or &lt;paramref name=&quot;expression&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="member" /> o <paramref name="expression" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;member&quot; /&gt; does not represent a field or property.  &#xA;  &#xA; -or-  &#xA;  &#xA; The property represented by &lt;paramref name=&quot;member&quot; /&gt; does not have a &lt;see langword=&quot;set&quot; /&gt; accessor.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;expression&quot; /&gt;.Type is not assignable to the type of the field or property that &lt;paramref name=&quot;member&quot; /&gt; represents.">
        <paramref name="member" /> no representa ningún campo ni ninguna propiedad.  
O bien 
La propiedad representada por <paramref name="member" /> no tiene un descriptor de acceso <see langword="set" />.  
O bien 
 <paramref name="expression" />.Type no se puede asignar al tipo del campo o propiedad que representa <paramref name="member" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberAssignment&quot; /&gt; that represents the initialization of a member by using a property accessor method.">Crea un objeto <see cref="T:System.Linq.Expressions.MemberAssignment" /> que representa la inicialización de un miembro mediante un método de descriptor de acceso de propiedad.</summary>
      <param name="propertyAccessor" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents a property accessor method.">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de descriptor de acceso de propiedad.</param>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MemberAssignment.Expression&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberAssignment&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.BindingType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.MemberBindingType.Assignment&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; property set to the &lt;see cref=&quot;T:System.Reflection.PropertyInfo&quot; /&gt; that represents the property accessed in &lt;paramref name=&quot;propertyAccessor&quot; /&gt;, and the &lt;see cref=&quot;P:System.Linq.Expressions.MemberAssignment.Expression&quot; /&gt; property set to &lt;paramref name=&quot;expression&quot; /&gt;.">
        <see cref="T:System.Linq.Expressions.MemberAssignment" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> se establece en el objeto <see cref="T:System.Reflection.PropertyInfo" /> que representa la propiedad a la que se obtiene acceso en <paramref name="propertyAccessor" />, y cuya propiedad <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> se establece en <paramref name="expression" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;propertyAccessor&quot; /&gt; or &lt;paramref name=&quot;expression&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="propertyAccessor" /> o <paramref name="expression" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;propertyAccessor&quot; /&gt; does not represent a property accessor method.  &#xA;  &#xA; -or-  &#xA;  &#xA; The property accessed by &lt;paramref name=&quot;propertyAccessor&quot; /&gt; does not have a &lt;see langword=&quot;set&quot; /&gt; accessor.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;expression&quot; /&gt;.Type is not assignable to the type of the field or property that &lt;paramref name=&quot;member&quot; /&gt; represents.">
        <paramref name="propertyAccessor" /> no representa un método de descriptor de acceso de propiedad.  
O bien 
La propiedad a la que accede <paramref name="propertyAccessor" /> no tiene un descriptor de acceso <see langword="set" />.  
o bien 
 <paramref name="expression" />.Type no se puede asignar al tipo del campo o propiedad que representa <paramref name="member" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt; that contains the given expressions and has no variables.">Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las expresiones dadas y que no tiene variables.</summary>
      <param name="expressions" vsli:raw="The expressions in the block.">Expresiones del bloque.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt;.">Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt; that contains the given variables and expressions.">Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las variables y expresiones dadas.</summary>
      <param name="variables" vsli:raw="The variables in the block.">Variables del bloque.</param>
      <param name="expressions" vsli:raw="The expressions in the block.">Expresiones del bloque.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt;.">Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt; that contains the given variables and expressions.">Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las variables y expresiones dadas.</summary>
      <param name="variables" vsli:raw="The variables in the block.">Variables del bloque.</param>
      <param name="expressions" vsli:raw="The expressions in the block.">Expresiones del bloque.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt;.">Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt; that contains two expressions and has no variables.">Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene dos expresiones y que no tiene variables.</summary>
      <param name="arg0" vsli:raw="The first expression in the block.">Primera expresión del bloque.</param>
      <param name="arg1" vsli:raw="The second expression in the block.">Segunda expresión del bloque.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt;.">Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt; that contains three expressions and has no variables.">Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene tres expresiones y que no tiene variables.</summary>
      <param name="arg0" vsli:raw="The first expression in the block.">Primera expresión del bloque.</param>
      <param name="arg1" vsli:raw="The second expression in the block.">Segunda expresión del bloque.</param>
      <param name="arg2" vsli:raw="The third expression in the block.">Tercera expresión del bloque.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt;.">Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt; that contains four expressions and has no variables.">Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene cuatro expresiones y que no tiene variables.</summary>
      <param name="arg0" vsli:raw="The first expression in the block.">Primera expresión del bloque.</param>
      <param name="arg1" vsli:raw="The second expression in the block.">Segunda expresión del bloque.</param>
      <param name="arg2" vsli:raw="The third expression in the block.">Tercera expresión del bloque.</param>
      <param name="arg3" vsli:raw="The fourth expression in the block.">Cuarta expresión del bloque.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt;.">Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt; that contains five expressions and has no variables.">Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene cinco expresiones y que no tiene variables.</summary>
      <param name="arg0" vsli:raw="The first expression in the block.">Primera expresión del bloque.</param>
      <param name="arg1" vsli:raw="The second expression in the block.">Segunda expresión del bloque.</param>
      <param name="arg2" vsli:raw="The third expression in the block.">Tercera expresión del bloque.</param>
      <param name="arg3" vsli:raw="The fourth expression in the block.">Cuarta expresión del bloque.</param>
      <param name="arg4" vsli:raw="The fifth expression in the block.">Quinta expresión del bloque.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt;.">Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt; that contains the given expressions and has no variables.">Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las expresiones dadas y que no tiene variables.</summary>
      <param name="expressions" vsli:raw="The expressions in the block.">Expresiones del bloque.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt;.">Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt; that contains the given expressions, has no variables and has specific result type.">Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las expresiones dadas, no tiene variables y tiene el tipo de resultado específico.</summary>
      <param name="type" vsli:raw="The result type of the block.">Tipo de resultado del bloque.</param>
      <param name="expressions" vsli:raw="The expressions in the block.">Expresiones del bloque.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt;.">Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt; that contains the given variables and expressions.">Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las variables y expresiones dadas.</summary>
      <param name="type" vsli:raw="The result type of the block.">Tipo de resultado del bloque.</param>
      <param name="variables" vsli:raw="The variables in the block.">Variables del bloque.</param>
      <param name="expressions" vsli:raw="The expressions in the block.">Expresiones del bloque.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt;.">Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt; that contains the given variables and expressions.">Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las variables y expresiones dadas.</summary>
      <param name="type" vsli:raw="The result type of the block.">Tipo de resultado del bloque.</param>
      <param name="variables" vsli:raw="The variables in the block.">Variables del bloque.</param>
      <param name="expressions" vsli:raw="The expressions in the block.">Expresiones del bloque.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt;.">Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt; that contains the given expressions, has no variables and has specific result type.">Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las expresiones dadas, no tiene variables y tiene el tipo de resultado específico.</summary>
      <param name="type" vsli:raw="The result type of the block.">Tipo de resultado del bloque.</param>
      <param name="expressions" vsli:raw="The expressions in the block.">Expresiones del bloque.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt;.">Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; representing a break statement.">Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Break.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; will jump to.">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; with &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Kind&quot; /&gt; equal to Break, the &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Target&quot; /&gt; property set to &lt;paramref name=&quot;target&quot; /&gt;, and a null value to be passed to the target label upon jumping.">
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Break, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" /> y un valor null que se pasará a la etiqueta de destino al saltar.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; representing a break statement. The value passed to the label upon jumping can be specified.">Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Break. Se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; will jump to.">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value" vsli:raw="The value that will be passed to the associated label upon jumping.">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; with &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Kind&quot; /&gt; equal to Break, the &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Target&quot; /&gt; property set to &lt;paramref name=&quot;target&quot; /&gt;, and &lt;paramref name=&quot;value&quot; /&gt; to be passed to the target label upon jumping.">
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Break, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" /> y un <paramref name="value" /> que se pasará a la etiqueta de destino al saltar.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; representing a break statement with the specified type. The value passed to the label upon jumping can be specified.">Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Break con el tipo especificado. Se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; will jump to.">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value" vsli:raw="The value that will be passed to the associated label upon jumping.">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</param>
      <param name="type" vsli:raw="An &lt;see cref=&quot;T:System.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property equal to.">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; with &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Kind&quot; /&gt; equal to Break, the &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Target&quot; /&gt; property set to &lt;paramref name=&quot;target&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property set to &lt;paramref name=&quot;type&quot; /&gt;, and &lt;paramref name=&quot;value&quot; /&gt; to be passed to the target label upon jumping.">
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Break, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" />, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y un <paramref name="value" /> que se pasará a la etiqueta de destino al saltar.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; representing a break statement with the specified type.">Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Break con el tipo especificado.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; will jump to.">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="type" vsli:raw="An &lt;see cref=&quot;T:System.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property equal to.">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; with &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Kind&quot; /&gt; equal to Break, the &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Target&quot; /&gt; property set to &lt;paramref name=&quot;target&quot; /&gt;, and the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property set to &lt;paramref name=&quot;type&quot; /&gt;.">
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Break, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" /> y la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that represents a call to a method that takes no arguments.">Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método que no toma ningún argumento.</summary>
      <param name="instance" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that specifies the instance for an instance method call (pass &lt;see langword=&quot;null&quot; /&gt; for a &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic) method).">
        <see cref="T:System.Linq.Expressions.Expression" /> que especifica la instancia para una llamada al método de instancia (pasa <see langword="null" /> para un método <see langword="static" />, <see langword="Shared" /> en Visual Basic).</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Call&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;instance&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and &lt;paramref name=&quot;method&quot; /&gt; represents an instance method.">
        <paramref name="method" /> es <see langword="null" />.  
O bien 
 <paramref name="instance" /> es <see langword="null" /> y <paramref name="method" /> representa un método de instancias.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;instance&quot; /&gt;.Type is not assignable to the declaring type of the method represented by &lt;paramref name=&quot;method&quot; /&gt;.">
        <paramref name="instance" />.Type no se puede asignar al tipo declarativo del método representado por <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that represents a call to a method that takes arguments.">Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método que toma argumentos.</summary>
      <param name="instance" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt; property equal to (pass &lt;see langword=&quot;null&quot; /&gt; for a &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic) method).">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> (pase <see langword="null" /> para un método <see langword="static" />, <see langword="Shared" /> en Visual Basic).</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arguments" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Arguments&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Call&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Arguments&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;instance&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and &lt;paramref name=&quot;method&quot; /&gt; represents an instance method.">
        <paramref name="method" /> es <see langword="null" />.  
O bien 
 <paramref name="instance" /> es <see langword="null" /> y <paramref name="method" /> representa un método de instancias.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;instance&quot; /&gt;.Type is not assignable to the declaring type of the method represented by &lt;paramref name=&quot;method&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The number of elements in &lt;paramref name=&quot;arguments&quot; /&gt; does not equal the number of parameters for the method represented by &lt;paramref name=&quot;method&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more of the elements of &lt;paramref name=&quot;arguments&quot; /&gt; is not assignable to the corresponding parameter for the method represented by &lt;paramref name=&quot;method&quot; /&gt;.">
        <paramref name="instance" />.Type no se puede asignar al tipo declarativo del método representado por <paramref name="method" />.  
O bien 
El número de elementos de <paramref name="arguments" /> no es igual al número de parámetros del método representado por <paramref name="method" />.  
o bien 
Uno o varios elementos de <paramref name="arguments" /> no se pueden asignar al parámetro correspondiente del método representado por <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that represents a call to a method that takes two arguments.">Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método que toma dos argumentos.</summary>
      <param name="instance" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that specifies the instance for an instance call. (pass null for a static (Shared in Visual Basic) method).">
        <see cref="T:System.Linq.Expressions.Expression" /> que especifica la instancia de una llamada de instancia. (Pasa null para un método estático, que en Visual Basic es compartido).</param>
      <param name="method" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the target method.">Objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método de destino.</param>
      <param name="arg0" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the first argument.">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el primer argumento.</param>
      <param name="arg1" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the second argument.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el segundo argumento.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Call&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that represents a call to a method that takes three arguments.">Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método que toma tres argumentos.</summary>
      <param name="instance" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that specifies the instance for an instance call. (pass null for a static (Shared in Visual Basic) method).">
        <see cref="T:System.Linq.Expressions.Expression" /> que especifica la instancia de una llamada de instancia. (Pasa null para un método estático, que en Visual Basic es compartido).</param>
      <param name="method" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the target method.">Objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método de destino.</param>
      <param name="arg0" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the first argument.">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el primer argumento.</param>
      <param name="arg1" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the second argument.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el segundo argumento.</param>
      <param name="arg2" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the third argument.">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el tercer argumento.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Call&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that represents a call to a method that takes arguments.">Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método que toma argumentos.</summary>
      <param name="instance" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that specifies the instance for an instance method call (pass &lt;see langword=&quot;null&quot; /&gt; for a &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic) method).">
        <see cref="T:System.Linq.Expressions.Expression" /> que especifica la instancia para una llamada al método de instancia (pasa <see langword="null" /> para un método <see langword="static" />, <see langword="Shared" /> en Visual Basic).</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Arguments&quot; /&gt; collection.">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Call&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Arguments&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;instance&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and &lt;paramref name=&quot;method&quot; /&gt; represents an instance method.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;arguments&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and one or more of its elements is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="method" /> es <see langword="null" />.  
o bien 
 <paramref name="instance" /> es <see langword="null" /> y <paramref name="method" /> representa un método de instancia.  
O bien 
 <paramref name="arguments" /> no es <see langword="null" /> y uno o varios de sus elementos son <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;instance&quot; /&gt;.Type is not assignable to the declaring type of the method represented by &lt;paramref name=&quot;method&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The number of elements in &lt;paramref name=&quot;arguments&quot; /&gt; does not equal the number of parameters for the method represented by &lt;paramref name=&quot;method&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more of the elements of &lt;paramref name=&quot;arguments&quot; /&gt; is not assignable to the corresponding parameter for the method represented by &lt;paramref name=&quot;method&quot; /&gt;.">
        <paramref name="instance" />.Type no se puede asignar al tipo declarativo del método representado por <paramref name="method" />.  
O bien 
El número de elementos de <paramref name="arguments" /> no es igual al número de parámetros del método representado por <paramref name="method" />.  
O bien 
Uno o varios elementos de <paramref name="arguments" /> no se pueden asignar al parámetro correspondiente del método representado por <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.String,System.Type[],System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that represents a call to a method by calling the appropriate factory method.">Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método llamando al método del generador apropiado.</summary>
      <param name="instance" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; whose &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property value will be searched for a specific method.">
        <see cref="T:System.Linq.Expressions.Expression" /> en cuyo valor de propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> se buscará un método específico.</param>
      <param name="methodName" vsli:raw="The name of the method.">Nombre del método.</param>
      <param name="typeArguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Type&quot; /&gt; objects that specify the type parameters of the generic method. This argument should be null when methodName specifies a non-generic method.">Matriz de objetos <see cref="T:System.Type" /> que especifican los parámetros de tipo del método genérico. Este argumento debería ser null cuando methodName especifica un método no genérico.</param>
      <param name="arguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects that represents the arguments to the method.">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representa los argumentos del método.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Call&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt; property equal to &lt;paramref name=&quot;instance&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; set to the &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the specified instance method, and &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Arguments&quot; /&gt; set to the specified arguments.">
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, cuya propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> es <paramref name="instance" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establece en el objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método de instancia especificado y <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> se establece en los argumentos especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;instance&quot; /&gt; or &lt;paramref name=&quot;methodName&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="instance" /> o <paramref name="methodName" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="No method whose name is &lt;paramref name=&quot;methodName&quot; /&gt;, whose type parameters match &lt;paramref name=&quot;typeArguments&quot; /&gt;, and whose parameter types match &lt;paramref name=&quot;arguments&quot; /&gt; is found in &lt;paramref name=&quot;instance&quot; /&gt;.Type or its base types.  &#xA;  &#xA; -or-  &#xA;  &#xA; More than one method whose name is &lt;paramref name=&quot;methodName&quot; /&gt;, whose type parameters match &lt;paramref name=&quot;typeArguments&quot; /&gt;, and whose parameter types match &lt;paramref name=&quot;arguments&quot; /&gt; is found in &lt;paramref name=&quot;instance&quot; /&gt;.Type or its base types.">No se encuentra en <paramref name="instance" />.Type o sus tipos base ningún método cuyo nombre sea <paramref name="methodName" />, cuyos parámetros de tipo coincidan con <paramref name="typeArguments" /> y cuyos tipos de parámetro se correspondan con <paramref name="arguments" />.  
O bien 
Se han encontrado en <paramref name="instance" />.Type o sus tipos base varios métodos cuyo nombre es <paramref name="methodName" />, cuyos parámetros de tipo coinciden con <paramref name="typeArguments" /> y cuyos tipos de parámetro se corresponden con <paramref name="arguments" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that represents a call to a static (Shared in Visual Basic) method.">Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método estático (Shared en Visual Basic).</summary>
      <param name="method" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the target method.">Objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método de destino.</param>
      <param name="arguments" vsli:raw="A collection of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the call arguments.">Colección de <see cref="T:System.Linq.Expressions.Expression" /> que representa los argumentos de la llamada.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Call&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that represents a call to a &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic) method that takes one argument.">Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método <see langword="static" /> (<see langword="Shared" /> en Visual Basic) que toma un argumento.</summary>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arg0" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the first argument.">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el primer argumento.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Call&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is null.">
        <paramref name="method" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that represents a call to a static method that takes two arguments.">Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método estático que toma dos argumentos.</summary>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arg0" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the first argument.">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el primer argumento.</param>
      <param name="arg1" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the second argument.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el segundo argumento.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Call&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is null.">
        <paramref name="method" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that represents a call to a static method that takes three arguments.">Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método estático que toma tres argumentos.</summary>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arg0" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the first argument.">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el primer argumento.</param>
      <param name="arg1" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the second argument.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el segundo argumento.</param>
      <param name="arg2" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the third argument.">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el tercer argumento.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Call&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is null.">
        <paramref name="method" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that represents a call to a static method that takes four arguments.">Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método estático que toma cuatro argumentos.</summary>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arg0" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the first argument.">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el primer argumento.</param>
      <param name="arg1" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the second argument.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el segundo argumento.</param>
      <param name="arg2" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the third argument.">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el tercer argumento.</param>
      <param name="arg3" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the fourth argument.">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuarto argumento.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Call&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is null.">
        <paramref name="method" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that represents a call to a static method that takes five arguments.">Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método estático que toma cinco argumentos.</summary>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arg0" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the first argument.">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el primer argumento.</param>
      <param name="arg1" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the second argument.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el segundo argumento.</param>
      <param name="arg2" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the third argument.">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el tercer argumento.</param>
      <param name="arg3" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the fourth argument.">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuarto argumento.</param>
      <param name="arg4" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the fifth argument.">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el quinto argumento.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Call&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is null.">
        <paramref name="method" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that represents a call to a &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic) method that has arguments.">Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método <see langword="static" /> (<see langword="Shared" /> en Visual Basic) con argumentos.</summary>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents a &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic) method to set the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método <see langword="static" /> (<see langword="Shared" /> en Visual Basic) en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Arguments&quot; /&gt; collection.">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Call&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Arguments&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="method" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The number of elements in &lt;paramref name=&quot;arguments&quot; /&gt; does not equal the number of parameters for the method represented by &lt;paramref name=&quot;method&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more of the elements of &lt;paramref name=&quot;arguments&quot; /&gt; is not assignable to the corresponding parameter for the method represented by &lt;paramref name=&quot;method&quot; /&gt;.">El número de elementos de <paramref name="arguments" /> no es igual al número de parámetros del método representado por <paramref name="method" />.  
O bien 
Uno o varios elementos de <paramref name="arguments" /> no se pueden asignar al parámetro correspondiente del método representado por <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Type,System.String,System.Type[],System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that represents a call to a &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic) method by calling the appropriate factory method.">Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método <see langword="static" /> (<see langword="Shared" /> en Visual Basic) llamando al método del generador apropiado.</summary>
      <param name="type" vsli:raw="The type that contains the specified &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic) method.">Tipo que contiene el método <see langword="static" /> (<see langword="Shared" /> en Visual Basic) especificado.</param>
      <param name="methodName" vsli:raw="The name of the method.">Nombre del método.</param>
      <param name="typeArguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Type&quot; /&gt; objects that specify the type parameters of the generic method. This argument should be null when methodName specifies a non-generic method.">Matriz de objetos <see cref="T:System.Type" /> que especifican los parámetros de tipo del método genérico. Este argumento debería ser null cuando methodName especifica un método no genérico.</param>
      <param name="arguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects that represent the arguments to the method.">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los argumentos del método.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Call&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; property set to the &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the specified &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic) method, and the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Arguments&quot; /&gt; property set to the specified arguments.">
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, cuya propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establece en el objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método <see langword="static" /> (<see langword="Shared" /> en Visual Basic) especificado, y cuya propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> se establece en los argumentos especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;type&quot; /&gt; or &lt;paramref name=&quot;methodName&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="type" /> o <paramref name="methodName" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="No method whose name is &lt;paramref name=&quot;methodName&quot; /&gt;, whose type parameters match &lt;paramref name=&quot;typeArguments&quot; /&gt;, and whose parameter types match &lt;paramref name=&quot;arguments&quot; /&gt; is found in &lt;paramref name=&quot;type&quot; /&gt; or its base types.  &#xA;  &#xA; -or-  &#xA;  &#xA; More than one method whose name is &lt;paramref name=&quot;methodName&quot; /&gt;, whose type parameters match &lt;paramref name=&quot;typeArguments&quot; /&gt;, and whose parameter types match &lt;paramref name=&quot;arguments&quot; /&gt; is found in &lt;paramref name=&quot;type&quot; /&gt; or its base types.">No se encuentra en <paramref name="type" /> o sus tipos base ningún método cuyo nombre sea <paramref name="methodName" />, cuyos parámetros de tipo coincidan con <paramref name="typeArguments" /> y cuyos tipos de parámetro se correspondan con <paramref name="arguments" />.  
o bien 
Se han encontrado en <paramref name="type" /> o sus tipos base varios métodos cuyo nombre es <paramref name="methodName" />, cuyos parámetros de tipo coinciden con <paramref name="typeArguments" /> y cuyos tipos de parámetro se corresponden con <paramref name="arguments" />.</exception>
    </member>
    <member name="P:System.Linq.Expressions.Expression.CanReduce">
      <summary vsli:raw="Indicates that the node can be reduced to a simpler node. If this returns true, Reduce() can be called to produce the reduced form.">Indica que el nodo se puede reducir a uno más simple. Si devuelve true, se puede llamar a Reduce() para generar el formulario reducido.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the node can be reduced; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />es si se puede reducir el nodo; en caso <see langword="false" />contrario,.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt; representing a catch statement with a reference to the caught &lt;see cref=&quot;T:System.Exception&quot; /&gt; object for use in the handler body.">Crea un objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa una instrucción Catch con una referencia al objeto <see cref="T:System.Exception" /> detectado para su uso en el cuerpo del controlador.</summary>
      <param name="variable" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; representing a reference to the &lt;see cref=&quot;T:System.Exception&quot; /&gt; object caught by this handler.">Objeto <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representa una referencia al objeto <see cref="T:System.Exception" /> detectado por este controlador.</param>
      <param name="body" vsli:raw="The body of the catch statement.">Cuerpo de la instrucción Catch.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt;.">Objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt; representing a catch statement with an &lt;see cref=&quot;T:System.Exception&quot; /&gt; filter and a reference to the caught &lt;see cref=&quot;T:System.Exception&quot; /&gt; object.">Crea un objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa una instrucción Catch con un filtro <see cref="T:System.Exception" /> y una referencia al objeto <see cref="T:System.Exception" /> detectado.</summary>
      <param name="variable" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; representing a reference to the &lt;see cref=&quot;T:System.Exception&quot; /&gt; object caught by this handler.">Objeto <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representa una referencia al objeto <see cref="T:System.Exception" /> detectado por este controlador.</param>
      <param name="body" vsli:raw="The body of the catch statement.">Cuerpo de la instrucción Catch.</param>
      <param name="filter" vsli:raw="The body of the &lt;see cref=&quot;T:System.Exception&quot; /&gt; filter.">Cuerpo del filtro <see cref="T:System.Exception" />.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt;.">Objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt; representing a catch statement.">Crea un objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa una instrucción Catch.</summary>
      <param name="type" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; of &lt;see cref=&quot;T:System.Exception&quot; /&gt; this &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt; will handle.">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que este <see cref="T:System.Linq.Expressions.CatchBlock" /> controlará.</param>
      <param name="body" vsli:raw="The body of the catch statement.">Cuerpo de la instrucción Catch.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt;.">Objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt; representing a catch statement with an &lt;see cref=&quot;T:System.Exception&quot; /&gt; filter but no reference to the caught &lt;see cref=&quot;T:System.Exception&quot; /&gt; object.">Crea un objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa una instrucción Catch con un filtro <see cref="T:System.Exception" /> pero sin ninguna referencia al objeto <see cref="T:System.Exception" /> detectado.</summary>
      <param name="type" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; of &lt;see cref=&quot;T:System.Exception&quot; /&gt; this &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt; will handle.">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que este <see cref="T:System.Linq.Expressions.CatchBlock" /> controlará.</param>
      <param name="body" vsli:raw="The body of the catch statement.">Cuerpo de la instrucción Catch.</param>
      <param name="filter" vsli:raw="The body of the &lt;see cref=&quot;T:System.Exception&quot; /&gt; filter.">Cuerpo del filtro <see cref="T:System.Exception" />.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt;.">Objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ClearDebugInfo(System.Linq.Expressions.SymbolDocumentInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DebugInfoExpression&quot; /&gt; for clearing a sequence point.">Crea un objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> para borrar un punto de secuencia.</summary>
      <param name="document" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.SymbolDocumentInfo&quot; /&gt; that represents the source file.">
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que representa el archivo de origen.</param>
      <returns vsli:raw="An instance of &lt;see cref=&quot;T:System.Linq.Expressions.DebugInfoExpression&quot; /&gt; for clearing a sequence point.">Instancia de <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> para borrar un punto de secuencia.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a coalescing operation.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de uso combinado.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Coalesce&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of &lt;paramref name=&quot;left&quot; /&gt; does not represent a reference type or a nullable value type.">La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="left" /> no representa un tipo de referencia ni un tipo de valor que acepta valores null.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type are not convertible to each other.">
        <paramref name="left" />.Type y <paramref name="right" />.Type no se pueden convertir entre sí.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a coalescing operation, given a conversion function.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de fusión, dada una función de conversión.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="conversion" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Coalesce&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; properties set to the specified values.">Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type are not convertible to each other.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;conversion&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and &lt;paramref name=&quot;conversion&quot; /&gt;.Type is a delegate type that does not take exactly one argument.">
        <paramref name="left" />.Type y <paramref name="right" />.Type no se pueden convertir entre sí.  
o bien 
 <paramref name="conversion" /> no es <see langword="null" /> y <paramref name="conversion" />.Type es un tipo de delegado que no toma exactamente un argumento.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of &lt;paramref name=&quot;left&quot; /&gt; does not represent a reference type or a nullable value type.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of &lt;paramref name=&quot;left&quot; /&gt; represents a type that is not assignable to the parameter type of the delegate type &lt;paramref name=&quot;conversion&quot; /&gt;.Type.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of &lt;paramref name=&quot;right&quot; /&gt; is not equal to the return type of the delegate type &lt;paramref name=&quot;conversion&quot; /&gt;.Type.">La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="left" /> no representa un tipo de referencia ni un tipo de valor que acepta valores null.  
O bien 
La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="left" /> representa un tipo que no se puede asignar al tipo de parámetro del tipo de delegado <paramref name="conversion" />.Type.  
o bien 
La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="right" /> no es igual que el tipo de valor devuelto del tipo de delegado <paramref name="conversion" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.ConditionalExpression&quot; /&gt; that represents a conditional statement.">Crea un objeto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa una instrucción condicional.</summary>
      <param name="test" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.Test&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />.</param>
      <param name="ifTrue" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfTrue&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />.</param>
      <param name="ifFalse" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfFalse&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ConditionalExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Conditional&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.Test&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfTrue&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfFalse&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.ConditionalExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> y <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> y <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;test&quot; /&gt; or &lt;paramref name=&quot;ifTrue&quot; /&gt; or &lt;paramref name=&quot;ifFalse&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="test" /> o <paramref name="ifTrue" /> o <paramref name="ifFalse" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;test&quot; /&gt;.Type is not &lt;see cref=&quot;T:System.Boolean&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;ifTrue&quot; /&gt;.Type is not equal to &lt;paramref name=&quot;ifFalse&quot; /&gt;.Type.">
        <paramref name="test" />.Type no es <see cref="T:System.Boolean" />.  
O bien 
 <paramref name="ifTrue" />.Type no es igual que <paramref name="ifFalse" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.ConditionalExpression&quot; /&gt; that represents a conditional statement.">Crea un objeto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa una instrucción condicional.</summary>
      <param name="test" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.Test&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />.</param>
      <param name="ifTrue" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfTrue&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />.</param>
      <param name="ifFalse" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfFalse&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />.</param>
      <param name="type" vsli:raw="A &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property equal to.">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ConditionalExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Conditional&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.Test&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfTrue&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfFalse&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.ConditionalExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> y <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> y <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Constant(System.Object)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.ConstantExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.ConstantExpression.Value&quot; /&gt; property set to the specified value.">Crea un objeto <see cref="T:System.Linq.Expressions.ConstantExpression" /> que tiene la propiedad <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> establecida en el valor especificado.</summary>
      <param name="value" vsli:raw="An &lt;see cref=&quot;T:System.Object&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ConstantExpression.Value&quot; /&gt; property equal to.">Objeto <see cref="T:System.Object" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ConstantExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Constant&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.ConstantExpression.Value&quot; /&gt; property set to the specified value.">
        <see cref="T:System.Linq.Expressions.ConstantExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> y cuya propiedad <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> se establece en el valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Constant(System.Object,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.ConstantExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.ConstantExpression.Value&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; properties set to the specified values.">Crea un objeto <see cref="T:System.Linq.Expressions.ConstantExpression" /> que tiene las propiedades <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> y <see cref="P:System.Linq.Expressions.Expression.Type" /> establecidas en los valores especificados.</summary>
      <param name="value" vsli:raw="An &lt;see cref=&quot;T:System.Object&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ConstantExpression.Value&quot; /&gt; property equal to.">Objeto <see cref="T:System.Object" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />.</param>
      <param name="type" vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property equal to.">
        <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ConstantExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Constant&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.ConstantExpression.Value&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.ConstantExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> y <see cref="P:System.Linq.Expressions.Expression.Type" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;type&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="type" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and &lt;paramref name=&quot;type&quot; /&gt; is not assignable from the dynamic type of &lt;paramref name=&quot;value&quot; /&gt;.">
        <paramref name="value" /> no es <see langword="null" /> y <paramref name="type" /> no se puede asignar a partir del tipo dinámico de <paramref name="value" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; representing a continue statement.">Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Continue.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; will jump to.">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; with &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Kind&quot; /&gt; equal to Continue, the &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Target&quot; /&gt; property set to &lt;paramref name=&quot;target&quot; /&gt;, and a null value to be passed to the target label upon jumping.">
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Continue, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" /> y un valor null que se pasará a la etiqueta de destino al saltar.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; representing a continue statement with the specified type.">Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Continue con el tipo especificado.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; will jump to.">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="type" vsli:raw="An &lt;see cref=&quot;T:System.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property equal to.">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; with &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Kind&quot; /&gt; equal to Continue, the &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Target&quot; /&gt; property set to &lt;paramref name=&quot;target&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property set to &lt;paramref name=&quot;type&quot; /&gt;, and a null value to be passed to the target label upon jumping.">
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Continue, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" />, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y un valor null que se pasará a la etiqueta de destino al saltar.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents a type conversion operation.">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de conversión de tipos.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type" vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property equal to.">
        <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Convert&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.Expression.Type" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; or &lt;paramref name=&quot;type&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> o <paramref name="type" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="No conversion operator is defined between &lt;paramref name=&quot;expression&quot; /&gt;.Type and &lt;paramref name=&quot;type&quot; /&gt;.">No hay ningún operador de conversión definido entre <paramref name="expression" />.Type y <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents a conversion operation for which the implementing method is specified.">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la operación de conversión para la que se especifica el método de implementación.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type" vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property equal to.">
        <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Convert&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; or &lt;paramref name=&quot;type&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> o <paramref name="type" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly one argument.">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente un argumento.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="No conversion operator is defined between &lt;paramref name=&quot;expression&quot; /&gt;.Type and &lt;paramref name=&quot;type&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;expression&quot; /&gt;.Type is not assignable to the argument type of the method represented by &lt;paramref name=&quot;method&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The return type of the method represented by &lt;paramref name=&quot;method&quot; /&gt; is not assignable to &lt;paramref name=&quot;type&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;expression&quot; /&gt;.Type or &lt;paramref name=&quot;type&quot; /&gt; is a nullable value type and the corresponding non-nullable value type does not equal the argument type or the return type, respectively, of the method represented by &lt;paramref name=&quot;method&quot; /&gt;.">No hay ningún operador de conversión definido entre <paramref name="expression" />.Type y <paramref name="type" />.  
o bien 
 <paramref name="expression" />.Type no se puede asignar al tipo de argumento del método representado por <paramref name="method" />.  
O bien 
El tipo de valor devuelto del método representado por <paramref name="method" /> no se puede asignar a <paramref name="type" />.  
o bien 
 <paramref name="expression" />.Type o <paramref name="type" /> es un tipo de valor que acepta valores null y el correspondiente tipo de valor que no acepta valores null no es igual que el tipo de argumento o el tipo de valor devuelto, respectivamente, del método representado por <paramref name="method" />.</exception>
      <exception cref="T:System.Reflection.AmbiguousMatchException" vsli:raw="More than one method that matches the &lt;paramref name=&quot;method&quot; /&gt; description was found.">Se ha encontrado más de un método que coincide con la descripción de <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents a conversion operation that throws an exception if the target type is overflowed.">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de conversión que produce una excepción si está desbordado el tipo de destino.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type" vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property equal to.">
        <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ConvertChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.Expression.Type" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; or &lt;paramref name=&quot;type&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> o <paramref name="type" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="No conversion operator is defined between &lt;paramref name=&quot;expression&quot; /&gt;.Type and &lt;paramref name=&quot;type&quot; /&gt;.">No hay ningún operador de conversión definido entre <paramref name="expression" />.Type y <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents a conversion operation that throws an exception if the target type is overflowed and for which the implementing method is specified.">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de conversión que produce una excepción si está desbordado el tipo de destino y para la que se especifica el método de implementación.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type" vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property equal to.">
        <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ConvertChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; or &lt;paramref name=&quot;type&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> o <paramref name="type" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly one argument.">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente un argumento.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="No conversion operator is defined between &lt;paramref name=&quot;expression&quot; /&gt;.Type and &lt;paramref name=&quot;type&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;expression&quot; /&gt;.Type is not assignable to the argument type of the method represented by &lt;paramref name=&quot;method&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The return type of the method represented by &lt;paramref name=&quot;method&quot; /&gt; is not assignable to &lt;paramref name=&quot;type&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;expression&quot; /&gt;.Type or &lt;paramref name=&quot;type&quot; /&gt; is a nullable value type and the corresponding non-nullable value type does not equal the argument type or the return type, respectively, of the method represented by &lt;paramref name=&quot;method&quot; /&gt;.">No hay ningún operador de conversión definido entre <paramref name="expression" />.Type y <paramref name="type" />.  
O bien 
 <paramref name="expression" />.Type no se puede asignar al tipo de argumento del método representado por <paramref name="method" />.  
o bien 
El tipo de valor devuelto del método representado por <paramref name="method" /> no se puede asignar a <paramref name="type" />.  
o bien 
 <paramref name="expression" />.Type o <paramref name="type" /> es un tipo de valor que acepta valores null y el correspondiente tipo de valor que no acepta valores null no es igual que el tipo de argumento o el tipo de valor devuelto, respectivamente, del método representado por <paramref name="method" />.</exception>
      <exception cref="T:System.Reflection.AmbiguousMatchException" vsli:raw="More than one method that matches the &lt;paramref name=&quot;method&quot; /&gt; description was found.">Se ha encontrado más de un método que coincide con la descripción de <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DebugInfo(System.Linq.Expressions.SymbolDocumentInfo,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DebugInfoExpression&quot; /&gt; with the specified span.">Crea un objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> con el intervalo especificado.</summary>
      <param name="document" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.SymbolDocumentInfo&quot; /&gt; that represents the source file.">
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que representa el archivo de origen.</param>
      <param name="startLine" vsli:raw="The start line of this &lt;see cref=&quot;T:System.Linq.Expressions.DebugInfoExpression&quot; /&gt;. Must be greater than 0.">Línea de inicio de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Debe ser mayor que 0.</param>
      <param name="startColumn" vsli:raw="The start column of this &lt;see cref=&quot;T:System.Linq.Expressions.DebugInfoExpression&quot; /&gt;. Must be greater than 0.">Columna de inicio de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Debe ser mayor que 0.</param>
      <param name="endLine" vsli:raw="The end line of this &lt;see cref=&quot;T:System.Linq.Expressions.DebugInfoExpression&quot; /&gt;. Must be greater or equal than the start line.">Línea final de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Debe ser mayor o igual que la línea de inicio.</param>
      <param name="endColumn" vsli:raw="The end column of this &lt;see cref=&quot;T:System.Linq.Expressions.DebugInfoExpression&quot; /&gt;. If the end line is the same as the start line, it must be greater or equal than the start column. In any case, must be greater than 0.">Columna final de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Si la línea de fin es igual que la de inicio, debe ser mayor o igual que la columna de inicio. En cualquier caso, debe ser mayor que 0.</param>
      <returns vsli:raw="An instance of &lt;see cref=&quot;T:System.Linq.Expressions.DebugInfoExpression&quot; /&gt;.">Instancia de <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the decrementing of the expression by 1.">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la disminución de la expresión en 1.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to decrement.">
        <see cref="T:System.Linq.Expressions.Expression" /> que se va a disminuir.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the decremented expression.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión disminuida.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the decrementing of the expression by 1.">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la disminución de la expresión en 1.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to decrement.">
        <see cref="T:System.Linq.Expressions.Expression" /> que se va a disminuir.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the implementing method.">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the decremented expression.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión disminuida.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Default(System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DefaultExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property set to the specified type.">Crea un objeto <see cref="T:System.Linq.Expressions.DefaultExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> está establecida en el tipo especificado.</summary>
      <param name="type" vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property equal to.">
        <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DefaultExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Default&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property set to the specified type.">
        <see cref="T:System.Linq.Expressions.DefaultExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> y cuya propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> se establece en el tipo especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an arithmetic division operation.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de división aritmética.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Divide&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The division operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">No hay ningún operador de división definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an arithmetic division operation. The implementing method can be specified.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de división aritmética. Se puede especificar el método de implementación.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Divide&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the division operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> es <see langword="null" /> y el operador de división no está definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a division assignment operation that does not have overflow checking.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de división que no tiene comprobación de desbordamiento.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.DivideAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a division assignment operation that does not have overflow checking.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de división que no tiene comprobación de desbordamiento.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.DivideAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a division assignment operation that does not have overflow checking.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de división que no tiene comprobación de desbordamiento.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.DivideAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;.">Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado.</summary>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="returnType" vsli:raw="The result type of the dynamic expression.">Tipo de resultado de la expresión dinámica.</param>
      <param name="arguments" vsli:raw="The arguments to the dynamic operation.">Argumentos de la operación dinámica.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt; and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;.">Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado.</summary>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="returnType" vsli:raw="The result type of the dynamic expression.">Tipo de resultado de la expresión dinámica.</param>
      <param name="arg0" vsli:raw="The first argument to the dynamic operation.">Primer argumento de la operación dinámica.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt; and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;.">Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado.</summary>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="returnType" vsli:raw="The result type of the dynamic expression.">Tipo de resultado de la expresión dinámica.</param>
      <param name="arg0" vsli:raw="The first argument to the dynamic operation.">Primer argumento de la operación dinámica.</param>
      <param name="arg1" vsli:raw="The second argument to the dynamic operation.">Segundo argumento de la operación dinámica.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt; and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;.">Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado.</summary>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="returnType" vsli:raw="The result type of the dynamic expression.">Tipo de resultado de la expresión dinámica.</param>
      <param name="arg0" vsli:raw="The first argument to the dynamic operation.">Primer argumento de la operación dinámica.</param>
      <param name="arg1" vsli:raw="The second argument to the dynamic operation.">Segundo argumento de la operación dinámica.</param>
      <param name="arg2" vsli:raw="The third argument to the dynamic operation.">Tercer argumento de la operación dinámica.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt; and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;.">Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado.</summary>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="returnType" vsli:raw="The result type of the dynamic expression.">Tipo de resultado de la expresión dinámica.</param>
      <param name="arg0" vsli:raw="The first argument to the dynamic operation.">Primer argumento de la operación dinámica.</param>
      <param name="arg1" vsli:raw="The second argument to the dynamic operation.">Segundo argumento de la operación dinámica.</param>
      <param name="arg2" vsli:raw="The third argument to the dynamic operation.">Tercer argumento de la operación dinámica.</param>
      <param name="arg3" vsli:raw="The fourth argument to the dynamic operation.">Cuarto argumento de la operación dinámica.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt; and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;.">Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado.</summary>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="returnType" vsli:raw="The result type of the dynamic expression.">Tipo de resultado de la expresión dinámica.</param>
      <param name="arguments" vsli:raw="The arguments to the dynamic operation.">Argumentos de la operación dinámica.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt; and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt;, given an &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; as the second argument.">Crea un objeto <see cref="T:System.Linq.Expressions.ElementInit" />, dado un objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> como segundo argumento.</summary>
      <param name="addMethod" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ElementInit.AddMethod&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" />.</param>
      <param name="arguments" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to set the &lt;see cref=&quot;P:System.Linq.Expressions.ElementInit.Arguments&quot; /&gt; property equal to.">Objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene objetos <see cref="T:System.Linq.Expressions.Expression" /> en los que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ElementInit.Arguments" />.</param>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.ElementInit.AddMethod&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.ElementInit.Arguments&quot; /&gt; properties set to the specified values.">Objeto <see cref="T:System.Linq.Expressions.ElementInit" /> que tiene las propiedades <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> y <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> establecidas en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;addMethod&quot; /&gt; or &lt;paramref name=&quot;arguments&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="addMethod" /> o <paramref name="arguments" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The method that &lt;paramref name=&quot;addMethod&quot; /&gt; represents is not named &quot;Add&quot; (case insensitive).  &#xA;  &#xA; -or-  &#xA;  &#xA; The method that &lt;paramref name=&quot;addMethod&quot; /&gt; represents is not an instance method.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;arguments&quot; /&gt; does not contain the same number of elements as the number of parameters for the method that &lt;paramref name=&quot;addMethod&quot; /&gt; represents.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of one or more elements of &lt;paramref name=&quot;arguments&quot; /&gt; is not assignable to the type of the corresponding parameter of the method that &lt;paramref name=&quot;addMethod&quot; /&gt; represents.">El método que <paramref name="addMethod" /> representa no se denomina "Add" (no distingue mayúsculas de minúsculas).  
O bien 
El método que <paramref name="addMethod" /> representa no es un método de instancia.  
O bien 
 <paramref name="arguments" /> no contiene el mismo número de elementos que el número de parámetros del método que <paramref name="addMethod" /> representa.  
O bien 
La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de uno o varios elementos de <paramref name="arguments" /> no se puede asignar al tipo del parámetro correspondiente del método que <paramref name="addMethod" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt;, given an array of values as the second argument.">Crea un objeto <see cref="T:System.Linq.Expressions.ElementInit" />, dada una matriz de valores como segundo argumento.</summary>
      <param name="addMethod" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ElementInit.AddMethod&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" />.</param>
      <param name="arguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to set the &lt;see cref=&quot;P:System.Linq.Expressions.ElementInit.Arguments&quot; /&gt; property equal to.">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> en los que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ElementInit.Arguments" />.</param>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.ElementInit.AddMethod&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.ElementInit.Arguments&quot; /&gt; properties set to the specified values.">Objeto <see cref="T:System.Linq.Expressions.ElementInit" /> que tiene las propiedades <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> y <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> establecidas en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;addMethod&quot; /&gt; or &lt;paramref name=&quot;arguments&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="addMethod" /> o <paramref name="arguments" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The method that addMethod represents is not named &quot;Add&quot; (case insensitive).  &#xA;  &#xA; -or-  &#xA;  &#xA; The method that addMethod represents is not an instance method.  &#xA;  &#xA; -or-  &#xA;  &#xA; arguments does not contain the same number of elements as the number of parameters for the method that addMethod represents.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of one or more elements of &lt;paramref name=&quot;arguments&quot; /&gt; is not assignable to the type of the corresponding parameter of the method that &lt;paramref name=&quot;addMethod&quot; /&gt; represents.">El método que addMethod representa no se denomina "Add" (sin distinción entre mayúsculas y minúsculas).  
O bien 
El método que addMethod representa no es un método de instancia.  
o bien 
El parámetro arguments no contiene el mismo número de elementos que el número de parámetros del método que addMethod representa.  
o bien 
La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de uno o varios elementos de <paramref name="arguments" /> no se puede asignar al tipo del parámetro correspondiente del método que <paramref name="addMethod" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Empty">
      <summary vsli:raw="Creates an empty expression that has &lt;see cref=&quot;T:System.Void&quot; /&gt; type.">Crea una expresión vacía que tiene el tipo <see cref="T:System.Void" />.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DefaultExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Default&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property set to &lt;see cref=&quot;T:System.Void&quot; /&gt;.">Objeto <see cref="T:System.Linq.Expressions.DefaultExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> y cuya propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> está establecida en <see cref="T:System.Void" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an equality comparison.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación de igualdad.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Equal&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The equality operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">No hay ningún operador de igualdad definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an equality comparison. The implementing method can be specified.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación de igualdad. Se puede especificar el método de implementación.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt; to &lt;see langword=&quot;true&quot; /&gt;; &lt;see langword=&quot;false&quot; /&gt; to set &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt; to &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en <see langword="true" />; es <see langword="false" /> para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en <see langword="false" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Equal&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the equality operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> es <see langword="null" /> y no hay ningún operador de igualdad definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise &lt;see langword=&quot;XOR&quot; /&gt; operation, using &lt;c&gt;op_ExclusiveOr&lt;/c&gt; for user-defined types.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación <see langword="XOR" /> bit a bit, usando <c>op_ExclusiveOr</c> para los tipos definidos por el usuario.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ExclusiveOr&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &lt;see langword=&quot;XOR&quot; /&gt; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">No hay ningún operador <see langword="XOR" /> definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise &lt;see langword=&quot;XOR&quot; /&gt; operation, using &lt;c&gt;op_ExclusiveOr&lt;/c&gt; for user-defined types. The implementing method can be specified.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación <see langword="XOR" /> bit a bit, usando <c>op_ExclusiveOr</c> para los tipos definidos por el usuario. Se puede especificar el método de implementación.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ExclusiveOr&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the &lt;see langword=&quot;XOR&quot; /&gt; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> es <see langword="null" /> y el operador <see langword="XOR" /> no está definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise XOR assignment operation, using &lt;c&gt;op_ExclusiveOr&lt;/c&gt; for user-defined types.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación XOR bit a bit, usando <c>op_ExclusiveOr</c> para los tipos definidos por el usuario.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise XOR assignment operation, using &lt;c&gt;op_ExclusiveOr&lt;/c&gt; for user-defined types.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación XOR bit a bit, usando <c>op_ExclusiveOr</c> para los tipos definidos por el usuario.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise XOR assignment operation, using &lt;c&gt;op_ExclusiveOr&lt;/c&gt; for user-defined types.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación XOR bit a bit, usando <c>op_ExclusiveOr</c> para los tipos definidos por el usuario.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Reflection.FieldInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt; that represents accessing a field.">Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a un campo.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Expression&quot; /&gt; property equal to. For &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), &lt;paramref name=&quot;expression&quot; /&gt; must be &lt;see langword=&quot;null&quot; /&gt;.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />. En modo <see langword="static" /> (<see langword="Shared" /> en Visual Basic), <paramref name="expression" /> debe ser <see langword="null" />.</param>
      <param name="field" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.FieldInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Member&quot; /&gt; property equal to.">Objeto <see cref="T:System.Reflection.FieldInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Member" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.MemberAccess&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Expression&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Member&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.MemberExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> y <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;field&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The field represented by &lt;paramref name=&quot;field&quot; /&gt; is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic) and &lt;paramref name=&quot;expression&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="field" /> es <see langword="null" />.  
o bien 
El campo representado por <paramref name="field" /> no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) y <paramref name="expression" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt;.Type is not assignable to the declaring type of the field represented by &lt;paramref name=&quot;field&quot; /&gt;.">
        <paramref name="expression" />.Type no se puede asignar al tipo declarativo del campo representado por <paramref name="field" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.String)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt; that represents accessing a field given the name of the field.">Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a un campo, dado el nombre del campo.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; whose &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; contains a field named &lt;paramref name=&quot;fieldName&quot; /&gt;. This can be null for static fields.">
        <see cref="T:System.Linq.Expressions.Expression" /> cuyo <see cref="P:System.Linq.Expressions.Expression.Type" /> contiene un campo llamado <paramref name="fieldName" />. Este puede ser null para los campos estáticos.</param>
      <param name="fieldName" vsli:raw="The name of a field to be accessed.">Nombre de un campo al que se va a obtener acceso.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.MemberAccess&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Expression&quot; /&gt; property set to &lt;paramref name=&quot;expression&quot; /&gt;, and the &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Member&quot; /&gt; property set to the &lt;see cref=&quot;T:System.Reflection.FieldInfo&quot; /&gt; that represents the field denoted by &lt;paramref name=&quot;fieldName&quot; /&gt;.">
        <see cref="T:System.Linq.Expressions.MemberExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> se establece en <paramref name="expression" /> y cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> se establece en el objeto <see cref="T:System.Reflection.FieldInfo" /> que representa el campo denotado por <paramref name="fieldName" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; or &lt;paramref name=&quot;fieldName&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> o <paramref name="fieldName" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="No field named &lt;paramref name=&quot;fieldName&quot; /&gt; is defined in &lt;paramref name=&quot;expression&quot; /&gt;.Type or its base types.">No se ha definido ningún campo denominado <paramref name="fieldName" /> en <paramref name="expression" />.Type o sus tipos base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Type,System.String)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt; that represents accessing a field.">Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a un campo.</summary>
      <param name="expression" vsli:raw="The containing object of the field. This can be null for static fields.">Objeto contenedor del campo. Este puede ser null para los campos estáticos.</param>
      <param name="type" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; that contains the field.">Propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> que contiene el campo.</param>
      <param name="fieldName" vsli:raw="The field to be accessed.">Campo al que se va a obtener acceso.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt;.">Objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetActionType(System.Type[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents a generic &lt;see cref=&quot;T:System.Action&quot; /&gt; delegate type that has specific type arguments.">Crea un objeto <see cref="T:System.Type" /> que representa un tipo de delegado <c>System.Action</c> genérico que tiene argumentos de tipo específicos.</summary>
      <param name="typeArgs" vsli:raw="An array of up to sixteen &lt;see cref=&quot;T:System.Type&quot; /&gt; objects that specify the type arguments for the &lt;see cref=&quot;T:System.Action&quot; /&gt; delegate type.">Matriz de hasta dieciséis objetos <see cref="T:System.Type" /> que especifican los argumentos de tipo para el tipo de delegado <see langword="System.Action" />.</param>
      <returns vsli:raw="The type of a &lt;see cref=&quot;T:System.Action&quot; /&gt; delegate that has the specified type arguments.">Tipo de un delegado <c>System.Action</c> que tiene los argumentos de tipo especificados.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;typeArgs&quot; /&gt; contains more than sixteen elements.">
        <paramref name="typeArgs" /> contiene más de dieciséis elementos.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;typeArgs&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="typeArgs" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetDelegateType(System.Type[])">
      <summary vsli:raw="Gets a &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; object that represents a generic &lt;see cref=&quot;T:System.Func`1&quot; /&gt; or &lt;see cref=&quot;T:System.Action&quot; /&gt; delegate type that has specific type arguments.">Obtiene un objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa un tipo de delegado <c>System.Func</c> o <c>System.Action</c> genérico que tiene argumentos de tipo específicos.</summary>
      <param name="typeArgs" vsli:raw="The type arguments of the delegate.">Argumentos de tipo del delegado.</param>
      <returns vsli:raw="The delegate type.">Tipo de delegado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetFuncType(System.Type[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; object that represents a generic &lt;see cref=&quot;T:System.Func`1&quot; /&gt; delegate type that has specific type arguments. The last type argument specifies the return type of the created delegate.">Crea un objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa un tipo de delegado <c>System.Func</c> genérico que tiene argumentos de tipo específicos. El último argumento de tipo especifica el tipo de valor devuelto del delegado creado.</summary>
      <param name="typeArgs" vsli:raw="An array of one to seventeen &lt;see cref=&quot;T:System.Type&quot; /&gt; objects that specify the type arguments for the &lt;see langword=&quot;System.Func&quot; /&gt; delegate type.">Matriz de entre uno y diecisiete objetos <see cref="T:System.Type" /> que especifican los argumentos de tipo para el tipo de delegado <see langword="System.Func" />.</param>
      <returns vsli:raw="The type of a &lt;see cref=&quot;T:System.Func`1&quot; /&gt; delegate that has the specified type arguments.">Tipo de un delegado <c>System.Func</c> que tiene los argumentos de tipo especificados.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;typeArgs&quot; /&gt; contains fewer than one or more than seventeen elements.">
        <paramref name="typeArgs" /> contiene menos de un elemento o más de diecisiete elementos.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;typeArgs&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="typeArgs" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; representing a &quot;go to&quot; statement.">Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción GoTo.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; will jump to.">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; with &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Kind&quot; /&gt; equal to Goto, the &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Target&quot; /&gt; property set to the specified value, and a null value to be passed to the target label upon jumping.">
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Goto, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en el valor especificado y un valor null que se pasará a la etiqueta de destino al saltar.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; representing a &quot;go to&quot; statement. The value passed to the label upon jumping can be specified.">Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción GoTo. Se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; will jump to.">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value" vsli:raw="The value that will be passed to the associated label upon jumping.">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; with &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Kind&quot; /&gt; equal to Goto, the &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Target&quot; /&gt; property set to &lt;paramref name=&quot;target&quot; /&gt;, and &lt;paramref name=&quot;value&quot; /&gt; to be passed to the target label upon jumping.">
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Goto, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" /> y un <paramref name="value" /> que se pasará a la etiqueta de destino al saltar.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; representing a &quot;go to&quot; statement with the specified type. The value passed to the label upon jumping can be specified.">Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción "go to" con el tipo especificado. Se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; will jump to.">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value" vsli:raw="The value that will be passed to the associated label upon jumping.">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</param>
      <param name="type" vsli:raw="An &lt;see cref=&quot;T:System.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property equal to.">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; with &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Kind&quot; /&gt; equal to Goto, the &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Target&quot; /&gt; property set to &lt;paramref name=&quot;target&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property set to &lt;paramref name=&quot;type&quot; /&gt;, and &lt;paramref name=&quot;value&quot; /&gt; to be passed to the target label upon jumping.">Objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Goto, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" />, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y un <paramref name="value" /> que se va a pasar a la etiqueta de destino cuando se produzca el salto.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; representing a &quot;go to&quot; statement with the specified type.">Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción "go to" con el tipo especificado.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; will jump to.">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="type" vsli:raw="An &lt;see cref=&quot;T:System.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property equal to.">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; with &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Kind&quot; /&gt; equal to Goto, the &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Target&quot; /&gt; property set to the specified value, the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property set to &lt;paramref name=&quot;type&quot; /&gt;, and a null value to be passed to the target label upon jumping.">Objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Goto, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en el valor especificado, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y un valor null que se va a pasar a la etiqueta de destino cuando se produzca el salto.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a &quot;greater than&quot; numeric comparison.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "mayor que".</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.GreaterThan&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &quot;greater than&quot; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">No hay ningún operador "mayor que" definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a &quot;greater than&quot; numeric comparison. The implementing method can be specified.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "mayor que". Se puede especificar el método de implementación.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt; to &lt;see langword=&quot;true&quot; /&gt;; &lt;see langword=&quot;false&quot; /&gt; to set &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt; to &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en <see langword="true" />; es <see langword="false" /> para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en <see langword="false" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.GreaterThan&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the &quot;greater than&quot; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> es <see langword="null" /> y no hay ningún operador "mayor que" definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a &quot;greater than or equal&quot; numeric comparison.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "mayor o igual que".</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &quot;greater than or equal&quot; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">No hay ningún operador "mayor o igual que" definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a &quot;greater than or equal&quot; numeric comparison.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "mayor o igual que".</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt; to &lt;see langword=&quot;true&quot; /&gt;; &lt;see langword=&quot;false&quot; /&gt; to set &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt; to &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en <see langword="true" />; es <see langword="false" /> para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en <see langword="false" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the &quot;greater than or equal&quot; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> es <see langword="null" /> y el operador "mayor o igual que" no está definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.ConditionalExpression&quot; /&gt; that represents a conditional block with an &lt;see langword=&quot;if&quot; /&gt; statement.">Crea un objeto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa un bloque condicional con una instrucción <see langword="if" />.</summary>
      <param name="test" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.Test&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />.</param>
      <param name="ifTrue" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfTrue&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ConditionalExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Conditional&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.Test&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfTrue&quot; /&gt;, properties set to the specified values. The &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfFalse&quot; /&gt; property is set to default expression and the type of the resulting &lt;see cref=&quot;T:System.Linq.Expressions.ConditionalExpression&quot; /&gt; returned by this method is &lt;see cref=&quot;T:System.Void&quot; /&gt;.">
        <see cref="T:System.Linq.Expressions.ConditionalExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> se establecen en los valores especificados. La propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> se establece en la expresión predeterminada y el tipo del objeto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> resultante devuelto por este método es <see cref="T:System.Void" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.ConditionalExpression&quot; /&gt; that represents a conditional block with &lt;see langword=&quot;if&quot; /&gt; and &lt;see langword=&quot;else&quot; /&gt; statements.">Crea un objeto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa un bloque condicional con instrucciones <see langword="if" /> y <see langword="else" />.</summary>
      <param name="test" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.Test&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />.</param>
      <param name="ifTrue" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfTrue&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />.</param>
      <param name="ifFalse" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfFalse&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ConditionalExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Conditional&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.Test&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfTrue&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfFalse&quot; /&gt; properties set to the specified values. The type of the resulting &lt;see cref=&quot;T:System.Linq.Expressions.ConditionalExpression&quot; /&gt; returned by this method is &lt;see cref=&quot;T:System.Void&quot; /&gt;.">
        <see cref="T:System.Linq.Expressions.ConditionalExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> y <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> y <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> se establecen en los valores especificados. El tipo del objeto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> resultante devuelto por este método es <see cref="T:System.Void" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the incrementing of the expression value by 1.">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa el aumento del valor de la expresión en 1.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to increment.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que se va a incrementar.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the incremented expression.">Objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión incrementada.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the incrementing of the expression by 1.">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa el incremento de la expresión en 1.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to increment.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que se va a incrementar.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the implementing method.">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the incremented expression.">Objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión incrementada.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Linq.Expressions.InvocationExpression&quot; /&gt; that applies a delegate or lambda expression to a list of argument expressions.">Crea un objeto <see cref="T:System.Linq.Expressions.InvocationExpression" /> que aplica un delegado o una expresión lambda a una lista de expresiones de argumento.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the delegate or lambda expression to be applied to.">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el delegado o expresión lambda a los que se aplicará.</param>
      <param name="arguments" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects that represent the arguments that the delegate or lambda expression is applied to.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los argumentos a los que se aplican el delegado o expresión lambda.</param>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.InvocationExpression&quot; /&gt; that applies the specified delegate or lambda expression to the provided arguments.">
        <see cref="T:System.Linq.Expressions.InvocationExpression" /> que aplica el delegado o expresión lambda especificados a los argumentos proporcionados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt;.Type does not represent a delegate type or an &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of an element of &lt;paramref name=&quot;arguments&quot; /&gt; is not assignable to the type of the corresponding parameter of the delegate represented by &lt;paramref name=&quot;expression&quot; /&gt;.">
        <paramref name="expression" />.Type no representa un tipo de delegado o <see cref="T:System.Linq.Expressions.Expression`1" />.  
O bien 
La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="arguments" /> no se puede asignar al tipo del parámetro correspondiente del delegado representado por <paramref name="expression" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;arguments&quot; /&gt; does not contain the same number of elements as the list of parameters for the delegate represented by &lt;paramref name=&quot;expression&quot; /&gt;.">
        <paramref name="arguments" /> no contiene el mismo número de elementos que la lista de parámetros para el delegado representado por <paramref name="expression" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Linq.Expressions.InvocationExpression&quot; /&gt; that applies a delegate or lambda expression to a list of argument expressions.">Crea un objeto <see cref="T:System.Linq.Expressions.InvocationExpression" /> que aplica un delegado o una expresión lambda a una lista de expresiones de argumento.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the delegate or lambda expression to be applied.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el delegado o la expresión lambda que se va a aplicar.</param>
      <param name="arguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects that represent the arguments that the delegate or lambda expression is applied to.">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los argumentos a los que se aplica el delegado o la expresión lambda.</param>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.InvocationExpression&quot; /&gt; that applies the specified delegate or lambda expression to the provided arguments.">
        <see cref="T:System.Linq.Expressions.InvocationExpression" /> que aplica el delegado o expresión lambda especificados a los argumentos proporcionados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt;.Type does not represent a delegate type or an &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of an element of &lt;paramref name=&quot;arguments&quot; /&gt; is not assignable to the type of the corresponding parameter of the delegate represented by &lt;paramref name=&quot;expression&quot; /&gt;.">
        <paramref name="expression" />.Type no representa un tipo de delegado o <see cref="T:System.Linq.Expressions.Expression`1" />.  
O bien 
La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="arguments" /> no se puede asignar al tipo del parámetro correspondiente del delegado representado por <paramref name="expression" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;arguments&quot; /&gt; does not contain the same number of elements as the list of parameters for the delegate represented by &lt;paramref name=&quot;expression&quot; /&gt;.">
        <paramref name="arguments" /> no contiene el mismo número de elementos que la lista de parámetros para el delegado representado por <paramref name="expression" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Returns whether the expression evaluates to false.">Devuelve si la expresión se evalúa en false.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to evaluate.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que se va a evaluar.</param>
      <returns vsli:raw="An instance of &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt;.">Instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Returns whether the expression evaluates to false.">Devuelve si la expresión se evalúa en false.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to evaluate.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que se va a evaluar.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the implementing method.">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
      <returns vsli:raw="An instance of &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt;.">Instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Returns whether the expression evaluates to true.">Devuelve si la expresión se evalúa en true.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to evaluate.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que se va a evaluar.</param>
      <returns vsli:raw="An instance of &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt;.">Instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Returns whether the expression evaluates to true.">Devuelve si la expresión se evalúa en true.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to evaluate.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que se va a evaluar.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the implementing method.">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
      <returns vsli:raw="An instance of &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt;.">Instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; representing a label with void type and no name.">Crea un objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa una etiqueta con tipo void y sin nombre.</summary>
      <returns vsli:raw="The new &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt;.">Nuevo objeto <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LabelExpression&quot; /&gt; representing a label without a default value.">Crea un objeto <see cref="T:System.Linq.Expressions.LabelExpression" /> que representa una etiqueta sin un valor predeterminado.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; which this &lt;see cref=&quot;T:System.Linq.Expressions.LabelExpression&quot; /&gt; will be associated with.">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> con el que se asociará este objeto <see cref="T:System.Linq.Expressions.LabelExpression" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LabelExpression&quot; /&gt; without a default value.">Objeto <see cref="T:System.Linq.Expressions.LabelExpression" /> sin un valor predeterminado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LabelExpression&quot; /&gt; representing a label with the given default value.">Crea un objeto <see cref="T:System.Linq.Expressions.LabelExpression" /> que representa una etiqueta con el valor predeterminado especificado.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; which this &lt;see cref=&quot;T:System.Linq.Expressions.LabelExpression&quot; /&gt; will be associated with.">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> con el que se asociará este objeto <see cref="T:System.Linq.Expressions.LabelExpression" />.</param>
      <param name="defaultValue" vsli:raw="The value of this &lt;see cref=&quot;T:System.Linq.Expressions.LabelExpression&quot; /&gt; when the label is reached through regular control flow.">Valor de este objeto <see cref="T:System.Linq.Expressions.LabelExpression" /> cuando se alcanza la etiqueta mediante el flujo de control regular.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LabelExpression&quot; /&gt; with the given default value.">
        <see cref="T:System.Linq.Expressions.LabelExpression" /> con el valor predeterminado dado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.String)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; representing a label with void type and the given name.">Crea un objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa una etiqueta con un tipo void y con el nombre dado.</summary>
      <param name="name" vsli:raw="The name of the label.">Nombre de la etiqueta.</param>
      <returns vsli:raw="The new &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt;.">Nuevo objeto <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; representing a label with the given type.">Crea un objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa una etiqueta con el tipo dado.</summary>
      <param name="type" vsli:raw="The type of value that is passed when jumping to the label.">Tipo de valor que se pasa cuando se produce el salto a la etiqueta.</param>
      <returns vsli:raw="The new &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt;.">Nuevo objeto <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Type,System.String)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; representing a label with the given type and name.">Crea un objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa una etiqueta con el tipo y el nombre dados.</summary>
      <param name="type" vsli:raw="The type of value that is passed when jumping to the label.">Tipo de valor que se pasa cuando se produce el salto a la etiqueta.</param>
      <param name="name" vsli:raw="The name of the label.">Nombre de la etiqueta.</param>
      <returns vsli:raw="The new &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt;.">Nuevo objeto <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; by first constructing a delegate type from the expression body, a parameter that indicates whether tail call optimization will be applied, and an enumerable collection of parameter expressions. It can be used when the delegate type is not known at compile time.">Crea una clase <see cref="T:System.Linq.Expressions.LambdaExpression" /> construyendo primero un tipo de delegado a partir del cuerpo de la expresión, un parámetro que indica si se aplicará la optimización de la llamada de cola y una colección enumerable de expresiones de parámetros. Se puede usar cuando no se conoce el tipo de delegado en tiempo de compilación.</summary>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall" vsli:raw="A &lt;see cref=&quot;T:System.Boolean&quot; /&gt; that indicates if tail call optimization will be applied when compiling the created expression.">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</param>
      <param name="parameters" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.NodeType&quot; /&gt; property equal to Lambda and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; by first constructing a delegate type from the expression body, a parameter that indicates whether tail call optimization will be applied, and an array of parameter expressions. It can be used when the delegate type is not known at compile time.">Crea una clase <see cref="T:System.Linq.Expressions.LambdaExpression" /> construyendo primero un tipo de delegado a partir del cuerpo de la expresión, un parámetro que indica si se aplicará la optimización de la llamada de cola y una matriz de expresiones de parámetros. Se puede usar cuando no se conoce el tipo de delegado en tiempo de compilación.</summary>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall" vsli:raw="A &lt;see cref=&quot;T:System.Boolean&quot; /&gt; that indicates if tail call optimization will be applied when compiling the created expression.">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</param>
      <param name="parameters" vsli:raw="An array that contains &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">Matriz que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.NodeType&quot; /&gt; property equal to Lambda and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; by first constructing a delegate type from the expression body, and an enumerable collection of parameter expressions. It can be used when the delegate type is not known at compile time.">Crea una clase <see cref="T:System.Linq.Expressions.LambdaExpression" /> construyendo primero un tipo de delegado a partir del cuerpo de la expresión y una colección enumerable de expresiones de parámetros. Se puede usar cuando no se conoce el tipo de delegado en tiempo de compilación.</summary>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.NodeType&quot; /&gt; property equal to Lambda and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; by first constructing a delegate type from the expression body, and an array of parameter expressions. It can be used when the delegate type is not known at compile time.">Crea una clase <see cref="T:System.Linq.Expressions.LambdaExpression" /> construyendo primero un tipo de delegado a partir del cuerpo de la expresión y una matriz de expresiones de parámetros. Se puede usar cuando no se conoce el tipo de delegado en tiempo de compilación.</summary>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">Matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Lambda&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;body&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more elements of &lt;paramref name=&quot;parameters&quot; /&gt; are &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="body" /> es <see langword="null" />.  
o bien 
Uno o más elementos de <paramref name="parameters" /> son <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;parameters&quot; /&gt; contains more than sixteen elements.">
        <paramref name="parameters" /> contiene más de dieciséis elementos.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; by first constructing a delegate type from the expression body, the name for the lambda, a parameter that indicates whether tail call optimization will be applied, and an enumerable collection of parameter expressions. It can be used when the delegate type is not known at compile time.">Crea una clase <see cref="T:System.Linq.Expressions.LambdaExpression" /> construyendo primero un tipo de delegado a partir del cuerpo de la expresión, el nombre de la expresión lambda, un parámetro que indica si se aplicará la optimización de la llamada de cola y una colección enumerable de expresiones de parámetros. Se puede usar cuando no se conoce el tipo de delegado en tiempo de compilación.</summary>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="name" vsli:raw="The name for the lambda. Used for emitting debug information.">Nombre de la expresión lambda. Se usa para emitir información de depuración.</param>
      <param name="tailCall" vsli:raw="A &lt;see cref=&quot;T:System.Boolean&quot; /&gt; that indicates if tail call optimization will be applied when compiling the created expression.">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</param>
      <param name="parameters" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.NodeType&quot; /&gt; property equal to Lambda and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; by first constructing a delegate type from the expression body, the name for the lambda, and an enumerable collection of parameter expressions. It can be used when the delegate type is not known at compile time.">Crea una clase <see cref="T:System.Linq.Expressions.LambdaExpression" /> construyendo primero un tipo de delegado a partir del cuerpo de la expresión, el nombre de la expresión lambda y una colección enumerable de expresiones de parámetros. Se puede usar cuando no se conoce el tipo de delegado en tiempo de compilación.</summary>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="name" vsli:raw="The name for the lambda. Used for emitting debug information.">Nombre de la expresión lambda. Se usa para emitir información de depuración.</param>
      <param name="parameters" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.NodeType&quot; /&gt; property equal to Lambda and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; where the delegate type is known at compile time, with a parameter that indicates whether tail call optimization will be applied, and an enumerable collection of parameter expressions.">Crea una clase <see cref="T:System.Linq.Expressions.LambdaExpression" /> en la que el tipo de delegado se conoce en el momento de la compilación, con un parámetro que indica si se aplicará la optimización de la llamada de cola y una colección enumerable de expresiones de parámetros.</summary>
      <param name="delegateType" vsli:raw="A &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; representing the delegate signature for the lambda.">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa la firma de delegado para lambda.</param>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall" vsli:raw="A &lt;see cref=&quot;T:System.Boolean&quot; /&gt; that indicates if tail call optimization will be applied when compiling the created expression.">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</param>
      <param name="parameters" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.NodeType&quot; /&gt; property equal to Lambda and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; where the delegate type is known at compile time, with a parameter that indicates whether tail call optimization will be applied, and an array of parameter expressions.">Crea una clase <see cref="T:System.Linq.Expressions.LambdaExpression" /> en la que el tipo de delegado se conoce en el momento de la compilación, con un parámetro que indica si se aplicará la optimización de la llamada de cola y una matriz de expresiones de parámetros.</summary>
      <param name="delegateType" vsli:raw="A &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; representing the delegate signature for the lambda.">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa la firma de delegado para lambda.</param>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall" vsli:raw="A &lt;see cref=&quot;T:System.Boolean&quot; /&gt; that indicates if tail call optimization will be applied when compiling the created expression.">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</param>
      <param name="parameters" vsli:raw="An array that contains &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">Matriz que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.NodeType&quot; /&gt; property equal to Lambda and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; where the delegate type is known at compile time, with an enumerable collection of parameter expressions.">Crea una clase <see cref="T:System.Linq.Expressions.LambdaExpression" /> en la que el tipo de delegado se conoce en el momento de la compilación, con una colección enumerable de expresiones de parámetros.</summary>
      <param name="delegateType" vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; that represents a delegate signature for the lambda.">Objeto <see cref="T:System.Type" /> que representa una signatura de delegado para la expresión lambda.</param>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns vsli:raw="An object that represents a lambda expression which has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Lambda&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">Objeto que representa una expresión lambda cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;delegateType&quot; /&gt; or &lt;paramref name=&quot;body&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more elements in &lt;paramref name=&quot;parameters&quot; /&gt; are &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="delegateType" /> o <paramref name="body" /> es <see langword="null" />.  
O bien 
Uno o más elementos de <paramref name="parameters" /> son <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;delegateType&quot; /&gt; does not represent a delegate type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;body&quot; /&gt;.Type represents a type that is not assignable to the return type of the delegate type represented by &lt;paramref name=&quot;delegateType&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;parameters&quot; /&gt; does not contain the same number of elements as the list of parameters for the delegate type represented by &lt;paramref name=&quot;delegateType&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of an element of &lt;paramref name=&quot;parameters&quot; /&gt; is not assignable from the type of the corresponding parameter type of the delegate type represented by &lt;paramref name=&quot;delegateType&quot; /&gt;.">
        <paramref name="delegateType" /> no representa un tipo de delegado.  
o bien 
 <paramref name="body" />.Type representa un tipo que no se puede asignar al tipo de valor devuelto del tipo de delegado representado por <paramref name="delegateType" />.  
O bien 
 <paramref name="parameters" /> no contiene el mismo número de elementos que la lista de parámetros para el tipo de delegado representado por <paramref name="delegateType" />.  
O bien 
La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="parameters" /> no se puede asignar desde el tipo del correspondiente tipo de parámetro del tipo de delegado representado por <paramref name="delegateType" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; where the delegate type is known at compile time, with an array of parameter expressions.">Crea una clase <see cref="T:System.Linq.Expressions.LambdaExpression" /> en la que el tipo de delegado se conoce en el momento de la compilación, con una colección enumerable de expresiones de parámetros.</summary>
      <param name="delegateType" vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; that represents a delegate signature for the lambda.">Objeto <see cref="T:System.Type" /> que representa una signatura de delegado para la expresión lambda.</param>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">Matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns vsli:raw="An object that represents a lambda expression which has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Lambda&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">Objeto que representa una expresión lambda cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;delegateType&quot; /&gt; or &lt;paramref name=&quot;body&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more elements in &lt;paramref name=&quot;parameters&quot; /&gt; are &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="delegateType" /> o <paramref name="body" /> es <see langword="null" />.  
O bien 
Uno o más elementos de <paramref name="parameters" /> son <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;delegateType&quot; /&gt; does not represent a delegate type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;body&quot; /&gt;.Type represents a type that is not assignable to the return type of the delegate type represented by &lt;paramref name=&quot;delegateType&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;parameters&quot; /&gt; does not contain the same number of elements as the list of parameters for the delegate type represented by &lt;paramref name=&quot;delegateType&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of an element of &lt;paramref name=&quot;parameters&quot; /&gt; is not assignable from the type of the corresponding parameter type of the delegate type represented by &lt;paramref name=&quot;delegateType&quot; /&gt;.">
        <paramref name="delegateType" /> no representa un tipo de delegado.  
O bien 
 <paramref name="body" />.Type representa un tipo que no se puede asignar al tipo de valor devuelto del tipo de delegado representado por <paramref name="delegateType" />.  
O bien 
 <paramref name="parameters" /> no contiene el mismo número de elementos que la lista de parámetros para el tipo de delegado representado por <paramref name="delegateType" />.  
o bien 
La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="parameters" /> no se puede asignar desde el tipo del correspondiente tipo de parámetro del tipo de delegado representado por <paramref name="delegateType" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; where the delegate type is known at compile time, with the name for the lambda, a parameter that indicates whether tail call optimization will be applied, and an enumerable collection of parameter expressions.">Crea una clase <see cref="T:System.Linq.Expressions.LambdaExpression" /> en la que el tipo de delegado se conoce en el momento de la compilación, con el nombre de la expresión lambda, un parámetro que indica si se aplicará la optimización de la llamada de cola y una colección enumerable de expresiones de parámetros.</summary>
      <param name="delegateType" vsli:raw="A &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; representing the delegate signature for the lambda.">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa la firma de delegado para lambda.</param>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="name" vsli:raw="The name for the lambda. Used for emitting debug information.">Nombre de la expresión lambda. Se usa para emitir información de depuración.</param>
      <param name="tailCall" vsli:raw="A &lt;see cref=&quot;T:System.Boolean&quot; /&gt; that indicates if tail call optimization will be applied when compiling the created expression.">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</param>
      <param name="parameters" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.NodeType&quot; /&gt; property equal to Lambda and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; where the delegate type is known at compile time, with the name for the lambda, and an enumerable collection of parameter expressions.">Crea una clase <see cref="T:System.Linq.Expressions.LambdaExpression" /> en la que el tipo de delegado se conoce en el momento de la compilación, con el nombre de la expresión lambda y una colección enumerable de expresiones de parámetros.</summary>
      <param name="delegateType" vsli:raw="A &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; representing the delegate signature for the lambda.">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa la firma de delegado para lambda.</param>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="name" vsli:raw="The name for the lambda. Used for emitting debug information.">Nombre de la expresión lambda. Se usa para emitir información de depuración.</param>
      <param name="parameters" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.NodeType&quot; /&gt; property equal to Lambda and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt; where the delegate type is known at compile time, with a parameter that indicates whether tail call optimization will be applied, and an enumerable collection of parameter expressions.">Crea una clase <see cref="T:System.Linq.Expressions.Expression`1" /> en la que el tipo de delegado se conoce en el momento de la compilación, con un parámetro que indica si se aplicará la optimización de la llamada de cola y una colección enumerable de expresiones de parámetros.</summary>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall" vsli:raw="A &lt;see cref=&quot;T:System.Boolean&quot; /&gt; that indicates if tail call optimization will be applied when compiling the created expression.">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</param>
      <param name="parameters" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate" vsli:raw="The delegate type.">Tipo de delegado.</typeparam>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Lambda&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.Expression`1" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt; where the delegate type is known at compile time, with a parameter that indicates whether tail call optimization will be applied, and an array of parameter expressions.">Crea una clase <see cref="T:System.Linq.Expressions.Expression`1" /> en la que el tipo de delegado se conoce en el momento de la compilación, con un parámetro que indica si se aplicará la optimización de la llamada de cola y una matriz de expresiones de parámetros.</summary>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall" vsli:raw="A &lt;see cref=&quot;T:System.Boolean&quot; /&gt; that indicates if tail call optimization will be applied when compiling the created expression.">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</param>
      <param name="parameters" vsli:raw="An array that contains &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">Matriz que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate" vsli:raw="The delegate type.">Tipo de delegado.</typeparam>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Lambda&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.Expression`1" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt; where the delegate type is known at compile time, with an enumerable collection of parameter expressions.">Crea una clase <see cref="T:System.Linq.Expressions.Expression`1" /> en la que el tipo de delegado se conoce en el momento de la compilación, con una colección enumerable de expresiones de parámetros.</summary>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate" vsli:raw="A delegate type.">Tipo de delegado.</typeparam>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Lambda&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.Expression`1" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;body&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more elements in &lt;paramref name=&quot;parameters&quot; /&gt; are &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="body" /> es <see langword="null" />.  
O bien 
Uno o más elementos de <paramref name="parameters" /> son <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;TDelegate&quot; /&gt; is not a delegate type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;body&quot; /&gt;.Type represents a type that is not assignable to the return type of &lt;paramref name=&quot;TDelegate&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;parameters&quot; /&gt; does not contain the same number of elements as the list of parameters for &lt;paramref name=&quot;TDelegate&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of an element of &lt;paramref name=&quot;parameters&quot; /&gt; is not assignable from the type of the corresponding parameter type of &lt;paramref name=&quot;TDelegate&quot; /&gt;.">
        <paramref name="TDelegate" /> no es un tipo de delegado.  
o bien 
 <paramref name="body" />.Type representa un tipo que no se puede asignar al tipo de valor devuelto de <paramref name="TDelegate" />.  
o bien 
 <paramref name="parameters" /> no contiene el mismo número de elementos que la lista de parámetros para <paramref name="TDelegate" />.  
O bien 
La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="parameters" /> no se puede asignar desde el tipo del correspondiente tipo de parámetro de <paramref name="TDelegate" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt; where the delegate type is known at compile time, with an array of parameter expressions.">Crea una clase <see cref="T:System.Linq.Expressions.Expression`1" /> en la que el tipo de delegado se conoce en el momento de la compilación, con una matriz de expresiones de parámetros.</summary>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">Matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate" vsli:raw="A delegate type.">Tipo de delegado.</typeparam>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Lambda&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.Expression`1" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;body&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more elements in &lt;paramref name=&quot;parameters&quot; /&gt; are &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="body" /> es <see langword="null" />.  
O bien 
Uno o más elementos de <paramref name="parameters" /> son <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;TDelegate&quot; /&gt; is not a delegate type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;body&quot; /&gt;.Type represents a type that is not assignable to the return type of &lt;paramref name=&quot;TDelegate&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;parameters&quot; /&gt; does not contain the same number of elements as the list of parameters for &lt;paramref name=&quot;TDelegate&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of an element of &lt;paramref name=&quot;parameters&quot; /&gt; is not assignable from the type of the corresponding parameter type of &lt;paramref name=&quot;TDelegate&quot; /&gt;.">
        <paramref name="TDelegate" /> no es un tipo de delegado.  
O bien 
 <paramref name="body" />.Type representa un tipo que no se puede asignar al tipo de valor devuelto de <paramref name="TDelegate" />.  
O bien 
 <paramref name="parameters" /> no contiene el mismo número de elementos que la lista de parámetros para <paramref name="TDelegate" />.  
o bien 
La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="parameters" /> no se puede asignar desde el tipo del correspondiente tipo de parámetro de <paramref name="TDelegate" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt; where the delegate type is known at compile time, with the name for the lambda, a parameter that indicates whether tail call optimization will be applied, and an enumerable collection of parameter expressions.">Crea una clase <see cref="T:System.Linq.Expressions.Expression`1" /> en la que el tipo de delegado se conoce en el momento de la compilación, con el nombre de la expresión lambda, un parámetro que indica si se aplicará la optimización de la llamada de cola y una colección enumerable de expresiones de parámetros.</summary>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="name" vsli:raw="The name of the lambda. Used for generating debugging info.">Nombre de la expresión lambda. Se usa para emitir información de depuración.</param>
      <param name="tailCall" vsli:raw="A &lt;see cref=&quot;T:System.Boolean&quot; /&gt; that indicates if tail call optimization will be applied when compiling the created expression.">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</param>
      <param name="parameters" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate" vsli:raw="The delegate type.">Tipo de delegado.</typeparam>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Lambda&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.Expression`1" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt; where the delegate type is known at compile time, with the name for the lambda, and an enumerable collection of parameter expressions.">Crea una clase <see cref="T:System.Linq.Expressions.Expression`1" /> en la que el tipo de delegado se conoce en el momento de la compilación, con el nombre de la expresión lambda y una colección enumerable de expresiones de parámetros.</summary>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="name" vsli:raw="The name of the lambda. Used for generating debugging information.">Nombre de la expresión lambda. Se usa para emitir información de depuración.</param>
      <param name="parameters" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate" vsli:raw="The delegate type.">Tipo de delegado.</typeparam>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Lambda&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.Expression`1" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise left-shift operation.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación bit a bit de desplazamiento a la izquierda.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.LeftShift&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The left-shift operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">No hay ningún operador de desplazamiento a la izquierda definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise left-shift operation.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación bit a bit de desplazamiento a la izquierda.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.LeftShift&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the left-shift operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> es <see langword="null" /> y no hay ningún operador de desplazamiento a la izquierda definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise left-shift assignment operation.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación y desplazamiento a la izquierda bit a bit.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.LeftShiftAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise left-shift assignment operation.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación y desplazamiento a la izquierda bit a bit.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.LeftShiftAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise left-shift assignment operation.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación y desplazamiento a la izquierda bit a bit.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.LeftShiftAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a &quot;less than&quot; numeric comparison.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "menor que".</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.LessThan&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &quot;less than&quot; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">No hay ningún operador "menor que" definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a &quot;less than&quot; numeric comparison.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "menor que".</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt; to &lt;see langword=&quot;true&quot; /&gt;; &lt;see langword=&quot;false&quot; /&gt; to set &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt; to &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en <see langword="true" />; es <see langword="false" /> para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en <see langword="false" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.LessThan&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the &quot;less than&quot; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> es <see langword="null" /> y el operador "menor que" no está definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a &quot; less than or equal&quot; numeric comparison.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "menor o igual que".</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.LessThanOrEqual&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &quot;less than or equal&quot; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">No hay ningún operador "menor o igual que" definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a &quot;less than or equal&quot; numeric comparison.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "menor o igual que".</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt; to &lt;see langword=&quot;true&quot; /&gt;; &lt;see langword=&quot;false&quot; /&gt; to set &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt; to &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en <see langword="true" />; es <see langword="false" /> para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en <see langword="false" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.LessThanOrEqual&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the &quot;less than or equal&quot; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> es <see langword="null" /> y no hay ningún operador "menor o igual que" definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberListBinding&quot; /&gt; where the member is a field or property.">Crea un objeto <see cref="T:System.Linq.Expressions.MemberListBinding" /> donde el miembro es un campo o una propiedad.</summary>
      <param name="member" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; that represents a field or property to set the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MemberInfo" /> que representa un campo o una propiedad en la que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="initializers" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.MemberListBinding.Initializers&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ElementInit" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberListBinding&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.BindingType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.MemberBindingType.ListBinding&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MemberListBinding.Initializers&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.MemberListBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> y <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;member&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more elements of &lt;paramref name=&quot;initializers&quot; /&gt; are &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="member" /> es <see langword="null" />.  
o bien 
Uno o más elementos de <paramref name="initializers" /> son <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;member&quot; /&gt; does not represent a field or property.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Reflection.FieldInfo.FieldType&quot; /&gt; or &lt;see cref=&quot;P:System.Reflection.PropertyInfo.PropertyType&quot; /&gt; of the field or property that &lt;paramref name=&quot;member&quot; /&gt; represents does not implement &lt;see cref=&quot;T:System.Collections.IEnumerable&quot; /&gt;.">
        <paramref name="member" /> no representa ningún campo ni ninguna propiedad.  
o bien 
El objeto <see cref="P:System.Reflection.FieldInfo.FieldType" /> o <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> del campo o de la propiedad que <paramref name="member" /> representa no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Linq.Expressions.ElementInit[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberListBinding&quot; /&gt; where the member is a field or property.">Crea un objeto <see cref="T:System.Linq.Expressions.MemberListBinding" /> donde el miembro es un campo o una propiedad.</summary>
      <param name="member" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; that represents a field or property to set the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MemberInfo" /> que representa un campo o una propiedad en la que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="initializers" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.MemberListBinding.Initializers&quot; /&gt; collection.">Matriz de objetos <see cref="T:System.Linq.Expressions.ElementInit" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberListBinding&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.BindingType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.MemberBindingType.ListBinding&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MemberListBinding.Initializers&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.MemberListBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> y <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;member&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more elements of &lt;paramref name=&quot;initializers&quot; /&gt; are &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="member" /> es <see langword="null" />.  
O bien 
Uno o más elementos de <paramref name="initializers" /> son <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;member&quot; /&gt; does not represent a field or property.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Reflection.FieldInfo.FieldType&quot; /&gt; or &lt;see cref=&quot;P:System.Reflection.PropertyInfo.PropertyType&quot; /&gt; of the field or property that &lt;paramref name=&quot;member&quot; /&gt; represents does not implement &lt;see cref=&quot;T:System.Collections.IEnumerable&quot; /&gt;.">
        <paramref name="member" /> no representa ningún campo ni ninguna propiedad.  
O bien 
El objeto <see cref="P:System.Reflection.FieldInfo.FieldType" /> o <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> del campo o de la propiedad que <paramref name="member" /> representa no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberListBinding&quot; /&gt; based on a specified property accessor method.">Crea un objeto <see cref="T:System.Linq.Expressions.MemberListBinding" /> basándose en el método de descriptor de acceso de propiedad especificado.</summary>
      <param name="propertyAccessor" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents a property accessor method.">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de descriptor de acceso de propiedad.</param>
      <param name="initializers" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.MemberListBinding.Initializers&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ElementInit" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberListBinding&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.BindingType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.MemberBindingType.ListBinding&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; property set to the &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; that represents the property accessed in &lt;paramref name=&quot;propertyAccessor&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.MemberListBinding.Initializers&quot; /&gt; populated with the elements of &lt;paramref name=&quot;initializers&quot; /&gt;.">
        <see cref="T:System.Linq.Expressions.MemberListBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> se establece en el objeto <see cref="T:System.Reflection.MemberInfo" /> que representa la propiedad a la que se obtiene acceso en <paramref name="propertyAccessor" />, y <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> se rellena con los elementos de <paramref name="initializers" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;propertyAccessor&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more elements of &lt;paramref name=&quot;initializers&quot; /&gt; are &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="propertyAccessor" /> es <see langword="null" />.  
o bien 
Uno o más elementos de <paramref name="initializers" /> son <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;propertyAccessor&quot; /&gt; does not represent a property accessor method.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Reflection.PropertyInfo.PropertyType&quot; /&gt; of the property that the method represented by &lt;paramref name=&quot;propertyAccessor&quot; /&gt; accesses does not implement &lt;see cref=&quot;T:System.Collections.IEnumerable&quot; /&gt;.">
        <paramref name="propertyAccessor" /> no representa ningún método de descriptor de acceso de propiedad.  
O bien 
El objeto <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> de la propiedad a la que obtiene acceso el método representado por <paramref name="propertyAccessor" /> no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Linq.Expressions.ElementInit[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberListBinding&quot; /&gt; object based on a specified property accessor method.">Crea un objeto <see cref="T:System.Linq.Expressions.MemberListBinding" /> basándose en el método de descriptor de acceso de propiedad especificado.</summary>
      <param name="propertyAccessor" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents a property accessor method.">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de descriptor de acceso de propiedad.</param>
      <param name="initializers" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.MemberListBinding.Initializers&quot; /&gt; collection.">Matriz de objetos <see cref="T:System.Linq.Expressions.ElementInit" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberListBinding&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.BindingType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.MemberBindingType.ListBinding&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; property set to the &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; that represents the property accessed in &lt;paramref name=&quot;propertyAccessor&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.MemberListBinding.Initializers&quot; /&gt; populated with the elements of &lt;paramref name=&quot;initializers&quot; /&gt;.">
        <see cref="T:System.Linq.Expressions.MemberListBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> se establece en el objeto <see cref="T:System.Reflection.MemberInfo" /> que representa la propiedad a la que se obtiene acceso en <paramref name="propertyAccessor" />, y <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> se rellena con los elementos de <paramref name="initializers" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;propertyAccessor&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more elements of &lt;paramref name=&quot;initializers&quot; /&gt; are &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="propertyAccessor" /> es <see langword="null" />.  
O bien 
Uno o más elementos de <paramref name="initializers" /> son <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;propertyAccessor&quot; /&gt; does not represent a property accessor method.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Reflection.PropertyInfo.PropertyType&quot; /&gt; of the property that the method represented by &lt;paramref name=&quot;propertyAccessor&quot; /&gt; accesses does not implement &lt;see cref=&quot;T:System.Collections.IEnumerable&quot; /&gt;.">
        <paramref name="propertyAccessor" /> no representa ningún método de descriptor de acceso de propiedad.  
o bien 
El objeto <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> de la propiedad a la que obtiene acceso el método representado por <paramref name="propertyAccessor" /> no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.ListInitExpression&quot; /&gt; that uses specified &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt; objects to initialize a collection.">Crea un objeto <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa los objetos <see cref="T:System.Linq.Expressions.ElementInit" /> especificados para inicializar una colección.</summary>
      <param name="newExpression" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.NewExpression&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="initializers" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.Initializers&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ElementInit" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ListInitExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ListInit&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.NewExpression&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.Initializers&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> y <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;newExpression&quot; /&gt; or &lt;paramref name=&quot;initializers&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more elements of &lt;paramref name=&quot;initializers&quot; /&gt; are &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="newExpression" /> o <paramref name="initializers" /> es <see langword="null" />.  
O bien 
Uno o más elementos de <paramref name="initializers" /> son <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;newExpression&quot; /&gt;.Type does not implement &lt;see cref=&quot;T:System.Collections.IEnumerable&quot; /&gt;.">
        <paramref name="newExpression" />.Type no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.ListInitExpression&quot; /&gt; that uses a method named &quot;Add&quot; to add elements to a collection.">Crea un objeto <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa un método llamado "Add" para agregar elementos a una colección.</summary>
      <param name="newExpression" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.NewExpression&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="initializers" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.Initializers&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ListInitExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ListInit&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.NewExpression&quot; /&gt; property set to the specified value.">
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> y cuya propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> se establece en el valor especificado.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;newExpression&quot; /&gt; or &lt;paramref name=&quot;initializers&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more elements of &lt;paramref name=&quot;initializers&quot; /&gt; are &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="newExpression" /> o <paramref name="initializers" /> es <see langword="null" />.  
o bien 
Uno o más elementos de <paramref name="initializers" /> son <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;newExpression&quot; /&gt;.Type does not implement &lt;see cref=&quot;T:System.Collections.IEnumerable&quot; /&gt;.">
        <paramref name="newExpression" />.Type no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="There is no instance method named &quot;Add&quot; (case insensitive) declared in &lt;paramref name=&quot;newExpression&quot; /&gt;.Type or its base type.  &#xA;  &#xA; -or-  &#xA;  &#xA; The add method on &lt;paramref name=&quot;newExpression&quot; /&gt;.Type or its base type does not take exactly one argument.  &#xA;  &#xA; -or-  &#xA;  &#xA; The type represented by the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of the first element of &lt;paramref name=&quot;initializers&quot; /&gt; is not assignable to the argument type of the add method on &lt;paramref name=&quot;newExpression&quot; /&gt;.Type or its base type.  &#xA;  &#xA; -or-  &#xA;  &#xA; More than one argument-compatible method named &quot;Add&quot; (case-insensitive) exists on &lt;paramref name=&quot;newExpression&quot; /&gt;.Type and/or its base type.">No hay ningún método de instancia denominado "Add" (no distingue mayúsculas de minúsculas) declarado en <paramref name="newExpression" />.Type o su tipo base.  
o bien 
El método de adición en <paramref name="newExpression" />.Type o su tipo base no toma exactamente un argumento.  
O bien 
El tipo representado por la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> del primer elemento de <paramref name="initializers" /> no es asignable al tipo de argumento del método de adición en <paramref name="newExpression" />.Type o su tipo base.  
o bien 
Existe más de un método compatible con los argumentos denominado "Add" (no distingue mayúsculas y minúsculas) en <paramref name="newExpression" />.Type o su tipo base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.ElementInit[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.ListInitExpression&quot; /&gt; that uses specified &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt; objects to initialize a collection.">Crea un objeto <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa los objetos <see cref="T:System.Linq.Expressions.ElementInit" /> especificados para inicializar una colección.</summary>
      <param name="newExpression" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.NewExpression&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="initializers" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.Initializers&quot; /&gt; collection.">Matriz de objetos <see cref="T:System.Linq.Expressions.ElementInit" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ListInitExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ListInit&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.NewExpression&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.Initializers&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> y <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;newExpression&quot; /&gt; or &lt;paramref name=&quot;initializers&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more elements of &lt;paramref name=&quot;initializers&quot; /&gt; are &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="newExpression" /> o <paramref name="initializers" /> es <see langword="null" />.  
O bien 
Uno o más elementos de <paramref name="initializers" /> son <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;newExpression&quot; /&gt;.Type does not implement &lt;see cref=&quot;T:System.Collections.IEnumerable&quot; /&gt;.">
        <paramref name="newExpression" />.Type no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.ListInitExpression&quot; /&gt; that uses a method named &quot;Add&quot; to add elements to a collection.">Crea un objeto <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa un método llamado "Add" para agregar elementos a una colección.</summary>
      <param name="newExpression" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.NewExpression&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="initializers" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.Initializers&quot; /&gt; collection.">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ListInitExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ListInit&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.NewExpression&quot; /&gt; property set to the specified value.">
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> y cuya propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> se establece en el valor especificado.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;newExpression&quot; /&gt; or &lt;paramref name=&quot;initializers&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more elements of &lt;paramref name=&quot;initializers&quot; /&gt; are &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="newExpression" /> o <paramref name="initializers" /> es <see langword="null" />.  
O bien 
Uno o más elementos de <paramref name="initializers" /> son <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;newExpression&quot; /&gt;.Type does not implement &lt;see cref=&quot;T:System.Collections.IEnumerable&quot; /&gt;.">
        <paramref name="newExpression" />.Type no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="There is no instance method named &quot;Add&quot; (case insensitive) declared in &lt;paramref name=&quot;newExpression&quot; /&gt;.Type or its base type.  &#xA;  &#xA; -or-  &#xA;  &#xA; The add method on &lt;paramref name=&quot;newExpression&quot; /&gt;.Type or its base type does not take exactly one argument.  &#xA;  &#xA; -or-  &#xA;  &#xA; The type represented by the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of the first element of &lt;paramref name=&quot;initializers&quot; /&gt; is not assignable to the argument type of the add method on &lt;paramref name=&quot;newExpression&quot; /&gt;.Type or its base type.  &#xA;  &#xA; -or-  &#xA;  &#xA; More than one argument-compatible method named &quot;Add&quot; (case-insensitive) exists on &lt;paramref name=&quot;newExpression&quot; /&gt;.Type and/or its base type.">No hay ningún método de instancia denominado "Add" (no distingue mayúsculas de minúsculas) declarado en <paramref name="newExpression" />.Type o su tipo base.  
O bien 
El método de adición en <paramref name="newExpression" />.Type o su tipo base no toma exactamente un argumento.  
O bien 
El tipo representado por la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> del primer elemento de <paramref name="initializers" /> no es asignable al tipo de argumento del método de adición en <paramref name="newExpression" />.Type o su tipo base.  
o bien 
Existe más de un método compatible con los argumentos denominado "Add" (no distingue mayúsculas y minúsculas) en <paramref name="newExpression" />.Type o su tipo base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.ListInitExpression&quot; /&gt; that uses a specified method to add elements to a collection.">Crea un objeto <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa el método especificado para agregar elementos a una colección.</summary>
      <param name="newExpression" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.NewExpression&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="addMethod" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents an instance method named &quot;Add&quot; (case insensitive), that adds an element to a collection.">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de instancia llamado "Add" (no distingue entre mayúsculas y minúsculas) que agrega un elemento a una colección.</param>
      <param name="initializers" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.Initializers&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ListInitExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ListInit&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.NewExpression&quot; /&gt; property set to the specified value.">
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> y cuya propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> se establece en el valor especificado.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;newExpression&quot; /&gt; or &lt;paramref name=&quot;initializers&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more elements of &lt;paramref name=&quot;initializers&quot; /&gt; are &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="newExpression" /> o <paramref name="initializers" /> es <see langword="null" />.  
O bien 
Uno o más elementos de <paramref name="initializers" /> son <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;newExpression&quot; /&gt;.Type does not implement &lt;see cref=&quot;T:System.Collections.IEnumerable&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;addMethod&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and it does not represent an instance method named &quot;Add&quot; (case insensitive) that takes exactly one argument.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;addMethod&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the type represented by the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of one or more elements of &lt;paramref name=&quot;initializers&quot; /&gt; is not assignable to the argument type of the method that &lt;paramref name=&quot;addMethod&quot; /&gt; represents.">
        <paramref name="newExpression" />.Type no implementa <see cref="T:System.Collections.IEnumerable" />.  
o bien 
 <paramref name="addMethod" /> no es <see langword="null" /> y no representa ningún método de instancia denominado "Add" (sin distinción entre mayúsculas y minúsculas) que tome exactamente un argumento.  
O bien 
 <paramref name="addMethod" /> no es <see langword="null" /> y el tipo representado por la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de uno o varios elementos de <paramref name="initializers" /> no se puede asignar al tipo de argumento del método que <paramref name="addMethod" /> representa.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;addMethod&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and no instance method named &quot;Add&quot; that takes one type-compatible argument exists on &lt;paramref name=&quot;newExpression&quot; /&gt;.Type or its base type.">
        <paramref name="addMethod" /> es <see langword="null" /> y, en <paramref name="newExpression" />.Type o su tipo base, no hay ningún método de instancia denominado "Add" que tome un argumento compatible con el tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.ListInitExpression&quot; /&gt; that uses a specified method to add elements to a collection.">Crea un objeto <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa el método especificado para agregar elementos a una colección.</summary>
      <param name="newExpression" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.NewExpression&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="addMethod" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents an instance method that takes one argument, that adds an element to a collection.">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de instancia que toma un argumento que agrega un elemento a una colección.</param>
      <param name="initializers" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.Initializers&quot; /&gt; collection.">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ListInitExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ListInit&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.NewExpression&quot; /&gt; property set to the specified value.">
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> y cuya propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> se establece en el valor especificado.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;newExpression&quot; /&gt; or &lt;paramref name=&quot;initializers&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more elements of &lt;paramref name=&quot;initializers&quot; /&gt; are &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="newExpression" /> o <paramref name="initializers" /> es <see langword="null" />.  
o bien 
Uno o más elementos de <paramref name="initializers" /> son <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;newExpression&quot; /&gt;.Type does not implement &lt;see cref=&quot;T:System.Collections.IEnumerable&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;addMethod&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and it does not represent an instance method named &quot;Add&quot; (case insensitive) that takes exactly one argument.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;addMethod&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the type represented by the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of one or more elements of &lt;paramref name=&quot;initializers&quot; /&gt; is not assignable to the argument type of the method that &lt;paramref name=&quot;addMethod&quot; /&gt; represents.">
        <paramref name="newExpression" />.Type no implementa <see cref="T:System.Collections.IEnumerable" />.  
O bien 
 <paramref name="addMethod" /> no es <see langword="null" /> y no representa ningún método de instancia denominado "Add" (sin distinción entre mayúsculas y minúsculas) que tome exactamente un argumento.  
O bien 
 <paramref name="addMethod" /> no es <see langword="null" /> y el tipo representado por la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de uno o varios elementos de <paramref name="initializers" /> no se puede asignar al tipo de argumento del método que <paramref name="addMethod" /> representa.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;addMethod&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and no instance method named &quot;Add&quot; that takes one type-compatible argument exists on &lt;paramref name=&quot;newExpression&quot; /&gt;.Type or its base type.">
        <paramref name="addMethod" /> es <see langword="null" /> y, en <paramref name="newExpression" />.Type o su tipo base, no hay ningún método de instancia denominado "Add" que tome un argumento compatible con el tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LoopExpression&quot; /&gt; with the given body.">Crea un objeto <see cref="T:System.Linq.Expressions.LoopExpression" /> con el cuerpo especificado.</summary>
      <param name="body" vsli:raw="The body of the loop.">Cuerpo del bucle.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.LoopExpression&quot; /&gt;.">Objeto <see cref="T:System.Linq.Expressions.LoopExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LoopExpression&quot; /&gt; with the given body and break target.">Crea un objeto <see cref="T:System.Linq.Expressions.LoopExpression" /> con el cuerpo especificado y el destino de Break.</summary>
      <param name="body" vsli:raw="The body of the loop.">Cuerpo del bucle.</param>
      <param name="break" vsli:raw="The break target used by the loop body.">Destino Break empleado por el cuerpo del bucle.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.LoopExpression&quot; /&gt;.">Objeto <see cref="T:System.Linq.Expressions.LoopExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LoopExpression&quot; /&gt; with the given body.">Crea un objeto <see cref="T:System.Linq.Expressions.LoopExpression" /> con el cuerpo especificado.</summary>
      <param name="body" vsli:raw="The body of the loop.">Cuerpo del bucle.</param>
      <param name="break" vsli:raw="The break target used by the loop body.">Destino Break empleado por el cuerpo del bucle.</param>
      <param name="continue" vsli:raw="The continue target used by the loop body.">Destino Continue empleado por el cuerpo del bucle.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.LoopExpression&quot; /&gt;.">Objeto <see cref="T:System.Linq.Expressions.LoopExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt;, given the left and right operands, by calling an appropriate factory method.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" />, dados los operandos izquierdo y derecho, llamando al método de generador adecuado.</summary>
      <param name="binaryType" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that specifies the type of binary operation.">Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica el tipo de la operación binaria.</param>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the left operand.">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando izquierdo.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the right operand.">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando derecho.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that results from calling the appropriate factory method.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> que resulta de llamar al método de generador adecuado.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;binaryType&quot; /&gt; does not correspond to a binary expression node.">
        <paramref name="binaryType" /> no corresponde a ningún nodo de expresión binaria.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt;, given the left operand, right operand and implementing method, by calling the appropriate factory method.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" />, dados el operando izquierdo, el operando derecho y el método de implementación, llamando al método de generador adecuado.</summary>
      <param name="binaryType" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that specifies the type of binary operation.">Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica el tipo de la operación binaria.</param>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the left operand.">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando izquierdo.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the right operand.">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando derecho.</param>
      <param name="liftToNull" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt; to &lt;see langword=&quot;true&quot; /&gt;; &lt;see langword=&quot;false&quot; /&gt; to set &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt; to &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en <see langword="true" />; es <see langword="false" /> para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en <see langword="false" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that specifies the implementing method.">
        <see cref="T:System.Reflection.MethodInfo" /> que especifica el método de implementación.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that results from calling the appropriate factory method.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> que resulta de llamar al método de generador adecuado.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;binaryType&quot; /&gt; does not correspond to a binary expression node.">
        <paramref name="binaryType" /> no corresponde a ningún nodo de expresión binaria.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt;, given the left operand, right operand, implementing method and type conversion function, by calling the appropriate factory method.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" />, dados el operando izquierdo, el operando derecho, el método de implementación y la función de conversión de tipos, llamando al método del generador apropiado.</summary>
      <param name="binaryType" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that specifies the type of binary operation.">Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica el tipo de la operación binaria.</param>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the left operand.">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando izquierdo.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the right operand.">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando derecho.</param>
      <param name="liftToNull" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt; to &lt;see langword=&quot;true&quot; /&gt;; &lt;see langword=&quot;false&quot; /&gt; to set &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt; to &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en <see langword="true" />; es <see langword="false" /> para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en <see langword="false" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that specifies the implementing method.">
        <see cref="T:System.Reflection.MethodInfo" /> que especifica el método de implementación.</param>
      <param name="conversion" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; that represents a type conversion function. This parameter is used only if &lt;paramref name=&quot;binaryType&quot; /&gt; is &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Coalesce&quot; /&gt; or compound assignment.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> que representa una función de conversión de tipos. Este parámetro solo se usa si <paramref name="binaryType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> o una asignación compuesta.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that results from calling the appropriate factory method.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> que resulta de llamar al método de generador adecuado.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;binaryType&quot; /&gt; does not correspond to a binary expression node.">
        <paramref name="binaryType" /> no corresponde a ningún nodo de expresión binaria.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeCatchBlock(System.Type,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt; representing a catch statement with the specified elements.">Crea un objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa una instrucción Catch con los elementos especificados.</summary>
      <param name="type" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; of &lt;see cref=&quot;T:System.Exception&quot; /&gt; this &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt; will handle.">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que este <see cref="T:System.Linq.Expressions.CatchBlock" /> controlará.</param>
      <param name="variable" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; representing a reference to the &lt;see cref=&quot;T:System.Exception&quot; /&gt; object caught by this handler.">Objeto <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representa una referencia al objeto <see cref="T:System.Exception" /> detectado por este controlador.</param>
      <param name="body" vsli:raw="The body of the catch statement.">Cuerpo de la instrucción Catch.</param>
      <param name="filter" vsli:raw="The body of the &lt;see cref=&quot;T:System.Exception&quot; /&gt; filter.">Cuerpo del filtro <see cref="T:System.Exception" />.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt;.">Objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;.">Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado.</summary>
      <param name="delegateType" vsli:raw="The type of the delegate used by the &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSite&quot; /&gt;.">Tipo de delegado usado por <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="arguments" vsli:raw="The arguments to the dynamic operation.">Argumentos de la operación dinámica.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt; and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.DelegateType&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt; and one argument.">Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado y un argumento.</summary>
      <param name="delegateType" vsli:raw="The type of the delegate used by the &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSite&quot; /&gt;.">Tipo de delegado usado por <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="arg0" vsli:raw="The argument to the dynamic operation.">Argumento de la operación dinámica.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt; and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.DelegateType&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt; and two arguments.">Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado y dos argumentos.</summary>
      <param name="delegateType" vsli:raw="The type of the delegate used by the &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSite&quot; /&gt;.">Tipo de delegado usado por <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="arg0" vsli:raw="The first argument to the dynamic operation.">Primer argumento de la operación dinámica.</param>
      <param name="arg1" vsli:raw="The second argument to the dynamic operation.">Segundo argumento de la operación dinámica.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt; and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.DelegateType&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt; and three arguments.">Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado y tres argumentos.</summary>
      <param name="delegateType" vsli:raw="The type of the delegate used by the &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSite&quot; /&gt;.">Tipo de delegado usado por <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="arg0" vsli:raw="The first argument to the dynamic operation.">Primer argumento de la operación dinámica.</param>
      <param name="arg1" vsli:raw="The second argument to the dynamic operation.">Segundo argumento de la operación dinámica.</param>
      <param name="arg2" vsli:raw="The third argument to the dynamic operation.">Tercer argumento de la operación dinámica.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt; and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.DelegateType&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt; and four arguments.">Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado y cuatro argumentos.</summary>
      <param name="delegateType" vsli:raw="The type of the delegate used by the &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSite&quot; /&gt;.">Tipo de delegado usado por <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="arg0" vsli:raw="The first argument to the dynamic operation.">Primer argumento de la operación dinámica.</param>
      <param name="arg1" vsli:raw="The second argument to the dynamic operation.">Segundo argumento de la operación dinámica.</param>
      <param name="arg2" vsli:raw="The third argument to the dynamic operation.">Tercer argumento de la operación dinámica.</param>
      <param name="arg3" vsli:raw="The fourth argument to the dynamic operation.">Cuarto argumento de la operación dinámica.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt; and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.DelegateType&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;.">Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado.</summary>
      <param name="delegateType" vsli:raw="The type of the delegate used by the &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSite&quot; /&gt;.">Tipo de delegado usado por <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="arguments" vsli:raw="The arguments to the dynamic operation.">Argumentos de la operación dinámica.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt; and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.DelegateType&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeGoto(System.Linq.Expressions.GotoExpressionKind,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; representing a jump of the specified &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpressionKind&quot; /&gt;. The value passed to the label upon jumping can also be specified.">Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa un salto del objeto <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> especificado. Además se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</summary>
      <param name="kind" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpressionKind&quot; /&gt; of the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt;.">
        <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> del objeto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; will jump to.">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value" vsli:raw="The value that will be passed to the associated label upon jumping.">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</param>
      <param name="type" vsli:raw="An &lt;see cref=&quot;T:System.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property equal to.">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; with &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Kind&quot; /&gt; equal to &lt;paramref name=&quot;kind&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Target&quot; /&gt; property set to &lt;paramref name=&quot;target&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property set to &lt;paramref name=&quot;type&quot; /&gt;, and &lt;paramref name=&quot;value&quot; /&gt; to be passed to the target label upon jumping.">
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a <paramref name="kind" />, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" />, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y un <paramref name="value" /> que se pasará a la etiqueta de destino al saltar.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeIndex(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Linq.Expressions.IndexExpression&quot; /&gt; that represents accessing an indexed property in an object.">Crea un objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> que representa el acceso a una propiedad indizada en un objeto.</summary>
      <param name="instance" vsli:raw="The object to which the property belongs. It should be null if the property is &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;shared&quot; /&gt; in Visual Basic).">Objeto al que pertenece la propiedad. Si la propiedad es <see langword="static" /> (<see langword="shared" /> en Visual Basic), debe ser null.</param>
      <param name="indexer" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; representing the property to index.">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa la propiedad que se va a indexar.</param>
      <param name="arguments" vsli:raw="An &lt;c&gt;IEnumerable&amp;lt;Expression&amp;gt;&lt;/c&gt; (&lt;c&gt;IEnumerable (Of Expression)&lt;/c&gt; in Visual Basic) that contains the arguments that will be used to index the property.">
        <c>IEnumerable&lt;Expression&gt;</c> (<c>IEnumerable (Of Expression)</c> en Visual Basic) que contiene los argumentos que se van a emplear para indizar la propiedad.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.IndexExpression&quot; /&gt;.">Objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeMemberAccess(System.Linq.Expressions.Expression,System.Reflection.MemberInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt; that represents accessing either a field or a property.">Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a un campo o a una propiedad.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the object that the member belongs to. This can be null for static members.">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el objeto al que pertenece el miembro. Puede ser null para los miembros estáticos.</param>
      <param name="member" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; that describes the field or property to be accessed.">
        <see cref="T:System.Reflection.MemberInfo" /> que describe el campo o la propiedad a los que se va a tener acceso.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt; that results from calling the appropriate factory method.">
        <see cref="T:System.Linq.Expressions.MemberExpression" /> que resulta de llamar al método de generador adecuado.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;member&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="member" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;member&quot; /&gt; does not represent a field or property.">
        <paramref name="member" /> no representa ningún campo ni ninguna propiedad.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeTry(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.TryExpression&quot; /&gt; representing a try block with the specified elements.">Crea un objeto <see cref="T:System.Linq.Expressions.TryExpression" /> que representa un bloque try con los elementos especificados.</summary>
      <param name="type" vsli:raw="The result type of the try expression. If null, body and all handlers must have identical type.">Tipo de resultado de la expresión try. Si es null, el cuerpo y todos los controladores deben tener un tipo idéntico.</param>
      <param name="body" vsli:raw="The body of the try block.">Cuerpo del bloque try.</param>
      <param name="finally" vsli:raw="The body of the finally block. Pass null if the try block has no finally block associated with it.">Cuerpo del bloque finally. Pasa null si el bloque try no tiene ningún bloque finally asociado.</param>
      <param name="fault" vsli:raw="The body of the fault block. Pass null if the try block has no fault block associated with it.">Cuerpo del bloque fault. Pasa null si el bloque try no tiene ningún bloque fault asociado.</param>
      <param name="handlers" vsli:raw="A collection of &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt;s representing the catch statements to be associated with the try block.">Colección de objetos <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa las instrucciones Catch que se van a asociar al bloque try.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.TryExpression&quot; /&gt;.">Objeto <see cref="T:System.Linq.Expressions.TryExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt;, given an operand, by calling the appropriate factory method.">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" />, dado un operando, llamando al método del generador apropiado.</summary>
      <param name="unaryType" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that specifies the type of unary operation.">Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica el tipo de la operación unaria.</param>
      <param name="operand" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the operand.">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando.</param>
      <param name="type" vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; that specifies the type to be converted to (pass &lt;see langword=&quot;null&quot; /&gt; if not applicable).">
        <see cref="T:System.Type" /> que especifica el tipo al que se va a convertir (pase <see langword="null" /> si no es aplicable).</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that results from calling the appropriate factory method.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que resulta de llamar al método de generador adecuado.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;operand&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="operand" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;unaryType&quot; /&gt; does not correspond to a unary expression node.">
        <paramref name="unaryType" /> no corresponde a un nodo de expresión unaria.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt;, given an operand and implementing method, by calling the appropriate factory method.">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" />, dados un operando y un método de implementación, llamando al método del generador apropiado.</summary>
      <param name="unaryType" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that specifies the type of unary operation.">Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica el tipo de la operación unaria.</param>
      <param name="operand" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the operand.">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando.</param>
      <param name="type" vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; that specifies the type to be converted to (pass &lt;see langword=&quot;null&quot; /&gt; if not applicable).">
        <see cref="T:System.Type" /> que especifica el tipo al que se va a convertir (pase <see langword="null" /> si no es aplicable).</param>
      <param name="method" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the implementing method.">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that results from calling the appropriate factory method.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que resulta de llamar al método de generador adecuado.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;operand&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="operand" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;unaryType&quot; /&gt; does not correspond to a unary expression node.">
        <paramref name="unaryType" /> no corresponde a un nodo de expresión unaria.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberMemberBinding&quot; /&gt; that represents the recursive initialization of members of a field or property.">Crea un objeto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa la inicialización recursiva de los miembros de un campo o una propiedad.</summary>
      <param name="member" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; property equal to.">Objeto <see cref="T:System.Reflection.MemberInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="bindings" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.MemberBinding&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.MemberMemberBinding.Bindings&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberMemberBinding&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.BindingType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.MemberBindingType.MemberBinding&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MemberMemberBinding.Bindings&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> y <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;member&quot; /&gt; or &lt;paramref name=&quot;bindings&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="member" /> o <paramref name="bindings" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;member&quot; /&gt; does not represent a field or property.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; property of an element of &lt;paramref name=&quot;bindings&quot; /&gt; does not represent a member of the type of the field or property that &lt;paramref name=&quot;member&quot; /&gt; represents.">
        <paramref name="member" /> no representa ningún campo ni ninguna propiedad.  
o bien 
La propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> de un elemento de <paramref name="bindings" /> no representa ningún miembro del tipo del campo o de la propiedad que <paramref name="member" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Linq.Expressions.MemberBinding[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberMemberBinding&quot; /&gt; that represents the recursive initialization of members of a field or property.">Crea un objeto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa la inicialización recursiva de los miembros de un campo o una propiedad.</summary>
      <param name="member" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; property equal to.">Objeto <see cref="T:System.Reflection.MemberInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="bindings" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.MemberBinding&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.MemberMemberBinding.Bindings&quot; /&gt; collection.">Matriz de objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberMemberBinding&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.BindingType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.MemberBindingType.MemberBinding&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MemberMemberBinding.Bindings&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> y <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;member&quot; /&gt; or &lt;paramref name=&quot;bindings&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="member" /> o <paramref name="bindings" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;member&quot; /&gt; does not represent a field or property.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; property of an element of &lt;paramref name=&quot;bindings&quot; /&gt; does not represent a member of the type of the field or property that &lt;paramref name=&quot;member&quot; /&gt; represents.">
        <paramref name="member" /> no representa ningún campo ni ninguna propiedad.  
o bien 
La propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> de un elemento de <paramref name="bindings" /> no representa ningún miembro del tipo del campo o de la propiedad que <paramref name="member" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberMemberBinding&quot; /&gt; that represents the recursive initialization of members of a member that is accessed by using a property accessor method.">Crea un objeto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa la inicialización recursiva de los miembros de un miembro al que se obtiene acceso mediante un método de descriptor de acceso de propiedad.</summary>
      <param name="propertyAccessor" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents a property accessor method.">Objeto <see cref="T:System.Reflection.MethodInfo" /> que representa un método de descriptor de acceso de propiedad.</param>
      <param name="bindings" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.MemberBinding&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.MemberMemberBinding.Bindings&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberMemberBinding&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.BindingType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.MemberBindingType.MemberBinding&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; property set to the &lt;see cref=&quot;T:System.Reflection.PropertyInfo&quot; /&gt; that represents the property accessed in &lt;paramref name=&quot;propertyAccessor&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.MemberMemberBinding.Bindings&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> se establece en el objeto <see cref="T:System.Reflection.PropertyInfo" /> que representa la propiedad a la que se obtiene acceso en <paramref name="propertyAccessor" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;propertyAccessor&quot; /&gt; or &lt;paramref name=&quot;bindings&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="propertyAccessor" /> o <paramref name="bindings" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;propertyAccessor&quot; /&gt; does not represent a property accessor method.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; property of an element of &lt;paramref name=&quot;bindings&quot; /&gt; does not represent a member of the type of the property accessed by the method that &lt;paramref name=&quot;propertyAccessor&quot; /&gt; represents.">
        <paramref name="propertyAccessor" /> no representa un método de descriptor de acceso de propiedad.  
O bien 
La propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> de un elemento de <paramref name="bindings" /> no representa ningún miembro del tipo de la propiedad a la que obtiene acceso el método representado por <paramref name="propertyAccessor" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Linq.Expressions.MemberBinding[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberMemberBinding&quot; /&gt; that represents the recursive initialization of members of a member that is accessed by using a property accessor method.">Crea un objeto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa la inicialización recursiva de los miembros de un miembro al que se obtiene acceso mediante un método de descriptor de acceso de propiedad.</summary>
      <param name="propertyAccessor" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents a property accessor method.">Objeto <see cref="T:System.Reflection.MethodInfo" /> que representa un método de descriptor de acceso de propiedad.</param>
      <param name="bindings" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.MemberBinding&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.MemberMemberBinding.Bindings&quot; /&gt; collection.">Matriz de objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberMemberBinding&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.BindingType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.MemberBindingType.MemberBinding&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; property set to the &lt;see cref=&quot;T:System.Reflection.PropertyInfo&quot; /&gt; that represents the property accessed in &lt;paramref name=&quot;propertyAccessor&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.MemberMemberBinding.Bindings&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> se establece en el objeto <see cref="T:System.Reflection.PropertyInfo" /> que representa la propiedad a la que se obtiene acceso en <paramref name="propertyAccessor" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;propertyAccessor&quot; /&gt; or &lt;paramref name=&quot;bindings&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="propertyAccessor" /> o <paramref name="bindings" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;propertyAccessor&quot; /&gt; does not represent a property accessor method.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; property of an element of &lt;paramref name=&quot;bindings&quot; /&gt; does not represent a member of the type of the property accessed by the method that &lt;paramref name=&quot;propertyAccessor&quot; /&gt; represents.">
        <paramref name="propertyAccessor" /> no representa un método de descriptor de acceso de propiedad.  
o bien 
La propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> de un elemento de <paramref name="bindings" /> no representa ningún miembro del tipo de la propiedad a la que obtiene acceso el método representado por <paramref name="propertyAccessor" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary vsli:raw="Represents an expression that creates a new object and initializes a property of the object.">Representa una expresión que crea un nuevo objeto e inicializa una propiedad del objeto.</summary>
      <param name="newExpression" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MemberInitExpression.NewExpression&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" />.</param>
      <param name="bindings" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.MemberBinding&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.MemberInitExpression.Bindings&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberInitExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.MemberInit&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MemberInitExpression.NewExpression&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MemberInitExpression.Bindings&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.MemberInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> y <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;newExpression&quot; /&gt; or &lt;paramref name=&quot;bindings&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="newExpression" /> o <paramref name="bindings" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; property of an element of &lt;paramref name=&quot;bindings&quot; /&gt; does not represent a member of the type that &lt;paramref name=&quot;newExpression&quot; /&gt;.Type represents.">La propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> de un elemento de <paramref name="bindings" /> no representa ningún miembro del tipo que <paramref name="newExpression" />.Type representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.MemberBinding[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberInitExpression&quot; /&gt;.">Crea una interfaz <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
      <param name="newExpression" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MemberInitExpression.NewExpression&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" />.</param>
      <param name="bindings" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.MemberBinding&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.MemberInitExpression.Bindings&quot; /&gt; collection.">Matriz de objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberInitExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.MemberInit&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MemberInitExpression.NewExpression&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MemberInitExpression.Bindings&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.MemberInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> y <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;newExpression&quot; /&gt; or &lt;paramref name=&quot;bindings&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="newExpression" /> o <paramref name="bindings" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; property of an element of &lt;paramref name=&quot;bindings&quot; /&gt; does not represent a member of the type that &lt;paramref name=&quot;newExpression&quot; /&gt;.Type represents.">La propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> de un elemento de <paramref name="bindings" /> no representa ningún miembro del tipo que <paramref name="newExpression" />.Type representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an arithmetic remainder operation.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de resto aritmética.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Modulo&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The modulus operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">No hay ningún operador de módulo definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an arithmetic remainder operation.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de resto aritmética.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Modulo&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the modulus operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> es <see langword="null" /> y el operador modulus no está definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a remainder assignment operation.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación y resto.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ModuloAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a remainder assignment operation.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación y resto.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ModuloAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a remainder assignment operation.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación y resto.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ModuloAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an arithmetic multiplication operation that does not have overflow checking.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de multiplicación aritmética sin comprobación de desbordamiento.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Multiply&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The multiplication operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">No hay ningún operador de multiplicación definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an arithmetic multiplication operation that does not have overflow checking.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de multiplicación aritmética sin comprobación de desbordamiento.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Multiply&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the multiplication operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> es <see langword="null" /> y no hay ningún operador de multiplicación definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a multiplication assignment operation that does not have overflow checking.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de multiplicación que no tiene comprobación de desbordamiento.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.MultiplyAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a multiplication assignment operation that does not have overflow checking.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de multiplicación que no tiene comprobación de desbordamiento.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.MultiplyAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a multiplication assignment operation that does not have overflow checking.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de multiplicación que no tiene comprobación de desbordamiento.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.MultiplyAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a multiplication assignment operation that has overflow checking.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de multiplicación que tiene comprobación de desbordamiento.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a multiplication assignment operation that has overflow checking.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de multiplicación que tiene comprobación de desbordamiento.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a multiplication assignment operation that has overflow checking.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de multiplicación que tiene comprobación de desbordamiento.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an arithmetic multiplication operation that has overflow checking.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de multiplicación aritmética con comprobación de desbordamiento.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.MultiplyChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The multiplication operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">No hay ningún operador de multiplicación definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an arithmetic multiplication operation that has overflow checking.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de multiplicación aritmética con comprobación de desbordamiento.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.MultiplyChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the multiplication operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> es <see langword="null" /> y no hay ningún operador de multiplicación definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents an arithmetic negation operation.">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de negación aritmética.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Negate&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property set to the specified value.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> y cuya propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> se establece en el valor especificado.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The unary minus operator is not defined for &lt;paramref name=&quot;expression&quot; /&gt;.Type.">No hay ningún operador unario menos definido para <paramref name="expression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents an arithmetic negation operation.">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de negación aritmética.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Negate&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly one argument.">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente un argumento.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the unary minus operator is not defined for &lt;paramref name=&quot;expression&quot; /&gt;.Type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;expression&quot; /&gt;.Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by &lt;paramref name=&quot;method&quot; /&gt;.">
        <paramref name="method" /> es <see langword="null" /> y no hay ningún operador unario menos definido para <paramref name="expression" />.Type.  
o bien 
 <paramref name="expression" />.Type (o su correspondiente tipo que no acepta valores null si se trata de un tipo de valor que acepta valores null) no puede asignarse al tipo de argumento del método representado por <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents an arithmetic negation operation that has overflow checking.">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de negación aritmética que tiene comprobación de desbordamiento.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.NegateChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property set to the specified value.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> y cuya propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> se establece en el valor especificado.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The unary minus operator is not defined for &lt;paramref name=&quot;expression&quot; /&gt;.Type.">No hay ningún operador unario menos definido para <paramref name="expression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents an arithmetic negation operation that has overflow checking. The implementing method can be specified.">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de negación aritmética que tiene comprobación de desbordamiento. Se puede especificar el método de implementación.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.NegateChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly one argument.">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente un argumento.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the unary minus operator is not defined for &lt;paramref name=&quot;expression&quot; /&gt;.Type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;expression&quot; /&gt;.Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by &lt;paramref name=&quot;method&quot; /&gt;.">
        <paramref name="method" /> es <see langword="null" /> y no hay ningún operador unario menos definido para <paramref name="expression" />.Type.  
O bien 
 <paramref name="expression" />.Type (o su correspondiente tipo que no acepta valores null si se trata de un tipo de valor que acepta valores null) no puede asignarse al tipo de argumento del método representado por <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; that represents calling the specified constructor that takes no arguments.">Crea un objeto <see cref="T:System.Linq.Expressions.NewExpression" /> que representa la llamada al constructor especificado que no toma ningún argumento.</summary>
      <param name="constructor" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.ConstructorInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Constructor&quot; /&gt; property equal to.">Objeto <see cref="T:System.Reflection.ConstructorInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.New&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Constructor&quot; /&gt; property set to the specified value.">
        <see cref="T:System.Linq.Expressions.NewExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.New" /> y cuya propiedad <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> se establece en el valor especificado.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;constructor&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="constructor" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The constructor that &lt;paramref name=&quot;constructor&quot; /&gt; represents has at least one parameter.">El constructor que <paramref name="constructor" /> representa tiene por lo menos un parámetro.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; that represents calling the specified constructor with the specified arguments.">Crea un objeto <see cref="T:System.Linq.Expressions.NewExpression" /> que representa la llamada al constructor especificado con los argumentos especificados.</summary>
      <param name="constructor" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.ConstructorInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Constructor&quot; /&gt; property equal to.">Objeto <see cref="T:System.Reflection.ConstructorInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</param>
      <param name="arguments" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Arguments&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.New&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Constructor&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Arguments&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.NewExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.New" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> y <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;constructor&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; An element of &lt;paramref name=&quot;arguments&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="constructor" /> es <see langword="null" />.  
o bien 
Un elemento de <paramref name="arguments" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;arguments&quot; /&gt; parameter does not contain the same number of elements as the number of parameters for the constructor that &lt;paramref name=&quot;constructor&quot; /&gt; represents.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of an element of &lt;paramref name=&quot;arguments&quot; /&gt; is not assignable to the type of the corresponding parameter of the constructor that &lt;paramref name=&quot;constructor&quot; /&gt; represents.">El parámetro <paramref name="arguments" /> no contiene el mismo número de elementos que el número de parámetros del constructor representado por <paramref name="constructor" />.  
o bien 
La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="arguments" /> no se puede asignar al tipo del parámetro correspondiente del constructor que representa <paramref name="constructor" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; that represents calling the specified constructor with the specified arguments. The members that access the constructor initialized fields are specified.">Crea un objeto <see cref="T:System.Linq.Expressions.NewExpression" /> que representa la llamada al constructor especificado con los argumentos especificados. Se especifican los miembros que obtienen acceso a los campos inicializados por el constructor.</summary>
      <param name="constructor" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.ConstructorInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Constructor&quot; /&gt; property equal to.">Objeto <see cref="T:System.Reflection.ConstructorInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</param>
      <param name="arguments" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Arguments&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <param name="members" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Members&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Reflection.MemberInfo" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewExpression.Members" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.New&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Constructor&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Arguments&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Members&quot; /&gt; properties set to the specified values.">Objeto <see cref="T:System.Linq.Expressions.NewExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.New" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> y <see cref="P:System.Linq.Expressions.NewExpression.Members" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;constructor&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; An element of &lt;paramref name=&quot;arguments&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; An element of &lt;paramref name=&quot;members&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="constructor" /> es <see langword="null" />.  
O bien 
Un elemento de <paramref name="arguments" /> es <see langword="null" />.  
o bien 
Un elemento de <paramref name="members" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;arguments&quot; /&gt; parameter does not contain the same number of elements as the number of parameters for the constructor that &lt;paramref name=&quot;constructor&quot; /&gt; represents.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of an element of &lt;paramref name=&quot;arguments&quot; /&gt; is not assignable to the type of the corresponding parameter of the constructor that &lt;paramref name=&quot;constructor&quot; /&gt; represents.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;paramref name=&quot;members&quot; /&gt; parameter does not have the same number of elements as &lt;paramref name=&quot;arguments&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; An element of &lt;paramref name=&quot;arguments&quot; /&gt; has a &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property that represents a type that is not assignable to the type of the member that is represented by the corresponding element of &lt;paramref name=&quot;members&quot; /&gt;.">El parámetro <paramref name="arguments" /> no contiene el mismo número de elementos que el número de parámetros del constructor representado por <paramref name="constructor" />.  
o bien 
La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="arguments" /> no se puede asignar al tipo del parámetro correspondiente del constructor que representa <paramref name="constructor" />.  
o bien 
El parámetro <paramref name="members" /> no contiene el mismo número de elementos que <paramref name="arguments" />.  
o bien 
Un elemento de <paramref name="arguments" /> tiene una propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa un tipo que no se puede asignar al tipo del miembro representado por el elemento correspondiente de <paramref name="members" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Reflection.MemberInfo[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; that represents calling the specified constructor with the specified arguments. The members that access the constructor initialized fields are specified as an array.">Crea un objeto <see cref="T:System.Linq.Expressions.NewExpression" /> que representa la llamada al constructor especificado con los argumentos especificados. Los miembros que obtienen acceso a los campos inicializados por el constructor se especifican como una matriz.</summary>
      <param name="constructor" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.ConstructorInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Constructor&quot; /&gt; property equal to.">Objeto <see cref="T:System.Reflection.ConstructorInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</param>
      <param name="arguments" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Arguments&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <param name="members" vsli:raw="An array of &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Members&quot; /&gt; collection.">Matriz de objetos <see cref="T:System.Reflection.MemberInfo" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewExpression.Members" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.New&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Constructor&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Arguments&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Members&quot; /&gt; properties set to the specified values.">Objeto <see cref="T:System.Linq.Expressions.NewExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.New" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> y <see cref="P:System.Linq.Expressions.NewExpression.Members" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;constructor&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; An element of &lt;paramref name=&quot;arguments&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; An element of &lt;paramref name=&quot;members&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="constructor" /> es <see langword="null" />.  
O bien 
Un elemento de <paramref name="arguments" /> es <see langword="null" />.  
O bien 
Un elemento de <paramref name="members" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;arguments&quot; /&gt; parameter does not contain the same number of elements as the number of parameters for the constructor that &lt;paramref name=&quot;constructor&quot; /&gt; represents.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of an element of &lt;paramref name=&quot;arguments&quot; /&gt; is not assignable to the type of the corresponding parameter of the constructor that &lt;paramref name=&quot;constructor&quot; /&gt; represents.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;paramref name=&quot;members&quot; /&gt; parameter does not have the same number of elements as &lt;paramref name=&quot;arguments&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; An element of &lt;paramref name=&quot;arguments&quot; /&gt; has a &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property that represents a type that is not assignable to the type of the member that is represented by the corresponding element of &lt;paramref name=&quot;members&quot; /&gt;.">El parámetro <paramref name="arguments" /> no contiene el mismo número de elementos que el número de parámetros del constructor representado por <paramref name="constructor" />.  
O bien 
La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="arguments" /> no se puede asignar al tipo del parámetro correspondiente del constructor que representa <paramref name="constructor" />.  
o bien 
El parámetro <paramref name="members" /> no contiene el mismo número de elementos que <paramref name="arguments" />.  
O bien 
Un elemento de <paramref name="arguments" /> tiene una propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa un tipo que no se puede asignar al tipo del miembro representado por el elemento correspondiente de <paramref name="members" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; that represents calling the specified constructor with the specified arguments.">Crea un objeto <see cref="T:System.Linq.Expressions.NewExpression" /> que representa la llamada al constructor especificado con los argumentos especificados.</summary>
      <param name="constructor" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.ConstructorInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Constructor&quot; /&gt; property equal to.">Objeto <see cref="T:System.Reflection.ConstructorInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</param>
      <param name="arguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Arguments&quot; /&gt; collection.">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.New&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Constructor&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Arguments&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.NewExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.New" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> y <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;constructor&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; An element of &lt;paramref name=&quot;arguments&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="constructor" /> es <see langword="null" />.  
o bien 
Un elemento de <paramref name="arguments" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The length of &lt;paramref name=&quot;arguments&quot; /&gt; does match the number of parameters for the constructor that &lt;paramref name=&quot;constructor&quot; /&gt; represents.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of an element of &lt;paramref name=&quot;arguments&quot; /&gt; is not assignable to the type of the corresponding parameter of the constructor that &lt;paramref name=&quot;constructor&quot; /&gt; represents.">La longitud de <paramref name="arguments" /> coincide con el número de parámetros del constructor que <paramref name="constructor" /> representa.  
o bien 
La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="arguments" /> no se puede asignar al tipo del parámetro correspondiente del constructor que representa <paramref name="constructor" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; that represents calling the parameterless constructor of the specified type.">Crea un objeto <see cref="T:System.Linq.Expressions.NewExpression" /> que representa la llamada al constructor sin parámetros del tipo especificado.</summary>
      <param name="type" vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; that has a constructor that takes no arguments.">
        <see cref="T:System.Type" /> que tiene un constructor que no toma ningún argumento.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.New&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Constructor&quot; /&gt; property set to the &lt;see cref=&quot;T:System.Reflection.ConstructorInfo&quot; /&gt; that represents the constructor without parameters for the specified type.">
        <see cref="T:System.Linq.Expressions.NewExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.New" /> y cuya propiedad <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> se establece en el objeto <see cref="T:System.Reflection.ConstructorInfo" /> que representa el constructor sin parámetros del tipo especificado.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;type&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="type" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The type that &lt;paramref name=&quot;type&quot; /&gt; represents does not have a constructor without parameters.">El tipo que <paramref name="type" /> representa no tiene un constructor sin parámetros.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.NewArrayExpression&quot; /&gt; that represents creating an array that has a specified rank.">Crea un objeto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa la creación de una matriz que tiene el rango especificado.</summary>
      <param name="type" vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; that represents the element type of the array.">
        <see cref="T:System.Type" /> que representa el tipo de elemento de la matriz.</param>
      <param name="bounds" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.NewArrayExpression.Expressions&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewArrayExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.NewArrayBounds&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.NewArrayExpression.Expressions&quot; /&gt; property set to the specified value.">
        <see cref="T:System.Linq.Expressions.NewArrayExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> y cuya propiedad <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> se establece en el valor especificado.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;type&quot; /&gt; or &lt;paramref name=&quot;bounds&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; An element of &lt;paramref name=&quot;bounds&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="type" /> o <paramref name="bounds" /> es <see langword="null" />.  
o bien 
Un elemento de <paramref name="bounds" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of an element of &lt;paramref name=&quot;bounds&quot; /&gt; does not represent an integral type.">La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="bounds" /> no representa un tipo entero.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.NewArrayExpression&quot; /&gt; that represents creating an array that has a specified rank.">Crea un objeto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa la creación de una matriz que tiene el rango especificado.</summary>
      <param name="type" vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; that represents the element type of the array.">
        <see cref="T:System.Type" /> que representa el tipo de elemento de la matriz.</param>
      <param name="bounds" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.NewArrayExpression.Expressions&quot; /&gt; collection.">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewArrayExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.NewArrayBounds&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.NewArrayExpression.Expressions&quot; /&gt; property set to the specified value.">
        <see cref="T:System.Linq.Expressions.NewArrayExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> y cuya propiedad <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> se establece en el valor especificado.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;type&quot; /&gt; or &lt;paramref name=&quot;bounds&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; An element of &lt;paramref name=&quot;bounds&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="type" /> o <paramref name="bounds" /> es <see langword="null" />.  
o bien 
Un elemento de <paramref name="bounds" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of an element of &lt;paramref name=&quot;bounds&quot; /&gt; does not represent an integral type.">La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="bounds" /> no representa un tipo entero.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.NewArrayExpression&quot; /&gt; that represents creating a one-dimensional array and initializing it from a list of elements.">Crea un objeto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa la creación de una matriz unidimensional y su inicialización a partir de una lista de elementos.</summary>
      <param name="type" vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; that represents the element type of the array.">
        <see cref="T:System.Type" /> que representa el tipo de elemento de la matriz.</param>
      <param name="initializers" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.NewArrayExpression.Expressions&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewArrayExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.NewArrayInit&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.NewArrayExpression.Expressions&quot; /&gt; property set to the specified value.">
        <see cref="T:System.Linq.Expressions.NewArrayExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> y cuya propiedad <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> se establece en el valor especificado.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;type&quot; /&gt; or &lt;paramref name=&quot;initializers&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; An element of &lt;paramref name=&quot;initializers&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="type" /> o <paramref name="initializers" /> es <see langword="null" />.  
O bien 
Un elemento de <paramref name="initializers" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of an element of &lt;paramref name=&quot;initializers&quot; /&gt; represents a type that is not assignable to the type that &lt;paramref name=&quot;type&quot; /&gt; represents.">La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="initializers" /> representa un tipo que no puede asignarse al tipo representado por <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.NewArrayExpression&quot; /&gt; that represents creating a one-dimensional array and initializing it from a list of elements.">Crea un objeto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa la creación de una matriz unidimensional y su inicialización a partir de una lista de elementos.</summary>
      <param name="type" vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; that represents the element type of the array.">
        <see cref="T:System.Type" /> que representa el tipo de elemento de la matriz.</param>
      <param name="initializers" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.NewArrayExpression.Expressions&quot; /&gt; collection.">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewArrayExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.NewArrayInit&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.NewArrayExpression.Expressions&quot; /&gt; property set to the specified value.">
        <see cref="T:System.Linq.Expressions.NewArrayExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> y cuya propiedad <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> se establece en el valor especificado.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;type&quot; /&gt; or &lt;paramref name=&quot;initializers&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; An element of &lt;paramref name=&quot;initializers&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="type" /> o <paramref name="initializers" /> es <see langword="null" />.  
O bien 
Un elemento de <paramref name="initializers" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of an element of &lt;paramref name=&quot;initializers&quot; /&gt; represents a type that is not assignable to the type &lt;paramref name=&quot;type&quot; /&gt;.">La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="initializers" /> representa un tipo que no puede asignarse al tipo <paramref name="type" />.</exception>
    </member>
    <member name="P:System.Linq.Expressions.Expression.NodeType">
      <summary vsli:raw="Gets the node type of this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Obtiene el tipo de nodo de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns vsli:raw="One of the &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; values.">Uno de los valores de <see cref="T:System.Linq.Expressions.ExpressionType" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents a bitwise complement operation.">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de complemento bit a bit.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Not&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property set to the specified value.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> y cuya propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> se establece en el valor especificado.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The unary not operator is not defined for &lt;paramref name=&quot;expression&quot; /&gt;.Type.">No hay ningún operador unario Not definido para <paramref name="expression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents a bitwise complement operation. The implementing method can be specified.">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de complemento bit a bit. Se puede especificar el método de implementación.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Not&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly one argument.">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente un argumento.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the unary not operator is not defined for &lt;paramref name=&quot;expression&quot; /&gt;.Type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;expression&quot; /&gt;.Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by &lt;paramref name=&quot;method&quot; /&gt;.">
        <paramref name="method" /> es <see langword="null" /> y no hay ningún operador unario Not definido para <paramref name="expression" />.Type.  
O bien 
 <paramref name="expression" />.Type (o su correspondiente tipo que no acepta valores null si se trata de un tipo de valor que acepta valores null) no puede asignarse al tipo de argumento del método representado por <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an inequality comparison.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación de desigualdad.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.NotEqual&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The inequality operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">No hay ningún operador de desigualdad definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an inequality comparison.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación de desigualdad.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt; to &lt;see langword=&quot;true&quot; /&gt;; &lt;see langword=&quot;false&quot; /&gt; to set &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt; to &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en <see langword="true" />; es <see langword="false" /> para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en <see langword="false" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.NotEqual&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the inequality operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> es <see langword="null" /> y no hay ningún operador de desigualdad definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Returns the expression representing the ones complement.">Devuelve la expresión que representa el complemento a unos.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Una clase <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <returns vsli:raw="An instance of &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt;.">Instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Returns the expression representing the ones complement.">Devuelve la expresión que representa el complemento a unos.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Una clase <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the implementing method.">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
      <returns vsli:raw="An instance of &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt;.">Instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise &lt;see langword=&quot;OR&quot; /&gt; operation.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación <see langword="OR" /> bit a bit.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Or&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The bitwise &lt;see langword=&quot;OR&quot; /&gt; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">No hay ningún operador <see langword="OR" /> bit a bit definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise &lt;see langword=&quot;OR&quot; /&gt; operation.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación <see langword="OR" /> bit a bit.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Or&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the bitwise &lt;see langword=&quot;OR&quot; /&gt; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> es <see langword="null" /> y el operador <see langword="OR" /> bit a bit no está definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise OR assignment operation.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación OR bit a bit.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.OrAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise OR assignment operation.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación OR bit a bit.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.OrAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise OR assignment operation.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación OR bit a bit.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.OrAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a conditional &lt;see langword=&quot;OR&quot; /&gt; operation that evaluates the second operand only if the first operand evaluates to &lt;see langword=&quot;false&quot; /&gt;.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación <see langword="OR" /> condicional que evalúa el segundo operando únicamente si el primer operando se evalúa como <see langword="false" />.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.OrElse&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The bitwise &lt;see langword=&quot;OR&quot; /&gt; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type are not the same Boolean type.">No hay ningún operador <see langword="OR" /> bit a bit definido para <paramref name="left" />.Type y <paramref name="right" />.Type.  
O bien 
 <paramref name="left" />.Type y <paramref name="right" />.Type no son del mismo tipo booleano.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a conditional &lt;see langword=&quot;OR&quot; /&gt; operation that evaluates the second operand only if the first operand evaluates to &lt;see langword=&quot;false&quot; /&gt;.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación <see langword="OR" /> condicional que evalúa el segundo operando únicamente si el primer operando se evalúa como <see langword="false" />.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.OrElse&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the bitwise &lt;see langword=&quot;OR&quot; /&gt; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type are not the same Boolean type.">
        <paramref name="method" /> es <see langword="null" /> y el operador <see langword="OR" /> bit a bit no está definido para <paramref name="left" />.Type y <paramref name="right" />.Type.  
O bien 
 <paramref name="method" /> es <see langword="null" /> y <paramref name="left" />.Type y <paramref name="right" />.Type no son del mismo tipo booleano.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Parameter(System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; node that can be used to identify a parameter or a variable in an expression tree.">Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> que puede usarse para identificar un parámetro o una variable en un árbol de expresión.</summary>
      <param name="type" vsli:raw="The type of the parameter or variable.">Tipo del parámetro o variable.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; node with the specified name and type.">Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> con el nombre y el tipo especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Parameter(System.Type,System.String)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; node that can be used to identify a parameter or a variable in an expression tree.">Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> que puede usarse para identificar un parámetro o una variable en un árbol de expresión.</summary>
      <param name="type" vsli:raw="The type of the parameter or variable.">Tipo del parámetro o variable.</param>
      <param name="name" vsli:raw="The name of the parameter or variable, used for debugging or printing purpose only.">Nombre del parámetro o variable; se emplea solo para depurar o imprimir.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Parameter&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.ParameterExpression.Name&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.ParameterExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Parameter" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.Expression.Type" /> y <see cref="P:System.Linq.Expressions.ParameterExpression.Name" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;type&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="type" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the assignment of the expression followed by a subsequent decrement by 1 of the original expression.">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la asignación de la expresión seguida de una disminución subsiguiente de 1 de la expresión original.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to apply the operations on.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se van a aplicar las operaciones.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the resultant expression.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the assignment of the expression followed by a subsequent decrement by 1 of the original expression.">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la asignación de la expresión seguida de una disminución subsiguiente de 1 de la expresión original.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to apply the operations on.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se van a aplicar las operaciones.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the implementing method.">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the resultant expression.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the assignment of the expression followed by a subsequent increment by 1 of the original expression.">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la asignación de la expresión seguida de un incremento subsiguiente de 1 de la expresión original.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to apply the operations on.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se van a aplicar las operaciones.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the resultant expression.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the assignment of the expression followed by a subsequent increment by 1 of the original expression.">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la asignación de la expresión seguida de un incremento subsiguiente de 1 de la expresión original.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to apply the operations on.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se van a aplicar las operaciones.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the implementing method.">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the resultant expression.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents raising a number to a power.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa la elevación de un número a una potencia.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Power&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The exponentiation operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;left&quot; /&gt;.Type and/or &lt;paramref name=&quot;right&quot; /&gt;.Type are not &lt;see cref=&quot;T:System.Double&quot; /&gt;.">No hay ningún operador de exponenciación definido para <paramref name="left" />.Type y <paramref name="right" />.Type.  
O bien 
 <paramref name="left" />.Type y/o <paramref name="right" />.Type no son <see cref="T:System.Double" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents raising a number to a power.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa la elevación de un número a una potencia.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Power&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the exponentiation operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and &lt;paramref name=&quot;left&quot; /&gt;.Type and/or &lt;paramref name=&quot;right&quot; /&gt;.Type are not &lt;see cref=&quot;T:System.Double&quot; /&gt;.">
        <paramref name="method" /> es <see langword="null" /> y el operador de exponenciación no está definido para <paramref name="left" />.Type y <paramref name="right" />.Type.  
O bien 
 <paramref name="method" /> es <see langword="null" /> y <paramref name="left" />.Type o <paramref name="right" />.Type no son <see cref="T:System.Double" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents raising an expression to a power and assigning the result back to the expression.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa la elevación de una expresión a una potencia y la asignación del resultado a dicha expresión.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.PowerAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents raising an expression to a power and assigning the result back to the expression.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa la elevación de una expresión a una potencia y la asignación del resultado a dicha expresión.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.PowerAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents raising an expression to a power and assigning the result back to the expression.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa la elevación de una expresión a una potencia y la asignación del resultado a dicha expresión.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.PowerAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that decrements the expression by 1 and assigns the result back to the expression.">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que disminuye la expresión en 1 y asigna el resultado a la expresión.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to apply the operations on.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se van a aplicar las operaciones.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the resultant expression.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that decrements the expression by 1 and assigns the result back to the expression.">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que disminuye la expresión en 1 y asigna el resultado a la expresión.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to apply the operations on.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se van a aplicar las operaciones.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the implementing method.">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the resultant expression.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that increments the expression by 1 and assigns the result back to the expression.">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que aumenta la expresión en 1 y asigna el resultado a la expresión.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to apply the operations on.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se van a aplicar las operaciones.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the resultant expression.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that increments the expression by 1 and assigns the result back to the expression.">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que aumenta la expresión en 1 y asigna el resultado a la expresión.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to apply the operations on.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se van a aplicar las operaciones.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the implementing method.">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the resultant expression.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt; that represents accessing a property by using a property accessor method.">Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a una propiedad mediante un método de descriptor de acceso de propiedad.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Expression&quot; /&gt; property equal to. This can be null for static properties.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />. Puede ser null para las propiedades estáticas.</param>
      <param name="propertyAccessor" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents a property accessor method.">Objeto <see cref="T:System.Reflection.MethodInfo" /> que representa un método de descriptor de acceso de propiedad.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.MemberAccess&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Expression&quot; /&gt; property set to &lt;paramref name=&quot;expression&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Member&quot; /&gt; property set to the &lt;see cref=&quot;T:System.Reflection.PropertyInfo&quot; /&gt; that represents the property accessed in &lt;paramref name=&quot;propertyAccessor&quot; /&gt;.">
        <see cref="T:System.Linq.Expressions.MemberExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> se establece en <paramref name="expression" /> y cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> se establece en el objeto <see cref="T:System.Reflection.PropertyInfo" /> que representa la propiedad a la que se obtiene acceso en <paramref name="propertyAccessor" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;propertyAccessor&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The method that &lt;paramref name=&quot;propertyAccessor&quot; /&gt; represents is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic) and &lt;paramref name=&quot;expression&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="propertyAccessor" /> es <see langword="null" />.  
o bien 
El método que <paramref name="propertyAccessor" /> representa no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) y el valor de <paramref name="expression" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt;.Type is not assignable to the declaring type of the method represented by &lt;paramref name=&quot;propertyAccessor&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The method that &lt;paramref name=&quot;propertyAccessor&quot; /&gt; represents is not a property accessor method.">
        <paramref name="expression" />.Type no se puede asignar al tipo declarativo del método representado por <paramref name="propertyAccessor" />.  
O bien 
El método que <paramref name="propertyAccessor" /> representa no es un método de descriptor de acceso de propiedad.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt; that represents accessing a property.">Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a una propiedad.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Expression&quot; /&gt; property equal to. This can be null for static properties.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />. Puede ser null para las propiedades estáticas.</param>
      <param name="property" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.PropertyInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Member&quot; /&gt; property equal to.">Objeto <see cref="T:System.Reflection.PropertyInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Member" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.MemberAccess&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Expression&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Member&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.MemberExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> y <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;property&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The property that &lt;paramref name=&quot;property&quot; /&gt; represents is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic) and &lt;paramref name=&quot;expression&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="property" /> es <see langword="null" />.  
o bien 
La propiedad que <paramref name="property" /> representa no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) y el valor de <paramref name="expression" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt;.Type is not assignable to the declaring type of the property that &lt;paramref name=&quot;property&quot; /&gt; represents.">
        <paramref name="expression" />.Type no se puede asignar al tipo declarativo de la propiedad que <paramref name="property" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Linq.Expressions.IndexExpression&quot; /&gt; representing the access to an indexed property.">Crea un objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> que representa el acceso a una propiedad indizada.</summary>
      <param name="instance" vsli:raw="The object to which the property belongs. If the property is static/shared, it must be null.">Objeto al que pertenece la propiedad. Si la propiedad es estática o compartida, deberá ser null.</param>
      <param name="indexer" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.PropertyInfo&quot; /&gt; that represents the property to index.">
        <see cref="T:System.Reflection.PropertyInfo" /> que representa la propiedad que se va a indexar.</param>
      <param name="arguments" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects that are used to index the property.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se usan para indexar la propiedad.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.IndexExpression&quot; /&gt;.">Objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Linq.Expressions.IndexExpression&quot; /&gt; representing the access to an indexed property.">Crea un objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> que representa el acceso a una propiedad indizada.</summary>
      <param name="instance" vsli:raw="The object to which the property belongs. If the property is static/shared, it must be null.">Objeto al que pertenece la propiedad. Si la propiedad es estática o compartida, deberá ser null.</param>
      <param name="indexer" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.PropertyInfo&quot; /&gt; that represents the property to index.">
        <see cref="T:System.Reflection.PropertyInfo" /> que representa la propiedad que se va a indexar.</param>
      <param name="arguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects that are used to index the property.">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se emplean para indizar la propiedad.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.IndexExpression&quot; /&gt;.">Objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt; that represents accessing a property.">Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a una propiedad.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; whose &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; contains a property named &lt;paramref name=&quot;propertyName&quot; /&gt;. This can be &lt;see langword=&quot;null&quot; /&gt; for static properties.">
        <see cref="T:System.Linq.Expressions.Expression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> contiene una propiedad denominada <paramref name="propertyName" />. Puede ser <see langword="null" /> para las propiedades estáticas.</param>
      <param name="propertyName" vsli:raw="The name of a property to be accessed.">Nombre de una propiedad a la que se va a obtener acceso.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.MemberAccess&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Expression&quot; /&gt; property set to &lt;paramref name=&quot;expression&quot; /&gt;, and the &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Member&quot; /&gt; property set to the &lt;see cref=&quot;T:System.Reflection.PropertyInfo&quot; /&gt; that represents the property denoted by &lt;paramref name=&quot;propertyName&quot; /&gt;.">
        <see cref="T:System.Linq.Expressions.MemberExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> se establece en <paramref name="expression" /> y cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> se establece en <see cref="T:System.Reflection.PropertyInfo" /> que representa la propiedad denotada por <paramref name="propertyName" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; or &lt;paramref name=&quot;propertyName&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> o <paramref name="propertyName" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="No property named &lt;paramref name=&quot;propertyName&quot; /&gt; is defined in &lt;paramref name=&quot;expression&quot; /&gt;.Type or its base types.">No se ha definido ninguna propiedad denominada <paramref name="propertyName" /> en <paramref name="expression" />.Type o sus tipos base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Linq.Expressions.IndexExpression&quot; /&gt; representing the access to an indexed property.">Crea un objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> que representa el acceso a una propiedad indizada.</summary>
      <param name="instance" vsli:raw="The object to which the property belongs. If the property is static/shared, it must be null.">Objeto al que pertenece la propiedad. Si la propiedad es estática o compartida, deberá ser null.</param>
      <param name="propertyName" vsli:raw="The name of the indexer.">Nombre del indizador.</param>
      <param name="arguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects that are used to index the property.">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se emplean para indizar la propiedad.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.IndexExpression&quot; /&gt;.">Objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Type,System.String)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt; accessing a property.">Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que obtiene acceso a una propiedad.</summary>
      <param name="expression" vsli:raw="The containing object of the property. This can be null for static properties.">Objeto contenedor de la propiedad. Puede ser null para las propiedades estáticas.</param>
      <param name="type" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; that contains the property.">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> que contiene la propiedad.</param>
      <param name="propertyName" vsli:raw="The property to be accessed.">Propiedad a la que se va a obtener acceso.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt;.">Objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PropertyOrField(System.Linq.Expressions.Expression,System.String)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt; that represents accessing a property or field.">Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a una propiedad o un campo.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; whose &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; contains a property or field named &lt;paramref name=&quot;propertyOrFieldName&quot; /&gt;.">
        <see cref="T:System.Linq.Expressions.Expression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> contiene una propiedad o un campo denominado <paramref name="propertyOrFieldName" />. Puede ser null para los miembros estáticos.</param>
      <param name="propertyOrFieldName" vsli:raw="The name of a property or field to be accessed.">Nombre de una propiedad o un campo al que se va a obtener acceso.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.MemberAccess&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Expression&quot; /&gt; property set to &lt;paramref name=&quot;expression&quot; /&gt;, and the &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Member&quot; /&gt; property set to the &lt;see cref=&quot;T:System.Reflection.PropertyInfo&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.FieldInfo&quot; /&gt; that represents the property or field denoted by &lt;paramref name=&quot;propertyOrFieldName&quot; /&gt;.">
        <see cref="T:System.Linq.Expressions.MemberExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> se establece en <paramref name="expression" /> y cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> se establece en el objeto <see cref="T:System.Reflection.PropertyInfo" /> o <see cref="T:System.Reflection.FieldInfo" /> que representa la propiedad o el campo denotados por <paramref name="propertyOrFieldName" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; or &lt;paramref name=&quot;propertyOrFieldName&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> o <paramref name="propertyOrFieldName" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="No property or field named &lt;paramref name=&quot;propertyOrFieldName&quot; /&gt; is defined in &lt;paramref name=&quot;expression&quot; /&gt;.Type or its base types.">No se ha definido ninguna propiedad o ningún campo denominado <paramref name="propertyOrFieldName" /> en <paramref name="expression" />.Type o sus tipos base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Quote(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents an expression that has a constant value of type &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una expresión que tiene un valor constante de tipo <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Quote&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property set to the specified value.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> y cuya propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> se establece en el valor especificado.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Reduce">
      <summary vsli:raw="Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.">Reduce este nodo a una expresión más simple. Si CanReduce devuelve true, debería devolver una expresión válida. Este método puede devolver otro nodo que se debe reducir a su vez.</summary>
      <returns vsli:raw="The reduced expression.">Expresión reducida.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReduceAndCheck">
      <summary vsli:raw="Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.">Reduce este nodo a una expresión más simple. Si CanReduce devuelve true, debería devolver una expresión válida. Este método puede devolver otro nodo que se debe reducir a su vez.</summary>
      <returns vsli:raw="The reduced expression.">Expresión reducida.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReduceExtensions">
      <summary vsli:raw="Reduces the expression to a known node type (that is not an Extension node) or just returns the expression if it is already a known type.">Reduce la expresión a un tipo de nodo conocido (no es un nodo de extensión) o, si ya es un tipo conocido, solo devuelve la expresión.</summary>
      <returns vsli:raw="The reduced expression.">Expresión reducida.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReferenceEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a reference equality comparison.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación de igualdad de referencia.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Equal&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReferenceNotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a reference inequality comparison.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación de desigualdad de referencia.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.NotEqual&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Rethrow">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents a rethrowing of an exception.">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa un reinicio de una excepción.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents a rethrowing of an exception.">Objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa un reinicio de una excepción.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Rethrow(System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents a rethrowing of an exception with a given type.">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa el reinicio de una excepción con un tipo dado.</summary>
      <param name="type" vsli:raw="The new &lt;see cref=&quot;T:System.Type&quot; /&gt; of the expression.">Nuevo objeto <see cref="T:System.Type" /> de la expresión.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents a rethrowing of an exception.">Objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa un reinicio de una excepción.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; representing a return statement.">Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Return.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; will jump to.">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; with &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Kind&quot; /&gt; equal to Return, the &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Target&quot; /&gt; property set to &lt;paramref name=&quot;target&quot; /&gt;, and a null value to be passed to the target label upon jumping.">
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Return, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" /> y un valor null que se pasará a la etiqueta de destino al saltar.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; representing a return statement. The value passed to the label upon jumping can be specified.">Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Return. Se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; will jump to.">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value" vsli:raw="The value that will be passed to the associated label upon jumping.">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; with &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Kind&quot; /&gt; equal to Continue, the &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Target&quot; /&gt; property set to &lt;paramref name=&quot;target&quot; /&gt;, and &lt;paramref name=&quot;value&quot; /&gt; to be passed to the target label upon jumping.">
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Continue, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" /> y un <paramref name="value" /> que se va a pasar a la etiqueta de destino cuando se produzca el salto.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; representing a return statement with the specified type. The value passed to the label upon jumping can be specified.">Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Return con el tipo especificado. Se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; will jump to.">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value" vsli:raw="The value that will be passed to the associated label upon jumping.">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</param>
      <param name="type" vsli:raw="An &lt;see cref=&quot;T:System.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property equal to.">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; with &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Kind&quot; /&gt; equal to Continue, the &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Target&quot; /&gt; property set to &lt;paramref name=&quot;target&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property set to &lt;paramref name=&quot;type&quot; /&gt;, and &lt;paramref name=&quot;value&quot; /&gt; to be passed to the target label upon jumping.">
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Continue, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" />, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y un <paramref name="value" /> que se pasará a la etiqueta de destino al saltar.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; representing a return statement with the specified type.">Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Return con el tipo especificado.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; will jump to.">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="type" vsli:raw="An &lt;see cref=&quot;T:System.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property equal to.">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; with &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Kind&quot; /&gt; equal to Return, the &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Target&quot; /&gt; property set to &lt;paramref name=&quot;target&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property set to &lt;paramref name=&quot;type&quot; /&gt;, and a null value to be passed to the target label upon jumping.">
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Return, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" />, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y un valor null que se pasará a la etiqueta de destino al saltar.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise right-shift operation.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de desplazamiento a la derecha bit a bit.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.RightShift&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The right-shift operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">No hay ningún operador de desplazamiento a la derecha definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise right-shift operation.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de desplazamiento a la derecha bit a bit.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.RightShift&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the right-shift operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> es <see langword="null" /> y no hay ningún operador de desplazamiento a la derecha definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise right-shift assignment operation.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de desplazamiento a la derecha bit a bit.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.RightShiftAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise right-shift assignment operation.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de desplazamiento a la derecha bit a bit.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.RightShiftAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise right-shift assignment operation.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de desplazamiento a la derecha bit a bit.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.RightShiftAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary vsli:raw="Creates an instance of &lt;see cref=&quot;T:System.Linq.Expressions.RuntimeVariablesExpression&quot; /&gt;.">Crea una instancia de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <param name="variables" vsli:raw="A collection of &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.RuntimeVariablesExpression.Variables&quot; /&gt; collection.">Colección de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />.</param>
      <returns vsli:raw="An instance of &lt;see cref=&quot;T:System.Linq.Expressions.RuntimeVariablesExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.RuntimeVariables&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.RuntimeVariablesExpression.Variables&quot; /&gt; property set to the specified value.">Instancia de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> y cuya propiedad <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> está establecida en el valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Linq.Expressions.ParameterExpression[])">
      <summary vsli:raw="Creates an instance of &lt;see cref=&quot;T:System.Linq.Expressions.RuntimeVariablesExpression&quot; /&gt;.">Crea una instancia de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <param name="variables" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.RuntimeVariablesExpression.Variables&quot; /&gt; collection.">Matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />.</param>
      <returns vsli:raw="An instance of &lt;see cref=&quot;T:System.Linq.Expressions.RuntimeVariablesExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.RuntimeVariables&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.RuntimeVariablesExpression.Variables&quot; /&gt; property set to the specified value.">Instancia de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> y cuya propiedad <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> está establecida en el valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an arithmetic subtraction operation that does not have overflow checking.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de sustracción aritmética que no tiene comprobación de desbordamiento.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Subtract&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The subtraction operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">No hay ningún operador de resta definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an arithmetic subtraction operation that does not have overflow checking.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de sustracción aritmética que no tiene comprobación de desbordamiento.</summary>
      <param name="left" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Subtract&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the subtraction operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> es <see langword="null" /> y el operador de resta no está definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a subtraction assignment operation that does not have overflow checking.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de sustracción que no tiene comprobación de desbordamiento.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.SubtractAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a subtraction assignment operation that does not have overflow checking.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de sustracción que no tiene comprobación de desbordamiento.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.SubtractAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a subtraction assignment operation that does not have overflow checking.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de sustracción que no tiene comprobación de desbordamiento.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.SubtractAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a subtraction assignment operation that has overflow checking.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de sustracción que tiene comprobación de desbordamiento.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a subtraction assignment operation that has overflow checking.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de sustracción que tiene comprobación de desbordamiento.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a subtraction assignment operation that has overflow checking.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de sustracción que tiene comprobación de desbordamiento.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an arithmetic subtraction operation that has overflow checking.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de sustracción aritmética que tiene comprobación de desbordamiento.</summary>
      <param name="left" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.SubtractChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The subtraction operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">No hay ningún operador de resta definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an arithmetic subtraction operation that has overflow checking.">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de sustracción aritmética que tiene comprobación de desbordamiento.</summary>
      <param name="left" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.SubtractChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the subtraction operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> es <see langword="null" /> y el operador de resta no está definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.SwitchExpression&quot; /&gt; that represents a &lt;see langword=&quot;switch&quot; /&gt; statement that has a default case.">Crea una clase <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa una instrucción <see langword="switch" /> que tiene un caso predeterminado.</summary>
      <param name="switchValue" vsli:raw="The value to be tested against each case.">Valor que se va a probar con respecto a cada caso.</param>
      <param name="defaultBody" vsli:raw="The result of the switch if &lt;paramref name=&quot;switchValue&quot; /&gt; does not match any of the cases.">Resultado del modificador si <paramref name="switchValue" /> no coincide con ninguno de los casos.</param>
      <param name="cases" vsli:raw="The set of cases for this switch expression.">Conjunto de casos para esta expresión switch.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.SwitchExpression&quot; /&gt;.">Objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.SwitchExpression&quot; /&gt; that represents a &lt;see langword=&quot;switch&quot; /&gt; statement that has a default case.">Crea una clase <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa una instrucción <see langword="switch" /> que tiene un caso predeterminado.</summary>
      <param name="switchValue" vsli:raw="The value to be tested against each case.">Valor que se va a probar con respecto a cada caso.</param>
      <param name="defaultBody" vsli:raw="The result of the switch if &lt;paramref name=&quot;switchValue&quot; /&gt; does not match any of the cases.">Resultado del modificador si <paramref name="switchValue" /> no coincide con ninguno de los casos.</param>
      <param name="comparison" vsli:raw="The equality comparison method to use.">Método de comparación de igualdad que se va a usar.</param>
      <param name="cases" vsli:raw="The set of cases for this switch expression.">Conjunto de casos para esta expresión switch.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.SwitchExpression&quot; /&gt;.">Objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.SwitchExpression&quot; /&gt; that represents a &lt;see langword=&quot;switch&quot; /&gt; statement that has a default case.">Crea una clase <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa una instrucción <see langword="switch" /> que tiene un caso predeterminado.</summary>
      <param name="switchValue" vsli:raw="The value to be tested against each case.">Valor que se va a probar con respecto a cada caso.</param>
      <param name="defaultBody" vsli:raw="The result of the switch if &lt;paramref name=&quot;switchValue&quot; /&gt; does not match any of the cases.">Resultado del modificador si <paramref name="switchValue" /> no coincide con ninguno de los casos.</param>
      <param name="comparison" vsli:raw="The equality comparison method to use.">Método de comparación de igualdad que se va a usar.</param>
      <param name="cases" vsli:raw="The set of cases for this switch expression.">Conjunto de casos para esta expresión switch.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.SwitchExpression&quot; /&gt;.">Objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.SwitchExpression&quot; /&gt; that represents a &lt;see langword=&quot;switch&quot; /&gt; statement without a default case.">Crea un objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa una instrucción <see langword="switch" /> sin un caso predeterminado.</summary>
      <param name="switchValue" vsli:raw="The value to be tested against each case.">Valor que se va a probar con respecto a cada caso.</param>
      <param name="cases" vsli:raw="The set of cases for this switch expression.">Conjunto de casos para esta expresión switch.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.SwitchExpression&quot; /&gt;.">Objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.SwitchExpression&quot; /&gt; that represents a &lt;see langword=&quot;switch&quot; /&gt; statement that has a default case.">Crea una clase <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa una instrucción <see langword="switch" /> que tiene un caso predeterminado.</summary>
      <param name="type" vsli:raw="The result type of the switch.">Tipo de resultado del modificador.</param>
      <param name="switchValue" vsli:raw="The value to be tested against each case.">Valor que se va a probar con respecto a cada caso.</param>
      <param name="defaultBody" vsli:raw="The result of the switch if &lt;paramref name=&quot;switchValue&quot; /&gt; does not match any of the cases.">Resultado del modificador si <paramref name="switchValue" /> no coincide con ninguno de los casos.</param>
      <param name="comparison" vsli:raw="The equality comparison method to use.">Método de comparación de igualdad que se va a usar.</param>
      <param name="cases" vsli:raw="The set of cases for this switch expression.">Conjunto de casos para esta expresión switch.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.SwitchExpression&quot; /&gt;.">Objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.SwitchExpression&quot; /&gt; that represents a &lt;see langword=&quot;switch&quot; /&gt; statement that has a default case.">Crea una clase <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa una instrucción <see langword="switch" /> que tiene un caso predeterminado.</summary>
      <param name="type" vsli:raw="The result type of the switch.">Tipo de resultado del modificador.</param>
      <param name="switchValue" vsli:raw="The value to be tested against each case.">Valor que se va a probar con respecto a cada caso.</param>
      <param name="defaultBody" vsli:raw="The result of the switch if &lt;paramref name=&quot;switchValue&quot; /&gt; does not match any of the cases.">Resultado del modificador si <paramref name="switchValue" /> no coincide con ninguno de los casos.</param>
      <param name="comparison" vsli:raw="The equality comparison method to use.">Método de comparación de igualdad que se va a usar.</param>
      <param name="cases" vsli:raw="The set of cases for this switch expression.">Conjunto de casos para esta expresión switch.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.SwitchExpression&quot; /&gt;.">Objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.SwitchCase&quot; /&gt; object to be used in a &lt;see cref=&quot;T:System.Linq.Expressions.SwitchExpression&quot; /&gt; object.">Crea un objeto <see cref="T:System.Linq.Expressions.SwitchCase" /> que se va a usar en un objeto <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <param name="body" vsli:raw="The body of the case.">Cuerpo del caso.</param>
      <param name="testValues" vsli:raw="The test values of the case.">Valores de prueba del caso.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.SwitchCase&quot; /&gt;.">Objeto <see cref="T:System.Linq.Expressions.SwitchCase" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.SwitchCase&quot; /&gt; for use in a &lt;see cref=&quot;T:System.Linq.Expressions.SwitchExpression&quot; /&gt;.">Crea un objeto <see cref="T:System.Linq.Expressions.SwitchCase" /> que se va a usar en un objeto <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <param name="body" vsli:raw="The body of the case.">Cuerpo del caso.</param>
      <param name="testValues" vsli:raw="The test values of the case.">Valores de prueba del caso.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.SwitchCase&quot; /&gt;.">Objeto <see cref="T:System.Linq.Expressions.SwitchCase" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String)">
      <summary vsli:raw="Creates an instance of &lt;see cref=&quot;T:System.Linq.Expressions.SymbolDocumentInfo&quot; /&gt;.">Crea una instancia de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <param name="fileName" vsli:raw="A &lt;see cref=&quot;T:System.String&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.FileName&quot; /&gt; equal to.">
        <see cref="T:System.String" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.SymbolDocumentInfo&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.FileName&quot; /&gt; property set to the specified value.">Objeto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que tiene la propiedad <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> establecida en el valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid)">
      <summary vsli:raw="Creates an instance of &lt;see cref=&quot;T:System.Linq.Expressions.SymbolDocumentInfo&quot; /&gt;.">Crea una instancia de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <param name="fileName" vsli:raw="A &lt;see cref=&quot;T:System.String&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.FileName&quot; /&gt; equal to.">
        <see cref="T:System.String" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
      <param name="language" vsli:raw="A &lt;see cref=&quot;T:System.Guid&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.Language&quot; /&gt; equal to.">
        <see cref="T:System.Guid" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.SymbolDocumentInfo&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.FileName&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.Language&quot; /&gt; properties set to the specified value.">Objeto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> cuyas propiedades <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> y <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> están establecidas en el valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid)">
      <summary vsli:raw="Creates an instance of &lt;see cref=&quot;T:System.Linq.Expressions.SymbolDocumentInfo&quot; /&gt;.">Crea una instancia de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <param name="fileName" vsli:raw="A &lt;see cref=&quot;T:System.String&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.FileName&quot; /&gt; equal to.">
        <see cref="T:System.String" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
      <param name="language" vsli:raw="A &lt;see cref=&quot;T:System.Guid&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.Language&quot; /&gt; equal to.">
        <see cref="T:System.Guid" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />.</param>
      <param name="languageVendor" vsli:raw="A &lt;see cref=&quot;T:System.Guid&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor&quot; /&gt; equal to.">
        <see cref="T:System.Guid" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.SymbolDocumentInfo&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.FileName&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.Language&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor&quot; /&gt; properties set to the specified value.">Objeto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que tiene las propiedades <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> y <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> establecidas en el valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid,System.Guid)">
      <summary vsli:raw="Creates an instance of &lt;see cref=&quot;T:System.Linq.Expressions.SymbolDocumentInfo&quot; /&gt;.">Crea una instancia de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <param name="fileName" vsli:raw="A &lt;see cref=&quot;T:System.String&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.FileName&quot; /&gt; equal to.">
        <see cref="T:System.String" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
      <param name="language" vsli:raw="A &lt;see cref=&quot;T:System.Guid&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.Language&quot; /&gt; equal to.">
        <see cref="T:System.Guid" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />.</param>
      <param name="languageVendor" vsli:raw="A &lt;see cref=&quot;T:System.Guid&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor&quot; /&gt; equal to.">
        <see cref="T:System.Guid" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />.</param>
      <param name="documentType" vsli:raw="A &lt;see cref=&quot;T:System.Guid&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType&quot; /&gt; equal to.">
        <see cref="T:System.Guid" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.SymbolDocumentInfo&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.FileName&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.Language&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType&quot; /&gt; properties set to the specified value.">Objeto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> cuyas propiedades <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> y <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> están establecidas en el valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents a throwing of an exception.">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa un inicio de una excepción.</summary>
      <param name="value" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Una clase <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the exception.">Objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la excepción.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents a throwing of an exception with a given type.">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa un inicio de una excepción con un tipo especificado.</summary>
      <param name="value" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Una clase <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="type" vsli:raw="The new &lt;see cref=&quot;T:System.Type&quot; /&gt; of the expression.">Nuevo objeto <see cref="T:System.Type" /> de la expresión.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the exception.">Objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la excepción.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ToString">
      <summary vsli:raw="Returns a textual representation of the &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Devuelve una representación textual de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns vsli:raw="A textual representation of the &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Representación textual de <see cref="T:System.Linq.Expressions.Expression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryCatch(System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.TryExpression&quot; /&gt; representing a try block with any number of catch statements and neither a fault nor finally block.">Crea un objeto <see cref="T:System.Linq.Expressions.TryExpression" /> que representa un bloque try con cualquier número de instrucciones Catch y ningún bloque fault ni finally.</summary>
      <param name="body" vsli:raw="The body of the try block.">Cuerpo del bloque try.</param>
      <param name="handlers" vsli:raw="The array of zero or more &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt; expressions representing the catch statements to be associated with the try block.">Matriz de cero o más expresiones <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa las instrucciones Catch que se van a asociar al bloque try.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.TryExpression&quot; /&gt;.">Objeto <see cref="T:System.Linq.Expressions.TryExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryCatchFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.TryExpression&quot; /&gt; representing a try block with any number of catch statements and a finally block.">Crea un objeto <see cref="T:System.Linq.Expressions.TryExpression" /> que representa un bloque try con cualquier número de instrucciones Catch y un bloque finally.</summary>
      <param name="body" vsli:raw="The body of the try block.">Cuerpo del bloque try.</param>
      <param name="finally" vsli:raw="The body of the finally block.">Cuerpo del bloque finally.</param>
      <param name="handlers" vsli:raw="The array of zero or more &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt; expressions representing the catch statements to be associated with the try block.">Matriz de cero o más expresiones <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa las instrucciones Catch que se van a asociar al bloque try.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.TryExpression&quot; /&gt;.">Objeto <see cref="T:System.Linq.Expressions.TryExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryFault(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.TryExpression&quot; /&gt; representing a try block with a fault block and no catch statements.">Crea un objeto <see cref="T:System.Linq.Expressions.TryExpression" /> que representa un bloque try con un bloque fault y ninguna instrucción Catch.</summary>
      <param name="body" vsli:raw="The body of the try block.">Cuerpo del bloque try.</param>
      <param name="fault" vsli:raw="The body of the fault block.">Cuerpo del bloque fault.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.TryExpression&quot; /&gt;.">Objeto <see cref="T:System.Linq.Expressions.TryExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.TryExpression&quot; /&gt; representing a try block with a finally block and no catch statements.">Crea un objeto <see cref="T:System.Linq.Expressions.TryExpression" /> que representa un bloque try con un bloque finally y ninguna instrucción Catch.</summary>
      <param name="body" vsli:raw="The body of the try block.">Cuerpo del bloque try.</param>
      <param name="finally" vsli:raw="The body of the finally block.">Cuerpo del bloque finally.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.TryExpression&quot; /&gt;.">Objeto <see cref="T:System.Linq.Expressions.TryExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryGetActionType(System.Type[],System.Type@)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; object that represents a generic System.Action delegate type that has specific type arguments.">Crea un objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa un tipo de delegado System.Action genérico con argumentos de tipo concretos.</summary>
      <param name="typeArgs" vsli:raw="An array of Type objects that specify the type arguments for the System.Action delegate type.">Matriz de objetos Type que especifica los argumentos de tipo para el tipo de delegado System.Action.</param>
      <param name="actionType" vsli:raw="When this method returns, contains the generic System.Action delegate type that has specific type arguments. Contains null if there is no generic System.Action delegate that matches the &lt;paramref name=&quot;typeArgs&quot; /&gt;. This parameter is passed uninitialized.">Cuando este método devuelve el resultado, contiene el tipo de delegado genérico System.Action con argumentos de tipo concretos. Contiene null si no hay ningún delegado System.Action genérico que coincida con el objeto <paramref name="typeArgs" />. Este parámetro se pasa sin inicializar.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if generic System.Action delegate type was created for specific &lt;paramref name=&quot;typeArgs&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, si el tipo de delegado System.Action genérico se ha creado para un elemento <paramref name="typeArgs" /> específico; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryGetFuncType(System.Type[],System.Type@)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; object that represents a generic System.Func delegate type that has specific type arguments. The last type argument specifies the return type of the created delegate.">Crea un objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa un tipo de delegado System.Func genérico que tiene argumentos de tipo específicos. El último argumento de tipo especifica el tipo de valor devuelto del delegado creado.</summary>
      <param name="typeArgs" vsli:raw="An array of Type objects that specify the type arguments for the System.Func delegate type.">Matriz de objetos Type que especifica los argumentos de tipo para el tipo de delegado System.Func.</param>
      <param name="funcType" vsli:raw="When this method returns, contains the generic System.Func delegate type that has specific type arguments. Contains null if there is no generic System.Func delegate that matches the &lt;paramref name=&quot;typeArgs&quot; /&gt;. This parameter is passed uninitialized.">Cuando este método devuelve el resultado, contiene el tipo de delegado genérico System.Func con argumentos de tipo concretos. Contiene null si no hay ningún delegado System.Func genérico que coincida con el objeto <paramref name="typeArgs" />. Este parámetro se pasa sin inicializar.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if generic System.Func delegate type was created for specific &lt;paramref name=&quot;typeArgs&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, si el tipo de delegado System.Func genérico se ha creado para un elemento <paramref name="typeArgs" /> específico; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.Expression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; that represents the static type of the expression.">
        <see cref="T:System.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeAs(System.Linq.Expressions.Expression,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents an explicit reference or boxing conversion where &lt;see langword=&quot;null&quot; /&gt; is supplied if the conversion fails.">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una referencia explícita o conversión boxing donde se suministra <see langword="null" /> si se produce un error de conversión.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type" vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property equal to.">
        <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.TypeAs&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.TypeAs" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.Expression.Type" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; or &lt;paramref name=&quot;type&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> o <paramref name="type" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.TypeBinaryExpression&quot; /&gt; that compares run-time type identity.">Crea un objeto <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> que compara la identidad de tipo en tiempo de ejecución.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="type" vsli:raw="A &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand&quot; /&gt; property equal to.">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.TypeBinaryExpression&quot; /&gt; for which the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property is equal to &lt;see cref=&quot;M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)&quot; /&gt; and for which the &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand&quot; /&gt; properties are set to the specified values.">
        <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> para la que la propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" /> y para la que las propiedades <see cref="T:System.Linq.Expressions.Expression" /> y <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> están establecidas en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeIs(System.Linq.Expressions.Expression,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.TypeBinaryExpression&quot; /&gt;.">Crea una interfaz <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.TypeBinaryExpression.Expression&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" />.</param>
      <param name="type" vsli:raw="A &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand&quot; /&gt; property equal to.">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.TypeBinaryExpression&quot; /&gt; for which the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property is equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.TypeIs&quot; /&gt; and for which the &lt;see cref=&quot;P:System.Linq.Expressions.TypeBinaryExpression.Expression&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand&quot; /&gt; properties are set to the specified values.">
        <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> para la que la propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.TypeIs" /> y para la que las propiedades <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> y <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> están establecidas en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; or &lt;paramref name=&quot;type&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> o <paramref name="type" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents a unary plus operation.">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación unaria más.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.UnaryPlus&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property set to the specified value.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> y cuya propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> se establece en el valor especificado.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The unary plus operator is not defined for &lt;paramref name=&quot;expression&quot; /&gt;.Type.">No hay ningún operador unario más definido para <paramref name="expression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents a unary plus operation.">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación unaria más.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property equal to.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.UnaryPlus&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly one argument.">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente un argumento.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the unary plus operator is not defined for &lt;paramref name=&quot;expression&quot; /&gt;.Type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;expression&quot; /&gt;.Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by &lt;paramref name=&quot;method&quot; /&gt;.">
        <paramref name="method" /> es <see langword="null" /> y no hay ningún operador unario más definido para <paramref name="expression" />.Type.  
O bien 
 <paramref name="expression" />.Type (o su correspondiente tipo que no acepta valores null si se trata de un tipo de valor que acepta valores null) no puede asignarse al tipo de argumento del método representado por <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Unbox(System.Linq.Expressions.Expression,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents an explicit unboxing.">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una conversión unboxing explícita.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to unbox.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> al que se va a aplicar la conversión unboxing.</param>
      <param name="type" vsli:raw="The new &lt;see cref=&quot;T:System.Type&quot; /&gt; of the expression.">Nuevo objeto <see cref="T:System.Type" /> de la expresión.</param>
      <returns vsli:raw="An instance of &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt;.">Instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Variable(System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; node that can be used to identify a parameter or a variable in an expression tree.">Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> que puede usarse para identificar un parámetro o una variable en un árbol de expresión.</summary>
      <param name="type" vsli:raw="The type of the parameter or variable.">Tipo del parámetro o variable.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; node with the specified name and type.">Nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> con el nombre y tipo especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Variable(System.Type,System.String)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; node that can be used to identify a parameter or a variable in an expression tree.">Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> que puede usarse para identificar un parámetro o una variable en un árbol de expresión.</summary>
      <param name="type" vsli:raw="The type of the parameter or variable.">Tipo del parámetro o variable.</param>
      <param name="name" vsli:raw="The name of the parameter or variable. This name is used for debugging or printing purpose only.">Nombre del parámetro o la variable. Este nombre se emplea únicamente para depurar o imprimir.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; node with the specified name and type.">Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> con el nombre y el tipo especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.VisitChildren(System.Linq.Expressions.ExpressionVisitor)">
      <summary vsli:raw="Reduces the node and then calls the visitor delegate on the reduced expression. The method throws an exception if the node is not reducible.">Reduce el nodo y, a continuación, llama al delegado del visitante en la expresión reducida. El método inicia una excepción si el nodo no es reducible.</summary>
      <param name="visitor" vsli:raw="An instance of &lt;see cref=&quot;T:System.Func`2&quot; /&gt;.">Instancia de <see cref="T:System.Func`2" />.</param>
      <returns vsli:raw="The expression being visited, or an expression which should replace it in the tree.">Expresión que se está visitando o una expresión que debería sustituirla en el árbol.</returns>
    </member>
    <member name="T:System.Linq.Expressions.Expression`1">
      <summary vsli:raw="Represents a strongly typed lambda expression as a data structure in the form of an expression tree. This class cannot be inherited.">Representa una expresión lambda fuertemente tipada como una estructura de datos en el formato de árbol de expresión. Esta clase no puede heredarse.</summary>
      <typeparam name="TDelegate" vsli:raw="The type of the delegate that the &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt; represents.">Tipo de delegado que <see cref="T:System.Linq.Expressions.Expression`1" /> representa.</typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Compile">
      <summary vsli:raw="Compiles the lambda expression described by the expression tree into executable code and produces a delegate that represents the lambda expression.">Compila la expresión lambda descrita por el árbol de la expresión en el código ejecutable y genera un delegado que representa la expresión lambda.</summary>
      <returns vsli:raw="A delegate of type &lt;paramref name=&quot;TDelegate&quot; /&gt; that represents the compiled lambda expression described by the &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt;.">Un delegado de tipo <paramref name="TDelegate" /> que representa la expresión lambda compilada descrita por <see cref="T:System.Linq.Expressions.Expression`1" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Compile(System.Boolean)">
      <summary vsli:raw="Compiles the lambda expression described by the expression tree into interpreted or compiled code and produces a delegate that represents the lambda expression.">Compila la expresión lambda descrita por el árbol de expresión en el código interpretado o compilado y genera a un delegado que representa la expresión lambda.</summary>
      <param name="preferInterpretation" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to indicate that the expression should be compiled to an interpreted form, if it is available; &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" /> para indicar que la expresión se debe compilar en un formulario interpretado, si está disponible; <see langword="false" /> en caso contrario.</param>
      <returns vsli:raw="A delegate that represents the compiled lambda expression described by the &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt;.">Delegado que representa la expresión lambda compilada descrita por el elemento <see cref="T:System.Linq.Expressions.Expression`1" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Compile(System.Runtime.CompilerServices.DebugInfoGenerator)">
      <summary vsli:raw="Produces a delegate that represents the lambda expression.">Genera un delegado que representa la expresión lambda.</summary>
      <param name="debugInfoGenerator" vsli:raw="Debugging information generator used by the compiler to mark sequence points and annotate local variables.">Generador de información de depuración usado por el compilador para marcar puntos de secuencia y anotar variables locales.</param>
      <returns vsli:raw="A delegate containing the compiled version of the lambda.">Delegado que contiene la versión compilada del lambda.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="body" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property of the result.">La propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> del resultado.</param>
      <param name="parameters" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; property of the result.">La propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> del resultado.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ExpressionType">
      <summary vsli:raw="Describes the node types for the nodes of an expression tree.">Describe los tipos de nodo para los nodos de un árbol de expresión.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Add">
      <summary vsli:raw="An addition operation, such as &lt;c&gt;a + b&lt;/c&gt;, without overflow checking, for numeric operands.">Operación de suma, como <c>a + b</c>, sin comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddAssign">
      <summary vsli:raw="An addition compound assignment operation, such as &lt;c&gt;(a += b)&lt;/c&gt;, without overflow checking, for numeric operands.">Operación de asignación compuesta de suma, como <c>(a += b)</c>, sin comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddAssignChecked">
      <summary vsli:raw="An addition compound assignment operation, such as &lt;c&gt;(a += b)&lt;/c&gt;, with overflow checking, for numeric operands.">Operación de asignación compuesta de suma, como <c>(a += b)</c>, con comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddChecked">
      <summary vsli:raw="An addition operation, such as &lt;c&gt;(a + b)&lt;/c&gt;, with overflow checking, for numeric operands.">Operación de suma, como <c>(a + b)</c>, con comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.And">
      <summary vsli:raw="A bitwise or logical &lt;see langword=&quot;AND&quot; /&gt; operation, such as &lt;c&gt;(a &amp;amp; b)&lt;/c&gt; in C# and &lt;c&gt;(a And b)&lt;/c&gt; in Visual Basic.">Operación <see langword="AND" /> bit a bit o lógica, como <c>(a &amp; b)</c> en C# y <c>(a And b)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AndAlso">
      <summary vsli:raw="A conditional &lt;see langword=&quot;AND&quot; /&gt; operation that evaluates the second operand only if the first operand evaluates to &lt;see langword=&quot;true&quot; /&gt;. It corresponds to &lt;c&gt;(a &amp;amp;&amp;amp; b)&lt;/c&gt; in C# and &lt;c&gt;(a AndAlso b)&lt;/c&gt; in Visual Basic.">Representa una operación <see langword="AND" /> condicional que evalúa el segundo operando solo si el primer operando se evalúa como <see langword="true" />. Se corresponde con <c>(a &amp;&amp; b)</c> en C# y <c>(a AndAlso b)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AndAssign">
      <summary vsli:raw="A bitwise or logical &lt;see langword=&quot;AND&quot; /&gt; compound assignment operation, such as &lt;c&gt;(a &amp;amp;= b)&lt;/c&gt; in C#.">Operación de asignación compuesta <see langword="AND" /> bit a bit o lógica, como <c>(a &amp;= b)</c> en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ArrayIndex">
      <summary vsli:raw="An indexing operation in a one-dimensional array, such as &lt;c&gt;array[index]&lt;/c&gt; in C# or &lt;c&gt;array(index)&lt;/c&gt; in Visual Basic.">Representa una operación de indización en una matriz unidimensional, como <c>array[index]</c> en C# o <c>array(index)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ArrayLength">
      <summary vsli:raw="An operation that obtains the length of a one-dimensional array, such as &lt;c&gt;array.Length&lt;/c&gt;.">Operación que obtiene la longitud de una matriz unidimensional, como <c>array.Length</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Assign">
      <summary vsli:raw="An assignment operation, such as &lt;c&gt;(a = b)&lt;/c&gt;.">Operación de asignación, como <c>(a = b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Block">
      <summary vsli:raw="A block of expressions.">Representa un bloque de expresiones.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Call">
      <summary vsli:raw="A method call, such as in the &lt;c&gt;obj.sampleMethod()&lt;/c&gt; expression.">Una llamada de método, como en la expresión <c>obj.sampleMethod()</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Coalesce">
      <summary vsli:raw="A node that represents a null coalescing operation, such as &lt;c&gt;(a ?? b)&lt;/c&gt; in C# or &lt;c&gt;If(a, b)&lt;/c&gt; in Visual Basic.">Nodo que representa una operación de uso combinado de Null, como <c>(a ?? b)</c> en C# o <c>If(a, b)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Conditional">
      <summary vsli:raw="A conditional operation, such as &lt;c&gt;a &amp;gt; b ? a : b&lt;/c&gt; in C# or &lt;c&gt;If(a &amp;gt; b, a, b)&lt;/c&gt; in Visual Basic.">Una operación condicional, como <c>a &gt; b ? a : b</c> en C# o <c>If(a &gt; b, a, b)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Constant">
      <summary vsli:raw="A constant value.">Un valor constante.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Convert">
      <summary vsli:raw="A cast or conversion operation, such as &lt;c&gt;(SampleType)obj&lt;/c&gt; in C#or &lt;c&gt;CType(obj, SampleType)&lt;/c&gt; in Visual Basic. For a numeric conversion, if the converted value is too large for the destination type, no exception is thrown.">Una transmisión u operación de conversión, como <c>(SampleType)obj</c> en C# o <c>CType(obj, SampleType)</c> en Visual Basic. Para una conversión numérica, si el valor convertido es demasiado grande para el tipo de destino, no se produce ninguna excepción.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ConvertChecked">
      <summary vsli:raw="A cast or conversion operation, such as &lt;c&gt;(SampleType)obj&lt;/c&gt; in C#or &lt;c&gt;CType(obj, SampleType)&lt;/c&gt; in Visual Basic. For a numeric conversion, if the converted value does not fit the destination type, an exception is thrown.">Una transmisión u operación de conversión, como <c>(SampleType)obj</c> en C# o <c>CType(obj, SampleType)</c> en Visual Basic. En el caso de una conversión numérica, se produce una excepción si el valor convertido no se ajusta al tipo de destino.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.DebugInfo">
      <summary vsli:raw="Debugging information.">Información de depuración.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Decrement">
      <summary vsli:raw="A unary decrement operation, such as &lt;c&gt;(a - 1)&lt;/c&gt; in C# and Visual Basic. The object &lt;c&gt;a&lt;/c&gt; should not be modified in place.">Una operación de decremento unario, como <c>(a - 1)</c> en C# y Visual Basic. El objeto <c>a</c> no se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Default">
      <summary vsli:raw="A default value.">Un valor predeterminado.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Divide">
      <summary vsli:raw="A division operation, such as &lt;c&gt;(a / b)&lt;/c&gt;, for numeric operands.">Una operación de división, como <c>(a / b)</c>, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.DivideAssign">
      <summary vsli:raw="An division compound assignment operation, such as &lt;c&gt;(a /= b)&lt;/c&gt;, for numeric operands.">Una operación de asignación compuesta de división, como <c>(a /= b)</c>, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Dynamic">
      <summary vsli:raw="A dynamic operation.">Una operación dinámica.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Equal">
      <summary vsli:raw="A node that represents an equality comparison, such as &lt;c&gt;(a == b)&lt;/c&gt; in C# or &lt;c&gt;(a = b)&lt;/c&gt; in Visual Basic.">Un nodo que representa una comparación de igualdad, como <c>(a == b)</c> en C# o <c>(a = b)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ExclusiveOr">
      <summary vsli:raw="A bitwise or logical &lt;see langword=&quot;XOR&quot; /&gt; operation, such as &lt;c&gt;(a ^ b)&lt;/c&gt; in C# or &lt;c&gt;(a Xor b)&lt;/c&gt; in Visual Basic.">Una operación <see langword="XOR" /> bit a bit o lógica, como <c>(a ^ b)</c> en C# o <c>(a Xor b)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign">
      <summary vsli:raw="A bitwise or logical &lt;see langword=&quot;XOR&quot; /&gt; compound assignment operation, such as &lt;c&gt;(a ^= b)&lt;/c&gt; in C#.">Operación de asignación compuesta <see langword="XOR" /> bit a bit o lógica, como <c>(a ^= b)</c> en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Extension">
      <summary vsli:raw="An extension expression.">Una expresión de extensión.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Goto">
      <summary vsli:raw="A &quot;go to&quot; expression, such as &lt;c&gt;goto Label&lt;/c&gt; in C# or &lt;c&gt;GoTo Label&lt;/c&gt; in Visual Basic.">Una expresión "ir a", como la <c>goto Label</c> en C# o la <c>GoTo Label</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.GreaterThan">
      <summary vsli:raw="A &quot;greater than&quot; comparison, such as &lt;c&gt;(a &amp;gt; b)&lt;/c&gt;.">Una comparación "mayor que", como <c>(a &gt; b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual">
      <summary vsli:raw="A &quot;greater than or equal to&quot; comparison, such as &lt;c&gt;(a &amp;gt;= b)&lt;/c&gt;.">Una comparación "mayor o igual que", como <c>(a &gt;= b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Increment">
      <summary vsli:raw="A unary increment operation, such as &lt;c&gt;(a + 1)&lt;/c&gt; in C# and Visual Basic. The object &lt;c&gt;a&lt;/c&gt; should not be modified in place.">Una operación de incremento unario, como <c>(a + 1)</c> en C# y Visual Basic. El objeto <c>a</c> no se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Index">
      <summary vsli:raw="An index operation or an operation that accesses a property that takes arguments.">Una operación de índice u operación que tiene acceso a una propiedad que admite argumentos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Invoke">
      <summary vsli:raw="An operation that invokes a delegate or lambda expression, such as &lt;c&gt;sampleDelegate.Invoke()&lt;/c&gt;.">Una operación que invoca un delegado o una expresión lambda, como <c>sampleDelegate.Invoke()</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.IsFalse">
      <summary vsli:raw="A &lt;see langword=&quot;false&quot; /&gt; condition value.">Un valor de condición <see langword="false" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.IsTrue">
      <summary vsli:raw="A &lt;see langword=&quot;true&quot; /&gt; condition value.">Un valor de condición <see langword="true" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Label">
      <summary vsli:raw="A label.">Una etiqueta.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Lambda">
      <summary vsli:raw="A lambda expression, such as &lt;c&gt;a =&amp;gt; a + a&lt;/c&gt; in C# or &lt;c&gt;Function(a) a + a&lt;/c&gt; in Visual Basic.">Una expresión lambda, como <c>a =&gt; a + a</c> en C# o <c>Function(a) a + a</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LeftShift">
      <summary vsli:raw="A bitwise left-shift operation, such as &lt;c&gt;(a &amp;lt;&amp;lt; b)&lt;/c&gt;.">Una operación de desplazamiento a la izquierda bit a bit, como <c>(a &lt;&lt; b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign">
      <summary vsli:raw="A bitwise left-shift compound assignment, such as &lt;c&gt;(a &amp;lt;&amp;lt;= b)&lt;/c&gt;.">Una asignación compuesta y desplazamiento a la izquierda bit a bit, como <c>(a &lt;&lt;= b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LessThan">
      <summary vsli:raw="A &quot;less than&quot; comparison, such as &lt;c&gt;(a &amp;lt; b)&lt;/c&gt;.">Una comparación "menor que", como <c>(a &lt; b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual">
      <summary vsli:raw="A &quot;less than or equal to&quot; comparison, such as &lt;c&gt;(a &amp;lt;= b)&lt;/c&gt;.">Una comparación "menor o igual que", como <c>(a &lt;= b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ListInit">
      <summary vsli:raw="An operation that creates a new &lt;see cref=&quot;T:System.Collections.IEnumerable&quot; /&gt; object and initializes it from a list of elements, such as &lt;c&gt;new List&amp;lt;SampleType&amp;gt;(){ a, b, c }&lt;/c&gt; in C# or &lt;c&gt;Dim sampleList = { a, b, c }&lt;/c&gt; in Visual Basic.">Una operación que crea un nuevo objeto <see cref="T:System.Collections.IEnumerable" /> y lo inicializa desde una lista de elementos, como <c>new List&lt;SampleType&gt;(){ a, b, c }</c> en C# o <c>Dim sampleList = { a, b, c }</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Loop">
      <summary vsli:raw="A loop, such as &lt;c&gt;for&lt;/c&gt; or &lt;c&gt;while&lt;/c&gt;.">Un bucle, como <c>for</c> o <c>while</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MemberAccess">
      <summary vsli:raw="An operation that reads from a field or property, such as &lt;c&gt;obj.SampleProperty&lt;/c&gt;.">Una operación que realiza la lectura de un campo o una propiedad, como <c>obj.SampleProperty</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MemberInit">
      <summary vsli:raw="An operation that creates a new object and initializes one or more of its members, such as &lt;c&gt;new Point { X = 1, Y = 2 }&lt;/c&gt; in C# or &lt;c&gt;New Point With {.X = 1, .Y = 2}&lt;/c&gt; in Visual Basic.">Una operación que crea un nuevo objeto e inicializa uno o más de sus miembros, como <c>new Point { X = 1, Y = 2 }</c> en C# o <c>New Point With {.X = 1, .Y = 2}</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Modulo">
      <summary vsli:raw="An arithmetic remainder operation, such as &lt;c&gt;(a % b)&lt;/c&gt; in C# or &lt;c&gt;(a Mod b)&lt;/c&gt; in Visual Basic.">Una operación de resto aritmético, como <c>(a % b)</c> en C# o <c>(a Mod b)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ModuloAssign">
      <summary vsli:raw="An arithmetic remainder compound assignment operation, such as &lt;c&gt;(a %= b)&lt;/c&gt; in C#.">Una operación de asignación compuesta y resto aritmético, como <c>(a %= b)</c> en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Multiply">
      <summary vsli:raw="A multiplication operation, such as &lt;c&gt;(a * b)&lt;/c&gt;, without overflow checking, for numeric operands.">Una operación de multiplicación, como <c>(a * b)</c>, sin comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyAssign">
      <summary vsli:raw="A multiplication compound assignment operation, such as &lt;c&gt;(a *= b)&lt;/c&gt;, without overflow checking, for numeric operands.">Una operación de asignación compuesta de multiplicación, como <c>(a *= b)</c>, sin comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked">
      <summary vsli:raw="A multiplication compound assignment operation, such as &lt;c&gt;(a *= b)&lt;/c&gt;, that has overflow checking, for numeric operands.">Una operación de asignación compuesta de multiplicación, como <c>(a *= b)</c>, con comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyChecked">
      <summary vsli:raw="An multiplication operation, such as &lt;c&gt;(a * b)&lt;/c&gt;, that has overflow checking, for numeric operands.">Una operación de multiplicación, como <c>(a * b)</c>, con comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Negate">
      <summary vsli:raw="An arithmetic negation operation, such as &lt;c&gt;(-a)&lt;/c&gt;. The object &lt;c&gt;a&lt;/c&gt; should not be modified in place.">Una operación de negación aritmética, como <c>(-a)</c>. El objeto <c>a</c> no se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NegateChecked">
      <summary vsli:raw="An arithmetic negation operation, such as &lt;c&gt;(-a)&lt;/c&gt;, that has overflow checking. The object &lt;c&gt;a&lt;/c&gt; should not be modified in place.">Una operación de negación aritmética, como <c>(-a)</c>, con comprobación de desbordamiento. El objeto <c>a</c> no se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.New">
      <summary vsli:raw="An operation that calls a constructor to create a new object, such as &lt;c&gt;new SampleType()&lt;/c&gt;.">Una operación que llama a un constructor para crear un nuevo objeto, como <c>new SampleType()</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NewArrayBounds">
      <summary vsli:raw="An operation that creates a new array, in which the bounds for each dimension are specified, such as &lt;c&gt;new SampleType[dim1, dim2]&lt;/c&gt; in C# or &lt;c&gt;New SampleType(dim1, dim2)&lt;/c&gt; in Visual Basic.">Una operación que crea una nueva matriz en la que se especifican los límites de cada dimensión, como <c>new SampleType[dim1, dim2]</c> en C# o <c>New SampleType(dim1, dim2)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NewArrayInit">
      <summary vsli:raw="An operation that creates a new one-dimensional array and initializes it from a list of elements, such as &lt;c&gt;new SampleType[]{a, b, c}&lt;/c&gt; in C# or &lt;c&gt;New SampleType(){a, b, c}&lt;/c&gt; in Visual Basic.">Una operación que crea una nueva matriz de tipo unidimensional y la inicializa desde una lista de elementos, como <c>new SampleType[]{a, b, c}</c> en C# o <c>New SampleType(){a, b, c}</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Not">
      <summary vsli:raw="A bitwise complement or logical negation operation. In C#, it is equivalent to &lt;c&gt;(~a)&lt;/c&gt; for integral types and to &lt;c&gt;(!a)&lt;/c&gt; for Boolean values. In Visual Basic, it is equivalent to &lt;c&gt;(Not a)&lt;/c&gt;. The object &lt;c&gt;a&lt;/c&gt; should not be modified in place.">Una operación de complemento bit a bit o de negación lógica. En C#, su equivalente es <c>(~a)</c> para los tipos enteros y <c>(!a)</c> para los valores booleanos. En Visual Basic, su equivalente es <c>(Not a)</c>. El objeto <c>a</c> no se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NotEqual">
      <summary vsli:raw="An inequality comparison, such as &lt;c&gt;(a != b)&lt;/c&gt; in C# or &lt;c&gt;(a &amp;lt;&amp;gt; b)&lt;/c&gt; in Visual Basic.">Una comparación de desigualdad, como <c>(a != b)</c> en C# o <c>(a &lt;&gt; b)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OnesComplement">
      <summary vsli:raw="A ones complement operation, such as &lt;c&gt;(~a)&lt;/c&gt; in C#.">Una operación de complemento a unos, como <c>(~a)</c> en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Or">
      <summary vsli:raw="A bitwise or logical &lt;see langword=&quot;OR&quot; /&gt; operation, such as &lt;c&gt;(a | b)&lt;/c&gt; in C# or &lt;c&gt;(a Or b)&lt;/c&gt; in Visual Basic.">Una operación <see langword="OR" /> bit a bit o lógica, como <c>(a | b)</c> en C# o <c>(a Or b)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OrAssign">
      <summary vsli:raw="A bitwise or logical &lt;see langword=&quot;OR&quot; /&gt; compound assignment, such as &lt;c&gt;(a |= b)&lt;/c&gt; in C#.">Una asignación compuesta <see langword="OR" /> bit a bit o lógica, como <c>(a |= b)</c> en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OrElse">
      <summary vsli:raw="A short-circuiting conditional &lt;see langword=&quot;OR&quot; /&gt; operation, such as &lt;c&gt;(a || b)&lt;/c&gt; in C# or &lt;c&gt;(a OrElse b)&lt;/c&gt; in Visual Basic.">Una operación <see langword="OR" /> condicional de cortocircuito, como <c>(a || b)</c> en C# o <c>(a OrElse b)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Parameter">
      <summary vsli:raw="A reference to a parameter or variable that is defined in the context of the expression. For more information, see &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt;.">Una referencia a un parámetro o variable que se define en el contexto de la expresión. Para obtener más información, vea <see cref="T:System.Linq.Expressions.ParameterExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PostDecrementAssign">
      <summary vsli:raw="A unary postfix decrement, such as &lt;c&gt;(a--)&lt;/c&gt;. The object &lt;c&gt;a&lt;/c&gt; should be modified in place.">Un postfijo de decremento unario, como <c>(a--)</c>. El objeto <c>a</c> se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PostIncrementAssign">
      <summary vsli:raw="A unary postfix increment, such as &lt;c&gt;(a++)&lt;/c&gt;. The object &lt;c&gt;a&lt;/c&gt; should be modified in place.">Un postfijo de incremento unario, como <c>(a++)</c>. El objeto <c>a</c> se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Power">
      <summary vsli:raw="A mathematical operation that raises a number to a power, such as &lt;c&gt;(a ^ b)&lt;/c&gt; in Visual Basic.">Una operación matemática que eleva un número a una potencia, como <c>(a ^ b)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PowerAssign">
      <summary vsli:raw="A compound assignment operation that raises a number to a power, such as &lt;c&gt;(a ^= b)&lt;/c&gt; in Visual Basic.">Una operación de asignación compuesta que eleva un número a una potencia, como <c>(a ^= b)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PreDecrementAssign">
      <summary vsli:raw="A unary prefix decrement, such as &lt;c&gt;(--a)&lt;/c&gt;. The object &lt;c&gt;a&lt;/c&gt; should be modified in place.">Un prefijo de decremento unario, como <c>(--a)</c>. El objeto <c>a</c> se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PreIncrementAssign">
      <summary vsli:raw="A unary prefix increment, such as &lt;c&gt;(++a)&lt;/c&gt;. The object &lt;c&gt;a&lt;/c&gt; should be modified in place.">Un prefijo de incremento unario, como <c>(++a)</c>. El objeto <c>a</c> se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Quote">
      <summary vsli:raw="An expression that has a constant value of type &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;. A &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Quote&quot; /&gt; node can contain references to parameters that are defined in the context of the expression it represents.">Una expresión que tiene un valor constante de tipo <see cref="T:System.Linq.Expressions.Expression" />. Un nodo <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> puede contener referencias a parámetros definidos en el contexto de la expresión que representa.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RightShift">
      <summary vsli:raw="A bitwise right-shift operation, such as &lt;c&gt;(a &amp;gt;&amp;gt; b)&lt;/c&gt;.">Una operación de desplazamiento a la derecha bit a bit, como <c>(a &gt;&gt; b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RightShiftAssign">
      <summary vsli:raw="A bitwise right-shift compound assignment operation, such as &lt;c&gt;(a &amp;gt;&amp;gt;= b)&lt;/c&gt;.">Una operación de asignación compuesta y desplazamiento a la derecha bit a bit, como <c>(a &gt;&gt;= b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RuntimeVariables">
      <summary vsli:raw="A list of run-time variables. For more information, see &lt;see cref=&quot;T:System.Linq.Expressions.RuntimeVariablesExpression&quot; /&gt;.">Una lista de variables en tiempo de ejecución. Para obtener más información, vea <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Subtract">
      <summary vsli:raw="A subtraction operation, such as &lt;c&gt;(a - b)&lt;/c&gt;, without overflow checking, for numeric operands.">Una operación de resta, como <c>(a - b)</c>, sin comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractAssign">
      <summary vsli:raw="A subtraction compound assignment operation, such as &lt;c&gt;(a -= b)&lt;/c&gt;, without overflow checking, for numeric operands.">Una operación de asignación compuesta de resta, como <c>(a -= b)</c>, sin comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked">
      <summary vsli:raw="A subtraction compound assignment operation, such as &lt;c&gt;(a -= b)&lt;/c&gt;, that has overflow checking, for numeric operands.">Una operación de asignación compuesta de resta, como <c>(a -= b)</c>, con comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractChecked">
      <summary vsli:raw="An arithmetic subtraction operation, such as &lt;c&gt;(a - b)&lt;/c&gt;, that has overflow checking, for numeric operands.">Una operación de resta aritmética, como <c>(a - b)</c>, que tiene comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Switch">
      <summary vsli:raw="A switch operation, such as &lt;see langword=&quot;switch&quot; /&gt; in C# or &lt;see langword=&quot;Select Case&quot; /&gt; in Visual Basic.">Una operación de modificador, como <see langword="switch" /> en C# o <see langword="Select Case" /> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Throw">
      <summary vsli:raw="An operation that throws an exception, such as &lt;c&gt;throw new Exception()&lt;/c&gt;.">Una operación que inicia una excepción, como <c>throw new Exception()</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Try">
      <summary vsli:raw="A &lt;see langword=&quot;try-catch&quot; /&gt; expression.">Una expresión <see langword="try-catch" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeAs">
      <summary vsli:raw="An explicit reference or boxing conversion in which &lt;see langword=&quot;null&quot; /&gt; is supplied if the conversion fails, such as &lt;c&gt;(obj as SampleType)&lt;/c&gt; in C# or &lt;c&gt;TryCast(obj, SampleType)&lt;/c&gt; in Visual Basic.">Una referencia explícita o una conversión boxing en la que se proporciona el valor <see langword="null" /> si se produce un error en la conversión, como <c>(obj as SampleType)</c> en C# o <c>TryCast(obj, SampleType)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeEqual">
      <summary vsli:raw="An exact type test.">Una prueba de tipo exacto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeIs">
      <summary vsli:raw="A type test, such as &lt;c&gt;obj is SampleType&lt;/c&gt; in C# or &lt;c&gt;TypeOf obj is SampleType&lt;/c&gt; in Visual Basic.">Un tipo de prueba, como <c>obj is SampleType</c> en C# o <c>TypeOf obj is SampleType</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.UnaryPlus">
      <summary vsli:raw="A unary plus operation, such as &lt;c&gt;(+a)&lt;/c&gt;. The result of a predefined unary plus operation is the value of the operand, but user-defined implementations might have unusual results.">Una operación de unario más, como <c>(+a)</c>. El resultado de una operación de unario más predefinida es el valor del operando, pero las implementaciones definidas por el usuario podrían tener resultados poco habituales.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Unbox">
      <summary vsli:raw="An unbox value type operation, such as &lt;see langword=&quot;unbox&quot; /&gt; and &lt;see langword=&quot;unbox.any&quot; /&gt; instructions in MSIL.">Una operación de conversión unboxing a un tipo de valor, como las instrucciones <see langword="unbox" /> y <see langword="unbox.any" /> en MSIL.</summary>
    </member>
    <member name="T:System.Linq.Expressions.ExpressionVisitor">
      <summary vsli:raw="Represents a visitor or rewriter for expression trees.">Representa un visitante o un objeto de reescritura de árboles de expresión.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.#ctor">
      <summary vsli:raw="Initializes a new instance of &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionVisitor&quot; /&gt;.">Inicializa una nueva instancia de la clase <see cref="T:System.Linq.Expressions.ExpressionVisitor" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit(System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Dispatches the list of expressions to one of the more specialized visit methods in this class.">Envía la lista de expresiones a uno de los métodos de visita más especializados de esta clase.</summary>
      <param name="nodes" vsli:raw="The expressions to visit.">Expresiones que se van a visitar.</param>
      <returns vsli:raw="The modified expression list, if any one of the elements were modified; otherwise, returns the original expression list.">Lista de expresiones modificada, si se modificó alguno de los elementos; de lo contrario, devuelve la lista de expresiones original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Dispatches the expression to one of the more specialized visit methods in this class.">Envía la expresión a uno de los métodos de visita más especializados de esta clase.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expresión que se va a visitar.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.Func{``0,``0})">
      <summary vsli:raw="Visits all nodes in the collection using a specified element visitor.">Visita todos los nodos de la colección utilizando un visitante de elementos especificado.</summary>
      <param name="nodes" vsli:raw="The nodes to visit.">Nodos que se van a visitar.</param>
      <param name="elementVisitor" vsli:raw="A delegate that visits a single element, optionally replacing it with a new element.">Delegado que visita un único elemento, reemplazándolo opcionalmente con un elemento nuevo.</param>
      <typeparam name="T" vsli:raw="The type of the nodes.">Tipo de los nodos.</typeparam>
      <returns vsli:raw="The modified node list, if any of the elements were modified; otherwise, returns the original node list.">Lista de nodos modificados, si se modificó alguno de los elementos; de lo contrario, devuelve la lista de nodos original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitAndConvert``1(``0,System.String)">
      <summary vsli:raw="Visits an expression, casting the result back to the original expression type.">Visita una expresión, convirtiendo de nuevo el resultado al tipo de expresión original.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expresión que se va a visitar.</param>
      <param name="callerName" vsli:raw="The name of the calling method; used to report to report a better error message.">Nombre del método de llamada; se utiliza para notificar un mensaje de error mejor.</param>
      <typeparam name="T" vsli:raw="The type of the expression.">Tipo de la expresión.</typeparam>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The visit method for this node returned a different type.">El método Visit para este nodo devolvió un tipo diferente.</exception>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitAndConvert``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.String)">
      <summary vsli:raw="Visits all expressions in the collection, casting the results back to the original expression type.">Visita una expresión, convirtiendo de nuevo el resultado al tipo de expresión original.</summary>
      <param name="nodes" vsli:raw="The expressions to visit.">Expresiones que se van a visitar.</param>
      <param name="callerName" vsli:raw="The name of the calling method; used to report a better error message.">Nombre del método de llamada; se utiliza para notificar un mensaje de error mejor.</param>
      <typeparam name="T" vsli:raw="The type of the expressions.">Tipo de las expresiones.</typeparam>
      <returns vsli:raw="The modified expression collection, if any expression was modified; otherwise, returns the original expression collection.">Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The visit method for one of the expressions returned a different type.">El método Visit para una de las expresiones devuelve un tipo diferente.</exception>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitBinary(System.Linq.Expressions.BinaryExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt;.">Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.BinaryExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expresión que se va a visitar.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitBlock(System.Linq.Expressions.BlockExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt;.">Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.BlockExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expresión que se va a visitar.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitCatchBlock(System.Linq.Expressions.CatchBlock)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt;.">Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.CatchBlock" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expresión que se va a visitar.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitConditional(System.Linq.Expressions.ConditionalExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.ConditionalExpression&quot; /&gt;.">Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.ConditionalExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expresión que se va a visitar.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitConstant(System.Linq.Expressions.ConstantExpression)">
      <summary vsli:raw="Visits the &lt;see cref=&quot;T:System.Linq.Expressions.ConstantExpression&quot; /&gt;.">Visita <see cref="T:System.Linq.Expressions.ConstantExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expresión que se va a visitar.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitDebugInfo(System.Linq.Expressions.DebugInfoExpression)">
      <summary vsli:raw="Visits the &lt;see cref=&quot;T:System.Linq.Expressions.DebugInfoExpression&quot; /&gt;.">Visita <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expresión que se va a visitar.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitDefault(System.Linq.Expressions.DefaultExpression)">
      <summary vsli:raw="Visits the &lt;see cref=&quot;T:System.Linq.Expressions.DefaultExpression&quot; /&gt;.">Visita <see cref="T:System.Linq.Expressions.DefaultExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expresión que se va a visitar.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitDynamic(System.Linq.Expressions.DynamicExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt;.">Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.DynamicExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expresión que se va a visitar.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitElementInit(System.Linq.Expressions.ElementInit)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt;.">Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.ElementInit" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expresión que se va a visitar.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitExtension(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Visits the children of the extension expression.">Visita los elementos secundarios de la expresión de extensión.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expresión que se va a visitar.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitGoto(System.Linq.Expressions.GotoExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt;.">Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.GotoExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expresión que se va a visitar.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitIndex(System.Linq.Expressions.IndexExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.IndexExpression&quot; /&gt;.">Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.IndexExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expresión que se va a visitar.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitInvocation(System.Linq.Expressions.InvocationExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.InvocationExpression&quot; /&gt;.">Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.InvocationExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expresión que se va a visitar.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLabel(System.Linq.Expressions.LabelExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.LabelExpression&quot; /&gt;.">Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.LabelExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expresión que se va a visitar.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLabelTarget(System.Linq.Expressions.LabelTarget)">
      <summary vsli:raw="Visits the &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt;.">Visita <see cref="T:System.Linq.Expressions.LabelTarget" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expresión que se va a visitar.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLambda``1(System.Linq.Expressions.Expression{``0})">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt;.">Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.Expression`1" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expresión que se va a visitar.</param>
      <typeparam name="T" vsli:raw="The type of the delegate.">Tipo de delegado.</typeparam>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitListInit(System.Linq.Expressions.ListInitExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.ListInitExpression&quot; /&gt;.">Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.ListInitExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expresión que se va a visitar.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLoop(System.Linq.Expressions.LoopExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.LoopExpression&quot; /&gt;.">Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.LoopExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expresión que se va a visitar.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMember(System.Linq.Expressions.MemberExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt;.">Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.MemberExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expresión que se va a visitar.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberAssignment(System.Linq.Expressions.MemberAssignment)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.MemberAssignment&quot; /&gt;.">Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.MemberAssignment" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expresión que se va a visitar.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberBinding(System.Linq.Expressions.MemberBinding)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.MemberBinding&quot; /&gt;.">Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.MemberBinding" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expresión que se va a visitar.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberInit(System.Linq.Expressions.MemberInitExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.MemberInitExpression&quot; /&gt;.">Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expresión que se va a visitar.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberListBinding(System.Linq.Expressions.MemberListBinding)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.MemberListBinding&quot; /&gt;.">Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.MemberListBinding" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expresión que se va a visitar.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberMemberBinding(System.Linq.Expressions.MemberMemberBinding)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.MemberMemberBinding&quot; /&gt;.">Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.MemberMemberBinding" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expresión que se va a visitar.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt;.">Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.MethodCallExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expresión que se va a visitar.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitNew(System.Linq.Expressions.NewExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt;.">Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.NewExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expresión que se va a visitar.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitNewArray(System.Linq.Expressions.NewArrayExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.NewArrayExpression&quot; /&gt;.">Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.NewArrayExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expresión que se va a visitar.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitParameter(System.Linq.Expressions.ParameterExpression)">
      <summary vsli:raw="Visits the &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt;.">Visita <see cref="T:System.Linq.Expressions.ParameterExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expresión que se va a visitar.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitRuntimeVariables(System.Linq.Expressions.RuntimeVariablesExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.RuntimeVariablesExpression&quot; /&gt;.">Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expresión que se va a visitar.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitSwitch(System.Linq.Expressions.SwitchExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.SwitchExpression&quot; /&gt;.">Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expresión que se va a visitar.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitSwitchCase(System.Linq.Expressions.SwitchCase)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.SwitchCase&quot; /&gt;.">Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.SwitchCase" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expresión que se va a visitar.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitTry(System.Linq.Expressions.TryExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.TryExpression&quot; /&gt;.">Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.TryExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expresión que se va a visitar.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitTypeBinary(System.Linq.Expressions.TypeBinaryExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.TypeBinaryExpression&quot; /&gt;.">Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expresión que se va a visitar.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitUnary(System.Linq.Expressions.UnaryExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt;.">Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expresión que se va a visitar.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="T:System.Linq.Expressions.GotoExpression">
      <summary vsli:raw="Represents an unconditional jump. This includes return statements, break and continue statements, and other jumps.">Representa un salto incondicional. Esto incluye instrucciones return, break y continue, y otros saltos.</summary>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Kind">
      <summary vsli:raw="The kind of the &quot;go to&quot; expression. Serves information purposes only.">Tipo de la expresión "ir a". Solo tiene fines informativos.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpressionKind&quot; /&gt; object representing the kind of the &quot;go to&quot; expression.">Objeto <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> que representa el tipo de la expresión "ir a".</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.NodeType">
      <summary vsli:raw="Returns the node type of this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Devuelve el tipo de nodo de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that represents this expression.">Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Target">
      <summary vsli:raw="The target label where this node jumps to.">Etiqueta de destino a donde salta este nodo.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; object representing the target label for this node.">Objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa la etiqueta de destino para este nodo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Type&quot; /&gt; that represents the static type of the expression.">
        <see cref="P:System.Linq.Expressions.GotoExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.GotoExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Target&quot; /&gt; property of the result.">La propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> del resultado.</param>
      <param name="value" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Value&quot; /&gt; property of the result.">La propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Value" /> del resultado.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Value">
      <summary vsli:raw="The value passed to the target, or null if the target is of type System.Void.">Valor pasado al destino o null si el destino es de tipo System.Void.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; object representing the value passed to the target or null.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el valor pasado al destino o null.</returns>
    </member>
    <member name="T:System.Linq.Expressions.GotoExpressionKind">
      <summary vsli:raw="Specifies what kind of jump this &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; represents.">Especifica qué tipo de salto representa esta clase <see cref="T:System.Linq.Expressions.GotoExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Break">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; that represents a break statement.">Clase <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción break.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Continue">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; that represents a continue statement.">Clase <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción continue.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Goto">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; that represents a jump to some location.">Clase <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa un salto a alguna ubicación.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Return">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; that represents a return statement.">Clase <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción return.</summary>
    </member>
    <member name="T:System.Linq.Expressions.IArgumentProvider">
      <summary vsli:raw="Provides an internal interface for accessing the arguments of multiple tree nodes (DynamicExpression, ElementInit, MethodCallExpression, InvocationExpression, NewExpression, and IndexExpression).  This API is for internal use only.">Proporciona una interfaz interna para acceder a los argumentos de varios nodos de árbol (DynamicExpression, ElementInit, MethodCallExpression, InvocationExpression, NewExpression e IndexExpression).  Esta API es solo para uso interno.</summary>
    </member>
    <member name="P:System.Linq.Expressions.IArgumentProvider.ArgumentCount">
      <summary vsli:raw="Returns the number of arguments to the expression tree node. This API is for internal use only.">Devuelve el número de argumentos al nodo de árbol de expresión. Esta API es solo para uso interno.</summary>
      <returns vsli:raw="The number of arguments to the expression tree node as &lt;see cref=&quot;T:System.Int32&quot; /&gt;.">Número de argumentos al nodo de árbol de expresión como <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.IArgumentProvider.GetArgument(System.Int32)">
      <summary vsli:raw="Returns the argument at &lt;paramref name=&quot;index&quot; /&gt;, throwing if &lt;paramref name=&quot;index&quot; /&gt; is out of bounds. This API is for internal use only.">Devuelve el argumento en <paramref name="index" />, y se iniciará una excepción si <paramref name="index" /> está fuera de los límites. Esta API es solo para uso interno.</summary>
      <param name="index" vsli:raw="The index of the argument.">Índice del argumento.</param>
      <returns vsli:raw="The argument at index.">El argumento en el índice.</returns>
    </member>
    <member name="T:System.Linq.Expressions.IDynamicExpression">
      <summary vsli:raw="Provides an internal interface for accessing the arguments of DynamicExpression tree nodes as well as CallSite and Rewriting functionality.  You should not use this API.  It is only public due to DLL refactoring and exists only for internal performance optimizations.">Proporciona una interfaz interna para acceder a los argumentos de los nodos del árbol de DynamicExpression, así como a la funcionalidad de sitio de llamada y reescritura.  Esta API no debe usarse.  Solo es pública debido a la refactorización de la DLL, y existe únicamente para optimizaciones de rendimiento interno.</summary>
    </member>
    <member name="M:System.Linq.Expressions.IDynamicExpression.CreateCallSite">
      <summary vsli:raw="Optionally creates the CallSite and returns the CallSite for the DynamicExpression's polymorphic inline cache.  You should not use this type.  It is only public due to assembly refactoring, and it is used internally for performance optimizations.">Opcionalmente, crea el elemento CallSite y devuelve el de la caché insertada polimórfica de DynamicExpression.  No se debe usar este tipo.  Solo es público debido a la refactorización del ensamblado y se usa internamente para optimizaciones de rendimiento.</summary>
      <returns vsli:raw="The CallSite for the DynamicExpression's polymorphic inline cache.">CallSite de la caché insertada polimórfica de DynamicExpression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IDynamicExpression.DelegateType">
      <summary vsli:raw="Gets the delegate type used by the CallSite, which is the type of the rules used in the dynamic expression's polymorphic inline cache.">Obtiene el tipo de delegado usado por CallSite, que es el tipo de las reglas usadas en la caché insertada polimórfica de la expresión dinámica.</summary>
      <returns vsli:raw="The delegate type used by the CallSite.">Tipo de delegado usado por el sitio de llamada.</returns>
    </member>
    <member name="M:System.Linq.Expressions.IDynamicExpression.Rewrite(System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Rewrites this node replacing the dynamic expression's arguments with the provided values.  The number of &lt;paramref name=&quot;args&quot; /&gt; needs to match the number of the current expression.  You should not use this type.  It is only public due to assembly refactoring, and it is used internally for performance optimizations.  This helper method allows re-writing of nodes to be independent of the specific implementation class deriving from DynamicExpression that is being used at the call site.">Vuelve a escribir este nodo y reemplaza los argumentos de la expresión dinámica por los valores proporcionados.  El número de <paramref name="args" /> debe coincidir con el número de la expresión actual.  No se debe usar este tipo.  Solo es público debido a la refactorización del ensamblado y se usa internamente para optimizaciones de rendimiento.  Este método auxiliar permite volver a escribir los nodos de modo que sean independientes de la clase de implementación específica que deriva del elemento DynamicExpression que se usa en el sitio de llamada.</summary>
      <param name="args" vsli:raw="The arguments used to replace this node.">Argumentos que se usan para reemplazar este nodo.</param>
      <returns vsli:raw="The rewritten node, but if no changes were made, then returns the same node.">Nodo reescrito; si no se realizaron cambios, devuelve el mismo nodo.</returns>
    </member>
    <member name="T:System.Linq.Expressions.IndexExpression">
      <summary vsli:raw="Represents indexing a property or array.">Representa la indización de una propiedad o una matriz.</summary>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Arguments">
      <summary vsli:raw="Gets the arguments that will be used to index the property or array.">Obtiene los argumentos que se usarán para indexar la propiedad o matriz.</summary>
      <returns vsli:raw="The read-only collection containing the arguments that will be used to index the property or array.">Colección de solo lectura que contiene los argumentos que se usarán para indexar la propiedad o matriz.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Indexer">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Reflection.PropertyInfo&quot; /&gt; for the property if the expression represents an indexed property, returns null otherwise.">Obtiene la <see cref="T:System.Reflection.PropertyInfo" /> de la propiedad si la expresión representa una propiedad indizada; devuelve null en caso contrario.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Reflection.PropertyInfo&quot; /&gt; for the property if the expression represents an indexed property, otherwise null.">Clase <see cref="T:System.Reflection.PropertyInfo" /> para la propiedad si la expresión representa una propiedad indizada; de lo contrario, devuelve null.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.NodeType">
      <summary vsli:raw="Returns the node type of this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Devuelve el tipo de nodo de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that represents this expression.">Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Object">
      <summary vsli:raw="An object to index.">Objeto que se va a indizar.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; representing the object to index.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el objeto que se va a indizar.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount">
      <summary vsli:raw="Returns the number of arguments to the expression tree node.  You should not use this member.  It is only public due to assembly refactoring, and it is used internally for performance optimizations.">Devuelve el número de argumentos al nodo de árbol de expresión.  No debe usar este miembro.  Solo es público debido a la refactorización del ensamblado y se usa internamente para optimizaciones de rendimiento.</summary>
      <returns vsli:raw="Returns &lt;see cref=&quot;T:System.Int32&quot; /&gt;.">Devuelva <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.IndexExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)">
      <summary vsli:raw="Returns the argument at index, throwing if index is out of bounds.  You should not use this member.  It is only public due to assembly refactoring, and it is used internally for performance optimizations.">Devuelve el argumento en el índice, indicando si el índice está fuera de los límites.  No debe usar este miembro.  Solo es público debido a la refactorización del ensamblado y se usa internamente para optimizaciones de rendimiento.</summary>
      <param name="index" vsli:raw="The index of the argument.">Índice del argumento.</param>
      <returns vsli:raw="Returns &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Devuelva <see cref="T:System.Linq.Expressions.Expression" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.IndexExpression.Type&quot; /&gt; that represents the static type of the expression.">
        <see cref="P:System.Linq.Expressions.IndexExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.IndexExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="object" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.IndexExpression.Object&quot; /&gt; property of the result.">La propiedad <see cref="P:System.Linq.Expressions.IndexExpression.Object" /> del resultado.</param>
      <param name="arguments" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.IndexExpression.Arguments&quot; /&gt; property of the result.">La propiedad <see cref="P:System.Linq.Expressions.IndexExpression.Arguments" /> del resultado.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="T:System.Linq.Expressions.InvocationExpression">
      <summary vsli:raw="Represents an expression that applies a delegate or lambda expression to a list of argument expressions.">Representa una expresión que aplica un delegado o una expresión lambda a una lista de expresiones de argumento.</summary>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Arguments">
      <summary vsli:raw="Gets the arguments that the delegate or lambda expression is applied to.">Obtiene los argumentos a los que se aplican el delegado o expresión lambda.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Collections.ObjectModel.ReadOnlyCollection`1&quot; /&gt; of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects which represent the arguments that the delegate is applied to.">
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los argumentos a los que se aplica el delegado.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Expression">
      <summary vsli:raw="Gets the delegate or lambda expression to be applied.">Obtiene el delegado o la expresión lambda que se van a aplicar.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the delegate to be applied.">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el delegado que se va a aplicar.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.NodeType">
      <summary vsli:raw="Returns the node type of this expression. Extension nodes should return &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Extension&quot; /&gt; when overriding this method.">Devuelve el tipo de nodo de esta expresión. Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> al reemplazar este método.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; of the expression.">Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount">
      <summary vsli:raw="Returns the number of arguments to the expression tree node.  You should not use this member.  It is only public due to assembly refactoring, and it is used internally for performance optimizations.">Devuelve el número de argumentos al nodo de árbol de expresión.  No debe usar este miembro.  Solo es público debido a la refactorización del ensamblado y se usa internamente para optimizaciones de rendimiento.</summary>
      <returns vsli:raw="The number of arguments to the expression tree node as &lt;see cref=&quot;T:System.Int32&quot; /&gt;.">Número de argumentos al nodo de árbol de expresión como <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.InvocationExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)">
      <summary vsli:raw="Returns the argument at index, throwing if index is out of bounds.  You should not use this member.  It is only public due to assembly refactoring, and it is used internally for performance optimizations.">Devuelve el argumento en el índice, indicando si el índice está fuera de los límites.  No debe usar este miembro.  Solo es público debido a la refactorización del ensamblado y se usa internamente para optimizaciones de rendimiento.</summary>
      <param name="index" vsli:raw="The index of the argument.">Índice del argumento.</param>
      <returns vsli:raw="The argument at index, throwing if index is out of bounds, as &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">El argumento en el índice, indicando si el índice está fuera de los límites, como <see cref="T:System.Linq.Expressions.Expression" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;P:System.Linq.Expressions.InvocationExpression.Expression&quot; /&gt; represents.">Obtiene el tipo estático de la expresión que <see cref="P:System.Linq.Expressions.InvocationExpression.Expression" /> representa.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.InvocationExpression.Type&quot; /&gt; that represents the static type of the expression.">
        <see cref="P:System.Linq.Expressions.InvocationExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.InvocationExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="expression" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.InvocationExpression.Expression&quot; /&gt; property of the result.">La propiedad <see cref="P:System.Linq.Expressions.InvocationExpression.Expression" /> del resultado.</param>
      <param name="arguments" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.InvocationExpression.Arguments&quot; /&gt; property of the result.">La propiedad <see cref="P:System.Linq.Expressions.InvocationExpression.Arguments" /> del resultado.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="T:System.Linq.Expressions.LabelExpression">
      <summary vsli:raw="Represents a label, which can be put in any &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; context. If it is jumped to, it will get the value provided by the corresponding &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt;. Otherwise, it receives the value in &lt;see cref=&quot;P:System.Linq.Expressions.LabelExpression.DefaultValue&quot; /&gt;. If the &lt;see cref=&quot;T:System.Type&quot; /&gt; equals System.Void, no value should be provided.">Representa una etiqueta, que se puede colocar en cualquier contexto de <see cref="T:System.Linq.Expressions.Expression" />. Si se salta a ella, obtendrá el valor proporcionado por la clase <see cref="T:System.Linq.Expressions.GotoExpression" /> correspondiente. De lo contrario, recibe el valor de <see cref="P:System.Linq.Expressions.LabelExpression.DefaultValue" />. Si <see cref="T:System.Type" /> es igual a System.Void, no se debe proporcionar ningún valor.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.DefaultValue">
      <summary vsli:raw="The value of the &lt;see cref=&quot;T:System.Linq.Expressions.LabelExpression&quot; /&gt; when the label is reached through regular control flow (for example, is not jumped to).">Valor de <see cref="T:System.Linq.Expressions.LabelExpression" /> cuando se llega a la etiqueta mediante el flujo de control normal (por ejemplo, no se salta a ella).</summary>
      <returns vsli:raw="The Expression object representing the value of the &lt;see cref=&quot;T:System.Linq.Expressions.LabelExpression&quot; /&gt;.">Objeto Expression que representa el valor de la clase <see cref="T:System.Linq.Expressions.LabelExpression" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.NodeType">
      <summary vsli:raw="Returns the node type of this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Devuelve el tipo de nodo de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that represents this expression.">Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.Target">
      <summary vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; which this label is associated with.">Clase <see cref="T:System.Linq.Expressions.LabelTarget" /> a la que está asociada esta etiqueta.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; which this label is associated with.">Clase <see cref="T:System.Linq.Expressions.LabelTarget" /> a la que está asociada esta etiqueta.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.LabelExpression.Type&quot; /&gt; that represents the static type of the expression.">
        <see cref="P:System.Linq.Expressions.LabelExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LabelExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.LabelExpression.Target&quot; /&gt; property of the result.">La propiedad <see cref="P:System.Linq.Expressions.LabelExpression.Target" /> del resultado.</param>
      <param name="defaultValue" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.LabelExpression.DefaultValue&quot; /&gt; property of the result.">Propiedad <see cref="P:System.Linq.Expressions.LabelExpression.DefaultValue" /> del resultado.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="T:System.Linq.Expressions.LabelTarget">
      <summary vsli:raw="Used to represent the target of a &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt;.">Se utiliza para representar el destino de una clase <see cref="T:System.Linq.Expressions.GotoExpression" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LabelTarget.Name">
      <summary vsli:raw="Gets the name of the label.">Obtiene el nombre de la etiqueta.</summary>
      <returns vsli:raw="The name of the label.">Nombre de la etiqueta.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LabelTarget.ToString">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.String&quot; /&gt; that represents the current &lt;see cref=&quot;T:System.Object&quot; /&gt;.">Devuelve una clase <see cref="T:System.String" /> que representa la clase <see cref="T:System.Object" /> actual.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.String&quot; /&gt; that represents the current &lt;see cref=&quot;T:System.Object&quot; /&gt;.">Una clase <see cref="T:System.String" /> que representa la clase <see cref="T:System.Object" /> actual.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelTarget.Type">
      <summary vsli:raw="The type of value that is passed when jumping to the label (or &lt;see cref=&quot;T:System.Void&quot; /&gt; if no value should be passed).">Tipo de valor que se pasa al saltar a la etiqueta (o <see cref="T:System.Void" /> si no se debe pasar ningún valor).</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the type of the value that is passed when jumping to the label or &lt;see cref=&quot;T:System.Void&quot; /&gt; if no value should be passed.">Objeto <see cref="T:System.Type" /> que representa el tipo del valor que se pasa al saltar a la etiqueta o <see cref="T:System.Void" /> si no se debe pasar ningún valor.</returns>
    </member>
    <member name="T:System.Linq.Expressions.LambdaExpression">
      <summary vsli:raw="Describes a lambda expression. This captures a block of code that is similar to a .NET method body.">Describe una expresión lambda. Captura un bloque de código similar a un cuerpo de método de .NET.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Body">
      <summary vsli:raw="Gets the body of the lambda expression.">Obtiene el cuerpo de la expresión lambda.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the body of the lambda expression.">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuerpo de la expresión lambda.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LambdaExpression.Compile">
      <summary vsli:raw="Produces a delegate that represents the lambda expression.">Genera un delegado que representa la expresión lambda.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Delegate&quot; /&gt; that contains the compiled version of the lambda expression.">
        <see cref="T:System.Delegate" /> que contiene la versión compilada de la expresión lambda.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LambdaExpression.Compile(System.Boolean)">
      <summary vsli:raw="Produces an interpreted or compiled delegate that represents the lambda expression.">Genera a un delegado interpretado o compilado que representa la expresión lambda.</summary>
      <param name="preferInterpretation" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to indicate that the expression should be compiled to an interpreted form, if it's available; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para indicar que la expresión se debe compilar en un formulario interpretado, si está disponible; en caso contrario, <see langword="false" />.</param>
      <returns vsli:raw="A delegate that represents the compiled lambda expression described by the &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; object.">Delegado que representa la expresión lambda compilada descrita por el objeto <see cref="T:System.Linq.Expressions.LambdaExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LambdaExpression.Compile(System.Runtime.CompilerServices.DebugInfoGenerator)">
      <summary vsli:raw="Produces a delegate that represents the lambda expression.">Genera un delegado que representa la expresión lambda.</summary>
      <param name="debugInfoGenerator" vsli:raw="Debugging information generator used by the compiler to mark sequence points and annotate local variables.">Generador de información de depuración usado por el compilador para marcar puntos de secuencia y anotar variables locales.</param>
      <returns vsli:raw="A delegate containing the compiled version of the lambda.">Delegado que contiene la versión compilada del lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Name">
      <summary vsli:raw="Gets the name of the lambda expression.">Obtiene el nombre de la expresión lambda.</summary>
      <returns vsli:raw="The name of the lambda expression.">Nombre de la expresión lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.NodeType">
      <summary vsli:raw="Returns the node type of this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Devuelve el tipo de nodo de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that represents this expression.">Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Parameters">
      <summary vsli:raw="Gets the parameters of the lambda expression.">Obtiene los parámetros de la expresión lambda.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Collections.ObjectModel.ReadOnlyCollection`1&quot; /&gt; of &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects that represent the parameters of the lambda expression.">
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representa los parámetros de la expresión lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.ReturnType">
      <summary vsli:raw="Gets the return type of the lambda expression.">Obtiene el tipo de valor devuelto de la expresión lambda.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the type of the lambda expression.">Objeto <see cref="T:System.Type" /> que representa el tipo de la expresión lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.TailCall">
      <summary vsli:raw="Gets the value that indicates if the lambda expression will be compiled with the tail call optimization.">Obtiene el valor que indica si la expresión lambda se compilará con la optimización de llamada de cola.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the lambda expression will be compiled with the tail call optimization; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />Si la expresión lambda se compilará con la optimización de llamada de cola; en caso <see langword="false" />contrario,.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Type&quot; /&gt; that represents the static type of the expression.">
        <see cref="P:System.Linq.Expressions.LambdaExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ListInitExpression">
      <summary vsli:raw="Represents a constructor call that has a collection initializer.">Representa una llamada a un constructor que tiene un inicializador de colección.</summary>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.CanReduce">
      <summary vsli:raw="Gets a value that indicates whether the expression tree node can be reduced.">Obtiene un valor que indica si el nodo del árbol de expresión se puede reducir.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the node can be reduced; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />es si se puede reducir el nodo; en caso <see langword="false" />contrario,.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.Initializers">
      <summary vsli:raw="Gets the element initializers that are used to initialize a collection.">Obtiene los inicializadores de elementos que se utilizan para inicializar una colección.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Collections.ObjectModel.ReadOnlyCollection`1&quot; /&gt; of &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt; objects which represent the elements that are used to initialize the collection.">Uno de los objetos <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de <see cref="T:System.Linq.Expressions.ElementInit" /> que representan los elementos que se utilizan para inicializar la colección.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.NewExpression">
      <summary vsli:raw="Gets the expression that contains a call to the constructor of a collection type.">Obtiene la expresión que contiene una llamada al constructor de un tipo de colección.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; that represents the call to the constructor of a collection type.">
        <see cref="T:System.Linq.Expressions.NewExpression" /> que representa la llamada al constructor de un tipo de colección.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.NodeType">
      <summary vsli:raw="Returns the node type of this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Devuelve el tipo de nodo de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that represents this expression.">Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ListInitExpression.Reduce">
      <summary vsli:raw="Reduces the binary expression node to a simpler expression.">Reduce el nodo de expresión binario a una expresión más sencilla.</summary>
      <returns vsli:raw="The reduced expression.">Expresión reducida.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.Type&quot; /&gt; that represents the static type of the expression.">
        <see cref="P:System.Linq.Expressions.ListInitExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ListInitExpression.Update(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="newExpression" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.NewExpression&quot; /&gt; property of the result.">La propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> del resultado.</param>
      <param name="initializers" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.Initializers&quot; /&gt; property of the result.">La propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> del resultado.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="T:System.Linq.Expressions.LoopExpression">
      <summary vsli:raw="Represents an infinite loop. It can be exited with &quot;break&quot;.">Representa un bucle infinito. Se puede salir del mismo con "break".</summary>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.Body">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that is the body of the loop.">Obtiene la clase <see cref="T:System.Linq.Expressions.Expression" />, que es el cuerpo del bucle.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that is the body of the loop.">Clase <see cref="T:System.Linq.Expressions.Expression" /> que es el cuerpo del bucle.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.BreakLabel">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that is used by the loop body as a break statement target.">Obtiene la clase <see cref="T:System.Linq.Expressions.LabelTarget" /> utilizada por el cuerpo del bucle como destino de la instrucción break.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that is used by the loop body as a break statement target.">Clase <see cref="T:System.Linq.Expressions.LabelTarget" /> utilizada por el cuerpo del bucle como destino de la instrucción break.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.ContinueLabel">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that is used by the loop body as a continue statement target.">Obtiene la clase <see cref="T:System.Linq.Expressions.LabelTarget" /> utilizada por el cuerpo del bucle como destino de la instrucción continue.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that is used by the loop body as a continue statement target.">Clase <see cref="T:System.Linq.Expressions.LabelTarget" /> utilizada por el cuerpo del bucle como destino de la instrucción continue.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.NodeType">
      <summary vsli:raw="Returns the node type of this expression. Extension nodes should return &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Extension&quot; /&gt; when overriding this method.">Devuelve el tipo de nodo de esta expresión. Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> al reemplazar este método.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; of the expression.">Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.LoopExpression.Type&quot; /&gt; that represents the static type of the expression.">
        <see cref="P:System.Linq.Expressions.LoopExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LoopExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="breakLabel" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.LoopExpression.BreakLabel&quot; /&gt; property of the result.">La propiedad <see cref="P:System.Linq.Expressions.LoopExpression.BreakLabel" /> del resultado.</param>
      <param name="continueLabel" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.LoopExpression.ContinueLabel&quot; /&gt; property of the result.">La propiedad <see cref="P:System.Linq.Expressions.LoopExpression.ContinueLabel" /> del resultado.</param>
      <param name="body" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.LoopExpression.Body&quot; /&gt; property of the result.">La propiedad <see cref="P:System.Linq.Expressions.LoopExpression.Body" /> del resultado.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberAssignment">
      <summary vsli:raw="Represents assignment operation for a field or property of an object.">Representa la operación de asignación de un campo o propiedad de un objeto.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberAssignment.Expression">
      <summary vsli:raw="Gets the expression to assign to the field or property.">Obtiene la expresión que se asigna al campo o propiedad.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the value to assign to the field or property.">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el valor que se asigna al campo o propiedad.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberAssignment.Update(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="expression" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.MemberAssignment.Expression&quot; /&gt; property of the result.">La propiedad <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> del resultado.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberBinding">
      <summary vsli:raw="Provides the base class from which the classes that represent bindings that are used to initialize members of a newly created object derive.">Proporciona la clase base de la que derivan las clases que representan enlaces que se utilizan para inicializar miembros de un objeto recientemente creado.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MemberBinding.#ctor(System.Linq.Expressions.MemberBindingType,System.Reflection.MemberInfo)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Linq.Expressions.MemberBinding&quot; /&gt; class.">Inicializa una nueva instancia de la clase <see cref="T:System.Linq.Expressions.MemberBinding" />.</summary>
      <param name="type" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.MemberBindingType&quot; /&gt; that discriminates the type of binding that is represented.">Objeto <see cref="T:System.Linq.Expressions.MemberBindingType" /> que discrimina el tipo de enlace que se representa.</param>
      <param name="member" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; that represents a field or property to be initialized.">Objeto <see cref="T:System.Reflection.MemberInfo" /> que representa un campo o propiedad que va a inicializarse.</param>
    </member>
    <member name="P:System.Linq.Expressions.MemberBinding.BindingType">
      <summary vsli:raw="Gets the type of binding that is represented.">Obtiene el tipo de enlace que se representa.</summary>
      <returns vsli:raw="One of the &lt;see cref=&quot;T:System.Linq.Expressions.MemberBindingType&quot; /&gt; values.">Uno de los valores de <see cref="T:System.Linq.Expressions.MemberBindingType" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberBinding.Member">
      <summary vsli:raw="Gets the field or property to be initialized.">Obtiene el campo o la propiedad que se va a inicializar.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; that represents the field or property to be initialized.">Objeto <see cref="T:System.Reflection.MemberInfo" /> que representa el campo o la propiedad que va a inicializarse.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberBinding.ToString">
      <summary vsli:raw="Returns a textual representation of the &lt;see cref=&quot;T:System.Linq.Expressions.MemberBinding&quot; /&gt;.">Devuelve una representación textual de <see cref="T:System.Linq.Expressions.MemberBinding" />.</summary>
      <returns vsli:raw="A textual representation of the &lt;see cref=&quot;T:System.Linq.Expressions.MemberBinding&quot; /&gt;.">Representación textual de <see cref="T:System.Linq.Expressions.MemberBinding" />.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberBindingType">
      <summary vsli:raw="Describes the binding types that are used in &lt;see cref=&quot;T:System.Linq.Expressions.MemberInitExpression&quot; /&gt; objects.">Describe los tipos de enlace que se utilizan en objetos <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.Assignment">
      <summary vsli:raw="A binding that represents initializing a member with the value of an expression.">Un enlace que representa la inicialización de un miembro con el valor de una expresión.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.ListBinding">
      <summary vsli:raw="A binding that represents initializing a member of type &lt;see cref=&quot;T:System.Collections.IList&quot; /&gt; or &lt;see cref=&quot;T:System.Collections.Generic.ICollection`1&quot; /&gt; from a list of elements.">Un enlace que representa la inicialización de un miembro de tipo <see cref="T:System.Collections.IList" /> o <see cref="T:System.Collections.Generic.ICollection`1" /> de una lista de elementos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.MemberBinding">
      <summary vsli:raw="A binding that represents recursively initializing members of a member.">Un enlace que representa la inicialización de forma recursiva de los miembros de un miembro.</summary>
    </member>
    <member name="T:System.Linq.Expressions.MemberExpression">
      <summary vsli:raw="Represents accessing a field or property.">Representa el acceso a un campo o propiedad.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MemberExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary vsli:raw="Dispatches to the specific visit method for this node type. For example, &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; calls the &lt;see cref=&quot;M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)&quot; /&gt;.">Envía la expresión al método de visita específico de este tipo de nodo. Por ejemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama a <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor" vsli:raw="The visitor to visit this node with.">Visitante con el que se va a visitar este nodo.</param>
      <returns vsli:raw="The result of visiting this node.">Resultado de visitar este nodo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.Expression">
      <summary vsli:raw="Gets the containing object of the field or property.">Obtiene el objeto contenedor del campo o propiedad.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the containing object of the field or property.">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el objeto contenedor del campo o propiedad.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.Member">
      <summary vsli:raw="Gets the field or property to be accessed.">Obtiene el campo o la propiedad a los que se va a tener acceso.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; that represents the field or property to be accessed.">
        <see cref="T:System.Reflection.MemberInfo" /> que representa el campo o la propiedad a los que se va a tener acceso.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.NodeType">
      <summary vsli:raw="Returns the node type of this &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Expression&quot; /&gt;.">Devuelve el tipo de nodo de <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that represents this expression.">Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberExpression.Update(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="expression" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Expression&quot; /&gt; property of the result.">La propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> del resultado.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberInitExpression">
      <summary vsli:raw="Represents calling a constructor and initializing one or more members of the new object.">Representa la llamada a un constructor y la inicialización de uno o más miembros del nuevo objeto.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.Bindings">
      <summary vsli:raw="Gets the bindings that describe how to initialize the members of the newly created object.">Obtiene los enlaces que describen cómo inicializar los miembros del objeto recientemente creado.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Collections.ObjectModel.ReadOnlyCollection`1&quot; /&gt; of &lt;see cref=&quot;T:System.Linq.Expressions.MemberBinding&quot; /&gt; objects which describe how to initialize the members.">Una colección <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de los objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que describen cómo inicializar los miembros.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.CanReduce">
      <summary vsli:raw="Gets a value that indicates whether the expression tree node can be reduced.">Obtiene un valor que indica si el nodo del árbol de expresión se puede reducir.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the node can be reduced; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />es si se puede reducir el nodo; en caso <see langword="false" />contrario,.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.NewExpression">
      <summary vsli:raw="Gets the expression that represents the constructor call.">Obtiene la expresión que representa la llamada al constructor.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; that represents the constructor call.">
        <see cref="T:System.Linq.Expressions.NewExpression" /> que representa la llamada al constructor.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.NodeType">
      <summary vsli:raw="Returns the node type of this Expression. Extension nodes should return &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Extension&quot; /&gt; when overriding this method.">Devuelve el tipo de nodo de esta expresión. Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> al reemplazar este método.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; of the expression.">Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberInitExpression.Reduce">
      <summary vsli:raw="Reduces the &lt;see cref=&quot;T:System.Linq.Expressions.MemberInitExpression&quot; /&gt; to a simpler expression.">Reduce <see cref="T:System.Linq.Expressions.MemberInitExpression" /> a una expresión más sencilla.</summary>
      <returns vsli:raw="The reduced expression.">Expresión reducida.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.MemberInitExpression.Type&quot; /&gt; that represents the static type of the expression.">
        <see cref="P:System.Linq.Expressions.MemberInitExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberInitExpression.Update(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="newExpression" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.MemberInitExpression.NewExpression&quot; /&gt; property of the result.">La propiedad <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> del resultado.</param>
      <param name="bindings" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.MemberInitExpression.Bindings&quot; /&gt; property of the result.">La propiedad <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> del resultado.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberListBinding">
      <summary vsli:raw="Represents initializing the elements of a collection member of a newly created object.">Representa la inicialización de los elementos de un miembro de colección de un objeto que se acaba de crear.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberListBinding.Initializers">
      <summary vsli:raw="Gets the element initializers for initializing a collection member of a newly created object.">Obtiene los inicializadores de elemento para inicializar un miembro de colección de un objeto que se acaba de crear.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Collections.ObjectModel.ReadOnlyCollection`1&quot; /&gt; of &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt; objects to initialize a collection member with.">
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de objetos <see cref="T:System.Linq.Expressions.ElementInit" /> con que se inicializa un miembro de colección.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberListBinding.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="initializers" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.MemberListBinding.Initializers&quot; /&gt; property of the result.">La propiedad <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> del resultado.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberMemberBinding">
      <summary vsli:raw="Represents initializing members of a member of a newly created object.">Representa la inicialización de los miembros de un miembro de un objeto que se acaba de crear.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberMemberBinding.Bindings">
      <summary vsli:raw="Gets the bindings that describe how to initialize the members of a member.">Obtiene los enlaces que describen cómo inicializar los miembros de un miembro.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Collections.ObjectModel.ReadOnlyCollection`1&quot; /&gt; of &lt;see cref=&quot;T:System.Linq.Expressions.MemberBinding&quot; /&gt; objects that describe how to initialize the members of the member.">
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de los objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que describen cómo inicializar los miembros del miembro.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberMemberBinding.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="bindings" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.MemberMemberBinding.Bindings&quot; /&gt; property of the result.">La propiedad <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> del resultado.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MethodCallExpression">
      <summary vsli:raw="Represents a call to either static or an instance method.">Representa una llamada a un método estático o un método de instancia.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary vsli:raw="Dispatches to the specific visit method for this node type. For example, &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; calls the &lt;see cref=&quot;M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)&quot; /&gt;.">Envía la expresión al método de visita específico de este tipo de nodo. Por ejemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama a <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor" vsli:raw="The visitor to visit this node with.">Visitante con el que se va a visitar este nodo.</param>
      <returns vsli:raw="The result of visiting this node.">Resultado de visitar este nodo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Arguments">
      <summary vsli:raw="Gets a collection of expressions that represent arguments of the called method.">Obtiene una colección de expresiones que representan los argumentos del método al que se llamó.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Collections.ObjectModel.ReadOnlyCollection`1&quot; /&gt; of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects which represent the arguments to the called method.">
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los argumentos del método al que se llamó.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Method">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; for the method to be called.">Obtiene la <see cref="T:System.Reflection.MethodInfo" /> del método al que se va a llamar.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the called method.">El objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método llamado.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.NodeType">
      <summary vsli:raw="Returns the node type of this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Devuelve el tipo de nodo de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that represents this expression.">Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Object">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the instance for instance method calls or null for static method calls.">Obtiene la <see cref="T:System.Linq.Expressions.Expression" /> que representa la instancia para las llamadas al método de instancia o null para las llamadas al método estático.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the receiving object of the method.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el objeto receptor del método.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount">
      <summary vsli:raw="Returns the number of arguments to the expression tree node.  You should not use this member.  It is only public due to assembly refactoring, and it is used internally for performance optimizations.">Devuelve el número de argumentos al nodo de árbol de expresión.  No debe usar este miembro.  Solo es público debido a la refactorización del ensamblado y se usa internamente para optimizaciones de rendimiento.</summary>
      <returns vsli:raw="The number of arguments to the expression tree node as  &lt;see cref=&quot;T:System.Int32&quot; /&gt;.">El número de argumentos del nodo de árbol de expresión <see cref="T:System.Int32" />como.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)">
      <summary vsli:raw="Returns the argument at index, throwing if index is out of bounds.  You should not use this member.  It is only public due to assembly refactoring, and it is used internally for performance optimizations.">Devuelve el argumento en el índice, indicando si el índice está fuera de los límites.  No debe usar este miembro.  Solo es público debido a la refactorización del ensamblado y se usa internamente para optimizaciones de rendimiento.</summary>
      <param name="index" vsli:raw="The index of the argument.">Índice del argumento.</param>
      <returns vsli:raw="Returns &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Devuelva <see cref="T:System.Linq.Expressions.Expression" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Type&quot; /&gt; that represents the static type of the expression.">
        <see cref="P:System.Linq.Expressions.MethodCallExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="object" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt; property of the result.">La propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> del resultado.</param>
      <param name="arguments" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Arguments&quot; /&gt; property of the result.">La propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> del resultado.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="T:System.Linq.Expressions.NewArrayExpression">
      <summary vsli:raw="Represents creating a new array and possibly initializing the elements of the new array.">Representa creando una nueva matriz y posiblemente inicializando los elementos de la nueva matriz.</summary>
    </member>
    <member name="M:System.Linq.Expressions.NewArrayExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary vsli:raw="Dispatches to the specific visit method for this node type. For example, &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; calls the &lt;see cref=&quot;M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)&quot; /&gt;.">Envía la expresión al método de visita específico de este tipo de nodo. Por ejemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama a <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor" vsli:raw="The visitor to visit this node with.">Visitante con el que se va a visitar este nodo.</param>
      <returns vsli:raw="The result of visiting this node.">Resultado de visitar este nodo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewArrayExpression.Expressions">
      <summary vsli:raw="Gets the bounds of the array if the value of the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property is &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.NewArrayBounds&quot; /&gt;, or the values to initialize the elements of the new array if the value of the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property is &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.NewArrayInit&quot; /&gt;.">Obtiene los límites de la matriz si el valor de la propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" />, o los valores para inicializar los elementos de la nueva matriz si el valor de la propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" />.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Collections.ObjectModel.ReadOnlyCollection`1&quot; /&gt; of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects which represent either the bounds of the array or the initialization values.">Un objeto <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de los objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los límites de la matriz o los valores de inicialización.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewArrayExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.NewArrayExpression.Type&quot; /&gt; that represents the static type of the expression.">
        <see cref="P:System.Linq.Expressions.NewArrayExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.NewArrayExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="expressions" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.NewArrayExpression.Expressions&quot; /&gt; property of the result.">La propiedad <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> del resultado.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="T:System.Linq.Expressions.NewExpression">
      <summary vsli:raw="Represents a constructor call.">Representa una llamada de constructor.</summary>
    </member>
    <member name="M:System.Linq.Expressions.NewExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary vsli:raw="Dispatches to the specific visit method for this node type. For example, &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; calls the &lt;see cref=&quot;M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)&quot; /&gt;.">Envía la expresión al método de visita específico de este tipo de nodo. Por ejemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama a <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor" vsli:raw="The visitor to visit this node with.">Visitante con el que se va a visitar este nodo.</param>
      <returns vsli:raw="The result of visiting this node.">Resultado de visitar este nodo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Arguments">
      <summary vsli:raw="Gets the arguments to the constructor.">Obtiene los argumentos del constructor.</summary>
      <returns vsli:raw="A collection of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects that represent the arguments to the constructor.">Colección de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los argumentos del constructor.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Constructor">
      <summary vsli:raw="Gets the called constructor.">Obtiene el constructor al que se llamó.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Reflection.ConstructorInfo&quot; /&gt; that represents the called constructor.">
        <see cref="T:System.Reflection.ConstructorInfo" /> que representa el constructor al que se llamó.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Members">
      <summary vsli:raw="Gets the members that can retrieve the values of the fields that were initialized with constructor arguments.">Obtiene los miembros que pueden recuperar los valores de los campos que se inicializaron con argumentos de constructor.</summary>
      <returns vsli:raw="A collection of &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; objects that represent the members that can retrieve the values of the fields that were initialized with constructor arguments.">Una colección de objetos <see cref="T:System.Reflection.MemberInfo" /> que representan los miembros que pueden recuperar los valores de los campos que se inicializaron con argumentos de constructor.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.NodeType">
      <summary vsli:raw="Returns the node type of this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Devuelve el tipo de nodo de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that represents this expression.">Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount">
      <summary vsli:raw="Gets the number of arguments to the expression tree node.">Obtiene el número de argumentos en el nodo de árbol de expresión.</summary>
      <returns vsli:raw="The number of arguments to the expression tree node.">Número de argumentos al nodo de árbol de expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.NewExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)">
      <summary vsli:raw="Returns the argument at index, throwing if index is out of bounds.">Devuelve el argumento en el índice, indicando si el índice está fuera de los límites.</summary>
      <param name="index" vsli:raw="The index of the argument.">Índice del argumento.</param>
      <returns vsli:raw="The argument at index, throwing if index is out of bounds.">Argumento en el índice, indicando si el índice está fuera de los límites.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Type&quot; /&gt; that represents the static type of the expression.">
        <see cref="P:System.Linq.Expressions.NewExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.NewExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="arguments" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Arguments&quot; /&gt; property of the result.">La propiedad <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> del resultado.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ParameterExpression">
      <summary vsli:raw="Represents a named parameter expression.">Representa una expresión de parámetro con nombre.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ParameterExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary vsli:raw="Dispatches to the specific visit method for this node type. For example, &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; calls the &lt;see cref=&quot;M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)&quot; /&gt;.">Envía la expresión al método de visita específico de este tipo de nodo. Por ejemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama a <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor" vsli:raw="The visitor to visit this node with.">Visitante con el que se va a visitar este nodo.</param>
      <returns vsli:raw="The result of visiting this node.">Resultado de visitar este nodo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.IsByRef">
      <summary vsli:raw="Indicates that this &lt;c&gt;ParameterExpression&lt;/c&gt; is to be treated as a &lt;see langword=&quot;ByRef&quot; /&gt; parameter.">Indica que el parámetro<c>ParameterExpression</c> se va a tratar como un parámetro <see langword="ByRef" />.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if this &lt;c&gt;ParameterExpression&lt;/c&gt; is a &lt;see langword=&quot;ByRef&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />Si este <c>ParameterExpression</c> es un <see langword="ByRef" /> parámetro; en caso <see langword="false" />contrario,.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.Name">
      <summary vsli:raw="Gets the name of the parameter or variable.">Obtiene el nombre del parámetro o variable.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.String&quot; /&gt; that contains the name of the parameter.">
        <see cref="T:System.String" />. que contiene el nombre del parámetro.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.NodeType">
      <summary vsli:raw="Returns the node type of this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Devuelve el tipo de nodo de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that represents this expression.">Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.ParameterExpression.Type&quot; /&gt; that represents the static type of the expression.">
        <see cref="P:System.Linq.Expressions.ParameterExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="T:System.Linq.Expressions.RuntimeVariablesExpression">
      <summary vsli:raw="An expression that provides runtime read/write permission for variables.">Expresión que proporciona permiso de lectura y escritura en tiempo de ejecución para variables.</summary>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.NodeType">
      <summary vsli:raw="Returns the node type of this Expression. Extension nodes should return &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Extension&quot; /&gt; when overriding this method.">Devuelve el tipo de nodo de esta expresión. Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> al reemplazar este método.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; of the expression.">Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.RuntimeVariablesExpression.Type&quot; /&gt; that represents the static type of the expression.">
        <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.RuntimeVariablesExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="variables" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.RuntimeVariablesExpression.Variables&quot; /&gt; property of the result.">La propiedad <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> del resultado.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables">
      <summary vsli:raw="The variables or parameters to which to provide runtime access.">Las variables o los parámetros para los que se va a proporcionar acceso en tiempo de ejecución.</summary>
      <returns vsli:raw="The read-only collection containing parameters that will be provided the runtime access.">Colección de solo lectura que contiene parámetros para los que se proporcionará acceso en tiempo de ejecución.</returns>
    </member>
    <member name="T:System.Linq.Expressions.SwitchCase">
      <summary vsli:raw="Represents one case of a &lt;see cref=&quot;T:System.Linq.Expressions.SwitchExpression&quot; /&gt;.">Representa un caso de una clase <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SwitchCase.Body">
      <summary vsli:raw="Gets the body of this case.">Obtiene el cuerpo de este caso.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; object that represents the body of the case block.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuerpo del bloque de casos.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchCase.TestValues">
      <summary vsli:raw="Gets the values of this case. This case is selected for execution when the &lt;see cref=&quot;P:System.Linq.Expressions.SwitchExpression.SwitchValue&quot; /&gt; matches any of these values.">Obtiene los valores de este caso. Este caso se selecciona para su ejecución cuando <see cref="P:System.Linq.Expressions.SwitchExpression.SwitchValue" /> coincide con cualquiera de estos valores.</summary>
      <returns vsli:raw="The read-only collection of the values for this case block.">Colección de solo lectura de los valores para este bloque de casos.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchCase.ToString">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.String&quot; /&gt; that represents the current &lt;see cref=&quot;T:System.Object&quot; /&gt;.">Devuelve una clase <see cref="T:System.String" /> que representa la clase <see cref="T:System.Object" /> actual.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.String&quot; /&gt; that represents the current &lt;see cref=&quot;T:System.Object&quot; /&gt;.">Una clase <see cref="T:System.String" /> que representa la clase <see cref="T:System.Object" /> actual.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchCase.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="testValues" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.SwitchCase.TestValues&quot; /&gt; property of the result.">La propiedad <see cref="P:System.Linq.Expressions.SwitchCase.TestValues" /> del resultado.</param>
      <param name="body" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.SwitchCase.Body&quot; /&gt; property of the result.">La propiedad <see cref="P:System.Linq.Expressions.SwitchCase.Body" /> del resultado.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="T:System.Linq.Expressions.SwitchExpression">
      <summary vsli:raw="Represents a control expression that handles multiple selections by passing control to &lt;see cref=&quot;T:System.Linq.Expressions.SwitchCase&quot; /&gt;.">Representa una expresión de control que administra varias selecciones pasando el control a <see cref="T:System.Linq.Expressions.SwitchCase" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Cases">
      <summary vsli:raw="Gets the collection of &lt;see cref=&quot;T:System.Linq.Expressions.SwitchCase&quot; /&gt; objects for the switch.">Obtiene la colección de objetos <see cref="T:System.Linq.Expressions.SwitchCase" /> del modificador.</summary>
      <returns vsli:raw="The collection of &lt;see cref=&quot;T:System.Linq.Expressions.SwitchCase&quot; /&gt; objects.">La colección de objetos <see cref="T:System.Linq.Expressions.SwitchCase" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Comparison">
      <summary vsli:raw="Gets the equality comparison method, if any.">Obtiene el método de comparación de igualdad, si existe.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; object representing the equality comparison method.">Objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método de comparación de igualdad.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.DefaultBody">
      <summary vsli:raw="Gets the test for the switch.">Obtiene la prueba para el modificador.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; object representing the test for the switch.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa la prueba del modificador.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.NodeType">
      <summary vsli:raw="Returns the node type of this Expression. Extension nodes should return &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Extension&quot; /&gt; when overriding this method.">Devuelve el tipo de nodo de esta expresión. Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> al reemplazar este método.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; of the expression.">Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.SwitchValue">
      <summary vsli:raw="Gets the test for the switch.">Obtiene la prueba para el modificador.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; object representing the test for the switch.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa la prueba del modificador.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.SwitchExpression.Type&quot; /&gt; that represents the static type of the expression.">
        <see cref="P:System.Linq.Expressions.SwitchExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase},System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="switchValue" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.SwitchExpression.SwitchValue&quot; /&gt; property of the result.">La propiedad <see cref="P:System.Linq.Expressions.SwitchExpression.SwitchValue" /> del resultado.</param>
      <param name="cases" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.SwitchExpression.Cases&quot; /&gt; property of the result.">La propiedad <see cref="P:System.Linq.Expressions.SwitchExpression.Cases" /> del resultado.</param>
      <param name="defaultBody" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.SwitchExpression.DefaultBody&quot; /&gt; property of the result.">La propiedad <see cref="P:System.Linq.Expressions.SwitchExpression.DefaultBody" /> del resultado.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="T:System.Linq.Expressions.SymbolDocumentInfo">
      <summary vsli:raw="Stores information necessary to emit debugging symbol information for a source file, in particular the file name and unique language identifier.">Almacena información necesaria para emitir información de símbolos de depuración para un archivo de código fuente, en particular el nombre de archivo y el identificador de idioma único.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType">
      <summary vsli:raw="Returns the document type's unique identifier, if any.">Devuelve el identificador único del tipo de documento, si existe. Tiene como valor predeterminado el GUID para un archivo de texto.</summary>
      <returns vsli:raw="The document type's unique identifier. The default is the GUID for a text file.">Identificador único del tipo de documento.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.FileName">
      <summary vsli:raw="The source file name.">Nombre del archivo de código fuente.</summary>
      <returns vsli:raw="The string representing the source file name.">Cadena que representa el nombre del archivo de código fuente.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.Language">
      <summary vsli:raw="Returns the language's unique identifier, if any.">Devuelve el identificador único del idioma, si existe.</summary>
      <returns vsli:raw="The language's unique identifier.">Identificador único del idioma.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor">
      <summary vsli:raw="Returns the language vendor's unique identifier, if any.">Devuelve el identificador único del proveedor de idioma, si existe.</summary>
      <returns vsli:raw="The language vendor's unique identifier.">Identificador único del proveedor de idioma.</returns>
    </member>
    <member name="T:System.Linq.Expressions.TryExpression">
      <summary vsli:raw="Represents a try/catch/finally/fault block.">Representa un bloque try/catch/finally/de errores.</summary>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Body">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; representing the body of the try block.">Obtiene la clase <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuerpo del bloque try.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; representing the body of the try block.">Clase <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuerpo del bloque try.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Fault">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; representing the fault block.">Obtiene la clase <see cref="T:System.Linq.Expressions.Expression" /> que representa el bloque de errores.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; representing the fault block.">Clase <see cref="T:System.Linq.Expressions.Expression" /> que representa el bloque de errores.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Finally">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; representing the finally block.">Obtiene la clase <see cref="T:System.Linq.Expressions.Expression" /> que representa el bloque finally.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; representing the finally block.">Clase <see cref="T:System.Linq.Expressions.Expression" /> que representa el bloque finally.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Handlers">
      <summary vsli:raw="Gets the collection of &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt; expressions associated with the try block.">Obtiene la colección de expresiones <see cref="T:System.Linq.Expressions.CatchBlock" /> asociadas al bloque try.</summary>
      <returns vsli:raw="The collection of &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt; expressions associated with the try block.">Colección de expresiones <see cref="T:System.Linq.Expressions.CatchBlock" /> asociadas al bloque try.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.NodeType">
      <summary vsli:raw="Returns the node type of this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Devuelve el tipo de nodo de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that represents this expression.">Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.TryExpression.Type&quot; /&gt; that represents the static type of the expression.">
        <see cref="P:System.Linq.Expressions.TryExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.TryExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock},System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="body" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.TryExpression.Body&quot; /&gt; property of the result.">La propiedad <see cref="P:System.Linq.Expressions.TryExpression.Body" /> del resultado.</param>
      <param name="handlers" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.TryExpression.Handlers&quot; /&gt; property of the result.">La propiedad <see cref="P:System.Linq.Expressions.TryExpression.Handlers" /> del resultado.</param>
      <param name="finally" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.TryExpression.Finally&quot; /&gt; property of the result.">La propiedad <see cref="P:System.Linq.Expressions.TryExpression.Finally" /> del resultado.</param>
      <param name="fault" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.TryExpression.Fault&quot; /&gt; property of the result.">La propiedad <see cref="P:System.Linq.Expressions.TryExpression.Fault" /> del resultado.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="T:System.Linq.Expressions.TypeBinaryExpression">
      <summary vsli:raw="Represents an operation between an expression and a type.">Representa una operación entre una expresión y un tipo.</summary>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.Expression">
      <summary vsli:raw="Gets the expression operand of a type test operation.">Obtiene el operando de la expresión de una operación de prueba de un tipo.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the expression operand of a type test operation.">Un objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando de la expresión de una operación de prueba de tipo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.NodeType">
      <summary vsli:raw="Returns the node type of this Expression. Extension nodes should return &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Extension&quot; /&gt; when overriding this method.">Devuelve el tipo de nodo de esta expresión. Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> al reemplazar este método.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; of the expression.">Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;P:System.Linq.Expressions.TypeBinaryExpression.Expression&quot; /&gt; represents.">Obtiene el tipo estático de la expresión que <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> representa.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.TypeBinaryExpression.Type&quot; /&gt; that represents the static type of the expression.">
        <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand">
      <summary vsli:raw="Gets the type operand of a type test operation.">Obtiene el operando de tipo de una operación de prueba de tipo.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; that represents the type operand of a type test operation.">Un <see cref="T:System.Type" /> que representa el operando del tipo de una operación de prueba de tipo.</returns>
    </member>
    <member name="M:System.Linq.Expressions.TypeBinaryExpression.Update(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="expression" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.TypeBinaryExpression.Expression&quot; /&gt; property of the result.">La propiedad <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> del resultado.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="T:System.Linq.Expressions.UnaryExpression">
      <summary vsli:raw="Represents an expression that has a unary operator.">Representa una expresión que tiene un operador unario.</summary>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.CanReduce">
      <summary vsli:raw="Gets a value that indicates whether the expression tree node can be reduced.">Obtiene un valor que indica si el nodo del árbol de expresión se puede reducir.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if a node can be reduced; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />es si se puede reducir un nodo; en caso <see langword="false" />contrario,.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.IsLifted">
      <summary vsli:raw="Gets a value that indicates whether the expression tree node represents a lifted call to an operator.">Obtiene un valor que indica si el nodo del árbol de expresión representa una llamada elevada a un operador.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the node represents a lifted call; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si el nodo representa una llamada elevada; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.IsLiftedToNull">
      <summary vsli:raw="Gets a value that indicates whether the expression tree node represents a lifted call to an operator whose return type is lifted to a nullable type.">Obtiene un valor que indica si el nodo del árbol de expresión representa una llamada elevada a un operador cuyo tipo de valor devuelto se eleva a un tipo que acepta valores null.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operator's return type is lifted to a nullable type; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si el tipo de valor devuelto del operador se eleva a un tipo que acepta valores null; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Method">
      <summary vsli:raw="Gets the implementing method for the unary operation.">Obtiene el método de implementación para la operación unaria.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the implementing method.">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.NodeType">
      <summary vsli:raw="Returns the node type of this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Devuelve el tipo de nodo de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that represents this expression.">Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Operand">
      <summary vsli:raw="Gets the operand of the unary operation.">Obtiene el operando de la operación unaria.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the operand of the unary operation.">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando de la operación unaria.</returns>
    </member>
    <member name="M:System.Linq.Expressions.UnaryExpression.Reduce">
      <summary vsli:raw="Reduces the expression node to a simpler expression.">Reduce el nodo de expresión a una expresión más sencilla.</summary>
      <returns vsli:raw="The reduced expression.">Expresión reducida.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Type&quot; /&gt; that represents the static type of the expression.">
        <see cref="P:System.Linq.Expressions.UnaryExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.UnaryExpression.Update(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="operand" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property of the result.">La propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> del resultado.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="T:System.Linq.IOrderedQueryable">
      <summary vsli:raw="Represents the result of a sorting operation.">Representa el resultado de una operación de ordenación.</summary>
    </member>
    <member name="T:System.Linq.IOrderedQueryable`1">
      <summary vsli:raw="Represents the result of a sorting operation.">Representa el resultado de una operación de ordenación.</summary>
      <typeparam name="T" vsli:raw="The type of the content of the data source.">Tipo de contenido del origen de datos.</typeparam>
    </member>
    <member name="T:System.Linq.IQueryable">
      <summary vsli:raw="Provides functionality to evaluate queries against a specific data source wherein the type of the data is not specified.">Proporciona funcionalidad para evaluar consultas con respecto a un origen de datos concreto en el que se especifica el tipo de los datos.</summary>
    </member>
    <member name="P:System.Linq.IQueryable.ElementType">
      <summary vsli:raw="Gets the type of the element(s) that are returned when the expression tree associated with this instance of &lt;see cref=&quot;T:System.Linq.IQueryable&quot; /&gt; is executed.">Obtiene el tipo de los elementos que se devuelven cuando se ejecuta el árbol de expresión asociado a esta instancia de <see cref="T:System.Linq.IQueryable" />.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; that represents the type of the element(s) that are returned when the expression tree associated with this object is executed.">Un <see cref="T:System.Type" /> que representa el tipo de los elementos que se devuelven cuando se ejecuta el árbol de expresión asociado a este objeto.</returns>
    </member>
    <member name="P:System.Linq.IQueryable.Expression">
      <summary vsli:raw="Gets the expression tree that is associated with the instance of &lt;see cref=&quot;T:System.Linq.IQueryable&quot; /&gt;.">Obtiene el árbol de expresión que está asociado a la instancia de <see cref="T:System.Linq.IQueryable" />.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that is associated with this instance of &lt;see cref=&quot;T:System.Linq.IQueryable&quot; /&gt;.">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que está asociado a esta instancia de <see cref="T:System.Linq.IQueryable" />.</returns>
    </member>
    <member name="P:System.Linq.IQueryable.Provider">
      <summary vsli:raw="Gets the query provider that is associated with this data source.">Obtiene el proveedor de consultas que está asociado a este origen de datos.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.IQueryProvider&quot; /&gt; that is associated with this data source.">El objeto <see cref="T:System.Linq.IQueryProvider" /> que está asociado a este origen de datos.</returns>
    </member>
    <member name="T:System.Linq.IQueryable`1">
      <summary vsli:raw="Provides functionality to evaluate queries against a specific data source wherein the type of the data is known.">Proporciona funcionalidad para evaluar consultas con respecto a un origen de datos concreto en el que se conoce el tipo de los datos.</summary>
      <typeparam name="T" vsli:raw="The type of the data in the data source.">El tipo de los datos del origen de datos.</typeparam>
    </member>
    <member name="T:System.Linq.IQueryProvider">
      <summary vsli:raw="Defines methods to create and execute queries that are described by an &lt;see cref=&quot;T:System.Linq.IQueryable&quot; /&gt; object.">Define los métodos para crear y ejecutar las consultas descritas por un objeto <see cref="T:System.Linq.IQueryable" />.</summary>
    </member>
    <member name="M:System.Linq.IQueryProvider.CreateQuery(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Constructs an &lt;see cref=&quot;T:System.Linq.IQueryable&quot; /&gt; object that can evaluate the query represented by a specified expression tree.">Construye un objeto <see cref="T:System.Linq.IQueryable" /> que puede evaluar la consulta representada por el árbol de expresión especificado.</summary>
      <param name="expression" vsli:raw="An expression tree that represents a LINQ query.">Árbol de expresión que representa una consulta de LINQ.</param>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.IQueryable&quot; /&gt; that can evaluate the query represented by the specified expression tree.">
        <see cref="T:System.Linq.IQueryable" /> que puede evaluar la consulta representada por el árbol de expresión especificado.</returns>
    </member>
    <member name="M:System.Linq.IQueryProvider.CreateQuery``1(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Constructs an &lt;see cref=&quot;T:System.Linq.IQueryable`1&quot; /&gt; object that can evaluate the query represented by a specified expression tree.">Construye un objeto <see cref="T:System.Linq.IQueryable`1" /> que puede evaluar la consulta representada por el árbol de expresión especificado.</summary>
      <param name="expression" vsli:raw="An expression tree that represents a LINQ query.">Árbol de expresión que representa una consulta de LINQ.</param>
      <typeparam name="TElement" vsli:raw="The type of the elements of the &lt;see cref=&quot;T:System.Linq.IQueryable`1&quot; /&gt; that is returned.">Tipo de los elementos del objeto <see cref="T:System.Linq.IQueryable`1" /> que se devuelve.</typeparam>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.IQueryable`1&quot; /&gt; that can evaluate the query represented by the specified expression tree.">
        <see cref="T:System.Linq.IQueryable`1" /> que puede evaluar la consulta representada por el árbol de expresión especificado.</returns>
    </member>
    <member name="M:System.Linq.IQueryProvider.Execute(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Executes the query represented by a specified expression tree.">Ejecuta la consulta representada por el árbol de expresión especificado.</summary>
      <param name="expression" vsli:raw="An expression tree that represents a LINQ query.">Árbol de expresión que representa una consulta de LINQ.</param>
      <returns vsli:raw="The value that results from executing the specified query.">Valor que es el resultado de ejecutar la consulta especificada.</returns>
    </member>
    <member name="M:System.Linq.IQueryProvider.Execute``1(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Executes the strongly-typed query represented by a specified expression tree.">Ejecuta la consulta fuertemente tipada representada por el árbol de expresión especificado.</summary>
      <param name="expression" vsli:raw="An expression tree that represents a LINQ query.">Árbol de expresión que representa una consulta de LINQ.</param>
      <typeparam name="TResult" vsli:raw="The type of the value that results from executing the query.">Tipo del valor que es el resultado de ejecutar la consulta.</typeparam>
      <returns vsli:raw="The value that results from executing the specified query.">Valor que es el resultado de ejecutar la consulta especificada.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.CallSite">
      <summary vsli:raw="A dynamic call site base class. This type is used as a parameter type to the dynamic site targets.">Clase base de un sitio de llamada dinámico. Este tipo se utiliza como un tipo de parámetro para los destinos de sitio dinámico.</summary>
    </member>
    <member name="P:System.Runtime.CompilerServices.CallSite.Binder">
      <summary vsli:raw="Class responsible for binding dynamic operations on the dynamic site.">Clase responsable de operaciones dinámicas de enlace en el sitio dinámico.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt; object responsible for binding dynamic operations.">Objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> responsable de operaciones dinámicas de enlace.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSite.Create(System.Type,System.Runtime.CompilerServices.CallSiteBinder)">
      <summary vsli:raw="Creates a call site with the given delegate type and binder.">Crea un sitio de llamada con el tipo de delegado y el enlazador dados.</summary>
      <param name="delegateType" vsli:raw="The call site delegate type.">Tipo de delegado del sitio de llamada.</param>
      <param name="binder" vsli:raw="The call site binder.">Enlazador del sitio de llamada.</param>
      <returns vsli:raw="The new call site.">Nuevo sitio de llamada.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.CallSite`1">
      <summary vsli:raw="Dynamic site type.">Tipo de sitio dinámico.</summary>
      <typeparam name="T" vsli:raw="The delegate type.">Tipo de delegado.</typeparam>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSite`1.Create(System.Runtime.CompilerServices.CallSiteBinder)">
      <summary vsli:raw="Creates an instance of the dynamic call site, initialized with the binder responsible for the runtime binding of the dynamic operations at this call site.">Crea una instancia del sitio de llamada dinámico, inicializada con el enlazador responsable del enlace en tiempo de ejecución de las operaciones dinámicas en este sitio de llamada.</summary>
      <param name="binder" vsli:raw="The binder responsible for the runtime binding of the dynamic operations at this call site.">Enlazador responsable del enlace en tiempo de ejecución de las operaciones dinámicas en este sitio de llamada.</param>
      <returns vsli:raw="The new instance of dynamic call site.">Nueva instancia de sitio de llamada dinámico.</returns>
    </member>
    <member name="F:System.Runtime.CompilerServices.CallSite`1.Target">
      <summary vsli:raw="The Level 0 cache - a delegate specialized based on the site history.">Caché de nivel 0: un delegado especializado basado en el historial del sitio.</summary>
    </member>
    <member name="P:System.Runtime.CompilerServices.CallSite`1.Update">
      <summary vsli:raw="The update delegate. Called when the dynamic site experiences cache miss.">Delegado de actualización. Se le llama cuando el sitio dinámico experimenta líneas no ejecutadas de caché.</summary>
      <returns vsli:raw="The update delegate.">Delegado de actualización.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.CallSiteBinder">
      <summary vsli:raw="Class responsible for runtime binding of the dynamic operations on the dynamic call site.">Clase responsable del enlace en tiempo de ejecución de las operaciones dinámicas en el sitio de llamada dinámico.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSiteBinder.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt; class.">Inicializa una nueva instancia de la clase <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSiteBinder.Bind(System.Object[],System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.LabelTarget)">
      <summary vsli:raw="Performs the runtime binding of the dynamic operation on a set of arguments.">Realiza el enlace en tiempo de ejecución de la operación dinámica sobre un conjunto de argumentos.</summary>
      <param name="args" vsli:raw="An array of arguments to the dynamic operation.">Matriz de argumentos de la operación dinámica.</param>
      <param name="parameters" vsli:raw="The array of &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; instances that represent the parameters of the call site in the binding process.">Matriz de instancias de <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representan los parámetros del sitio de llamada en el proceso de enlace.</param>
      <param name="returnLabel" vsli:raw="A LabelTarget used to return the result of the dynamic binding.">Objeto LabelTarget utilizado para devolver el resultado del enlace dinámico.</param>
      <returns vsli:raw="An Expression that performs tests on the dynamic operation arguments, and performs the dynamic operation if the tests are valid. If the tests fail on subsequent occurrences of the dynamic operation, Bind will be called again to produce a new &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; for the new argument types.">Expresión que realiza pruebas sobre los argumentos de la operación dinámica y realiza la operación dinámica si las pruebas son válidas. Si se produce un error en las pruebas en las repeticiones subsiguientes de la operación dinámica, se llamará de nuevo a Bind para generar una nueva clase <see cref="T:System.Linq.Expressions.Expression" /> para los nuevos tipos de argumento.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSiteBinder.BindDelegate``1(System.Runtime.CompilerServices.CallSite{``0},System.Object[])">
      <summary vsli:raw="Provides low-level runtime binding support. Classes can override this and provide a direct delegate for the implementation of rule. This can enable saving rules to disk, having specialized rules available at runtime, or providing a different caching policy.">Proporciona compatibilidad con el enlace en tiempo de ejecución de bajo nivel. Las clases pueden reemplazarlo y proporcionar un delegado directo para la implementación de la regla. Esto puede permitir guardar reglas en el disco, tener reglas especializadas disponibles en tiempo de ejecución o proporcionar una directiva de almacenamiento en memoria caché diferente.</summary>
      <param name="site" vsli:raw="The CallSite the bind is being performed for.">Sitio de llamada para el que se va a realizar el enlace.</param>
      <param name="args" vsli:raw="The arguments for the binder.">Argumentos para el enlazador.</param>
      <typeparam name="T" vsli:raw="The target type of the CallSite.">Tipo de destino del sitio de llamada.</typeparam>
      <returns vsli:raw="A new delegate which replaces the CallSite Target.">Nuevo delegado que reemplaza el destino del sitio de llamada.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSiteBinder.CacheTarget``1(``0)">
      <summary vsli:raw="Adds a target to the cache of known targets. The cached targets will be scanned before calling BindDelegate to produce the new rule.">Agrega un destino a la memoria caché de destinos conocidos. Se examinarán los destinos almacenados en memoria caché antes de llamar a BindDelegate para generar la nueva regla.</summary>
      <param name="target" vsli:raw="The target delegate to be added to the cache.">Delegado de destino que se va a agregar a la memoria caché.</param>
      <typeparam name="T" vsli:raw="The type of target being added.">Tipo de destino que se va a agregar.</typeparam>
    </member>
    <member name="P:System.Runtime.CompilerServices.CallSiteBinder.UpdateLabel">
      <summary vsli:raw="Gets a label that can be used to cause the binding to be updated. It indicates that the expression's binding is no longer valid. This is typically used when the &quot;version&quot; of a dynamic object has changed.">Obtiene una etiqueta que se puede utilizar para provocar la actualización del enlace. Indica que el enlace de la expresión ya no es válido. Normalmente se utiliza cuando la "versión" de un objeto dinámico ha cambiado.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; object representing a label that can be used to trigger the binding update.">Objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa una etiqueta que se puede utilizar para desencadenar la actualización del enlace.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.CallSiteHelpers">
      <summary vsli:raw="Class that contains helper methods for DLR CallSites.">Clase que contiene métodos del asistente para sitios de llamada DLR.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSiteHelpers.IsInternalFrame(System.Reflection.MethodBase)">
      <summary vsli:raw="Checks if a &lt;see cref=&quot;T:System.Reflection.MethodBase&quot; /&gt; is internally used by DLR and should not be displayed on the language code's stack.">Comprueba si DLR utiliza internamente <see cref="T:System.Reflection.MethodBase" /> y no se debe mostrar en la pila del código de idioma.</summary>
      <param name="mb" vsli:raw="The input &lt;see cref=&quot;T:System.Reflection.MethodBase&quot; /&gt;.">Clase <see cref="T:System.Reflection.MethodBase" /> de entrada.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the input &lt;see cref=&quot;T:System.Reflection.MethodBase&quot; /&gt; is internally used by DLR and should not be displayed on the language code's stack. Otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es true si DLR utiliza internamente la clase <see cref="T:System.Reflection.MethodBase" /> de entrada y no se debe mostrar en la pila del código de idioma. De lo contrario, es false.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.DebugInfoGenerator">
      <summary vsli:raw="Generates debug information for lambda expressions in an expression tree.">Genera información de depuración para expresiones lambda en un árbol de expresión.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.DebugInfoGenerator.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Runtime.CompilerServices.DebugInfoGenerator&quot; /&gt; class.">Inicializa una nueva instancia de la clase <see cref="T:System.Runtime.CompilerServices.DebugInfoGenerator" />.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.DebugInfoGenerator.CreatePdbGenerator">
      <summary vsli:raw="Creates a program database (PDB) symbol generator.">Crea un generador de símbolos de base de datos de programa (PDB).</summary>
      <returns vsli:raw="A PDB symbol generator.">Generador de símbolos de PDB.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.DebugInfoGenerator.MarkSequencePoint(System.Linq.Expressions.LambdaExpression,System.Int32,System.Linq.Expressions.DebugInfoExpression)">
      <summary vsli:raw="Marks a sequence point in Microsoft intermediate language (MSIL) code.">Marca un punto de secuencia en código Lenguaje intermedio de Microsoft (MSIL).</summary>
      <param name="method" vsli:raw="The lambda expression that is generated.">Expresión lambda que se genera.</param>
      <param name="ilOffset" vsli:raw="The offset within MSIL code at which to mark the sequence point.">Desplazamiento dentro del código MSIL en el que se va a marcar el punto de secuencia.</param>
      <param name="sequencePoint" vsli:raw="Debug information that corresponds to the sequence point.">Información de depuración correspondiente al punto de secuencia.</param>
    </member>
    <member name="T:System.Runtime.CompilerServices.DynamicAttribute">
      <summary vsli:raw="Indicates that the use of &lt;see cref=&quot;T:System.Object&quot; /&gt; on a member is meant to be treated as a dynamically dispatched type.">Indica que el uso de <see cref="T:System.Object" /> en un miembro significa que se tratará como un tipo enviado dinámicamente.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.DynamicAttribute.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Runtime.CompilerServices.DynamicAttribute&quot; /&gt; class.">Inicializa una nueva instancia de la clase <see cref="T:System.Runtime.CompilerServices.DynamicAttribute" />.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.DynamicAttribute.#ctor(System.Boolean[])">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Runtime.CompilerServices.DynamicAttribute&quot; /&gt; class.">Inicializa una nueva instancia de la clase <see cref="T:System.Runtime.CompilerServices.DynamicAttribute" />.</summary>
      <param name="transformFlags" vsli:raw="Specifies, in a prefix traversal of a type's construction, which &lt;see cref=&quot;T:System.Object&quot; /&gt; occurrences are meant to be treated as a dynamically dispatched type.">Especifica, en un cruce seguro de prefijo de la construcción de un tipo, que las apariciones de <see cref="T:System.Object" /> deben tratarse como un tipo enviado dinámicamente.</param>
    </member>
    <member name="P:System.Runtime.CompilerServices.DynamicAttribute.TransformFlags">
      <summary vsli:raw="Specifies, in a prefix traversal of a type's construction, which &lt;see cref=&quot;T:System.Object&quot; /&gt; occurrences are meant to be treated as a dynamically dispatched type.">Especifica, en un cruce seguro de prefijo de la construcción de un tipo, que las apariciones de <see cref="T:System.Object" /> deben tratarse como un tipo enviado dinámicamente.</summary>
      <returns vsli:raw="The list of &lt;see cref=&quot;T:System.Object&quot; /&gt; occurrences that are meant to be treated as a dynamically dispatched type.">Lista de apariciones de <see cref="T:System.Object" /> que deben tratarse como un tipo enviado dinámicamente.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.IRuntimeVariables">
      <summary vsli:raw="Represents the values of run-time variables.">Representa los valores de variables en tiempo de ejecución.</summary>
    </member>
    <member name="P:System.Runtime.CompilerServices.IRuntimeVariables.Count">
      <summary vsli:raw="Gets a count of the run-time variables.">Obtiene un recuento de las variables en tiempo de ejecución.</summary>
      <returns vsli:raw="The number of run-time variables.">Número de variables en tiempo de ejecución.</returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.IRuntimeVariables.Item(System.Int32)">
      <summary vsli:raw="Gets the value of the run-time variable at the specified index.">Obtiene el valor de la variable en tiempo de ejecución en el índice especificado.</summary>
      <param name="index" vsli:raw="The zero-based index of the run-time variable whose value is to be returned.">Índice de base cero de la variable en tiempo de ejecución cuyo valor se va a devolver.</param>
      <returns vsli:raw="The value of the run-time variable.">Valor de la variable en tiempo de ejecución.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1">
      <summary vsli:raw="The builder for read only collection.">Generador para la colección de solo lectura.</summary>
      <typeparam name="T" vsli:raw="The type of the collection element.">Tipo del elemento de colección.</typeparam>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.#ctor">
      <summary vsli:raw="Constructs a &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;.">Construye un objeto <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary vsli:raw="Constructs a &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;, copying the contents of the given collection.">Crea un elemento <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />; para hacerlo, se copia el contenido de la colección especificada.</summary>
      <param name="collection" vsli:raw="Collection to copy elements from.">Colección de la que se van a copiar elementos.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.#ctor(System.Int32)">
      <summary vsli:raw="Constructs a &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt; with a given initial capacity. The contents are empty but builder will have reserved room for the given number of elements before any reallocations are required.">Crea un <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> con una capacidad inicial determinada. El contenido está vacío pero el generador habrá reservado sitio para el número dado de elementos antes de que sea necesaria ninguna reasignación.</summary>
      <param name="capacity" vsli:raw="Initial capacity.">Capacidad inicial.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Add(`0)">
      <summary vsli:raw="Adds an item to the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;.">Agrega un elemento a <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
      <param name="item" vsli:raw="The object to add to the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;.">Objeto que se va a agregar a <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</param>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Capacity">
      <summary vsli:raw="Gets or sets the capacity of this &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;.">Obtiene o establece la capacidad de un objeto <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
      <returns vsli:raw="The capacity of this &lt;c&gt;ReadOnlyCollectionBuilder.&lt;/c&gt;">La capacidad de este <c>ReadOnlyCollectionBuilder.</c></returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Clear">
      <summary vsli:raw="Removes all items from the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;.">Quita todos los elementos de <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Contains(`0)">
      <summary vsli:raw="Determines whether the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt; contains a specific value.">Determina si <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> contiene un valor específico.</summary>
      <param name="item" vsli:raw="the object to locate in the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;.">Objeto que se va a buscar en <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if item is found in the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es true si se encuentra el elemento en <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />; de lo contrario, es false.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.CopyTo(`0[],System.Int32)">
      <summary vsli:raw="Copies the elements of the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt; to an &lt;see cref=&quot;T:System.Array&quot; /&gt;, starting at particular &lt;see cref=&quot;T:System.Array&quot; /&gt; index.">Copia los elementos de <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> a <see cref="T:System.Array" />, empezando en un índice determinado de <see cref="T:System.Array" />.</summary>
      <param name="array" vsli:raw="The one-dimensional &lt;see cref=&quot;T:System.Array&quot; /&gt; that is the destination of the elements copied from &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;.">
        <see cref="T:System.Array" /> unidimensional que constituye el destino de los elementos copiados de <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</param>
      <param name="arrayIndex" vsli:raw="The zero-based index in array at which copying begins.">Índice de base cero de la matriz donde comienza la copia.</param>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Count">
      <summary vsli:raw="Gets the number of elements in the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;.">Obtiene el número de elementos de <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
      <returns vsli:raw="The number of elements in the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;.">Número de elementos incluidos en <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Devuelve un enumerador que procesa una iteración en la colección.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Collections.Generic.IEnumerator`1&quot; /&gt; that can be used to iterate through the collection.">
        <see cref="T:System.Collections.Generic.IEnumerator`1" /> que se puede utilizar para ejecutar una iteración en la colección.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.IndexOf(`0)">
      <summary vsli:raw="Returns the index of the first occurrence of a given value in the builder.">Devuelve el índice de la primera aparición de un valor dado en el generador.</summary>
      <param name="item" vsli:raw="An item to search for.">Elemento que se va a buscar.</param>
      <returns vsli:raw="The index of the first occurrence of an item.">Índice de la primera aparición de un elemento.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Insert(System.Int32,`0)">
      <summary vsli:raw="Inserts an item to the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt; at the specified index.">Inserta un elemento en la interfaz <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />, en el índice especificado.</summary>
      <param name="index" vsli:raw="The zero-based index at which item should be inserted.">Índice de base cero en el que debe insertarse un elemento.</param>
      <param name="item" vsli:raw="The object to insert into the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;.">Objeto que se va a insertar en <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</param>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Item(System.Int32)">
      <summary vsli:raw="Gets or sets the element at the specified index.">Obtiene o establece el elemento en el índice especificado.</summary>
      <param name="index" vsli:raw="The zero-based index of the element to get or set.">Índice de base cero del elemento que se va a obtener o establecer.</param>
      <returns vsli:raw="The element at the specified index.">Elemento en el índice especificado.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Remove(`0)">
      <summary vsli:raw="Removes the first occurrence of a specific object from the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;.">Quita la primera aparición de un objeto específico de la interfaz <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
      <param name="item" vsli:raw="The object to remove from the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;.">Objeto que se va a quitar de <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if item was successfully removed from the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;; otherwise, false. This method also returns false if item is not found in the original &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;.">Es true si el elemento se quitó correctamente de <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />; de lo contrario, es false. Este método también devuelve false si el elemento no se encontró en la clase <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> original.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.RemoveAt(System.Int32)">
      <summary vsli:raw="Removes the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt; item at the specified index.">Quita el elemento de la interfaz <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> que se encuentra en el índice especificado.</summary>
      <param name="index" vsli:raw="The zero-based index of the item to remove.">Índice de base cero del elemento que se va a quitar.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Reverse">
      <summary vsli:raw="Reverses the order of the elements in the entire &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;.">Invierte el orden de los elementos en la <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> completa.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Reverse(System.Int32,System.Int32)">
      <summary vsli:raw="Reverses the order of the elements in the specified range.">Invierte el orden de los elementos en el intervalo especificado.</summary>
      <param name="index" vsli:raw="The zero-based starting index of the range to reverse.">Índice inicial de base cero del intervalo que se va a invertir.</param>
      <param name="count" vsli:raw="The number of elements in the range to reverse.">Número de elementos del intervalo que se va a invertir.</param>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
      <summary vsli:raw="Gets a value indicating whether the &lt;see cref=&quot;T:System.Collections.Generic.ICollection`1&quot; /&gt; is read-only.">Obtiene un valor que indica si <see cref="T:System.Collections.Generic.ICollection`1" /> es de solo lectura.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Collections.Generic.ICollection`1&quot; /&gt; is read-only; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si la interfaz <see cref="T:System.Collections.Generic.ICollection`1" /> es de solo lectura; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
      <summary vsli:raw="Copies the elements of the &lt;see cref=&quot;T:System.Collections.Generic.ICollection`1&quot; /&gt; to an array, starting at the specified array index.">Copia los elementos de la interfaz <see cref="T:System.Collections.Generic.ICollection`1" /> en una matriz, comenzando en el índice especificado de la matriz.</summary>
      <param name="array" vsli:raw="The one-dimensional array that is the destination of the elements copied from &lt;see cref=&quot;T:System.Collections.Generic.ICollection`1&quot; /&gt;. The array must have zero-based indexing.">Matriz unidimensional que constituye el destino de los elementos copiados desde <see cref="T:System.Collections.Generic.ICollection`1" />. La matriz debe tener una indización de base cero.</param>
      <param name="index" vsli:raw="The zero-based index in &lt;paramref name=&quot;array&quot; /&gt; at which copying begins.">Índice de base cero en la <paramref name="array" /> donde comienza la copia.</param>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#ICollection#IsSynchronized">
      <summary vsli:raw="Gets a value indicating whether access to the &lt;see cref=&quot;T:System.Collections.ICollection&quot; /&gt; is synchronized (thread safe).">Obtiene un valor que indica si el acceso a la interfaz <see cref="T:System.Collections.ICollection" /> está sincronizado (es seguro para subprocesos).</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if access to the &lt;see cref=&quot;T:System.Collections.ICollection&quot; /&gt; is synchronized (thread safe); otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si el acceso a <see cref="T:System.Collections.ICollection" /> está sincronizado (es seguro para subprocesos); de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#ICollection#SyncRoot">
      <summary vsli:raw="Gets an object that can be used to synchronize access to the &lt;see cref=&quot;T:System.Collections.ICollection&quot; /&gt;.">Obtiene un objeto que se puede usar para sincronizar el acceso a <see cref="T:System.Collections.ICollection" />.</summary>
      <returns vsli:raw="An object that can be used to synchronize access to the &lt;see cref=&quot;T:System.Collections.ICollection&quot; /&gt;.">Objeto que se puede usar para sincronizar el acceso a <see cref="T:System.Collections.ICollection" />.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Devuelve un enumerador que procesa una iteración en la colección.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; that can be used to iterate through the collection.">
        <see cref="T:System.Collections.IEnumerator" /> que se puede utilizar para recorrer en iteración la colección.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#Add(System.Object)">
      <summary vsli:raw="Adds an item to the &lt;see cref=&quot;T:System.Collections.IList&quot; /&gt;.">Agrega un elemento a <see cref="T:System.Collections.IList" />.</summary>
      <param name="value" vsli:raw="The &lt;see cref=&quot;T:System.Object&quot; /&gt; to add to the &lt;see cref=&quot;T:System.Collections.IList&quot; /&gt;.">
        <see cref="T:System.Object" /> que se va a agregar a <see cref="T:System.Collections.IList" />.</param>
      <returns vsli:raw="The position into which the new element was inserted.">Posición en la que se insertó el nuevo elemento.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#Contains(System.Object)">
      <summary vsli:raw="Determines whether the &lt;see cref=&quot;T:System.Collections.IList&quot; /&gt; contains a specific value.">Determina si <see cref="T:System.Collections.IList" /> contiene un valor específico.</summary>
      <param name="value" vsli:raw="The &lt;see cref=&quot;T:System.Object&quot; /&gt; to locate in the &lt;see cref=&quot;T:System.Collections.IList&quot; /&gt;.">Objeto <see cref="T:System.Object" /> que se va a buscar en la interfaz <see cref="T:System.Collections.IList" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;item&quot; /&gt; is found in the &lt;see cref=&quot;T:System.Collections.IList&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si <paramref name="item" /> se encuentra en la matriz <see cref="T:System.Collections.IList" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#IndexOf(System.Object)">
      <summary vsli:raw="Determines the index of a specific item in the &lt;see cref=&quot;T:System.Collections.IList&quot; /&gt;.">Determina el índice de un elemento específico de <see cref="T:System.Collections.IList" />.</summary>
      <param name="value" vsli:raw="The object to locate in the &lt;see cref=&quot;T:System.Collections.IList&quot; /&gt;.">Objeto que se va a buscar en <see cref="T:System.Collections.IList" />.</param>
      <returns vsli:raw="The index of &lt;paramref name=&quot;item&quot; /&gt; if found in the list; otherwise, -1.">Devuelve el índice de <paramref name="item" /> si se encuentra en la lista; de lo contrario, devuelve -1.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#Insert(System.Int32,System.Object)">
      <summary vsli:raw="Inserts an item to the &lt;see cref=&quot;T:System.Collections.IList&quot; /&gt; at the specified index.">Inserta un elemento en la interfaz <see cref="T:System.Collections.IList" />, en el índice especificado.</summary>
      <param name="index" vsli:raw="The zero-based index at which &lt;paramref name=&quot;item&quot; /&gt; should be inserted.">Índice basado en cero en el que debe insertarse <paramref name="item" />.</param>
      <param name="value" vsli:raw="The object to insert into the &lt;see cref=&quot;T:System.Collections.IList&quot; /&gt;.">Objeto que se va a insertar en <see cref="T:System.Collections.IList" />.</param>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#IsFixedSize">
      <summary vsli:raw="Gets a value indicating whether the &lt;see cref=&quot;T:System.Collections.IList&quot; /&gt; has a fixed size.">Obtiene un valor que indica si la interfaz <see cref="T:System.Collections.IList" /> tiene un tamaño fijo.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Collections.IList&quot; /&gt; has a fixed size; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si la interfaz <see cref="T:System.Collections.IList" /> tiene un tamaño fijo; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#IsReadOnly">
      <summary vsli:raw="Gets a value indicating whether the &lt;see cref=&quot;T:System.Collections.IList&quot; /&gt; is read-only.">Obtiene un valor que indica si <see cref="T:System.Collections.IList" /> es de solo lectura.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Collections.IList&quot; /&gt; is read-only; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si la interfaz <see cref="T:System.Collections.IList" /> es de solo lectura; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#Item(System.Int32)">
      <summary vsli:raw="Gets or sets the element at the specified index.">Obtiene o establece el elemento en el índice especificado.</summary>
      <param name="index" vsli:raw="The zero-based index of the element to get or set.">Índice de base cero del elemento que se va a obtener o establecer.</param>
      <returns vsli:raw="The element at the specified index.">Elemento en el índice especificado.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#Remove(System.Object)">
      <summary vsli:raw="Removes the first occurrence of a specific object from the &lt;see cref=&quot;T:System.Collections.IList&quot; /&gt;.">Quita la primera aparición de un objeto específico de la interfaz <see cref="T:System.Collections.IList" />.</summary>
      <param name="value" vsli:raw="The object to remove from the &lt;see cref=&quot;T:System.Collections.IList&quot; /&gt;.">Objeto que se va a quitar de <see cref="T:System.Collections.IList" />.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.ToArray">
      <summary vsli:raw="Copies the elements of the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt; to a new array.">Copia los elementos de <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> en una nueva matriz.</summary>
      <returns vsli:raw="An array containing copies of the elements of the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;.">Matriz  que contiene copias de los elementos de <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.ToReadOnlyCollection">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Collections.ObjectModel.ReadOnlyCollection`1&quot; /&gt; containing all of the elements of the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;, avoiding copying the elements to the new array if possible. Resets the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt; after the &lt;see cref=&quot;T:System.Collections.ObjectModel.ReadOnlyCollection`1&quot; /&gt; has been created.">Crea una clase <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> que contiene todos los elementos de <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />, evitando copiar los elementos a la nueva matriz si es posible. Restablece <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> una vez creado <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</summary>
      <returns vsli:raw="A new instance of &lt;see cref=&quot;T:System.Collections.ObjectModel.ReadOnlyCollection`1&quot; /&gt;.">Nueva instancia de <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.RuleCache`1">
      <summary vsli:raw="Represents a cache of runtime binding rules.">Representa una memoria caché de reglas de enlace en tiempo de ejecución.</summary>
      <typeparam name="T" vsli:raw="The delegate type.">Tipo de delegado.</typeparam>
    </member>
  </members>
</doc>