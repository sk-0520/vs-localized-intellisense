<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Reflection.Emit</name>
  </assembly>
  <members>
    <member name="T:System.Reflection.Emit.AssemblyBuilder">
      <summary>Определяет и представляет динамическую сборку.</summary>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.CodeBase">
      <summary>Получает расположение сборки, как оно было указано изначально (так же, как и для объекта <see cref="T:System.Reflection.AssemblyName" />).</summary>
      <returns>Местоположение сборки, как оно было указано изначально.</returns>
      <exception cref="T:System.NotSupportedException">В настоящее время этот метод не поддерживается.</exception>
      <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
      <summary>Определяет динамическую сборку с указанным именем и правами доступа.</summary>
      <param name="name">Имя сборки.</param>
      <param name="access">Права доступа сборки.</param>
      <returns>Объект, представляющий новую сборку.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
      <summary>Определяет новую сборку с указанным именем и правами доступа и атрибутами.</summary>
      <param name="name">Имя сборки.</param>
      <param name="access">Права доступа сборки.</param>
      <param name="assemblyAttributes">Коллекция, содержащая атрибуты сборки.</param>
      <returns>Объект, представляющий новую сборку.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String)">
      <summary>Определяет именованный несохраняемый динамический модуль в данной сборке.</summary>
      <param name="name">Имя динамического модуля.</param>
      <returns>Объект <see cref="T:System.Reflection.Emit.ModuleBuilder" />, представляющий определенный в результате динамический модуль.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> начинается с пробела.  
-или- 
Длина параметра <paramref name="name" /> равна нулю.  

или - 
Длина <paramref name="name" /> превышает максимальную длину, определенную в системе.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> — <see langword="null" />.</exception>
      <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
      <exception cref="T:System.ExecutionEngineException">Не удается загрузить сборку для используемого по умолчанию интерфейса записи символов.  
 -или-  
 Не удается найти тип, реализующий используемый по умолчанию интерфейс записи символов.</exception>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.EntryPoint">
      <summary>Возвращает точку входа данной сборки.</summary>
      <returns>Возвращает точку входа данной сборки.</returns>
      <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.Equals(System.Object)">
      <summary>Возвращает значение, указывающее, равен ли данный экземпляр указанному объекту.</summary>
      <param name="obj">Объект, сравниваемый с этим экземпляром, или значение <see langword="null" />.</param>
      <returns>
        <see langword="true" />, если значение параметра <paramref name="obj" /> равно типу и значению данного экземпляра; в противном случае — <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.FullName">
      <summary>Получает отображаемое имя текущей динамической сборки.</summary>
      <returns>Отображаемое имя динамической сборки.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetCustomAttributes(System.Boolean)">
      <summary>Возвращает все настраиваемые атрибуты, которые были применены к текущему <see cref="T:System.Reflection.Emit.AssemblyBuilder" />.</summary>
      <param name="inherit">Данный аргумент не учитывается для объектов этого типа.</param>
      <returns>Массив, содержащий настраиваемые атрибуты; массив является пустым, если атрибуты отсутствуют.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>Возвращает настраиваемые атрибуты, примененные к текущему <see cref="T:System.Reflection.Emit.AssemblyBuilder" />, которые являются производными от указанного типа атрибута.</summary>
      <param name="attributeType">Базовый тип, от которого наследуют атрибуты.</param>
      <param name="inherit">Данный аргумент не учитывается для объектов этого типа.</param>
      <returns>Массив, содержащий настраиваемые атрибуты, происходящие (на любом уровне) от <paramref name="attributeType" />; если массив пуст, таких атрибутов нет.</returns>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="attributeType" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="attributeType" /> не является объектом <see cref="T:System.Type" />, предоставляемым средой выполнения. Например, <paramref name="attributeType" /> является объектом <see cref="T:System.Reflection.Emit.TypeBuilder" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetCustomAttributesData">
      <summary>Возвращает объекты <see cref="T:System.Reflection.CustomAttributeData" />, содержащие сведения об атрибутах, примененных к текущему объекту <see cref="T:System.Reflection.Emit.AssemblyBuilder" />.</summary>
      <returns>Универсальный список объектов <see cref="T:System.Reflection.CustomAttributeData" />, представляющих данные об атрибутах, которые были применены к текущему модулю.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule(System.String)">
      <summary>Возвращает динамический модуль с указанным именем.</summary>
      <param name="name">Имя запрошенного динамического модуля.</param>
      <returns>Объект ModuleBuilder, представляющий запрошенный динамический модуль.</returns>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">Длина параметра <paramref name="name" /> равна нулю.</exception>
      <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetExportedTypes">
      <summary>Получает экспортируемые типы, определенные в этой сборке.</summary>
      <returns>Массив элементов типа <see cref="T:System.Type" />, содержащий экспортируемые типы, определенные в этой сборке.</returns>
      <exception cref="T:System.NotSupportedException">Этот метод не реализован.</exception>
      <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetFile(System.String)">
      <summary>Возвращает объект <see cref="T:System.IO.FileStream" /> для указанного файла из таблицы файлов манифеста данной сборки.</summary>
      <param name="name">Имя указанного файла.</param>
      <returns>Объект <see cref="T:System.IO.FileStream" /> для заданного файла, или <see langword="null" />, если файл не найден.</returns>
      <exception cref="T:System.NotSupportedException">В настоящее время этот метод не поддерживается.</exception>
      <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetFiles(System.Boolean)">
      <summary>Получает файлы из таблицы манифеста сборки с указанием включать или не включать модули ресурсов.</summary>
      <param name="getResourceModules">Значение <see langword="true" />, если необходимо включать модули ресурсов; в противном случае — значение <see langword="false" />.</param>
      <returns>Массив объектов <see cref="T:System.IO.FileStream" />.</returns>
      <exception cref="T:System.NotSupportedException">В настоящее время этот метод не поддерживается.</exception>
      <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetHashCode">
      <summary>Возвращает хэш-код данного экземпляра.</summary>
      <returns>Хэш-код в виде 32-разрядного целого числа со знаком.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetLoadedModules(System.Boolean)">
      <summary>Возвращает все загруженные модули, входящие в эту сборку, дополнительно возможно включение модулей ресурсов.</summary>
      <param name="getResourceModules">Значение <see langword="true" />, если необходимо включать модули ресурсов; в противном случае — значение <see langword="false" />.</param>
      <returns>Загруженные модули, являющиеся частью этой сборки.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceInfo(System.String)">
      <summary>Возвращает сведения о сохранении заданного ресурса.</summary>
      <param name="resourceName">Имя ресурса.</param>
      <returns>
        <see cref="T:System.Reflection.ManifestResourceInfo" /> со сведениями о топологии ресурса или <see langword="null" />, если ресурс не найден.</returns>
      <exception cref="T:System.NotSupportedException">В настоящее время этот метод не поддерживается.</exception>
      <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceNames">
      <summary>Загружает указанный ресурс манифеста из сборки.</summary>
      <returns>Массив типа <see langword="String" /> , содержащий имена всех ресурсов.</returns>
      <exception cref="T:System.NotSupportedException">Этот метод не поддерживается для динамической сборки. Для получения имен ресурсов манифеста используйте метод <see cref="M:System.Reflection.Assembly.GetManifestResourceNames" />.</exception>
      <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceStream(System.String)">
      <summary>Загружает указанный ресурс манифеста из сборки.</summary>
      <param name="name">Имя запрошенного ресурса манифеста.</param>
      <returns>Объект <see cref="T:System.IO.Stream" />, представляющий данный ресурс манифеста.</returns>
      <exception cref="T:System.NotSupportedException">В настоящее время этот метод не поддерживается.</exception>
      <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceStream(System.Type,System.String)">
      <summary>Загружает из сборки указанный ресурс манифеста с учетом ограничения области действия пространства имен по типу.</summary>
      <param name="type">Тип, пространством имен которого ограничена область действия имени ресурса манифеста.</param>
      <param name="name">Имя запрошенного ресурса манифеста.</param>
      <returns>Объект <see cref="T:System.IO.Stream" />, представляющий данный ресурс манифеста.</returns>
      <exception cref="T:System.NotSupportedException">В настоящее время этот метод не поддерживается.</exception>
      <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetModule(System.String)">
      <summary>Получает указанный модуль этой сборки.</summary>
      <param name="name">Имя запрашиваемого модуля.</param>
      <returns>Запрашиваемый модуль или значение <see langword="null" />, если модуль не найден.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetModules(System.Boolean)">
      <summary>Получает все модули, входящие в эту сборку, дополнительно возможно включение модулей ресурсов.</summary>
      <param name="getResourceModules">Значение <see langword="true" />, если необходимо включать модули ресурсов; в противном случае — значение <see langword="false" />.</param>
      <returns>Модули, являющиеся частью этой сборки.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetName(System.Boolean)">
      <summary>Получает объект <see cref="T:System.Reflection.AssemblyName" />, указанный при создании текущей динамической сборки, и задает указанную базу кода.</summary>
      <param name="copiedName">Значение <see langword="true" /> для установки базы кода в расположение сборки после теневого копирования; для копирования базы кода в исходное расположение — значение <see langword="false" />.</param>
      <returns>Имя динамической сборки.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetReferencedAssemblies">
      <summary>Получает неполный список объектов <see cref="T:System.Reflection.AssemblyName" /> для сборок, на которые ссылается этот объект <see cref="T:System.Reflection.Emit.AssemblyBuilder" />.</summary>
      <returns>Массив имен сборок, на которые сделаны ссылки. Этот массив не представляет собой полный список.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetSatelliteAssembly(System.Globalization.CultureInfo)">
      <summary>Получает сопутствующую сборку для указанной культуры.</summary>
      <param name="culture">Заданные язык и региональные параметры.</param>
      <returns>Указанная вспомогательная сборка.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="culture" /> — <see langword="null" />.</exception>
      <exception cref="T:System.IO.FileNotFoundException">Не удается найти сборку.</exception>
      <exception cref="T:System.IO.FileLoadException">Вспомогательная сборка с соответствующим именем файла была найдена, но параметр <see langword="CultureInfo" /> не соответствует указанному.</exception>
      <exception cref="T:System.BadImageFormatException">Вспомогательная сборка не является допустимой сборкой.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
      <summary>Получает указанную версию вспомогательной сборки для указанной культуры.</summary>
      <param name="culture">Заданные язык и региональные параметры.</param>
      <param name="version">Версия вспомогательной сборки.</param>
      <returns>Указанная вспомогательная сборка.</returns>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="culture" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.IO.FileLoadException">Вспомогательная сборка с соответствующим именем файла была найдена, но <see langword="CultureInfo" /> или версия не соответствуют указанным.</exception>
      <exception cref="T:System.IO.FileNotFoundException">Не удается найти сборку.</exception>
      <exception cref="T:System.BadImageFormatException">Вспомогательная сборка не является допустимой сборкой.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetType(System.String,System.Boolean,System.Boolean)">
      <summary>Получает указанный тип из типов, определенных и созданных в текущем объекте <see cref="T:System.Reflection.Emit.AssemblyBuilder" />.</summary>
      <param name="name">Имя типа, который нужно найти.</param>
      <param name="throwOnError">Значение <see langword="true" /> для создания исключения, если тип не найден, в противном случае — значение <see langword="false" />.</param>
      <param name="ignoreCase">Значение <see langword="true" />, чтобы игнорировать при поиске регистр имени типа, в противном случае — значение <see langword="false" />.</param>
      <returns>Указанный тип или значение <see langword="null" />, если тип не найден или еще не создан.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.GlobalAssemblyCache">
      <summary>Получает значение, указывающее, была ли сборка загружена из глобального кэша сборок.</summary>
      <returns>Всегда <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.HostContext">
      <summary>Получает контекст узла, где создается динамическая сборка.</summary>
      <returns>Значение, указывающее контекст узла, где создается динамическая сборка.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.ImageRuntimeVersion">
      <summary>Получает версию общеязыковой среды выполнения, которая сохраняется в файле, содержащем манифест.</summary>
      <returns>Строка, содержащая информацию о версии общеязыковой среды выполнения.</returns>
      <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>Возвращает значение, указывающее, применен ли к данному элементу один или несколько экземпляров указанного типа атрибута.</summary>
      <param name="attributeType">Тип атрибута для проверки.</param>
      <param name="inherit">Данный аргумент не учитывается для объектов этого типа.</param>
      <returns>Значение <see langword="true" />, если к этой динамической сборке применяется один или несколько экземпляров параметра <paramref name="attributeType" />, в противном случае — значение <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.IsDynamic">
      <summary>Получает значение, указывающее, что текущая сборка — динамическая.</summary>
      <returns>Всегда <see langword="true" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.Location">
      <summary>Извлекает местоположение (в формате базы кодов) загруженного файла, содержащего манифест (если только не применялось теневое копирование).</summary>
      <returns>Местоположение загруженного файла, содержащего манифест. Если загруженный файл подвергался теневому копированию, <see langword="Location" /> указывает на местоположение файла до выполнения теневого копирования.</returns>
      <exception cref="T:System.NotSupportedException">В настоящее время этот метод не поддерживается.</exception>
      <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.ManifestModule">
      <summary>Получает модуль в текущем объекте <see cref="T:System.Reflection.Emit.AssemblyBuilder" />, содержащий манифест сборки.</summary>
      <returns>Модуль манифеста.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.ReflectionOnly">
      <summary>Возвращает значение, указывающее, пребывает ли динамическая сборка только в контексте отражения.</summary>
      <returns>Значение <see langword="true" />, если динамическая сборка находится только в контексте отражения; в противном случае — <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>Устанавливает пользовательский атрибут сборки с помощью большого двоичного объекта пользовательских атрибутов.</summary>
      <param name="con">Конструктор настраиваемого атрибута.</param>
      <param name="binaryAttribute">Большой двоичный объект байтов, представляющий атрибуты.</param>
      <exception cref="T:System.ArgumentNullException">Параметр <paramref name="con" /> или <paramref name="binaryAttribute" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="con" /> не является объектом <see langword="RuntimeConstructorInfo" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>Задается пользовательский атрибут сборки с помощью средства построения пользовательских атрибутов.</summary>
      <param name="customBuilder">Экземпляр вспомогательного класса для определения настраиваемого атрибута.</param>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="con" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
    </member>
    <member name="T:System.Reflection.Emit.AssemblyBuilderAccess">
      <summary>Определяет режимы доступа для динамической сборки.</summary>
    </member>
    <member name="F:System.Reflection.Emit.AssemblyBuilderAccess.Run">
      <summary>Динамическую сборку можно выполнять, но нельзя сохранять.</summary>
    </member>
    <member name="F:System.Reflection.Emit.AssemblyBuilderAccess.RunAndCollect">
      <summary>Динамическая сборка будет автоматически выгружена, и ее память освобождается, когда она больше недоступна.</summary>
    </member>
    <member name="T:System.Reflection.Emit.ConstructorBuilder">
      <summary>Определяет и представляет конструктор динамического класса.</summary>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.Attributes">
      <summary>Получает атрибуты для этого конструктора.</summary>
      <returns>Атрибуты для этого конструктора.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.CallingConvention">
      <summary>Возвращает значение <see cref="T:System.Reflection.CallingConventions" />, которое зависит от того, является ли объявленный тип универсальным.</summary>
      <returns>
        <see cref="F:System.Reflection.CallingConventions.HasThis" />, если объявляемый тип является универсальным; в противном случае — <see cref="F:System.Reflection.CallingConventions.Standard" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.DeclaringType">
      <summary>Получает ссылку на объект <see cref="T:System.Type" /> для типа, который объявляет этот элемент.</summary>
      <returns>Тип, объявляющий этот элемент.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
      <summary>Определяет параметр данного конструктора.</summary>
      <param name="iSequence">Позиция параметра в списке параметров. Параметры индексируются так, что первый параметр имеет номер 1.</param>
      <param name="attributes">Атрибуты параметра.</param>
      <param name="strParamName">Имя параметра. Имя может быть пустой строкой.</param>
      <returns>Объект, представляющий новый параметр этого конструктора.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="iSequence" /> меньше 0 (нуля) или больше, чем число параметров конструктора.</exception>
      <exception cref="T:System.InvalidOperationException">Содержащий тип был создан с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.GetCustomAttributes(System.Boolean)">
      <summary>Возвращает все пользовательские атрибуты, определенные для данного конструктора.</summary>
      <param name="inherit">Управляет наследованием пользовательских атрибутов базового класса. Этот параметр не учитывается.</param>
      <returns>Массив объектов, представляющий все пользовательские атрибуты конструктора, который представлен этим экземпляром <see cref="T:System.Reflection.Emit.ConstructorBuilder" />.</returns>
      <exception cref="T:System.NotSupportedException">В настоящее время этот метод не поддерживается.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>Возвращает пользовательские атрибуты, идентифицируемые заданным типом.</summary>
      <param name="attributeType">Тип пользовательского атрибута.</param>
      <param name="inherit">Управляет наследованием пользовательских атрибутов базового класса. Этот параметр не учитывается.</param>
      <returns>Массив объектов, представляющий атрибуты этого конструктора.</returns>
      <exception cref="T:System.NotSupportedException">В настоящее время этот метод не поддерживается.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.GetILGenerator">
      <summary>Получает объект <see cref="T:System.Reflection.Emit.ILGenerator" /> для данного конструктора.</summary>
      <returns>Объект <see cref="T:System.Reflection.Emit.ILGenerator" /> для этого конструктора.</returns>
      <exception cref="T:System.InvalidOperationException">Конструктор является конструктором без параметров.  
-или- 
Конструктор содержит флаги <see cref="T:System.Reflection.MethodAttributes" /> или <see cref="T:System.Reflection.MethodImplAttributes" />, которые указывают. что конструктор не должен содержать основной метод текста.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.GetILGenerator(System.Int32)">
      <summary>Возвращает объект <see cref="T:System.Reflection.Emit.ILGenerator" /> с указанным размером потока MSIL, который может быть использован для построения основного текста метода для этого конструктора.</summary>
      <param name="streamSize">Размер потока языка MSIL в байтах.</param>
      <returns>Объект <see cref="T:System.Reflection.Emit.ILGenerator" /> для данного конструктора.</returns>
      <exception cref="T:System.InvalidOperationException">Конструктор является конструктором без параметров.  

или - 
Конструктор содержит флаги <see cref="T:System.Reflection.MethodAttributes" /> или <see cref="T:System.Reflection.MethodImplAttributes" />, которые указывают. что конструктор не должен содержать основной метод текста.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.GetMethodImplementationFlags">
      <summary>Возвращает флаги реализации метода для данного конструктора.</summary>
      <returns>Флаги реализации метода для данного конструктора.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.GetParameters">
      <summary>Возвращает параметры данного конструктора.</summary>
      <returns>Массив, представляющий параметры этого конструктора.</returns>
      <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> не был вызван для этого типа конструктора в платформе .NET Framework версии 1.0 и 1.1.</exception>
      <exception cref="T:System.NotSupportedException">Метод <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> не был вызван для этого типа конструктора в платформе .NET Framework версии 2.0.</exception>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.InitLocals">
      <summary>Возвращает или задает признак, показывающий, инициализируются локальные переменные нулем или нет.</summary>
      <returns>Чтение и запись. Возвращает или задает признак, показывающий, инициализируются локальные переменные нулем или нет.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
      <summary>Динамически вызывает отражаемый данным экземпляром конструктор с указанными аргументами и с учетом ограничений, которые задает <see langword="Binder" />.</summary>
      <param name="obj">Объект, который нужно заново инициализировать.</param>
      <param name="invokeAttr">Одно из возможных значений <see langword="BindingFlags" />, указывающее требуемый тип связывания.</param>
      <param name="binder">
        <see langword="Binder" />, определяющий набор свойств и разрешающий связывание, приведение типов аргументов и вызов элементов с помощью отражения. Если <paramref name="binder" /> имеет значение <see langword="null" />, используется Binder.DefaultBinding.</param>
      <param name="parameters">Список аргументов. Массив аргументов, число, порядок и тип которых соответствует параметрам вызываемого конструктора. Если параметры отсутствуют, это должна быть NULL-ссылка (<see langword="Nothing" /> в Visual Basic).</param>
      <param name="culture">Параметр <see cref="T:System.Globalization.CultureInfo" /> , используемый для управления приведением типов. Если параметр имеет значение NULL, для текущего потока используется <see cref="T:System.Globalization.CultureInfo" />.</param>
      <returns>Экземпляр класса, связанный с конструктором.</returns>
      <exception cref="T:System.NotSupportedException">В настоящее время этот метод не поддерживается. Можно извлечь конструктор с помощью метода <see cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> и для полученного объекта <see cref="M:System.Reflection.ConstructorInfo.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" /> вызвать метод <see cref="T:System.Reflection.ConstructorInfo" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
      <summary>Динамически вызывает конструктор, представленный этим экземпляром для данного объекта, передавая указанные параметры и учитывая ограничения данного модуля привязки.</summary>
      <param name="invokeAttr">Это должен быть одноразрядный флаг из объекта <see cref="T:System.Reflection.BindingFlags" />, например InvokeMethod, NonPublic и др.</param>
      <param name="binder">Объект, позволяющий осуществлять привязку, приведение типов аргументов, вызов элементов, а также поиск объектов <see langword="MemberInfo" /> с помощью отражения. Если указан модуль привязки <see langword="null" />, используется модуль привязки по умолчанию. См. раздел <see cref="T:System.Reflection.Binder" />.</param>
      <param name="parameters">Список аргументов. Массив аргументов, число, порядок и тип которых соответствует параметрам вызываемого конструктора. Если параметров нет, должно быть указано значение <see langword="null" />.</param>
      <param name="culture">Экземпляр объекта <see cref="T:System.Globalization.CultureInfo" />, используемого для управления приведением типов. Если параметр имеет значение NULL, для текущего потока используется <see cref="T:System.Globalization.CultureInfo" />. Например, необходимо преобразовывать объект <see cref="T:System.String" />, представляющий 1000, в числовой объект <see cref="T:System.Double" />, поскольку в разных языках и региональных параметрах 1000 представляется по-разному.</param>
      <returns>Значение, возвращаемое вызванным конструктором.</returns>
      <exception cref="T:System.NotSupportedException">В настоящее время этот метод не поддерживается. Можно извлечь конструктор с помощью метода <see cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> и для полученного объекта <see cref="M:System.Reflection.ConstructorInfo.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" /> вызвать метод <see cref="T:System.Reflection.ConstructorInfo" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>Проверяет, определен ли указанный пользовательский атрибут.</summary>
      <param name="attributeType">Тип пользовательского атрибута.</param>
      <param name="inherit">Управляет наследованием пользовательских атрибутов базового класса. Этот параметр не учитывается.</param>
      <returns>
        <see langword="true" />, если указанный пользовательский атрибут определен; в противном случае — <see langword="false" />.</returns>
      <exception cref="T:System.NotSupportedException">В настоящее время этот метод не поддерживается. Можно извлечь конструктор с помощью метода <see cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> и для полученного объекта <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> вызвать метод <see cref="T:System.Reflection.ConstructorInfo" />.</exception>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.MethodHandle">
      <summary>Получает внутренний маркер метода. Этот дескриптор используется для доступа к основному дескриптору метаданных.</summary>
      <returns>Внутренний дескриптор метода. Этот дескриптор используется для доступа к основному дескриптору метаданных.</returns>
      <exception cref="T:System.NotSupportedException">Для данного класса это свойство не поддерживается.</exception>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.Module">
      <summary>Возвращает динамический модуль, в котором определяется этот конструктор.</summary>
      <returns>Объект <see cref="T:System.Reflection.Module" />, который представляет динамический модуль, в котором определен этот конструктор.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.Name">
      <summary>Извлекает имя данного конструктора.</summary>
      <returns>Имя данного конструктора.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.ReflectedType">
      <summary>Хранит ссылку на объект <see cref="T:System.Type" />, из которого был получен данный объект.</summary>
      <returns>
        <see langword="Type" /> Объект, из которого получен этот объект.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>Устанавливает пользовательский атрибут с помощью большого двоичного объекта пользовательских атрибутов.</summary>
      <param name="con">Конструктор настраиваемого атрибута.</param>
      <param name="binaryAttribute">Большой двоичный объект байтов, представляющий атрибуты.</param>
      <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="con" /> или <paramref name="binaryAttribute" /> — <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>Задает настраиваемый атрибут с помощью построителя настраиваемых атрибутов.</summary>
      <param name="customBuilder">Экземпляр вспомогательного класса для определения настраиваемого атрибута.</param>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="customBuilder" /> имеет значение <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
      <summary>Устанавливает флаги реализации метода для данного конструктора.</summary>
      <param name="attributes">Флаги реализации метода.</param>
      <exception cref="T:System.InvalidOperationException">Содержащий тип был создан с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.ToString">
      <summary>Возвращает экземпляр объекта <see cref="T:System.Reflection.Emit.ConstructorBuilder" /> в виде объекта <see cref="T:System.String" />.</summary>
      <returns>Строка, содержащая имя, атрибуты и исключения этого конструктора, за которой следует текущий поток MSIL.</returns>
    </member>
    <member name="T:System.Reflection.Emit.EnumBuilder">
      <summary>Описывает и представляет тип перечисления.</summary>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.Assembly">
      <summary>Возвращает динамическую сборку, которая содержит определение данного перечисления.</summary>
      <returns>Только для чтения. Динамическая сборка, которая содержит определение данного перечисления.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.AssemblyQualifiedName">
      <summary>Возвращает полный путь перечисления, определяемый отображаемым именем родительской сборки.</summary>
      <returns>Только для чтения. Полный путь перечисления, определяемый отображаемым именем родительской сборки.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.BaseType">
      <summary>Возвращает родительский объект <see cref="T:System.Type" /> данного типа, который всегда представляет собой объект типа <see cref="T:System.Enum" />.</summary>
      <returns>Только для чтения. Родительский объект <see cref="T:System.Type" /> данного типа.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.CreateTypeInfo">
      <summary>Получает объект <see cref="T:System.Reflection.TypeInfo" />, представляющий данное перечисление.</summary>
      <returns>Объект, представляющий данное перечисление.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.DeclaringType">
      <summary>Возвращает тип, которым объявлен данный объект <see cref="T:System.Reflection.Emit.EnumBuilder" />.</summary>
      <returns>Только для чтения. Тип, которым объявлен данный объект <see cref="T:System.Reflection.Emit.EnumBuilder" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.DefineLiteral(System.String,System.Object)">
      <summary>Задает определенную числовую константу для поименованного статического поля в типе перечисления.</summary>
      <param name="literalName">Имя статического поля.</param>
      <param name="literalValue">Числовая константа данного литерала.</param>
      <returns>Определенное поле.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.FullName">
      <summary>Возвращает полное имя данного перечисления.</summary>
      <returns>Только для чтения. Полное имя данного перечисления.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetConstructors(System.Reflection.BindingFlags)">
      <summary>Возвращает массив объектов <see cref="T:System.Reflection.ConstructorInfo" />, представляющих открытые и закрытые конструкторы, определенные для этого класса, как указано.</summary>
      <param name="bindingAttr">Это должен быть одноразрядный флаг из <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" /> и так далее.</param>
      <returns>Возвращает массив объектов <see cref="T:System.Reflection.ConstructorInfo" />, представляющих указанные конструкторы, определенные для этого класса. Если конструкторы не определены, возвращается пустой массив.</returns>
      <exception cref="T:System.NotSupportedException">В настоящее время этот метод не поддерживается в неполных типах.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetCustomAttributes(System.Boolean)">
      <summary>Возвращает все пользовательские атрибуты, определенные для данного конструктора.</summary>
      <param name="inherit">Указывает, следует ли выполнять поиск в цепочке наследования этого члена для нахождения атрибутов.</param>
      <returns>Возвращает массив объектов, предоставляющих все пользовательские атрибуты конструктора, который в свою очередь представлен экземпляром объекта <see cref="T:System.Reflection.Emit.ConstructorBuilder" />.</returns>
      <exception cref="T:System.NotSupportedException">В настоящее время этот метод не поддерживается в неполных типах.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>Возвращает пользовательские атрибуты, идентифицируемые заданным типом.</summary>
      <param name="attributeType">Объект <see langword="Type" />, к которому применяются настраиваемые атрибуты.</param>
      <param name="inherit">Указывает, следует ли выполнять поиск в цепочке наследования этого члена для нахождения атрибутов.</param>
      <returns>Возвращает массив объектов, предоставляющих атрибуты типа <see cref="T:System.Type" /><paramref name="attributeType" /> данного конструктора.</returns>
      <exception cref="T:System.NotSupportedException">В настоящее время этот метод не поддерживается в неполных типах.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetElementType">
      <summary>При вызове этого метода всегда возникает исключение <see cref="T:System.NotSupportedException" />.</summary>
      <returns>Этот метод не поддерживается. Возвращаемое значение отсутствует.</returns>
      <exception cref="T:System.NotSupportedException">В настоящее время этот метод не поддерживается.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetEnumUnderlyingType">
      <summary>Возвращает базовый тип целого числа данного перечисления, устанавливаемый при определении построителя перечисления.</summary>
      <returns>Базовый тип.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
      <summary>Возвращает событие с указанным именем.</summary>
      <param name="name">Имя события, которое нужно получить.</param>
      <param name="bindingAttr">Это атрибут вызова. Это должен быть одноразрядный флаг из <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" /> и так далее.</param>
      <returns>Возвращает объект <see cref="T:System.Reflection.EventInfo" />, предоставляющий событие (имеющее заданное имя), объявленное или наследованное данным типом. Если совпадений не найдено, возвращается значение <see langword="null" />.</returns>
      <exception cref="T:System.NotSupportedException">В настоящее время этот метод не поддерживается в неполных типах.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetEvents">
      <summary>Возвращает события для открытых событий, объявленных или наследованных данным типом.</summary>
      <returns>Возвращает массив объектов <see cref="T:System.Reflection.EventInfo" />, представляющих открытые события, объявленные или наследуемые этим типом. Если открытые события отсутствуют, возвращается пустой массив.</returns>
      <exception cref="T:System.NotSupportedException">В настоящее время этот метод не поддерживается в неполных типах.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetEvents(System.Reflection.BindingFlags)">
      <summary>Возвращает открытые и не являющиеся открытыми события, объявленные данным типом.</summary>
      <param name="bindingAttr">Это должен быть одноразрядный флаг из <see cref="T:System.Reflection.BindingFlags" />, например <see langword="InvokeMethod" />, <see langword="NonPublic" /> и так далее.</param>
      <returns>Возвращает массив объектов <see cref="T:System.Reflection.EventInfo" />, предоставляющий открытые и не являющиеся открытыми события, объявленные или наследованные данным типом. Если указанные события отсутствуют, возвращается пустой массив.</returns>
      <exception cref="T:System.NotSupportedException">В настоящее время этот метод не поддерживается в неполных типах.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetField(System.String,System.Reflection.BindingFlags)">
      <summary>Возвращает поле, указанное данным именем.</summary>
      <param name="name">Имя получаемого поля.</param>
      <param name="bindingAttr">Это должен быть одноразрядный флаг из <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" /> и так далее.</param>
      <returns>Возвращает объект <see cref="T:System.Reflection.FieldInfo" />, представляющий поле, объявленное или наследуемое этим типом, с указанным именем и открытым или закрытым модификатором. Если совпадений не найдено, возвращается значение null.</returns>
      <exception cref="T:System.NotSupportedException">В настоящее время этот метод не поддерживается в неполных типах.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetFields(System.Reflection.BindingFlags)">
      <summary>Возвращает открытые и не являющиеся открытыми поля, объявленные данным типом.</summary>
      <param name="bindingAttr">Это должен быть одноразрядный флаг из объекта <see cref="T:System.Reflection.BindingFlags" />, например InvokeMethod, NonPublic и др.</param>
      <returns>Возвращает массив объектов <see cref="T:System.Reflection.FieldInfo" />, представляющих открытые и не являющиеся открытыми поля, объявленные или наследованные этим типом. Если заданные поля отсутствуют, возвращается пустой массив.</returns>
      <exception cref="T:System.NotSupportedException">В настоящее время этот метод не поддерживается в неполных типах.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetInterface(System.String,System.Boolean)">
      <summary>Возвращает интерфейс, реализованный (прямо или косвенно) данным типом, с указанным полным именем.</summary>
      <param name="name">Имя интерфейса.</param>
      <param name="ignoreCase">Если значение <see langword="true" />, при поиске не учитывается регистр. Если значение <see langword="false" />, при поиске учитывается регистр.</param>
      <returns>Возвращает объект <see cref="T:System.Type" />, предоставляющий реализованный интерфейс. Возвращает значение null, если совпадающее имя интерфейса не найдено.</returns>
      <exception cref="T:System.NotSupportedException">В настоящее время этот метод не поддерживается в неполных типах.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetInterfaceMap(System.Type)">
      <summary>Возвращает сопоставление интерфейса для запрошенного интерфейса.</summary>
      <param name="interfaceType">Тип интерфейса, для которого следует извлечь сопоставление интерфейса.</param>
      <returns>Сопоставление запрошенного интерфейса.</returns>
      <exception cref="T:System.ArgumentException">Тип не реализует данный интерфейс.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetInterfaces">
      <summary>Возвращает массив всех интерфейсов, реализованных для данного класса, а также базовые классы.</summary>
      <returns>Возвращает массив объектов <see cref="T:System.Type" />, представляющих реализованные интерфейсы. Если они не определены, возвращается пустой массив.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
      <summary>Возвращает все элементы с указанными именами, типами и привязками, которые объявлены или наследованы этим типом.</summary>
      <param name="name">Имя элемента.</param>
      <param name="type">Тип элемента, который следует вернуть.</param>
      <param name="bindingAttr">Это должен быть одноразрядный флаг из <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" /> и так далее.</param>
      <returns>Возвращает массив объектов <see cref="T:System.Reflection.MemberInfo" />, представляющих открытые и не являющиеся открытыми члены, определенные для данного типа, если используется <paramref name="nonPublic" />; в противном случае возвращаются только открытые члены.</returns>
      <exception cref="T:System.NotSupportedException">В настоящее время этот метод не поддерживается в неполных типах.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetMembers(System.Reflection.BindingFlags)">
      <summary>Возвращает указанные элементы, объявленные или наследованные данным типом.</summary>
      <param name="bindingAttr">Это должен быть одноразрядный флаг из <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" /> и так далее.</param>
      <returns>Возвращает массив объектов <see cref="T:System.Reflection.MemberInfo" />, представляющих открытые и не являющиеся открытыми члены, объявленные или наследованные этим типом. Если соответствующие члены отсутствуют, возвращается пустой массив.</returns>
      <exception cref="T:System.NotSupportedException">В настоящее время этот метод не поддерживается в неполных типах.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetMethods(System.Reflection.BindingFlags)">
      <summary>Возвращает все открытые и закрытые методы, объявленные или наследуемые данным типом, как указано.</summary>
      <param name="bindingAttr">Это должен быть одноразрядный флаг из <see cref="T:System.Reflection.BindingFlags" />, например <see langword="InvokeMethod" />, <see langword="NonPublic" /> и так далее.</param>
      <returns>Возвращает массив объектов <see cref="T:System.Reflection.MethodInfo" />, представляющих открытые и закрытые методы, определенные для данного типа, если используется <paramref name="nonPublic" />; в противном случае возвращаются только открытые методы.</returns>
      <exception cref="T:System.NotSupportedException">В настоящее время этот метод не поддерживается в неполных типах.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
      <summary>Возвращает указанные вложенные типы, которые объявлены этим типом.</summary>
      <param name="name">Строка <see cref="T:System.String" />, содержащая имя искомого вложенного типа.</param>
      <param name="bindingAttr">Битовая маска, составленная из одного или нескольких объектов <see cref="T:System.Reflection.BindingFlags" /> и указывающая, как ведется поиск.  

или - 
Нуль для выполнения поиска открытых методов с учетом регистра.</param>
      <returns>Если поиск выполнен успешно, возвращается объект <see cref="T:System.Type" />, предоставляющий вложенный тип, который соответствует указанным требованиям; в противном случае возвращается <see langword="null" />.</returns>
      <exception cref="T:System.NotSupportedException">В настоящее время этот метод не поддерживается в неполных типах.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
      <summary>Возвращает открытые и не являющиеся открытыми вложенные типы, объявленные или наследованные данным типом.</summary>
      <param name="bindingAttr">Это должен быть одноразрядный флаг из <see cref="T:System.Reflection.BindingFlags" />, например <see langword="InvokeMethod" />, <see langword="NonPublic" /> и так далее.</param>
      <returns>Массив объектов <see cref="T:System.Type" />, представляющий все типы, вложенные внутри текущего типа <see cref="T:System.Type" /> и удовлетворяющие указанным ограничениям привязки.  
Пустой массив типа <see cref="T:System.Type" />, если внутри текущего объекта <see cref="T:System.Type" /> нет вложенных типов, или ни один из вложенных типов не удовлетворяет ограничениям привязки.</returns>
      <exception cref="T:System.NotSupportedException">В настоящее время этот метод не поддерживается в неполных типах.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetProperties(System.Reflection.BindingFlags)">
      <summary>Возвращает все открытые и закрытые свойства, объявленные или наследуемые данным типом, как указано.</summary>
      <param name="bindingAttr">Это атрибут вызова. Это должен быть одноразрядный флаг из <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" /> и так далее.</param>
      <returns>Возвращает массив объектов <see cref="T:System.Reflection.PropertyInfo" />, представляющих открытые и закрытые свойства, определенные для данного типа, если используется <paramref name="nonPublic" />; в противном случае возвращаются только открытые свойства.</returns>
      <exception cref="T:System.NotSupportedException">В настоящее время этот метод не поддерживается в неполных типах.</exception>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.GUID">
      <summary>Возвращает GUID данного перечисления.</summary>
      <returns>Только для чтения. GUID данного перечисления.</returns>
      <exception cref="T:System.NotSupportedException">В настоящее время этот метод не поддерживается в неполных типах.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
      <summary>Вызывает указанный член. Вызываемый метод должен быть доступен и обеспечивать наиболее точное соответствие заданному списку аргументов с учетом ограничений заданного модуля привязки и атрибутов вызова.</summary>
      <param name="name">Имя вызываемого члена. Это может быть конструктор, метод, свойство или поле. Необходимо указать подходящий атрибут вызова. Обратите внимание, что можно вызвать член класса, заданный по умолчанию, передав в качестве имени члена пустую строку.</param>
      <param name="invokeAttr">Атрибут вызова. Это должен быть одноразрядный флаг из <see langword="BindingFlags" />.</param>
      <param name="binder">Объект, позволяющий осуществлять привязку, приведение типов аргументов, вызов элементов, а также поиск объектов <see langword="MemberInfo" /> с помощью отражения. Если указан модуль привязки <see langword="null" />, используется модуль привязки по умолчанию. См. раздел <see cref="T:System.Reflection.Binder" />.</param>
      <param name="target">Объект, для которого следует вызвать указанный член. Если член является статическим, этот параметр игнорируется.</param>
      <param name="args">Список аргументов. Это массив объектов, содержащий число, порядок и тип параметров вызываемого элемента. Если параметров нет, должно быть указано значение NULL.</param>
      <param name="modifiers">Массив с такой же длиной, как у <paramref name="args" /> с элементами, представляющими атрибуты, связанные с аргументами вызываемого члена. Параметр имеет атрибуты, связанные с ним в метаданных. Они используются различными службами взаимодействия. Подробнее об этом см. спецификации метаданных.</param>
      <param name="culture">Экземпляр объекта <see langword="CultureInfo" />, используемого для управления приведением типов. Если параметр имеет значение NULL, для текущего потока используется <see langword="CultureInfo" />. (Обратите внимание, что необходимо, например, преобразовывать строку, представляющую число 1000 в число с удвоенной точностью, поскольку в разных языках и региональных параметрах число 1000 представляется по-разному).</param>
      <param name="namedParameters">Каждый параметр в массиве <paramref name="namedParameters" /> получает значение в соответствующем элементе в массиве <paramref name="args" />. Если длина <paramref name="args" /> превышает длину <paramref name="namedParameters" />, оставшиеся значения аргументов передаются по порядку.</param>
      <returns>Возвращает возвращаемое значение вызываемого члена.</returns>
      <exception cref="T:System.NotSupportedException">В настоящее время этот метод не поддерживается в неполных типах.</exception>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.IsByRefLike" />
    <member name="P:System.Reflection.Emit.EnumBuilder.IsConstructedGenericType">
      <summary>Возвращает значение, указывающее, представляет ли этот данный объект сконструированный универсальный тип.</summary>
      <returns>Значение <see langword="true" />, если этот объект представляет сконструированный универсальный тип; в противном случае — значение <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>Проверяет, определен ли указанный пользовательский атрибут.</summary>
      <param name="attributeType">Объект <see langword="Type" />, к которому применяются настраиваемые атрибуты.</param>
      <param name="inherit">Указывает, следует ли выполнять поиск в цепочке наследования этого члена для нахождения атрибутов.</param>
      <returns>
        <see langword="true" />, если в этом элементе определены один или несколько экземпляров типа <paramref name="attributeType" />, в противном случае <see langword="false" />.</returns>
      <exception cref="T:System.NotSupportedException">В настоящее время этот метод не поддерживается в неполных типах.</exception>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.IsSZArray" />
    <member name="P:System.Reflection.Emit.EnumBuilder.IsTypeDefinition" />
    <member name="P:System.Reflection.Emit.EnumBuilder.IsVariableBoundArray" />
    <member name="M:System.Reflection.Emit.EnumBuilder.MakeArrayType">
      <summary>Возвращает объект <see cref="T:System.Type" />, представляющий одномерный массив текущего типа с нижней границей, равной нулю.</summary>
      <returns>Объект <see cref="T:System.Type" />, представляющий одномерный массив текущего типа с нижней границей, равной нулю.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.MakeArrayType(System.Int32)">
      <summary>Возвращает объект <see cref="T:System.Type" />, представляющий массив текущего типа указанной размерности.</summary>
      <param name="rank">Размерность массива. Это число должно быть меньше либо равно 32.</param>
      <returns>Объект, представляющий массив текущего типа указанной размерности.</returns>
      <exception cref="T:System.IndexOutOfRangeException">Значение параметра <paramref name="rank" /> меньше 1.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.MakeByRefType">
      <summary>Возвращает объект <see cref="T:System.Type" />, который представляет текущий тип при передаче в качестве параметра ref (параметра ByRef в Visual Basic).</summary>
      <returns>Объект <see cref="T:System.Type" />, который представляет текущий тип при передаче в качестве параметра ref (параметра ByRef в Visual Basic).</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.MakePointerType">
      <summary>Возвращает объект <see cref="T:System.Type" />, который представляет указатель на текущий тип.</summary>
      <returns>Объект <see cref="T:System.Type" />, который представляет указатель на текущий тип.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.Module">
      <summary>Возвращает динамический модуль, содержащий определение объекта <see cref="T:System.Reflection.Emit.EnumBuilder" />.</summary>
      <returns>Только для чтения. Динамический модуль, содержащий определение объекта <see cref="T:System.Reflection.Emit.EnumBuilder" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.Name">
      <summary>Возвращает имя данного перечисления.</summary>
      <returns>Только для чтения. Имя данного перечисления.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.Namespace">
      <summary>Возвращает пространство имен данного перечисления.</summary>
      <returns>Только для чтения. Пространство имен данного перечисления.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.ReflectedType">
      <summary>Возвращает тип, который использовался для получения этого объекта <see cref="T:System.Reflection.Emit.EnumBuilder" />.</summary>
      <returns>Только для чтения. Тип, который был использован для получения этого объекта <see cref="T:System.Reflection.Emit.EnumBuilder" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>Задает настраиваемый атрибут с помощью большого двоичного объекта пользовательских атрибутов.</summary>
      <param name="con">Конструктор настраиваемого атрибута.</param>
      <param name="binaryAttribute">Большой двоичный объект байтов, предоставляющий атрибуты.</param>
      <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="con" /> или <paramref name="binaryAttribute" /> — <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>Устанавливает пользовательский атрибут с помощью построителя пользовательских атрибутов.</summary>
      <param name="customBuilder">Экземпляр вспомогательного класса для определения настраиваемого атрибута.</param>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="con" /> имеет значение <see langword="null" />.</exception>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.TypeHandle">
      <summary>Извлекает внутренний дескриптор перечисления.</summary>
      <returns>Только для чтения. Внутренний дескриптор перечисления.</returns>
      <exception cref="T:System.NotSupportedException">Данное свойство в настоящий момент не поддерживается.</exception>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.UnderlyingField">
      <summary>Возвращает основное поле для данного перечисления.</summary>
      <returns>Только для чтения. Основное поле для данного перечисления.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.UnderlyingSystemType">
      <summary>Возвращает основной тип системы для данного перечисления.</summary>
      <returns>Только для чтения. Возвращает базовый системный тип.</returns>
    </member>
    <member name="T:System.Reflection.Emit.EventBuilder">
      <summary>Определяет события для класса.</summary>
    </member>
    <member name="M:System.Reflection.Emit.EventBuilder.AddOtherMethod(System.Reflection.Emit.MethodBuilder)">
      <summary>Добавляет "дополнительный" метод, связанный с данным событием. "Дополнительным" называется метод, который не вызывается при наступлении события и не вызывает событие сам. Эту функцию можно вызывать много раз для добавления нужного числа "дополнительных" методов.</summary>
      <param name="mdBuilder">Объект <see langword="MethodBuilder" />, представляющий "дополнительный" метод.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="mdBuilder" /> — <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> был вызван для включающего типа.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EventBuilder.SetAddOnMethod(System.Reflection.Emit.MethodBuilder)">
      <summary>Устанавливает метод, используемый для подписки на событие.</summary>
      <param name="mdBuilder">Объект <see langword="MethodBuilder" />, представляющий метод, используемый для подписки на данное событие.</param>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="mdBuilder" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> был вызван для включающего типа.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EventBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>Устанавливает пользовательский атрибут с помощью большого двоичного объекта пользовательских атрибутов.</summary>
      <param name="con">Конструктор настраиваемого атрибута.</param>
      <param name="binaryAttribute">Большой двоичный объект байтов, представляющий атрибуты.</param>
      <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="con" /> или <paramref name="binaryAttribute" /> — <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> был вызван для включающего типа.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EventBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>Устанавливает пользовательский атрибут с помощью построителя пользовательских атрибутов.</summary>
      <param name="customBuilder">Экземпляр вспомогательного класса для описания пользовательского атрибута.</param>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="con" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> был вызван для включающего типа.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EventBuilder.SetRaiseMethod(System.Reflection.Emit.MethodBuilder)">
      <summary>Устанавливает метод, используемый для вызова данного события.</summary>
      <param name="mdBuilder">Объект <see langword="MethodBuilder" />, представляющий метод, используемый для вызова данного события.</param>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="mdBuilder" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> был вызван для включающего типа.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EventBuilder.SetRemoveOnMethod(System.Reflection.Emit.MethodBuilder)">
      <summary>Устанавливает метод, используемый для отказа от подписки на событие.</summary>
      <param name="mdBuilder">Объект <see langword="MethodBuilder" />, представляющий метод, используемый для отказа от подписки на данное событие.</param>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="mdBuilder" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> был вызван для включающего типа.</exception>
    </member>
    <member name="T:System.Reflection.Emit.FieldBuilder">
      <summary>Определяет и предоставляет поле. Этот класс не наследуется.</summary>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.Attributes">
      <summary>Указывает атрибуты данного поля. Это свойство доступно только для чтения.</summary>
      <returns>Атрибуты данного поля.</returns>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.DeclaringType">
      <summary>Указывает ссылку на объект <see cref="T:System.Type" /> типа, которым объявлено данное поле. Это свойство доступно только для чтения.</summary>
      <returns>Ссылка на объект <see cref="T:System.Type" /> типа, которым объявлено данное поле.</returns>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.FieldHandle">
      <summary>Указывает внутренний дескриптор метаданных для данного поля. Это свойство доступно только для чтения.</summary>
      <returns>Внутренний дескриптор метаданных для данного поля.</returns>
      <exception cref="T:System.NotSupportedException">Этот метод не поддерживается.</exception>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.FieldType">
      <summary>Указывает объект <see cref="T:System.Type" />, предоставляющий тип данного поля. Это свойство доступно только для чтения.</summary>
      <returns>Объект <see cref="T:System.Type" />, представляющий тип данного поля.</returns>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.GetCustomAttributes(System.Boolean)">
      <summary>Возвращает все пользовательские атрибуты, определенные для данного поля.</summary>
      <param name="inherit">Управляет наследованием пользовательских атрибутов базового класса.</param>
      <returns>Массив объектов <see cref="T:System.Object" />, предоставляющий все пользовательские атрибуты конструктора, который в свою очередь представлен экземпляром объекта <see cref="T:System.Reflection.Emit.FieldBuilder" />.</returns>
      <exception cref="T:System.NotSupportedException">Этот метод не поддерживается.</exception>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>Возвращает все пользовательские атрибуты, определенные для данного поля, идентифицируемого указанным типом.</summary>
      <param name="attributeType">Тип пользовательского атрибута.</param>
      <param name="inherit">Управляет наследованием пользовательских атрибутов базового класса.</param>
      <returns>Массив объектов <see cref="T:System.Object" />, предоставляющий все пользовательские атрибуты конструктора, который в свою очередь представлен экземпляром объекта <see cref="T:System.Reflection.Emit.FieldBuilder" />.</returns>
      <exception cref="T:System.NotSupportedException">Этот метод не поддерживается.</exception>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.GetValue(System.Object)">
      <summary>Извлекает значение поля для указанного объекта.</summary>
      <param name="obj">Объект, к полю которого требуется доступ.</param>
      <returns>Объект <see cref="T:System.Object" />, содержащий значение поля, отражаемого данным экземпляром.</returns>
      <exception cref="T:System.NotSupportedException">Этот метод не поддерживается.</exception>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>Показывает, определен ли для поля атрибут указанного типа.</summary>
      <param name="attributeType">Тип атрибута.</param>
      <param name="inherit">Управляет наследованием пользовательских атрибутов базового класса.</param>
      <returns>
        <see langword="true" />, если для данного поля определен один или несколько экземпляров <paramref name="attributeType" />; в противном случае возвращается <see langword="false" />.</returns>
      <exception cref="T:System.NotSupportedException">В настоящее время этот метод не поддерживается. Можно извлечь поле с помощью метода <see cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" /> и для полученного объекта <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> вызвать метод <see cref="T:System.Reflection.FieldInfo" />.</exception>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.Module">
      <summary>Возвращает модуль, в котором определяется тип, содержащий это поле.</summary>
      <returns>Объект <see cref="T:System.Reflection.Module" />, который представляет динамический модуль, в котором определено это поле.</returns>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.Name">
      <summary>Указывает имя данного поля. Это свойство доступно только для чтения.</summary>
      <returns>Объект <see cref="T:System.String" />, содержащий имя данного поля.</returns>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.ReflectedType">
      <summary>Дает ссылку на объект <see cref="T:System.Type" />, откуда был получен данный объект. Это свойство доступно только для чтения.</summary>
      <returns>Ссылка на объект <see cref="T:System.Type" />, из которого был получен данный экземпляр.</returns>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.SetConstant(System.Object)">
      <summary>Устанавливает значение, присваиваемое полю по умолчанию.</summary>
      <param name="defaultValue">Новое значение, присваиваемое полю по умолчанию.</param>
      <exception cref="T:System.InvalidOperationException">Содержащий тип был создан с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      <exception cref="T:System.ArgumentException">Тип поля не поддерживается.  
-или- 
Тип параметра <paramref name="defaultValue" /> не совпадает с типом поля.  

или - 
Поле имеет тип <see cref="T:System.Object" /> или другой ссылочный тип, значение <paramref name="defaultValue" /> не равно <see langword="null" />, и значение не может быть присвоено ссылочному типу.</exception>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>Задает настраиваемый атрибут с помощью большого двоичного объекта пользовательских атрибутов.</summary>
      <param name="con">Конструктор пользовательского атрибута.</param>
      <param name="binaryAttribute">Большой двоичный объект байтов, предоставляющий атрибуты.</param>
      <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="con" /> или <paramref name="binaryAttribute" /> — <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Родительский тип данного поля закрыт.</exception>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>Устанавливает пользовательский атрибут с помощью построителя пользовательских атрибутов.</summary>
      <param name="customBuilder">Экземпляр вспомогательного класса для определения пользовательского атрибута.</param>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="con" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Родительский тип данного поля закрыт.</exception>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.SetOffset(System.Int32)">
      <summary>Устанавливает расположение поля.</summary>
      <param name="iOffset">Смещение поля внутри содержащего это поле типа.</param>
      <exception cref="T:System.InvalidOperationException">Содержащий тип был создан с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      <exception cref="T:System.ArgumentException">Значение параметра <paramref name="iOffset" /> меньше нуля.</exception>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)">
      <summary>Задает значение поля, которое поддерживается указанным объектом.</summary>
      <param name="obj">Объект, к полю которого требуется доступ.</param>
      <param name="val">Значение, присваиваемое этому полю.</param>
      <param name="invokeAttr">Элемент <see langword="IBinder" />, который указывает желаемый тип связывания (например, IBinder.CreateInstance, IBinder.ExactBinding).</param>
      <param name="binder">Набор свойств и разрешение на связывание, приведение типов аргументов и вызов элементов с помощью отражения. Если для связывателя задано значение null, используется Binder.DefaultBinding.</param>
      <param name="culture">Программные настройки конкретного языка и региональных параметров.</param>
      <exception cref="T:System.NotSupportedException">Этот метод не поддерживается.</exception>
    </member>
    <member name="T:System.Reflection.Emit.GenericTypeParameterBuilder">
      <summary>Определяет и создает параметры универсального типа для динамически определенных универсальных типов и методов. Этот класс не наследуется.</summary>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.Assembly">
      <summary>Возвращает объект <see cref="T:System.Reflection.Assembly" />, представляющий динамическую сборку, содержащую определение универсального типа, к которому принадлежит текущий параметр типа.</summary>
      <returns>Объект <see cref="T:System.Reflection.Assembly" />, представляющий динамическую сборку, содержащую определение универсального типа, к которому принадлежит текущий параметр типа.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.AssemblyQualifiedName">
      <summary>Получает значение <see langword="null" /> во всех случаях.</summary>
      <returns>Пустая ссылка (<see langword="Nothing" /> в Visual Basic) во всех случаях.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.BaseType">
      <summary>Возвращает ограничение базового типа, относящееся к текущему параметру универсального типа.</summary>
      <returns>Объект <see cref="T:System.Type" />, представляющий ограничение базового типа, относящееся к параметру универсального типа, или значение <see langword="null" />, если параметр типа не имеет ограничения базового типа.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.ContainsGenericParameters">
      <summary>Получает значение <see langword="true" /> во всех случаях.</summary>
      <returns>Значение <see langword="true" /> во всех случаях.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.DeclaringMethod">
      <summary>Возвращает метод <see cref="T:System.Reflection.MethodInfo" />, который представляет объявляемый метод, если текущий <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> представляет параметр типа универсального метода.</summary>
      <returns>Метод <see cref="T:System.Reflection.MethodInfo" />, который представляет объявляемый метод, если текущий <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> представляет параметр типа универсального метода; в противном случае — <see langword="null" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.DeclaringType">
      <summary>Возвращает определение универсального типа или определение универсального метода, к которому принадлежит параметр универсального типа.</summary>
      <returns>Если параметр типа принадлежит универсальному типу, объект <see cref="T:System.Type" /> представляет этот универсальный тип; если параметр типа принадлежит универсальному методу, объект <see cref="T:System.Type" /> представляет этот тип, объявивший указанный универсальный метод.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.Equals(System.Object)">
      <summary>Проверяет, является ли данный объект экземпляром <see langword="EventToken" /> и равен ли он текущему экземпляру.</summary>
      <param name="o">Объект для сравнения с текущим экземпляром.</param>
      <returns>Возвращается <see langword="true" />, если <paramref name="o" /> является экземпляром <see langword="EventToken" /> и совпадает с текущим экземпляром; в противном случае возвращается <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.FullName">
      <summary>Получает значение <see langword="null" /> во всех случаях.</summary>
      <returns>Пустая ссылка (<see langword="Nothing" /> в Visual Basic) во всех случаях.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.GenericParameterAttributes">
      <summary>Возвращает сочетание флагов <see cref="T:System.Reflection.GenericParameterAttributes" />, описывающих ковариацию и особые ограничения текущего параметра универсального типа.</summary>
      <returns>Побитовое сочетание значений, которое описывает ковариацию и особые ограничения текущего параметра универсального типа.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.GenericParameterPosition">
      <summary>Возвращает позицию параметра типа в списке параметров типа универсального типа или метода, объявившего об этом параметре.</summary>
      <returns>Позиция параметра типа в списке параметров типа универсального типа или метода, объявившего об этом параметре.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetConstructors(System.Reflection.BindingFlags)">
      <summary>Для неполных параметров универсального типа не поддерживается.</summary>
      <param name="bindingAttr">Не поддерживается.</param>
      <returns>Для неполных параметров универсального типа не поддерживается.</returns>
      <exception cref="T:System.NotSupportedException">Во всех случаях.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetCustomAttributes(System.Boolean)">
      <summary>Для неполных параметров универсального типа не поддерживается.</summary>
      <param name="inherit">Указывает, следует ли выполнять поиск в цепочке наследования этого члена для нахождения атрибутов.</param>
      <returns>Для неполных параметров универсального типа не поддерживается.</returns>
      <exception cref="T:System.NotSupportedException">Во всех случаях.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>Для неполных параметров универсального типа не поддерживается.</summary>
      <param name="attributeType">Тип атрибута для поиска. Возвращаются только те атрибуты, которые можно назначить этому типу.</param>
      <param name="inherit">Указывает, следует ли выполнять поиск в цепочке наследования этого члена для нахождения атрибутов.</param>
      <returns>Для неполных параметров универсального типа не поддерживается.</returns>
      <exception cref="T:System.NotSupportedException">Во всех случаях.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetElementType">
      <summary>Во всех случаях вызывает исключение <see cref="T:System.NotSupportedException" /> .</summary>
      <returns>Тип, на который ссылается текущий тип массива, тип указателя или тип <see langword="ByRef" />; значение <see langword="null" />, если текущий тип не является типом массива или указателя и не передается по ссылке.</returns>
      <exception cref="T:System.NotSupportedException">Во всех случаях.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
      <summary>Для неполных параметров универсального типа не поддерживается.</summary>
      <param name="name">Не поддерживается.</param>
      <param name="bindingAttr">Не поддерживается.</param>
      <returns>Для неполных параметров универсального типа не поддерживается.</returns>
      <exception cref="T:System.NotSupportedException">Во всех случаях.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetEvents">
      <summary>Для неполных параметров универсального типа не поддерживается.</summary>
      <returns>Для неполных параметров универсального типа не поддерживается.</returns>
      <exception cref="T:System.NotSupportedException">Во всех случаях.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetEvents(System.Reflection.BindingFlags)">
      <summary>Для неполных параметров универсального типа не поддерживается.</summary>
      <param name="bindingAttr">Не поддерживается.</param>
      <returns>Для неполных параметров универсального типа не поддерживается.</returns>
      <exception cref="T:System.NotSupportedException">Во всех случаях.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetField(System.String,System.Reflection.BindingFlags)">
      <summary>Для неполных параметров универсального типа не поддерживается.</summary>
      <param name="name">Не поддерживается.</param>
      <param name="bindingAttr">Не поддерживается.</param>
      <returns>Для неполных параметров универсального типа не поддерживается.</returns>
      <exception cref="T:System.NotSupportedException">Во всех случаях.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetFields(System.Reflection.BindingFlags)">
      <summary>Для неполных параметров универсального типа не поддерживается.</summary>
      <param name="bindingAttr">Не поддерживается.</param>
      <returns>Для неполных параметров универсального типа не поддерживается.</returns>
      <exception cref="T:System.NotSupportedException">Во всех случаях.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetGenericArguments">
      <summary>Недопустим для параметров универсального типа.</summary>
      <returns>Недопустим для параметров универсального типа.</returns>
      <exception cref="T:System.InvalidOperationException">Во всех случаях.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetGenericTypeDefinition">
      <summary>Недопустим для параметров универсального типа.</summary>
      <returns>Недопустим для параметров универсального типа.</returns>
      <exception cref="T:System.InvalidOperationException">Во всех случаях.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetHashCode">
      <summary>Возвращает 32-разрядный целочисленный хэш-код для текущего экземпляра.</summary>
      <returns>Хэш-код 32-разрядного целого числа.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetInterface(System.String,System.Boolean)">
      <summary>Для неполных параметров универсального типа не поддерживается.</summary>
      <param name="name">Имя интерфейса.</param>
      <param name="ignoreCase">Значение <see langword="true" /> для поиска без учета регистра; <see langword="false" /> для поиска с учетом регистра.</param>
      <returns>Для неполных параметров универсального типа не поддерживается.</returns>
      <exception cref="T:System.NotSupportedException">Во всех случаях.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetInterfaceMap(System.Type)">
      <summary>Для неполных параметров универсального типа не поддерживается.</summary>
      <param name="interfaceType">Объект <see cref="T:System.Type" />, который представляет тип интерфейса, для которого возвращается сопоставление.</param>
      <returns>Для неполных параметров универсального типа не поддерживается.</returns>
      <exception cref="T:System.NotSupportedException">Во всех случаях.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetInterfaces">
      <summary>Для неполных параметров универсального типа не поддерживается.</summary>
      <returns>Для неполных параметров универсального типа не поддерживается.</returns>
      <exception cref="T:System.NotSupportedException">Во всех случаях.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
      <summary>Для неполных параметров универсального типа не поддерживается.</summary>
      <param name="name">Не поддерживается.</param>
      <param name="type">Не поддерживается.</param>
      <param name="bindingAttr">Не поддерживается.</param>
      <returns>Для неполных параметров универсального типа не поддерживается.</returns>
      <exception cref="T:System.NotSupportedException">Во всех случаях.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetMembers(System.Reflection.BindingFlags)">
      <summary>Для неполных параметров универсального типа не поддерживается.</summary>
      <param name="bindingAttr">Не поддерживается.</param>
      <returns>Для неполных параметров универсального типа не поддерживается.</returns>
      <exception cref="T:System.NotSupportedException">Во всех случаях.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetMethods(System.Reflection.BindingFlags)">
      <summary>Для неполных параметров универсального типа не поддерживается.</summary>
      <param name="bindingAttr">Не поддерживается.</param>
      <returns>Для неполных параметров универсального типа не поддерживается.</returns>
      <exception cref="T:System.NotSupportedException">Во всех случаях.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
      <summary>Для неполных параметров универсального типа не поддерживается.</summary>
      <param name="name">Не поддерживается.</param>
      <param name="bindingAttr">Не поддерживается.</param>
      <returns>Для неполных параметров универсального типа не поддерживается.</returns>
      <exception cref="T:System.NotSupportedException">Во всех случаях.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
      <summary>Для неполных параметров универсального типа не поддерживается.</summary>
      <param name="bindingAttr">Не поддерживается.</param>
      <returns>Для неполных параметров универсального типа не поддерживается.</returns>
      <exception cref="T:System.NotSupportedException">Во всех случаях.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetProperties(System.Reflection.BindingFlags)">
      <summary>Для неполных параметров универсального типа не поддерживается.</summary>
      <param name="bindingAttr">Не поддерживается.</param>
      <returns>Для неполных параметров универсального типа не поддерживается.</returns>
      <exception cref="T:System.NotSupportedException">Во всех случаях.</exception>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.GUID">
      <summary>Для неполных параметров универсального типа не поддерживается.</summary>
      <returns>Для неполных параметров универсального типа не поддерживается.</returns>
      <exception cref="T:System.NotSupportedException">Во всех случаях.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
      <summary>Для неполных параметров универсального типа не поддерживается.</summary>
      <param name="name">Не поддерживается.</param>
      <param name="invokeAttr">Не поддерживается.</param>
      <param name="binder">Не поддерживается.</param>
      <param name="target">Не поддерживается.</param>
      <param name="args">Не поддерживается.</param>
      <param name="modifiers">Не поддерживается.</param>
      <param name="culture">Не поддерживается.</param>
      <param name="namedParameters">Не поддерживается.</param>
      <returns>Для неполных параметров универсального типа не поддерживается.</returns>
      <exception cref="T:System.NotSupportedException">Во всех случаях.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.IsAssignableFrom(System.Type)">
      <summary>Во всех случаях создает исключение <see cref="T:System.NotSupportedException" />.</summary>
      <param name="c">Объект для тестирования.</param>
      <returns>Во всех случаях создает исключение <see cref="T:System.NotSupportedException" />.</returns>
      <exception cref="T:System.NotSupportedException">Во всех случаях.</exception>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsByRefLike" />
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsConstructedGenericType">
      <summary>Возвращает значение, указывающее, представляет ли этот данный объект сконструированный универсальный тип.</summary>
      <returns>Значение <see langword="true" />, если этот объект представляет сконструированный универсальный тип; в противном случае — значение <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>Для неполных параметров универсального типа не поддерживается.</summary>
      <param name="attributeType">Не поддерживается.</param>
      <param name="inherit">Не поддерживается.</param>
      <returns>Для неполных параметров универсального типа не поддерживается.</returns>
      <exception cref="T:System.NotSupportedException">Во всех случаях.</exception>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsGenericParameter">
      <summary>Получает значение <see langword="true" /> во всех случаях.</summary>
      <returns>Значение <see langword="true" /> во всех случаях.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsGenericType">
      <summary>Возвращает значение <see langword="false" /> во всех случаях.</summary>
      <returns>Значение <see langword="false" /> во всех случаях.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsGenericTypeDefinition">
      <summary>Получает значение <see langword="false" /> во всех случаях.</summary>
      <returns>Значение <see langword="false" /> во всех случаях.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.IsSubclassOf(System.Type)">
      <summary>Для неполных параметров универсального типа не поддерживается.</summary>
      <param name="c">Не поддерживается.</param>
      <returns>Для неполных параметров универсального типа не поддерживается.</returns>
      <exception cref="T:System.NotSupportedException">Во всех случаях.</exception>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsSZArray" />
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsTypeDefinition" />
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsVariableBoundArray" />
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.MakeArrayType">
      <summary>Возвращает тип одномерного массива, тип элементов которого является параметром универсального типа.</summary>
      <returns>Объект <see cref="T:System.Type" />, который представляет тип одномерного массива, тип элементов которого равен параметру универсального типа.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.MakeArrayType(System.Int32)">
      <summary>Возвращает тип массива, типом элемента которого является параметр универсального типа с определенным количеством измерений.</summary>
      <param name="rank">Размерность массива.</param>
      <returns>Объект <see cref="T:System.Type" />, который представляет тип массива, тип элементов которого равен параметру универсального типа с указанным количеством измерений.</returns>
      <exception cref="T:System.IndexOutOfRangeException">
        <paramref name="rank" /> не является допустимым количеством измерений. Например, значение меньше 1.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.MakeByRefType">
      <summary>Возвращает объект <see cref="T:System.Type" />, который представляет текущий параметр универсального типа при передаче его в качестве параметра ссылки.</summary>
      <returns>Объект <see cref="T:System.Type" />, который представляет текущий параметр универсального типа при передаче его в качестве параметра ссылки.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.MakeGenericType(System.Type[])">
      <summary>Недопустим для неполных параметров универсального типа.</summary>
      <param name="typeArguments">Массив аргументов типа.</param>
      <returns>Этот метод является недопустимым для неполных параметров универсального типа.</returns>
      <exception cref="T:System.InvalidOperationException">Во всех случаях.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.MakePointerType">
      <summary>Возвращает объект <see cref="T:System.Type" />, который представляет указатель на текущий параметра универсального типа.</summary>
      <returns>Объект <see cref="T:System.Type" />, который представляет указатель на текущий параметра универсального типа.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.Module">
      <summary>Возвращает динамический модуль, содержащий параметр универсального типа.</summary>
      <returns>Объект <see cref="T:System.Reflection.Module" />, который представляет динамический модуль, содержащий параметр общего типа.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.Name">
      <summary>Возвращает имя параметра универсального типа.</summary>
      <returns>Имя универсального параметра типа.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.Namespace">
      <summary>Получает значение <see langword="null" /> во всех случаях.</summary>
      <returns>Пустая ссылка (<see langword="Nothing" /> в Visual Basic) во всех случаях.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.ReflectedType">
      <summary>Возвращает объект <see cref="T:System.Type" />, который использовался для получения <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</summary>
      <returns>Объект <see cref="T:System.Type" />, который использовался для получения <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.SetBaseTypeConstraint(System.Type)">
      <summary>Задает базовый тип, который должен наследоваться типом, чтобы быть замещенным для параметра типа.</summary>
      <param name="baseTypeConstraint">Тип <see cref="T:System.Type" />, который должен быть унаследован любым типом, который должен быть замещенным для параметра типа.</param>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>Задает настраиваемый атрибут с помощью большого двоичного объекта пользовательских атрибутов.</summary>
      <param name="con">Конструктор настраиваемого атрибута.</param>
      <param name="binaryAttribute">Большой двоичный объект байтов, предоставляющий атрибут.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> — <see langword="null" />.  

или - 
Массив <paramref name="binaryAttribute" /> является нулевой ссылкой.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>Задает настраиваемый атрибут с помощью построителя настраиваемых атрибутов.</summary>
      <param name="customBuilder">Экземпляр вспомогательного класса для определения пользовательского атрибута.</param>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="customBuilder" /> имеет значение <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes(System.Reflection.GenericParameterAttributes)">
      <summary>Задает дисперсию характеристик и специальные ограничения универсального параметра, такие как ограничение конструктора без параметров.</summary>
      <param name="genericParameterAttributes">Побитовая комбинация значений <see cref="T:System.Reflection.GenericParameterAttributes" />, которая представляет дисперсные характеристики и специальные ограничения текущего параметра универсального типа.</param>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.SetInterfaceConstraints(System.Type[])">
      <summary>Задает интерфейсы, которые должны быть реализованы типом, чтобы быть замещенным параметром типа.</summary>
      <param name="interfaceConstraints">Массив объектов <see cref="T:System.Type" />, который представляет интерфейсы, которые должен реализовать тип, чтобы быть замещенным параметром типа.</param>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.ToString">
      <summary>Возвращает представление строки текущего параметра универсального типа.</summary>
      <returns>Строка, которая содержит имя параметра универсального типа.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.TypeHandle">
      <summary>Для неполных параметров универсального типа не поддерживается.</summary>
      <returns>Для неполных параметров универсального типа не поддерживается.</returns>
      <exception cref="T:System.NotSupportedException">Во всех случаях.</exception>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.UnderlyingSystemType">
      <summary>Возвращает текущий параметр универсального типа.</summary>
      <returns>Текущий объект <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> .</returns>
    </member>
    <member name="T:System.Reflection.Emit.MethodBuilder">
      <summary>Определяет и предоставляет метод (или конструктор) для динамического класса.</summary>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.Attributes">
      <summary>Извлекает атрибуты данного метода.</summary>
      <returns>Только для чтения. Извлекает перечисление <see langword="MethodAttributes" /> данного метода.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.CallingConvention">
      <summary>Возвращает соглашение о вызовах данного метода.</summary>
      <returns>Только для чтения. Соглашение о вызовах метода.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.ContainsGenericParameters">
      <summary>Не поддерживается для этого типа.</summary>
      <returns>Не поддерживается.</returns>
      <exception cref="T:System.NotSupportedException">Вызванный метод не поддерживается в базовом классе.</exception>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.DeclaringType">
      <summary>Возвращает тип, которым объявлен данный метод.</summary>
      <returns>Только для чтения. Тип, объявляющий этот метод.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
      <summary>Задает количество параметров универсального типа для текущего метода, определяет их имена и возвращает массив объектов <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />, которые могут использоваться для определения ограничений.</summary>
      <param name="names">Массив строк, который представляет имена параметров универсального типа.</param>
      <returns>Массив объектов <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />, представляющий параметры типа универсального метода.</returns>
      <exception cref="T:System.InvalidOperationException">Для этого метода уже были определены параметры универсального типа.  

или - 
Метод уже завершен.  

или - 
Метод <see cref="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)" /> был вызван для текущего метода.</exception>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="names" /> имеет значение <see langword="null" />.  

или - 
Элемент <paramref name="names" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="names" /> является пустым массивом.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
      <summary>Задает атрибуты параметров и имя параметра этого метода или возвращаемого значения данного метода. Возвращает ParameterBuilder, который можно использовать для применения настраиваемых атрибутов.</summary>
      <param name="position">Позиция параметра в списке параметров. Параметры индексируются, начиная с номера 1 для первого параметра; число 0 представляет возвращаемое значение метода.</param>
      <param name="attributes">Атрибуты параметра.</param>
      <param name="strParamName">Имя параметра. Имя может быть пустой строкой.</param>
      <returns>Возвращает объект <see langword="ParameterBuilder" />, представляющий параметр этого метода или возвращаемое значение этого метода.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">Метод не имеет параметров.  

или - 
Значение параметра <paramref name="position" /> меньше нуля.  

или - 
<paramref name="position" /> превышает число параметров метода.</exception>
      <exception cref="T:System.InvalidOperationException">Содержащий тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
-или- 
Для текущего метода свойство <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> имеет значение <see langword="true" />, но свойство <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> имеет значение <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.Equals(System.Object)">
      <summary>Определяет, идентичен ли указанный объект данному экземпляру.</summary>
      <param name="obj">Объект, который следует сравнить с этим экземпляром <see langword="MethodBuilder" />.</param>
      <returns>
        <see langword="true" />, если <paramref name="obj" /> является экземпляром <see langword="MethodBuilder" /> и равен этому объекту, в противном случае — <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetBaseDefinition">
      <summary>Возвращает базовую реализацию метода.</summary>
      <returns>Базовая реализация данного метода.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Boolean)">
      <summary>Возвращает все пользовательские атрибуты, определенные для данного метода.</summary>
      <param name="inherit">Указывает, следует ли для поиска пользовательских атрибутов просматривать цепочку наследования данного члена.</param>
      <returns>Возвращает массив объектов, предоставляющий все пользовательские атрибуты данного метода.</returns>
      <exception cref="T:System.NotSupportedException">В настоящее время этот метод не поддерживается. Чтобы извлечь метод, можно воспользоваться методом <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> и для полученного объекта <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> вызвать <see cref="T:System.Reflection.MethodInfo" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>Возвращает пользовательские атрибуты, идентифицируемые заданным типом.</summary>
      <param name="attributeType">Тип пользовательского атрибута.</param>
      <param name="inherit">Указывает, следует ли для поиска пользовательских атрибутов просматривать цепочку наследования данного члена.</param>
      <returns>Возвращает массив объектов, предоставляющих атрибуты типа <paramref name="attributeType" /> данного метода.</returns>
      <exception cref="T:System.NotSupportedException">В настоящее время этот метод не поддерживается. Чтобы извлечь метод, можно воспользоваться методом <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> и для полученного объекта <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> вызвать <see cref="T:System.Reflection.MethodInfo" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetGenericArguments">
      <summary>Возвращает массив объектов <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />, которые представляют параметры типа метода, если последний является универсальным.</summary>
      <returns>Массив объектов <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />, представляющих параметры типа, если метод является универсальным, или значение <see langword="null" />, если метод не является универсальным.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition">
      <summary>Возвращает этот метод.</summary>
      <returns>Текущий экземпляр <see cref="T:System.Reflection.Emit.MethodBuilder" />.</returns>
      <exception cref="T:System.InvalidOperationException">Текущий метод не является универсальным. То есть свойство <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> возвращает значение <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetHashCode">
      <summary>Получает хэш-код данного метода.</summary>
      <returns>Хэш-код данного метода.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetILGenerator">
      <summary>Возвращает объект <see langword="ILGenerator" /> данного метода с используемым по умолчанию 64-байтным потоком языка MSIL.</summary>
      <returns>Возвращает объект <see langword="ILGenerator" /> данного метода.</returns>
      <exception cref="T:System.InvalidOperationException">Метод не должен содержать основной текст из-за флагов <see cref="T:System.Reflection.MethodAttributes" /> и <see cref="T:System.Reflection.MethodImplAttributes" />, например потому, что выставлен флаг <see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" />.  

или - 
Этот метод является универсальным, но не является определением универсального метода. То есть значение свойства <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> равно <see langword="true" />, однако значение свойства <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> равно <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetILGenerator(System.Int32)">
      <summary>Возвращает объект <see langword="ILGenerator" /> данного метода с заданным размером потока языка MSIL.</summary>
      <param name="size">Размер потока языка MSIL в байтах.</param>
      <returns>Возвращает объект <see langword="ILGenerator" /> данного метода.</returns>
      <exception cref="T:System.InvalidOperationException">Метод не должен содержать основной текст из-за флагов <see cref="T:System.Reflection.MethodAttributes" /> и <see cref="T:System.Reflection.MethodImplAttributes" />, например потому, что выставлен флаг <see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" />.  

или - 
Этот метод является универсальным, но не является определением универсального метода. То есть значение свойства <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> равно <see langword="true" />, однако значение свойства <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> равно <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags">
      <summary>Возвращает флаги реализации метода.</summary>
      <returns>Возвращает флаги реализации метода.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetParameters">
      <summary>Возвращает параметры данного метода.</summary>
      <returns>Массив объектов <see langword="ParameterInfo" />, предоставляющих параметры данного метода.</returns>
      <exception cref="T:System.NotSupportedException">В настоящее время этот метод не поддерживается. Чтобы извлечь метод, можно воспользоваться методом <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> и для полученного объекта <see langword="GetParameters" /> вызвать <see cref="T:System.Reflection.MethodInfo" />.</exception>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.InitLocals">
      <summary>Возвращает или задает логическое значение, которое определяет, инициализированы ли с нуля локальные переменные в этом методе. По умолчанию этому свойству присваивается значение <see langword="true" />.</summary>
      <returns>Значение <see langword="true" />, если локальные переменные в этом методе инициализируются с нуля, в противном случае — <see langword="false" />.</returns>
      <exception cref="T:System.InvalidOperationException">Для текущего метода свойство <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> имеет значение <see langword="true" />, но свойство <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> имеет значение <see langword="false" />. (Возвращает или задает).</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
      <summary>Вызывает динамически метод, отражаемый данным экземпляром для заданного объекта, передавая при этом указанные параметры и учитывая ограничения, накладываемые связывателем.</summary>
      <param name="obj">Объект, для которого следует вызвать указанный метод. Если метод является статическим, данный параметр не обрабатывается.</param>
      <param name="invokeAttr">Это должен быть одноразрядный флаг из <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" /> и так далее.</param>
      <param name="binder">Объект, позволяющий осуществлять связывание, приведение типов аргументов, вызов элементов, а также извлечение объектов MemberInfo посредством отражения. Если модуль привязки имеет значение <see langword="null" />, используется модуль привязки по умолчанию. Дополнительные сведения см. в разделе <see cref="T:System.Reflection.Binder" />.</param>
      <param name="parameters">Список аргументов. Массив аргументов, число, порядок и тип которых соответствует параметрам вызываемого метода. При отсутствии параметров — <see langword="null" />.</param>
      <param name="culture">Экземпляр объекта <see cref="T:System.Globalization.CultureInfo" />, используемого для управления приведением типов. Если значение параметра — NULL, для текущего потока используется <see cref="T:System.Globalization.CultureInfo" /> . (Обратите внимание, что необходимо, к примеру, преобразовывать объект <see cref="T:System.String" />, представляющий 1000, в значение <see cref="T:System.Double" />, поскольку в разных языках и региональных параметрах 1000 представляется по-разному).</param>
      <returns>Возвращает объект, содержащий значение возвращаемое, вызванным методом.</returns>
      <exception cref="T:System.NotSupportedException">В настоящее время этот метод не поддерживается. Чтобы извлечь метод, можно воспользоваться методом <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> и для полученного объекта <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> вызвать <see cref="T:System.Reflection.MethodInfo" />.</exception>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.IsConstructedGenericMethod" />
    <member name="M:System.Reflection.Emit.MethodBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>Проверяет, определен ли указанный пользовательский атрибут.</summary>
      <param name="attributeType">Тип пользовательского атрибута.</param>
      <param name="inherit">Указывает, следует ли для поиска пользовательских атрибутов просматривать цепочку наследования данного члена.</param>
      <returns>
        <see langword="true" />, если указанный пользовательский атрибут определен; в противном случае — <see langword="false" />.</returns>
      <exception cref="T:System.NotSupportedException">В настоящее время этот метод не поддерживается. Чтобы извлечь метод, можно воспользоваться методом <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> и для полученного объекта <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> вызвать <see cref="T:System.Reflection.MethodInfo" />.</exception>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod">
      <summary>Возвращает значение, указывающее, является ли этот метод универсальным методом.</summary>
      <returns>Значение <see langword="true" />, если объект является универсальным; в противном случае — <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition">
      <summary>Возвращает значение, указывающее, представляет ли текущий объект <see cref="T:System.Reflection.Emit.MethodBuilder" /> определение универсального метода.</summary>
      <returns>Значение <see langword="true" />, если текущий объект <see cref="T:System.Reflection.Emit.MethodBuilder" /> представляет определение универсального метода; в противном случае — <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.IsSecurityCritical">
      <summary>Во всех случаях вызывает исключение <see cref="T:System.NotSupportedException" />.</summary>
      <returns>Во всех случаях вызывает исключение <see cref="T:System.NotSupportedException" />.</returns>
      <exception cref="T:System.NotSupportedException">Во всех случаях. Это свойство не поддерживается в динамических сборках.</exception>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.IsSecuritySafeCritical">
      <summary>Во всех случаях вызывает исключение <see cref="T:System.NotSupportedException" />.</summary>
      <returns>Во всех случаях вызывает исключение <see cref="T:System.NotSupportedException" />.</returns>
      <exception cref="T:System.NotSupportedException">Во всех случаях. Это свойство не поддерживается в динамических сборках.</exception>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.IsSecurityTransparent">
      <summary>Во всех случаях вызывает исключение <see cref="T:System.NotSupportedException" />.</summary>
      <returns>Во всех случаях вызывает исключение <see cref="T:System.NotSupportedException" />.</returns>
      <exception cref="T:System.NotSupportedException">Во всех случаях. Это свойство не поддерживается в динамических сборках.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
      <summary>Возвращает универсальный метод, сконструированный на основе текущего определения универсального метода с помощью определенных аргументов универсального типа.</summary>
      <param name="typeArguments">Массив объектов <see cref="T:System.Type" />, который представляет тип аргументов для универсального метода.</param>
      <returns>Метод <see cref="T:System.Reflection.MethodInfo" />, представляющий универсальный метод, который был сконструирован на основе текущего определения универсального метода с помощью определенных аргументов универсального типа.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.MethodHandle">
      <summary>Извлекает внутренний маркер метода. Этот дескриптор используется для доступа к основному дескриптору метаданных.</summary>
      <returns>Только для чтения. Внутренний дескриптор метода. Этот дескриптор используется для доступа к основному дескриптору метаданных.</returns>
      <exception cref="T:System.NotSupportedException">В настоящее время этот метод не поддерживается. Чтобы извлечь метод, можно воспользоваться методом <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> и для полученного объекта <see cref="P:System.Reflection.MethodBase.MethodHandle" /> вызвать <see cref="T:System.Reflection.MethodInfo" />.</exception>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.Module">
      <summary>Возвращает модуль, в котором определяется текущий метод.</summary>
      <returns>Модуль <see cref="T:System.Reflection.Module" />, в котором определяется элемент, представленный текущим <see cref="T:System.Reflection.MemberInfo" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.Name">
      <summary>Извлекает имя данного метода.</summary>
      <returns>Только для чтения. Извлекает строку, содержащую простое имя метода.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.ReflectedType">
      <summary>Возвращает класс, который использовался при отражении для извлечения данного объекта.</summary>
      <returns>Только для чтения. Тип, который использовался для извлечения данного метода.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.ReturnParameter">
      <summary>Получает объект <see cref="T:System.Reflection.ParameterInfo" />, который содержит сведения о типе возвращаемого значения этого метода, например: имеет ли возвращаемый тип пользовательские модификаторы.</summary>
      <returns>Объект <see cref="T:System.Reflection.ParameterInfo" />, содержащий сведения о типе возвращаемого значения.</returns>
      <exception cref="T:System.InvalidOperationException">Объявленный тип не был создан.</exception>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.ReturnType">
      <summary>Возвращает тип возвращаемого значения метода, предоставленного этим объектом <see cref="T:System.Reflection.Emit.MethodBuilder" />.</summary>
      <returns>Тип возвращаемых данных метода.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.ReturnTypeCustomAttributes">
      <summary>Возвращает пользовательские атрибуты типа возвращаемого значения этого метода.</summary>
      <returns>Только для чтения. Пользовательские атрибуты типа возвращаемого значения этого метода.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>Задает настраиваемый атрибут с помощью большого двоичного объекта пользовательских атрибутов.</summary>
      <param name="con">Конструктор настраиваемого атрибута.</param>
      <param name="binaryAttribute">Большой двоичный объект байтов, предоставляющий атрибуты.</param>
      <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="con" /> или <paramref name="binaryAttribute" /> — <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Для текущего метода свойство <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> имеет значение <see langword="true" />, но свойство <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> имеет значение <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>Устанавливает пользовательский атрибут с помощью построителя пользовательских атрибутов.</summary>
      <param name="customBuilder">Экземпляр вспомогательного класса для описания пользовательского атрибута.</param>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="customBuilder" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Для текущего метода свойство <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> имеет значение <see langword="true" />, но свойство <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> имеет значение <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
      <summary>Устанавливает флаги реализации метода для данного метода.</summary>
      <param name="attributes">Флаги реализации, которые следует установить.</param>
      <exception cref="T:System.InvalidOperationException">Содержащий тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  

или - 
Для текущего метода свойство <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> имеет значение <see langword="true" />, но свойство <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> имеет значение <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
      <summary>Задает количество и типы параметров для метода.</summary>
      <param name="parameterTypes">Массив объектов <see cref="T:System.Type" />, представляющий типы параметров.</param>
      <exception cref="T:System.InvalidOperationException">Текущий метод является универсальным, однако не является определением универсального метода. То есть значение свойства <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> равно <see langword="true" />, однако значение свойства <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> равно <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
      <summary>Задает тип возвращаемого значения метода.</summary>
      <param name="returnType">Объект <see cref="T:System.Type" />, который представляет тип возвращаемого значения метода.</param>
      <exception cref="T:System.InvalidOperationException">Текущий метод является универсальным, однако не является определением универсального метода. То есть значение свойства <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> равно <see langword="true" />, однако значение свойства <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> равно <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
      <summary>Задает сигнатуру метода, включая тип возвращаемого значения, типы параметров, а также требуемые и необязательные пользовательские модификаторы типа возвращаемых значений и типов параметров.</summary>
      <param name="returnType">Тип возвращаемых данных метода.</param>
      <param name="returnTypeRequiredCustomModifiers">Массив типов, представляющих обязательные настраиваемые модификаторы, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />, для возвращаемого типа метода. Если возвращаемый тип не содержит требуемых настраиваемых модификаторов, укажите <see langword="null" />.</param>
      <param name="returnTypeOptionalCustomModifiers">Массив типов, представляющих необязательные настраиваемые модификаторы, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />, для возвращаемого типа метода. Если возвращаемый тип не содержит необязательные настраиваемые модификаторы, укажите <see langword="null" />.</param>
      <param name="parameterTypes">Типы параметров метода.</param>
      <param name="parameterTypeRequiredCustomModifiers">Массив массивов типов. Каждый массив типов представляет обязательные настраиваемые модификаторы для соответствующего параметра, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />. Если определенный параметр не имеет обязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива массивов. Если ни один из параметров не имеет обязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива массивов.</param>
      <param name="parameterTypeOptionalCustomModifiers">Массив массивов типов. Каждый массив типов представляет необязательные настраиваемые модификаторы для соответствующего параметра, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />. Если определенный параметр не имеет необязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива массивов. Если ни один из параметров не имеет необязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива типов.</param>
      <exception cref="T:System.InvalidOperationException">Текущий метод является универсальным, однако не является определением универсального метода. То есть значение свойства <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> равно <see langword="true" />, однако значение свойства <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> равно <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.ToString">
      <summary>Возвращает экземпляр <see langword="MethodBuilder" /> в виде строки.</summary>
      <returns>Возвращает строку, содержащую имя, атрибуты, подпись метода, исключения и локальную подпись данного метода, за которыми следует поток инструкций языка MSIL.</returns>
    </member>
    <member name="T:System.Reflection.Emit.ModuleBuilder">
      <summary>Определяет и представляет модуль в динамической сборке.</summary>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.Assembly">
      <summary>Получает динамическую сборку, определившую данный экземпляр <see cref="T:System.Reflection.Emit.ModuleBuilder" />.</summary>
      <returns>Динамическая сборка, определившая текущий динамический модуль.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions">
      <summary>Завершает определения глобальной функции и глобальных данных для этого динамического модуля.</summary>
      <exception cref="T:System.InvalidOperationException">Данный метод был вызван ранее.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
      <summary>Определяет тип перечисления, который является типом значения с одним нестатическим полем, называемым <paramref name="value__" /> указанного типа.</summary>
      <param name="name">Полный путь к типу перечисления. Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</param>
      <param name="visibility">Атрибуты типа данного перечисления. Атрибутами являются любые биты, определенные с помощью <see cref="F:System.Reflection.TypeAttributes.VisibilityMask" />.</param>
      <param name="underlyingType">Базовый тип данного перечисления. Это должен быть встроенный целочисленный тип.</param>
      <returns>Определенное перечисление.</returns>
      <exception cref="T:System.ArgumentException">Переданы атрибуты, не являющиеся атрибутами видимости.  

или - 
Перечисление с указанным именем существует в родительской сборке этого модуля.  

-или- 
Атрибуты видимости не соответствуют области действия перечисления. Например, если в качестве значения параметра <paramref name="visibility" /> указано <see cref="F:System.Reflection.TypeAttributes.NestedPublic" />, но перечисление не относится к вложенному типу.</exception>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
      <summary>Определяет глобальный метод с данными именем, атрибутами, соглашениями о вызовах, возвращаемыми типами и типами параметров.</summary>
      <param name="name">Имя метода. Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</param>
      <param name="attributes">Атрибуты метода. Параметр <paramref name="attributes" /> должен включать атрибут <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
      <param name="callingConvention">Соглашение о вызовах для метода.</param>
      <param name="returnType">Тип возвращаемых данных метода.</param>
      <param name="parameterTypes">Типы параметров метода.</param>
      <returns>Определенный глобальный метод.</returns>
      <exception cref="T:System.ArgumentException">Метод не является статическим. То есть параметр <paramref name="attributes" /> не включает <see cref="F:System.Reflection.MethodAttributes.Static" />.  

или - 
Элементом массива <see cref="T:System.Type" /> является <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> — <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> был вызван ранее.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
      <summary>Определяет глобальный метод с данными именем, атрибутами, соглашениями о вызовах, возвращаемым типом, пользовательскими модификаторами для возвращаемого типа, типами параметров и пользовательскими модификаторами для типов параметров.</summary>
      <param name="name">Имя метода. Параметр <paramref name="name" /> не должен содержать внедренные символы NULL.</param>
      <param name="attributes">Атрибуты метода. Параметр <paramref name="attributes" /> должен включать атрибут <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
      <param name="callingConvention">Соглашение о вызовах для метода.</param>
      <param name="returnType">Тип возвращаемых данных метода.</param>
      <param name="requiredReturnTypeCustomModifiers">Массив типов представляет собой требуемые пользовательские модификаторы для возвращаемого типа, например <see cref="T:System.Runtime.CompilerServices.IsConst" /> или <see cref="T:System.Runtime.CompilerServices.IsBoxed" />. Если возвращаемый тип не содержит требуемых настраиваемых модификаторов, укажите <see langword="null" />.</param>
      <param name="optionalReturnTypeCustomModifiers">Массив типов представляет собой необязательные пользовательские модификаторы для возвращаемого типа, например <see cref="T:System.Runtime.CompilerServices.IsConst" /> или <see cref="T:System.Runtime.CompilerServices.IsBoxed" />. Если возвращаемый тип не содержит необязательные настраиваемые модификаторы, укажите <see langword="null" />.</param>
      <param name="parameterTypes">Типы параметров метода.</param>
      <param name="requiredParameterTypeCustomModifiers">Массив массивов типов. Каждый массив типов представляет собой требуемые пользовательские модификаторы для соответствующего параметра глобального метода. Если определенный аргумент не содержит требуемые пользовательские модификаторы, вместо массива данных укажите <see langword="null" />. Если глобальный метод не содержит аргументов или если аргументы не содержат пользовательские модификаторы, укажите значение <see langword="null" /> вместо массива массивов.</param>
      <param name="optionalParameterTypeCustomModifiers">Массив массивов типов. Каждый массив типов представляет собой необязательные пользовательские модификаторы для соответствующего параметра. Если определенный аргумент не содержит необязательные пользовательские модификаторы, вместо массива данных укажите <see langword="null" />. Если глобальный метод не содержит аргументов или если аргументы не содержат необязательные пользовательские модификаторы, укажите значение <see langword="null" /> вместо массива массивов.</param>
      <returns>Определенный глобальный метод.</returns>
      <exception cref="T:System.ArgumentException">Метод не является статическим. То есть параметр <paramref name="attributes" /> не включает <see cref="F:System.Reflection.MethodAttributes.Static" />.  

или - 
Элементом массива <see cref="T:System.Type" /> является <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> — <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> вызывался до этого.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
      <summary>Определяет глобальный метод с данными именем, атрибутами, возвращаемыми типами и типами параметров.</summary>
      <param name="name">Имя метода. Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</param>
      <param name="attributes">Атрибуты метода. Параметр <paramref name="attributes" /> должен включать атрибут <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
      <param name="returnType">Тип возвращаемых данных метода.</param>
      <param name="parameterTypes">Типы параметров метода.</param>
      <returns>Определенный глобальный метод.</returns>
      <exception cref="T:System.ArgumentException">Метод не является статическим. То есть параметр <paramref name="attributes" /> не включает <see cref="F:System.Reflection.MethodAttributes.Static" />.  

или - 
Длина параметра <paramref name="name" /> равна нулю. 
или - 
Элементом массива <see cref="T:System.Type" /> является <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> был вызван ранее.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
      <summary>Определяет инициализированное поле данных в разделе .sdata переносимого исполняемого PE-файла.</summary>
      <param name="name">Имя, используемое для ссылки на данные. Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</param>
      <param name="data">Большой двоичный объект (BLOB) данных.</param>
      <param name="attributes">Атрибуты поля. Значение по умолчанию — <see langword="Static" />.</param>
      <returns>Поле для ссылки на данные.</returns>
      <exception cref="T:System.ArgumentException">Длина параметра <paramref name="name" /> равна нулю.  

или - 
Размер параметра <paramref name="data" /> меньше или равен нулю, либо больше или равен 0x3f0000.</exception>
      <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="name" /> или <paramref name="data" /> — <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> был вызван ранее.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
      <summary>Определяет метод <see langword="PInvoke" /> с заданными именем, именем DLL-библиотеки, в котором этот метод определен, атрибутами метода, соглашением о вызовах, возвращаемым типом, типами параметров метода и флагами <see langword="PInvoke" />.</summary>
      <param name="name">Имя метода <see langword="PInvoke" />. Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</param>
      <param name="dllName">Имя библиотеки DLL, в которой определен метод <see langword="PInvoke" />.</param>
      <param name="attributes">Атрибуты метода.</param>
      <param name="callingConvention">Соглашение о вызове метода.</param>
      <param name="returnType">Возвращаемый тип метода.</param>
      <param name="parameterTypes">Типы параметров метода.</param>
      <param name="nativeCallConv">Собственное соглашение о вызове.</param>
      <param name="nativeCharSet">Собственная кодировка метода.</param>
      <returns>Определенный метод <see langword="PInvoke" />.</returns>
      <exception cref="T:System.ArgumentException">Метод не является статическим или вмещающий тип является интерфейсом.  
 -или-  
 Метод является абстрактным.  
 -или-  
 Метод был определен ранее.</exception>
      <exception cref="T:System.ArgumentNullException">Параметр <paramref name="name" /> или <paramref name="dllName" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Содержащий тип был создан ранее с помощью метода <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
      <summary>Определяет метод <see langword="PInvoke" /> с заданными именем, именем DLL-библиотеки, в котором этот метод определен, атрибутами метода, соглашением о вызовах, возвращаемым типом, типами параметров метода и флагами <see langword="PInvoke" />.</summary>
      <param name="name">Имя метода <see langword="PInvoke" />. Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</param>
      <param name="dllName">Имя библиотеки DLL, в которой определен метод <see langword="PInvoke" />.</param>
      <param name="entryName">Имя точки входа в библиотеке DLL.</param>
      <param name="attributes">Атрибуты метода.</param>
      <param name="callingConvention">Соглашение о вызове метода.</param>
      <param name="returnType">Возвращаемый тип метода.</param>
      <param name="parameterTypes">Типы параметров метода.</param>
      <param name="nativeCallConv">Собственное соглашение о вызове.</param>
      <param name="nativeCharSet">Собственная кодировка метода.</param>
      <returns>Определенный метод <see langword="PInvoke" />.</returns>
      <exception cref="T:System.ArgumentException">Метод не является статическим или вмещающий тип является интерфейсом, или метод является абстрактным, или метод был определен ранее.</exception>
      <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="name" /> или <paramref name="dllName" /> — <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Содержащий тип был создан ранее с помощью метода <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)">
      <summary>Создает объект <see langword="TypeBuilder" /> для закрытого типа с указанным в этом модуле именем.</summary>
      <param name="name">Полный путь к типу, включая пространство имен. Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</param>
      <returns>Закрытый тип с указанным именем.</returns>
      <exception cref="T:System.ArgumentException">Тип с данным именем существует в родительской сборке этого модуля.  

или -  

 Атрибуты вложенного типа установлены для типа, который не является вложенным.</exception>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)">
      <summary>Конструирует <see langword="TypeBuilder" /> с заданными именем и атрибутами типа.</summary>
      <param name="name">Полный путь к типу. Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</param>
      <param name="attr">Атрибуты определенного в результате типа.</param>
      <returns>Объект <see langword="TypeBuilder" />, созданный с учетом всех запрошенных атрибутов.</returns>
      <exception cref="T:System.ArgumentException">Тип с данным именем существует в родительской сборке этого модуля.  

или -  

 Атрибуты вложенного типа установлены для типа, который не является вложенным.</exception>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
      <summary>Конструирует <see langword="TypeBuilder" /> с заданным именем, атрибутами и типом, который расширяет определенный тип.</summary>
      <param name="name">Полный путь к типу. Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</param>
      <param name="attr">Атрибут, который будет связан с типом.</param>
      <param name="parent">Тип, расширяющий определенный тип.</param>
      <returns>Объект <see langword="TypeBuilder" />, созданный с учетом всех запрошенных атрибутов.</returns>
      <exception cref="T:System.ArgumentException">Тип с данным именем существует в родительской сборке этого модуля.  

или -  

 Атрибуты вложенного типа установлены для типа, который не является вложенным.</exception>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
      <summary>Конструирует <see langword="TypeBuilder" /> с заданными именем, атрибутами, типом, который расширяет определенный тип, и общим размером типа.</summary>
      <param name="name">Полный путь к типу. Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</param>
      <param name="attr">Атрибуты определенного в результате типа.</param>
      <param name="parent">Тип, расширяющий определенный тип.</param>
      <param name="typesize">Общий размер типа.</param>
      <returns>Объект <see langword="TypeBuilder" />.</returns>
      <exception cref="T:System.ArgumentException">Тип с данным именем существует в родительской сборке этого модуля.  

или -  

 Атрибуты вложенного типа установлены для типа, который не является вложенным.</exception>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
      <summary>Конструирует <see langword="TypeBuilder" /> с заданными именем, атрибутами, типом, который расширяет определенный тип, и размером упаковки типа.</summary>
      <param name="name">Полный путь к типу. Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</param>
      <param name="attr">Атрибуты определенного в результате типа.</param>
      <param name="parent">Тип, расширяющий определенный тип.</param>
      <param name="packsize">Размер упаковки типа.</param>
      <returns>Объект <see langword="TypeBuilder" />.</returns>
      <exception cref="T:System.ArgumentException">Тип с данным именем существует в родительской сборке этого модуля.  
 -или-  
 Атрибуты вложенного типа установлены для типа, который не является вложенным.</exception>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
      <summary>Конструирует <see langword="TypeBuilder" /> с заданными именем, атрибутами, типом, который расширяет определенный тип, а также размером уплотнения и общим размером определенного типа.</summary>
      <param name="name">Полный путь к типу. Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</param>
      <param name="attr">Атрибуты определенного в результате типа.</param>
      <param name="parent">Тип, расширяющий определенный тип.</param>
      <param name="packingSize">Размер упаковки типа.</param>
      <param name="typesize">Общий размер типа.</param>
      <returns>Объект <see langword="TypeBuilder" />, созданный с учетом всех запрошенных атрибутов.</returns>
      <exception cref="T:System.ArgumentException">Тип с данным именем существует в родительской сборке этого модуля.  
 -или-  
 Атрибуты вложенного типа установлены для типа, который не является вложенным.</exception>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
      <summary>Конструирует <see langword="TypeBuilder" /> с заданными именем, атрибутами, типом, который расширяет определенный тип, и интерфейсами, реализующими этот тип.</summary>
      <param name="name">Полный путь к типу. Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</param>
      <param name="attr">Атрибуты, которые будут связаны с типом.</param>
      <param name="parent">Тип, расширяющий определенный тип.</param>
      <param name="interfaces">Список интерфейсов, реализуемых типом.</param>
      <returns>Объект <see langword="TypeBuilder" />, созданный с учетом всех запрошенных атрибутов.</returns>
      <exception cref="T:System.ArgumentException">Тип с данным именем существует в родительской сборке этого модуля.  
 -или-  
 Атрибуты вложенного типа установлены для типа, который не является вложенным.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> — <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
      <summary>Определяет неинициализированное поле данных в разделе .sdata переносимого исполняемого PE-файла.</summary>
      <param name="name">Имя, используемое для ссылки на данные. Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</param>
      <param name="size">Размер поля данных.</param>
      <param name="attributes">Атрибуты поля.</param>
      <returns>Поле для ссылки на данные.</returns>
      <exception cref="T:System.ArgumentException">Длина параметра <paramref name="name" /> равна нулю.  
-или- 
 Значение <paramref name="size" /> меньше или равно нулю либо больше или равно 0x003f0000.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> — <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> был вызван ранее.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.Equals(System.Object)">
      <summary>Возвращает значение, указывающее, равен ли данный экземпляр указанному объекту.</summary>
      <param name="obj">Объект, сравниваемый с этим экземпляром, или значение <see langword="null" />.</param>
      <returns>
        <see langword="true" />, если значение параметра <paramref name="obj" /> равно типу и значению данного экземпляра; в противном случае — <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.FullyQualifiedName">
      <summary>Получает значение типа <see langword="String" />, предоставляющее полное имя и путь для данного модуля.</summary>
      <returns>Полное имя модуля.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
      <summary>Возвращает именованный метод класса массива.</summary>
      <param name="arrayClass">Класс массива.</param>
      <param name="methodName">Имя метода класса массива.</param>
      <param name="callingConvention">Соглашение о вызове метода.</param>
      <param name="returnType">Тип возвращаемых данных метода.</param>
      <param name="parameterTypes">Типы параметров метода.</param>
      <returns>Именованный метод класса массива.</returns>
      <exception cref="T:System.ArgumentException">Параметр <paramref name="arrayClass" /> не является массивом.</exception>
      <exception cref="T:System.ArgumentNullException">Параметр <paramref name="arrayClass" /> или <paramref name="methodName" /> имеет значение <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Boolean)">
      <summary>Возвращает все настраиваемые атрибуты, которые были применены к текущему <see cref="T:System.Reflection.Emit.ModuleBuilder" />.</summary>
      <param name="inherit">Данный аргумент не учитывается для объектов этого типа.</param>
      <returns>Массив, содержащий настраиваемые атрибуты; массив является пустым, если атрибуты отсутствуют.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>Возвращает настраиваемые атрибуты, примененные к текущему <see cref="T:System.Reflection.Emit.ModuleBuilder" />, которые являются производными от указанного типа атрибута.</summary>
      <param name="attributeType">Базовый тип, от которого наследуют атрибуты.</param>
      <param name="inherit">Данный аргумент не учитывается для объектов этого типа.</param>
      <returns>Массив, содержащий настраиваемые атрибуты, происходящие (на любом уровне) от <paramref name="attributeType" />; если массив пуст, таких атрибутов нет.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="attributeType" /> — <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="attributeType" /> не является объектом <see cref="T:System.Type" />, предоставляемым средой выполнения. Например, <paramref name="attributeType" /> является объектом <see cref="T:System.Reflection.Emit.TypeBuilder" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributesData">
      <summary>Возвращает сведения об атрибутах, примененных к текущему объекту <see cref="T:System.Reflection.Emit.ModuleBuilder" />; сведения представляют собой объекты <see cref="T:System.Reflection.CustomAttributeData" />.</summary>
      <returns>Универсальный список объектов <see cref="T:System.Reflection.CustomAttributeData" />, представляющих данные об атрибутах, которые были применены к текущему модулю.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetField(System.String,System.Reflection.BindingFlags)">
      <summary>Возвращает поле уровня модуля, определенное в области .sdata переносимого исполняемого файла (PE) с данными именем и атрибутами привязки.</summary>
      <param name="name">Имя поля.</param>
      <param name="bindingAttr">Комбинация двоичных флагов привязки <see langword="BindingFlags" />, используемых для управления поиском.</param>
      <returns>Поле, имеющее заданное имя и атрибуты привязки, либо значение <see langword="null" />, если поле не существует.</returns>
      <exception cref="T:System.ArgumentNullException">Параметр <paramref name="name" /> имеет значение <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetFields(System.Reflection.BindingFlags)">
      <summary>Возвращает все поля, определенные в области .sdata переносимого исполняемого файла (PE), соответствующие заданным флагам привязки.</summary>
      <param name="bindingFlags">Комбинация двоичных флагов привязки <see langword="BindingFlags" />, используемых для управления поиском.</param>
      <returns>Массив полей, соответствующих заданным флагам; если таких полей нет, массив пуст.</returns>
      <exception cref="T:System.ArgumentNullException">Параметр <paramref name="name" /> имеет значение <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetHashCode">
      <summary>Возвращает хэш-код данного экземпляра.</summary>
      <returns>Хэш-код в виде 32-разрядного целого числа со знаком.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetMethods(System.Reflection.BindingFlags)">
      <summary>Возвращает все методы, которые определены на уровне модуля для текущего объекта <see cref="T:System.Reflection.Emit.ModuleBuilder" /> и соответствуют указанным флагам привязки.</summary>
      <param name="bindingFlags">Комбинация двоичных флагов привязки <see langword="BindingFlags" />, используемых для управления поиском.</param>
      <returns>Массив, который содержит все методы уровня модуля, соответствующие <paramref name="bindingFlags" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)">
      <summary>Возвращает пару значений, определяющих природу кода в модуле и платформе, на которой применяется этот модуль.</summary>
      <param name="peKind">Этот метод возвращает сочетание значений <see cref="T:System.Reflection.PortableExecutableKinds" />, определяющее характер кода в модуле.</param>
      <param name="machine">Этот метод возвращает одно из значений <see cref="T:System.Reflection.ImageFileMachine" />, определяющее платформу, на которой применяется модуль.</param>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String)">
      <summary>Получает именованный тип, определенный в модуле.</summary>
      <param name="className">Имя получаемого объекта <see cref="T:System.Type" />.</param>
      <returns>Запрошенный тип, если тип определен в данном модуле, в противном случае — значение <see langword="null" />.</returns>
      <exception cref="T:System.ArgumentException">Длина параметра <paramref name="className" /> равна нулю или больше 1023.</exception>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="className" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.Security.SecurityException">Запрошенный объект <see cref="T:System.Type" /> не является открытым и вызывающая сторона не имеет разрешения (<see cref="T:System.Security.Permissions.ReflectionPermission" />) на отражение неоткрытых объектов за пределами текущей сборки.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Инициализатор класса вызывается и создает исключение.</exception>
      <exception cref="T:System.TypeLoadException">При загрузке объекта <see cref="T:System.Type" /> произошла ошибка.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)">
      <summary>Получает определенный в модуле именованный тип (с возможностью игнорирования регистра символов в имени типа).</summary>
      <param name="className">Имя получаемого объекта <see cref="T:System.Type" />.</param>
      <param name="ignoreCase">Если значение <see langword="true" />, при поиске не учитывается регистр. Если значение <see langword="false" />, при поиске учитывается регистр.</param>
      <returns>Запрошенный тип, если тип определен в данном модуле, в противном случае — значение <see langword="null" />.</returns>
      <exception cref="T:System.ArgumentException">Длина параметра <paramref name="className" /> равна нулю или больше 1023.</exception>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="className" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.Security.SecurityException">Запрошенный объект <see cref="T:System.Type" /> не является открытым и вызывающая сторона не имеет разрешения (<see cref="T:System.Security.Permissions.ReflectionPermission" />) на отражение неоткрытых объектов за пределами текущей сборки.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Инициализатор класса вызывается и создает исключение.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
      <summary>Получает определенный в модуле именованный тип (с возможностью игнорирования регистра символов в имени типа). Позволяет указать, следует ли создавать исключение, если тип не будет найден.</summary>
      <param name="className">Имя получаемого объекта <see cref="T:System.Type" />.</param>
      <param name="throwOnError">Значение <see langword="true" />, чтобы создать исключение, если тип не удается найти; значение <see langword="false" />, чтобы вернуть значение <see langword="null" />.</param>
      <param name="ignoreCase">Если значение <see langword="true" />, при поиске не учитывается регистр. Если значение <see langword="false" />, при поиске учитывается регистр.</param>
      <returns>Заданный тип, если тип объявлен в данном модуле, в противном случае — значение <see langword="null" />.</returns>
      <exception cref="T:System.ArgumentException">Длина параметра <paramref name="className" /> равна нулю или больше 1023.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="className" /> — <see langword="null" />.</exception>
      <exception cref="T:System.Security.SecurityException">Запрошенный объект <see cref="T:System.Type" /> не является открытым и вызывающая сторона не имеет разрешения (<see cref="T:System.Security.Permissions.ReflectionPermission" />) на отражение неоткрытых объектов за пределами текущей сборки.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Инициализатор класса вызывается и создает исключение.</exception>
      <exception cref="T:System.TypeLoadException">Значение параметра <paramref name="throwOnError" /> равно <see langword="true" />, и указанный тип не был найден.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetTypes">
      <summary>Возвращаются все классы, определенные в данном модуле.</summary>
      <returns>Массив, содержащий типы, которые определены в модуле, отражаемом данным экземпляром.</returns>
      <exception cref="T:System.Reflection.ReflectionTypeLoadException">Невозможно загрузить один или несколько классов в модуле.</exception>
      <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>Возвращает значение, обозначающее, применен ли к этому модулю указанный тип атрибутов.</summary>
      <param name="attributeType">Тип настраиваемого атрибута для проверки.</param>
      <param name="inherit">Данный аргумент не учитывается для объектов этого типа.</param>
      <returns>Значение <see langword="true" />, если к этому модулю применен один или несколько экземпляров <paramref name="attributeType" />, в противном случае — значение <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="attributeType" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="attributeType" /> не является объектом <see cref="T:System.Type" />, предоставляемым средой выполнения. Например, <paramref name="attributeType" /> является объектом <see cref="T:System.Reflection.Emit.TypeBuilder" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.IsResource">
      <summary>Возвращает значение, указывающее, является ли объект ресурсом.</summary>
      <returns>Значение <see langword="true" />, если объект является ресурсом; в обратном случае — значение <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.MDStreamVersion">
      <summary>Возвращает версию потока метаданных.</summary>
      <returns>32-разрядное целое число, представляющее версию потока метаданных. Два байта старшего разряда представляют основной номер версии, а два байта младшего разряда — дополнительный.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.MetadataToken">
      <summary>Получает токен, который определяет текущий динамический модуль в метаданных.</summary>
      <returns>Целочисленный токен, который идентифицирует текущий модуль в метаданных.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.ModuleVersionId">
      <summary>Возвращает универсальный уникальный идентификатор (UUID), по которому можно различить две версии модуля.</summary>
      <returns>Значение свойства <see cref="T:System.Guid" />, по которому можно различить две версии модуля.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.Name">
      <summary>Строка, указывающая, что это модуль, расположенный в памяти.</summary>
      <returns>Текст, указывающий, что это модуль, расположенный в памяти.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
      <summary>Возвращает поле, определенное заданным токеном метаданных, в контексте, определенном заданными параметрами универсального типа.</summary>
      <param name="metadataToken">токен метаданных, определяющий поле в модуле.</param>
      <param name="genericTypeArguments">Массив объектов <see cref="T:System.Type" />, представляющих аргументы типа для данного типа, если токен находится в области, либо значение <see langword="null" />, если этот тип не является универсальным.</param>
      <param name="genericMethodArguments">Массив объектов <see cref="T:System.Type" />, представляющих аргументы типа для метода, если токен находится в области, либо значение <see langword="null" />, если этот метод не является универсальным.</param>
      <returns>Объект <see cref="T:System.Reflection.FieldInfo" />, представляющий поле, которое определяется заданным токеном метаданных.</returns>
      <exception cref="T:System.ArgumentException">Параметр <paramref name="metadataToken" /> не является маркером для поля в области текущего модуля.  
-или- 
 Параметр <paramref name="metadataToken" /> определяет поле, родительская спецификация <see langword="TypeSpec" /> которого имеет подпись, содержащую сведения о типе элемента <see langword="var" /> (параметр типа для универсального типа) или <see langword="mvar" /> (параметр типа для универсального метода), а для метода <paramref name="genericTypeArguments" /> или <paramref name="genericMethodArguments" /> не предоставлены необходимые аргументы типа.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="metadataToken" /> не является допустимым маркером для поля в области текущего модуля.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
      <summary>Возвращает тип или член, которые определены заданным токеном метаданных, в контексте, определенном заданными параметрами универсального типа.</summary>
      <param name="metadataToken">токен метаданных, определяющий тип или член в модуле.</param>
      <param name="genericTypeArguments">Массив объектов <see cref="T:System.Type" />, представляющих аргументы типа для данного типа, если токен находится в области, либо значение <see langword="null" />, если этот тип не является универсальным.</param>
      <param name="genericMethodArguments">Массив объектов <see cref="T:System.Type" />, представляющих аргументы типа для метода, если токен находится в области, либо значение <see langword="null" />, если этот метод не является универсальным.</param>
      <returns>Объект <see cref="T:System.Reflection.MemberInfo" />, представляющий тип члена, который определяется заданным токеном метаданных.</returns>
      <exception cref="T:System.ArgumentException">Параметр <paramref name="metadataToken" /> не является маркером для типа или члена в области текущего модуля.  

или - 
Параметр <paramref name="metadataToken" /> является объектом <see langword="MethodSpec" /> или <see langword="TypeSpec" />, подпись которого содержит сведения о типе элемента <see langword="var" /> (параметр типа для универсального типа) или <see langword="mvar" /> (параметр типа для универсального метода), а для метода <paramref name="genericTypeArguments" /> или <paramref name="genericMethodArguments" /> не предоставлены необходимые аргументы типа.  

или - 
Параметр <paramref name="metadataToken" /> определяет свойство или событие.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="metadataToken" /> не является допустимым маркером для поля в области текущего модуля.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
      <summary>Возвращает метод или конструктор, определенный заданным маркером метаданных, в контексте, определенном заданными параметрами универсального типа.</summary>
      <param name="metadataToken">маркер метаданных, определяющий метод или конструктор в модуле.</param>
      <param name="genericTypeArguments">Массив объектов <see cref="T:System.Type" />, представляющих аргументы типа для данного типа, если токен находится в области, либо значение <see langword="null" />, если этот тип не является универсальным.</param>
      <param name="genericMethodArguments">Массив объектов <see cref="T:System.Type" />, представляющих аргументы типа для метода, если токен находится в области, либо значение <see langword="null" />, если этот метод не является универсальным.</param>
      <returns>Объект <see cref="T:System.Reflection.MethodBase" />, представляющий метод, определенный заданным токеном метаданных.</returns>
      <exception cref="T:System.ArgumentException">Параметр <paramref name="metadataToken" /> не является маркером для метода или конструктора в области текущего модуля.  
-или- 
 Параметр <paramref name="metadataToken" /> является объектом <see langword="MethodSpec" />, сигнатура которого содержит сведения о типе элемента <see langword="var" /> (параметр типа для универсального типа) или <see langword="mvar" /> (параметр типа для универсального метода), а для <paramref name="genericTypeArguments" />, <paramref name="genericMethodArguments" /> или обоих параметров не предоставлены необходимые аргументы типа.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="metadataToken" /> не является допустимым маркером для поля в области текущего модуля.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.ResolveSignature(System.Int32)">
      <summary>Возвращает большой двоичный объект подписи, определенный токеном метаданных.</summary>
      <param name="metadataToken">токен метаданных, определяющий подпись в модуле.</param>
      <returns>Массив байтов, представляющий большой двоичный объект подписи.</returns>
      <exception cref="T:System.ArgumentException">Параметр <paramref name="metadataToken" /> не является допустимым объектом <see langword="MemberRef" />, <see langword="MethodDef" />, <see langword="TypeSpec" />, сигнатурой или маркером <see langword="FieldDef" /> в области видимости текущего модуля.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="metadataToken" /> не является допустимым маркером для поля в области текущего модуля.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.ResolveString(System.Int32)">
      <summary>Возвращает строку, определенную заданным маркером метаданных.</summary>
      <param name="metadataToken">маркер метаданных, определяющий строку в куче строк модуля.</param>
      <returns>Объект <see cref="T:System.String" />, содержащий строковое значение из кучи строк метаданных.</returns>
      <exception cref="T:System.ArgumentException">Параметр <paramref name="metadataToken" /> не является маркером для строки в области текущего модуля.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="metadataToken" /> не является допустимым маркером для поля в области текущего модуля.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
      <summary>Возвращает тип, определенный заданным токеном метаданных, в контексте, определенном заданными параметрами универсального типа.</summary>
      <param name="metadataToken">Маркер метаданных, который определяет тип в модуле.</param>
      <param name="genericTypeArguments">Массив объектов <see cref="T:System.Type" />, представляющих аргументы типа для данного типа, если токен находится в области, либо значение <see langword="null" />, если этот тип не является универсальным.</param>
      <param name="genericMethodArguments">Массив объектов <see cref="T:System.Type" />, представляющих аргументы типа для метода, если токен находится в области, либо значение <see langword="null" />, если этот метод не является универсальным.</param>
      <returns>Объект <see cref="T:System.Type" />, представляющий тип, который определяется заданным токеном метаданных.</returns>
      <exception cref="T:System.ArgumentException">Параметр <paramref name="metadataToken" /> не является маркером для типа в области текущего модуля.  

или - 
Параметр <paramref name="metadataToken" /> является объектом <see langword="TypeSpec" />, сигнатура которого содержит сведения о типе элемента <see langword="var" /> (параметр типа для универсального типа) или <see langword="mvar" /> (параметр типа для универсального метода), а для <paramref name="genericTypeArguments" />, <paramref name="genericMethodArguments" /> или обоих параметров не предоставлены необходимые аргументы типа.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="metadataToken" /> не является допустимым маркером для поля в области текущего модуля.</exception>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.ScopeName">
      <summary>Получает строку, представляющую имя динамического модуля.</summary>
      <returns>Имя динамического модуля.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>Устанавливает пользовательский атрибут для этого модуля с помощью указанного большого двоичного объекта (BLOB), представляющего атрибут.</summary>
      <param name="con">Конструктор настраиваемого атрибута.</param>
      <param name="binaryAttribute">Большой двоичный объект байтов, представляющий атрибут.</param>
      <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="con" /> или <paramref name="binaryAttribute" /> — <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>Применяет к модулю настраиваемый атрибут с помощью построителя настраиваемых атрибутов.</summary>
      <param name="customBuilder">Экземпляр вспомогательного класса для определения применяемого пользовательского атрибута.</param>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="customBuilder" /> имеет значение <see langword="null" />.</exception>
    </member>
    <member name="T:System.Reflection.Emit.PropertyBuilder">
      <summary>Определяет свойства для типа.</summary>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.AddOtherMethod(System.Reflection.Emit.MethodBuilder)">
      <summary>Добавляет один из дополнительных методов, связанных с данным свойством.</summary>
      <param name="mdBuilder">Объект <see langword="MethodBuilder" />, представляющий "дополнительный" метод.</param>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="mdBuilder" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> был вызван для включающего типа.</exception>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.Attributes">
      <summary>Получает атрибуты данного свойства.</summary>
      <returns>Атрибуты данного свойства.</returns>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.CanRead">
      <summary>Получает значение, указывающее, можно ли выполнить считывание данного свойства.</summary>
      <returns>Значение <see langword="true" />, если свойство доступно для чтения; в противном случае — значение <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.CanWrite">
      <summary>Получает значение, указывающее, можно ли производить запись в данное свойство.</summary>
      <returns>Значение <see langword="true" />, если свойство доступно для записи; в обратном случае — значение <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.DeclaringType">
      <summary>Получает класс, объявляющий этот член.</summary>
      <returns>Объект <see langword="Type" /> для класса, объявляющего данный член.</returns>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetAccessors(System.Boolean)">
      <summary>Возвращает массив открытых и неоткрытых методов доступа <see langword="get" /> и <see langword="set" /> данного свойства.</summary>
      <param name="nonPublic">Указывает, должны ли в массиве элементов <see langword="MethodInfo" /> возвращаться методы, не являющиеся открытыми. <see langword="true" />, если неоткрытые методы должны быть включены; в противном случае — <see langword="false" />.</param>
      <returns>Массив элементов типа <see langword="MethodInfo" />, содержащий соответствующие открытые и неоткрытые методы доступа или пустой массив, если у данного свойства методы доступа отсутствуют.</returns>
      <exception cref="T:System.NotSupportedException">Этот метод не поддерживается.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetCustomAttributes(System.Boolean)">
      <summary>Возвращает массив, содержащий все пользовательские атрибуты данного свойства.</summary>
      <param name="inherit">Если этот параметр равен <see langword="true" />, для поиска пользовательских атрибутов просматривается цепочка наследования данного свойства.</param>
      <returns>Массив, содержащий все пользовательские атрибуты.</returns>
      <exception cref="T:System.NotSupportedException">Этот метод не поддерживается.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>Возвращает массив пользовательских атрибутов, идентифицируемых типом <see cref="T:System.Type" />.</summary>
      <param name="attributeType">Массив пользовательских атрибутов, идентифицируемых типом.</param>
      <param name="inherit">Если этот параметр равен <see langword="true" />, для поиска пользовательских атрибутов просматривается цепочка наследования данного свойства.</param>
      <returns>Массив пользовательских атрибутов, определенных для данного отраженного элемента или <see langword="null" />, если ни одного атрибута для данного элемента не определено.</returns>
      <exception cref="T:System.NotSupportedException">Этот метод не поддерживается.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetGetMethod(System.Boolean)">
      <summary>Возвращает открытый и неоткрытый метод доступа get данного свойства.</summary>
      <param name="nonPublic">Указывает, должны ли возвращаться методы доступа get, не являющиеся открытыми. <see langword="true" />, если неоткрытые методы должны быть включены; в противном случае — <see langword="false" />.</param>
      <returns>Если параметр <paramref name="nonPublic" /> равен <see langword="MethodInfo" />, возвращается объект <see langword="true" />, предоставляющий метод доступа get данного свойства. Если параметр <paramref name="nonPublic" /> равен <see langword="null" /> и метод доступа get является неоткрытым, или параметр <paramref name="nonPublic" /> равен <see langword="false" />, но метод доступа get отсутствует, возвращается <see langword="true" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetIndexParameters">
      <summary>Возвращает массив, содержащий все индексные параметры данного свойства.</summary>
      <returns>Массив элементов типа <see langword="ParameterInfo" />, содержащий параметры для индексов.</returns>
      <exception cref="T:System.NotSupportedException">Этот метод не поддерживается.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetSetMethod(System.Boolean)">
      <summary>Возвращает метод доступа для этого свойства.</summary>
      <param name="nonPublic">Указывает, должен ли возвращаться метод доступа, если он не является открытым. <see langword="true" />, если неоткрытые методы должны быть включены; в противном случае — <see langword="false" />.</param>
      <returns>Метод свойства <see langword="Set" /> или <see langword="null" />, как показано в следующей таблице.  
  Значение 
  Условие 
  Объект <see cref="T:System.Reflection.MethodInfo" />, который предоставляет метод Set для этого свойства.  

  Метод доступа является открытым.  

 <paramref name="nonPublic" /> имеет значение True, а закрытые методы могут быть возвращены.  

  null 
 <paramref name="nonPublic" /> имеет значение True, но свойство доступно только для чтения.  

 <paramref name="nonPublic" /> имеет значение False, а метод доступа не является открытым.</returns>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetValue(System.Object,System.Object[])">
      <summary>Получает значение индексированного свойства через вызов метода чтения данного свойства.</summary>
      <param name="obj">Объект, свойство которого будет возвращено.</param>
      <param name="index">Необязательные значения индекса для индексированных свойств. Для неиндексированных свойств это значение должно быть равно <see langword="null" />.</param>
      <returns>Значение указанного индексированного свойства.</returns>
      <exception cref="T:System.NotSupportedException">Этот метод не поддерживается.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetValue(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
      <summary>Получает значение свойства в соответствии с указанными связыванием, индексом и объектом <see langword="CultureInfo" />.</summary>
      <param name="obj">Объект, свойство которого будет возвращено.</param>
      <param name="invokeAttr">Атрибут вызова. Должен представлять собой двоичный флаг из набора <see langword="BindingFlags" />: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="Static" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> или <see langword="SetProperty" />. Необходимо указать подходящий атрибут вызова. Если требуется вызвать статический элемент, следует установить флаг <see langword="Static" /> объекта <see langword="BindingFlags" />.</param>
      <param name="binder">Объект, позволяющий осуществлять привязку, приведение типов аргументов, вызов элементов, а также поиск объектов <see langword="MemberInfo" /> с помощью отражения. Если значение параметра <paramref name="binder" /> равно <see langword="null" />, используется связыватель по умолчанию.</param>
      <param name="index">Необязательные значения индекса для индексированных свойств. Для неиндексированных свойств это значение должно быть равно <see langword="null" />.</param>
      <param name="culture">Объект <see langword="CultureInfo" />, представляющий язык и региональные параметры, для которых должен быть локализован ресурс. Обратите внимание, что в случае, если ресурс не локализован на данном языке, при поиске соответствия будет последовательно вызываться метод <see langword="CultureInfo.Parent" />. Если данное значение равно <see langword="null" />, объект <see langword="CultureInfo" /> извлекается из свойства <see langword="CultureInfo.CurrentUICulture" />.</param>
      <returns>Значение свойства для <paramref name="obj" />.</returns>
      <exception cref="T:System.NotSupportedException">Этот метод не поддерживается.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>Указывает, определен ли для данного свойства один или несколько экземпляров типа, задаваемого параметром <paramref name="attributeType" />.</summary>
      <param name="attributeType">Объект <see langword="Type" />, к которому применяются настраиваемые атрибуты.</param>
      <param name="inherit">Указывает, следует ли для поиска пользовательских атрибутов просматривать цепочку наследования данного свойства.</param>
      <returns>Возвращается значение <see langword="true" />, если для данного свойства определен один или несколько экземпляров типа, задаваемого параметром <paramref name="attributeType" />; в противном случае возвращается <see langword="false" />.</returns>
      <exception cref="T:System.NotSupportedException">Этот метод не поддерживается.</exception>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.Module">
      <summary>Возвращает модуль, в котором определяется тип, объявляющий текущее свойство.</summary>
      <returns>Модуль <see cref="T:System.Reflection.Module" />, в котором определяется тип, объявляющий текущее свойство.</returns>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.Name">
      <summary>Получает имя данного элемента.</summary>
      <returns>Объект <see cref="T:System.String" />, содержащий имя данного элемента.</returns>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.PropertyType">
      <summary>Возвращает тип поля данного свойства.</summary>
      <returns>Тип свойства.</returns>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.ReflectedType">
      <summary>Получает объект класса, который использовался для извлечения данного экземпляра объекта <see langword="MemberInfo" />.</summary>
      <returns>Объект <see langword="Type" />, с помощью которого был получен данный объект <see langword="MemberInfo" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetConstant(System.Object)">
      <summary>Устанавливает значение, присваиваемое свойству по умолчанию.</summary>
      <param name="defaultValue">Значение, принимаемое данным свойством по умолчанию.</param>
      <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> был вызван для включающего типа.</exception>
      <exception cref="T:System.ArgumentException">Тип свойства не является поддерживаемым.  
-или- 
Тип параметра <paramref name="defaultValue" /> не совпадает с типом свойства.  

или - 
Свойство имеет тип <see cref="T:System.Object" /> или другой ссылочный тип, значение <paramref name="defaultValue" /> не равно <see langword="null" />, и значение не может быть присвоено ссылочному типу.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>Устанавливает пользовательский атрибут с помощью большого двоичного объекта пользовательских атрибутов.</summary>
      <param name="con">Конструктор настраиваемого атрибута.</param>
      <param name="binaryAttribute">Большой двоичный объект байтов, представляющий атрибуты.</param>
      <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="con" /> или <paramref name="binaryAttribute" /> — <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> был вызван для включающего типа.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>Задает настраиваемый атрибут с помощью построителя настраиваемых атрибутов.</summary>
      <param name="customBuilder">Экземпляр вспомогательного класса для определения настраиваемого атрибута.</param>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="customBuilder" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> был вызван для включающего типа.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetGetMethod(System.Reflection.Emit.MethodBuilder)">
      <summary>Устанавливает метод, который получает значение свойства.</summary>
      <param name="mdBuilder">Объект <see langword="MethodBuilder" />, предоставляющий метод, который получает значение свойства.</param>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="mdBuilder" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> был вызван для включающего типа.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetSetMethod(System.Reflection.Emit.MethodBuilder)">
      <summary>Устанавливает метод, который задает значение свойства.</summary>
      <param name="mdBuilder">Объект <see langword="MethodBuilder" />, предоставляющий метод, который задает значение свойства.</param>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="mdBuilder" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> был вызван для включающего типа.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetValue(System.Object,System.Object,System.Object[])">
      <summary>Задает значение свойства с необязательными значениями индекса для свойств индекса.</summary>
      <param name="obj">Объект, значение свойства которого будет установлено.</param>
      <param name="value">Новое значение для этого свойства.</param>
      <param name="index">Необязательные значения индекса для индексированных свойств. Для неиндексированных свойств это значение должно быть равно <see langword="null" />.</param>
      <exception cref="T:System.NotSupportedException">Этот метод не поддерживается.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
      <summary>Устанавливает указанное значение для свойства указанного объекта.</summary>
      <param name="obj">Объект, свойство которого будет возвращено.</param>
      <param name="value">Новое значение для этого свойства.</param>
      <param name="invokeAttr">Атрибут вызова. Должен представлять собой двоичный флаг из набора <see langword="BindingFlags" />: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="Static" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> или <see langword="SetProperty" />. Необходимо указать подходящий атрибут вызова. Если требуется вызвать статический элемент, следует установить флаг <see langword="Static" /> объекта <see langword="BindingFlags" />.</param>
      <param name="binder">Объект, позволяющий осуществлять привязку, приведение типов аргументов, вызов элементов, а также поиск объектов <see langword="MemberInfo" /> с помощью отражения. Если значение параметра <paramref name="binder" /> равно <see langword="null" />, используется связыватель по умолчанию.</param>
      <param name="index">Необязательные значения индекса для индексированных свойств. Для неиндексированных свойств это значение должно быть равно <see langword="null" />.</param>
      <param name="culture">Объект <see langword="CultureInfo" />, представляющий язык и региональные параметры, для которых должен быть локализован ресурс. Обратите внимание, что в случае, если ресурс не локализован на данном языке, при поиске соответствия будет последовательно вызываться метод <see langword="CultureInfo.Parent" />. Если данное значение равно <see langword="null" />, объект <see langword="CultureInfo" /> извлекается из свойства <see langword="CultureInfo.CurrentUICulture" />.</param>
      <exception cref="T:System.NotSupportedException">Этот метод не поддерживается.</exception>
    </member>
    <member name="T:System.Reflection.Emit.TypeBuilder">
      <summary>Определяет и создает новые экземпляры классов во время выполнения.</summary>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)">
      <summary>Добавляет интерфейс, реализуемый данным типом.</summary>
      <param name="interfaceType">Интерфейс, реализуемый данным типом.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="interfaceType" /> — <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.Assembly">
      <summary>Извлекает динамическую сборку, которая содержит определение данного типа.</summary>
      <returns>Только для чтения. Извлекает динамическую сборку, которая содержит определение данного типа.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName">
      <summary>Возвращает полное имя этого типа, дополненное отображаемым именем сборки.</summary>
      <returns>Только для чтения. Полное имя этого типа, дополненное отображаемым именем сборки.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.BaseType">
      <summary>Возвращает базовый тип этого типа.</summary>
      <returns>Только для чтения. Возвращает базовый тип этого типа.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.CreateType">
      <summary>Создает объект <see cref="T:System.Type" /> для этого класса. После определения полей и методов в классе вызывается метод <see langword="CreateType" /> для загрузки его объекта <see langword="Type" />.</summary>
      <returns>Возвращает новый объект <see cref="T:System.Type" /> для этого класса.</returns>
      <exception cref="T:System.InvalidOperationException">Включающий тип не создан.  

или -  

 Этот тип не является абстрактным, а содержит абстрактный метод.  

или -  

 Этот тип не является абстрактным классом или интерфейсом, а содержит метод без тела метода.</exception>
      <exception cref="T:System.NotSupportedException">Тип содержит неверный код на языке MSIL.  

или -  

 Конечный адрес ветвления задан с использованием однобайтового смещения, но он находится на расстоянии более 127 байт от ветви.</exception>
      <exception cref="T:System.TypeLoadException">Не удалось загрузить тип. Например, он содержит метод <see langword="static" />, имеющий соглашение о вызовах <see cref="F:System.Reflection.CallingConventions.HasThis" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.CreateTypeInfo">
      <summary>Получает объект <see cref="T:System.Reflection.TypeInfo" />, представляющий этот тип.</summary>
      <returns>Объект, представляющий этот тип.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.DeclaringMethod">
      <summary>Возвращает метод, который объявил текущий параметр универсального типа.</summary>
      <returns>Объект <see cref="T:System.Reflection.MethodBase" />, представляющий метод, который объявил текущий тип, если текущий тип является параметром универсального типа; в противном случае — <see langword="null" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.DeclaringType">
      <summary>Возвращает тип, объявивший этот тип.</summary>
      <returns>Только для чтения. Тип, объявивший этот тип.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
      <summary>Добавляет в тип новый конструктор с заданными атрибутами и сигнатурой.</summary>
      <param name="attributes">Атрибуты конструктора.</param>
      <param name="callingConvention">Соглашение о вызовах конструктора.</param>
      <param name="parameterTypes">Типы параметров конструктора.</param>
      <returns>Определенный конструктор.</returns>
      <exception cref="T:System.InvalidOperationException">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
      <summary>Добавляет в тип новый конструктор с заданными атрибутами, сигнатурой и настраиваемыми модификаторами.</summary>
      <param name="attributes">Атрибуты конструктора.</param>
      <param name="callingConvention">Соглашение о вызовах конструктора.</param>
      <param name="parameterTypes">Типы параметров конструктора.</param>
      <param name="requiredCustomModifiers">Массив массивов типов. Каждый массив типов представляет обязательные настраиваемые модификаторы для соответствующего параметра, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />. Если определенный параметр не имеет обязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива массивов. Если ни один из параметров не имеет обязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива массивов.</param>
      <param name="optionalCustomModifiers">Массив массивов типов. Каждый массив типов представляет необязательные настраиваемые модификаторы для соответствующего параметра, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />. Если определенный параметр не имеет необязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива массивов. Если ни один из параметров не имеет необязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива типов.</param>
      <returns>Определенный конструктор.</returns>
      <exception cref="T:System.ArgumentException">Размер <paramref name="requiredCustomModifiers" /> или <paramref name="optionalCustomModifiers" /> не равен размеру <paramref name="parameterTypes" />.</exception>
      <exception cref="T:System.InvalidOperationException">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
-или- 
Для текущего динамического типа свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> имеет значение <see langword="true" />, но свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> имеет значение <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
      <summary>Определяет конструктор без параметров. Определенный здесь конструктор просто вызовет конструктор без параметров родительского элемента.</summary>
      <param name="attributes">Объект <see langword="MethodAttributes" />, представляющий атрибуты, применяемые к конструктору.</param>
      <returns>Возвращает конструктор.</returns>
      <exception cref="T:System.NotSupportedException">У родительского типа (базового типа) нет конструктора без параметров.</exception>
      <exception cref="T:System.InvalidOperationException">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
-или- 
Для текущего динамического типа свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> имеет значение <see langword="true" />, но свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> имеет значение <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
      <summary>Добавляет новое событие в тип с заданным именем, атрибутами и типом события.</summary>
      <param name="name">Имя события. Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</param>
      <param name="attributes">Атрибуты события.</param>
      <param name="eventtype">Тип события.</param>
      <returns>Определенное событие.</returns>
      <exception cref="T:System.ArgumentException">Длина параметра <paramref name="name" /> равна нулю.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> — <see langword="null" />.  

или - 
<paramref name="eventtype" /> — <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
      <summary>Добавляет новое поле в тип с заданным именем, атрибутами и типом поля.</summary>
      <param name="fieldName">Имя поля. Параметр <paramref name="fieldName" /> не может содержать внедренные значения NULL.</param>
      <param name="type">Тип поля.</param>
      <param name="attributes">Атрибуты поля.</param>
      <returns>Определенное поле.</returns>
      <exception cref="T:System.ArgumentException">Длина параметра <paramref name="fieldName" /> равна нулю.  

или - 
Параметр <paramref name="type" /> имеет значение System.Void.  

-или- 
Общий размер был указан для родительского класса этого поля.</exception>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="fieldName" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
      <summary>Добавляет новое поле в тип с заданным именем, атрибутами, типом поля и настраиваемыми модификаторами.</summary>
      <param name="fieldName">Имя поля. Параметр <paramref name="fieldName" /> не может содержать внедренные значения NULL.</param>
      <param name="type">Тип поля.</param>
      <param name="requiredCustomModifiers">Массив типов, представляющих обязательные настраиваемые модификаторы для поля, например <see cref="T:Microsoft.VisualC.IsConstModifier" />.</param>
      <param name="optionalCustomModifiers">Массив типов, представляющих необязательные настраиваемые модификаторы для поля, например <see cref="T:Microsoft.VisualC.IsConstModifier" />.</param>
      <param name="attributes">Атрибуты поля.</param>
      <returns>Определенное поле.</returns>
      <exception cref="T:System.ArgumentException">Длина параметра <paramref name="fieldName" /> равна нулю.  
-или- 
 Параметр <paramref name="type" /> имеет значение System.Void.  

или - 
Общий размер был указан для родительского класса этого поля.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="fieldName" /> — <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
      <summary>Определяет параметры универсального типа для текущего типа, указывая их количество и имена, и возвращает массив объектов <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />, которые можно использовать для задания их ограничений.</summary>
      <param name="names">Массив имен для параметров универсального типа.</param>
      <returns>Массив объектов <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />, которые можно использовать для определения ограничений параметров универсального типа для текущего типа.</returns>
      <exception cref="T:System.InvalidOperationException">Для этого типа уже были определены параметры универсального типа.</exception>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="names" /> имеет значение <see langword="null" />.  
-или- 
Элемент <paramref name="names" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="names" /> является пустым массивом.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
      <summary>Определяет инициализированное поле данных в разделе .sdata переносимого исполняемого (PE) файла.</summary>
      <param name="name">Имя, используемое для ссылки на данные. Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</param>
      <param name="data">Большой двоичный объект данных.</param>
      <param name="attributes">Атрибуты поля.</param>
      <returns>Поле для ссылки на данные.</returns>
      <exception cref="T:System.ArgumentException">Длина параметра <paramref name="name" /> равна нулю.  

или - 
Размер данных не больше нуля либо не меньше 0x3f0000.</exception>
      <exception cref="T:System.ArgumentNullException">Параметр <paramref name="name" /> или <paramref name="data" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> был вызван ранее.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
      <summary>Добавляет новый метод в тип с указанным именем и атрибутами метода.</summary>
      <param name="name">Имя метода. Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</param>
      <param name="attributes">Атрибуты метода.</param>
      <returns>Объект <see cref="T:System.Reflection.Emit.MethodBuilder" />, представляющий вновь определенный метод.</returns>
      <exception cref="T:System.ArgumentException">Длина параметра <paramref name="name" /> равна нулю.  
-или- 
Тип родительского элемента данного метода — интерфейс, и этот метод не является виртуальным (<see langword="Overridable" /> в Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> — <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  

или - 
Для текущего динамического типа свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> имеет значение <see langword="true" />, но свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> имеет значение <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
      <summary>Добавляет новый метод в тип с указанным именем, атрибутами метода, соглашением о вызовах.</summary>
      <param name="name">Имя метода. Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</param>
      <param name="attributes">Атрибуты метода.</param>
      <param name="callingConvention">Соглашение о вызовах метода.</param>
      <returns>Объект <see cref="T:System.Reflection.Emit.MethodBuilder" />, представляющий вновь определенный метод.</returns>
      <exception cref="T:System.ArgumentException">Длина параметра <paramref name="name" /> равна нулю.  

или - 
Тип родительского элемента данного метода является интерфейсом, и этот метод не является виртуальным (<see langword="Overridable" /> в Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> — <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  

или - 
Для текущего динамического типа свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> имеет значение <see langword="true" />, но свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> имеет значение <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
      <summary>Добавляет новый метод в тип с указанным именем, атрибутами метода, соглашением о вызовах и сигнатурой метода.</summary>
      <param name="name">Имя метода. Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</param>
      <param name="attributes">Атрибуты метода.</param>
      <param name="callingConvention">Соглашение о вызовах метода.</param>
      <param name="returnType">Тип возвращаемых данных метода.</param>
      <param name="parameterTypes">Типы параметров метода.</param>
      <returns>Объект <see cref="T:System.Reflection.Emit.MethodBuilder" />, представляющий вновь определенный метод.</returns>
      <exception cref="T:System.ArgumentException">Длина параметра <paramref name="name" /> равна нулю.  
-или- 
Тип родительского элемента данного метода — интерфейс, и этот метод не является виртуальным (<see langword="Overridable" /> в Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  

или - 
Для текущего динамического типа свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> имеет значение <see langword="true" />, но свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> имеет значение <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
      <summary>Добавляет новый метод в тип с указанным именем, атрибутами метода, соглашением о вызовах, сигнатурой метода и настраиваемыми модификаторами.</summary>
      <param name="name">Имя метода. Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</param>
      <param name="attributes">Атрибуты метода.</param>
      <param name="callingConvention">Соглашение о вызовах метода.</param>
      <param name="returnType">Тип возвращаемых данных метода.</param>
      <param name="returnTypeRequiredCustomModifiers">Массив типов, представляющих обязательные настраиваемые модификаторы, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />, для возвращаемого типа метода. Если возвращаемый тип не содержит требуемых настраиваемых модификаторов, укажите <see langword="null" />.</param>
      <param name="returnTypeOptionalCustomModifiers">Массив типов, представляющих необязательные настраиваемые модификаторы, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />, для возвращаемого типа метода. Если возвращаемый тип не содержит необязательные настраиваемые модификаторы, укажите <see langword="null" />.</param>
      <param name="parameterTypes">Типы параметров метода.</param>
      <param name="parameterTypeRequiredCustomModifiers">Массив массивов типов. Каждый массив типов представляет обязательные настраиваемые модификаторы для соответствующего параметра, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />. Если определенный параметр не имеет обязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива массивов. Если ни один из параметров не имеет обязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива массивов.</param>
      <param name="parameterTypeOptionalCustomModifiers">Массив массивов типов. Каждый массив типов представляет необязательные настраиваемые модификаторы для соответствующего параметра, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />. Если определенный параметр не имеет необязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива массивов. Если ни один из параметров не имеет необязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива типов.</param>
      <returns>Объект <see cref="T:System.Reflection.Emit.MethodBuilder" />, представляющий добавленный метод.</returns>
      <exception cref="T:System.ArgumentException">Длина параметра <paramref name="name" /> равна нулю.  
-или- 
Тип родительского элемента данного метода — интерфейс, и этот метод не является виртуальным (<see langword="Overridable" /> в Visual Basic).  

или - 
Размер <paramref name="parameterTypeRequiredCustomModifiers" /> или <paramref name="parameterTypeOptionalCustomModifiers" /> не равен размеру <paramref name="parameterTypes" />.</exception>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  

или - 
Для текущего динамического типа свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> имеет значение <see langword="true" />, но свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> имеет значение <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
      <summary>Добавляет новый метод в тип с указанным именем, атрибутами метода и сигнатурой метода.</summary>
      <param name="name">Имя метода. Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</param>
      <param name="attributes">Атрибуты метода.</param>
      <param name="returnType">Тип возвращаемых данных метода.</param>
      <param name="parameterTypes">Типы параметров метода.</param>
      <returns>Определенный метод.</returns>
      <exception cref="T:System.ArgumentException">Длина параметра <paramref name="name" /> равна нулю.  

или - 
Тип родительского элемента данного метода — интерфейс, и этот метод не является виртуальным (<see langword="Overridable" /> в Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> — <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  

или - 
Для текущего динамического типа свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> имеет значение <see langword="true" />, но свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> имеет значение <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
      <summary>Задает тело данного метода, реализующее объявление данного метода, возможно, с другим именем.</summary>
      <param name="methodInfoBody">Тело метода, которое будет использоваться. Должно быть объектом <see langword="MethodBuilder" />.</param>
      <param name="methodInfoDeclaration">Метод, объявление которого будет использоваться.</param>
      <exception cref="T:System.ArgumentException">Объект <paramref name="methodInfoBody" /> не принадлежит к этому классу.</exception>
      <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="methodInfoBody" /> или <paramref name="methodInfoDeclaration" /> — <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  

или - 
Объявляющий тип <paramref name="methodInfoBody" /> не является типом, представленным этим <see cref="T:System.Reflection.Emit.TypeBuilder" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
      <summary>Определяет вложенный тип с заданным именем.</summary>
      <param name="name">Краткое имя объекта. Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</param>
      <returns>Определенный вложенный тип.</returns>
      <exception cref="T:System.ArgumentException">Длина <paramref name="name" /> равна нулю или больше 1023.  

или - 
Эта операция создаст тип с повторяющимся <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> в текущей сборке.</exception>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
      <summary>Определяет вложенный тип с заданным именем и атрибутами.</summary>
      <param name="name">Краткое имя объекта. Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</param>
      <param name="attr">Атрибуты типа.</param>
      <returns>Определенный вложенный тип.</returns>
      <exception cref="T:System.ArgumentException">Не указан вложенный атрибут.  

или - 
Этот тип запечатан.  

-или- 
Этот тип является массивом.  

или - 
Этот тип является интерфейсом, а вложенный тип не является интерфейсом.  

или - 
Длина <paramref name="name" /> равна нулю или больше 1023.  

или - 
Эта операция создаст тип с повторяющимся <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> в текущей сборке.</exception>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
      <summary>Определяет вложенный тип на основе его имени, атрибутов и типа, который он расширяет.</summary>
      <param name="name">Краткое имя объекта. Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</param>
      <param name="attr">Атрибуты типа.</param>
      <param name="parent">Тип, который вложенный тип расширяет.</param>
      <returns>Определенный вложенный тип.</returns>
      <exception cref="T:System.ArgumentException">Не указан вложенный атрибут.  
-или- 
Этот тип запечатан.  

или - 
Этот тип является массивом.  

или - 
Этот тип является интерфейсом, а вложенный тип не является интерфейсом.  

или - 
Длина <paramref name="name" /> равна нулю или больше 1023.  

или - 
Эта операция создаст тип с повторяющимся <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> в текущей сборке.</exception>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
      <summary>Определяет вложенный тип по заданным имени, атрибутам, общему размеру типа и типу, который он расширяет.</summary>
      <param name="name">Краткое имя объекта. Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</param>
      <param name="attr">Атрибуты типа.</param>
      <param name="parent">Тип, который вложенный тип расширяет.</param>
      <param name="typeSize">Общий размер типа.</param>
      <returns>Определенный вложенный тип.</returns>
      <exception cref="T:System.ArgumentException">Не указан вложенный атрибут.  
-или- 
Этот тип запечатан.  

или - 
Этот тип является массивом.  

или - 
Этот тип является интерфейсом, а вложенный тип не является интерфейсом.  

или - 
Длина <paramref name="name" /> равна нулю или больше 1023.  

или - 
Эта операция создаст тип с повторяющимся <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> в текущей сборке.</exception>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
      <summary>Определяет вложенный тип по заданным имени, атрибутам, типу, который он расширяет, и размеру упаковки.</summary>
      <param name="name">Краткое имя объекта. Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</param>
      <param name="attr">Атрибуты типа.</param>
      <param name="parent">Тип, который вложенный тип расширяет.</param>
      <param name="packSize">Размер упаковки типа.</param>
      <returns>Определенный вложенный тип.</returns>
      <exception cref="T:System.ArgumentException">Не указан вложенный атрибут.  

или - 
Этот тип запечатан.  

-или- 
Этот тип является массивом.  

или - 
Этот тип является интерфейсом, а вложенный тип не является интерфейсом.  

или - 
Длина <paramref name="name" /> равна нулю или больше 1023.  

или - 
Эта операция создаст тип с повторяющимся <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> в текущей сборке.</exception>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
      <summary>Определяет вложенный тип на основе его имени, атрибутов, размера и типа, который он расширяет.</summary>
      <param name="name">Краткое имя объекта. Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</param>
      <param name="attr">Атрибуты типа.</param>
      <param name="parent">Тип, который вложенный тип расширяет.</param>
      <param name="packSize">Размер упаковки типа.</param>
      <param name="typeSize">Общий размер типа.</param>
      <returns>Определенный вложенный тип.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
      <summary>Определяет вложенный тип по заданным имени, атрибутам, типу, который он расширяет, и интерфейсам, которые он реализует.</summary>
      <param name="name">Краткое имя объекта. Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</param>
      <param name="attr">Атрибуты типа.</param>
      <param name="parent">Тип, который вложенный тип расширяет.</param>
      <param name="interfaces">Интерфейсы, реализуемые вложенным типом.</param>
      <returns>Определенный вложенный тип.</returns>
      <exception cref="T:System.ArgumentException">Не указан вложенный атрибут.  

или - 
Этот тип запечатан.  

или - 
Этот тип является массивом.  


-или- 
Этот тип является интерфейсом, а вложенный тип не является интерфейсом.  

или - 
Длина <paramref name="name" /> равна нулю или больше 1023.  

или - 
Эта операция создаст тип с повторяющимся <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> в текущей сборке.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> — <see langword="null" />.  

или - 
Элемент массива <paramref name="interfaces" /> является <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
      <summary>Определяет метод <see langword="PInvoke" /> с учетом его имени, имени библиотеки DLL, в которой определен метод, атрибутов метода, соглашения о вызове метода, возвращаемого типа метода, типов параметров метода и флагов <see langword="PInvoke" />.</summary>
      <param name="name">Имя метода <see langword="PInvoke" />. Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</param>
      <param name="dllName">Имя библиотеки DLL, в которой определен метод <see langword="PInvoke" />.</param>
      <param name="attributes">Атрибуты метода.</param>
      <param name="callingConvention">Соглашение о вызове метода.</param>
      <param name="returnType">Возвращаемый тип метода.</param>
      <param name="parameterTypes">Типы параметров метода.</param>
      <param name="nativeCallConv">Собственное соглашение о вызове.</param>
      <param name="nativeCharSet">Собственная кодировка метода.</param>
      <returns>Определенный метод <see langword="PInvoke" />.</returns>
      <exception cref="T:System.ArgumentException">Метод не является статическим.  

или - 
Родительский тип является интерфейсом.  

или - 
Метод является абстрактным.  

или - 
Метод был определен ранее.  


-или- 
Длина параметра <paramref name="name" /> или <paramref name="dllName" /> равна нулю.</exception>
      <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="name" /> или <paramref name="dllName" /> — <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Содержащий тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
      <summary>Определяет метод <see langword="PInvoke" /> с учетом его имени, имени библиотеки DLL, в которой определен метод, имени точки входа, атрибутов метода, соглашения о вызове метода, возвращаемого типа метода, типов параметров метода и флагов <see langword="PInvoke" />.</summary>
      <param name="name">Имя метода <see langword="PInvoke" />. Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</param>
      <param name="dllName">Имя библиотеки DLL, в которой определен метод <see langword="PInvoke" />.</param>
      <param name="entryName">Имя точки входа в библиотеке DLL.</param>
      <param name="attributes">Атрибуты метода.</param>
      <param name="callingConvention">Соглашение о вызове метода.</param>
      <param name="returnType">Возвращаемый тип метода.</param>
      <param name="parameterTypes">Типы параметров метода.</param>
      <param name="nativeCallConv">Собственное соглашение о вызове.</param>
      <param name="nativeCharSet">Собственная кодировка метода.</param>
      <returns>Определенный метод <see langword="PInvoke" />.</returns>
      <exception cref="T:System.ArgumentException">Метод не является статическим.  

или - 
Родительский тип является интерфейсом.  

или - 
Метод является абстрактным.  

или - 
Метод был определен ранее.  

или - 
Длина параметра <paramref name="name" />, <paramref name="dllName" /> или <paramref name="entryName" /> равна нулю.</exception>
      <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="name" />, <paramref name="dllName" /> или <paramref name="entryName" /> равно <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Содержащий тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][])">
      <summary>Определяет метод <see langword="PInvoke" /> с учетом его имени, имени библиотеки DLL, в которой определен метод, имени точки входа, атрибутов метода, соглашения о вызове метода, возвращаемого типа метода, типов параметров метода, флагов <see langword="PInvoke" /> и настраиваемых модификаторов для параметров и возвращаемого типа.</summary>
      <param name="name">Имя метода <see langword="PInvoke" />. Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</param>
      <param name="dllName">Имя библиотеки DLL, в которой определен метод <see langword="PInvoke" />.</param>
      <param name="parameterTypeOptionalCustomModifiers">Массив массивов типов. Каждый массив типов представляет необязательные настраиваемые модификаторы для соответствующего параметра, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />. Если определенный параметр не имеет необязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива массивов. Если ни один из параметров не имеет необязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива типов.</param>
      <param name="nativeCallConv">Собственное соглашение о вызове.</param>
      <param name="nativeCharSet">Собственная кодировка метода.</param>
      <param name="entryName">Имя точки входа в библиотеке DLL.</param>
      <param name="attributes">Атрибуты метода.</param>
      <param name="callingConvention">Соглашение о вызове метода.</param>
      <param name="returnType">Возвращаемый тип метода.</param>
      <param name="returnTypeRequiredCustomModifiers">Массив типов, представляющих обязательные настраиваемые модификаторы, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />, для возвращаемого типа метода. Если возвращаемый тип не содержит требуемых настраиваемых модификаторов, укажите <see langword="null" />.</param>
      <param name="returnTypeOptionalCustomModifiers">Массив типов, представляющих необязательные настраиваемые модификаторы, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />, для возвращаемого типа метода. Если возвращаемый тип не содержит необязательные настраиваемые модификаторы, укажите <see langword="null" />.</param>
      <param name="parameterTypes">Типы параметров метода.</param>
      <param name="parameterTypeRequiredCustomModifiers">Массив массивов типов. Каждый массив типов представляет обязательные настраиваемые модификаторы для соответствующего параметра, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />. Если определенный параметр не имеет обязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива массивов. Если ни один из параметров не имеет обязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива массивов.</param>
      <returns>Объект <see cref="T:System.Reflection.Emit.MethodBuilder" />, представляющий определенный метод <see langword="PInvoke" />.</returns>
      <exception cref="T:System.ArgumentException">Метод не является статическим.  

или - 
Родительский тип является интерфейсом.  

или - 
Метод является абстрактным.  


-или- 
Метод был определен ранее.  
-или- 
Длина параметра <paramref name="name" />, <paramref name="dllName" /> или <paramref name="entryName" /> равна нулю.  

или - 
Размер <paramref name="parameterTypeRequiredCustomModifiers" /> или <paramref name="parameterTypeOptionalCustomModifiers" /> не равен размеру <paramref name="parameterTypes" />.</exception>
      <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="name" />, <paramref name="dllName" /> или <paramref name="entryName" /> равно <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
-или- 
Для текущего динамического типа свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> имеет значение <see langword="true" />, но свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> имеет значение <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
      <summary>Добавляет новое свойство в тип с заданным именем, атрибутами, соглашением о вызове и сигнатурой свойства.</summary>
      <param name="name">Имя свойства. Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</param>
      <param name="attributes">Атрибуты свойства.</param>
      <param name="callingConvention">Соглашение о вызовах методов доступа свойства.</param>
      <param name="returnType">Возвращаемый тип свойства.</param>
      <param name="parameterTypes">Типы параметров свойства.</param>
      <returns>Заданное свойство.</returns>
      <exception cref="T:System.ArgumentException">Длина параметра <paramref name="name" /> равна нулю.</exception>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="name" /> имеет значение <see langword="null" />.  

или - 
Один из элементов массива <paramref name="parameterTypes" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
      <summary>Добавляет новое свойство в тип с заданным именем, соглашением о вызовах, сигнатурой свойства и настраиваемыми модификаторами.</summary>
      <param name="name">Имя свойства. Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</param>
      <param name="attributes">Атрибуты свойства.</param>
      <param name="callingConvention">Соглашение о вызовах методов доступа свойства.</param>
      <param name="returnType">Возвращаемый тип свойства.</param>
      <param name="returnTypeRequiredCustomModifiers">Массив типов, представляющих обязательные настраиваемые модификаторы, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />, для возвращаемого типа свойства. Если возвращаемый тип не содержит требуемых настраиваемых модификаторов, укажите <see langword="null" />.</param>
      <param name="returnTypeOptionalCustomModifiers">Массив типов, представляющих необязательные настраиваемые модификаторы, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />, для типа возвращаемого значения свойства. Если возвращаемый тип не содержит необязательные настраиваемые модификаторы, укажите <see langword="null" />.</param>
      <param name="parameterTypes">Типы параметров свойства.</param>
      <param name="parameterTypeRequiredCustomModifiers">Массив массивов типов. Каждый массив типов представляет обязательные настраиваемые модификаторы для соответствующего параметра, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />. Если определенный параметр не имеет обязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива массивов. Если ни один из параметров не имеет обязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива массивов.</param>
      <param name="parameterTypeOptionalCustomModifiers">Массив массивов типов. Каждый массив типов представляет необязательные настраиваемые модификаторы для соответствующего параметра, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />. Если определенный параметр не имеет необязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива массивов. Если ни один из параметров не имеет необязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива типов.</param>
      <returns>Заданное свойство.</returns>
      <exception cref="T:System.ArgumentException">Длина параметра <paramref name="name" /> равна нулю.</exception>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="name" /> имеет значение <see langword="null" />.  

или - 
Один из элементов массива <paramref name="parameterTypes" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
      <summary>Добавляет новое свойство в тип с заданным именем и сигнатурой свойства.</summary>
      <param name="name">Имя свойства. Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</param>
      <param name="attributes">Атрибуты свойства.</param>
      <param name="returnType">Возвращаемый тип свойства.</param>
      <param name="parameterTypes">Типы параметров свойства.</param>
      <returns>Заданное свойство.</returns>
      <exception cref="T:System.ArgumentException">Длина параметра <paramref name="name" /> равна нулю.</exception>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="name" /> имеет значение <see langword="null" />.  

или - 
Один из элементов массива <paramref name="parameterTypes" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
      <summary>Добавляет новое свойство в тип с заданным именем, сигнатурой свойства и настраиваемыми модификаторами.</summary>
      <param name="name">Имя свойства. Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</param>
      <param name="attributes">Атрибуты свойства.</param>
      <param name="returnType">Возвращаемый тип свойства.</param>
      <param name="returnTypeRequiredCustomModifiers">Массив типов, представляющих обязательные настраиваемые модификаторы, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />, для возвращаемого типа свойства. Если возвращаемый тип не содержит требуемых настраиваемых модификаторов, укажите <see langword="null" />.</param>
      <param name="returnTypeOptionalCustomModifiers">Массив типов, представляющих необязательные настраиваемые модификаторы, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />, для типа возвращаемого значения свойства. Если возвращаемый тип не содержит необязательные настраиваемые модификаторы, укажите <see langword="null" />.</param>
      <param name="parameterTypes">Типы параметров свойства.</param>
      <param name="parameterTypeRequiredCustomModifiers">Массив массивов типов. Каждый массив типов представляет обязательные настраиваемые модификаторы для соответствующего параметра, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />. Если определенный параметр не имеет обязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива массивов. Если ни один из параметров не имеет обязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива массивов.</param>
      <param name="parameterTypeOptionalCustomModifiers">Массив массивов типов. Каждый массив типов представляет необязательные настраиваемые модификаторы для соответствующего параметра, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />. Если определенный параметр не имеет необязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива массивов. Если ни один из параметров не имеет необязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива типов.</param>
      <returns>Заданное свойство.</returns>
      <exception cref="T:System.ArgumentException">Длина параметра <paramref name="name" /> равна нулю.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> равно <see langword="null" />  

или - 
Один из элементов массива <paramref name="parameterTypes" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer">
      <summary>Определяет инициализатор для этого типа.</summary>
      <returns>Возвращает инициализатор типа.</returns>
      <exception cref="T:System.InvalidOperationException">Содержащий тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
      <summary>Определяет неинициализированное поле данных в разделе <see langword=".sdata" /> переносимого исполняемого (PE) файла.</summary>
      <param name="name">Имя, используемое для ссылки на данные. Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</param>
      <param name="size">Размер поля данных.</param>
      <param name="attributes">Атрибуты поля.</param>
      <returns>Поле для ссылки на данные.</returns>
      <exception cref="T:System.ArgumentException">Длина параметра <paramref name="name" /> равна нулю.  
-или- 
 Значение <paramref name="size" /> меньше или равно нулю либо больше или равно 0x003f0000.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> — <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.FullName">
      <summary>Извлекает полный путь данного типа.</summary>
      <returns>Только для чтения. Извлекает полный путь данного типа.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.GenericParameterAttributes">
      <summary>Получает значение, указывающее ковариацию и особые ограничения текущего параметра универсального типа.</summary>
      <returns>Побитовое сочетание значений <see cref="T:System.Reflection.GenericParameterAttributes" />, которое описывает ковариацию и особые ограничения текущего параметра универсального типа.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.GenericParameterPosition">
      <summary>Возвращает позицию параметра типа в списке параметров типа универсального типа, в котором объявлен этот параметр.</summary>
      <returns>Если текущий объект <see cref="T:System.Reflection.Emit.TypeBuilder" /> представляет параметр универсального типа, позиция параметра типа в списке параметров типа универсального типа, который объявил параметр. В противном случае — не определено.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
      <summary>Возвращает конструктор указанного сконструированного универсального типа, соответствующего указанному конструктору определения универсального типа.</summary>
      <param name="type">Сконструированный универсальный тип, конструктор которого возвращается.</param>
      <param name="constructor">Конструктор в определении универсального типа <paramref name="type" />, который указывает, какой конструктор <paramref name="type" /> следует вернуть.</param>
      <returns>Объект <see cref="T:System.Reflection.ConstructorInfo" />, представляющий конструктор <paramref name="type" />, соответствующий <paramref name="constructor" />, который указывает конструктор, принадлежащий определению универсального типа <paramref name="type" />.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="type" /> не представляет универсальный тип.  

или - 
Параметр<paramref name="type" /> не является параметром типа <see cref="T:System.Reflection.Emit.TypeBuilder" />.  

или - 
Объявляющий тип <paramref name="constructor" /> не является определением универсального типа.  

или - 
Объявляющий тип <paramref name="constructor" /> не является определением универсального типа <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)">
      <summary>Возвращает массив объектов <see cref="T:System.Reflection.ConstructorInfo" />, представляющих открытые и закрытые конструкторы, определенные для этого класса, как указано.</summary>
      <param name="bindingAttr">Это должен быть одноразрядный флаг из <see cref="T:System.Reflection.BindingFlags" />, как в <see langword="InvokeMethod" />, <see langword="NonPublic" /> и так далее.</param>
      <returns>Возвращает массив объектов <see cref="T:System.Reflection.ConstructorInfo" />, представляющих указанные конструкторы, определенные для этого класса. Если конструкторы не определены, возвращается пустой массив.</returns>
      <exception cref="T:System.NotSupportedException">Этот метод не реализован для неполных типов.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)">
      <summary>Возвращает все настраиваемые атрибуты, определенные для данного типа.</summary>
      <param name="inherit">Указывает, следует ли выполнять поиск в цепочке наследования этого члена для нахождения атрибутов.</param>
      <returns>Возвращает массив объектов, представляющих все настраиваемые атрибуты этого типа.</returns>
      <exception cref="T:System.NotSupportedException">В настоящее время этот метод не поддерживается для неполных типов. Извлеките тип с помощью <see cref="M:System.Type.GetType" /> и вызовите <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> в возвращенном типе <see cref="T:System.Type" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>Возвращает все настраиваемые атрибуты текущего типа, которые можно назначить указанному типу.</summary>
      <param name="attributeType">Тип атрибута для поиска. Возвращаются только те атрибуты, которые можно назначить этому типу.</param>
      <param name="inherit">Указывает, следует ли выполнять поиск в цепочке наследования этого члена для нахождения атрибутов.</param>
      <returns>Массив настраиваемых атрибутов, определенных для текущего типа.</returns>
      <exception cref="T:System.NotSupportedException">В настоящее время этот метод не поддерживается для неполных типов. Извлеките тип с помощью <see cref="M:System.Type.GetType" /> и вызовите <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> в возвращенном типе <see cref="T:System.Type" />.</exception>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="attributeType" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">Тип должен быть типом, предоставленным базовой системой среды выполнения.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetElementType">
      <summary>При вызове этого метода всегда возникает исключение <see cref="T:System.NotSupportedException" />.</summary>
      <returns>Этот метод не поддерживается. Возвращаемое значение отсутствует.</returns>
      <exception cref="T:System.NotSupportedException">Этот метод не поддерживается.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
      <summary>Возвращает событие с указанным именем.</summary>
      <param name="name">Имя искомого события.</param>
      <param name="bindingAttr">Битовая комбинация значений <see cref="T:System.Reflection.BindingFlags" />, определяющая границы поиска.</param>
      <returns>Объект <see cref="T:System.Reflection.EventInfo" />, представляющий событие, объявленное или наследованное этим типом с указанным именем; или значение <see langword="null" />, если совпадений не обнаружено.</returns>
      <exception cref="T:System.NotSupportedException">Этот метод не реализован для неполных типов.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetEvents">
      <summary>Возвращает открытые события, объявленные или наследованные данным типом.</summary>
      <returns>Возвращает массив объектов <see cref="T:System.Reflection.EventInfo" /> , представляющих открытые события, объявленные или наследуемые этим типом. Если открытые события отсутствуют, возвращается пустой массив.</returns>
      <exception cref="T:System.NotSupportedException">Этот метод не реализован для неполных типов.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)">
      <summary>Возвращает открытые и не являющиеся открытыми события, объявленные данным типом.</summary>
      <param name="bindingAttr">Битовая комбинация значений <see cref="T:System.Reflection.BindingFlags" />, определяющая границы поиска.</param>
      <returns>Возвращает массив объектов <see cref="T:System.Reflection.EventInfo" />, представляющих события, которые объявлены или унаследованы этим типом и удовлетворяют указанным флагам привязки. Если соответствующие события отсутствуют, возвращается пустой массив.</returns>
      <exception cref="T:System.NotSupportedException">Этот метод не реализован для неполных типов.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)">
      <summary>Возвращает поле, указанное данным именем.</summary>
      <param name="name">Имя получаемого поля.</param>
      <param name="bindingAttr">Это должен быть одноразрядный флаг из <see cref="T:System.Reflection.BindingFlags" />, как в <see langword="InvokeMethod" />, <see langword="NonPublic" /> и так далее.</param>
      <returns>Возвращает объект <see cref="T:System.Reflection.FieldInfo" />, представляющий поле, объявленное или наследуемое этим типом, с указанным именем и открытым или закрытым модификатором. Если совпадений нет, возвращается значение <see langword="null" />.</returns>
      <exception cref="T:System.NotSupportedException">Этот метод не реализован для неполных типов.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
      <summary>Возвращает поле указанного сконструированного универсального типа, соответствующее указанному полю определения универсального типа.</summary>
      <param name="type">Сконструированный универсальный тип, поле которого возвращается.</param>
      <param name="field">Поле определения универсального типа <paramref name="type" />, которое указывает, какое поле <paramref name="type" /> следует вернуть.</param>
      <returns>Объект <see cref="T:System.Reflection.FieldInfo" />, представляющий поле <paramref name="type" />, соответствующее <paramref name="field" />, который указывает поле, принадлежащее определению универсального типа <paramref name="type" />.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="type" /> не представляет универсальный тип.  

или - 
Параметр<paramref name="type" /> не является параметром типа <see cref="T:System.Reflection.Emit.TypeBuilder" />.  

-или- 
Объявляющий тип <paramref name="field" /> не является определением универсального типа.  

или - 
Объявляющий тип <paramref name="field" /> не является определением универсального типа <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)">
      <summary>Возвращает открытые и не являющиеся открытыми поля, объявленные данным типом.</summary>
      <param name="bindingAttr">Это должен быть одноразрядный флаг из <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" /> и так далее.</param>
      <returns>Возвращает массив объектов <see cref="T:System.Reflection.FieldInfo" />, представляющих открытые и не являющиеся открытыми поля, объявленные или наследованные этим типом. Если заданные поля отсутствуют, возвращается пустой массив.</returns>
      <exception cref="T:System.NotSupportedException">Этот метод не реализован для неполных типов.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments">
      <summary>Возвращает массив объектов <see cref="T:System.Type" />, которые представляют аргументы универсального типа или параметры определения универсального типа.</summary>
      <returns>Массив объектов <see cref="T:System.Type" />. Элементы массива, которые представляют аргументы универсального типа или параметры определения универсального типа.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition">
      <summary>Возвращает объект <see cref="T:System.Type" />, представляющий определение универсального типа, на основе которого можно получить текущий тип.</summary>
      <returns>Объект <see cref="T:System.Type" />, представляющий определение универсального типа, на основе которого можно получить текущий тип.</returns>
      <exception cref="T:System.InvalidOperationException">Текущий тип не является универсальным. То есть <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> возвращает <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)">
      <summary>Возвращает интерфейс, реализованный (прямо или косвенно) данным классом с полным именем, совпадающим с именем данного интерфейса.</summary>
      <param name="name">Имя интерфейса.</param>
      <param name="ignoreCase">Если значение <see langword="true" />, при поиске не учитывается регистр. Если значение <see langword="false" />, при поиске учитывается регистр.</param>
      <returns>Возвращает объект <see cref="T:System.Type" />, предоставляющий реализованный интерфейс. Возвращает значение null, если совпадающее имя интерфейса не найдено.</returns>
      <exception cref="T:System.NotSupportedException">Этот метод не реализован для неполных типов.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)">
      <summary>Возвращает сопоставление для запрошенного интерфейса.</summary>
      <param name="interfaceType">Тип <see cref="T:System.Type" /> интерфейса, для которого должно быть получено сопоставление.</param>
      <returns>Возвращает запрошенное сопоставление интерфейса.</returns>
      <exception cref="T:System.NotSupportedException">Этот метод не реализован для неполных типов.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetInterfaces">
      <summary>Возвращает массив всех интерфейсов, реализованных для данного типа и его базовых типов.</summary>
      <returns>Возвращает массив объектов <see cref="T:System.Type" />, представляющих реализованные интерфейсы. Если они не определены, возвращается пустой массив.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
      <summary>Возвращает все открытые и закрытые члены, объявленные или наследуемые данным типом, как указано.</summary>
      <param name="name">Имя элемента.</param>
      <param name="type">Тип возвращаемого элемента.</param>
      <param name="bindingAttr">Это должен быть одноразрядный флаг из <see cref="T:System.Reflection.BindingFlags" />, как в <see langword="InvokeMethod" />, <see langword="NonPublic" /> и так далее.</param>
      <returns>Возвращает массив объектов <see cref="T:System.Reflection.MemberInfo" />, представляющих открытые и не являющиеся открытыми члены, определенные для данного типа, если используется <paramref name="nonPublic" />; в противном случае возвращаются только открытые члены.</returns>
      <exception cref="T:System.NotSupportedException">Этот метод не реализован для неполных типов.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)">
      <summary>Возвращает открытые и не являющиеся открытыми члены, объявленные или наследуемые данным типом.</summary>
      <param name="bindingAttr">Это должен быть одноразрядный флаг из <see cref="T:System.Reflection.BindingFlags" />, например <see langword="InvokeMethod" />, <see langword="NonPublic" /> и так далее.</param>
      <returns>Возвращает массив объектов <see cref="T:System.Reflection.MemberInfo" />, представляющих открытые и не являющиеся открытыми члены, объявленные или наследованные этим типом. Если соответствующие члены отсутствуют, возвращается пустой массив.</returns>
      <exception cref="T:System.NotSupportedException">Этот метод не реализован для неполных типов.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
      <summary>Возвращает метод указанного сконструированного универсального типа, соответствующего указанному методу определения универсального типа.</summary>
      <param name="type">Сконструированный универсальный тип, метод которого возвращается.</param>
      <param name="method">Метод определения универсального типа <paramref name="type" />, который указывает, какой метод <paramref name="type" /> следует вернуть.</param>
      <returns>Объект <see cref="T:System.Reflection.MethodInfo" />, представляющий метод <paramref name="type" />, соответствующий <paramref name="method" />, который указывает метод, принадлежащий определению универсального типа <paramref name="type" />.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> представляет универсальный метод, который не является определением универсального метода.  

или - 
<paramref name="type" /> не представляет универсальный тип.  

или - 
Параметр<paramref name="type" /> не является параметром типа <see cref="T:System.Reflection.Emit.TypeBuilder" />.  


-или- 
Объявляющий тип <paramref name="method" /> не является определением универсального типа.  

или - 
Объявляющий тип <paramref name="method" /> не является определением универсального типа <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)">
      <summary>Возвращает все открытые и закрытые методы, объявленные или наследуемые данным типом, как указано.</summary>
      <param name="bindingAttr">Это должен быть одноразрядный флаг из <see cref="T:System.Reflection.BindingFlags" />, как в <see langword="InvokeMethod" />, <see langword="NonPublic" /> и так далее.</param>
      <returns>Возвращает массив объектов <see cref="T:System.Reflection.MethodInfo" />, представляющих открытые и закрытые методы, определенные для данного типа, если используется <paramref name="nonPublic" />; в противном случае возвращаются только открытые методы.</returns>
      <exception cref="T:System.NotSupportedException">Этот метод не реализован для неполных типов.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
      <summary>Возвращает открытые и не являющиеся открытыми вложенные типы, объявленные этим типом.</summary>
      <param name="name">Строка <see cref="T:System.String" />, содержащая имя искомого вложенного типа.</param>
      <param name="bindingAttr">Битовая маска, составленная из одного или нескольких объектов <see cref="T:System.Reflection.BindingFlags" /> и указывающая, как ведется поиск.  

или - 
Нуль для выполнения поиска открытых методов с учетом регистра.</param>
      <returns>Если поиск выполнен успешно, возвращается объект <see cref="T:System.Type" />, предоставляющий вложенный тип, который соответствует указанным требованиям; в противном случае возвращается <see langword="null" />.</returns>
      <exception cref="T:System.NotSupportedException">Этот метод не реализован для неполных типов.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
      <summary>Возвращает открытые и не являющиеся открытыми вложенные типы, объявленные или наследованные данным типом.</summary>
      <param name="bindingAttr">Это должен быть одноразрядный флаг из <see cref="T:System.Reflection.BindingFlags" />, как в <see langword="InvokeMethod" />, <see langword="NonPublic" /> и так далее.</param>
      <returns>Массив объектов <see cref="T:System.Type" />, представляющий все типы, вложенные внутри текущего типа <see cref="T:System.Type" /> и удовлетворяющие указанным ограничениям привязки.  
Пустой массив типа <see cref="T:System.Type" />, если внутри текущего объекта <see cref="T:System.Type" /> нет вложенных типов, или ни один из вложенных типов не удовлетворяет ограничениям привязки.</returns>
      <exception cref="T:System.NotSupportedException">Этот метод не реализован для неполных типов.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)">
      <summary>Возвращает все открытые и закрытые свойства, объявленные или наследуемые данным типом, как указано.</summary>
      <param name="bindingAttr">Это атрибут вызова. Это должен быть одноразрядный флаг из <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" /> и так далее.</param>
      <returns>Возвращает массив объектов <see langword="PropertyInfo" />, представляющих открытые и закрытые свойства, определенные для данного типа, если используется <paramref name="nonPublic" />; в противном случае возвращаются только открытые свойства.</returns>
      <exception cref="T:System.NotSupportedException">Этот метод не реализован для неполных типов.</exception>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.GUID">
      <summary>Получает идентификатор GUID этого типа.</summary>
      <returns>Только для чтения. Получает идентификатор GUID этого типа.</returns>
      <exception cref="T:System.NotSupportedException">В настоящее время этот метод не поддерживается для неполных типов.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
      <summary>Вызывает указанный член. Вызываемый метод должен быть доступен и обеспечивать наиболее точное соответствие заданному списку аргументов с учетом ограничений заданного модуля привязки и атрибутов вызова.</summary>
      <param name="name">Имя вызываемого члена. Это может быть конструктор, метод, свойство или поле. Необходимо указать подходящий атрибут вызова. Обратите внимание, что можно вызвать член класса, заданный по умолчанию, передав в качестве имени члена пустую строку.</param>
      <param name="invokeAttr">Атрибут вызова. Это должен быть одноразрядный флаг из <see langword="BindingFlags" />.</param>
      <param name="binder">Объект, позволяющий осуществлять привязку, приведение типов аргументов, вызов элементов, а также поиск объектов <see langword="MemberInfo" /> с помощью отражения. Если указан модуль привязки <see langword="null" />, используется модуль привязки по умолчанию. См. раздел <see cref="T:System.Reflection.Binder" />.</param>
      <param name="target">Объект, для которого следует вызвать указанный член. Если член является статическим, этот параметр игнорируется.</param>
      <param name="args">Список аргументов. Это массив объектов, содержащий число, порядок и тип параметров вызываемого члена. Если параметров нет, должно быть указано значение NULL.</param>
      <param name="modifiers">Массив с такой же длиной, как у <paramref name="args" /> с элементами, представляющими атрибуты, связанные с аргументами вызываемого члена. Параметр имеет атрибуты, связанные с ним в метаданных. Они используются различными службами взаимодействия. Дополнительные сведения см. в спецификации метаданных.</param>
      <param name="culture">Экземпляр объекта <see langword="CultureInfo" />, используемого для управления приведением типов. Если параметр имеет значение NULL, для текущего потока используется <see langword="CultureInfo" />. (Обратите внимание, что необходимо, например, преобразовать строку, представляющую 1000, в число с двойной точностью, поскольку для разных языков и региональных параметров 1000 представляется по-разному.)</param>
      <param name="namedParameters">Каждый параметр в массиве <paramref name="namedParameters" /> получает значение в соответствующем элементе в массиве <paramref name="args" />. Если длина <paramref name="args" /> превышает длину <paramref name="namedParameters" />, оставшиеся значения аргументов передаются по порядку.</param>
      <returns>Возвращает возвращаемое значение вызываемого члена.</returns>
      <exception cref="T:System.NotSupportedException">В настоящее время этот метод не поддерживается для неполных типов.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Type)">
      <summary>Возвращает значение, указывающее, может ли заданный <see cref="T:System.Type" /> быть назначен этому объекту.</summary>
      <param name="c">Объект для тестирования.</param>
      <returns>
        <see langword="true" />, если параметр <paramref name="c" /> и текущий тип представляют один и тот же тип, или если текущий тип находится в иерархии наследования для <paramref name="c" />, или если текущий тип является интерфейсом, который поддерживает <paramref name="c" />. Значение <see langword="false" />, если не действует ни одно из этих условий или если значение параметра <paramref name="c" /> равно <see langword="null" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsByRefLike" />
    <member name="P:System.Reflection.Emit.TypeBuilder.IsConstructedGenericType">
      <summary>Возвращает значение, указывающее, представляет ли этот данный объект сконструированный универсальный тип.</summary>
      <returns>Значение<see langword="true" /> , если этот объект представляет сконструированный универсальный тип; в противном случае — значение <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.IsCreated">
      <summary>Возвращает значение, которое показывает, был ли создан текущий динамический тип.</summary>
      <returns>Значение <see langword="true" />, если был вызван метод <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />. В противном случае — значение <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>Определяет, применяется ли настраиваемый атрибут к текущему типу.</summary>
      <param name="attributeType">Тип атрибута для поиска. Возвращаются только те атрибуты, которые можно назначить этому типу.</param>
      <param name="inherit">Указывает, следует ли выполнять поиск в цепочке наследования этого члена для нахождения атрибутов.</param>
      <returns>
        <see langword="true" />, если для данного типа определены один или несколько экземпляров <paramref name="attributeType" /> или атрибут является производным от <paramref name="attributeType" />; в противном случае — <see langword="false" />.</returns>
      <exception cref="T:System.NotSupportedException">В настоящее время этот метод не поддерживается для неполных типов. Извлеките тип с помощью <see cref="M:System.Type.GetType" /> и вызовите <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> в возвращенном типе <see cref="T:System.Type" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="attributeType" /> не определен.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="attributeType" /> — <see langword="null" />.</exception>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsGenericParameter">
      <summary>Возвращает значение, указывающее, является ли текущий тип параметром универсального типа.</summary>
      <returns>Значение <see langword="true" />, если текущий объект <see cref="T:System.Reflection.Emit.TypeBuilder" /> представляет параметр универсального типа; в противном случае — <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsGenericType">
      <summary>Возвращает значение, указывающее, является ли текущий тип универсальным.</summary>
      <returns>Значение <see langword="true" />, если тип, представленный текущим объектом <see cref="T:System.Reflection.Emit.TypeBuilder" />, является универсальным; в противном случае — значение <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition">
      <summary>Возвращает значение, определяющее, представляет ли текущий объект <see cref="T:System.Reflection.Emit.TypeBuilder" /> определение универсального типа, на основе которого можно конструировать другие универсальные типы.</summary>
      <returns>Значение <see langword="true" />, если этот объект <see cref="T:System.Reflection.Emit.TypeBuilder" /> представляет определение универсального типа. В противном случае — значение <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
      <summary>Получает значение, которое указывает, является ли текущий тип критическим с точки зрения безопасности или надежным с точки зрения безопасности и, следовательно, может ли он выполнять важные операции.</summary>
      <returns>Значение <see langword="true" />, если текущий тип является критическим с точки зрения безопасности или надежным с точки зрения безопасности; значение <see langword="false" />, если он является прозрачным.</returns>
      <exception cref="T:System.NotSupportedException">Текущий динамический тип не был создан путем вызова метода <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
      <summary>Получает значение, которое указывает, является ли текущий тип надежным с точки зрения безопасности и, следовательно, может ли он выполнять критически важные операции и предоставлять доступ прозрачному коду.</summary>
      <returns>Значение <see langword="true" />, если текущий тип является надежным с точки зрения безопасности; значение <see langword="false" />, если он является критическим с точки зрения безопасности или прозрачным.</returns>
      <exception cref="T:System.NotSupportedException">Текущий динамический тип не был создан путем вызова метода <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
      <summary>Получает значение, которое указывает, является ли текущий тип прозрачным и, следовательно, не может выполнять критические операции.</summary>
      <returns>Значение <see langword="true" />, если тип является прозрачным; в противном случае — значение <see langword="false" />.</returns>
      <exception cref="T:System.NotSupportedException">Текущий динамический тип не был создан путем вызова метода <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.IsSubclassOf(System.Type)">
      <summary>Определяет, является ли этот тип производным от указанного типа.</summary>
      <param name="c">Проверяемый тип <see cref="T:System.Type" />.</param>
      <returns>Только для чтения. Возвращает значение <see langword="true" />, если тип совпадает с типом <paramref name="c" /> или является подтипом типа <paramref name="c" />; в противном случае — значение <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsSZArray" />
    <member name="P:System.Reflection.Emit.TypeBuilder.IsTypeDefinition" />
    <member name="P:System.Reflection.Emit.TypeBuilder.IsVariableBoundArray" />
    <member name="M:System.Reflection.Emit.TypeBuilder.MakeArrayType">
      <summary>Возвращает объект <see cref="T:System.Type" />, представляющий одномерный массив текущего типа с нижней границей, равной нулю.</summary>
      <returns>Объект <see cref="T:System.Type" />, представляющий одномерный массив текущего типа с нижней границей, равной нулю.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
      <summary>Возвращает объект <see cref="T:System.Type" />, представляющий массив текущего типа указанной размерности.</summary>
      <param name="rank">Размерность массива.</param>
      <returns>Объект <see cref="T:System.Type" />, который представляет одномерный массив текущего типа.</returns>
      <exception cref="T:System.IndexOutOfRangeException">
        <paramref name="rank" /> не является допустимой размерностью массива.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.MakeByRefType">
      <summary>Возвращает объект <see cref="T:System.Type" />, который представляет текущий тип при передаче в качестве параметра <see langword="ref" /> (параметра <see langword="ByRef" /> в Visual Basic).</summary>
      <returns>Объект <see cref="T:System.Type" />, который представляет текущий тип при передаче в качестве параметра <see langword="ref" /> (параметра <see langword="ByRef" /> в Visual Basic).</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
      <summary>Замещает элементы массива типов для параметров типа определения текущего универсального типа и возвращает результирующий сконструированный тип.</summary>
      <param name="typeArguments">Массив типов, который должен быть замещен параметрами типа определения текущего универсального типа.</param>
      <returns>
        <see cref="T:System.Type" /> представляет сконструированный тип, сформированный путем замещения элементов объекта <paramref name="typeArguments" /> параметрами текущего универсального типа.</returns>
      <exception cref="T:System.InvalidOperationException">Текущий тип не представляет определение универсального типа. То есть <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> возвращает <see langword="false" />.</exception>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="typeArguments" /> имеет значение <see langword="null" />.  

или - 
Любой элемент <paramref name="typeArguments" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">Свойство <see cref="P:System.Type.Module" /> любого элемента <paramref name="typeArguments" /> — <see langword="null" />.  

или - 
Свойство <see cref="P:System.Reflection.Module.Assembly" /> модуля любого элемента <paramref name="typeArguments" /> — <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.MakePointerType">
      <summary>Возвращает объект <see cref="T:System.Type" />, который представляет тип неуправляемого указателя на текущий тип.</summary>
      <returns>Объект <see cref="T:System.Type" />, который представляет тип неуправляемого указателя на текущий тип.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.Module">
      <summary>Извлекает динамический модуль, который содержит определение данного типа.</summary>
      <returns>Только для чтения. Извлекает динамический модуль, который содержит определение данного типа.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.Name">
      <summary>Извлекает имя данного типа.</summary>
      <returns>Только для чтения. Извлекает имя <see cref="T:System.String" /> данного типа.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.Namespace">
      <summary>Получает пространство имен, в котором определен этот объект <see langword="TypeBuilder" />.</summary>
      <returns>Только для чтения. Получает пространство имен, в котором определен этот объект <see langword="TypeBuilder" /> .</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.PackingSize">
      <summary>Получает размер упаковки данного типа.</summary>
      <returns>Только для чтения. Получает размер упаковки данного типа.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.ReflectedType">
      <summary>Возвращает тип, который был использован для получения этого типа.</summary>
      <returns>Только для чтения. Тип, который был использован для получения этого типа.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>Задает настраиваемый атрибут с помощью большого двоичного объекта пользовательских атрибутов.</summary>
      <param name="con">Конструктор настраиваемого атрибута.</param>
      <param name="binaryAttribute">Большой двоичный объект байтов, предоставляющий атрибуты.</param>
      <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="con" /> или <paramref name="binaryAttribute" /> — <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Для текущего динамического типа свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> имеет значение <see langword="true" />, но свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> имеет значение <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>Задает настраиваемый атрибут с помощью построителя настраиваемых атрибутов.</summary>
      <param name="customBuilder">Экземпляр вспомогательного класса для определения настраиваемого атрибута.</param>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="customBuilder" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Для текущего динамического типа свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> имеет значение <see langword="true" />, но свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> имеет значение <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
      <summary>Задает базовый тип конструируемого в настоящий момент типа.</summary>
      <param name="parent">Новый базовый тип.</param>
      <exception cref="T:System.InvalidOperationException">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
-или- 
 <paramref name="parent" /> имеет значение <see langword="null" />, и текущий экземпляр представляет интерфейс, атрибуты которого не включают <see cref="F:System.Reflection.TypeAttributes.Abstract" />.  

или - 
Для текущего динамического типа свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> имеет значение <see langword="true" />, но свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> имеет значение <see langword="false" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" /> является интерфейсом. Это условие исключения было впервые представлено в .NET Framework 2.0.</exception>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.Size">
      <summary>Получает общий размер типа.</summary>
      <returns>Только для чтения. Получает общий размер этого типа.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.ToString">
      <summary>Возвращает имя типа, исключая пространство имен.</summary>
      <returns>Только для чтения. Имя типа, исключая пространство имен.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.TypeHandle">
      <summary>Не поддерживается в динамических модулях.</summary>
      <returns>Только для чтения.</returns>
      <exception cref="T:System.NotSupportedException">Не поддерживается в динамических модулях.</exception>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.UnderlyingSystemType">
      <summary>Возвращает базовый системный тип для данного <see langword="TypeBuilder" />.</summary>
      <returns>Только для чтения. Возвращает базовый системный тип.</returns>
      <exception cref="T:System.InvalidOperationException">Этот тип является перечислением, но базовый системный тип отсутствует.</exception>
    </member>
    <member name="F:System.Reflection.Emit.TypeBuilder.UnspecifiedTypeSize">
      <summary>Представляет, что общий размер для типа не указан.</summary>
    </member>
  </members>
</doc>