<?xml version="1.0" encoding="utf-8"?>
<doc xmlns:vsli="https://github.com/sk-0520/vs-localized-intellisense/tree/master/schema/2024">
  <assembly>
    <name>System.Threading</name>
  </assembly>
  <members>
    <member name="T:System.Threading.AbandonedMutexException">
      <summary vsli:raw="The exception that is thrown when one thread acquires a &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that another thread has abandoned by exiting without releasing it.">Die Ausnahme, die ausgelöst wird, wenn ein Thread ein <see cref="T:System.Threading.Mutex" />-Objekt abruft, das von einem anderen Thread abgebrochen wurde, indem das Objekt beim Beenden nicht freigegeben wurde.</summary>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.AbandonedMutexException&quot; /&gt; class with default values.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.AbandonedMutexException" />-Klasse mit Standardwerten.</summary>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.Int32,System.Threading.WaitHandle)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.AbandonedMutexException&quot; /&gt; class with a specified index for the abandoned mutex, if applicable, and a &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that represents the mutex.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.AbandonedMutexException" />-Klasse mit einem festgelegten Index für den abgebrochenen Mutex (falls zutreffend) und einem <see cref="T:System.Threading.Mutex" />-Objekt, das den Mutex darstellt.</summary>
      <param name="location" vsli:raw="The index of the abandoned mutex in the array of wait handles if the exception is thrown for the &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitAny&quot; /&gt; method, or -1 if the exception is thrown for the &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitOne&quot; /&gt; or &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitAll&quot; /&gt; methods.">Der Index des abgebrochenen Mutex im Array von Wait-Handles, wenn die Ausnahme für die <see cref="Overload:System.Threading.WaitHandle.WaitAny" />-Methode ausgelöst wird, oder –1, wenn die Ausnahme für die <see cref="Overload:System.Threading.WaitHandle.WaitOne" />-Methode oder die <see cref="Overload:System.Threading.WaitHandle.WaitAll" />-Methode ausgelöst wird.</param>
      <param name="handle" vsli:raw="A &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that represents the abandoned mutex.">Ein <see cref="T:System.Threading.Mutex" />-Objekt, das den abgebrochenen Mutex darstellt.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.AbandonedMutexException&quot; /&gt; class with serialized data.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.AbandonedMutexException" />-Klasse mit serialisierten Daten.</summary>
      <param name="info" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.SerializationInfo&quot; /&gt; object that holds the serialized object data about the exception being thrown.">Das <see cref="T:System.Runtime.Serialization.SerializationInfo" />-Objekt, das die serialisierten Objektdaten für die ausgelöste Ausnahme enthält.</param>
      <param name="context" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.StreamingContext&quot; /&gt; object that contains contextual information about the source or destination.">Das <see cref="T:System.Runtime.Serialization.StreamingContext" />-Objekt, das die Kontextinformationen für die Quelle oder das Ziel enthält.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.AbandonedMutexException&quot; /&gt; class with a specified error message.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.AbandonedMutexException" />-Klasse mit einer angegebenen Fehlermeldung.</summary>
      <param name="message" vsli:raw="An error message that explains the reason for the exception.">Eine Fehlermeldung, in der die Ursache der Ausnahme erklärt wird.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String,System.Exception)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.AbandonedMutexException&quot; /&gt; class with a specified error message and inner exception.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.AbandonedMutexException" />-Klasse mit einer festgelegten Fehlermeldung und einer festgelegten inneren Ausnahme.</summary>
      <param name="message" vsli:raw="An error message that explains the reason for the exception.">Eine Fehlermeldung, in der die Ursache der Ausnahme erklärt wird.</param>
      <param name="inner" vsli:raw="The exception that is the cause of the current exception. If the &lt;paramref name=&quot;inner&quot; /&gt; parameter is not &lt;see langword=&quot;null&quot; /&gt;, the current exception is raised in a &lt;see langword=&quot;catch&quot; /&gt; block that handles the inner exception.">Die Ausnahme, die die Ursache der aktuellen Ausnahme ist. Wenn der <paramref name="inner" />-Parameter nicht <see langword="null" /> ist, wird die aktuelle Ausnahme in einem <see langword="catch" />-Block ausgelöst, der die innere Ausnahme behandelt.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String,System.Exception,System.Int32,System.Threading.WaitHandle)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.AbandonedMutexException&quot; /&gt; class with a specified error message, the inner exception, the index for the abandoned mutex, if applicable, and a &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that represents the mutex.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.AbandonedMutexException" />-Klasse mit einer festgelegten Fehlermeldung, der inneren Ausnahme, dem Index für den abgebrochenen Mutex (falls zutreffend) und einem <see cref="T:System.Threading.Mutex" />-Objekt, das den Mutex darstellt.</summary>
      <param name="message" vsli:raw="An error message that explains the reason for the exception.">Eine Fehlermeldung, in der die Ursache der Ausnahme erklärt wird.</param>
      <param name="inner" vsli:raw="The exception that is the cause of the current exception. If the &lt;paramref name=&quot;inner&quot; /&gt; parameter is not &lt;see langword=&quot;null&quot; /&gt;, the current exception is raised in a &lt;see langword=&quot;catch&quot; /&gt; block that handles the inner exception.">Die Ausnahme, die die Ursache der aktuellen Ausnahme ist. Wenn der <paramref name="inner" />-Parameter nicht <see langword="null" /> ist, wird die aktuelle Ausnahme in einem <see langword="catch" />-Block ausgelöst, der die innere Ausnahme behandelt.</param>
      <param name="location" vsli:raw="The index of the abandoned mutex in the array of wait handles if the exception is thrown for the &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitAny&quot; /&gt; method, or -1 if the exception is thrown for the &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitOne&quot; /&gt; or &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitAll&quot; /&gt; methods.">Der Index des abgebrochenen Mutex im Array von Wait-Handles, wenn die Ausnahme für die <see cref="Overload:System.Threading.WaitHandle.WaitAny" />-Methode ausgelöst wird, oder –1, wenn die Ausnahme für die <see cref="Overload:System.Threading.WaitHandle.WaitOne" />-Methode oder die <see cref="Overload:System.Threading.WaitHandle.WaitAll" />-Methode ausgelöst wird.</param>
      <param name="handle" vsli:raw="A &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that represents the abandoned mutex.">Ein <see cref="T:System.Threading.Mutex" />-Objekt, das den abgebrochenen Mutex darstellt.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String,System.Int32,System.Threading.WaitHandle)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.AbandonedMutexException&quot; /&gt; class with a specified error message, the index of the abandoned mutex, if applicable, and the abandoned mutex.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.AbandonedMutexException" />-Klasse mit einer festgelegten Fehlermeldung, dem Index des abgebrochenen Mutex (falls zutreffend) und dem abgebrochenen Mutex.</summary>
      <param name="message" vsli:raw="An error message that explains the reason for the exception.">Eine Fehlermeldung, in der die Ursache der Ausnahme erklärt wird.</param>
      <param name="location" vsli:raw="The index of the abandoned mutex in the array of wait handles if the exception is thrown for the &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitAny&quot; /&gt; method, or -1 if the exception is thrown for the &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitOne&quot; /&gt; or &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitAll&quot; /&gt; methods.">Der Index des abgebrochenen Mutex im Array von Wait-Handles, wenn die Ausnahme für die <see cref="Overload:System.Threading.WaitHandle.WaitAny" />-Methode ausgelöst wird, oder –1, wenn die Ausnahme für die <see cref="Overload:System.Threading.WaitHandle.WaitOne" />-Methode oder die <see cref="Overload:System.Threading.WaitHandle.WaitAll" />-Methode ausgelöst wird.</param>
      <param name="handle" vsli:raw="A &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that represents the abandoned mutex.">Ein <see cref="T:System.Threading.Mutex" />-Objekt, das den abgebrochenen Mutex darstellt.</param>
    </member>
    <member name="P:System.Threading.AbandonedMutexException.Mutex">
      <summary vsli:raw="Gets the abandoned mutex that caused the exception, if known.">Ruft den abgebrochenen Mutex ab, das die Ausnahme verursacht hat (falls bekannt).</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that represents the abandoned mutex, or &lt;see langword=&quot;null&quot; /&gt; if the abandoned mutex could not be identified.">Ein <see cref="T:System.Threading.Mutex" />-Objekt, das den abgebrochenen Mutex darstellt, oder <see langword="null" />, wenn der abgebrochene Mutex nicht bestimmt werden konnte.</returns>
    </member>
    <member name="P:System.Threading.AbandonedMutexException.MutexIndex">
      <summary vsli:raw="Gets the index of the abandoned mutex that caused the exception, if known.">Ruft den Index des abgebrochenen Mutex ab, der die Ausnahme verursacht hat (falls bekannt).</summary>
      <returns vsli:raw="The index, in the array of wait handles passed to the &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitAny&quot; /&gt; method, of the &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that represents the abandoned mutex, or -1 if the index of the abandoned mutex could not be determined.">Der Index <see cref="Overload:System.Threading.WaitHandle.WaitAny" /><see cref="T:System.Threading.Mutex" /> des-Objekts, das den abgebrochenen Mutex darstellt, im Array der Wait-Handles, das an die-Methode übermittelt wurde, oder-1, wenn der Index des abgebrochenen Mutex nicht bestimmt werden konnte.</returns>
    </member>
    <member name="T:System.Threading.AsyncFlowControl">
      <summary vsli:raw="Provides the functionality to restore the migration, or flow, of the execution context between threads.">Stellt die Funktionen zum Wiederherstellen der Migration oder des Flusses des Ausführungskontexts zwischen Threads bereit.</summary>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; class.">Gibt alle von der aktuellen Instanz der <see cref="T:System.Threading.AsyncFlowControl" />-Klasse verwendeten Ressourcen frei.</summary>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure is not used on the thread where it was created.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure has already been used to call &lt;see cref=&quot;M:System.Threading.AsyncFlowControl.Dispose&quot; /&gt; or &lt;see cref=&quot;M:System.Threading.AsyncFlowControl.Undo&quot; /&gt;.">Die <see cref="T:System.Threading.AsyncFlowControl" />-Struktur wird nicht für den Thread verwendet, für den sie erstellt wurde.  

oder - 
Die <see cref="T:System.Threading.AsyncFlowControl" />-Struktur wurde bereits für den Aufruf von <see cref="M:System.Threading.AsyncFlowControl.Dispose" /> oder <see cref="M:System.Threading.AsyncFlowControl.Undo" /> verwendet.</exception>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.Equals(System.Object)">
      <summary vsli:raw="Determines whether the specified object is equal to the current &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure.">Bestimmt, ob das angegebene Objekt und die aktuelle <see cref="T:System.Threading.AsyncFlowControl" />-Struktur gleich sind.</summary>
      <param name="obj" vsli:raw="An object to compare with the current structure.">Ein Objekt, das mit der aktuellen Struktur verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;obj&quot; /&gt; is an &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure and is equal to the current &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn <paramref name="obj" /> eine <see cref="T:System.Threading.AsyncFlowControl" />-Struktur und gleich der aktuellen <see cref="T:System.Threading.AsyncFlowControl" />-Struktur ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.Equals(System.Threading.AsyncFlowControl)">
      <summary vsli:raw="Determines whether the specified &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure is equal to the current &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure.">Bestimmt, ob die angegebene <see cref="T:System.Threading.AsyncFlowControl" />-Struktur und die aktuelle <see cref="T:System.Threading.AsyncFlowControl" />-Struktur gleich sind.</summary>
      <param name="obj" vsli:raw="An &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure to compare with the current structure.">Eine <see cref="T:System.Threading.AsyncFlowControl" />-Struktur, die mit der aktuellen Struktur verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;obj&quot; /&gt; is equal to the current &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn <paramref name="obj" /> der aktuellen <see cref="T:System.Threading.AsyncFlowControl" />-Struktur entspricht, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.GetHashCode">
      <summary vsli:raw="Gets a hash code for the current &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure.">Ruft einen Hashcode für die aktuelle <see cref="T:System.Threading.AsyncFlowControl" />-Struktur ab.</summary>
      <returns vsli:raw="A hash code for the current &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure.">Ein Hashcode für die aktuelle <see cref="T:System.Threading.AsyncFlowControl" />-Struktur.</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.op_Equality(System.Threading.AsyncFlowControl,System.Threading.AsyncFlowControl)">
      <summary vsli:raw="Compares two &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structures to determine whether they are equal.">Vergleicht zwei <see cref="T:System.Threading.AsyncFlowControl" />-Strukturen, um zu bestimmen, ob diese gleich sind.</summary>
      <param name="a" vsli:raw="An &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure.">Eine <see cref="T:System.Threading.AsyncFlowControl" />-Struktur.</param>
      <param name="b" vsli:raw="An &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure.">Eine <see cref="T:System.Threading.AsyncFlowControl" />-Struktur.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two structures are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn die zwei Strukturen gleich sind, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.op_Inequality(System.Threading.AsyncFlowControl,System.Threading.AsyncFlowControl)">
      <summary vsli:raw="Compares two &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structures to determine whether they are not equal.">Vergleicht zwei <see cref="T:System.Threading.AsyncFlowControl" />-Strukturen, um zu bestimmen, ob diese ungleich sind.</summary>
      <param name="a" vsli:raw="An &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure.">Eine <see cref="T:System.Threading.AsyncFlowControl" />-Struktur.</param>
      <param name="b" vsli:raw="An &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure.">Eine <see cref="T:System.Threading.AsyncFlowControl" />-Struktur.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the structures are not equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn die Strukturen ungleich sind, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.Undo">
      <summary vsli:raw="Restores the flow of the execution context between threads.">Stellt den Fluss des Ausführungskontexts zwischen Threads wieder her.</summary>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure is not used on the thread where it was created.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure has already been used to call &lt;see cref=&quot;M:System.Threading.AsyncFlowControl.Dispose&quot; /&gt; or &lt;see cref=&quot;M:System.Threading.AsyncFlowControl.Undo&quot; /&gt;.">Die <see cref="T:System.Threading.AsyncFlowControl" />-Struktur wird nicht für den Thread verwendet, für den sie erstellt wurde.  

oder - 
Die <see cref="T:System.Threading.AsyncFlowControl" />-Struktur wurde bereits für den Aufruf von <see cref="M:System.Threading.AsyncFlowControl.Dispose" /> oder <see cref="M:System.Threading.AsyncFlowControl.Undo" /> verwendet.</exception>
    </member>
    <member name="T:System.Threading.AsyncLocal`1">
      <summary vsli:raw="Represents ambient data that is local to a given asynchronous control flow, such as an asynchronous method.">Stellt Umgebungsdaten dar, die für eine angegebene asynchrone Ablaufsteuerung lokal sind, wie etwa eine asynchrone Methode.</summary>
      <typeparam name="T" vsli:raw="The type of the ambient data.">Der Typ der Umgebungsdaten.</typeparam>
    </member>
    <member name="M:System.Threading.AsyncLocal`1.#ctor">
      <summary vsli:raw="Instantiates an &lt;see cref=&quot;T:System.Threading.AsyncLocal`1&quot; /&gt; instance that does not receive change notifications.">Instanziiert eine <see cref="T:System.Threading.AsyncLocal`1" />-Instanz, die keine Änderungsbenachrichtigungen empfängt.</summary>
    </member>
    <member name="M:System.Threading.AsyncLocal`1.#ctor(System.Action{System.Threading.AsyncLocalValueChangedArgs{`0}})">
      <summary vsli:raw="Instantiates an &lt;see cref=&quot;T:System.Threading.AsyncLocal`1&quot; /&gt; local instance that receives change notifications.">Instanziiert eine lokale <see cref="T:System.Threading.AsyncLocal`1" />-Instanz, die Änderungsbenachrichtigungen empfängt.</summary>
      <param name="valueChangedHandler" vsli:raw="The delegate that is called whenever the current value changes on any thread.">Der Delegat, der aufgerufen wird, wenn sich der aktuelle Wert auf einem beliebigen Thread ändert.</param>
    </member>
    <member name="P:System.Threading.AsyncLocal`1.Value">
      <summary vsli:raw="Gets or sets the value of the ambient data.">Ruft den Wert der Umgebungsdaten ab oder legt ihn fest.</summary>
      <returns vsli:raw="The value of the ambient data. If no value has been set, the returned value is &lt;c&gt;default(T)&lt;/c&gt;.">Der Wert der Umgebungsdaten. Wenn kein Wert festgelegt wurde, ist der zurückgegebene Wert <c>default (T)</c>.</returns>
    </member>
    <member name="T:System.Threading.AsyncLocalValueChangedArgs`1">
      <summary vsli:raw="The class that provides data change information to &lt;see cref=&quot;T:System.Threading.AsyncLocal`1&quot; /&gt; instances that register for change notifications.">Die Klasse, die <see cref="T:System.Threading.AsyncLocal`1" />-Instanzen, die sich für Änderungsbenachrichtigungen registrieren, Informationen über Datenänderungen zur Verfügung stellt.</summary>
      <typeparam name="T" vsli:raw="The type of the data.">Der Typ der Daten.</typeparam>
    </member>
    <member name="P:System.Threading.AsyncLocalValueChangedArgs`1.CurrentValue">
      <summary vsli:raw="Gets the data's current value.">Ruft den aktuellen Wert der Daten ab.</summary>
      <returns vsli:raw="The data's current value.">Der aktuelle Wert der Daten.</returns>
    </member>
    <member name="P:System.Threading.AsyncLocalValueChangedArgs`1.PreviousValue">
      <summary vsli:raw="Gets the data's previous value.">Ruft den vorherigen Wert der Daten ab.</summary>
      <returns vsli:raw="The data's previous value.">Der vorherige Wert der Daten.</returns>
    </member>
    <member name="P:System.Threading.AsyncLocalValueChangedArgs`1.ThreadContextChanged">
      <summary vsli:raw="Returns a value that indicates whether the value changes because of a change of execution context.">Gibt einen Wert zurück, der angibt, ob sich der Wert aufgrund einer Änderung des Ausführungskontexts ändert.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the value changed because of a change of execution context; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn sich der Wert aufgrund einer Änderung des Ausführungstexts ändert, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="T:System.Threading.AutoResetEvent">
      <summary vsli:raw="Represents a thread synchronization event that, when signaled, resets automatically after releasing a single waiting thread. This class cannot be inherited.">Stellt ein Threadsynchronisierungsereignis dar, das automatisch ausgelöst wird, nachdem ein einzelner wartender Thread freigegeben wurde. Diese Klasse kann nicht vererbt werden.</summary>
    </member>
    <member name="M:System.Threading.AutoResetEvent.#ctor(System.Boolean)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.AutoResetEvent&quot; /&gt; class with a Boolean value indicating whether to set the initial state to signaled.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.AutoResetEvent" />-Klasse mit einem booleschen Wert, der angibt, ob der anfängliche Zustand auf signalisiert festgelegt werden soll.</summary>
      <param name="initialState" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set the initial state to signaled; &lt;see langword=&quot;false&quot; /&gt; to set the initial state to non-signaled.">
        <see langword="true" />, wenn der anfängliche Zustand auf signalisiert festgelegt werden soll. <see langword="false" />, wenn der anfängliche Zustand auf nicht signalisiert festgelegt werden soll.</param>
    </member>
    <member name="T:System.Threading.Barrier">
      <summary vsli:raw="Enables multiple tasks to cooperatively work on an algorithm in parallel through multiple phases.">Ermöglicht es mehreren Aufgaben, parallel über mehrere Phasen gemeinsam an einem Algorithmus zu arbeiten.</summary>
    </member>
    <member name="M:System.Threading.Barrier.#ctor(System.Int32)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt; class.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.Barrier" />-Klasse.</summary>
      <param name="participantCount" vsli:raw="The number of participating threads.">Die Anzahl teilnehmender Threads.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;participantCount&quot; /&gt; is less than 0 or greater than 32,767.">
        <paramref name="participantCount" /> ist kleiner als 0 oder größer als 32.767.</exception>
    </member>
    <member name="M:System.Threading.Barrier.#ctor(System.Int32,System.Action{System.Threading.Barrier})">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt; class.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.Barrier" />-Klasse.</summary>
      <param name="participantCount" vsli:raw="The number of participating threads.">Die Anzahl teilnehmender Threads.</param>
      <param name="postPhaseAction" vsli:raw="The &lt;see cref=&quot;T:System.Action`1&quot; /&gt; to be executed after each phase. null (Nothing in Visual Basic) may be passed to indicate no action is taken.">Das nach jeder Phase auszuführende <see cref="T:System.Action`1" />. NULL (Nothing in Visual Basic) kann übergeben werden. Damit wird angegeben, dass keine Aktion ausgeführt wird.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;participantCount&quot; /&gt; is less than 0 or greater than 32,767.">
        <paramref name="participantCount" /> ist kleiner als 0 oder größer als 32.767.</exception>
    </member>
    <member name="M:System.Threading.Barrier.AddParticipant">
      <summary vsli:raw="Notifies the &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt; that there will be an additional participant.">Benachrichtigt <see cref="T:System.Threading.Barrier" /> über das Vorhandensein eines weiteren Teilnehmers.</summary>
      <returns vsli:raw="The phase number of the barrier in which the new participants will first participate.">Die Phasennummer der Grenze, an der die neuen Teilnehmer zuerst teilnehmen.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Die aktuelle Instanz wurde bereits verworfen.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Adding a participant would cause the barrier's participant count to exceed 32,767.  &#xA;  &#xA; -or-  &#xA;  &#xA; The method was invoked from within a post-phase action.">Einen Teilnehmer hinzuzufügen würde verursachen, dass die Teilnehmeranzahl der Barriere 32.767 überschreitet.  

oder -  

 Die Methode wurde aus einer Postphasenaktion aufgerufen.</exception>
    </member>
    <member name="M:System.Threading.Barrier.AddParticipants(System.Int32)">
      <summary vsli:raw="Notifies the &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt; that there will be additional participants.">Benachrichtigt <see cref="T:System.Threading.Barrier" /> über das Vorhandensein weiterer Teilnehmer.</summary>
      <param name="participantCount" vsli:raw="The number of additional participants to add to the barrier.">Die Anzahl zusätzlicher Teilnehmer, die der Grenze hinzugefügt werden soll.</param>
      <returns vsli:raw="The phase number of the barrier in which the new participants will first participate.">Die Phasennummer der Grenze, an der die neuen Teilnehmer zuerst teilnehmen.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Die aktuelle Instanz wurde bereits verworfen.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;participantCount&quot; /&gt; is less than 0.  &#xA;  &#xA; -or-  &#xA;  &#xA; Adding &lt;paramref name=&quot;participantCount&quot; /&gt; participants would cause the barrier's participant count to exceed 32,767.">
        <paramref name="participantCount" /> ist kleiner als 0.  

oder - 
<paramref name="participantCount" />-Teilnehmer hinzuzufügen würde verursachen, dass die Teilnehmeranzahl der Barriere 32.767 überschreitet.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method was invoked from within a post-phase action.">Die Methode wurde aus einer Postphasenaktion aufgerufen.</exception>
    </member>
    <member name="P:System.Threading.Barrier.CurrentPhaseNumber">
      <summary vsli:raw="Gets the number of the barrier's current phase.">Ruft die Nummer der aktuellen Phase der Grenze ab.</summary>
      <returns vsli:raw="Returns the number of the barrier's current phase.">Gibt die Nummer der aktuellen Phase der Grenze zurück.</returns>
    </member>
    <member name="M:System.Threading.Barrier.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt; class.">Gibt alle von der aktuellen Instanz der <see cref="T:System.Threading.Barrier" />-Klasse verwendeten Ressourcen frei.</summary>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method was invoked from within a post-phase action.">Die Methode wurde aus einer Postphasenaktion aufgerufen.</exception>
    </member>
    <member name="M:System.Threading.Barrier.Dispose(System.Boolean)">
      <summary vsli:raw="Releases the unmanaged resources used by the &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt;, and optionally releases the managed resources.">Gibt die von <see cref="T:System.Threading.Barrier" /> verwendeten nicht verwalteten Ressourcen und optional die verwalteten Ressourcen frei.</summary>
      <param name="disposing" vsli:raw="true to release both managed and unmanaged resources; false to release only unmanaged resources.">true, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, false, um nur nicht verwaltete Ressourcen freizugeben.</param>
    </member>
    <member name="P:System.Threading.Barrier.ParticipantCount">
      <summary vsli:raw="Gets the total number of participants in the barrier.">Ruft die Gesamtanzahl von Teilnehmern für die Grenze ab.</summary>
      <returns vsli:raw="Returns the total number of participants in the barrier.">Gibt die Gesamtanzahl von Teilnehmern für die Grenze zurück.</returns>
    </member>
    <member name="P:System.Threading.Barrier.ParticipantsRemaining">
      <summary vsli:raw="Gets the number of participants in the barrier that haven't yet signaled in the current phase.">Ruft die Anzahl von Teilnehmern für die Grenze ab, die in der aktuellen Phase noch nicht signalisiert haben.</summary>
      <returns vsli:raw="Returns the number of participants in the barrier that haven't yet signaled in the current phase.">Gibt die Anzahl der Teilnehmer an der Barriere zurück, die in der aktuellen Phase noch nicht signalisiert haben.</returns>
    </member>
    <member name="M:System.Threading.Barrier.RemoveParticipant">
      <summary vsli:raw="Notifies the &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt; that there will be one less participant.">Benachrichtigt <see cref="T:System.Threading.Barrier" />, dass ein Teilnehmer nicht mehr vorhanden ist.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Die aktuelle Instanz wurde bereits verworfen.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The barrier already has 0 participants.  &#xA;  &#xA; -or-  &#xA;  &#xA; The method was invoked from within a post-phase action.">Die Barriere hat bereits 0 Teilnehmer.  

oder -  

 Die Methode wurde aus einer Postphasenaktion aufgerufen.</exception>
    </member>
    <member name="M:System.Threading.Barrier.RemoveParticipants(System.Int32)">
      <summary vsli:raw="Notifies the &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt; that there will be fewer participants.">Benachrichtigt <see cref="T:System.Threading.Barrier" /> über die geringere Anzahl von Teilnehmern.</summary>
      <param name="participantCount" vsli:raw="The number of additional participants to remove from the barrier.">Die Anzahl zusätzlicher Teilnehmer, die aus der Grenze entfernt werden sollen.</param>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Die aktuelle Instanz wurde bereits verworfen.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The total participant count is less than the specified &lt;paramref name=&quot;participantCount&quot; /&gt;">Die gesamte Teilnehmeranzahl ist kleiner als der angegebene <paramref name="participantCount" /></exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The barrier already has 0 participants.  &#xA;  &#xA; -or-  &#xA;  &#xA; The method was invoked from within a post-phase action.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current participant count is less than the specified participantCount.">Die Barriere hat bereits 0 Teilnehmer.  

oder -  

 Die Methode wurde aus einer Postphasenaktion aufgerufen.  

oder -  

 aktuelle Teilnehmeranzahl ist kleiner als der angegebene participantCount</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait">
      <summary vsli:raw="Signals that a participant has reached the barrier and waits for all other participants to reach the barrier as well.">Signalisiert, dass ein Teilnehmer die Barriere erreicht hat und darauf wartet, dass alle anderen Teilnehmer die Barriere ebenfalls erreichen.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Die aktuelle Instanz wurde bereits verworfen.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method was invoked from within a post-phase action, the barrier currently has 0 participants, or the barrier is signaled by more threads than are registered as participants.">Die Methode wurde innerhalb einer Postphasenaktion aufgerufen, die Barriere hat derzeit 0 Teilnehmer, oder die Barriere wird von mehr Threads gemeldet als Teilnehmer registriert sind.</exception>
      <exception cref="T:System.Threading.BarrierPostPhaseException" vsli:raw="If an exception is thrown from the post phase action of a Barrier after all participating threads have called SignalAndWait, the exception will be wrapped in a BarrierPostPhaseException and be thrown on all participating threads.">Wenn eine Ausnahme aus der Post-Phasenaktion einer Grenze ausgelöst wird, nachdem alle teilnehmenden Threads SignalAndWait aufgerufen haben, wird die Ausnahme in einer BarrierPostPhaseException umbrochen und für alle teilnehmenden Threads ausgelöst.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.Int32)">
      <summary vsli:raw="Signals that a participant has reached the barrier and waits for all other participants to reach the barrier as well, using a 32-bit signed integer to measure the timeout.">Signalisiert, dass ein Teilnehmer die Barriere erreicht hat und darauf wartet, dass alle anderen Teilnehmer die Barriere ebenfalls erreichen. Dabei wird eine 32-Bit-Ganzzahl mit Vorzeichen zum Messen des Timeouts verwendet.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;(-1) to wait indefinitely.">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if all participants reached the barrier within the specified time; otherwise &lt;see langword=&quot;false&quot; /&gt;.">wenn alle Teilnehmer die Grenze innerhalb der angegebenen Zeit erreicht haben, andernfalls false.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Die aktuelle Instanz wurde bereits verworfen.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method was invoked from within a post-phase action, the barrier currently has 0 participants, or the barrier is signaled by more threads than are registered as participants.">Die Methode wurde innerhalb einer Postphasenaktion aufgerufen, die Barriere hat derzeit 0 Teilnehmer, oder die Barriere wird von mehr Threads gemeldet als Teilnehmer registriert sind.</exception>
      <exception cref="T:System.Threading.BarrierPostPhaseException" vsli:raw="If an exception is thrown from the post phase action of a Barrier after all participating threads have called SignalAndWait, the exception will be wrapped in a BarrierPostPhaseException and be thrown on all participating threads.">Wenn eine Ausnahme aus der Post-Phasenaktion einer Grenze ausgelöst wird, nachdem alle teilnehmenden Threads SignalAndWait aufgerufen haben, wird die Ausnahme in einer BarrierPostPhaseException umbrochen und für alle teilnehmenden Threads ausgelöst.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.Int32,System.Threading.CancellationToken)">
      <summary vsli:raw="Signals that a participant has reached the barrier and waits for all other participants to reach the barrier as well, using a 32-bit signed integer to measure the timeout, while observing a cancellation token.">Signalisiert, dass ein Teilnehmer die Barriere erreicht hat und darauf wartet, dass alle anderen Teilnehmer die Barriere ebenfalls erreichen. Dabei wird eine 32-Bit-Ganzzahl mit Vorzeichen zum Messen des Timeouts verwendet und ein Abbruchtoken berücksichtigt.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;(-1) to wait indefinitely.">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">Das zu überwachende <see cref="T:System.Threading.CancellationToken" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if all participants reached the barrier within the specified time; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">wenn alle Teilnehmer die Grenze innerhalb der angegebenen Zeit erreicht haben, andernfalls false.</returns>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; has been canceled.">
        <paramref name="cancellationToken" /> wurde abgebrochen.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Die aktuelle Instanz wurde bereits verworfen.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method was invoked from within a post-phase action, the barrier currently has 0 participants, or the barrier is signaled by more threads than are registered as participants.">Die Methode wurde innerhalb einer Postphasenaktion aufgerufen, die Barriere hat derzeit 0 Teilnehmer, oder die Barriere wird von mehr Threads gemeldet als Teilnehmer registriert sind.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.Threading.CancellationToken)">
      <summary vsli:raw="Signals that a participant has reached the barrier and waits for all other participants to reach the barrier, while observing a cancellation token.">Signalisiert, dass ein Teilnehmer die Barriere erreicht hat und darauf wartet, dass alle anderen Teilnehmer die Barriere erreichen. Dabei wird ein Abbruchtoken überwacht.</summary>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">Das zu überwachende <see cref="T:System.Threading.CancellationToken" />.</param>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; has been canceled.">
        <paramref name="cancellationToken" /> wurde abgebrochen.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Die aktuelle Instanz wurde bereits verworfen.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method was invoked from within a post-phase action, the barrier currently has 0 participants, or the barrier is signaled by more threads than are registered as participants.">Die Methode wurde innerhalb einer Postphasenaktion aufgerufen, die Barriere hat derzeit 0 Teilnehmer, oder die Barriere wird von mehr Threads gemeldet als Teilnehmer registriert sind.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.TimeSpan)">
      <summary vsli:raw="Signals that a participant has reached the barrier and waits for all other participants to reach the barrier as well, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; object to measure the time interval.">Signalisiert, dass ein Teilnehmer die Barriere erreicht hat und darauf wartet, dass alle anderen Teilnehmer die Barriere ebenfalls erreichen. Dabei wird das Zeitintervall mit einem <see cref="T:System.TimeSpan" />-Objekt gemessen.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely.">Eine <see cref="T:System.TimeSpan" />-Struktur, die die Anzahl der zu wartenden Millisekunden angibt, oder eine <see cref="T:System.TimeSpan" />-Struktur, die -1 Millisekunden zum unendlichen Warten angibt.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if all other participants reached the barrier; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">True, wenn alle anderen Teilnehmer die Grenze erreicht haben, andernfalls false.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Die aktuelle Instanz wurde bereits verworfen.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out, or it is greater than 32,767.">
        <paramref name="timeout" /> ist eine negative Zahl ungleich -1 Millisekunden, die ein unendliches Timeout darstellt, oder ist größer als 32.767.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method was invoked from within a post-phase action, the barrier currently has 0 participants, or the barrier is signaled by more threads than are registered as participants.">Die Methode wurde innerhalb einer Postphasenaktion aufgerufen, die Barriere hat derzeit 0 Teilnehmer, oder die Barriere wird von mehr Threads gemeldet als Teilnehmer registriert sind.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary vsli:raw="Signals that a participant has reached the barrier and waits for all other participants to reach the barrier as well, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; object to measure the time interval, while observing a cancellation token.">Signalisiert, dass ein Teilnehmer die Barriere erreicht hat und darauf wartet, dass alle anderen Teilnehmer die Barriere ebenfalls erreichen. Dabei wird das Zeitintervall mit einem <see cref="T:System.TimeSpan" />-Objekt gemessen und ein Abbruchtoken berücksichtigt.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely.">Eine <see cref="T:System.TimeSpan" />-Struktur, die die Anzahl der zu wartenden Millisekunden angibt, oder eine <see cref="T:System.TimeSpan" />-Struktur, die -1 Millisekunden zum unendlichen Warten angibt.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">Das zu überwachende <see cref="T:System.Threading.CancellationToken" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if all other participants reached the barrier; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">True, wenn alle anderen Teilnehmer die Grenze erreicht haben, andernfalls false.</returns>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; has been canceled.">
        <paramref name="cancellationToken" /> wurde abgebrochen.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Die aktuelle Instanz wurde bereits verworfen.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out.">
        <paramref name="timeout" /> ist eine negative Zahl ungleich -1 Millisekunden, die ein unendliches Timeout darstellt.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method was invoked from within a post-phase action, the barrier currently has 0 participants, or the barrier is signaled by more threads than are registered as participants.">Die Methode wurde innerhalb einer Postphasenaktion aufgerufen, die Barriere hat derzeit 0 Teilnehmer, oder die Barriere wird von mehr Threads gemeldet als Teilnehmer registriert sind.</exception>
    </member>
    <member name="T:System.Threading.BarrierPostPhaseException">
      <summary vsli:raw="The exception that is thrown when the post-phase action of a &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt; fails.">Die Ausnahme, die bei einem Fehler der Nachphasenaktion einer <see cref="T:System.Threading.Barrier" /> ausgelöst wird.</summary>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.BarrierPostPhaseException&quot; /&gt; class with a system-supplied message that describes the error.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.BarrierPostPhaseException" />-Klasse mit einer vom System generierten Meldung, die den Fehler beschreibt.</summary>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.Exception)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.BarrierPostPhaseException&quot; /&gt; class with the specified inner exception.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.BarrierPostPhaseException" />-Klasse mit der angegebenen internen Ausnahme.</summary>
      <param name="innerException" vsli:raw="The exception that is the cause of the current exception.">Die Ausnahme, die die Ursache der aktuellen Ausnahme ist.</param>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.BarrierPostPhaseException&quot; /&gt; class with serialized data.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.BarrierPostPhaseException" />-Klasse mit serialisierten Daten.</summary>
      <param name="info" vsli:raw="The object that holds the serialized object data.">Das Objekt, das die Daten des serialisierten Objekts enthält.</param>
      <param name="context" vsli:raw="The contextual information about the source or destination.">Die Kontextinformationen zur Quelle bzw. zum Ziel.</param>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.BarrierPostPhaseException&quot; /&gt; class with a specified message that describes the error.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.BarrierPostPhaseException" />-Klasse mit einer angegebenen Meldung, die den Fehler beschreibt.</summary>
      <param name="message" vsli:raw="The message that describes the exception. The caller of this constructor is required to ensure that this string has been localized for the current system culture.">Die Meldung, in der die Ausnahme beschrieben wird Der Aufrufer dieses Konstruktors muss sicherstellen, dass diese Zeichenfolge für die aktuelle Systemkultur lokalisiert wurde.</param>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.String,System.Exception)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.BarrierPostPhaseException&quot; /&gt; class with a specified error message and a reference to the inner exception that is the cause of this exception.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.BarrierPostPhaseException" />-Klasse mit einer angegebenen Fehlermeldung und einem Verweis auf die innere Ausnahme, die diese Ausnahme ausgelöst hat.</summary>
      <param name="message" vsli:raw="The message that describes the exception. The caller of this constructor is required to ensure that this string has been localized for the current system culture.">Die Meldung, in der die Ausnahme beschrieben wird Der Aufrufer dieses Konstruktors muss sicherstellen, dass diese Zeichenfolge für die aktuelle Systemkultur lokalisiert wurde.</param>
      <param name="innerException" vsli:raw="The exception that is the cause of the current exception. If the &lt;paramref name=&quot;innerException&quot; /&gt; parameter is not &lt;see langword=&quot;null&quot; /&gt;, the current exception is raised in a &lt;see langword=&quot;catch&quot; /&gt; block that handles the inner exception.">Die Ausnahme, die die Ursache der aktuellen Ausnahme ist. Wenn der <paramref name="innerException" />-Parameter nicht <see langword="null" /> ist, wird die aktuelle Ausnahme in einem <see langword="catch" />-Block ausgelöst, der die innere Ausnahme behandelt.</param>
    </member>
    <member name="T:System.Threading.ContextCallback">
      <summary vsli:raw="Represents a method to be called within a new context.">Stellt eine Methode dar, die in einem neuen Kontext aufgerufen werden muss.</summary>
      <param name="state" vsli:raw="An object containing information to be used by the callback method each time it executes.">Ein Objekt mit den Informationen, die von der Rückrufmethode bei jeder Ausführung verwendet werden.</param>
    </member>
    <member name="T:System.Threading.CountdownEvent">
      <summary vsli:raw="Represents a synchronization primitive that is signaled when its count reaches zero.">Stellt einen Synchronisierungsprimitiven dar, dem signalisiert wird, wenn sein Zähler 0 (null) erreicht.</summary>
    </member>
    <member name="M:System.Threading.CountdownEvent.#ctor(System.Int32)">
      <summary vsli:raw="Initializes a new instance of &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; class with the specified count.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.CountdownEvent" />-Klasse mit der angegebenen Anzahl.</summary>
      <param name="initialCount" vsli:raw="The number of signals initially required to set the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt;.">Die zum Festlegen von <see cref="T:System.Threading.CountdownEvent" /> ursprünglich erforderliche Anzahl von Signalen.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;initialCount&quot; /&gt; is less than 0.">
        <paramref name="initialCount" /> ist kleiner als 0.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.AddCount">
      <summary vsli:raw="Increments the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt;'s current count by one.">Erhöht die aktuelle Anzahl von <see cref="T:System.Threading.CountdownEvent" /> um 1.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Die aktuelle Instanz wurde bereits verworfen.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The current instance is already set.&#xA;&#xA; -or-&#xA;&#xA; &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; is equal to or greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">Die aktuelle Instanz ist bereits festgelegt.  

oder - 
<see cref="P:System.Threading.CountdownEvent.CurrentCount" /> ist größer oder gleich <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.AddCount(System.Int32)">
      <summary vsli:raw="Increments the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt;'s current count by a specified value.">Erhöht die aktuelle Anzahl von <see cref="T:System.Threading.CountdownEvent" /> um einen angegebenen Wert.</summary>
      <param name="signalCount" vsli:raw="The value by which to increase &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt;.">Der Wert, um den <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> erhöht werden soll.</param>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Die aktuelle Instanz wurde bereits verworfen.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;signalCount&quot; /&gt; is less than or equal to 0.">
        <paramref name="signalCount" /> ist kleiner oder gleich 0.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The current instance is already set.&#xA;&#xA; -or-&#xA;&#xA; &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; is equal to or greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt; after count is incremented by &lt;paramref name=&quot;signalCount&quot; /&gt;.">Die aktuelle Instanz ist bereits festgelegt.  

oder - 
<see cref="P:System.Threading.CountdownEvent.CurrentCount" /> ist größer gleich <see cref="F:System.Int32.MaxValue" />, nach die Anzahl schrittweise durch <paramref name="signalCount." /> erhöht wird.</exception>
    </member>
    <member name="P:System.Threading.CountdownEvent.CurrentCount">
      <summary vsli:raw="Gets the number of remaining signals required to set the event.">Ruft die Anzahl verbleibender Signale ab, die zum Festlegen des Ereignisses erforderlich sind.</summary>
      <returns vsli:raw="The number of remaining signals required to set the event.">Die Anzahl verbleibender Signale, die zum Festlegen des Ereignisses erforderlich sind.</returns>
    </member>
    <member name="M:System.Threading.CountdownEvent.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; class.">Gibt alle von der aktuellen Instanz der <see cref="T:System.Threading.CountdownEvent" />-Klasse verwendeten Ressourcen frei.</summary>
    </member>
    <member name="M:System.Threading.CountdownEvent.Dispose(System.Boolean)">
      <summary vsli:raw="Releases the unmanaged resources used by the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt;, and optionally releases the managed resources.">Gibt die von <see cref="T:System.Threading.CountdownEvent" /> verwendeten nicht verwalteten Ressourcen und optional die verwalteten Ressourcen frei.</summary>
      <param name="disposing" vsli:raw="true to release both managed and unmanaged resources; false to release only unmanaged resources.">true, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, false, um nur nicht verwaltete Ressourcen freizugeben.</param>
    </member>
    <member name="P:System.Threading.CountdownEvent.InitialCount">
      <summary vsli:raw="Gets the numbers of signals initially required to set the event.">Ruft die Anzahl von Signalen ab, die ursprünglich zum Festlegen des Ereignisses erforderlich waren.</summary>
      <returns vsli:raw="The number of signals initially required to set the event.">Die Anzahl von Signalen, die ursprünglich zum Festlegen des Ereignisses erforderlich waren.</returns>
    </member>
    <member name="P:System.Threading.CountdownEvent.IsSet">
      <summary vsli:raw="Indicates whether the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; object's current count has reached zero.">Gibt an, ob die aktuelle Anzahl des <see cref="T:System.Threading.CountdownEvent" />-Objekts 0 (null) erreicht hat.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current count is zero; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> , wenn die aktuelle Anzahl 0 (null) ist. andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.CountdownEvent.Reset">
      <summary vsli:raw="Resets the &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; to the value of &lt;see cref=&quot;P:System.Threading.CountdownEvent.InitialCount&quot; /&gt;.">Setzt <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> auf den Wert von <see cref="P:System.Threading.CountdownEvent.InitialCount" /> zurück.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Die aktuelle Instanz wurde bereits verworfen.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Reset(System.Int32)">
      <summary vsli:raw="Resets the &lt;see cref=&quot;P:System.Threading.CountdownEvent.InitialCount&quot; /&gt; property to a specified value.">Setzt die <see cref="P:System.Threading.CountdownEvent.InitialCount" />-Eigenschaft auf einen angegebenen Wert zurück.</summary>
      <param name="count" vsli:raw="The number of signals required to set the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt;.">Die zum Festlegen von <see cref="T:System.Threading.CountdownEvent" /> erforderliche Anzahl von Signalen.</param>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Die aktuelle Instanz wurde bereits verworfen.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;count&quot; /&gt; is less than 0.">
        <paramref name="count" /> ist kleiner als 0.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Signal">
      <summary vsli:raw="Registers a signal with the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt;, decrementing the value of &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt;.">Registriert ein Signal beim <see cref="T:System.Threading.CountdownEvent" /> und dekrementiert den Wert von <see cref="P:System.Threading.CountdownEvent.CurrentCount" />.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the signal caused the count to reach zero and the event was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">True, wenn die Anzahl aufgrund des Signals 0 (null) erreicht hat und das Ereignis festgelegt wurde, andernfalls false.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Die aktuelle Instanz wurde bereits verworfen.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The current instance is already set.">Die aktuelle Instanz ist bereits festgelegt.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Signal(System.Int32)">
      <summary vsli:raw="Registers multiple signals with the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt;, decrementing the value of &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; by the specified amount.">Registriert mehrere Signale bei <see cref="T:System.Threading.CountdownEvent" /> und verringert den Wert von <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> um den angegebenen Wert.</summary>
      <param name="signalCount" vsli:raw="The number of signals to register.">Die Anzahl zu registrierender Signale.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the signals caused the count to reach zero and the event was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">True, wenn die Anzahl aufgrund der Signale 0 (null) erreicht hat und das Ereignis festgelegt wurde, andernfalls false.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Die aktuelle Instanz wurde bereits verworfen.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;signalCount&quot; /&gt; is less than 1.">
        <paramref name="signalCount" /> ist kleiner als 1.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The current instance is already set. -or- Or &lt;paramref name=&quot;signalCount&quot; /&gt; is greater than &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt;.">Die aktuelle Instanz ist bereits festgelegt. -oder- <paramref name="signalCount" /> ist größer als <see cref="P:System.Threading.CountdownEvent.CurrentCount" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.TryAddCount">
      <summary vsli:raw="Attempts to increment &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; by one.">Versucht, <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> um eins zu inkrementieren.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the increment succeeded; otherwise, false. If &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; is already at zero, this method will return &lt;see langword=&quot;false&quot; /&gt;.">True, wenn die Anzahl erfolgreich erhöht wurde, andernfalls false. Wenn <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> bereits 0 (null) ist, gibt diese Methode false zurück.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Die aktuelle Instanz wurde bereits verworfen.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; is equal to &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> ist gleich <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.TryAddCount(System.Int32)">
      <summary vsli:raw="Attempts to increment &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; by a specified value.">Versucht, <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> durch einen angegebenen Wert zu inkrementieren.</summary>
      <param name="signalCount" vsli:raw="The value by which to increase &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt;.">Der Wert, um den <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> erhöht werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the increment succeeded; otherwise, false. If &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; is already at zero this will return &lt;see langword=&quot;false&quot; /&gt;.">True, wenn die Anzahl erfolgreich erhöht wurde, andernfalls false. Wenn <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> bereits 0 (null) ist, wird false zurückgegeben.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Die aktuelle Instanz wurde bereits verworfen.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;signalCount&quot; /&gt; is less than or equal to 0.">
        <paramref name="signalCount" /> ist kleiner oder gleich 0.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; + &lt;paramref name=&quot;signalCount&quot; /&gt; is equal to or greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> + <paramref name="signalCount" /> ist größer oder gleich <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait">
      <summary vsli:raw="Blocks the current thread until the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; is set.">Blockiert den aktuellen Thread, bis <see cref="T:System.Threading.CountdownEvent" /> festgelegt wird.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Die aktuelle Instanz wurde bereits verworfen.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.Int32)">
      <summary vsli:raw="Blocks the current thread until the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; is set, using a 32-bit signed integer to measure the timeout.">Blockiert den aktuellen Thread, bis <see cref="T:System.Threading.CountdownEvent" /> festgelegt wird, wobei eine 32-Bit-Ganzzahl mit Vorzeichen zum Messen des Timeouts verwendet wird.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;(-1) to wait indefinitely.">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">True, wenn <see cref="T:System.Threading.CountdownEvent" /> festgelegt wurde, andernfalls false.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Die aktuelle Instanz wurde bereits verworfen.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.Int32,System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; is set, using a 32-bit signed integer to measure the timeout, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Blockiert den aktuellen Thread, bis <see cref="T:System.Threading.CountdownEvent" /> festgelegt wird, wobei eine 32-Bit-Ganzzahl mit Vorzeichen zum Messen des Timeouts verwendet und ein <see cref="T:System.Threading.CancellationToken" /> überwacht wird.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;(-1) to wait indefinitely.">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">Das zu überwachende <see cref="T:System.Threading.CancellationToken" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">True, wenn <see cref="T:System.Threading.CountdownEvent" /> festgelegt wurde, andernfalls false.</returns>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; has been canceled.">
        <paramref name="cancellationToken" /> wurde abgebrochen.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed. -or- The &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has already been disposed.">Die aktuelle Instanz wurde bereits verworfen. - Oder - Die <see cref="T:System.Threading.CancellationTokenSource" />, die <paramref name="cancellationToken" /> erstellte, wurde bereits freigegeben.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; is set, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Blockiert den aktuellen Thread, bis <see cref="T:System.Threading.CountdownEvent" /> festgelegt wird, wobei ein <see cref="T:System.Threading.CancellationToken" /> überwacht wird.</summary>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">Das zu überwachende <see cref="T:System.Threading.CancellationToken" />.</param>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; has been canceled.">
        <paramref name="cancellationToken" /> wurde abgebrochen.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.&#xA;&#xA;-or-&#xA;&#xA;The &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has already been disposed.">Die aktuelle Instanz wurde bereits verworfen. - Oder - Die <see cref="T:System.Threading.CancellationTokenSource" />, die <paramref name="cancellationToken" /> erstellte, wurde bereits freigegeben.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.TimeSpan)">
      <summary vsli:raw="Blocks the current thread until the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; is set, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; to measure the timeout.">Blockiert den aktuellen Thread, bis <see cref="T:System.Threading.CountdownEvent" /> festgelegt wird, wobei ein <see cref="T:System.TimeSpan" /> zum Messen des Timeouts verwendet wird.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely.">Eine <see cref="T:System.TimeSpan" />-Struktur, die die Anzahl der zu wartenden Millisekunden angibt, oder eine <see cref="T:System.TimeSpan" />-Struktur, die -1 Millisekunden zum unendlichen Warten angibt.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">True, wenn <see cref="T:System.Threading.CountdownEvent" /> festgelegt wurde, andernfalls false.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Die aktuelle Instanz wurde bereits verworfen.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> ist eine negative Zahl ungleich  -1 Millisekunden, die ein unendliches Timeout darstellt, - oder - Timeout ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; is set, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; to measure the timeout, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Blockiert den aktuellen Thread, bis <see cref="T:System.Threading.CountdownEvent" /> festgelegt wird, wobei ein <see cref="T:System.TimeSpan" /> zum Messen des Zeitintervalls verwendet und ein <see cref="T:System.Threading.CancellationToken" /> überwacht wird.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely.">Eine <see cref="T:System.TimeSpan" />-Struktur, die die Anzahl der zu wartenden Millisekunden angibt, oder eine <see cref="T:System.TimeSpan" />-Struktur, die -1 Millisekunden zum unendlichen Warten angibt.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">Das zu überwachende <see cref="T:System.Threading.CancellationToken" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">True, wenn <see cref="T:System.Threading.CountdownEvent" /> festgelegt wurde, andernfalls false.</returns>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; has been canceled.">
        <paramref name="cancellationToken" /> wurde abgebrochen.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed. -or- The &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has already been disposed.">Die aktuelle Instanz wurde bereits verworfen. - Oder - Die <see cref="T:System.Threading.CancellationTokenSource" />, die <paramref name="cancellationToken" /> erstellte, wurde bereits freigegeben.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> ist eine negative Zahl ungleich  -1 Millisekunden, die ein unendliches Timeout darstellt, - oder - Timeout ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="P:System.Threading.CountdownEvent.WaitHandle">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Threading.WaitHandle&quot; /&gt; that is used to wait for the event to be set.">Ruft ein <see cref="T:System.Threading.WaitHandle" /> ab, das verwendet wird, um auf das festzulegende Ereignis zu warten.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.WaitHandle&quot; /&gt; that is used to wait for the event to be set.">Ein <see cref="T:System.Threading.WaitHandle" />, das verwendet wird, um auf das festzulegende Ereignis zu warten.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Die aktuelle Instanz wurde bereits verworfen.</exception>
    </member>
    <member name="T:System.Threading.EventResetMode">
      <summary vsli:raw="Indicates whether an &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt; is reset automatically or manually after receiving a signal.">Gibt an, ob eine <see cref="T:System.Threading.EventWaitHandle" />-Klasse nach dem Empfangen eines Signals automatisch oder manuell zurückgesetzt wird.</summary>
    </member>
    <member name="F:System.Threading.EventResetMode.AutoReset">
      <summary vsli:raw="When signaled, the &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt; resets automatically after releasing a single thread. If no threads are waiting, the &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt; remains signaled until a thread blocks, and resets after releasing the thread.">Bei Signalisierung wird die <see cref="T:System.Threading.EventWaitHandle" />-Methode automatisch nach der Freigabe eines einzigen Threads zurückgesetzt. Wenn sich keine Threads in der Warteschlange befinden, bleibt die <see cref="T:System.Threading.EventWaitHandle" />-Methode solange signalisiert, bis ein Thread blockiert wird. Sie wird zurückgesetzt, nachdem der Thread freigegeben wurde.</summary>
    </member>
    <member name="F:System.Threading.EventResetMode.ManualReset">
      <summary vsli:raw="When signaled, the &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt; releases all waiting threads and remains signaled until it is manually reset.">Bei Signalisierung gibt die <see cref="T:System.Threading.EventWaitHandle" />-Methode alle wartenden Threads frei. Sie bleibt solange signalisiert, bis sie manuell zurückgesetzt wird.</summary>
    </member>
    <member name="T:System.Threading.EventWaitHandle">
      <summary vsli:raw="Represents a thread synchronization event.">Stellt ein Threadsynchronisierungsereignis dar.</summary>
    </member>
    <member name="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt; class, specifying whether the wait handle is initially signaled, and whether it resets automatically or manually.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.EventWaitHandle" />-Klasse und gibt an, ob das WaitHandle anfänglich signalisiert ist und ob es automatisch oder manuell zurückgesetzt wird.</summary>
      <param name="initialState" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set the initial state to signaled; &lt;see langword=&quot;false&quot; /&gt; to set it to nonsignaled.">
        <see langword="true" />, wenn der anfängliche Zustand auf signalisiert festgelegt werden soll. <see langword="false" />, wenn er auf nicht signalisiert festgelegt werden soll.</param>
      <param name="mode" vsli:raw="One of the &lt;see cref=&quot;T:System.Threading.EventResetMode&quot; /&gt; values that determines whether the event resets automatically or manually.">Einer der <see cref="T:System.Threading.EventResetMode" />-Werte, der bestimmt, ob das Ereignis automatisch oder manuell zurückgesetzt wird.</param>
    </member>
    <member name="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt; class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, and the name of a system synchronization event.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.EventWaitHandle" />-Klasse, gibt an, ob das WaitHandle anfänglich signalisiert ist, wenn es als Ergebnis dieses Aufrufs erstellt wurde, ob es automatisch oder manuell zurückgesetzt wird, und gibt den Namen eines Systemsynchronisierungsereignisses an.</summary>
      <param name="initialState" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set the initial state to signaled if the named event is created as a result of this call; &lt;see langword=&quot;false&quot; /&gt; to set it to nonsignaled.">
        <see langword="true" /> zum Festlegen des anfänglichen Zustands auf „signalisiert“, wenn das benannte Ereignis als Ergebnis dieses Aufrufs erstellt wird; <see langword="false" /> zum Festlegen auf „nicht signalisiert“.</param>
      <param name="mode" vsli:raw="One of the &lt;see cref=&quot;T:System.Threading.EventResetMode&quot; /&gt; values that determines whether the event resets automatically or manually.">Einer der <see cref="T:System.Threading.EventResetMode" />-Werte, der bestimmt, ob das Ereignis automatisch oder manuell zurückgesetzt wird.</param>
      <param name="name" vsli:raw="The name, if the synchronization object is to be shared with other processes; otherwise, &lt;see langword=&quot;null&quot; /&gt; or an empty string. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">Der Name des systemweiten Synchronisierungsereignisses.</param>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Win32-Fehler.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named event exists and has access control security, but the user does not have &lt;see cref=&quot;F:System.Security.AccessControl.EventWaitHandleRights.FullControl&quot; /&gt;.">Das benannte Ereignis ist vorhanden und verfügt über Zugriffssteuerungssicherheit, aber der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be created. A synchronization object of a different type might have the same name.">Das benannte Ereignis kann nicht erstellt werden, möglicherweise weil ein Wait-Handle eines anderen Typs den gleichen Namen hat.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&#xA;          The &lt;paramref name=&quot;mode&quot; /&gt; enum value was out of legal range.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="name" /> ist länger als 260 Zeichen.</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt; class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, and a Boolean variable whose value after the call indicates whether the named system event was created.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.EventWaitHandle" />-Klasse, die Folgendes angibt: ob das Wait-Handle anfänglich signalisiert wird, wenn es als Ergebnis dieses Aufrufs erstellt wird; ob es automatisch oder manuell zurückgesetzt wird; den Namen eines Systemsynchronisierungsereignisses und eine boolesche Variable, deren Wert nach dem Aufruf angibt, ob das benannte Systemereignis erstellt wurde.</summary>
      <param name="initialState" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set the initial state to signaled if the named event is created as a result of this call; &lt;see langword=&quot;false&quot; /&gt; to set it to nonsignaled.">
        <see langword="true" /> zum Festlegen des anfänglichen Zustands auf „signalisiert“, wenn das benannte Ereignis als Ergebnis dieses Aufrufs erstellt wird; <see langword="false" /> zum Festlegen auf „nicht signalisiert“.</param>
      <param name="mode" vsli:raw="One of the &lt;see cref=&quot;T:System.Threading.EventResetMode&quot; /&gt; values that determines whether the event resets automatically or manually.">Einer der <see cref="T:System.Threading.EventResetMode" />-Werte, der bestimmt, ob das Ereignis automatisch oder manuell zurückgesetzt wird.</param>
      <param name="name" vsli:raw="The name, if the synchronization object is to be shared with other processes; otherwise, &lt;see langword=&quot;null&quot; /&gt; or an empty string. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">Der Name des systemweiten Synchronisierungsereignisses.</param>
      <param name="createdNew" vsli:raw="When this method returns, contains &lt;see langword=&quot;true&quot; /&gt; if a local event was created (that is, if &lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; or an empty string) or if the specified named system event was created; &lt;see langword=&quot;false&quot; /&gt; if the specified named system event already existed. This parameter is passed uninitialized.">Enthält nach dem Beenden dieser Methode den Wert <see langword="true" />, wenn ein lokales Ereignis erstellt wurde (d. h., wenn <paramref name="name" /> gleich <see langword="null" /> oder eine leere Zeichenfolge ist) oder wenn das angegebene benannte Systemereignis erstellt wurde. Der Wert ist <see langword="false" />, wenn das angegebene benannte Systemsereignis bereits vorhanden war. Dieser Parameter wird nicht initialisiert übergeben.</param>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Win32-Fehler.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named event exists and has access control security, but the user does not have &lt;see cref=&quot;F:System.Security.AccessControl.EventWaitHandleRights.FullControl&quot; /&gt;.">Das benannte Ereignis ist vorhanden und verfügt über Zugriffssteuerungssicherheit, aber der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be created. A synchronization object of a different type might have the same name.">Das benannte Ereignis kann nicht erstellt werden, möglicherweise weil ein Wait-Handle eines anderen Typs den gleichen Namen hat.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&#xA;          The &lt;paramref name=&quot;mode&quot; /&gt; enum value was out of legal range.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="name" /> ist länger als 260 Zeichen.</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
      <summary vsli:raw="Opens the specified named synchronization event, if it already exists.">Öffnet das bestimmte benannte Synchronisierungsereignis, wenn es bereits vorhanden ist.</summary>
      <param name="name" vsli:raw="The name of the synchronization object to be opened and shared with other processes. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">Der Name des zu öffnenden Systemsynchronisierungsereignisses.</param>
      <returns vsli:raw="An object that represents the named system event.">Ein Objekt, das das benannte Systemereignis darstellt.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is an empty string.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="name" /> ist eine leere Zeichenfolge.  

oder - 
<paramref name="name" /> ist länger als 260 Zeichen.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be opened. It may not exist, or a synchronization object of a different type might have the same name. In some cases, this exception may be thrown for invalid names.">Das benannte Systemereignis ist nicht vorhanden.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Win32-Fehler.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named event exists, but the user does not have the security access required to use it.">Das benannte Ereignis ist vorhanden, der Benutzer verfügt jedoch nicht über den nötigen Sicherheitszugriff, um es zu verwenden.</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.Reset">
      <summary vsli:raw="Sets the state of the event to nonsignaled, causing threads to block.">Legt den Zustand des Ereignisses auf nicht signalisiert fest, sodass Threads blockiert werden.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operation succeeds; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn die Operation erfolgreich ausgeführt wird, andernfalls <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;M:System.Threading.WaitHandle.Close&quot; /&gt; method was previously called on this &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt;.">Die <see cref="M:System.Threading.WaitHandle.Close" />-Methode wurde zuvor für dieses <see cref="T:System.Threading.EventWaitHandle" /> aufgerufen.</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.Set">
      <summary vsli:raw="Sets the state of the event to signaled, allowing one or more waiting threads to proceed.">Legt den Zustand des Ereignisses auf signalisiert fest und ermöglicht so einem oder mehreren wartenden Threads fortzufahren.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operation succeeds; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn die Operation erfolgreich ausgeführt wird, andernfalls <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;M:System.Threading.WaitHandle.Close&quot; /&gt; method was previously called on this &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt;.">Die <see cref="M:System.Threading.WaitHandle.Close" />-Methode wurde zuvor für dieses <see cref="T:System.Threading.EventWaitHandle" /> aufgerufen.</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
      <summary vsli:raw="Opens the specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.">Öffnet das angegebene benannte Synchronisierungsereignis, wenn es bereits vorhanden ist, und gibt einen Wert zurück, der angibt, ob der Vorgang erfolgreich war.</summary>
      <param name="name" vsli:raw="The name of the synchronization object to be opened and shared with other processes. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">Der Name des zu öffnenden Systemsynchronisierungsereignisses.</param>
      <param name="result" vsli:raw="When this method returns, contains a &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt; object that represents the named synchronization event if the call succeeded, or &lt;see langword=&quot;null&quot; /&gt; if the call failed. This parameter is treated as uninitialized.">Enthält nach Rückgabe dieser Methode ein <see cref="T:System.Threading.EventWaitHandle" />-Objekt, das das benannte Synchronisierungsereignis darstellt, wenn der Aufruf erfolgreich ausgeführt wurde, oder <see langword="null" />, wenn beim Aufruf ein Fehler aufgetreten ist. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the named synchronization event was opened successfully; otherwise, &lt;see langword=&quot;false&quot; /&gt;. In some cases, &lt;see langword=&quot;false&quot; /&gt; may be returned for invalid names.">
        <see langword="true" />, wenn das benannte Synchronisierungsereignis erfolgreich geöffnet wurde; andernfalls <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is an empty string.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="name" /> ist eine leere Zeichenfolge.  

oder - 
<paramref name="name" /> ist länger als 260 Zeichen.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive. For some invalid names, the method may return &lt;see langword=&quot;false&quot; /&gt; instead.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Win32-Fehler.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named event exists, but the user does not have the desired security access.">Das benannte Ereignis ist vorhanden, aber der Benutzer verfügt nicht über den erforderlichen Sicherheitszugriff.</exception>
    </member>
    <member name="T:System.Threading.ExecutionContext">
      <summary vsli:raw="Manages the execution context for the current thread. This class cannot be inherited.">Verwaltet den Ausführungskontext für den aktuellen Thread. Diese Klasse kann nicht vererbt werden.</summary>
    </member>
    <member name="M:System.Threading.ExecutionContext.Capture">
      <summary vsli:raw="Captures the execution context from the current thread.">Zeichnet den Ausführungskontext des aktuellen Threads auf.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Threading.ExecutionContext&quot; /&gt; object representing the execution context for the current thread.">Ein <see cref="T:System.Threading.ExecutionContext" />-Objekt, das den Ausführungskontext für den aktuellen Thread darstellt.</returns>
    </member>
    <member name="M:System.Threading.ExecutionContext.CreateCopy">
      <summary vsli:raw="Creates a copy of the current execution context.">Erstellt eine Kopie des aktuellen Ausführungskontexts.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Threading.ExecutionContext&quot; /&gt; object representing the current execution context.">Ein <see cref="T:System.Threading.ExecutionContext" />-Objekt, das den aktuellen Ausführungskontext darstellt.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="This context cannot be copied because it is used. Only newly captured contexts can be copied.">Dieser Kontext kann nicht kopiert werden, da er verwendet wird. Nur neu erfasste Kontexte können kopiert werden.</exception>
    </member>
    <member name="M:System.Threading.ExecutionContext.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.ExecutionContext&quot; /&gt; class.">Gibt alle von der aktuellen Instanz der <see cref="T:System.Threading.ExecutionContext" />-Klasse verwendeten Ressourcen frei.</summary>
    </member>
    <member name="M:System.Threading.ExecutionContext.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary vsli:raw="Sets the specified &lt;see cref=&quot;T:System.Runtime.Serialization.SerializationInfo&quot; /&gt; object with the logical context information needed to recreate an instance of the current execution context.">Legt das <see cref="T:System.Runtime.Serialization.SerializationInfo" />-Objekt mit den logischen Kontextinformationen ab, die zum erneuten Erstellen einer Instanz des aktuellem Ausführungskontexts erforderlich sind.</summary>
      <param name="info" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.SerializationInfo&quot; /&gt; object to be populated with serialization information.">Das <see cref="T:System.Runtime.Serialization.SerializationInfo" />-Objekt, das mit Serialisierungsinformationen aufgefüllt werden soll.</param>
      <param name="context" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.StreamingContext&quot; /&gt; structure representing the destination context of the serialization.">Die <see cref="T:System.Runtime.Serialization.StreamingContext" />-Struktur, die den Zielkontext der Serialisierung darstellt.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;info&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="info" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.ExecutionContext.IsFlowSuppressed">
      <summary vsli:raw="Indicates whether the flow of the execution context is currently suppressed.">Gibt an, ob der Fluss des Ausführungskontexts derzeit unterdrückt wird.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the flow is suppressed; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der Fluss unterdrückt wird, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.ExecutionContext.RestoreFlow">
      <summary vsli:raw="Restores the flow of the execution context across asynchronous threads.">Stellt den Fluss des Ausführungskontexts über asynchrone Threads wieder her.</summary>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The context flow cannot be restored because it is not being suppressed.">Der Kontextfluss kann nicht wiederhergestellt werden, da er nicht unterdrückt wird.</exception>
    </member>
    <member name="M:System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext,System.Threading.ContextCallback,System.Object)">
      <summary vsli:raw="Runs a method in a specified execution context on the current thread.">Führt für den aktuellen Thread eine Methode in einem angegebenen Ausführungskontext aus.</summary>
      <param name="executionContext" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ExecutionContext&quot; /&gt; to set.">Die festzulegende <see cref="T:System.Threading.ExecutionContext" />.</param>
      <param name="callback" vsli:raw="A &lt;see cref=&quot;T:System.Threading.ContextCallback&quot; /&gt; delegate that represents the method to be run in the provided execution context.">Ein <see cref="T:System.Threading.ContextCallback" />-Delegat, der die im bereitgestellten Ausführungskontext auszuführende Methode darstellt.</param>
      <param name="state" vsli:raw="The object to pass to the callback method.">Das Objekt, das an die Rückrufmethode übergeben werden soll.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;executionContext&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;executionContext&quot; /&gt; was not acquired through a capture operation.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;executionContext&quot; /&gt; has already been used as the argument to a &lt;see cref=&quot;M:System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext,System.Threading.ContextCallback,System.Object)&quot; /&gt; call.">
        <paramref name="executionContext" /> ist <see langword="null" />.  

oder - 
<paramref name="executionContext" /> wurde nicht durch einen Aufzeichnungsvorgang ermittelt.  

oder - 
<paramref name="executionContext" /> wurde bereits als Argument für einen Aufruf von <see cref="M:System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext,System.Threading.ContextCallback,System.Object)" /> verwendet.</exception>
    </member>
    <member name="M:System.Threading.ExecutionContext.SuppressFlow">
      <summary vsli:raw="Suppresses the flow of the execution context across asynchronous threads.">Unterdrückt den Fluss des Ausführungskontexts über asynchrone Threads hinweg.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure for restoring the flow.">Eine <see cref="T:System.Threading.AsyncFlowControl" />-Struktur zum Wiederherstellen des Flusses.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The context flow is already suppressed.">Der Kontextfluss wird bereits unterdrückt.</exception>
    </member>
    <member name="T:System.Threading.HostExecutionContext">
      <summary vsli:raw="Encapsulates and propagates the host execution context across threads.">Kapselt den Hostausführungskontext und gibt ihn threadübergreifend weiter.</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContext.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.HostExecutionContext&quot; /&gt; class.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.HostExecutionContext" />-Klasse.</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContext.#ctor(System.Object)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.HostExecutionContext&quot; /&gt; class using the specified state.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.HostExecutionContext" />-Klasse unter Verwendung des angegebenen Zustands.</summary>
      <param name="state" vsli:raw="An object representing the host execution context state.">Ein Objekt, das den Zustand des Hostausführungskontexts darstellt.</param>
    </member>
    <member name="M:System.Threading.HostExecutionContext.CreateCopy">
      <summary vsli:raw="Creates a copy of the current host execution context.">Erstellt eine Kopie des aktuellen Hostausführungskontexts.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.HostExecutionContext&quot; /&gt; object representing the host context for the current thread.">Ein <see cref="T:System.Threading.HostExecutionContext" />-Objekt, das den Hostkontext für den aktuellen Thread darstellt.</returns>
    </member>
    <member name="M:System.Threading.HostExecutionContext.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.HostExecutionContext&quot; /&gt; class.">Gibt alle von der aktuellen Instanz der <see cref="T:System.Threading.HostExecutionContext" />-Klasse verwendeten Ressourcen frei.</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContext.Dispose(System.Boolean)">
      <summary vsli:raw="When overridden in a derived class, releases the unmanaged resources used by the &lt;see cref=&quot;T:System.Threading.WaitHandle&quot; /&gt;, and optionally releases the managed resources.">Gibt beim Überschreiben in einer abgeleiteten Klasse die von <see cref="T:System.Threading.WaitHandle" /> verwendeten nicht verwalteten Ressourcen und optional die verwalteten Ressourcen frei.</summary>
      <param name="disposing" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to release both managed and unmanaged resources; &lt;see langword=&quot;false&quot; /&gt; to release only unmanaged resources.">
        <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
    </member>
    <member name="P:System.Threading.HostExecutionContext.State">
      <summary vsli:raw="Gets or sets the state of the host execution context.">Ruft den Zustand des Hostausführungskontexts ab oder legt diesen fest.</summary>
      <returns vsli:raw="An object representing the host execution context state.">Ein Objekt, das den Zustand des Hostausführungskontexts darstellt.</returns>
    </member>
    <member name="T:System.Threading.HostExecutionContextManager">
      <summary vsli:raw="Provides the functionality that allows a common language runtime host to participate in the flow, or migration, of the execution context.">Stellt die Funktionen bereit, über die ein Host der Common Language Runtime am Fluss teilnehmen oder der Ausführungskontext migriert werden kann.</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContextManager.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.HostExecutionContextManager&quot; /&gt; class.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.HostExecutionContextManager" />-Klasse.</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContextManager.Capture">
      <summary vsli:raw="Captures the host execution context from the current thread.">Zeichnet den Hostausführungskontext des aktuellen Threads auf.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.HostExecutionContext&quot; /&gt; object representing the host execution context of the current thread.">Ein <see cref="T:System.Threading.HostExecutionContext" />-Objekt, das den Hostausführungskontext des aktuellen Threads darstellt.</returns>
    </member>
    <member name="M:System.Threading.HostExecutionContextManager.Revert(System.Object)">
      <summary vsli:raw="Restores the host execution context to its prior state.">Stellt den vorherigen Zustand des Hostausführungskontexts wieder her.</summary>
      <param name="previousState" vsli:raw="The previous context state to revert to.">Der vorherige Kontextzustand, der wiederhergestellt werden soll.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;previousState&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;previousState&quot; /&gt; was not created on the current thread.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;previousState&quot; /&gt; is not the last state for the &lt;see cref=&quot;T:System.Threading.HostExecutionContext&quot; /&gt;.">
        <paramref name="previousState" /> ist <see langword="null" />.  

oder - 
<paramref name="previousState" /> wurde nicht für den aktuellen Thread erstellt.  

oder - 
<paramref name="previousState" /> ist nicht der letzte Zustand für den <see cref="T:System.Threading.HostExecutionContext" />.</exception>
    </member>
    <member name="M:System.Threading.HostExecutionContextManager.SetHostExecutionContext(System.Threading.HostExecutionContext)">
      <summary vsli:raw="Sets the current host execution context to the specified host execution context.">Legt den aktuellen Hostausführungskontext auf den angegebenen Hostausführungskontext fest.</summary>
      <param name="hostExecutionContext" vsli:raw="The &lt;see cref=&quot;T:System.Threading.HostExecutionContext&quot; /&gt; to be set.">Der festzulegende <see cref="T:System.Threading.HostExecutionContext" />.</param>
      <returns vsli:raw="An object for restoring the &lt;see cref=&quot;T:System.Threading.HostExecutionContext&quot; /&gt; to its previous state.">Ein Objekt zum Wiederherstellen des vorherigen Zustands des <see cref="T:System.Threading.HostExecutionContext" />.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;hostExecutionContext&quot; /&gt; was not acquired through a capture operation.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;hostExecutionContext&quot; /&gt; has been the argument to a previous &lt;see cref=&quot;M:System.Threading.HostExecutionContextManager.SetHostExecutionContext(System.Threading.HostExecutionContext)&quot; /&gt; method call.">
        <paramref name="hostExecutionContext" /> wurde nicht durch einen Aufzeichnungsvorgang ermittelt.  

oder - 
<paramref name="hostExecutionContext" /> war bereits das Argument in einem vorherigen Aufruf der <see cref="M:System.Threading.HostExecutionContextManager.SetHostExecutionContext(System.Threading.HostExecutionContext)" />-Methode.</exception>
    </member>
    <member name="T:System.Threading.Interlocked">
      <summary vsli:raw="Provides atomic operations for variables that are shared by multiple threads.">Stellt atomare Operationen für Variablen bereit, die von mehreren Threads gemeinsam genutzt werden.</summary>
    </member>
    <member name="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)">
      <summary vsli:raw="Adds two 32-bit integers and replaces the first integer with the sum, as an atomic operation.">Fügt in einer atomaren Operation zwei 32-Bit-Ganzzahlen hinzu und ersetzt die erste Ganzzahl durch die Summe.</summary>
      <param name="location1" vsli:raw="A variable containing the first value to be added. The sum of the two values is stored in &lt;paramref name=&quot;location1&quot; /&gt;.">Eine Variable, die den ersten Wert enthält, der hinzugefügt werden soll. Die Summe der beiden Werte wird in <paramref name="location1" /> gespeichert.</param>
      <param name="value" vsli:raw="The value to be added to the integer at &lt;paramref name=&quot;location1&quot; /&gt;.">Der Wert, der der Ganzzahl in <paramref name="location1" /> hinzugefügt werden soll.</param>
      <returns vsli:raw="The new value that was stored at &lt;paramref name=&quot;location1&quot; /&gt; by this operation.">Der unter <paramref name="location1" /> gespeicherte neue Wert.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a null pointer.">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)">
      <summary vsli:raw="Adds two 64-bit integers and replaces the first integer with the sum, as an atomic operation.">Fügt in einer atomaren Operation zwei 64-Bit-Ganzzahlen hinzu und ersetzt die erste Ganzzahl durch die Summe.</summary>
      <param name="location1" vsli:raw="A variable containing the first value to be added. The sum of the two values is stored in &lt;paramref name=&quot;location1&quot; /&gt;.">Eine Variable, die den ersten Wert enthält, der hinzugefügt werden soll. Die Summe der beiden Werte wird in <paramref name="location1" /> gespeichert.</param>
      <param name="value" vsli:raw="The value to be added to the integer at &lt;paramref name=&quot;location1&quot; /&gt;.">Der Wert, der der Ganzzahl in <paramref name="location1" /> hinzugefügt werden soll.</param>
      <returns vsli:raw="The new value that was stored at &lt;paramref name=&quot;location1&quot; /&gt; by this operation.">Der unter <paramref name="location1" /> gespeicherte neue Wert.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a null pointer.">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
      <summary vsli:raw="Compares two double-precision floating point numbers for equality and, if they are equal, replaces the first value.">Vergleicht zwei Gleitkommazahlen mit doppelter Genauigkeit hinsichtlich ihrer Gleichheit und ersetzt bei vorliegender Gleichheit den ersten Wert.</summary>
      <param name="location1" vsli:raw="The destination, whose value is compared with &lt;paramref name=&quot;comparand&quot; /&gt; and possibly replaced.">Das Ziel, dessen Wert mit <paramref name="comparand" /> verglichen und möglicherweise ersetzt wird.</param>
      <param name="value" vsli:raw="The value that replaces the destination value if the comparison results in equality.">Der Wert, der den Zielwert ersetzt, wenn der Vergleich Gleichheit ergibt.</param>
      <param name="comparand" vsli:raw="The value that is compared to the value at &lt;paramref name=&quot;location1&quot; /&gt;.">Der Wert, der mit dem Wert bei <paramref name="location1" /> verglichen wird.</param>
      <returns vsli:raw="The original value in &lt;paramref name=&quot;location1&quot; /&gt;.">Der ursprüngliche Wert in <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a null pointer.">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
      <summary vsli:raw="Compares two 32-bit signed integers for equality and, if they are equal, replaces the first value.">Vergleicht zwei 32-Bit-Ganzzahlen mit Vorzeichen hinsichtlich ihrer Gleichheit und ersetzt bei vorliegender Gleichheit den ersten Wert.</summary>
      <param name="location1" vsli:raw="The destination, whose value is compared with &lt;paramref name=&quot;comparand&quot; /&gt; and possibly replaced.">Das Ziel, dessen Wert mit <paramref name="comparand" /> verglichen und möglicherweise ersetzt wird.</param>
      <param name="value" vsli:raw="The value that replaces the destination value if the comparison results in equality.">Der Wert, der den Zielwert ersetzt, wenn der Vergleich Gleichheit ergibt.</param>
      <param name="comparand" vsli:raw="The value that is compared to the value at &lt;paramref name=&quot;location1&quot; /&gt;.">Der Wert, der mit dem Wert bei <paramref name="location1" /> verglichen wird.</param>
      <returns vsli:raw="The original value in &lt;paramref name=&quot;location1&quot; /&gt;.">Der ursprüngliche Wert in <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a null pointer.">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)">
      <summary vsli:raw="Compares two 64-bit signed integers for equality and, if they are equal, replaces the first value.">Vergleicht zwei 64-Bit-Ganzzahlen mit Vorzeichen hinsichtlich ihrer Gleichheit und ersetzt bei vorliegender Gleichheit den ersten Wert.</summary>
      <param name="location1" vsli:raw="The destination, whose value is compared with &lt;paramref name=&quot;comparand&quot; /&gt; and possibly replaced.">Das Ziel, dessen Wert mit <paramref name="comparand" /> verglichen und möglicherweise ersetzt wird.</param>
      <param name="value" vsli:raw="The value that replaces the destination value if the comparison results in equality.">Der Wert, der den Zielwert ersetzt, wenn der Vergleich Gleichheit ergibt.</param>
      <param name="comparand" vsli:raw="The value that is compared to the value at &lt;paramref name=&quot;location1&quot; /&gt;.">Der Wert, der mit dem Wert bei <paramref name="location1" /> verglichen wird.</param>
      <returns vsli:raw="The original value in &lt;paramref name=&quot;location1&quot; /&gt;.">Der ursprüngliche Wert in <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a null pointer.">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)">
      <summary vsli:raw="Compares two platform-specific handles or pointers for equality and, if they are equal, replaces the first one.">Vergleicht zwei plattformspezifische Handles oder Zeiger hinsichtlich ihrer Gleichheit und ersetzt bei vorliegender Gleichheit den ersten.</summary>
      <param name="location1" vsli:raw="The destination &lt;see cref=&quot;T:System.IntPtr&quot; /&gt;, whose value is compared with the value of &lt;paramref name=&quot;comparand&quot; /&gt; and possibly replaced by &lt;paramref name=&quot;value&quot; /&gt;.">Das Ziel <see cref="T:System.IntPtr" />, dessen Wert mit dem Wert von <paramref name="comparand" /> verglichen und möglicherweise durch <paramref name="value" /> ersetzt wird.</param>
      <param name="value" vsli:raw="The &lt;see cref=&quot;T:System.IntPtr&quot; /&gt; that replaces the destination value if the comparison results in equality.">Der <see cref="T:System.IntPtr" />, der den Zielwert ersetzt, wenn der Vergleich Gleichheit ergibt.</param>
      <param name="comparand" vsli:raw="The &lt;see cref=&quot;T:System.IntPtr&quot; /&gt; that is compared to the value at &lt;paramref name=&quot;location1&quot; /&gt;.">Der <see cref="T:System.IntPtr" />, der mit dem Wert in <paramref name="location1" /> verglichen wird.</param>
      <returns vsli:raw="The original value in &lt;paramref name=&quot;location1&quot; /&gt;.">Der ursprüngliche Wert in <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a null pointer.">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
      <summary vsli:raw="Compares two objects for reference equality and, if they are equal, replaces the first object.">Vergleicht zwei Objekte hinsichtlich ihrer Verweisgleichheit und ersetzt bei vorliegender Gleichheit das erste Objekt.</summary>
      <param name="location1" vsli:raw="The destination object that is compared by reference with &lt;paramref name=&quot;comparand&quot; /&gt; and possibly replaced.">Das Zielobjekt, das mit <paramref name="comparand" /> nach Verweis verglichen und möglicherweise ersetzt wird.</param>
      <param name="value" vsli:raw="The object that replaces the destination object if the reference comparison results in equality.">Das Objekt, das das Zielobjekt ersetzt, wenn beim Verweisevergleich Gleichheit festgestellt wird.</param>
      <param name="comparand" vsli:raw="The object that is compared by reference to the object at &lt;paramref name=&quot;location1&quot; /&gt;.">Das Objekt, das nach Verweis mit dem Objekt bei <paramref name="location1" /> verglichen wird.</param>
      <returns vsli:raw="The original value in &lt;paramref name=&quot;location1&quot; /&gt;.">Der ursprüngliche Wert in <paramref name="location1" />.</returns>
      <exception cref="T:System.ArgumentNullException">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
      <summary vsli:raw="Compares two single-precision floating point numbers for equality and, if they are equal, replaces the first value.">Vergleicht zwei Gleitkommazahlen mit einfacher Genauigkeit hinsichtlich ihrer Gleichheit und ersetzt bei vorliegender Gleichheit den ersten Wert.</summary>
      <param name="location1" vsli:raw="The destination, whose value is compared with &lt;paramref name=&quot;comparand&quot; /&gt; and possibly replaced.">Das Ziel, dessen Wert mit <paramref name="comparand" /> verglichen und möglicherweise ersetzt wird.</param>
      <param name="value" vsli:raw="The value that replaces the destination value if the comparison results in equality.">Der Wert, der den Zielwert ersetzt, wenn der Vergleich Gleichheit ergibt.</param>
      <param name="comparand" vsli:raw="The value that is compared to the value at &lt;paramref name=&quot;location1&quot; /&gt;.">Der Wert, der mit dem Wert bei <paramref name="location1" /> verglichen wird.</param>
      <returns vsli:raw="The original value in &lt;paramref name=&quot;location1&quot; /&gt;.">Der ursprüngliche Wert in <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a null pointer.">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
      <summary vsli:raw="Compares two instances of the specified reference type &lt;paramref name=&quot;T&quot; /&gt; for reference equality and, if they are equal, replaces the first one.">Vergleicht zwei Instanzen des angegebenen Referenztyps <paramref name="T" /> hinsichtlich ihrer Verweisgleichheit und ersetzt bei vorliegender Gleichheit den ersten.</summary>
      <param name="location1" vsli:raw="The destination, whose value is compared by reference with &lt;paramref name=&quot;comparand&quot; /&gt; and possibly replaced. This is a reference parameter (&lt;see langword=&quot;ref&quot; /&gt; in C#, &lt;see langword=&quot;ByRef&quot; /&gt; in Visual Basic).">Das Ziel, dessen Wert mit <paramref name="comparand" /> nach Verweis verglichen und möglicherweise ersetzt wird. Dies ist ein Verweisparameter (<see langword="ref" /> in C#, <see langword="ByRef" /> in Visual Basic).</param>
      <param name="value" vsli:raw="The value that replaces the destination value if the comparison by reference results in equality.">Der Wert, der den Zielwert ersetzt, wenn der Vergleich nach Verweis Gleichheit ergibt.</param>
      <param name="comparand" vsli:raw="The value that is compared by reference to the value at &lt;paramref name=&quot;location1&quot; /&gt;.">Der Wert, der nach Verweis mit dem Wert bei <paramref name="location1" /> verglichen wird.</param>
      <typeparam name="T" vsli:raw="The type to be used for &lt;paramref name=&quot;location1&quot; /&gt;, &lt;paramref name=&quot;value&quot; /&gt;, and &lt;paramref name=&quot;comparand&quot; /&gt;. This type must be a reference type.">Der Typ, der für <paramref name="location1" />, <paramref name="value" /> und <paramref name="comparand" /> verwendet werden soll. Dieser Typ muss ein Referenztyp sein.</typeparam>
      <returns vsli:raw="The original value in &lt;paramref name=&quot;location1&quot; /&gt;.">Der ursprüngliche Wert in <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a null pointer.">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Decrement(System.Int32@)">
      <summary vsli:raw="Decrements a specified variable and stores the result, as an atomic operation.">Dekrementiert den Wert einer angegebenen Variablen und speichert das Ergebnis in einer atomaren Operation.</summary>
      <param name="location" vsli:raw="The variable whose value is to be decremented.">Die Variable, deren Wert dekrementiert werden soll.</param>
      <returns vsli:raw="The decremented value.">Der dekrementierte Wert.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The address of &lt;paramref name=&quot;location&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">Die Adresse von <paramref name="location" /> ist ein NULL-Zeiger.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Decrement(System.Int64@)">
      <summary vsli:raw="Decrements the specified variable and stores the result, as an atomic operation.">Dekrementiert den Wert der angegebenen Variablen und speichert das Ergebnis in einer atomaren Operation.</summary>
      <param name="location" vsli:raw="The variable whose value is to be decremented.">Die Variable, deren Wert dekrementiert werden soll.</param>
      <returns vsli:raw="The decremented value.">Der dekrementierte Wert.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The address of &lt;paramref name=&quot;location&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">Die Adresse von <paramref name="location" /> ist ein NULL-Zeiger.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Double@,System.Double)">
      <summary vsli:raw="Sets a double-precision floating point number to a specified value and returns the original value, as an atomic operation.">Legt in einer atomaren Operation eine Gleitkommazahl mit doppelter Genauigkeit auf einen angegebenen Wert fest und gibt den ursprünglichen Wert zurück.</summary>
      <param name="location1" vsli:raw="The variable to set to the specified value.">Die Variable, die auf den angegebenen Wert festgelegt werden soll.</param>
      <param name="value" vsli:raw="The value to which the &lt;paramref name=&quot;location1&quot; /&gt; parameter is set.">Der Wert, auf den der <paramref name="location1" />-Parameter festgelegt ist.</param>
      <returns vsli:raw="The original value of &lt;paramref name=&quot;location1&quot; /&gt;.">Der ursprüngliche Wert von <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)">
      <summary vsli:raw="Sets a 32-bit signed integer to a specified value and returns the original value, as an atomic operation.">Legt eine 32-Bit-Ganzzahl mit Vorzeichen in einer atomaren Operation auf einen angegebenen Wert fest und gibt den ursprünglichen Wert zurück.</summary>
      <param name="location1" vsli:raw="The variable to set to the specified value.">Die Variable, die auf den angegebenen Wert festgelegt werden soll.</param>
      <param name="value" vsli:raw="The value to which the &lt;paramref name=&quot;location1&quot; /&gt; parameter is set.">Der Wert, auf den der <paramref name="location1" />-Parameter festgelegt ist.</param>
      <returns vsli:raw="The original value of &lt;paramref name=&quot;location1&quot; /&gt;.">Der ursprüngliche Wert von <paramref name="location1" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)">
      <summary vsli:raw="Sets a 64-bit signed integer to a specified value and returns the original value, as an atomic operation.">Legt eine 64-Bit-Ganzzahl mit Vorzeichen in einer atomaren Operation auf einen angegebenen Wert fest und gibt den ursprünglichen Wert zurück.</summary>
      <param name="location1" vsli:raw="The variable to set to the specified value.">Die Variable, die auf den angegebenen Wert festgelegt werden soll.</param>
      <param name="value" vsli:raw="The value to which the &lt;paramref name=&quot;location1&quot; /&gt; parameter is set.">Der Wert, auf den der <paramref name="location1" />-Parameter festgelegt ist.</param>
      <returns vsli:raw="The original value of &lt;paramref name=&quot;location1&quot; /&gt;.">Der ursprüngliche Wert von <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)">
      <summary vsli:raw="Sets a platform-specific handle or pointer to a specified value and returns the original value, as an atomic operation.">Legt in einer atomaren Operation ein plattformspezifisches Handle bzw. einen plattformspezifischen Zeiger auf einen angegebenen Wert fest und gibt den ursprünglichen Wert zurück.</summary>
      <param name="location1" vsli:raw="The variable to set to the specified value.">Die Variable, die auf den angegebenen Wert festgelegt werden soll.</param>
      <param name="value" vsli:raw="The value to which the &lt;paramref name=&quot;location1&quot; /&gt; parameter is set.">Der Wert, auf den der <paramref name="location1" />-Parameter festgelegt ist.</param>
      <returns vsli:raw="The original value of &lt;paramref name=&quot;location1&quot; /&gt;.">Der ursprüngliche Wert von <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)">
      <summary vsli:raw="Sets an object to a specified value and returns a reference to the original object, as an atomic operation.">Legt in einer atomaren Operation ein Objekt auf einen angegebenen Wert fest und gibt einen Verweis auf das ursprüngliche Objekt zurück.</summary>
      <param name="location1" vsli:raw="The variable to set to the specified value.">Die Variable, die auf den angegebenen Wert festgelegt werden soll.</param>
      <param name="value" vsli:raw="The value to which the &lt;paramref name=&quot;location1&quot; /&gt; parameter is set.">Der Wert, auf den der <paramref name="location1" />-Parameter festgelegt ist.</param>
      <returns vsli:raw="The original value of &lt;paramref name=&quot;location1&quot; /&gt;.">Der ursprüngliche Wert von <paramref name="location1" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Single@,System.Single)">
      <summary vsli:raw="Sets a single-precision floating point number to a specified value and returns the original value, as an atomic operation.">Legt in einer atomaren Operation eine Gleitkommazahl mit einfacher Genauigkeit auf einen angegebenen Wert fest und gibt den ursprünglichen Wert zurück.</summary>
      <param name="location1" vsli:raw="The variable to set to the specified value.">Die Variable, die auf den angegebenen Wert festgelegt werden soll.</param>
      <param name="value" vsli:raw="The value to which the &lt;paramref name=&quot;location1&quot; /&gt; parameter is set.">Der Wert, auf den der <paramref name="location1" />-Parameter festgelegt ist.</param>
      <returns vsli:raw="The original value of &lt;paramref name=&quot;location1&quot; /&gt;.">Der ursprüngliche Wert von <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
      <summary vsli:raw="Sets a variable of the specified type &lt;paramref name=&quot;T&quot; /&gt; to a specified value and returns the original value, as an atomic operation.">Legt eine Variable vom angegebenen Typ <paramref name="T" /> in einer atomaren Operation auf einen angegebenen Wert fest und gibt den ursprünglichen Wert zurück.</summary>
      <param name="location1" vsli:raw="The variable to set to the specified value. This is a reference parameter (&lt;see langword=&quot;ref&quot; /&gt; in C#, &lt;see langword=&quot;ByRef&quot; /&gt; in Visual Basic).">Die Variable, die auf den angegebenen Wert festgelegt werden soll. Dies ist ein Verweisparameter (<see langword="ref" /> in C#, <see langword="ByRef" /> in Visual Basic).</param>
      <param name="value" vsli:raw="The value to which the &lt;paramref name=&quot;location1&quot; /&gt; parameter is set.">Der Wert, auf den der <paramref name="location1" />-Parameter festgelegt ist.</param>
      <typeparam name="T" vsli:raw="The type to be used for &lt;paramref name=&quot;location1&quot; /&gt; and &lt;paramref name=&quot;value&quot; /&gt;. This type must be a reference type.">Der Typ, der für <paramref name="location1" /> und <paramref name="value" /> verwendet werden soll. Dieser Typ muss ein Referenztyp sein.</typeparam>
      <returns vsli:raw="The original value of &lt;paramref name=&quot;location1&quot; /&gt;.">Der ursprüngliche Wert von <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Increment(System.Int32@)">
      <summary vsli:raw="Increments a specified variable and stores the result, as an atomic operation.">Inkrementiert den Wert einer angegebenen Variablen und speichert das Ergebnis in einer atomaren Operation.</summary>
      <param name="location" vsli:raw="The variable whose value is to be incremented.">Die Variable, deren Wert inkrementiert werden soll.</param>
      <returns vsli:raw="The incremented value.">Der inkrementierte Wert.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">Die Adresse von <paramref name="location" /> ist ein NULL-Zeiger.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Increment(System.Int64@)">
      <summary vsli:raw="Increments a specified variable and stores the result, as an atomic operation.">Inkrementiert den Wert einer angegebenen Variablen und speichert das Ergebnis in einer atomaren Operation.</summary>
      <param name="location" vsli:raw="The variable whose value is to be incremented.">Die Variable, deren Wert inkrementiert werden soll.</param>
      <returns vsli:raw="The incremented value.">Der inkrementierte Wert.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">Die Adresse von <paramref name="location" /> ist ein NULL-Zeiger.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.MemoryBarrier">
      <summary vsli:raw="Synchronizes memory access as follows: The processor that executes the current thread cannot reorder instructions in such a way that memory accesses before the call to &lt;see cref=&quot;M:System.Threading.Interlocked.MemoryBarrier&quot; /&gt; execute after memory accesses that follow the call to &lt;see cref=&quot;M:System.Threading.Interlocked.MemoryBarrier&quot; /&gt;.">Synchronisiert den Arbeitsspeicherzugriff wie folgt: Der Prozessor, der den aktuellen Thread ausführt, kann Anweisungen nicht so neu anordnen, dass Speicherzugriffe vor dem Aufruf von <see cref="M:System.Threading.Interlocked.MemoryBarrier" /> nach Speicherzugriffen ausgeführt werden, die nach dem Aufruf von <see cref="M:System.Threading.Interlocked.MemoryBarrier" /> erfolgen.</summary>
    </member>
    <member name="M:System.Threading.Interlocked.MemoryBarrierProcessWide">
      <summary vsli:raw="Provides a process-wide memory barrier that ensures that reads and writes from any CPU cannot move across the barrier.">Bietet eine prozessübergreifende Arbeitsspeicherbarriere, die verhindert, dass Lese- und Schreibvorgänge von CPUs über die Barriere hinaus verschoben werden.</summary>
    </member>
    <member name="M:System.Threading.Interlocked.Read(System.Int64@)">
      <summary vsli:raw="Returns a 64-bit value, loaded as an atomic operation.">Gibt einen 64-Bit-Wert zurück, der in einer atomaren Operation geladen wird.</summary>
      <param name="location" vsli:raw="The 64-bit value to be loaded.">Der zu ladende 64-Bit-Wert.</param>
      <returns vsli:raw="The loaded value.">Der geladene Wert.</returns>
    </member>
    <member name="T:System.Threading.LazyInitializer">
      <summary vsli:raw="Provides lazy initialization routines.">Stellt verzögerte Initialisierungsroutinen bereit.</summary>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@)">
      <summary vsli:raw="Initializes a target reference type with the type's parameterless constructor if it hasn't already been initialized.">Initialisiert einen Zielverweistyp mit seinem parameterlosen Konstruktor, wenn er noch nicht initialisiert wurde.</summary>
      <param name="target" vsli:raw="A reference to initialize if it has not already been initialized. If it is &lt;see langword=&quot;null&quot; /&gt;, it is considered not initialized; otherwise, it's considered initialized.">Ein Verweis, der initialisiert werden soll, wenn er noch nicht initialisiert wurde.</param>
      <typeparam name="T" vsli:raw="The type of the reference to be initialized.">Der Typ des zu initialisierenden Verweises.</typeparam>
      <returns vsli:raw="The initialized object.">Das initialisierte Objekt.</returns>
      <exception cref="T:System.MemberAccessException" vsli:raw="Permissions to access the constructor of type &lt;paramref name=&quot;T&quot; /&gt; were missing.">Berechtigungen, auf den Konstruktor des Typs <paramref name="T" /> zuzugreifen, haben gefehlt.</exception>
      <exception cref="T:System.MissingMemberException" vsli:raw="Type &lt;paramref name=&quot;T&quot; /&gt; does not have a parameterless constructor.">Der Typ <paramref name="T" /> hat keinen parameterlosen Konstruktor.</exception>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@)">
      <summary vsli:raw="Initializes a target reference or value type with its parameterless constructor if it hasn't already been initialized.">Initialisiert einen Zielverweis- oder Werttyp mit seinem parameterlosen Konstruktor, wenn er noch nicht initialisiert wurde.</summary>
      <param name="target" vsli:raw="A reference or value of type &lt;c&gt;T&lt;/c&gt; to initialize if it hasn't already been initialized.">Ein Verweis oder Wert des Typs <c>T</c>, der initialisiert werden soll, wenn er noch nicht initialisiert wurde.</param>
      <param name="initialized" vsli:raw="A reference to a Boolean value that determines whether the target has already been initialized.">Ein Verweis auf einen booleschen Wert, der bestimmt, ob das Ziel bereits initialisiert wurde.</param>
      <param name="syncLock" vsli:raw="A reference to an object used as the mutually exclusive lock for initializing &lt;paramref name=&quot;target&quot; /&gt;. If &lt;paramref name=&quot;syncLock&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;, a new object will be instantiated.">Ein Verweis auf ein Objekt, das für die Initialisierung von <paramref name="target" /> als sich gegenseitig ausschließende Sperre verwendet wird. Wenn <paramref name="syncLock" /><see langword="null" /> ist, wird ein neues Objekt instanziiert.</param>
      <typeparam name="T" vsli:raw="The type of the reference to be initialized.">Der Typ des zu initialisierenden Verweises.</typeparam>
      <returns vsli:raw="The initialized object.">Das initialisierte Objekt.</returns>
      <exception cref="T:System.MemberAccessException" vsli:raw="Permissions to access the constructor of type &lt;paramref name=&quot;T&quot; /&gt; were missing.">Berechtigungen, auf den Konstruktor des Typs <paramref name="T" /> zuzugreifen, haben gefehlt.</exception>
      <exception cref="T:System.MissingMemberException" vsli:raw="Type &lt;paramref name=&quot;T&quot; /&gt; does not have a parameterless constructor.">Der Typ <paramref name="T" /> hat keinen parameterlosen Konstruktor.</exception>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@,System.Func{``0})">
      <summary vsli:raw="Initializes a target reference or value type by using a specified function if it hasn't already been initialized.">Initialisiert einen Zielverweis- oder Werttyp mit einer angegebenen Funktion, wenn er noch nicht initialisiert wurde.</summary>
      <param name="target" vsli:raw="A reference or value of type &lt;c&gt;T&lt;/c&gt; to initialize if it hasn't already been initialized.">Ein Verweis oder Wert des Typs <c>T</c>, der initialisiert werden soll, wenn er noch nicht initialisiert wurde.</param>
      <param name="initialized" vsli:raw="A reference to a Boolean value that determines whether the target has already been initialized.">Ein Verweis auf einen booleschen Wert, der bestimmt, ob das Ziel bereits initialisiert wurde.</param>
      <param name="syncLock" vsli:raw="A reference to an object used as the mutually exclusive lock for initializing &lt;paramref name=&quot;target&quot; /&gt;. If &lt;paramref name=&quot;syncLock&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;, a new object will be instantiated.">Ein Verweis auf ein Objekt, das für die Initialisierung von <paramref name="target" /> als sich gegenseitig ausschließende Sperre verwendet wird. Wenn <paramref name="syncLock" /><see langword="null" /> ist, wird ein neues Objekt instanziiert.</param>
      <param name="valueFactory" vsli:raw="The function that is called to initialize the reference or value.">Die Funktion, die aufgerufen wird, um den Verweis oder den Wert zu initialisieren.</param>
      <typeparam name="T" vsli:raw="The type of the reference to be initialized.">Der Typ des zu initialisierenden Verweises.</typeparam>
      <returns vsli:raw="The initialized object.">Das initialisierte Objekt.</returns>
      <exception cref="T:System.MemberAccessException" vsli:raw="Permissions to access the constructor of type &lt;paramref name=&quot;T&quot; /&gt; were missing.">Berechtigungen, auf den Konstruktor des Typs <paramref name="T" /> zuzugreifen, haben gefehlt.</exception>
      <exception cref="T:System.MissingMemberException" vsli:raw="Type &lt;paramref name=&quot;T&quot; /&gt; does not have a parameterless constructor.">Der Typ <paramref name="T" /> hat keinen parameterlosen Konstruktor.</exception>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Func{``0})">
      <summary vsli:raw="Initializes a target reference type by using a specified function if it hasn't already been initialized.">Initialisiert einen Zielverweistyp mit einer angegebenen Funktion, wenn er noch nicht initialisiert wurde.</summary>
      <param name="target" vsli:raw="The reference to initialize if it hasn't already been initialized.">Der Verweis, der initialisiert werden soll, wenn er noch nicht initialisiert wurde.</param>
      <param name="valueFactory" vsli:raw="The function that is called to initialize the reference.">Die Funktion, die aufgerufen wird, um den Verweis zu initialisieren.</param>
      <typeparam name="T" vsli:raw="The type of the reference to be initialized.">Der Typ des zu initialisierenden Verweises.</typeparam>
      <returns vsli:raw="The initialized object.">Das initialisierte Objekt.</returns>
      <exception cref="T:System.MissingMemberException" vsli:raw="Type &lt;paramref name=&quot;T&quot; /&gt; does not have a parameterless constructor.">Der Typ <paramref name="T" /> hat keinen parameterlosen Konstruktor.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;valueFactory&quot; /&gt; returned null (Nothing in Visual Basic).">
        <paramref name="valueFactory" /> gibt null (Nothing in Visual Basic) zurück.</exception>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Object@,System.Func{``0})">
      <summary vsli:raw="Initializes a target reference type with a specified function if it has not already been initialized.">Initialisiert einen Zielverweistyp mit einer angegebenen Funktion, wenn er noch nicht initialisiert wurde.</summary>
      <param name="target" vsli:raw="A reference to initialize if it has not already been initialized. If it is &lt;see langword=&quot;null&quot; /&gt;, it is considered not initialized; otherwise, it's considered initialized.">Ein Verweis, der initialisiert werden soll, wenn er noch nicht initialisiert wurde.</param>
      <param name="syncLock" vsli:raw="A reference to an object used as the mutually exclusive lock for initializing&#xA;            &lt;paramref name=&quot;target&quot; /&gt;. If &lt;paramref name=&quot;syncLock&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;, a new object will be instantiated.">Ein Verweis auf ein Objekt, das für die Initialisierung von <paramref name="target" /> als sich gegenseitig ausschließende Sperre verwendet wird. Wenn <paramref name="syncLock" /><see langword="null" /> ist, wird ein neues Objekt instanziiert.</param>
      <param name="valueFactory" vsli:raw="The method to invoke to initialize &lt;paramref name=&quot;target&quot; /&gt;.">Die Methode, die zum Initialisieren von <paramref name="target" /> aufgerufen wird.</param>
      <typeparam name="T" vsli:raw="The type of the reference to be initialized.">Der Typ des zu initialisierenden Verweises.</typeparam>
      <returns vsli:raw="The initialized object.">Das initialisierte Objekt.</returns>
    </member>
    <member name="T:System.Threading.LockCookie">
      <summary vsli:raw="Defines the lock that implements single-writer/multiple-reader semantics. This is a value type.">Definiert die Sperre, die die Semantik für einen Writer und mehrere Reader implementiert. Dies ist ein Werttyp.</summary>
    </member>
    <member name="M:System.Threading.LockCookie.Equals(System.Object)">
      <summary vsli:raw="Indicates whether a specified object is a &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; and is equal to the current instance.">Gibt an, ob ein angegebenes Objekt ein <see cref="T:System.Threading.LockCookie" /> und gleich der aktuellen Instanz ist.</summary>
      <param name="obj" vsli:raw="The object to compare to the current instance.">Das Objekt, das mit der aktuellen Instanz verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the value of &lt;paramref name=&quot;obj&quot; /&gt; is equal to the value of the current instance; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der Wert von <paramref name="obj" /> dem Wert der aktuellen Instanz entspricht, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.LockCookie.Equals(System.Threading.LockCookie)">
      <summary vsli:raw="Indicates whether the current instance is equal to the specified &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt;.">Gibt an, ob die aktuelle Instanz und das angegebene <see cref="T:System.Threading.LockCookie" /> gleich sind.</summary>
      <param name="obj" vsli:raw="The &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; to compare to the current instance.">Die Struktur <see cref="T:System.Threading.LockCookie" />, die mit der aktuellen Instanz verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;obj&quot; /&gt; is equal to the value of the current instance; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn <paramref name="obj" /> gleich dem Wert der aktuellen Instanz ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.LockCookie.GetHashCode">
      <summary vsli:raw="Returns the hash code for this instance.">Gibt den Hashcode für diese Instanz zurück.</summary>
      <returns vsli:raw="A 32-bit signed integer hash code.">Ein 32-Bit-Hashcode als ganze Zahl mit Vorzeichen.</returns>
    </member>
    <member name="M:System.Threading.LockCookie.op_Equality(System.Threading.LockCookie,System.Threading.LockCookie)">
      <summary vsli:raw="Indicates whether two &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; structures are equal.">Gibt an, ob zwei <see cref="T:System.Threading.LockCookie" />-Strukturen gleich sind.</summary>
      <param name="a" vsli:raw="The &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; to compare to &lt;paramref name=&quot;b&quot; /&gt;.">Das <see cref="T:System.Threading.LockCookie" />, das mit <paramref name="b" /> verglichen werden soll.</param>
      <param name="b" vsli:raw="The &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; to compare to &lt;paramref name=&quot;a&quot; /&gt;.">Das <see cref="T:System.Threading.LockCookie" />, das mit <paramref name="a" /> verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;a&quot; /&gt; is equal to &lt;paramref name=&quot;b&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn <paramref name="a" /> und <paramref name="b" /> gleich sind, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.LockCookie.op_Inequality(System.Threading.LockCookie,System.Threading.LockCookie)">
      <summary vsli:raw="Indicates whether two &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; structures are not equal.">Gibt an, ob zwei <see cref="T:System.Threading.LockCookie" />-Strukturen ungleich sind.</summary>
      <param name="a" vsli:raw="The &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; to compare to &lt;paramref name=&quot;b&quot; /&gt;.">Das <see cref="T:System.Threading.LockCookie" />, das mit <paramref name="b" /> verglichen werden soll.</param>
      <param name="b" vsli:raw="The &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; to compare to &lt;paramref name=&quot;a&quot; /&gt;.">Das <see cref="T:System.Threading.LockCookie" />, das mit <paramref name="a" /> verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;a&quot; /&gt; is not equal to &lt;paramref name=&quot;b&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn <paramref name="a" /> und <paramref name="b" /> ungleich sind, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="T:System.Threading.LockRecursionException">
      <summary vsli:raw="The exception that is thrown when recursive entry into a lock is not compatible with the recursion policy for the lock.">Die Ausnahme, die ausgelöst wird, wenn die rekursive Anforderung einer Sperre nicht mit der Rekursionsrichtlinie der Sperre kompatibel ist.</summary>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.LockRecursionException&quot; /&gt; class with a system-supplied message that describes the error.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.LockRecursionException" />-Klasse mit einer vom System generierten Meldung, die den Fehler beschreibt.</summary>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.LockRecursionException&quot; /&gt; class with serialized data.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.LockRecursionException" />-Klasse mit serialisierten Daten.</summary>
      <param name="info" vsli:raw="The object that holds the serialized object data.">Das Objekt, das die Daten des serialisierten Objekts enthält.</param>
      <param name="context" vsli:raw="The contextual information about the source or destination.">Die Kontextinformationen zur Quelle bzw. zum Ziel.</param>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor(System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.LockRecursionException&quot; /&gt; class with a specified message that describes the error.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.LockRecursionException" />-Klasse mit einer angegebenen Meldung, die den Fehler beschreibt.</summary>
      <param name="message" vsli:raw="The message that describes the exception. The caller of this constructor must make sure that this string has been localized for the current system culture.">Die Meldung, in der die Ausnahme beschrieben wird Der Aufrufer dieses Konstruktors muss sicherstellen, dass diese Zeichenfolge für die aktuelle Systemkultur lokalisiert wurde.</param>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor(System.String,System.Exception)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.LockRecursionException&quot; /&gt; class with a specified error message and a reference to the inner exception that is the cause of this exception.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.LockRecursionException" />-Klasse mit einer angegebenen Fehlermeldung und einem Verweis auf die innere Ausnahme, die diese Ausnahme ausgelöst hat.</summary>
      <param name="message" vsli:raw="The message that describes the exception. The caller of this constructor must make sure that this string has been localized for the current system culture.">Die Meldung, in der die Ausnahme beschrieben wird Der Aufrufer dieses Konstruktors muss sicherstellen, dass diese Zeichenfolge für die aktuelle Systemkultur lokalisiert wurde.</param>
      <param name="innerException" vsli:raw="The exception that caused the current exception. If the &lt;paramref name=&quot;innerException&quot; /&gt; parameter is not &lt;see langword=&quot;null&quot; /&gt;, the current exception is raised in a &lt;see langword=&quot;catch&quot; /&gt; block that handles the inner exception.">Die Ausnahme, die die aktuelle Ausnahme verursacht hat. Wenn der <paramref name="innerException" />-Parameter nicht <see langword="null" /> ist, wird die aktuelle Ausnahme in einem <see langword="catch" />-Block ausgelöst, der die innere Ausnahme behandelt.</param>
    </member>
    <member name="T:System.Threading.LockRecursionPolicy">
      <summary vsli:raw="Specifies whether a lock can be entered multiple times by the same thread.">Gibt an, ob eine Sperre mehrmals dem gleichen Thread zugewiesen werden kann.</summary>
    </member>
    <member name="F:System.Threading.LockRecursionPolicy.NoRecursion">
      <summary vsli:raw="If a thread tries to enter a lock recursively, an exception is thrown. Some classes may allow certain recursions when this setting is in effect.">Wenn ein Thread rekursiv versucht, eine Sperre zu erhalten, wird eine Ausnahme ausgelöst. Einige Klassen gestatten gewisse Rekursionen, wenn diese Einstellung aktiv ist.</summary>
    </member>
    <member name="F:System.Threading.LockRecursionPolicy.SupportsRecursion">
      <summary vsli:raw="A thread can enter a lock recursively. Some classes may restrict this capability.">Ein Thread kann rekursiv eine Sperre erhalten. Einige Klassen beschränken diese Möglichkeit einer rekursiven Zuweisung.</summary>
    </member>
    <member name="T:System.Threading.ManualResetEvent">
      <summary vsli:raw="Represents a thread synchronization event that, when signaled, must be reset manually. This class cannot be inherited.">Stellt ein Threadsynchronisierungsereignis dar; muss bei Signalisierung manuell zurückgesetzt werden. Diese Klasse kann nicht vererbt werden.</summary>
    </member>
    <member name="M:System.Threading.ManualResetEvent.#ctor(System.Boolean)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.ManualResetEvent&quot; /&gt; class with a Boolean value indicating whether to set the initial state to signaled.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.ManualResetEvent" />-Klasse mit einem booleschen Wert, der angibt, ob der anfängliche Zustand auf signalisiert festgelegt werden soll.</summary>
      <param name="initialState" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set the initial state signaled; &lt;see langword=&quot;false&quot; /&gt; to set the initial state to nonsignaled.">
        <see langword="true" />, wenn der anfängliche Zustand auf signalisiert festgelegt werden soll, <see langword="false" />, wenn der anfängliche Zustand auf nicht signalisiert festgelegt werden soll.</param>
    </member>
    <member name="T:System.Threading.ManualResetEventSlim">
      <summary vsli:raw="Represents a thread synchronization event that, when signaled, must be reset manually. This class is a lightweight alternative to &lt;see cref=&quot;T:System.Threading.ManualResetEvent&quot; /&gt;.">Stellt ein Threadsynchronisierungsereignis dar, das bei Signalisierung manuell zurückgesetzt werden muss. Diese Klasse ist eine einfache Alternative zu <see cref="T:System.Threading.ManualResetEvent" />.</summary>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; class with an initial state of nonsignaled.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.ManualResetEventSlim" />-Klasse mit dem Anfangszustand "nicht signalisiert".</summary>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.#ctor(System.Boolean)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; class with a Boolean value indicating whether to set the initial state to signaled.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.ManualResetEventSlim" />-Klasse mit einem booleschen Wert, der angibt, ob der anfängliche Zustand auf signalisiert festgelegt werden soll.</summary>
      <param name="initialState" vsli:raw="true to set the initial state signaled; false to set the initial state to nonsignaled.">True, um den Anfangszustand auf „signalisiert“ festzulegen, false um den Anfangszustand auf „nicht signalisiert“ festzulegen.</param>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.#ctor(System.Boolean,System.Int32)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; class with a Boolean value indicating whether to set the initial state to signaled and a specified spin count.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.ManualResetEventSlim" />-Klasse mit einem booleschen Wert, der angibt, ob der Anfangszustand auf „signalisiert“ festgelegt werden soll, und einer festgelegten Spin-Anzahl.</summary>
      <param name="initialState" vsli:raw="true to set the initial state to signaled; false to set the initial state to nonsignaled.">True, um den Anfangszustand auf "signalisiert" festzulegen, false um den Anfangszustand auf "nicht signalisiert" festzulegen.</param>
      <param name="spinCount" vsli:raw="The number of spin waits that will occur before falling back to a kernel-based wait operation.">Die Anzahl von Spin-Wartevorgängen, die vor dem Fallback auf einen kernelbasierten Wartevorgang stattfinden.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;spinCount&quot; /&gt; is less than 0 or greater than the maximum allowed value.">
        <paramref name="spinCount" /> ist kleiner als 0 oder größer als der maximal zulässige Wert.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; class.">Gibt alle von der aktuellen Instanz der <see cref="T:System.Threading.ManualResetEventSlim" />-Klasse verwendeten Ressourcen frei.</summary>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Dispose(System.Boolean)">
      <summary vsli:raw="Releases the unmanaged resources used by the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt;, and optionally releases the managed resources.">Gibt die von <see cref="T:System.Threading.ManualResetEventSlim" /> verwendeten nicht verwalteten Ressourcen und optional die verwalteten Ressourcen frei.</summary>
      <param name="disposing" vsli:raw="true to release both managed and unmanaged resources; false to release only unmanaged resources.">true, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, false, um nur nicht verwaltete Ressourcen freizugeben.</param>
    </member>
    <member name="P:System.Threading.ManualResetEventSlim.IsSet">
      <summary vsli:raw="Gets whether the event is set.">Ruft einen Wert ab, der angibt, ob das Ereignis festgelegt wurde.</summary>
      <returns vsli:raw="true if the event is set; otherwise, false.">True, wenn das Ereignis festgelegt wurde, andernfalls false.</returns>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Reset">
      <summary vsli:raw="Sets the state of the event to nonsignaled, which causes threads to block.">Legt den Zustand des Ereignisses auf „nicht signalisiert“ fest, sodass Threads blockiert werden.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The object has already been disposed.">Das Objekt wurde bereits verworfen.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Set">
      <summary vsli:raw="Sets the state of the event to signaled, which allows one or more threads waiting on the event to proceed.">Legt den Zustand des Ereignisses auf „signalisiert“ fest und ermöglicht so die weitere Ausführung eines oder mehrerer wartender Threads.</summary>
    </member>
    <member name="P:System.Threading.ManualResetEventSlim.SpinCount">
      <summary vsli:raw="Gets the number of spin waits that will occur before falling back to a kernel-based wait operation.">Ruft die Anzahl von Spin-Wartevorgängen an, die vor dem Fallback auf einen kernelbasierten Wartevorgang stattfinden.</summary>
      <returns vsli:raw="Returns the number of spin waits that will occur before falling back to a kernel-based wait operation.">Gibt die Anzahl von Spin-Wartevorgängen zurück, die vor dem Fallback auf einen kernelbasierten Wartevorgang stattfinden.</returns>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait">
      <summary vsli:raw="Blocks the current thread until the current &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; is set.">Blockiert den aktuellen Thread, bis das aktuelle <see cref="T:System.Threading.ManualResetEventSlim" /> festgelegt wird.</summary>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The maximum number of waiters has been exceeded.">Die maximale Waiteranzahl wurde überschritten.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The object has already been disposed.">Das Objekt wurde bereits verworfen.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.Int32)">
      <summary vsli:raw="Blocks the current thread until the current &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; is set, using a 32-bit signed integer to measure the time interval.">Blockiert den aktuellen Thread, bis das aktuelle <see cref="T:System.Threading.ManualResetEventSlim" /> festgelegt wird, wobei eine 32-Bit-Ganzzahl mit Vorzeichen zum Messen des Zeitintervalls verwendet wird.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;(-1) to wait indefinitely.">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn <see cref="T:System.Threading.ManualResetEventSlim" /> festgelegt war; andernfalls <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The maximum number of waiters has been exceeded.">Die maximale Waiteranzahl wurde überschritten.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The object has already been disposed.">Das Objekt wurde bereits verworfen.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.Int32,System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until the current &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; is set, using a 32-bit signed integer to measure the time interval, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Blockiert den aktuellen Thread, bis das aktuelle <see cref="T:System.Threading.ManualResetEventSlim" /> festgelegt wird, wobei eine 32-Bit-Ganzzahl mit Vorzeichen zum Messen des Zeitintervalls verwendet und ein <see cref="T:System.Threading.CancellationToken" /> überwacht wird.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;(-1) to wait indefinitely.">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">Das zu überwachende <see cref="T:System.Threading.CancellationToken" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn <see cref="T:System.Threading.ManualResetEventSlim" /> festgelegt war; andernfalls <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">
        <paramref name="cancellationToken" /> wurde abgebrochen.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The maximum number of waiters has been exceeded.">Die maximale Waiteranzahl wurde überschritten.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The object has already been disposed or the &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has been disposed.">Das Objekt wurde bereits freigegeben oder das <see cref="T:System.Threading.CancellationTokenSource" />-Element, das <paramref name="cancellationToken" /> erstellt hat, wurde freigegeben.</exception>
      <exception cref="">
        <paramref name="cancellationToken" /> wurde abgebrochen.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until the current &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; receives a signal, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Blockiert den aktuellen Thread, bis das aktuelle <see cref="T:System.Threading.ManualResetEventSlim" /> ein Signal empfängt, wobei ein <see cref="T:System.Threading.CancellationToken" /> überwacht wird.</summary>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">Das zu überwachende <see cref="T:System.Threading.CancellationToken" />.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The maximum number of waiters has been exceeded.">Die maximale Waiteranzahl wurde überschritten.</exception>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">
        <paramref name="cancellationToken" /> wurde abgebrochen.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The object has already been disposed or the &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has been disposed.">Das Objekt wurde bereits freigegeben oder das <see cref="T:System.Threading.CancellationTokenSource" />-Element, das <paramref name="cancellationToken" /> erstellt hat, wurde freigegeben.</exception>
      <exception cref="">
        <paramref name="cancellationToken" /> wurde abgebrochen.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.TimeSpan)">
      <summary vsli:raw="Blocks the current thread until the current &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; is set, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; to measure the time interval.">Blockiert den aktuellen Thread, bis das aktuelle <see cref="T:System.Threading.ManualResetEventSlim" /> festgelegt wird, wobei ein <see cref="T:System.TimeSpan" /> zum Messen des Zeitintervalls verwendet wird.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely.">Eine <see cref="T:System.TimeSpan" />-Struktur, die die Anzahl der zu wartenden Millisekunden angibt, oder eine <see cref="T:System.TimeSpan" />-Struktur, die -1 Millisekunden zum unendlichen Warten angibt.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn <see cref="T:System.Threading.ManualResetEventSlim" /> festgelegt war; andernfalls <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out.  &#xA;  &#xA; -or-  &#xA;  &#xA; The number of milliseconds in &lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> ist eine negative Zahl ungleich -1 Millisekunden, die ein unendliches Timeout darstellt. 

oder - 
Die Anzahl der Millisekunden in <paramref name="timeout" /> ist größer als in <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The maximum number of waiters has been exceeded.">Die maximale Waiteranzahl wurde überschritten.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The object has already been disposed.">Das Objekt wurde bereits verworfen.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until the current &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; is set, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; to measure the time interval, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Blockiert den aktuellen Thread, bis das aktuelle <see cref="T:System.Threading.ManualResetEventSlim" /> festgelegt wird, wobei ein <see cref="T:System.TimeSpan" /> zum Messen des Zeitintervalls verwendet und ein <see cref="T:System.Threading.CancellationToken" /> überwacht wird.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely.">Eine <see cref="T:System.TimeSpan" />-Struktur, die die Anzahl der zu wartenden Millisekunden angibt, oder eine <see cref="T:System.TimeSpan" />-Struktur, die -1 Millisekunden zum unendlichen Warten angibt.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">Das zu überwachende <see cref="T:System.Threading.CancellationToken" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn <see cref="T:System.Threading.ManualResetEventSlim" /> festgelegt war; andernfalls <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">
        <paramref name="cancellationToken" /> wurde abgebrochen.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out.  &#xA;  &#xA; -or-  &#xA;  &#xA; The number of milliseconds in &lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> ist eine negative Zahl ungleich -1 Millisekunden, die ein unendliches Timeout darstellt. 

oder - 
Die Anzahl der Millisekunden in <paramref name="timeout" /> ist größer als in <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The maximum number of waiters has been exceeded.">Die maximale Waiteranzahl wurde überschritten.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The object has already been disposed or the &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has been disposed.">Das Objekt wurde bereits freigegeben oder das <see cref="T:System.Threading.CancellationTokenSource" />-Element, das <paramref name="cancellationToken" /> erstellt hat, wurde freigegeben.</exception>
      <exception cref="">
        <paramref name="cancellationToken" /> wurde abgebrochen.</exception>
    </member>
    <member name="P:System.Threading.ManualResetEventSlim.WaitHandle">
      <summary vsli:raw="Gets the underlying &lt;see cref=&quot;T:System.Threading.WaitHandle&quot; /&gt; object for this &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt;.">Ruft das zugrunde liegende <see cref="T:System.Threading.WaitHandle" />-Objekt für dieses <see cref="T:System.Threading.ManualResetEventSlim" /> ab.</summary>
      <returns vsli:raw="The underlying &lt;see cref=&quot;T:System.Threading.WaitHandle&quot; /&gt; event object for this &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt;.">Das zugrunde liegende <see cref="T:System.Threading.WaitHandle" />-Ereignisobjekt für dieses <see cref="T:System.Threading.ManualResetEventSlim" />.</returns>
    </member>
    <member name="T:System.Threading.Monitor">
      <summary vsli:raw="Provides a mechanism that synchronizes access to objects.">Stellt einen Mechanismus bereit, der den Zugriff auf Objekte synchronisiert.</summary>
    </member>
    <member name="M:System.Threading.Monitor.Enter(System.Object)">
      <summary vsli:raw="Acquires an exclusive lock on the specified object.">Erhält eine exklusive Sperre für das angegebene Objekt.</summary>
      <param name="obj" vsli:raw="The object on which to acquire the monitor lock.">Das Objekt, für das die Monitorsperre erhalten werden soll.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
      <summary vsli:raw="Acquires an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.">Erhält eine exklusive Sperre für das angegebene Objekt und legt atomar einen Wert fest, der angibt, ob die Sperre angenommen wurde.</summary>
      <param name="obj" vsli:raw="The object on which to wait.">Das Objekt, auf das gewartet werden soll.</param>
      <param name="lockTaken" vsli:raw="The result of the attempt to acquire the lock, passed by reference. The input must be &lt;see langword=&quot;false&quot; /&gt;. The output is &lt;see langword=&quot;true&quot; /&gt; if the lock is acquired; otherwise, the output is &lt;see langword=&quot;false&quot; /&gt;. The output is set even if an exception occurs during the attempt to acquire the lock.  &#xA;  &#xA; Note   If no exception occurs, the output of this method is always &lt;see langword=&quot;true&quot; /&gt;.">Das Ergebnis des Versuchs, die Sperre abzurufen, übergeben als Verweis. Die Eingabe muss <see langword="false" /> sein. Die Ausgabe ist <see langword="true" />, wenn die Sperre abgerufen wurde. Andernfalls ist die Ausgabe <see langword="false" />. Die Ausgabe wird auch dann festgelegt, wenn eine Ausnahme bei dem Versuch auftritt, die Sperre abzurufen.  
Hinweis   Wenn keine Ausnahme auftritt, ist die Ausgabe dieser Methode immer <see langword="true" />.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The input to &lt;paramref name=&quot;lockTaken&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;.">Die Eingabe für <paramref name="lockTaken" /> ist <see langword="true" />.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Exit(System.Object)">
      <summary vsli:raw="Releases an exclusive lock on the specified object.">Hebt eine exklusive Sperre für das angegebene Objekt auf.</summary>
      <param name="obj" vsli:raw="The object on which to release the lock.">Das Objekt, dessen Sperre aufgehoben werden soll.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The current thread does not own the lock for the specified object.">Der aktuelle Thread besitzt die Sperre für das angegebene Objekt nicht.</exception>
    </member>
    <member name="M:System.Threading.Monitor.IsEntered(System.Object)">
      <summary vsli:raw="Determines whether the current thread holds the lock on the specified object.">Bestimmt, ob der aktuelle Thread die Sperre für das angegebene Objekt enthält.</summary>
      <param name="obj" vsli:raw="The object to test.">Das zu überprüfende Objekt.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread holds the lock on &lt;paramref name=&quot;obj&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der aktuelle Thread die Schreibsperre für <paramref name="obj" /> enthält, andernfalls <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;obj&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="obj" /> ist <see langword="null" />.</exception>
    </member>
    <member name="P:System.Threading.Monitor.LockContentionCount">
      <summary vsli:raw="Gets the number of times there was contention when trying to take the monitor's lock.">Ruft die Anzahl der Konflikte ab beim Versuch, die Sperre des Monitors aufzuheben.</summary>
      <returns vsli:raw="The number of times there was contention when trying to take the monitor's lock.">Gibt an, wie oft Konflikte aufgetreten sind, als versucht wurde, die Sperre des Monitors zu übernehmen.</returns>
    </member>
    <member name="M:System.Threading.Monitor.Pulse(System.Object)">
      <summary vsli:raw="Notifies a thread in the waiting queue of a change in the locked object's state.">Benachrichtigt einen Thread in der Warteschlange für abzuarbeitende Threads über eine Änderung am Zustand des gesperrten Objekts.</summary>
      <param name="obj" vsli:raw="The object a thread is waiting for.">Das Objekt, auf das ein Thread wartet.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The calling thread does not own the lock for the specified object.">Der aufrufende Thread besitzt keine Sperre für das angegebene Objekt.</exception>
    </member>
    <member name="M:System.Threading.Monitor.PulseAll(System.Object)">
      <summary vsli:raw="Notifies all waiting threads of a change in the object's state.">Benachrichtigt alle wartenden Threads über eine Änderung am Zustand des Objekts.</summary>
      <param name="obj" vsli:raw="The object that sends the pulse.">Das Objekt, das den Impuls sendet.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The calling thread does not own the lock for the specified object.">Der aufrufende Thread besitzt keine Sperre für das angegebene Objekt.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object)">
      <summary vsli:raw="Attempts to acquire an exclusive lock on the specified object.">Versucht, eine exklusive Sperre für das angegebene Objekt zu erhalten.</summary>
      <param name="obj" vsli:raw="The object on which to acquire the lock.">Das Objekt, für das die Sperre erhalten werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread acquires the lock; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der aktuelle Thread die Sperre erhält, andernfalls <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
      <summary vsli:raw="Attempts to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.">Versucht, eine exklusive Sperre für das angegebene Objekt zu erhalten, und legt atomar einen Wert fest, der angibt, ob die Sperre angenommen wurde.</summary>
      <param name="obj" vsli:raw="The object on which to acquire the lock.">Das Objekt, für das die Sperre erhalten werden soll.</param>
      <param name="lockTaken" vsli:raw="The result of the attempt to acquire the lock, passed by reference. The input must be &lt;see langword=&quot;false&quot; /&gt;. The output is &lt;see langword=&quot;true&quot; /&gt; if the lock is acquired; otherwise, the output is &lt;see langword=&quot;false&quot; /&gt;. The output is set even if an exception occurs during the attempt to acquire the lock.">Das Ergebnis des Versuchs, die Sperre abzurufen, übergeben als Verweis. Die Eingabe muss <see langword="false" /> sein. Die Ausgabe ist <see langword="true" />, wenn die Sperre abgerufen wurde. Andernfalls ist die Ausgabe <see langword="false" />. Die Ausgabe wird auch dann festgelegt, wenn eine Ausnahme bei dem Versuch auftritt, die Sperre abzurufen.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The input to &lt;paramref name=&quot;lockTaken&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;.">Die Eingabe für <paramref name="lockTaken" /> ist <see langword="true" />.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
      <summary vsli:raw="Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object.">Versucht über eine angegebene Anzahl von Millisekunden hinweg, eine exklusive Sperre für das angegebene Objekt zu erhalten.</summary>
      <param name="obj" vsli:raw="The object on which to acquire the lock.">Das Objekt, für das die Sperre erhalten werden soll.</param>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait for the lock.">Die Anzahl der Millisekunden, für die auf die Sperre gewartet werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread acquires the lock; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der aktuelle Thread die Sperre erhält, andernfalls <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is negative, and not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;.">
        <paramref name="millisecondsTimeout" /> ist negativ und ungleich <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
      <summary vsli:raw="Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.">Versucht für die angegebene Anzahl von Millisekunden, eine exklusive Sperre für das angegebene Objekt zu erhalten, und legt atomar einen Wert fest, der angibt, ob die Sperre angenommen wurde.</summary>
      <param name="obj" vsli:raw="The object on which to acquire the lock.">Das Objekt, für das die Sperre erhalten werden soll.</param>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait for the lock.">Die Anzahl der Millisekunden, für die auf die Sperre gewartet werden soll.</param>
      <param name="lockTaken" vsli:raw="The result of the attempt to acquire the lock, passed by reference. The input must be &lt;see langword=&quot;false&quot; /&gt;. The output is &lt;see langword=&quot;true&quot; /&gt; if the lock is acquired; otherwise, the output is &lt;see langword=&quot;false&quot; /&gt;. The output is set even if an exception occurs during the attempt to acquire the lock.">Das Ergebnis des Versuchs, die Sperre abzurufen, übergeben als Verweis. Die Eingabe muss <see langword="false" /> sein. Die Ausgabe ist <see langword="true" />, wenn die Sperre abgerufen wurde. Andernfalls ist die Ausgabe <see langword="false" />. Die Ausgabe wird auch dann festgelegt, wenn eine Ausnahme bei dem Versuch auftritt, die Sperre abzurufen.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The input to &lt;paramref name=&quot;lockTaken&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;.">Die Eingabe für <paramref name="lockTaken" /> ist <see langword="true" />.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is negative, and not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;.">
        <paramref name="millisecondsTimeout" /> ist negativ und ungleich <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
      <summary vsli:raw="Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object.">Versucht über einen angegebenen Zeitraum hinweg, eine exklusive Sperre für das angegebene Objekt zu erhalten.</summary>
      <param name="obj" vsli:raw="The object on which to acquire the lock.">Das Objekt, für das die Sperre erhalten werden soll.</param>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; representing the amount of time to wait for the lock. A value of -1 millisecond specifies an infinite wait.">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne darstellt, für die auf die Sperre gewartet werden soll. Ein Wert von –1 Millisekunde gibt eine unbegrenzte Wartezeit an.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread acquires the lock; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der aktuelle Thread die Sperre erhält, andernfalls <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of &lt;paramref name=&quot;timeout&quot; /&gt; in milliseconds is negative and is not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1 millisecond), or is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">Der Wert von <paramref name="timeout" /> in Millisekunden ist negativ und nicht gleich <see cref="F:System.Threading.Timeout.Infinite" /> (–1 Millisekunde) oder ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
      <summary vsli:raw="Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.">Versucht für die angegebene Dauer, eine exklusive Sperre für das angegebene Objekt zu erhalten, und legt atomar einen Wert fest, der angibt, ob die Sperre angenommen wurde.</summary>
      <param name="obj" vsli:raw="The object on which to acquire the lock.">Das Objekt, für das die Sperre erhalten werden soll.</param>
      <param name="timeout" vsli:raw="The amount of time to wait for the lock. A value of -1 millisecond specifies an infinite wait.">Die Zeitspanne, für die auf die Sperre gewartet werden soll. Ein Wert von –1 Millisekunde gibt eine unbegrenzte Wartezeit an.</param>
      <param name="lockTaken" vsli:raw="The result of the attempt to acquire the lock, passed by reference. The input must be &lt;see langword=&quot;false&quot; /&gt;. The output is &lt;see langword=&quot;true&quot; /&gt; if the lock is acquired; otherwise, the output is &lt;see langword=&quot;false&quot; /&gt;. The output is set even if an exception occurs during the attempt to acquire the lock.">Das Ergebnis des Versuchs, die Sperre abzurufen, übergeben als Verweis. Die Eingabe muss <see langword="false" /> sein. Die Ausgabe ist <see langword="true" />, wenn die Sperre abgerufen wurde. Andernfalls ist die Ausgabe <see langword="false" />. Die Ausgabe wird auch dann festgelegt, wenn eine Ausnahme bei dem Versuch auftritt, die Sperre abzurufen.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The input to &lt;paramref name=&quot;lockTaken&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;.">Die Eingabe für <paramref name="lockTaken" /> ist <see langword="true" />.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of &lt;paramref name=&quot;timeout&quot; /&gt; in milliseconds is negative and is not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1 millisecond), or is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">Der Wert von <paramref name="timeout" /> in Millisekunden ist negativ und nicht gleich <see cref="F:System.Threading.Timeout.Infinite" /> (–1 Millisekunde) oder ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object)">
      <summary vsli:raw="Releases the lock on an object and blocks the current thread until it reacquires the lock.">Hebt die Sperre für ein Objekt auf und blockiert den aktuellen Thread, bis er die Sperre erneut erhält.</summary>
      <param name="obj" vsli:raw="The object on which to wait.">Das Objekt, auf das gewartet werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the call returned because the caller reacquired the lock for the specified object. This method does not return if the lock is not reacquired.">
        <see langword="true" />, wenn der Aufruf beendet wurde, weil der Aufrufer die Sperre für das angegebene Objekt erneut erhalten hat. Diese Methode wird nicht beendet, wenn die Sperre nicht erneut erhalten wird.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The calling thread does not own the lock for the specified object.">Der aufrufende Thread besitzt keine Sperre für das angegebene Objekt.</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException" vsli:raw="The thread that invokes &lt;see langword=&quot;Wait&quot; /&gt; is later interrupted from the waiting state. This happens when another thread calls this thread's &lt;see cref=&quot;M:System.Threading.Thread.Interrupt&quot; /&gt; method.">Der Thread, der <see langword="Wait" /> aufruft, wird später im Wartezustand unterbrochen. Dies geschieht, wenn ein anderer Thread die <see cref="M:System.Threading.Thread.Interrupt" />-Methode dieses Threads aufruft.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
      <summary vsli:raw="Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue.">Hebt die Sperre für ein Objekt auf und blockiert den aktuellen Thread, bis er die Sperre erneut erhält. Wenn das angegebene Timeoutintervall abläuft, tritt der Thread in die Warteschlange für abgearbeitete Threads ein.</summary>
      <param name="obj" vsli:raw="The object on which to wait.">Das Objekt, auf das gewartet werden soll.</param>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait before the thread enters the ready queue.">Die Anzahl von Millisekunden, die gewartet wird, bevor der Thread in die Warteschlange für abgearbeitete Threads eintritt.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the lock was reacquired before the specified time elapsed; &lt;see langword=&quot;false&quot; /&gt; if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired.">
        <see langword="true" />, wenn die Sperre erneut erhalten wurde, bevor die angegebene Zeitspanne verstrichen ist. <see langword="false" />, wenn die Sperre erneut erhalten wurde, nachdem die angegebene Zeitspanne verstrichen ist. Die Methode wird erst beendet, wenn die Sperre erneut erhalten wurde.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The calling thread does not own the lock for the specified object.">Der aufrufende Thread besitzt keine Sperre für das angegebene Objekt.</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException" vsli:raw="The thread that invokes &lt;see langword=&quot;Wait&quot; /&gt; is later interrupted from the waiting state. This happens when another thread calls this thread's &lt;see cref=&quot;M:System.Threading.Thread.Interrupt&quot; /&gt; method.">Der Thread, der <see langword="Wait" /> aufruft, wird später im Wartezustand unterbrochen. Dies geschieht, wenn ein anderer Thread die <see cref="M:System.Threading.Thread.Interrupt" />-Methode dieses Threads aufruft.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of the &lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; parameter is negative, and is not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;.">Der Wert des <paramref name="millisecondsTimeout" />-Parameters ist negativ und ungleich <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
      <summary vsli:raw="Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue. This method also specifies whether the synchronization domain for the context (if in a synchronized context) is exited before the wait and reacquired afterward.">Hebt die Sperre für ein Objekt auf und blockiert den aktuellen Thread, bis er die Sperre erneut erhält. Wenn das angegebene Timeoutintervall abläuft, tritt der Thread in die Warteschlange für abgearbeitete Threads ein. Diese Methode gibt außerdem an, ob die Synchronisierungsdomäne danach für den Kontext (wenn es sich um einen synchronisierten Kontext handelt) vor dem Warten und erneuten Erhalten verlassen wird.</summary>
      <param name="obj" vsli:raw="The object on which to wait.">Das Objekt, auf das gewartet werden soll.</param>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait before the thread enters the ready queue.">Die Anzahl von Millisekunden, die gewartet wird, bevor der Thread in die Warteschlange für abgearbeitete Threads eintritt.</param>
      <param name="exitContext" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to exit and reacquire the synchronization domain for the context (if in a synchronized context) before the wait; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, um die Synchronisierungsdomäne für den Kontext (sofern ein synchronisierter Kontext vorliegt) vor dem Wartevorgang zu beenden und erneut zu erhalten, andernfalls <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the lock was reacquired before the specified time elapsed; &lt;see langword=&quot;false&quot; /&gt; if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired.">
        <see langword="true" />, wenn die Sperre erneut erhalten wurde, bevor die angegebene Zeitspanne verstrichen ist. <see langword="false" />, wenn die Sperre erneut erhalten wurde, nachdem die angegebene Zeitspanne verstrichen ist. Die Methode wird erst beendet, wenn die Sperre erneut erhalten wurde.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="&lt;see langword=&quot;Wait&quot; /&gt; is not invoked from within a synchronized block of code.">
        <see langword="Wait" /> wird nicht aus einem synchronisierten Codeblock aufgerufen.</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException" vsli:raw="The thread that invokes &lt;see langword=&quot;Wait&quot; /&gt; is later interrupted from the waiting state. This happens when another thread calls this thread's &lt;see cref=&quot;M:System.Threading.Thread.Interrupt&quot; /&gt; method.">Der Thread, der <see langword="Wait" /> aufruft, wird später im Wartezustand unterbrochen. Dies geschieht, wenn ein anderer Thread die <see cref="M:System.Threading.Thread.Interrupt" />-Methode dieses Threads aufruft.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of the &lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; parameter is negative, and is not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;.">Der Wert des <paramref name="millisecondsTimeout" />-Parameters ist negativ und ungleich <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
      <summary vsli:raw="Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue.">Hebt die Sperre für ein Objekt auf und blockiert den aktuellen Thread, bis er die Sperre erneut erhält. Wenn das angegebene Timeoutintervall abläuft, tritt der Thread in die Warteschlange für abgearbeitete Threads ein.</summary>
      <param name="obj" vsli:raw="The object on which to wait.">Das Objekt, auf das gewartet werden soll.</param>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; representing the amount of time to wait before the thread enters the ready queue.">Ein <see cref="T:System.TimeSpan" />, der die Zeit angibt, die gewartet wird, bevor der Thread in die Warteschlange für abgearbeitete Threads eintritt.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the lock was reacquired before the specified time elapsed; &lt;see langword=&quot;false&quot; /&gt; if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired.">
        <see langword="true" />, wenn die Sperre erneut erhalten wurde, bevor die angegebene Zeitspanne verstrichen ist. <see langword="false" />, wenn die Sperre erneut erhalten wurde, nachdem die angegebene Zeitspanne verstrichen ist. Die Methode wird erst beendet, wenn die Sperre erneut erhalten wurde.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The calling thread does not own the lock for the specified object.">Der aufrufende Thread besitzt keine Sperre für das angegebene Objekt.</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException" vsli:raw="The thread that invokes &lt;see langword=&quot;Wait&quot; /&gt; is later interrupted from the waiting state. This happens when another thread calls this thread's &lt;see cref=&quot;M:System.Threading.Thread.Interrupt&quot; /&gt; method.">Der Thread, der <see langword="Wait" /> aufruft, wird später im Wartezustand unterbrochen. Dies geschieht, wenn ein anderer Thread die <see cref="M:System.Threading.Thread.Interrupt" />-Methode dieses Threads aufruft.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of the &lt;paramref name=&quot;timeout&quot; /&gt; parameter in milliseconds is negative and does not represent &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1 millisecond), or is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">Der Wert des <paramref name="timeout" />-Parameters in Millisekunden ist negativ und stellt nicht <see cref="F:System.Threading.Timeout.Infinite" /> (–1 Millisekunde) dar, oder er ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
      <summary vsli:raw="Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue. Optionally exits the synchronization domain for the synchronized context before the wait and reacquires the domain afterward.">Hebt die Sperre für ein Objekt auf und blockiert den aktuellen Thread, bis er die Sperre erneut erhält. Wenn das angegebene Timeoutintervall abläuft, tritt der Thread in die Warteschlange für abgearbeitete Threads ein. Beendet vor dem Warten optional auch die Synchronisierungsdomäne für den synchronisierten Kontext und erhält die Domäne anschließend wieder.</summary>
      <param name="obj" vsli:raw="The object on which to wait.">Das Objekt, auf das gewartet werden soll.</param>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; representing the amount of time to wait before the thread enters the ready queue.">Ein <see cref="T:System.TimeSpan" />, der die Zeit angibt, die gewartet wird, bevor der Thread in die Warteschlange für abgearbeitete Threads eintritt.</param>
      <param name="exitContext" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to exit and reacquire the synchronization domain for the context (if in a synchronized context) before the wait; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, um die Synchronisierungsdomäne für den Kontext (sofern ein synchronisierter Kontext vorliegt) vor dem Wartevorgang zu beenden und erneut zu erhalten, andernfalls <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the lock was reacquired before the specified time elapsed; &lt;see langword=&quot;false&quot; /&gt; if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired.">
        <see langword="true" />, wenn die Sperre erneut erhalten wurde, bevor die angegebene Zeitspanne verstrichen ist. <see langword="false" />, wenn die Sperre erneut erhalten wurde, nachdem die angegebene Zeitspanne verstrichen ist. Die Methode wird erst beendet, wenn die Sperre erneut erhalten wurde.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="&lt;see langword=&quot;Wait&quot; /&gt; is not invoked from within a synchronized block of code.">
        <see langword="Wait" /> wird nicht aus einem synchronisierten Codeblock aufgerufen.</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException" vsli:raw="The thread that invokes Wait is later interrupted from the waiting state. This happens when another thread calls this thread's &lt;see cref=&quot;M:System.Threading.Thread.Interrupt&quot; /&gt; method.">Der Thread, der „Wait“ aufruft, wird später im Wartezustand unterbrochen. Dies geschieht, wenn ein anderer Thread die <see cref="M:System.Threading.Thread.Interrupt" />-Methode dieses Threads aufruft.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The &lt;paramref name=&quot;timeout&quot; /&gt; parameter is negative and does not represent &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1 millisecond), or is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">Der <paramref name="timeout" />-Parameter ist negativ und stellt nicht <see cref="F:System.Threading.Timeout.Infinite" /> dar (–1 Millisekunde), oder er ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="T:System.Threading.Mutex">
      <summary vsli:raw="A synchronization primitive that can also be used for interprocess synchronization.">Ein primitiver Synchronisierungstyp, der auch für die prozessübergreifende Synchronisierung verwendet werden kann.</summary>
    </member>
    <member name="M:System.Threading.Mutex.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; class with default properties.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.Mutex" />-Klasse mit Standardeigenschaften.</summary>
    </member>
    <member name="M:System.Threading.Mutex.#ctor(System.Boolean)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.Mutex" />-Klasse mit einem booleschen Wert, der angibt, ob dem aufrufenden Thread der anfängliche Besitz des Mutex zugewiesen werden soll.</summary>
      <param name="initiallyOwned" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to give the calling thread initial ownership of the mutex; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, um dem aufrufenden Thread den anfänglichen Besitz des Mutex zuzuweisen, andernfalls <see langword="false" />.</param>
    </member>
    <member name="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, and a string that is the name of the mutex.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.Mutex" />-Klasse mit einem booleschen Wert, der angibt, ob dem aufrufenden Thread der anfängliche Besitz des Mutex zugewiesen werden soll, sowie mit einer Zeichenfolge, die den Namen des Mutex darstellt.</summary>
      <param name="initiallyOwned" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, um dem aufrufenden Thread den anfänglichen Besitz des benannten Systemmutex zuzuweisen, wenn der benannte Systemmutex als Ergebnis dieses Aufrufs erstellt wird, andernfalls <see langword="false" />.</param>
      <param name="name" vsli:raw="The name, if the synchronization object is to be shared with other processes; otherwise, &lt;see langword=&quot;null&quot; /&gt; or an empty string. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">Der Name des <see cref="T:System.Threading.Mutex" />. Bei einem Wert von <see langword="null" /> ist das <see cref="T:System.Threading.Mutex" /> unbenannt.</param>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named mutex exists and has access control security, but the user does not have &lt;see cref=&quot;F:System.Security.AccessControl.MutexRights.FullControl&quot; /&gt;.">Das benannte Mutex ist vorhanden und verfügt über Zugriffssteuerungssicherheit, aber der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Win32-Fehler.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be created. A synchronization object of a different type might have the same name.">Das benannte Mutex kann nicht erstellt werden, möglicherweise weil ein Wait-Handle eines anderen Typs denselben Namen hat.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&#xA;          .NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="name" /> ist länger als 260 Zeichen.</exception>
    </member>
    <member name="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, and a Boolean value that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.Mutex" />-Klasse mit einem booleschen Wert, der angibt, ob dem aufrufenden Thread der anfängliche Besitz des Mutex zugewiesen werden soll, mit einer Zeichenfolge mit dem Namen des Mutex sowie mit einem booleschen Wert, der beim Beenden der Methode angibt, ob dem aufrufenden Thread der anfängliche Besitz des Mutex gewährt wurde.</summary>
      <param name="initiallyOwned" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, um dem aufrufenden Thread den anfänglichen Besitz des benannten Systemmutex zuzuweisen, wenn der benannte Systemmutex als Ergebnis dieses Aufrufs erstellt wird, andernfalls <see langword="false" />.</param>
      <param name="name" vsli:raw="The name, if the synchronization object is to be shared with other processes; otherwise, &lt;see langword=&quot;null&quot; /&gt; or an empty string. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">Der Name des <see cref="T:System.Threading.Mutex" />. Bei einem Wert von <see langword="null" /> ist das <see cref="T:System.Threading.Mutex" /> unbenannt.</param>
      <param name="createdNew" vsli:raw="When this method returns, contains a Boolean that is &lt;see langword=&quot;true&quot; /&gt; if a local mutex was created (that is, if &lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; or an empty string) or if the specified named system mutex was created; &lt;see langword=&quot;false&quot; /&gt; if the specified named system mutex already existed. This parameter is passed uninitialized.">Enthält nach dem Beenden dieser Methode einen booleschen Wert, der <see langword="true" /> ist, wenn ein lokaler Mutex erstellt wurde (d. h. wenn <paramref name="name" /> gleich <see langword="null" /> oder eine leere Zeichenfolge ist) oder wenn der angegebene benannte Systemmutex erstellt wurde. Der Wert ist <see langword="false" />, wenn der angegebene benannte Systemmutex bereits vorhanden war. Dieser Parameter wird nicht initialisiert übergeben.</param>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named mutex exists and has access control security, but the user does not have &lt;see cref=&quot;F:System.Security.AccessControl.MutexRights.FullControl&quot; /&gt;.">Das benannte Mutex ist vorhanden und verfügt über Zugriffssteuerungssicherheit, aber der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Win32-Fehler.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be created. A synchronization object of a different type might have the same name.">Das benannte Mutex kann nicht erstellt werden, möglicherweise weil ein Wait-Handle eines anderen Typs denselben Namen hat.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&#xA;          .NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="name" /> ist länger als 260 Zeichen.</exception>
    </member>
    <member name="M:System.Threading.Mutex.OpenExisting(System.String)">
      <summary vsli:raw="Opens the specified named mutex, if it already exists.">Öffnet den bestimmten benannten Mutex, wenn er bereits vorhanden ist.</summary>
      <param name="name" vsli:raw="The name of the synchronization object to be shared with other processes. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">Der Name des zu öffnenden Systemmutex.</param>
      <returns vsli:raw="An object that represents the named system mutex.">Ein Objekt, das den benannten Systemmutex darstellt.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is an empty string.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="name" /> ist eine leere Zeichenfolge.  

oder - 
<paramref name="name" /> ist länger als 260 Zeichen.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be created. A synchronization object of a different type might have the same name. In some cases, this exception may be thrown for invalid names.">Der benannte Mutex ist nicht vorhanden.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Win32-Fehler.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named mutex exists, but the user does not have the security access required to use it.">Das benannte Mutex ist vorhanden, aber der Benutzer verfügt nicht über den Sicherheitszugriff, der für die Verwendung erforderlich ist.</exception>
    </member>
    <member name="M:System.Threading.Mutex.ReleaseMutex">
      <summary vsli:raw="Releases the &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; once.">Gibt das <see cref="T:System.Threading.Mutex" /> einmal frei.</summary>
      <exception cref="T:System.ApplicationException" vsli:raw="The calling thread does not own the mutex.">Der aufrufende Thread besitzt den Mutex nicht.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Die aktuelle Instanz wurde bereits verworfen.</exception>
    </member>
    <member name="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
      <summary vsli:raw="Opens the specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.">Öffnet den bestimmten benannten Mutex, wenn er bereits vorhanden ist, und gibt einen Wert zurück, der angibt, ob der Vorgang erfolgreich war.</summary>
      <param name="name" vsli:raw="The name of the synchronization object to be shared with other processes. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">Der Name des zu öffnenden Systemmutex.</param>
      <param name="result" vsli:raw="When this method returns, contains a &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that represents the named mutex if the call succeeded, or &lt;see langword=&quot;null&quot; /&gt; if the call failed. This parameter is treated as uninitialized.">Enthält nach Beenden der Methode ein <see cref="T:System.Threading.Mutex" />-Objekt, das das benannte Mutex darstellt, wenn der Aufruf erfolgreich ausgeführt wurde, oder <see langword="null" />, wenn der Aufruf fehlgeschlagen ist. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the named mutex was opened successfully; otherwise, &lt;see langword=&quot;false&quot; /&gt;. In some cases, &lt;see langword=&quot;false&quot; /&gt; may be returned for invalid names.">
        <see langword="true" />, wenn der benannte Mutex erfolgreich geöffnet wurde; andernfalls <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is an empty string.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="name" /> ist eine leere Zeichenfolge.  

oder - 
<paramref name="name" /> ist länger als 260 Zeichen.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive. For some invalid names, the method may return &lt;see langword=&quot;false&quot; /&gt; instead.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Win32-Fehler.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named mutex exists, but the user does not have the security access required to use it.">Das benannte Mutex ist vorhanden, aber der Benutzer verfügt nicht über den Sicherheitszugriff, der für die Verwendung erforderlich ist.</exception>
    </member>
    <member name="T:System.Threading.ReaderWriterLock">
      <summary vsli:raw="Defines a lock that supports single writers and multiple readers.">Definiert eine Sperre, die einen Writer und mehrere Reader unterstützt.</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.ReaderWriterLock&quot; /&gt; class.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.ReaderWriterLock" />-Klasse.</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)">
      <summary vsli:raw="Acquires a reader lock, using an &lt;see cref=&quot;T:System.Int32&quot; /&gt; value for the time-out.">Erhält eine Lesesperre unter Verwendung eines <see cref="T:System.Int32" />-Werts für das Timeout.</summary>
      <param name="millisecondsTimeout" vsli:raw="The time-out in milliseconds.">Das Timeout in Millisekunden.</param>
      <exception cref="T:System.ApplicationException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; expires before the lock request is granted.">
        <paramref name="millisecondsTimeout" /> läuft ab, bevor die Sperranforderung erteilt wird.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)">
      <summary vsli:raw="Acquires a reader lock, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; value for the time-out.">Erhält eine Lesesperre unter Verwendung eines <see cref="T:System.TimeSpan" />-Werts für das Timeout.</summary>
      <param name="timeout" vsli:raw="A &lt;see langword=&quot;TimeSpan&quot; /&gt; specifying the time-out period.">Eine <see langword="TimeSpan" />, die den Timeout-Zeitraum angibt.</param>
      <exception cref="T:System.ApplicationException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; expires before the lock request is granted.">
        <paramref name="timeout" /> läuft ab, bevor die Sperranforderung erteilt wird.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; specifies a negative value other than -1 milliseconds.">
        <paramref name="timeout" /> gibt einen negativen Wert ungleich -1 Millisekunden an.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)">
      <summary vsli:raw="Acquires the writer lock, using an &lt;see cref=&quot;T:System.Int32&quot; /&gt; value for the time-out.">Erhält die Schreibsperre unter Verwendung eines <see cref="T:System.Int32" />-Werts für das Timeout.</summary>
      <param name="millisecondsTimeout" vsli:raw="The time-out in milliseconds.">Das Timeout in Millisekunden.</param>
      <exception cref="T:System.ApplicationException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; expires before the lock request is granted.">
        <paramref name="timeout" /> läuft ab, bevor die Sperranforderung erteilt wird.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)">
      <summary vsli:raw="Acquires the writer lock, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; value for the time-out.">Erhält die Schreibsperre unter Verwendung eines <see cref="T:System.TimeSpan" />-Werts für das Timeout.</summary>
      <param name="timeout" vsli:raw="The &lt;see langword=&quot;TimeSpan&quot; /&gt; specifying the time-out period.">Die <see langword="TimeSpan" />, die den Timeout-Zeitraum angibt.</param>
      <exception cref="T:System.ApplicationException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; expires before the lock request is granted.">
        <paramref name="timeout" /> läuft ab, bevor die Sperranforderung erteilt wird.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; specifies a negative value other than -1 milliseconds.">
        <paramref name="timeout" /> gibt einen negativen Wert ungleich -1 Millisekunden an.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)">
      <summary vsli:raw="Indicates whether the writer lock has been granted to any thread since the sequence number was obtained.">Gibt an, ob einem Thread die Schreibsperre erteilt wurde, seitdem die Sequenznummer erhalten wurde.</summary>
      <param name="seqNum" vsli:raw="The sequence number.">Die Sequenznummer.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the writer lock has been granted to any thread since the sequence number was obtained; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn einem Thread die Schreibsperre erteilt wurde, seitdem die Sequenznummer erhalten wurde, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)">
      <summary vsli:raw="Restores the lock status of the thread to what it was before &lt;see cref=&quot;M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)&quot; /&gt; was called.">Stellt den Sperrstatus des Threads mit dem Status vor dem Aufruf von <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" /> wieder her.</summary>
      <param name="lockCookie" vsli:raw="A &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; returned by &lt;see cref=&quot;M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)&quot; /&gt;.">Eine von <see cref="T:System.Threading.LockCookie" /> zurückgegebene <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" />-Struktur.</param>
      <exception cref="T:System.ApplicationException" vsli:raw="The thread does not have the writer lock.">Der Thread verfügt nicht über die Schreibsperre.</exception>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;lockCookie&quot; /&gt; is a null pointer.">Die Adresse von <paramref name="lockCookie" /> ist ein NULL-Zeiger.</exception>
    </member>
    <member name="P:System.Threading.ReaderWriterLock.IsReaderLockHeld">
      <summary vsli:raw="Gets a value indicating whether the current thread holds a reader lock.">Ruft einen Wert ab, der angibt, ob der aktuelle Thread eine Lesesperre besitzt.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread holds a reader lock; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der aktuelle Thread eine Lesesperre aufweist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLock.IsWriterLockHeld">
      <summary vsli:raw="Gets a value indicating whether the current thread holds the writer lock.">Ruft einen Wert ab, der angibt, ob der aktuelle Thread die Schreibsperre enthält.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread holds the writer lock; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der aktuelle Thread die Schreibsperre enthält, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.ReleaseLock">
      <summary vsli:raw="Releases the lock, regardless of the number of times the thread acquired the lock.">Hebt die Sperre unabhängig davon auf, wie oft dem Thread die Sperre zugewiesen wurde.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; value representing the released lock.">Ein <see cref="T:System.Threading.LockCookie" />-Wert, der die aufgehobene Sperre darstellt.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.ReleaseReaderLock">
      <summary vsli:raw="Decrements the lock count.">Verringert die Sperrenanzahl.</summary>
      <exception cref="T:System.ApplicationException" vsli:raw="The thread does not have any reader or writer locks.">Der Thread verfügt weder über Lese- noch über Schreibsperren.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.ReleaseWriterLock">
      <summary vsli:raw="Decrements the lock count on the writer lock.">Verringert die Sperrenanzahl für die Schreibsperre.</summary>
      <exception cref="T:System.ApplicationException" vsli:raw="The thread does not have the writer lock.">Der Thread verfügt nicht über die Schreibsperre.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)">
      <summary vsli:raw="Restores the lock status of the thread to what it was before calling &lt;see cref=&quot;M:System.Threading.ReaderWriterLock.ReleaseLock&quot; /&gt;.">Stellt den Sperrstatus des Threads mit dem Status vor dem Aufruf von <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" /> wieder her.</summary>
      <param name="lockCookie" vsli:raw="A &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; returned by &lt;see cref=&quot;M:System.Threading.ReaderWriterLock.ReleaseLock&quot; /&gt;.">Eine von <see cref="T:System.Threading.LockCookie" /> zurückgegebene <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" />-Struktur.</param>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;lockCookie&quot; /&gt; is a null pointer.">Die Adresse von <paramref name="lockCookie" /> ist ein NULL-Zeiger.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)">
      <summary vsli:raw="Upgrades a reader lock to the writer lock, using an &lt;see cref=&quot;T:System.Int32&quot; /&gt; value for the time-out.">Wandelt eine Lesesperre unter Verwendung eines <see langword="Int32" />-Werts für das Timeout in eine Schreibsperre um.</summary>
      <param name="millisecondsTimeout" vsli:raw="The time-out in milliseconds.">Das Timeout in Millisekunden.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; value.">Ein <see cref="T:System.Threading.LockCookie" />-Wert.</returns>
      <exception cref="T:System.ApplicationException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; expires before the lock request is granted.">
        <paramref name="millisecondsTimeout" /> läuft ab, bevor die Sperranforderung erteilt wird.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)">
      <summary vsli:raw="Upgrades a reader lock to the writer lock, using a &lt;see langword=&quot;TimeSpan&quot; /&gt; value for the time-out.">Wandelt eine Lesesperre unter Verwendung eines <see langword="TimeSpan" />-Werts für das Timeout in eine Schreibsperre um.</summary>
      <param name="timeout" vsli:raw="The &lt;see langword=&quot;TimeSpan&quot; /&gt; specifying the time-out period.">Die <see langword="TimeSpan" />, die den Timeout-Zeitraum angibt.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; value.">Ein <see cref="T:System.Threading.LockCookie" />-Wert.</returns>
      <exception cref="T:System.ApplicationException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; expires before the lock request is granted.">
        <paramref name="timeout" /> läuft ab, bevor die Sperranforderung erteilt wird.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; specifies a negative value other than -1 milliseconds.">
        <paramref name="timeout" /> gibt einen negativen Wert ungleich -1 Millisekunden an.</exception>
    </member>
    <member name="P:System.Threading.ReaderWriterLock.WriterSeqNum">
      <summary vsli:raw="Gets the current sequence number.">Ruft die aktuelle Sequenznummer ab.</summary>
      <returns vsli:raw="The current sequence number.">Die aktuelle Sequenznummer.</returns>
    </member>
    <member name="T:System.Threading.ReaderWriterLockSlim">
      <summary vsli:raw="Represents a lock that is used to manage access to a resource, allowing multiple threads for reading or exclusive access for writing.">Stellt eine Sperre dar, mit der der Zugriff auf eine Ressource verwaltet wird. Mehrere Threads können hierbei Lesezugriff oder exklusiven Schreibzugriff erhalten.</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; class with default property values.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.ReaderWriterLockSlim" />-Klasse mit Standardeigenschaftswerten.</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; class, specifying the lock recursion policy.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.ReaderWriterLockSlim" />-Klasse unter Angabe der Rekursionsrichtlinie für die Sperre.</summary>
      <param name="recursionPolicy" vsli:raw="One of the enumeration values that specifies the lock recursion policy.">Einer der Enumerationswerte, der die Rekursionsrichtlinie für die Sperre angibt.</param>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
      <summary vsli:raw="Gets the total number of unique threads that have entered the lock in read mode.">Ruft die Gesamtzahl von eindeutigen Threads ab, denen die Sperre im Lesemodus zugewiesen ist.</summary>
      <returns vsli:raw="The number of unique threads that have entered the lock in read mode.">Die Anzahl von eindeutigen Threads, denen die Sperre im Lesemodus zugewiesen ist.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; class.">Gibt alle von der aktuellen Instanz der <see cref="T:System.Threading.ReaderWriterLockSlim" />-Klasse verwendeten Ressourcen frei.</summary>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="&lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.WaitingReadCount&quot; /&gt; is greater than zero.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount&quot; /&gt; is greater than zero.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount&quot; /&gt; is greater than zero.">
        <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /> ist größer als 0 (null).  

oder - 
<see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /> ist größer als 0 (null).  

oder - 
<see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /> ist größer als 0 (null).</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
      <summary vsli:raw="Tries to enter the lock in read mode.">Versucht, die Sperre im Lesemodus zu erhalten.</summary>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt;, and the current thread has attempted to acquire the read lock when it already holds the read lock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt;, and the current thread has attempted to acquire the read lock when it already holds the write lock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. This limit is so large that applications should never encounter this exception.">Die <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />-Eigenschaft ist gleich <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, und der aktuelle Thread hat versucht, die Lesesperre zu erlangen, obwohl er die Lesesperre bereits besitzt.  

oder - 
Die <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />-Eigenschaft ist gleich <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, und der aktuelle Thread hat versucht, die Lesesperre zu erlangen, obwohl er die Schreibsperre bereits besitzt.  

oder - 
Die Rekursionszahl würde die Kapazität des Zählers übersteigen. Dieser Grenzwert ist so groß, dass diese Ausnahme nie für Anwendungen auftreten sollte.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">Das <see cref="T:System.Threading.ReaderWriterLockSlim" />-Objekt wurde verworfen.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
      <summary vsli:raw="Tries to enter the lock in upgradeable mode.">Versucht, die Sperre im erweiterbaren Modus zu erhalten.</summary>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt; and the current thread has already entered the lock in any mode.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current thread has entered read mode, so trying to enter upgradeable mode would create the possibility of a deadlock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.">Die <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />-Eigenschaft ist <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, und dem aktuellen Thread wurde die Sperre bereits in einem der Modi zugewiesen.  

oder - 
Der aktuelle Thread befindet sich im Lesemodus, sodass durch eine Zuweisung des erweiterbaren Modus die Möglichkeit eines Deadlocks entstehen würde.  

oder - 
Die Rekursionszahl würde die Kapazität des Zählers übersteigen. Die Kapazität ist so groß, dass Anwendungen diese Grenze niemals erreichen dürften.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">Das <see cref="T:System.Threading.ReaderWriterLockSlim" />-Objekt wurde verworfen.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
      <summary vsli:raw="Tries to enter the lock in write mode.">Versucht, die Sperre im Schreibmodus zu erhalten.</summary>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt; and the current thread has already entered the lock in any mode.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current thread has entered read mode and doesn't already own a write lock, so trying to enter the lock in write mode would create the possibility of a deadlock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.">Die <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />-Eigenschaft ist <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, und dem aktuellen Thread wurde die Sperre bereits in einem der Modi zugewiesen.  

oder - 
Der aktuelle Thread befindet sich im Lesemodus und besitzt noch keine Schreibsperre, sodass durch eine Zuweisung des Schreibmodus die Möglichkeit eines Deadlocks entstehen würde.  

oder - 
Die Rekursionszahl würde die Kapazität des Zählers übersteigen. Die Kapazität ist so groß, dass Anwendungen diese Grenze niemals erreichen dürften.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">Das <see cref="T:System.Threading.ReaderWriterLockSlim" />-Objekt wurde verworfen.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
      <summary vsli:raw="Reduces the recursion count for read mode, and exits read mode if the resulting count is 0 (zero).">Verringert die Rekursionszahl für den Lesemodus oder beendet den Lesemodus, wenn das Rekursionsergebnis 0 (null) ist.</summary>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The current thread has not entered the lock in read mode.">Der aktuelle Thread befindet sich nicht im Lesemodus.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
      <summary vsli:raw="Reduces the recursion count for upgradeable mode, and exits upgradeable mode if the resulting count is 0 (zero).">Verringert die Rekursionszahl für den erweiterbaren Modus oder beendet den erweiterbaren Modus, wenn das Rekursionsergebnis 0 (null) ist.</summary>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The current thread has not entered the lock in upgradeable mode.">Der aktuelle Thread befindet sich nicht im erweiterbaren Modus.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
      <summary vsli:raw="Reduces the recursion count for write mode, and exits write mode if the resulting count is 0 (zero).">Verringert die Rekursionszahl für den Schreibmodus oder beendet den Schreibmodus, wenn das Rekursionsergebnis 0 (null) ist.</summary>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The current thread has not entered the lock in write mode.">Der aktuelle Thread befindet sich nicht im Schreibmodus.</exception>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld">
      <summary vsli:raw="Gets a value that indicates whether the current thread has entered the lock in read mode.">Ruft einen Wert ab, der angibt, ob die Sperre dem aktuellen Thread im Lesemodus zugewiesen ist.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread has entered read mode; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn sich der aktuelle Thread im Lesemodus befindet, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld">
      <summary vsli:raw="Gets a value that indicates whether the current thread has entered the lock in upgradeable mode.">Ruft einen Wert ab, der angibt, ob die Sperre dem aktuellen Thread im erweiterbaren Modus zugewiesen ist.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread has entered upgradeable mode; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn sich der aktuelle Thread im erweiterbaren Modus befindet, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld">
      <summary vsli:raw="Gets a value that indicates whether the current thread has entered the lock in write mode.">Ruft einen Wert ab, der angibt, ob die Sperre dem aktuellen Thread im Schreibmodus zugewiesen ist.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread has entered write mode; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn sich der aktuelle Thread im Schreibmodus befindet, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy">
      <summary vsli:raw="Gets a value that indicates the recursion policy for the current &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object.">Ruft einen Wert ab, der die Rekursionsrichtlinie für das aktuelle <see cref="T:System.Threading.ReaderWriterLockSlim" />-Objekt angibt.</summary>
      <returns vsli:raw="One of the enumeration values that specifies the lock recursion policy.">Einer der Enumerationswerte, der die Rekursionsrichtlinie für die Sperre angibt.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount">
      <summary vsli:raw="Gets the number of times the current thread has entered the lock in read mode, as an indication of recursion.">Ruft einen Wert ab, der als Indikator für eine Rekursion angibt, wie oft dem aktuellen Thread die Sperre im Lesemodus zugewiesen ist.</summary>
      <returns vsli:raw="0 (zero) if the current thread has not entered read mode, 1 if the thread has entered read mode but has not entered it recursively, or n if the thread has entered the lock recursively n - 1 times.">0 (null), wenn sich der aktuelle Thread nicht im Lesemodus befindet, 1, wenn der Thread in den Lesemodus gewechselt ist, ihn aber nicht rekursiv eingegeben hat, oder n , wenn der Thread die Sperre n -1 mal rekursiv eingegeben hat.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount">
      <summary vsli:raw="Gets the number of times the current thread has entered the lock in upgradeable mode, as an indication of recursion.">Ruft einen Wert ab, der als Indikator für eine Rekursion angibt, wie oft dem aktuellen Thread die Sperre im erweiterbaren Modus zugewiesen ist.</summary>
      <returns vsli:raw="0 if the current thread has not entered upgradeable mode, 1 if the thread has entered upgradeable mode but has not entered it recursively, or n if the thread has entered upgradeable mode recursively n - 1 times.">0 (null), wenn sich der aktuelle Thread nicht im erweiterbaren Modus befindet, 1, wenn sich der Thread im erweiterbaren Modus befindet, ihn aber nicht rekursiv eingegeben hat, oder n , wenn der Thread den erweiterbaren Modus n -1 mal rekursiv eingegeben hat.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount">
      <summary vsli:raw="Gets the number of times the current thread has entered the lock in write mode, as an indication of recursion.">Ruft einen Wert ab, der als Indikator für eine Rekursion angibt, wie oft dem aktuellen Thread die Sperre im Schreibmodus zugewiesen ist.</summary>
      <returns vsli:raw="0 if the current thread has not entered write mode, 1 if the thread has entered write mode but has not entered it recursively, or n if the thread has entered write mode recursively n - 1 times.">0 (null), wenn sich der aktuelle Thread nicht im Schreibmodus befindet, 1, wenn sich der Thread im Schreibmodus befindet, ihn jedoch nicht rekursiv eingegeben hat, oder n , wenn der Thread den Schreibmodus n -1 mal rekursiv eingegeben hat.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
      <summary vsli:raw="Tries to enter the lock in read mode, with an optional integer time-out.">Versucht, die Sperre im Lesemodus zu erhalten. Optional wird ein ganzzahliger Timeout berücksichtigt.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or -1 (&lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;) to wait indefinitely.">Die Zeit in Millisekunden, die gewartet wird, oder -1 (<see cref="F:System.Threading.Timeout.Infinite" />), um unbegrenzt zu warten.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the calling thread entered read mode, otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der aufrufende Thread den Lesemodus erhalten hat, andernfalls <see langword="false" />.</returns>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt; and the current thread has already entered the lock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.">Die <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />-Eigenschaft ist <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, und der aktuelle Thread hat die Sperre bereits erhalten.  

oder - 
Die Rekursionszahl würde die Kapazität des Zählers übersteigen. Die Kapazität ist so groß, dass Anwendungen diese Grenze niemals erreichen dürften.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of &lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is negative, but it is not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1), which is the only negative value allowed.">Der Wert von <paramref name="millisecondsTimeout" /> ist negativ, aber ungleich <see cref="F:System.Threading.Timeout.Infinite" /> (-1), der den einzigen zulässigen negativen Wert darstellt.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">Das <see cref="T:System.Threading.ReaderWriterLockSlim" />-Objekt wurde verworfen.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
      <summary vsli:raw="Tries to enter the lock in read mode, with an optional time-out.">Versucht, die Sperre im Lesemodus zu erhalten. Optional wird ein Timeout berücksichtigt.</summary>
      <param name="timeout" vsli:raw="The interval to wait, or -1 milliseconds to wait indefinitely.">Der Zeitintervall bis zum Timeout, oder -1 Millisekunden, um unbegrenzt zu warten.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the calling thread entered read mode, otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der aufrufende Thread den Lesemodus erhalten hat, andernfalls <see langword="false" />.</returns>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt; and the current thread has already entered the lock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.">Die <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />-Eigenschaft ist <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, und der aktuelle Thread hat die Sperre bereits erhalten.  

oder - 
Die Rekursionszahl würde die Kapazität des Zählers übersteigen. Die Kapazität ist so groß, dass Anwendungen diese Grenze niemals erreichen dürften.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of &lt;paramref name=&quot;timeout&quot; /&gt; is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.  &#xA;  &#xA; -or-  &#xA;  &#xA; The value of &lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt; milliseconds.">Der Wert von <paramref name="timeout" /> ist negativ, aber ungleich -1 Millisekunden. (Dies ist der einzige zulässige negative Wert.)  

oder - 
Der Wert von <paramref name="timeout" /> ist größer als <see cref="F:System.Int32.MaxValue" /> Millisekunden.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">Das <see cref="T:System.Threading.ReaderWriterLockSlim" />-Objekt wurde verworfen.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
      <summary vsli:raw="Tries to enter the lock in upgradeable mode, with an optional time-out.">Versucht, die Sperre im erweiterbaren Modus zu erhalten. Optional wird ein Timeout berücksichtigt.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or -1 (&lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;) to wait indefinitely.">Die Zeit in Millisekunden, die gewartet wird, oder -1 (<see cref="F:System.Threading.Timeout.Infinite" />), um unbegrenzt zu warten.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the calling thread entered upgradeable mode, otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der aufrufende Thread den erweiterbaren Modus erhalten hat, andernfalls <see langword="false" />.</returns>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt; and the current thread has already entered the lock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.">Die <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />-Eigenschaft ist <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, und der aktuelle Thread hat die Sperre bereits erhalten.  

oder - 
Der aktuelle Thread befindet sich bereits im Lesemodus, sodass durch eine Zuweisung des erweiterbaren Modus die Möglichkeit eines Deadlocks entstehen würde.  

oder - 
Die Rekursionszahl würde die Kapazität des Zählers übersteigen. Die Kapazität ist so groß, dass Anwendungen diese Grenze niemals erreichen dürften.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of &lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is negative, but it is not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1), which is the only negative value allowed.">Der Wert von <paramref name="millisecondsTimeout" /> ist negativ, aber ungleich <see cref="F:System.Threading.Timeout.Infinite" /> (-1), der den einzigen zulässigen negativen Wert darstellt.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">Das <see cref="T:System.Threading.ReaderWriterLockSlim" />-Objekt wurde verworfen.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
      <summary vsli:raw="Tries to enter the lock in upgradeable mode, with an optional time-out.">Versucht, die Sperre im erweiterbaren Modus zu erhalten. Optional wird ein Timeout berücksichtigt.</summary>
      <param name="timeout" vsli:raw="The interval to wait, or -1 milliseconds to wait indefinitely.">Der Zeitintervall bis zum Timeout, oder -1 Millisekunden, um unbegrenzt zu warten.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the calling thread entered upgradeable mode, otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der aufrufende Thread den erweiterbaren Modus erhalten hat, andernfalls <see langword="false" />.</returns>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt; and the current thread has already entered the lock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.">Die <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />-Eigenschaft ist <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, und der aktuelle Thread hat die Sperre bereits erhalten.  

oder - 
Der aktuelle Thread befindet sich bereits im Lesemodus, sodass durch eine Zuweisung des erweiterbaren Modus die Möglichkeit eines Deadlocks entstehen würde.  

oder - 
Die Rekursionszahl würde die Kapazität des Zählers übersteigen. Die Kapazität ist so groß, dass Anwendungen diese Grenze niemals erreichen dürften.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of &lt;paramref name=&quot;timeout&quot; /&gt; is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.  &#xA;  &#xA; -or-  &#xA;  &#xA; The value of &lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt; milliseconds.">Der Wert von <paramref name="timeout" /> ist negativ, aber ungleich -1 Millisekunden. (Dies ist der einzige zulässige negative Wert.)  

oder - 
Der Wert von <paramref name="timeout" /> ist größer als <see cref="F:System.Int32.MaxValue" /> Millisekunden.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">Das <see cref="T:System.Threading.ReaderWriterLockSlim" />-Objekt wurde verworfen.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
      <summary vsli:raw="Tries to enter the lock in write mode, with an optional time-out.">Versucht, die Sperre im Schreibmodus zu erhalten. Optional wird ein Timeout berücksichtigt.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or -1 (&lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;) to wait indefinitely.">Die Zeit in Millisekunden, die gewartet wird, oder -1 (<see cref="F:System.Threading.Timeout.Infinite" />), um unbegrenzt zu warten.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the calling thread entered write mode, otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der aufrufende Thread den Schreibmodus erhalten hat, andernfalls <see langword="false" />.</returns>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt; and the current thread has already entered the lock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.">Die <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />-Eigenschaft ist <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, und der aktuelle Thread hat die Sperre bereits erhalten.  

oder - 
Der aktuelle Thread befindet sich bereits im Lesemodus, sodass durch eine Zuweisung des Schreibmodus die Möglichkeit eines Deadlocks entstehen würde.  

oder - 
Die Rekursionszahl würde die Kapazität des Zählers übersteigen. Die Kapazität ist so groß, dass Anwendungen diese Grenze niemals erreichen dürften.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of &lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is negative, but it is not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1), which is the only negative value allowed.">Der Wert von <paramref name="millisecondsTimeout" /> ist negativ, aber ungleich <see cref="F:System.Threading.Timeout.Infinite" /> (-1), der den einzigen zulässigen negativen Wert darstellt.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">Das <see cref="T:System.Threading.ReaderWriterLockSlim" />-Objekt wurde verworfen.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
      <summary vsli:raw="Tries to enter the lock in write mode, with an optional time-out.">Versucht, die Sperre im Schreibmodus zu erhalten. Optional wird ein Timeout berücksichtigt.</summary>
      <param name="timeout" vsli:raw="The interval to wait, or -1 milliseconds to wait indefinitely.">Der Zeitintervall bis zum Timeout, oder -1 Millisekunden, um unbegrenzt zu warten.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the calling thread entered write mode, otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der aufrufende Thread den Schreibmodus erhalten hat, andernfalls <see langword="false" />.</returns>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt; and the current thread has already entered the lock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.">Die <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />-Eigenschaft ist <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, und der aktuelle Thread hat die Sperre bereits erhalten.  

oder - 
Der aktuelle Thread befindet sich bereits im Lesemodus, sodass durch eine Zuweisung des Schreibmodus die Möglichkeit eines Deadlocks entstehen würde.  

oder - 
Die Rekursionszahl würde die Kapazität des Zählers übersteigen. Die Kapazität ist so groß, dass Anwendungen diese Grenze niemals erreichen dürften.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of &lt;paramref name=&quot;timeout&quot; /&gt; is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.  &#xA;  &#xA; -or-  &#xA;  &#xA; The value of &lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt; milliseconds.">Der Wert von <paramref name="timeout" /> ist negativ, aber ungleich -1 Millisekunden. (Dies ist der einzige zulässige negative Wert.)  

oder - 
Der Wert von <paramref name="timeout" /> ist größer als <see cref="F:System.Int32.MaxValue" /> Millisekunden.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">Das <see cref="T:System.Threading.ReaderWriterLockSlim" />-Objekt wurde verworfen.</exception>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount">
      <summary vsli:raw="Gets the total number of threads that are waiting to enter the lock in read mode.">Ruft die Gesamtzahl von Threads ab, die auf eine Zuweisung des Lesemodus warten.</summary>
      <returns vsli:raw="The total number of threads that are waiting to enter read mode.">Die Gesamtzahl von Threads, die auf eine Zuweisung des Lesemodus warten.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount">
      <summary vsli:raw="Gets the total number of threads that are waiting to enter the lock in upgradeable mode.">Ruft die Gesamtzahl von Threads ab, die auf eine Zuweisung des erweiterbaren Modus warten.</summary>
      <returns vsli:raw="The total number of threads that are waiting to enter upgradeable mode.">Die Gesamtzahl von Threads, die auf eine Zuweisung des erweiterbaren Modus warten.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount">
      <summary vsli:raw="Gets the total number of threads that are waiting to enter the lock in write mode.">Ruft die Gesamtzahl von Threads ab, die auf eine Zuweisung des Schreibmodus warten.</summary>
      <returns vsli:raw="The total number of threads that are waiting to enter write mode.">Die Gesamtzahl von Threads, die auf eine Zuweisung des Schreibmodus warten.</returns>
    </member>
    <member name="T:System.Threading.Semaphore">
      <summary vsli:raw="Limits the number of threads that can access a resource or pool of resources concurrently.">Schränkt die Anzahl von Threads ein, die gleichzeitig auf eine Ressource oder einen Pool von Ressourcen zugreifen können.</summary>
    </member>
    <member name="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Semaphore&quot; /&gt; class, specifying the initial number of entries and the maximum number of concurrent entries.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.Semaphore" />-Klasse und gibt die ursprüngliche Anzahl von Einträgen und die maximale Anzahl von gleichzeitigen Einträgen an.</summary>
      <param name="initialCount" vsli:raw="The initial number of requests for the semaphore that can be granted concurrently.">Die anfängliche Anzahl von Anforderungen für das Semaphor, die gleichzeitig gewährt werden können.</param>
      <param name="maximumCount" vsli:raw="The maximum number of requests for the semaphore that can be granted concurrently.">Die maximale Anzahl von Anforderungen für das Semaphor, die gleichzeitig gewährt werden können.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;initialCount&quot; /&gt; is greater than &lt;paramref name=&quot;maximumCount&quot; /&gt;.">
        <paramref name="initialCount" /> ist größer als <paramref name="maximumCount" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;maximumCount&quot; /&gt; is less than 1.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;initialCount&quot; /&gt; is less than 0.">
        <paramref name="maximumCount" /> ist kleiner als 1.  

oder - 
<paramref name="initialCount" /> ist kleiner als 0.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Semaphore&quot; /&gt; class, specifying the initial number of entries and the maximum number of concurrent entries, and optionally specifying the name of a system semaphore object.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.Semaphore" />-Klasse, gibt die ursprüngliche Anzahl von Einträgen und die maximale Anzahl von gleichzeitigen Einträgen sowie optional den Namen eines Systemsemaphorobjekts an.</summary>
      <param name="initialCount" vsli:raw="The initial number of requests for the semaphore that can be granted concurrently.">Die anfängliche Anzahl von Anforderungen für das Semaphor, die gleichzeitig gewährt werden können.</param>
      <param name="maximumCount" vsli:raw="The maximum number of requests for the semaphore that can be granted concurrently.">Die maximale Anzahl von Anforderungen für das Semaphor, die gleichzeitig gewährt werden können.</param>
      <param name="name" vsli:raw="The name, if the synchronization object is to be shared with other processes; otherwise, &lt;see langword=&quot;null&quot; /&gt; or an empty string. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">Der Name eines benannten Systemsemaphorobjekts.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;initialCount&quot; /&gt; is greater than &lt;paramref name=&quot;maximumCount&quot; /&gt;.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="initialCount" /> ist größer als <paramref name="maximumCount" />.  

oder - 
<paramref name="name" /> ist länger als 260 Zeichen.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;maximumCount&quot; /&gt; is less than 1.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;initialCount&quot; /&gt; is less than 0.">
        <paramref name="maximumCount" /> ist kleiner als 1.  

oder - 
<paramref name="initialCount" /> ist kleiner als 0.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Win32-Fehler.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named semaphore exists and has access control security, and the user does not have &lt;see cref=&quot;F:System.Security.AccessControl.SemaphoreRights.FullControl&quot; /&gt;.">Der benannte Semaphor ist vorhanden und verfügt über Zugriffssteuerungssicherheit, und der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be created. A synchronization object of a different type might have the same name.">Der benannte Semaphor kann nicht erstellt werden, möglicherweise, weil ein Wait-Handle eines anderen Typs den gleichen Namen hat.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Semaphore&quot; /&gt; class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, and specifying a variable that receives a value indicating whether a new system semaphore was created.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.Semaphore" />-Klasse, gibt die ursprüngliche Anzahl von Einträgen und die maximale Anzahl von gleichzeitigen Einträgen sowie optional den Namen eines Systemsemaphorobjekts an, gibt eine Variable an, die einen Wert empfängt, der angibt, ob ein neues Systemsemaphor erstellt wurde.</summary>
      <param name="initialCount" vsli:raw="The initial number of requests for the semaphore that can be satisfied concurrently.">Die ursprüngliche Anzahl von Anforderungen für das Semaphor, die gleichzeitig ausgeführt werden können.</param>
      <param name="maximumCount" vsli:raw="The maximum number of requests for the semaphore that can be satisfied concurrently.">Die maximale Anzahl von Anforderungen für das Semaphor, die gleichzeitig ausgeführt werden können.</param>
      <param name="name" vsli:raw="The name, if the synchronization object is to be shared with other processes; otherwise, &lt;see langword=&quot;null&quot; /&gt; or an empty string. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">Der Name eines benannten Systemsemaphorobjekts.</param>
      <param name="createdNew" vsli:raw="When this method returns, contains &lt;see langword=&quot;true&quot; /&gt; if a local semaphore was created (that is, if &lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; or an empty string) or if the specified named system semaphore was created; &lt;see langword=&quot;false&quot; /&gt; if the specified named system semaphore already existed. This parameter is passed uninitialized.">Enthält nach dem Beenden dieser Methode den Wert <see langword="true" />, wenn ein lokales Semaphor erstellt wurde (d. h., wenn <paramref name="name" /> gleich <see langword="null" /> oder eine leere Zeichenfolge ist) oder wenn das angegebene benannte Systemsemaphor erstellt wurde. Der Wert ist <see langword="false" />, wenn das angegebene benannte Systemsemaphor bereits vorhanden war. Dieser Parameter wird nicht initialisiert übergeben.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;initialCount&quot; /&gt; is greater than &lt;paramref name=&quot;maximumCount&quot; /&gt;.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="initialCount" /> ist größer als <paramref name="maximumCount" />.  

oder - 
<paramref name="name" /> ist länger als 260 Zeichen.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;maximumCount&quot; /&gt; is less than 1.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;initialCount&quot; /&gt; is less than 0.">
        <paramref name="maximumCount" /> ist kleiner als 1.  

oder - 
<paramref name="initialCount" /> ist kleiner als 0.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Win32-Fehler.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named semaphore exists and has access control security, and the user does not have &lt;see cref=&quot;F:System.Security.AccessControl.SemaphoreRights.FullControl&quot; /&gt;.">Der benannte Semaphor ist vorhanden und verfügt über Zugriffssteuerungssicherheit, und der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be created. A synchronization object of a different type might have the same name.">Der benannte Semaphor kann nicht erstellt werden, möglicherweise, weil ein Wait-Handle eines anderen Typs den gleichen Namen hat.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.OpenExisting(System.String)">
      <summary vsli:raw="Opens the specified named semaphore, if it already exists.">Öffnet die bestimmte benannte Semaphore, wenn sie bereits vorhanden ist.</summary>
      <param name="name" vsli:raw="The name of the synchronization object to be shared with other processes. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">Der Name des zu öffnenden Systemsemaphors.</param>
      <returns vsli:raw="An object that represents the named system semaphore.">Ein Objekt, das das benannte Systemsemaphor darstellt.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is an empty string.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="name" /> ist eine leere Zeichenfolge.  

oder - 
<paramref name="name" /> ist länger als 260 Zeichen.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be created. A synchronization object of a different type might have the same name. In some cases, this exception may be thrown for invalid names.">Das benannte Semaphor ist nicht vorhanden.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Win32-Fehler.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named semaphore exists, but the user does not have the security access required to use it.">Der benannte Semaphor ist vorhanden, aber der Benutzer verfügt nicht über den Sicherheitszugriff, der für die Verwendung erforderlich ist.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.Release">
      <summary vsli:raw="Exits the semaphore and returns the previous count.">Beendet das Semaphor und gibt die vorherige Anzahl zurück.</summary>
      <returns vsli:raw="The count on the semaphore before the &lt;see cref=&quot;Overload:System.Threading.Semaphore.Release&quot; /&gt; method was called.">Die Anzahl für das Semaphor vor dem Aufruf der <see cref="Overload:System.Threading.Semaphore.Release" />-Methode.</returns>
      <exception cref="T:System.Threading.SemaphoreFullException" vsli:raw="The semaphore count is already at the maximum value.">Die Anzahl für das Semaphor weist bereits den maximalen Wert auf.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="A Win32 error occurred with a named semaphore.">Bei einem benannten Semaphor ist ein Win32-Fehler aufgetreten.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The current semaphore represents a named system semaphore, but the user does not have &lt;see cref=&quot;F:System.Security.AccessControl.SemaphoreRights.Modify&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current semaphore represents a named system semaphore, but it was not opened with &lt;see cref=&quot;F:System.Security.AccessControl.SemaphoreRights.Modify&quot; /&gt;.">Das aktuelle Semaphor stellt ein benanntes Systemsemaphor dar. Der Benutzer verfügt jedoch nicht über <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.  

oder - 
Das aktuelle Semaphor stellt ein benanntes Systemsemaphor dar, es wurde jedoch nicht mit <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> geöffnet.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.Release(System.Int32)">
      <summary vsli:raw="Exits the semaphore a specified number of times and returns the previous count.">Gibt das Semaphor eine festgelegte Anzahl von Malen frei und gibt den vorherigen Zähler zurück.</summary>
      <param name="releaseCount" vsli:raw="The number of times to exit the semaphore.">Die Anzahl von Malen, die das Semaphor freigegeben werden soll.</param>
      <returns vsli:raw="The count on the semaphore before the &lt;see cref=&quot;Overload:System.Threading.Semaphore.Release&quot; /&gt; method was called.">Die Anzahl für das Semaphor vor dem Aufruf der <see cref="Overload:System.Threading.Semaphore.Release" />-Methode.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;releaseCount&quot; /&gt; is less than 1.">
        <paramref name="releaseCount" /> ist kleiner als 1.</exception>
      <exception cref="T:System.Threading.SemaphoreFullException" vsli:raw="The semaphore count is already at the maximum value.">Die Anzahl für das Semaphor weist bereits den maximalen Wert auf.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="A Win32 error occurred with a named semaphore.">Bei einem benannten Semaphor ist ein Win32-Fehler aufgetreten.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The current semaphore represents a named system semaphore, but the user does not have &lt;see cref=&quot;F:System.Security.AccessControl.SemaphoreRights.Modify&quot; /&gt; rights.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current semaphore represents a named system semaphore, but it was not opened with &lt;see cref=&quot;F:System.Security.AccessControl.SemaphoreRights.Modify&quot; /&gt; rights.">Das aktuelle Semaphor stellt ein benanntes Systemsemaphor dar. Der Benutzer verfügt jedoch nicht über <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />-Rechte.  

oder - 
Das aktuelle Semaphor stellt ein benanntes Systemsemaphor dar, es wurde jedoch nicht mit <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />-Rechten geöffnet.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
      <summary vsli:raw="Opens the specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.">Öffnet das angegebene benannte Semaphor, wenn es bereits vorhanden ist, und gibt einen Wert zurück, der angibt, ob der Vorgang erfolgreich war.</summary>
      <param name="name" vsli:raw="The name of the synchronization object to be shared with other processes. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">Der Name des zu öffnenden Systemsemaphors.</param>
      <param name="result" vsli:raw="When this method returns, contains a &lt;see cref=&quot;T:System.Threading.Semaphore&quot; /&gt; object that represents the named semaphore if the call succeeded, or &lt;see langword=&quot;null&quot; /&gt; if the call failed. This parameter is treated as uninitialized.">Enthält nach Beenden der Methode ein <see cref="T:System.Threading.Semaphore" />-Objekt, das das benannte Semaphor darstellt, wenn der Aufruf erfolgreich ausgeführt wurde, oder <see langword="null" />, wenn der Aufruf fehlgeschlagen ist. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the named semaphore was opened successfully; otherwise, &lt;see langword=&quot;false&quot; /&gt;. In some cases, &lt;see langword=&quot;false&quot; /&gt; may be returned for invalid names.">
        <see langword="true" />, wenn das benannte Semaphor erfolgreich geöffnet wurde; andernfalls <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is an empty string.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="name" /> ist eine leere Zeichenfolge.  

oder - 
<paramref name="name" /> ist länger als 260 Zeichen.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive. For some invalid names, the method may return &lt;see langword=&quot;false&quot; /&gt; instead.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Win32-Fehler.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named semaphore exists, but the user does not have the security access required to use it.">Der benannte Semaphor ist vorhanden, aber der Benutzer verfügt nicht über den Sicherheitszugriff, der für die Verwendung erforderlich ist.</exception>
    </member>
    <member name="T:System.Threading.SemaphoreFullException">
      <summary vsli:raw="The exception that is thrown when the &lt;see cref=&quot;Overload:System.Threading.Semaphore.Release&quot; /&gt; method is called on a semaphore whose count is already at the maximum.">Die Ausnahme, die ausgelöst wird, wenn die <see cref="Overload:System.Threading.Semaphore.Release" />-Methode für ein Semaphor aufgerufen wird, dessen Zähler bereits den Maximalwert aufweist.</summary>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SemaphoreFullException&quot; /&gt; class with default values.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.SemaphoreFullException" />-Klasse mit Standardwerten.</summary>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SemaphoreFullException&quot; /&gt; class with serialized data.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.SemaphoreFullException" />-Klasse mit serialisierten Daten.</summary>
      <param name="info" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.SerializationInfo&quot; /&gt; object that holds the serialized object data about the exception being thrown.">Das <see cref="T:System.Runtime.Serialization.SerializationInfo" />-Objekt, das die serialisierten Objektdaten für die ausgelöste Ausnahme enthält.</param>
      <param name="context" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.StreamingContext&quot; /&gt; object that contains contextual information about the source or destination.">Das <see cref="T:System.Runtime.Serialization.StreamingContext" />-Objekt, das die Kontextinformationen für die Quelle oder das Ziel enthält.</param>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor(System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SemaphoreFullException&quot; /&gt; class with a specified error message.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.SemaphoreFullException" />-Klasse mit einer angegebenen Fehlermeldung.</summary>
      <param name="message" vsli:raw="The error message that explains the reason for the exception.">Die Fehlermeldung, in der die Ursache der Ausnahme erklärt wird.</param>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor(System.String,System.Exception)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SemaphoreFullException&quot; /&gt; class with a specified error message and a reference to the inner exception that is the cause of this exception.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.SemaphoreFullException" />-Klasse mit einer angegebenen Fehlermeldung und einem Verweis auf die innere Ausnahme, die diese Ausnahme ausgelöst hat.</summary>
      <param name="message" vsli:raw="The error message that explains the reason for the exception.">Die Fehlermeldung, in der die Ursache der Ausnahme erklärt wird.</param>
      <param name="innerException" vsli:raw="The exception that is the cause of the current exception. If the &lt;paramref name=&quot;innerException&quot; /&gt; parameter is not &lt;see langword=&quot;null&quot; /&gt;, the current exception is raised in a &lt;see langword=&quot;catch&quot; /&gt; block that handles the inner exception.">Die Ausnahme, die die Ursache der aktuellen Ausnahme ist. Wenn der <paramref name="innerException" />-Parameter nicht <see langword="null" /> ist, wird die aktuelle Ausnahme in einem <see langword="catch" />-Block ausgelöst, der die innere Ausnahme behandelt.</param>
    </member>
    <member name="T:System.Threading.SemaphoreSlim">
      <summary vsli:raw="Represents a lightweight alternative to &lt;see cref=&quot;T:System.Threading.Semaphore&quot; /&gt; that limits the number of threads that can access a resource or pool of resources concurrently.">Eine einfache Alternative zu <see cref="T:System.Threading.Semaphore" />, die die Anzahl der Threads beschränkt, die gleichzeitig auf eine Ressource oder einen Ressourcenpool zugreifen können.</summary>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.#ctor(System.Int32)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; class, specifying the initial number of requests that can be granted concurrently.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.SemaphoreSlim" />-Klasse und gibt die ursprüngliche Anzahl von Anforderungen an, die gleichzeitig gewährt werden können.</summary>
      <param name="initialCount" vsli:raw="The initial number of requests for the semaphore that can be granted concurrently.">Die anfängliche Anzahl von Anforderungen für das Semaphor, die gleichzeitig gewährt werden können.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;initialCount&quot; /&gt; is less than 0.">
        <paramref name="initialCount" /> ist kleiner als 0.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.#ctor(System.Int32,System.Int32)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; class, specifying the initial and maximum number of requests that can be granted concurrently.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.SemaphoreSlim" />-Klasse und gibt die ursprüngliche sowie die maximale Anzahl von Anforderungen an, die gleichzeitig gewährt werden können.</summary>
      <param name="initialCount" vsli:raw="The initial number of requests for the semaphore that can be granted concurrently.">Die anfängliche Anzahl von Anforderungen für das Semaphor, die gleichzeitig gewährt werden können.</param>
      <param name="maxCount" vsli:raw="The maximum number of requests for the semaphore that can be granted concurrently.">Die maximale Anzahl von Anforderungen für das Semaphor, die gleichzeitig gewährt werden können.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;initialCount&quot; /&gt; is less than 0, or &lt;paramref name=&quot;initialCount&quot; /&gt; is greater than &lt;paramref name=&quot;maxCount&quot; /&gt;, or &lt;paramref name=&quot;maxCount&quot; /&gt; is equal to or less than 0.">
        <paramref name="initialCount" /> ist kleiner als 0, oder <paramref name="initialCount" /> ist größer als <paramref name="maxCount" />, oder <paramref name="maxCount" /> ist kleiner gleich 0.</exception>
    </member>
    <member name="P:System.Threading.SemaphoreSlim.AvailableWaitHandle">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Threading.WaitHandle&quot; /&gt; that can be used to wait on the semaphore.">Gibt ein <see cref="T:System.Threading.WaitHandle" /> zurück, das verwendet werden kann um auf die Semaphore zu warten.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.WaitHandle&quot; /&gt; that can be used to wait on the semaphore.">Ein <see cref="T:System.Threading.WaitHandle" />, das verwendet werden kann um auf die Semaphore zu warten.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; has been disposed.">
        <see cref="T:System.Threading.SemaphoreSlim" /> wurde verworfen.</exception>
    </member>
    <member name="P:System.Threading.SemaphoreSlim.CurrentCount">
      <summary vsli:raw="Gets the number of remaining threads that can enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; object.">Ruft die Anzahl der verbleibenden Threads ab, für die das Eintreten in das <see cref="T:System.Threading.SemaphoreSlim" />-Objekt zulässig ist.</summary>
      <returns vsli:raw="The number of remaining threads that can enter the semaphore.">Die Anzahl der verbleibenden Threads, für die das Eintreten in das Semaphor zulässig ist.</returns>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; class.">Gibt alle von der aktuellen Instanz der <see cref="T:System.Threading.SemaphoreSlim" />-Klasse verwendeten Ressourcen frei.</summary>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Dispose(System.Boolean)">
      <summary vsli:raw="Releases the unmanaged resources used by the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, and optionally releases the managed resources.">Gibt die von <see cref="T:System.Threading.SemaphoreSlim" /> verwendeten nicht verwalteten Ressourcen und optional die verwalteten Ressourcen frei.</summary>
      <param name="disposing" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to release both managed and unmanaged resources; &lt;see langword=&quot;false&quot; /&gt; to release only unmanaged resources.">
        <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Release">
      <summary vsli:raw="Releases the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; object once.">Gibt das <see cref="T:System.Threading.SemaphoreSlim" />-Objekt einmal frei.</summary>
      <returns vsli:raw="The previous count of the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;.">Die vorherige Anzahl von <see cref="T:System.Threading.SemaphoreSlim" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Die aktuelle Instanz wurde bereits verworfen.</exception>
      <exception cref="T:System.Threading.SemaphoreFullException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; has already reached its maximum size.">Der <see cref="T:System.Threading.SemaphoreSlim" /> hat bereits seine maximale Größe erreicht.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Release(System.Int32)">
      <summary vsli:raw="Releases the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; object a specified number of times.">Gibt das <see cref="T:System.Threading.SemaphoreSlim" />-Objekt eine festgelegte Anzahl von Malen frei.</summary>
      <param name="releaseCount" vsli:raw="The number of times to exit the semaphore.">Die Anzahl von Malen, die das Semaphor freigegeben werden soll.</param>
      <returns vsli:raw="The previous count of the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;.">Die vorherige Anzahl von <see cref="T:System.Threading.SemaphoreSlim" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Die aktuelle Instanz wurde bereits verworfen.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;releaseCount&quot; /&gt; is less than 1.">
        <paramref name="releaseCount" /> ist kleiner als 1.</exception>
      <exception cref="T:System.Threading.SemaphoreFullException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; has already reached its maximum size.">Der <see cref="T:System.Threading.SemaphoreSlim" /> hat bereits seine maximale Größe erreicht.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait">
      <summary vsli:raw="Blocks the current thread until it can enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;.">Blockiert den aktuellen Thread, bis er in die Warteschlange von <see cref="T:System.Threading.SemaphoreSlim" /> eingereiht werden kann.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Die aktuelle Instanz wurde bereits verworfen.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.Int32)">
      <summary vsli:raw="Blocks the current thread until it can enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, using a 32-bit signed integer that specifies the timeout.">Blockiert den aktuellen Thread, bis er in die Warteschlange von <see cref="T:System.Threading.SemaphoreSlim" /> eingereiht werden kann, wobei das Timeout mit einer 32-Bit-Ganzzahl mit Vorzeichen angegeben wird.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;(-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately.">Die Anzahl der Millisekunden, die gewartet werden muss, <see cref="F:System.Threading.Timeout.Infinite" />(-1), um auf unbestimmte Zeit zu warten, oder null, um den Zustand des Wait-Handles zu testen und sofort zurückzukehren.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread successfully entered the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der aktuelle Thread erfolgreich in die Warteschlange von <see cref="T:System.Threading.SemaphoreSlim" /> eingereiht wurde, andernfalls <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite timeout -or- timeout is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="millisecondsTimeout" /> ist eine negative Zahl ungleich -1, die ein unendliches Zeitlimit darstellt, oder das Zeitlimit ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; has been disposed.">
        <see cref="T:System.Threading.SemaphoreSlim" /> wurde verworfen.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.Int32,System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until it can enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, using a 32-bit signed integer that specifies the timeout, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Blockiert den aktuellen Thread, bis er in die Warteschlange von <see cref="T:System.Threading.SemaphoreSlim" /> eingereiht werden kann, wobei eine 32-Bit-Ganzzahl mit Vorzeichen zum Angeben des Timeouts verwendet und ein <see cref="T:System.Threading.CancellationToken" /> überwacht wird.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;(-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately.">Die Anzahl der Millisekunden, die gewartet werden muss, <see cref="F:System.Threading.Timeout.Infinite" />(-1), um auf unbestimmte Zeit zu warten, oder null, um den Zustand des Wait-Handles zu testen und sofort zurückzukehren.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">Das zu überwachende <see cref="T:System.Threading.CancellationToken" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread successfully entered the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der aktuelle Thread erfolgreich in die Warteschlange von <see cref="T:System.Threading.SemaphoreSlim" /> eingereiht wurde, andernfalls <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">
        <paramref name="cancellationToken" /> wurde abgebrochen.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite timeout.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="millisecondsTimeout" /> ist eine negative Zahl ungleich -1, die ein unendliches Zeitlimit darstellt, oder das Zeitlimit ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; instance has been disposed, or the &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has been disposed.">Die <see cref="T:System.Threading.SemaphoreSlim" />-Instanz wurde verworfen, oder die <see cref="T:System.Threading.CancellationTokenSource" />, die <paramref name="cancellationToken" /> erstellt hat, wurde verworfen.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until it can enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Blockiert den aktuellen Thread, bis er in die Warteschlange von <see cref="T:System.Threading.SemaphoreSlim" /> eingereiht werden kann, wobei ein <see cref="T:System.Threading.CancellationToken" /> überwacht wird.</summary>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; token to observe.">Das zu überwachende <see cref="T:System.Threading.CancellationToken" />-Token.</param>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">
        <paramref name="cancellationToken" /> wurde abgebrochen.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.&#xA;&#xA; -or-&#xA;&#xA; The &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has already been disposed.">Die aktuelle Instanz wurde bereits verworfen.  

oder - 
Die <see cref="T:System.Threading.CancellationTokenSource" />, die <paramref name="cancellationToken" /> erstellt hat, wurde bereits freigegeben.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan)">
      <summary vsli:raw="Blocks the current thread until it can enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; to specify the timeout.">Blockiert den aktuellen Thread, bis er in die Warteschlange von <see cref="T:System.Threading.SemaphoreSlim" /> eingereiht werden kann, wobei ein <see cref="T:System.TimeSpan" /> zum Angeben des Timeouts verwendet wird.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents 0 milliseconds to test the wait handle and return immediately.">Eine <see cref="T:System.TimeSpan" />-Struktur, die die Anzahl der zu wartenden Millisekunden angibt, eine <see cref="T:System.TimeSpan" />-Struktur, die -1 Millisekunden zum unendlichen Warten angibt, oder eine <see cref="T:System.TimeSpan" />-Struktur, die 0 Millisekunden darstellt, um den Wait-Handle zu testen und sofort zurückzukehren.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread successfully entered the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der aktuelle Thread erfolgreich in die Warteschlange von <see cref="T:System.Threading.SemaphoreSlim" /> eingereiht wurde, andernfalls <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1, which represents an infinite timeout.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> ist eine negative Zahl ungleich -1, die ein unendliches Zeitlimit darstellt, oder das Zeitlimit ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The semaphoreSlim instance has been disposed.">Die „semaphoreSlim“-Instanz wurde verworfen <paramref name="." />.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until it can enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that specifies the timeout, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Blockiert den aktuellen Thread, bis er in die Warteschlange von <see cref="T:System.Threading.SemaphoreSlim" /> eingereiht werden kann, wobei eine <see cref="T:System.TimeSpan" /> den Timeout angibt und ein <see cref="T:System.Threading.CancellationToken" /> überwacht wird.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents 0 milliseconds to test the wait handle and return immediately.">Eine <see cref="T:System.TimeSpan" />-Struktur, die die Anzahl der zu wartenden Millisekunden angibt, eine <see cref="T:System.TimeSpan" />-Struktur, die -1 Millisekunden zum unendlichen Warten angibt, oder eine <see cref="T:System.TimeSpan" />-Struktur, die 0 Millisekunden darstellt, um den Wait-Handle zu testen und sofort zurückzukehren.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">Das zu überwachende <see cref="T:System.Threading.CancellationToken" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread successfully entered the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der aktuelle Thread erfolgreich in die Warteschlange von <see cref="T:System.Threading.SemaphoreSlim" /> eingereiht wurde, andernfalls <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">
        <paramref name="cancellationToken" /> wurde abgebrochen.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1, which represents an infinite timeout.&#xA;&#xA;-or-.&#xA;&#xA;&lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> ist eine negative Zahl ungleich -1, die ein unendliches Zeitlimit darstellt, oder das Zeitlimit ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The semaphoreSlim instance has been disposed.&#xA;&#xA;-or-&#xA;&#xA;The &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has already been disposed.">Die semaphoreSlim-Instanz wurde verworfen <paramref name="." /><paramref name="-or-" />  
Die <see cref="T:System.Threading.CancellationTokenSource" />, die <paramref name="cancellationToken" /> erstellt hat, wurde bereits freigegeben.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync">
      <summary vsli:raw="Asynchronously waits to enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;.">Wartet asynchron auf den Zutritt zum <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
      <returns vsli:raw="A task that will complete when the semaphore has been entered.">Eine Aufgabe, die abgeschlossen wird, wenn das Semaphor eingegeben wurde.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; has been disposed.">
        <see cref="T:System.Threading.SemaphoreSlim" /> wurde verworfen.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.Int32)">
      <summary vsli:raw="Asynchronously waits to enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, using a 32-bit signed integer to measure the time interval.">Wartet asynchron auf den Zutritt zum <see cref="T:System.Threading.SemaphoreSlim" />, wobei eine 32-Bit-Ganzzahl mit Vorzeichen zum Messen des Zeitintervalls verwendet wird.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately.">Die Anzahl der Millisekunden, die gewartet werden muss, <see cref="F:System.Threading.Timeout.Infinite" />(-1), um auf unbestimmte Zeit zu warten, oder null, um den Zustand des Wait-Handles zu testen und sofort zurückzukehren.</param>
      <returns vsli:raw="A task that will complete with a result of &lt;see langword=&quot;true&quot; /&gt; if the current thread successfully entered the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, otherwise with a result of &lt;see langword=&quot;false&quot; /&gt;.">Eine Aufgabe, die mit dem Ergebnis <see langword="true" /> abgeschlossen wird, wenn der aktuelle Thread erfolgreich in <see cref="T:System.Threading.SemaphoreSlim" /> gewechselt ist, andernfalls mit dem Ergebnis <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Die aktuelle Instanz wurde bereits verworfen.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite timeout.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="millisecondsTimeout" /> ist eine negative Zahl ungleich -1, die ein unendliches Zeitlimit darstellt, oder das Zeitlimit ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.Int32,System.Threading.CancellationToken)">
      <summary vsli:raw="Asynchronously waits to enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, using a 32-bit signed integer to measure the time interval, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Wartet asynchron auf den Zutritt zum <see cref="T:System.Threading.SemaphoreSlim" />, wobei eine 32-Bit-Ganzzahl mit Vorzeichen zum Messen des Zeitintervalls verwendet wird, während ein <see cref="T:System.Threading.CancellationToken" /> beobachtet wird.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately.">Die Anzahl der Millisekunden, die gewartet werden muss, <see cref="F:System.Threading.Timeout.Infinite" />(-1), um auf unbestimmte Zeit zu warten, oder null, um den Zustand des Wait-Handles zu testen und sofort zurückzukehren.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">Das zu überwachende <see cref="T:System.Threading.CancellationToken" />.</param>
      <returns vsli:raw="A task that will complete with a result of &lt;see langword=&quot;true&quot; /&gt; if the current thread successfully entered the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, otherwise with a result of &lt;see langword=&quot;false&quot; /&gt;.">Eine Aufgabe, die mit dem Ergebnis <see langword="true" /> abgeschlossen wird, wenn der aktuelle Thread erfolgreich in <see cref="T:System.Threading.SemaphoreSlim" /> gewechselt ist, andernfalls mit dem Ergebnis <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a number other than -1, which represents an infinite timeout.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="millisecondsTimeout" /> ist eine Zahl ungleich -1, die ein unendliches Zeitlimit darstellt, oder das Zeitlimit ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Die aktuelle Instanz wurde bereits verworfen.</exception>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">
        <paramref name="cancellationToken" /> wurde abgebrochen.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.Threading.CancellationToken)">
      <summary vsli:raw="Asynchronously waits to enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Wartet asynchron auf den Zutritt zum <see cref="T:System.Threading.SemaphoreSlim" />, während ein ein <see cref="T:System.Threading.CancellationToken" /> beobachtet wird.</summary>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; token to observe.">Das zu überwachende <see cref="T:System.Threading.CancellationToken" />-Token.</param>
      <returns vsli:raw="A task that will complete when the semaphore has been entered.">Eine Aufgabe, die abgeschlossen wird, wenn das Semaphor eingegeben wurde.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Die aktuelle Instanz wurde bereits verworfen.</exception>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">
        <paramref name="cancellationToken" /> wurde abgebrochen.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan)">
      <summary vsli:raw="Asynchronously waits to enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; to measure the time interval.">Wartet asynchron auf den Zutritt zum <see cref="T:System.Threading.SemaphoreSlim" /> unter Verwendung einer <see cref="T:System.TimeSpan" /> zum Messen des Zeitintervalls.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents 0 milliseconds to test the wait handle and return immediately.">Eine <see cref="T:System.TimeSpan" />-Struktur, die die Anzahl der zu wartenden Millisekunden angibt, eine <see cref="T:System.TimeSpan" />-Struktur, die -1 Millisekunden zum unendlichen Warten angibt, oder eine <see cref="T:System.TimeSpan" />-Struktur, die 0 Millisekunden darstellt, um den Wait-Handle zu testen und sofort zurückzukehren.</param>
      <returns vsli:raw="A task that will complete with a result of &lt;see langword=&quot;true&quot; /&gt; if the current thread successfully entered the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, otherwise with a result of &lt;see langword=&quot;false&quot; /&gt;.">Eine Aufgabe, die mit dem Ergebnis <see langword="true" /> abgeschlossen wird, wenn der aktuelle Thread erfolgreich in <see cref="T:System.Threading.SemaphoreSlim" /> gewechselt ist, andernfalls mit dem Ergebnis <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Die aktuelle Instanz wurde bereits verworfen.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1, which represents an infinite timeout.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="millisecondsTimeout" /> ist eine negative Zahl ungleich -1, die ein unendliches Zeitlimit darstellt, oder das Zeitlimit ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan,System.Threading.CancellationToken)">
      <summary vsli:raw="Asynchronously waits to enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; to measure the time interval, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Wartet asynchron auf den Zutritt zum <see cref="T:System.Threading.SemaphoreSlim" /> unter Verwendung einer <see cref="T:System.TimeSpan" /> zum Messen des Zeitintervalls, während ein <see cref="T:System.Threading.CancellationToken" /> beobachtet wird.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents 0 milliseconds to test the wait handle and return immediately.">Eine <see cref="T:System.TimeSpan" />-Struktur, die die Anzahl der zu wartenden Millisekunden angibt, eine <see cref="T:System.TimeSpan" />-Struktur, die -1 Millisekunden zum unendlichen Warten angibt, oder eine <see cref="T:System.TimeSpan" />-Struktur, die 0 Millisekunden darstellt, um den Wait-Handle zu testen und sofort zurückzukehren.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; token to observe.">Das zu überwachende <see cref="T:System.Threading.CancellationToken" />-Token.</param>
      <returns vsli:raw="A task that will complete with a result of &lt;see langword=&quot;true&quot; /&gt; if the current thread successfully entered the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, otherwise with a result of &lt;see langword=&quot;false&quot; /&gt;.">Eine Aufgabe, die mit dem Ergebnis <see langword="true" /> abgeschlossen wird, wenn der aktuelle Thread erfolgreich in <see cref="T:System.Threading.SemaphoreSlim" /> gewechselt ist, andernfalls mit dem Ergebnis <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1, which represents an infinite timeout.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="millisecondsTimeout" /> ist eine negative Zahl ungleich -1, die ein unendliches Zeitlimit darstellt, oder das Zeitlimit ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">
        <paramref name="cancellationToken" /> wurde abgebrochen.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; has been disposed.">
        <see cref="T:System.Threading.SemaphoreSlim" /> wurde verworfen.</exception>
    </member>
    <member name="T:System.Threading.SendOrPostCallback">
      <summary vsli:raw="Represents a method to be called when a message is to be dispatched to a synchronization context.">Stellt eine Methode dar, die aufgerufen werden muss, wenn eine Nachricht an einen Synchronisierungskontext gesendet werden soll.</summary>
      <param name="state" vsli:raw="The object passed to the delegate.">Das an den Delegaten übergebene Objekt.</param>
    </member>
    <member name="T:System.Threading.SpinLock">
      <summary vsli:raw="Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop repeatedly checking until the lock becomes available.">Stellt einen sich gegenseitig ausschließenden Sperrprimitiven bereit, wobei ein Thread, der versucht, die Sperre abzurufen, wiederholt in einer Schleife wartet, bis die Sperre verfügbar wird.</summary>
    </member>
    <member name="M:System.Threading.SpinLock.#ctor(System.Boolean)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SpinLock&quot; /&gt; structure with the option to track thread IDs to improve debugging.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.SpinLock" />-Struktur mit der Option, Thread-IDs nachzuverfolgen, um das Debuggen zu vereinfachen.</summary>
      <param name="enableThreadOwnerTracking" vsli:raw="Whether to capture and use thread IDs for debugging purposes.">Gibt an, ob Thread-IDs zu Debugzwecken erfasst und verwendet werden.</param>
    </member>
    <member name="M:System.Threading.SpinLock.Enter(System.Boolean@)">
      <summary vsli:raw="Acquires the lock in a reliable manner, such that even if an exception occurs within the method call, &lt;paramref name=&quot;lockTaken&quot; /&gt; can be examined reliably to determine whether the lock was acquired.">Ruft die Sperre zuverlässig ab, sodass <paramref name="lockTaken" /> auch bei einer Ausnahme innerhalb des Methodenaufrufs zuverlässig untersucht werden kann, um zu bestimmen, ob die Sperre abgerufen wurde.</summary>
      <param name="lockTaken" vsli:raw="True if the lock is acquired; otherwise, false. &lt;paramref name=&quot;lockTaken&quot; /&gt; must be initialized to false prior to calling this method.">True, wenn die Sperre abgerufen wird, andernfalls false. <paramref name="lockTaken" /> muss vor dem Aufrufen dieser Methode mit false initialisiert werden.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;lockTaken&quot; /&gt; argument must be initialized to false prior to calling Enter.">Das <paramref name="lockTaken" />-Argument muss vor dem Aufrufen von Enter mit false initialisiert werden.</exception>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="Thread ownership tracking is enabled, and the current thread has already acquired this lock.">Die Threadbesitznachverfolgung wird aktiviert, und der aktuelle Thread hat diese Sperre bereits abgerufen.</exception>
    </member>
    <member name="M:System.Threading.SpinLock.Exit">
      <summary vsli:raw="Releases the lock.">Hebt die Sperre auf.</summary>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="Thread ownership tracking is enabled, and the current thread is not the owner of this lock.">Die Threadbesitznachverfolgung wird aktiviert, und der aktuelle Thread ist nicht Besitzer dieser Sperre.</exception>
    </member>
    <member name="M:System.Threading.SpinLock.Exit(System.Boolean)">
      <summary vsli:raw="Releases the lock.">Hebt die Sperre auf.</summary>
      <param name="useMemoryBarrier" vsli:raw="A Boolean value that indicates whether a memory fence should be issued in order to immediately publish the exit operation to other threads.">Ein boolescher Wert, der angibt, ob eine Arbeitsspeicherumgrenzung ausgegeben werden soll, um den Beendigungsvorgang sofort für andere Threads zu veröffentlichen.</param>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="Thread ownership tracking is enabled, and the current thread is not the owner of this lock.">Die Threadbesitznachverfolgung wird aktiviert, und der aktuelle Thread ist nicht Besitzer dieser Sperre.</exception>
    </member>
    <member name="P:System.Threading.SpinLock.IsHeld">
      <summary vsli:raw="Gets whether the lock is currently held by any thread.">Ruft einen Wert ab, der angibt, ob die Sperre zurzeit von einem Thread verwendet wird.</summary>
      <returns vsli:raw="true if the lock is currently held by any thread; otherwise false.">True, wenn die Sperre zurzeit von einem Thread verwendet wird, andernfalls false.</returns>
    </member>
    <member name="P:System.Threading.SpinLock.IsHeldByCurrentThread">
      <summary vsli:raw="Gets whether the lock is held by the current thread.">Ruft einen Wert ab, der angibt, ob die Sperre vom aktuellen Thread verwendet wird.</summary>
      <returns vsli:raw="true if the lock is held by the current thread; otherwise false.">True, wenn die Sperre vom aktuellen Thread verwendet wird, andernfalls false.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Thread ownership tracking is disabled.">Die Threadbesitznachverfolgung wird deaktiviert.</exception>
    </member>
    <member name="P:System.Threading.SpinLock.IsThreadOwnerTrackingEnabled">
      <summary vsli:raw="Gets whether thread ownership tracking is enabled for this instance.">Ruft einen Wert ab, der angibt, ob die Threadbesitznachverfolgung für diese Instanz aktiviert ist.</summary>
      <returns vsli:raw="true if thread ownership tracking is enabled for this instance; otherwise false.">True, wenn die Threadbesitznachverfolgung für diese Instanz aktiviert ist, andernfalls false.</returns>
    </member>
    <member name="M:System.Threading.SpinLock.TryEnter(System.Boolean@)">
      <summary vsli:raw="Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, &lt;paramref name=&quot;lockTaken&quot; /&gt; can be examined reliably to determine whether the lock was acquired.">Versucht, die Sperre zuverlässig abzurufen, sodass <paramref name="lockTaken" /> auch bei einer Ausnahme innerhalb des Methodenaufrufs zuverlässig untersucht werden kann, um zu bestimmen, ob die Sperre abgerufen wurde.</summary>
      <param name="lockTaken" vsli:raw="True if the lock is acquired; otherwise, false. &lt;paramref name=&quot;lockTaken&quot; /&gt; must be initialized to false prior to calling this method.">True, wenn die Sperre abgerufen wird, andernfalls false. <paramref name="lockTaken" /> muss vor dem Aufrufen dieser Methode mit false initialisiert werden.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;lockTaken&quot; /&gt; argument must be initialized to false prior to calling TryEnter.">Das <paramref name="lockTaken" />-Argument muss vor dem Aufrufen von TryEnter mit false initialisiert werden.</exception>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="Thread ownership tracking is enabled, and the current thread has already acquired this lock.">Die Threadbesitznachverfolgung wird aktiviert, und der aktuelle Thread hat diese Sperre bereits abgerufen.</exception>
    </member>
    <member name="M:System.Threading.SpinLock.TryEnter(System.Int32,System.Boolean@)">
      <summary vsli:raw="Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, &lt;paramref name=&quot;lockTaken&quot; /&gt; can be examined reliably to determine whether the lock was acquired.">Versucht, die Sperre zuverlässig abzurufen, sodass <paramref name="lockTaken" /> auch bei einer Ausnahme innerhalb des Methodenaufrufs zuverlässig untersucht werden kann, um zu bestimmen, ob die Sperre abgerufen wurde.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1) to wait indefinitely.">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</param>
      <param name="lockTaken" vsli:raw="True if the lock is acquired; otherwise, false. &lt;paramref name=&quot;lockTaken&quot; /&gt; must be initialized to false prior to calling this method.">True, wenn die Sperre abgerufen wird, andernfalls false. <paramref name="lockTaken" /> muss vor dem Aufrufen dieser Methode mit false initialisiert werden.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;lockTaken&quot; /&gt; argument must be initialized to false prior to calling TryEnter.">Das <paramref name="lockTaken" />-Argument muss vor dem Aufrufen von TryEnter mit false initialisiert werden.</exception>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="Thread ownership tracking is enabled, and the current thread has already acquired this lock.">Die Threadbesitznachverfolgung wird aktiviert, und der aktuelle Thread hat diese Sperre bereits abgerufen.</exception>
    </member>
    <member name="M:System.Threading.SpinLock.TryEnter(System.TimeSpan,System.Boolean@)">
      <summary vsli:raw="Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, &lt;paramref name=&quot;lockTaken&quot; /&gt; can be examined reliably to determine whether the lock was acquired.">Versucht, die Sperre zuverlässig abzurufen, sodass <paramref name="lockTaken" /> auch bei einer Ausnahme innerhalb des Methodenaufrufs zuverlässig untersucht werden kann, um zu bestimmen, ob die Sperre abgerufen wurde.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely.">Eine <see cref="T:System.TimeSpan" />-Struktur, die die Anzahl der zu wartenden Millisekunden angibt, oder eine <see cref="T:System.TimeSpan" />-Struktur, die -1 Millisekunden zum unendlichen Warten angibt.</param>
      <param name="lockTaken" vsli:raw="True if the lock is acquired; otherwise, false. &lt;paramref name=&quot;lockTaken&quot; /&gt; must be initialized to false prior to calling this method.">True, wenn die Sperre abgerufen wird, andernfalls false. <paramref name="lockTaken" /> muss vor dem Aufrufen dieser Methode mit false initialisiert werden.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt; milliseconds.">
        <paramref name="timeout" /> ist eine negative Zahl ungleich -1 Millisekunden, die ein unendliches Timeout darstellt, - oder - Timeout ist größer als <see cref="F:System.Int32.MaxValue" /> Millisekunden.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;lockTaken&quot; /&gt; argument must be initialized to false prior to calling TryEnter.">Das <paramref name="lockTaken" />-Argument muss vor dem Aufrufen von TryEnter mit false initialisiert werden.</exception>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="Thread ownership tracking is enabled, and the current thread has already acquired this lock.">Die Threadbesitznachverfolgung wird aktiviert, und der aktuelle Thread hat diese Sperre bereits abgerufen.</exception>
    </member>
    <member name="T:System.Threading.SpinWait">
      <summary vsli:raw="Provides support for spin-based waiting.">Stellt Unterstützung für Spin-basierte Wartevorgänge bereit.</summary>
    </member>
    <member name="P:System.Threading.SpinWait.Count">
      <summary vsli:raw="Gets the number of times &lt;see cref=&quot;M:System.Threading.SpinWait.SpinOnce&quot; /&gt; has been called on this instance.">Ruft die Anzahl von <see cref="M:System.Threading.SpinWait.SpinOnce" />-Aufrufen für diese Instanz ab.</summary>
      <returns vsli:raw="Returns an integer that represents the number of times &lt;see cref=&quot;M:System.Threading.SpinWait.SpinOnce&quot; /&gt; has been called on this instance.">Gibt eine ganze Zahl zurück, die angibt, wie häufig <see cref="M:System.Threading.SpinWait.SpinOnce" /> für diese Instanz aufgerufen wurde.</returns>
    </member>
    <member name="P:System.Threading.SpinWait.NextSpinWillYield">
      <summary vsli:raw="Gets whether the next call to &lt;see cref=&quot;M:System.Threading.SpinWait.SpinOnce&quot; /&gt; will yield the processor, triggering a forced context switch.">Ruft einen Wert ab, der angibt, ob der nächste Aufruf von <see cref="M:System.Threading.SpinWait.SpinOnce" /> den Prozessor ergibt und einen erzwungenen Kontextwechsel auslöst.</summary>
      <returns vsli:raw="Whether the next call to &lt;see cref=&quot;M:System.Threading.SpinWait.SpinOnce&quot; /&gt; will yield the processor, triggering a forced context switch.">Gibt an, ob der nächste Aufruf von <see cref="M:System.Threading.SpinWait.SpinOnce" /> den Prozessor ergibt und einen erzwungenen Kontextwechsel auslöst.</returns>
    </member>
    <member name="M:System.Threading.SpinWait.Reset">
      <summary vsli:raw="Resets the spin counter.">Setzt die Spin-Anzahl zurück.</summary>
    </member>
    <member name="M:System.Threading.SpinWait.SpinOnce">
      <summary vsli:raw="Performs a single spin.">Führt einen Spin-Vorgang aus.</summary>
    </member>
    <member name="M:System.Threading.SpinWait.SpinOnce(System.Int32)">
      <summary vsli:raw="Performs a single spin and calls &lt;see cref=&quot;M:System.Threading.Thread.Sleep(System.Int32)&quot; /&gt; after a minimum spin count.">Führt einen einzelnen Spin durch und ruft <see cref="M:System.Threading.Thread.Sleep(System.Int32)" /> nach einer minimalen Spinanzahl auf.</summary>
      <param name="sleep1Threshold" vsli:raw="A minimum spin count after which &lt;see langword=&quot;Thread.Sleep(1)&quot; /&gt; may be used. A value of -1 disables the use of &lt;see langword=&quot;Thread.Sleep(1)&quot; /&gt;.">Eine minimale Spinanzahl, nach der <see langword="Thread.Sleep(1)" /> verwendet werden kann. Ein Wert von -1 deaktiviert die Verwendung von <see langword="Thread.Sleep(1)" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;sleep1Threshold&quot; /&gt; is less than -1.">
        <paramref name="sleep1Threshold" /> ist kleiner als -1.</exception>
    </member>
    <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean})">
      <summary vsli:raw="Spins until the specified condition is satisfied.">Führt Spin-Vorgänge aus, bis die angegebene Bedingung erfüllt wird.</summary>
      <param name="condition" vsli:raw="A delegate to be executed over and over until it returns true.">Ein Delegat, der immer wieder ausgeführt wird, bis true zurückgegeben wird.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;condition&quot; /&gt; argument is null.">Das <paramref name="condition" />-Argument ist null.</exception>
    </member>
    <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean},System.Int32)">
      <summary vsli:raw="Spins until the specified condition is satisfied or until the specified timeout is expired.">Führt Spin-Vorgänge aus, bis die angegebene Bedingung erfüllt wird oder das angegebene Timeout abgelaufen ist.</summary>
      <param name="condition" vsli:raw="A delegate to be executed over and over until it returns true.">Ein Delegat, der immer wieder ausgeführt wird, bis true zurückgegeben wird.</param>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1) to wait indefinitely.">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the condition is satisfied within the timeout; otherwise, false.">True, wenn die Bedingung innerhalb des Timeouts erfüllt wird, andernfalls false.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;condition&quot; /&gt; argument is null.">Das <paramref name="condition" />-Argument ist null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</exception>
    </member>
    <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean},System.TimeSpan)">
      <summary vsli:raw="Spins until the specified condition is satisfied or until the specified timeout is expired.">Führt Spin-Vorgänge aus, bis die angegebene Bedingung erfüllt wird oder das angegebene Timeout abgelaufen ist.</summary>
      <param name="condition" vsli:raw="A delegate to be executed over and over until it returns true.">Ein Delegat, der immer wieder ausgeführt wird, bis true zurückgegeben wird.</param>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a TimeSpan that represents -1 milliseconds to wait indefinitely.">Ein <see cref="T:System.TimeSpan" />, das die Wartezeit in Millisekunden darstellt, oder ein TimeSpan-Wert, der -1 Millisekunden für Warten ohne Timeout darstellt.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the condition is satisfied within the timeout; otherwise, false.">True, wenn die Bedingung innerhalb des Timeouts erfüllt wird, andernfalls false.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;condition&quot; /&gt; argument is null.">Das <paramref name="condition" />-Argument ist null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> ist eine negative Zahl ungleich  -1 Millisekunden, die ein unendliches Timeout darstellt, - oder - Timeout ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="T:System.Threading.SynchronizationContext">
      <summary vsli:raw="Provides the basic functionality for propagating a synchronization context in various synchronization models.">Stellt die Basisfunktionen für die Weitergabe eines Synchronisierungskontexts in unterschiedlichen Synchronisierungsmodellen bereit.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.#ctor">
      <summary vsli:raw="Creates a new instance of the &lt;see cref=&quot;T:System.Threading.SynchronizationContext&quot; /&gt; class.">Erstellt eine neue Instanz der <see cref="T:System.Threading.SynchronizationContext" />-Klasse.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.CreateCopy">
      <summary vsli:raw="When overridden in a derived class, creates a copy of the synchronization context.">Erstellt beim Überschreiben in einer abgeleiteten Klasse eine Kopie des Synchronisierungskontexts.</summary>
      <returns vsli:raw="A new &lt;see cref=&quot;T:System.Threading.SynchronizationContext&quot; /&gt; object.">Ein neues <see cref="T:System.Threading.SynchronizationContext" />-Objekt.</returns>
    </member>
    <member name="P:System.Threading.SynchronizationContext.Current">
      <summary vsli:raw="Gets the synchronization context for the current thread.">Ruft den Synchronisierungskontext für den aktuellen Thread ab.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.SynchronizationContext&quot; /&gt; object representing the current synchronization context.">Ein <see cref="T:System.Threading.SynchronizationContext" />-Objekt, das den aktuellen Synchronisierungskontext darstellt.</returns>
    </member>
    <member name="M:System.Threading.SynchronizationContext.IsWaitNotificationRequired">
      <summary vsli:raw="Determines if wait notification is required.">Bestimmt, ob eine Wartezeitbenachrichtigung erforderlich ist.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if wait notification is required; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn eine Wartezeitbenachrichtigung erforderlich ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.SynchronizationContext.OperationCompleted">
      <summary vsli:raw="When overridden in a derived class, responds to the notification that an operation has completed.">Antwortet beim Überschreiben in einer abgeleiteten Klasse auf die Benachrichtigung, dass ein Vorgang abgeschlossen wurde.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.OperationStarted">
      <summary vsli:raw="When overridden in a derived class, responds to the notification that an operation has started.">Antwortet beim Überschreiben in einer abgeleiteten Klasse auf die Benachrichtigung, dass ein Vorgang gestartet wurde.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.Post(System.Threading.SendOrPostCallback,System.Object)">
      <summary vsli:raw="When overridden in a derived class, dispatches an asynchronous message to a synchronization context.">Sendet beim Überschreiben in einer abgeleiteten Klasse eine asynchrone Meldung an einen Synchronisierungskontext.</summary>
      <param name="d" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SendOrPostCallback&quot; /&gt; delegate to call.">Der aufzurufende <see cref="T:System.Threading.SendOrPostCallback" />-Delegat.</param>
      <param name="state" vsli:raw="The object passed to the delegate.">Das an den Delegaten übergebene Objekt.</param>
    </member>
    <member name="M:System.Threading.SynchronizationContext.Send(System.Threading.SendOrPostCallback,System.Object)">
      <summary vsli:raw="When overridden in a derived class, dispatches a synchronous message to a synchronization context.">Sendet beim Überschreiben in einer abgeleiteten Klasse eine synchrone Meldung an einen Synchronisierungskontext.</summary>
      <param name="d" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SendOrPostCallback&quot; /&gt; delegate to call.">Der aufzurufende <see cref="T:System.Threading.SendOrPostCallback" />-Delegat.</param>
      <param name="state" vsli:raw="The object passed to the delegate.">Das an den Delegaten übergebene Objekt.</param>
      <exception cref="T:System.NotSupportedException" vsli:raw="The method was called in a Windows Store app. The implementation of &lt;see cref=&quot;T:System.Threading.SynchronizationContext&quot; /&gt; for Windows Store apps does not support the &lt;see cref=&quot;M:System.Threading.SynchronizationContext.Send(System.Threading.SendOrPostCallback,System.Object)&quot; /&gt; method.">Die Methode wurde in einer Windows Store-App aufgerufen. Die Implementierung von <see cref="T:System.Threading.SynchronizationContext" /> für Windows Store-Apps unterstützt nicht die <see cref="M:System.Threading.SynchronizationContext.Send(System.Threading.SendOrPostCallback,System.Object)" />-Methode.</exception>
    </member>
    <member name="M:System.Threading.SynchronizationContext.SetSynchronizationContext(System.Threading.SynchronizationContext)">
      <summary vsli:raw="Sets the current synchronization context.">Legt den aktuellen Synchronisierungskontext fest.</summary>
      <param name="syncContext" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SynchronizationContext&quot; /&gt; object to be set.">Das festzulegende <see cref="T:System.Threading.SynchronizationContext" />-Objekt.</param>
    </member>
    <member name="M:System.Threading.SynchronizationContext.SetWaitNotificationRequired">
      <summary vsli:raw="Sets notification that wait notification is required and prepares the callback method so it can be called more reliably when a wait occurs.">Legt fest, dass eine Wartezeitbenachrichtigung erforderlich ist, und bereitet die Rückrufmethode vor, sodass sie bei einem Wartevorgang zuverlässiger aufgerufen werden kann.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.Wait(System.IntPtr[],System.Boolean,System.Int32)">
      <summary vsli:raw="Waits for any or all the elements in the specified array to receive a signal.">Wartet darauf, dass ein beliebiges oder alle Elemente im angegebenen Array ein Signal empfangen.</summary>
      <param name="waitHandles" vsli:raw="An array of type &lt;see cref=&quot;T:System.IntPtr&quot; /&gt; that contains the native operating system handles.">Ein Array vom Typ <see cref="T:System.IntPtr" />, das die systemeigenen Betriebssystemhandles enthält.</param>
      <param name="waitAll" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to wait for all handles; &lt;see langword=&quot;false&quot; /&gt; to wait for any handle.">
        <see langword="true" />, um auf alle Handles zu warten, <see langword="false" />, um auf ein beliebiges Handle zu warten.</param>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1) to wait indefinitely.">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</param>
      <returns vsli:raw="The array index of the object that satisfied the wait.">Der Arrayindex des Objekts, das den Wartevorgang erfüllt hat.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;waitHandles&quot; /&gt; is null.">
        <paramref name="waitHandles" /> ist NULL.</exception>
    </member>
    <member name="M:System.Threading.SynchronizationContext.WaitHelper(System.IntPtr[],System.Boolean,System.Int32)">
      <summary vsli:raw="Helper function that waits for any or all the elements in the specified array to receive a signal.">Hilfsfunktion, die darauf wartet, dass ein beliebiges oder alle Elemente im angegebenen Array ein Signal empfangen.</summary>
      <param name="waitHandles" vsli:raw="An array of type &lt;see cref=&quot;T:System.IntPtr&quot; /&gt; that contains the native operating system handles.">Ein Array vom Typ <see cref="T:System.IntPtr" />, das die systemeigenen Betriebssystemhandles enthält.</param>
      <param name="waitAll" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to wait for all handles;  &lt;see langword=&quot;false&quot; /&gt; to wait for any handle.">
        <see langword="true" />, um auf alle Handles zu warten, <see langword="false" />, um auf ein beliebiges Handle zu warten.</param>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1) to wait indefinitely.">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</param>
      <returns vsli:raw="The array index of the object that satisfied the wait.">Der Arrayindex des Objekts, das den Wartevorgang erfüllt hat.</returns>
    </member>
    <member name="T:System.Threading.SynchronizationLockException">
      <summary vsli:raw="The exception that is thrown when a method requires the caller to own the lock on a given Monitor, and the method is invoked by a caller that does not own that lock.">Die Ausnahme, die ausgelöst wird, wenn der Aufrufer für eine Methode über eine Sperre für einen bestimmten Monitor verfügen muss und die Methode von einem Aufrufer aufgerufen wird, der nicht über diese Sperre verfügt.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SynchronizationLockException&quot; /&gt; class with default properties.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.SynchronizationLockException" />-Klasse mit Standardeigenschaften.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SynchronizationLockException&quot; /&gt; class with serialized data.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.SynchronizationLockException" />-Klasse mit serialisierten Daten.</summary>
      <param name="info" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.SerializationInfo&quot; /&gt; that holds the serialized object data about the exception being thrown.">Die <see cref="T:System.Runtime.Serialization.SerializationInfo" />, die die serialisierten Objektdaten für die ausgelöste Ausnahme enthält.</param>
      <param name="context" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.StreamingContext&quot; /&gt; that contains contextual information about the source or destination.">Der <see cref="T:System.Runtime.Serialization.StreamingContext" />, der die Kontextinformationen über die Quelle oder das Ziel enthält.</param>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor(System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SynchronizationLockException&quot; /&gt; class with a specified error message.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.SynchronizationLockException" />-Klasse mit einer angegebenen Fehlermeldung.</summary>
      <param name="message" vsli:raw="The error message that explains the reason for the exception.">Die Fehlermeldung, in der die Ursache der Ausnahme erklärt wird.</param>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor(System.String,System.Exception)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SynchronizationLockException&quot; /&gt; class with a specified error message and a reference to the inner exception that is the cause of this exception.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.SynchronizationLockException" />-Klasse mit einer angegebenen Fehlermeldung und einem Verweis auf die innere Ausnahme, die diese Ausnahme ausgelöst hat.</summary>
      <param name="message" vsli:raw="The error message that explains the reason for the exception.">Die Fehlermeldung, in der die Ursache der Ausnahme erklärt wird.</param>
      <param name="innerException" vsli:raw="The exception that is the cause of the current exception. If the &lt;paramref name=&quot;innerException&quot; /&gt; parameter is not &lt;see langword=&quot;null&quot; /&gt;, the current exception is raised in a &lt;see langword=&quot;catch&quot; /&gt; block that handles the inner exception.">Die Ausnahme, die die Ursache der aktuellen Ausnahme ist. Wenn der <paramref name="innerException" />-Parameter nicht <see langword="null" /> ist, wird die aktuelle Ausnahme in einem <see langword="catch" />-Block ausgelöst, der die innere Ausnahme behandelt.</param>
    </member>
    <member name="T:System.Threading.ThreadLocal`1">
      <summary vsli:raw="Provides thread-local storage of data.">Stellt Thread-lokalen Datenspeicher bereit.</summary>
      <typeparam name="T" vsli:raw="Specifies the type of data stored per-thread.">Gibt den gespeicherten Datentyp pro Thread an.</typeparam>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor">
      <summary vsli:raw="Initializes the &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance.">Initialisiert die <see cref="T:System.Threading.ThreadLocal`1" />-Instanz.</summary>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor(System.Boolean)">
      <summary vsli:raw="Initializes the &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance and specifies whether all values are accessible from any thread.">Initialisiert die <see cref="T:System.Threading.ThreadLocal`1" />-Instanz und gibt an, ob alle Werte von jedem Thread aus zugänglich sind.</summary>
      <param name="trackAllValues" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to track all values set on the instance and expose them through the &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Values&quot; /&gt; property; &lt;see langword=&quot;false&quot; /&gt; otherwise. When set to &lt;see langword=&quot;true&quot; /&gt;, a value stored from a given thread will be available through &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Values&quot; /&gt; even after that thread has exited.">
        <see langword="true" />, alle Werte nachzuverfolgen, die für die Instanz festgelegt sind, und sie über die <see cref="P:System.Threading.ThreadLocal`1.Values" />-Eigenschaft verfügbar zu machen; andernfalls <see langword="false" />.</param>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor(System.Func{`0})">
      <summary vsli:raw="Initializes the &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance with the specified &lt;paramref name=&quot;valueFactory&quot; /&gt; function.">Initialisiert die <see cref="T:System.Threading.ThreadLocal`1" />-Instanz mit der angegebenen <paramref name="valueFactory" />-Funktion.</summary>
      <param name="valueFactory" vsli:raw="The  &lt;see cref=&quot;T:System.Func`1&quot; /&gt; invoked to produce a lazily-initialized value when an attempt is made to retrieve &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Value&quot; /&gt; without it having been previously initialized.">Das <see cref="T:System.Func`1" />, das aufgerufen wird, um einen verzögert initialisierten Wert zu erzeugen, wenn versucht wird, <see cref="P:System.Threading.ThreadLocal`1.Value" /> ohne vorherige Initialisierung abzurufen.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;valueFactory&quot; /&gt; is a null reference (Nothing in Visual Basic).">
        <paramref name="valueFactory" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor(System.Func{`0},System.Boolean)">
      <summary vsli:raw="Initializes the &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance with the specified &lt;paramref name=&quot;valueFactory&quot; /&gt; function and a flag that indicates whether all values are accessible from any thread.">Initialisiert die <see cref="T:System.Threading.ThreadLocal`1" />-Instanz mit der angegebenen <paramref name="valueFactory" />-Funktion und einem Flag, das angibt, ob alle Werte von jedem Thread aus zugänglich sind.</summary>
      <param name="valueFactory" vsli:raw="The &lt;see cref=&quot;T:System.Func`1&quot; /&gt; invoked to produce a lazily-initialized value when an attempt is made to retrieve &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Value&quot; /&gt; without it having been previously initialized.">Das <see cref="T:System.Func`1" />, das aufgerufen wird, um einen verzögert initialisierten Wert zu erzeugen, wenn versucht wird, <see cref="P:System.Threading.ThreadLocal`1.Value" /> ohne vorherige Initialisierung abzurufen.</param>
      <param name="trackAllValues" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to track all values set on the instance and expose them through the &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Values&quot; /&gt; property; &lt;see langword=&quot;false&quot; /&gt; otherwise. When set to &lt;see langword=&quot;true&quot; /&gt;, a value stored from a given thread will be available through &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Values&quot; /&gt; even after that thread has exited.">
        <see langword="true" />, alle Werte nachzuverfolgen, die für die Instanz festgelegt sind, und sie über die <see cref="P:System.Threading.ThreadLocal`1.Values" />-Eigenschaft verfügbar zu machen; andernfalls <see langword="false" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;valueFactory&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; reference (&lt;see langword=&quot;Nothing&quot; /&gt; in Visual Basic).">
        <paramref name="valueFactory" /> ist ein <see langword="null" />-Verweis (<see langword="Nothing" /> in Visual Basic).</exception>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; class.">Gibt alle von der aktuellen Instanz der <see cref="T:System.Threading.ThreadLocal`1" />-Klasse verwendeten Ressourcen frei.</summary>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.Dispose(System.Boolean)">
      <summary vsli:raw="Releases the resources used by this &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance.">Gibt die von dieser <see cref="T:System.Threading.ThreadLocal`1" />-Instanz verwendeten Ressourcen frei.</summary>
      <param name="disposing" vsli:raw="A Boolean value that indicates whether this method is being called due to a call to &lt;see cref=&quot;M:System.Threading.ThreadLocal`1.Dispose&quot; /&gt;.">Ein boolescher Wert, der angibt, ob diese Methode aufgrund eines Aufrufs von <see cref="M:System.Threading.ThreadLocal`1.Dispose" /> aufgerufen wird.</param>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.Finalize">
      <summary vsli:raw="Releases the resources used by this &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance.">Gibt die von dieser <see cref="T:System.Threading.ThreadLocal`1" />-Instanz verwendeten Ressourcen frei.</summary>
    </member>
    <member name="P:System.Threading.ThreadLocal`1.IsValueCreated">
      <summary vsli:raw="Gets whether &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Value&quot; /&gt; is initialized on the current thread.">Ruft einen Wert ab, der angibt, ob <see cref="P:System.Threading.ThreadLocal`1.Value" /> für den aktuellen Thread initialisiert wurde.</summary>
      <returns vsli:raw="true if &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Value&quot; /&gt; is initialized on the current thread; otherwise false.">True, wenn <see cref="P:System.Threading.ThreadLocal`1.Value" /> erfolgreich im aktuellen Thread initialisiert wurde, andernfalls false.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance has been disposed.">Die <see cref="T:System.Threading.ThreadLocal`1" />-Instanz wurde verworfen.</exception>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.ToString">
      <summary vsli:raw="Creates and returns a string representation of this instance for the current thread.">Erstellt eine Zeichenfolgendarstellung dieser Instanz für den aktuellen Thread und gibt sie zurück.</summary>
      <returns vsli:raw="The result of calling &lt;see cref=&quot;M:System.Object.ToString&quot; /&gt; on the &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Value&quot; /&gt;.">Das Ergebnis des Aufrufs von <see cref="M:System.Object.ToString" /> für <see cref="P:System.Threading.ThreadLocal`1.Value" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance has been disposed.">Die <see cref="T:System.Threading.ThreadLocal`1" />-Instanz wurde verworfen.</exception>
      <exception cref="T:System.NullReferenceException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Value&quot; /&gt; for the current thread is a null reference (Nothing in Visual Basic).">Der <see cref="P:System.Threading.ThreadLocal`1.Value" /> für den aktuellen Thread ist ein NULL-Verweis (Nothing in Visual Basic).</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The initialization function attempted to reference &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Value&quot; /&gt; recursively.">Die Initialisierungsfunktion versuchte, auf <see cref="P:System.Threading.ThreadLocal`1.Value" /> rekursiv zu verweisen.</exception>
      <exception cref="T:System.MissingMemberException" vsli:raw="No parameterless constructor is provided and no value factory is supplied.">Es werden weder ein Standardkonstruktor noch eine Wertfactory bereitgestellt.</exception>
    </member>
    <member name="P:System.Threading.ThreadLocal`1.Value">
      <summary vsli:raw="Gets or sets the value of this instance for the current thread.">Ruft den Wert dieser Instanz für den aktuellen Thread ab oder legt ihn fest.</summary>
      <returns vsli:raw="Returns an instance of the object that this ThreadLocal is responsible for initializing.">Gibt eine Instanz des Objekts zurück, für dessen Initialisierung dieser ThreadLocal zuständig ist.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance has been disposed.">Die <see cref="T:System.Threading.ThreadLocal`1" />-Instanz wurde verworfen.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The initialization function attempted to reference &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Value&quot; /&gt; recursively.">Die Initialisierungsfunktion versuchte, auf <see cref="P:System.Threading.ThreadLocal`1.Value" /> rekursiv zu verweisen.</exception>
      <exception cref="T:System.MissingMemberException" vsli:raw="No parameterless constructor is provided and no value factory is supplied.">Es werden weder ein Standardkonstruktor noch eine Wertfactory bereitgestellt.</exception>
    </member>
    <member name="P:System.Threading.ThreadLocal`1.Values">
      <summary vsli:raw="Gets a list containing the values stored by all threads that have accessed this instance.">Ruft eine Liste aller Werte ab, die aktuell von allen Threads, die auf diese Instanz zugegriffen haben, gespeichert werden.</summary>
      <returns vsli:raw="A list for all of the values stored by all of the threads that have accessed this instance.">Eine Liste aller Werte, die aktuell von allen Threads, die auf diese Instanz zugegriffen haben, gespeichert sind.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Values stored by all threads are not available because this instance was initialized with the &lt;paramref name=&quot;trackAllValues&quot; /&gt; argument set to &lt;see langword=&quot;false&quot; /&gt; in the call to a class constructor.">Werte, die von allen Threads gespeichert werden, sind nicht verfügbar, da diese Instanz mit dem <paramref name="trackAllValues" />-Argument initialisiert wurde, das beim Aufruf eines Klassenkonstruktors auf <see langword="false" /> festgelegt wurde.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance has been disposed.">Die <see cref="T:System.Threading.ThreadLocal`1" />-Instanz wurde verworfen.</exception>
    </member>
    <member name="T:System.Threading.Volatile">
      <summary vsli:raw="Contains methods for performing volatile memory operations.">Enthält Methoden zum Ausführen von flüchtigen Speichervorgängen.</summary>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Boolean@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Liest den Wert des angegebenen Felds. Führt auf Systemen, die dies erfordern, eine Arbeitsspeicherbegrenzung ein, die eine erneute Anforderung von Speichervorgängen durch den Prozessor verhindert. Dies geschieht wie folgt: Wenn nach dieser Methode im Code ein Lese- oder Schreibvorgang aufgeführt ist, kann der Prozessor diesen nicht vor diese Methode verschieben.</summary>
      <param name="location" vsli:raw="The field to read.">Das zu lesende Feld.</param>
      <returns vsli:raw="The value that was read.">Der gelesene Wert. Dieser Wert entspricht dem letzten von einem Prozessor im Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Byte@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Liest den Wert des angegebenen Felds. Führt auf Systemen, die dies erfordern, eine Arbeitsspeicherbegrenzung ein, die eine erneute Anforderung von Speichervorgängen durch den Prozessor verhindert. Dies geschieht wie folgt: Wenn nach dieser Methode im Code ein Lese- oder Schreibvorgang aufgeführt ist, kann der Prozessor diesen nicht vor diese Methode verschieben.</summary>
      <param name="location" vsli:raw="The field to read.">Das zu lesende Feld.</param>
      <returns vsli:raw="The value that was read.">Der gelesene Wert. Dieser Wert entspricht dem letzten von einem Prozessor im Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Double@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Liest den Wert des angegebenen Felds. Führt auf Systemen, die dies erfordern, eine Arbeitsspeicherbegrenzung ein, die eine erneute Anforderung von Speichervorgängen durch den Prozessor verhindert. Dies geschieht wie folgt: Wenn nach dieser Methode im Code ein Lese- oder Schreibvorgang aufgeführt ist, kann der Prozessor diesen nicht vor diese Methode verschieben.</summary>
      <param name="location" vsli:raw="The field to read.">Das zu lesende Feld.</param>
      <returns vsli:raw="The value that was read.">Der gelesene Wert. Dieser Wert entspricht dem letzten von einem Prozessor im Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Int16@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Liest den Wert des angegebenen Felds. Führt auf Systemen, die dies erfordern, eine Arbeitsspeicherbegrenzung ein, die eine erneute Anforderung von Speichervorgängen durch den Prozessor verhindert. Dies geschieht wie folgt: Wenn nach dieser Methode im Code ein Lese- oder Schreibvorgang aufgeführt ist, kann der Prozessor diesen nicht vor diese Methode verschieben.</summary>
      <param name="location" vsli:raw="The field to read.">Das zu lesende Feld.</param>
      <returns vsli:raw="The value that was read.">Der gelesene Wert. Dieser Wert entspricht dem letzten von einem Prozessor im Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Int32@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Liest den Wert des angegebenen Felds. Führt auf Systemen, die dies erfordern, eine Arbeitsspeicherbegrenzung ein, die eine erneute Anforderung von Speichervorgängen durch den Prozessor verhindert. Dies geschieht wie folgt: Wenn nach dieser Methode im Code ein Lese- oder Schreibvorgang aufgeführt ist, kann der Prozessor diesen nicht vor diese Methode verschieben.</summary>
      <param name="location" vsli:raw="The field to read.">Das zu lesende Feld.</param>
      <returns vsli:raw="The value that was read.">Der gelesene Wert. Dieser Wert entspricht dem letzten von einem Prozessor im Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Int64@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Liest den Wert des angegebenen Felds. Führt auf Systemen, die dies erfordern, eine Arbeitsspeicherbegrenzung ein, die eine erneute Anforderung von Speichervorgängen durch den Prozessor verhindert. Dies geschieht wie folgt: Wenn nach dieser Methode im Code ein Lese- oder Schreibvorgang aufgeführt ist, kann der Prozessor diesen nicht vor diese Methode verschieben.</summary>
      <param name="location" vsli:raw="The field to read.">Das zu lesende Feld.</param>
      <returns vsli:raw="The value that was read.">Der gelesene Wert. Dieser Wert entspricht dem letzten von einem Prozessor im Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.IntPtr@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Liest den Wert des angegebenen Felds. Führt auf Systemen, die dies erfordern, eine Arbeitsspeicherbegrenzung ein, die eine erneute Anforderung von Speichervorgängen durch den Prozessor verhindert. Dies geschieht wie folgt: Wenn nach dieser Methode im Code ein Lese- oder Schreibvorgang aufgeführt ist, kann der Prozessor diesen nicht vor diese Methode verschieben.</summary>
      <param name="location" vsli:raw="The field to read.">Das zu lesende Feld.</param>
      <returns vsli:raw="The value that was read.">Der gelesene Wert. Dieser Wert entspricht dem letzten von einem Prozessor im Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.SByte@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Liest den Wert des angegebenen Felds. Führt auf Systemen, die dies erfordern, eine Arbeitsspeicherbegrenzung ein, die eine erneute Anforderung von Speichervorgängen durch den Prozessor verhindert. Dies geschieht wie folgt: Wenn nach dieser Methode im Code ein Lese- oder Schreibvorgang aufgeführt ist, kann der Prozessor diesen nicht vor diese Methode verschieben.</summary>
      <param name="location" vsli:raw="The field to read.">Das zu lesende Feld.</param>
      <returns vsli:raw="The value that was read.">Der gelesene Wert. Dieser Wert entspricht dem letzten von einem Prozessor im Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Single@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Liest den Wert des angegebenen Felds. Führt auf Systemen, die dies erfordern, eine Arbeitsspeicherbegrenzung ein, die eine erneute Anforderung von Speichervorgängen durch den Prozessor verhindert. Dies geschieht wie folgt: Wenn nach dieser Methode im Code ein Lese- oder Schreibvorgang aufgeführt ist, kann der Prozessor diesen nicht vor diese Methode verschieben.</summary>
      <param name="location" vsli:raw="The field to read.">Das zu lesende Feld.</param>
      <returns vsli:raw="The value that was read.">Der gelesene Wert. Dieser Wert entspricht dem letzten von einem Prozessor im Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UInt16@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Liest den Wert des angegebenen Felds. Führt auf Systemen, die dies erfordern, eine Arbeitsspeicherbegrenzung ein, die eine erneute Anforderung von Speichervorgängen durch den Prozessor verhindert. Dies geschieht wie folgt: Wenn nach dieser Methode im Code ein Lese- oder Schreibvorgang aufgeführt ist, kann der Prozessor diesen nicht vor diese Methode verschieben.</summary>
      <param name="location" vsli:raw="The field to read.">Das zu lesende Feld.</param>
      <returns vsli:raw="The value that was read.">Der gelesene Wert. Dieser Wert entspricht dem letzten von einem Prozessor im Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UInt32@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Liest den Wert des angegebenen Felds. Führt auf Systemen, die dies erfordern, eine Arbeitsspeicherbegrenzung ein, die eine erneute Anforderung von Speichervorgängen durch den Prozessor verhindert. Dies geschieht wie folgt: Wenn nach dieser Methode im Code ein Lese- oder Schreibvorgang aufgeführt ist, kann der Prozessor diesen nicht vor diese Methode verschieben.</summary>
      <param name="location" vsli:raw="The field to read.">Das zu lesende Feld.</param>
      <returns vsli:raw="The value that was read.">Der gelesene Wert. Dieser Wert entspricht dem letzten von einem Prozessor im Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UInt64@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Liest den Wert des angegebenen Felds. Führt auf Systemen, die dies erfordern, eine Arbeitsspeicherbegrenzung ein, die eine erneute Anforderung von Speichervorgängen durch den Prozessor verhindert. Dies geschieht wie folgt: Wenn nach dieser Methode im Code ein Lese- oder Schreibvorgang aufgeführt ist, kann der Prozessor diesen nicht vor diese Methode verschieben.</summary>
      <param name="location" vsli:raw="The field to read.">Das zu lesende Feld.</param>
      <returns vsli:raw="The value that was read.">Der gelesene Wert. Dieser Wert entspricht dem letzten von einem Prozessor im Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UIntPtr@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Liest den Wert des angegebenen Felds. Führt auf Systemen, die dies erfordern, eine Arbeitsspeicherbegrenzung ein, die eine erneute Anforderung von Speichervorgängen durch den Prozessor verhindert. Dies geschieht wie folgt: Wenn nach dieser Methode im Code ein Lese- oder Schreibvorgang aufgeführt ist, kann der Prozessor diesen nicht vor diese Methode verschieben.</summary>
      <param name="location" vsli:raw="The field to read.">Das zu lesende Feld.</param>
      <returns vsli:raw="The value that was read.">Der gelesene Wert. Dieser Wert entspricht dem letzten von einem Prozessor im Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read``1(``0@)">
      <summary vsli:raw="Reads the object reference from the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Liest den Objektverweis aus dem angegebenen Feld. Führt auf Systemen, die dies erfordern, eine Arbeitsspeicherbegrenzung ein, die eine erneute Anforderung von Speichervorgängen durch den Prozessor verhindert. Dies geschieht wie folgt: Wenn nach dieser Methode im Code ein Lese- oder Schreibvorgang aufgeführt ist, kann der Prozessor diesen nicht vor diese Methode verschieben.</summary>
      <param name="location" vsli:raw="The field to read.">Das zu lesende Feld.</param>
      <typeparam name="T" vsli:raw="The type of field to read. This must be a reference type, not a value type.">Der Typ des zu lesenden Felds. Dabei muss es sich um einen Verweistyp und keinen Werttyp handeln.</typeparam>
      <returns vsli:raw="The reference to &lt;paramref name=&quot;T&quot; /&gt; that was read. This reference is the latest written by any processor in the computer, regardless of the number of processors or the state of processor cache.">Der Verweis auf <paramref name="T" />, der gelesen wurde. Dieser Verweis entspricht dem letzten von einem Prozessor im Computer geschriebenen Verweis, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Boolean@,System.Boolean)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Schreibt den angegebenen Wert in das angegebene Feld. Führt auf Systemen, die dies erfordern, eine Arbeitsspeicherbegrenzung ein, die eine erneute Anforderung von Speichervorgängen durch den Prozessor verhindert. Dies geschieht wie folgt: Wenn vor dieser Methode im Code ein Lese- oder Schreibvorgang aufgeführt ist, kann der Prozessor diesen nicht hinter diese Methode verschieben.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Das Feld, in das der Wert geschrieben wird.</param>
      <param name="value" vsli:raw="The value to write.">Der zu schreibende Wert. Der Wert wird sofort geschrieben, sodass er für alle Prozessoren im Computer sichtbar ist.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Byte@,System.Byte)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Schreibt den angegebenen Wert in das angegebene Feld. Führt auf Systemen, die dies erfordern, eine Arbeitsspeicherbegrenzung ein, die eine erneute Anforderung von Speichervorgängen durch den Prozessor verhindert. Dies geschieht wie folgt: Wenn vor dieser Methode im Code ein Lese- oder Schreibvorgang aufgeführt ist, kann der Prozessor diesen nicht hinter diese Methode verschieben.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Das Feld, in das der Wert geschrieben wird.</param>
      <param name="value" vsli:raw="The value to write.">Der zu schreibende Wert. Der Wert wird sofort geschrieben, sodass er für alle Prozessoren im Computer sichtbar ist.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Double@,System.Double)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Schreibt den angegebenen Wert in das angegebene Feld. Führt auf Systemen, die dies erfordern, eine Arbeitsspeicherbegrenzung ein, die eine erneute Anforderung von Speichervorgängen durch den Prozessor verhindert. Dies geschieht wie folgt: Wenn vor dieser Methode im Code ein Lese- oder Schreibvorgang aufgeführt ist, kann der Prozessor diesen nicht hinter diese Methode verschieben.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Das Feld, in das der Wert geschrieben wird.</param>
      <param name="value" vsli:raw="The value to write.">Der zu schreibende Wert. Der Wert wird sofort geschrieben, sodass er für alle Prozessoren im Computer sichtbar ist.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Int16@,System.Int16)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Schreibt den angegebenen Wert in das angegebene Feld. Führt auf Systemen, die dies erfordern, eine Arbeitsspeicherbegrenzung ein, die eine erneute Anforderung von Speichervorgängen durch den Prozessor verhindert. Dies geschieht wie folgt: Wenn vor dieser Methode im Code ein Lese- oder Schreibvorgang aufgeführt ist, kann der Prozessor diesen nicht hinter diese Methode verschieben.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Das Feld, in das der Wert geschrieben wird.</param>
      <param name="value" vsli:raw="The value to write.">Der zu schreibende Wert. Der Wert wird sofort geschrieben, sodass er für alle Prozessoren im Computer sichtbar ist.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Int32@,System.Int32)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Schreibt den angegebenen Wert in das angegebene Feld. Führt auf Systemen, die dies erfordern, eine Arbeitsspeicherbegrenzung ein, die eine erneute Anforderung von Speichervorgängen durch den Prozessor verhindert. Dies geschieht wie folgt: Wenn vor dieser Methode im Code ein Lese- oder Schreibvorgang aufgeführt ist, kann der Prozessor diesen nicht hinter diese Methode verschieben.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Das Feld, in das der Wert geschrieben wird.</param>
      <param name="value" vsli:raw="The value to write.">Der zu schreibende Wert. Der Wert wird sofort geschrieben, sodass er für alle Prozessoren im Computer sichtbar ist.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Int64@,System.Int64)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Schreibt den angegebenen Wert in das angegebene Feld. Führt auf Systemen, die dies erfordern, eine Arbeitsspeicherbegrenzung ein, die eine erneute Anforderung von Speichervorgängen durch den Prozessor verhindert. Dies geschieht wie folgt: Wenn vor dieser Methode im Code ein Lese- oder Schreibvorgang aufgeführt ist, kann der Prozessor diesen nicht hinter diese Methode verschieben.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Das Feld, in das der Wert geschrieben wird.</param>
      <param name="value" vsli:raw="The value to write.">Der zu schreibende Wert. Der Wert wird sofort geschrieben, sodass er für alle Prozessoren im Computer sichtbar ist.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.IntPtr@,System.IntPtr)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Schreibt den angegebenen Wert in das angegebene Feld. Führt auf Systemen, die dies erfordern, eine Arbeitsspeicherbegrenzung ein, die eine erneute Anforderung von Speichervorgängen durch den Prozessor verhindert. Dies geschieht wie folgt: Wenn vor dieser Methode im Code ein Lese- oder Schreibvorgang aufgeführt ist, kann der Prozessor diesen nicht hinter diese Methode verschieben.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Das Feld, in das der Wert geschrieben wird.</param>
      <param name="value" vsli:raw="The value to write.">Der zu schreibende Wert. Der Wert wird sofort geschrieben, sodass er für alle Prozessoren im Computer sichtbar ist.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.SByte@,System.SByte)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Schreibt den angegebenen Wert in das angegebene Feld. Führt auf Systemen, die dies erfordern, eine Arbeitsspeicherbegrenzung ein, die eine erneute Anforderung von Speichervorgängen durch den Prozessor verhindert. Dies geschieht wie folgt: Wenn vor dieser Methode im Code ein Lese- oder Schreibvorgang aufgeführt ist, kann der Prozessor diesen nicht hinter diese Methode verschieben.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Das Feld, in das der Wert geschrieben wird.</param>
      <param name="value" vsli:raw="The value to write.">Der zu schreibende Wert. Der Wert wird sofort geschrieben, sodass er für alle Prozessoren im Computer sichtbar ist.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Single@,System.Single)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Schreibt den angegebenen Wert in das angegebene Feld. Führt auf Systemen, die dies erfordern, eine Arbeitsspeicherbegrenzung ein, die eine erneute Anforderung von Speichervorgängen durch den Prozessor verhindert. Dies geschieht wie folgt: Wenn vor dieser Methode im Code ein Lese- oder Schreibvorgang aufgeführt ist, kann der Prozessor diesen nicht hinter diese Methode verschieben.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Das Feld, in das der Wert geschrieben wird.</param>
      <param name="value" vsli:raw="The value to write.">Der zu schreibende Wert. Der Wert wird sofort geschrieben, sodass er für alle Prozessoren im Computer sichtbar ist.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UInt16@,System.UInt16)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Schreibt den angegebenen Wert in das angegebene Feld. Führt auf Systemen, die dies erfordern, eine Arbeitsspeicherbegrenzung ein, die eine erneute Anforderung von Speichervorgängen durch den Prozessor verhindert. Dies geschieht wie folgt: Wenn vor dieser Methode im Code ein Lese- oder Schreibvorgang aufgeführt ist, kann der Prozessor diesen nicht hinter diese Methode verschieben.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Das Feld, in das der Wert geschrieben wird.</param>
      <param name="value" vsli:raw="The value to write.">Der zu schreibende Wert. Der Wert wird sofort geschrieben, sodass er für alle Prozessoren im Computer sichtbar ist.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UInt32@,System.UInt32)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Schreibt den angegebenen Wert in das angegebene Feld. Führt auf Systemen, die dies erfordern, eine Arbeitsspeicherbegrenzung ein, die eine erneute Anforderung von Speichervorgängen durch den Prozessor verhindert. Dies geschieht wie folgt: Wenn vor dieser Methode im Code ein Lese- oder Schreibvorgang aufgeführt ist, kann der Prozessor diesen nicht hinter diese Methode verschieben.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Das Feld, in das der Wert geschrieben wird.</param>
      <param name="value" vsli:raw="The value to write.">Der zu schreibende Wert. Der Wert wird sofort geschrieben, sodass er für alle Prozessoren im Computer sichtbar ist.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UInt64@,System.UInt64)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Schreibt den angegebenen Wert in das angegebene Feld. Führt auf Systemen, die dies erfordern, eine Arbeitsspeicherbegrenzung ein, die eine erneute Anforderung von Speichervorgängen durch den Prozessor verhindert. Dies geschieht wie folgt: Wenn vor dieser Methode im Code ein Lese- oder Schreibvorgang aufgeführt ist, kann der Prozessor diesen nicht hinter diese Methode verschieben.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Das Feld, in das der Wert geschrieben wird.</param>
      <param name="value" vsli:raw="The value to write.">Der zu schreibende Wert. Der Wert wird sofort geschrieben, sodass er für alle Prozessoren im Computer sichtbar ist.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UIntPtr@,System.UIntPtr)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Schreibt den angegebenen Wert in das angegebene Feld. Führt auf Systemen, die dies erfordern, eine Arbeitsspeicherbegrenzung ein, die eine erneute Anforderung von Speichervorgängen durch den Prozessor verhindert. Dies geschieht wie folgt: Wenn vor dieser Methode im Code ein Lese- oder Schreibvorgang aufgeführt ist, kann der Prozessor diesen nicht hinter diese Methode verschieben.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Das Feld, in das der Wert geschrieben wird.</param>
      <param name="value" vsli:raw="The value to write.">Der zu schreibende Wert. Der Wert wird sofort geschrieben, sodass er für alle Prozessoren im Computer sichtbar ist.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write``1(``0@,``0)">
      <summary vsli:raw="Writes the specified object reference to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Schreibt den angegebenen Objektverweis in das angegebene Feld. Führt auf Systemen, die dies erfordern, eine Arbeitsspeicherbegrenzung ein, die eine erneute Anforderung von Speichervorgängen durch den Prozessor verhindert. Dies geschieht wie folgt: Wenn vor dieser Methode im Code ein Lese- oder Schreibvorgang aufgeführt ist, kann der Prozessor diesen nicht hinter diese Methode verschieben.</summary>
      <param name="location" vsli:raw="The field where the object reference is written.">Das Feld, in das der Objektverweis geschrieben wird.</param>
      <param name="value" vsli:raw="The object reference to write.">Der zu schreibende Objektverweis. Der Verweis wird sofort geschrieben, sodass er für alle Prozessoren im Computer sichtbar ist.</param>
      <typeparam name="T" vsli:raw="The type of field to write. This must be a reference type, not a value type.">Der Typ des zu schreibenden Felds. Dabei muss es sich um einen Verweistyp und keinen Werttyp handeln.</typeparam>
    </member>
    <member name="T:System.Threading.WaitHandleCannotBeOpenedException">
      <summary vsli:raw="The exception that is thrown when an attempt is made to open a system mutex, semaphore, or event wait handle that does not exist.">Diese Ausnahme wird bei dem Versuch ausgelöst, ein nicht vorhandenes Systemmutex, Semaphor oder Wait-Handle eines Ereignisses zu öffnen.</summary>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.WaitHandleCannotBeOpenedException&quot; /&gt; class with default values.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" />-Klasse mit Standardwerten.</summary>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.WaitHandleCannotBeOpenedException&quot; /&gt; class with serialized data.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" />-Klasse mit serialisierten Daten.</summary>
      <param name="info" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.SerializationInfo&quot; /&gt; object that holds the serialized object data about the exception being thrown.">Das <see cref="T:System.Runtime.Serialization.SerializationInfo" />-Objekt, das die serialisierten Objektdaten für die ausgelöste Ausnahme enthält.</param>
      <param name="context" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.StreamingContext&quot; /&gt; object that contains contextual information about the source or destination.">Das <see cref="T:System.Runtime.Serialization.StreamingContext" />-Objekt, das die Kontextinformationen für die Quelle oder das Ziel enthält.</param>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor(System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.WaitHandleCannotBeOpenedException&quot; /&gt; class with a specified error message.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" />-Klasse mit einer angegebenen Fehlermeldung.</summary>
      <param name="message" vsli:raw="The error message that explains the reason for the exception.">Die Fehlermeldung, in der die Ursache der Ausnahme erklärt wird.</param>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor(System.String,System.Exception)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.WaitHandleCannotBeOpenedException&quot; /&gt; class with a specified error message and a reference to the inner exception that is the cause of this exception.">Initialisiert eine neue Instanz der <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" />-Klasse mit einer angegebenen Fehlermeldung und einem Verweis auf die innere Ausnahme, die diese Ausnahme ausgelöst hat.</summary>
      <param name="message" vsli:raw="The error message that explains the reason for the exception.">Die Fehlermeldung, in der die Ursache der Ausnahme erklärt wird.</param>
      <param name="innerException" vsli:raw="The exception that is the cause of the current exception. If the &lt;paramref name=&quot;innerException&quot; /&gt; parameter is not &lt;see langword=&quot;null&quot; /&gt;, the current exception is raised in a &lt;see langword=&quot;catch&quot; /&gt; block that handles the inner exception.">Die Ausnahme, die die Ursache der aktuellen Ausnahme ist. Wenn der <paramref name="innerException" />-Parameter nicht <see langword="null" /> ist, wird die aktuelle Ausnahme in einem <see langword="catch" />-Block ausgelöst, der die innere Ausnahme behandelt.</param>
    </member>
  </members>
</doc>