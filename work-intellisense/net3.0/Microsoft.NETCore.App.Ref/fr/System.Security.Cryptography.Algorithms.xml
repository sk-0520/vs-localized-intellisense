<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Security.Cryptography.Algorithms</name>
  </assembly>
  <members>
    <member name="T:System.Security.Cryptography.Aes">
      <summary>Représente la classe de base abstraite dont doivent hériter toutes les implémentations AES (Advanced Encryption Standard).</summary>
    </member>
    <member name="M:System.Security.Cryptography.Aes.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.Aes" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.Aes.Create">
      <summary>Crée un objet de chiffrement qui permet d’exécuter l’algorithme symétrique.</summary>
      <returns>Objet de chiffrement qui permet d’exécuter l’algorithme symétrique.</returns>
    </member>
    <member name="M:System.Security.Cryptography.Aes.Create(System.String)">
      <summary>Crée un objet de chiffrement qui spécifie l’implémentation d’AES à utiliser pour exécuter l’algorithme symétrique.</summary>
      <param name="algorithmName">Nom de l’implémentation spécifique d’AES à utiliser.</param>
      <returns>Objet de chiffrement qui permet d’exécuter l’algorithme symétrique.</returns>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="algorithmName" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="T:System.Security.Cryptography.AesCcm">
      <summary>Représente une clé AES (Advanced Encryption Standard) à utiliser avec le mode de fonctionnement CCM (Counter with CBC-MAC).</summary>
    </member>
    <member name="M:System.Security.Cryptography.AesCcm.#ctor(System.Byte[])">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.AesCcm" /> avec une clé fournie.</summary>
      <param name="key">Clé secrète à utiliser pour cette instance.</param>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="key" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La longueur du paramètre <paramref name="key" /> est autre que 16, 24 ou 32 octets (128, 192 ou 256 bits).</exception>
    </member>
    <member name="M:System.Security.Cryptography.AesCcm.#ctor(System.ReadOnlySpan{System.Byte})">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.AesCcm" /> avec une clé fournie.</summary>
      <param name="key">Clé secrète à utiliser pour cette instance.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La longueur du paramètre <paramref name="key" /> est autre que 16, 24 ou 32 octets (128, 192 ou 256 bits).</exception>
    </member>
    <member name="M:System.Security.Cryptography.AesCcm.Decrypt(System.Byte[],System.Byte[],System.Byte[],System.Byte[],System.Byte[])">
      <summary>Déchiffre le texte chiffré dans la mémoire tampon de destination fournie si la balise d’authentification peut être validée.</summary>
      <param name="nonce">Nonce associé à ce message, qui doit correspondre à la valeur fournie lors du chiffrement.</param>
      <param name="ciphertext">Contenu chiffré à déchiffrer.</param>
      <param name="tag">Balise d’authentification générée pour ce message lors du chiffrement.</param>
      <param name="plaintext">Tableau d’octets devant recevoir le contenu déchiffré.</param>
      <param name="associatedData">Données supplémentaires associées à ce message, qui doivent correspondre à la valeur fournie lors du chiffrement.</param>
      <exception cref="T:System.ArgumentException">Le paramètre <paramref name="plaintext" /> et le <paramref name="ciphertext" /> n’ont pas la même longueur.
ou
La longueur du paramètre <paramref name="nonce" /> n’est pas autorisée par <see cref="P:System.Security.Cryptography.AesCcm.NonceByteSizes" />.
ou
La longueur du paramètre <paramref name="tag" /> n’est pas autorisée par <see cref="P:System.Security.Cryptography.AesCcm.TagByteSizes" />.</exception>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="nonce" />, <paramref name="ciphertext" />, <paramref name="tag" /> ou <paramref name="plaintext" /> est <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La valeur de balise n’a pas pu être vérifiée, ou l’opération de déchiffrement a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.AesCcm.Decrypt(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.ReadOnlySpan{System.Byte})">
      <summary>Déchiffre le texte chiffré dans la mémoire tampon de destination fournie si la balise d’authentification peut être validée.</summary>
      <param name="nonce">Nonce associé à ce message, qui doit correspondre à la valeur fournie lors du chiffrement.</param>
      <param name="ciphertext">Contenu chiffré à déchiffrer.</param>
      <param name="tag">Balise d’authentification générée pour ce message lors du chiffrement.</param>
      <param name="plaintext">Plage d’octets devant recevoir le contenu déchiffré.</param>
      <param name="associatedData">Données supplémentaires associées à ce message, qui doivent correspondre à la valeur fournie lors du chiffrement.</param>
      <exception cref="T:System.ArgumentException">Le paramètre <paramref name="plaintext" /> et le <paramref name="ciphertext" /> n’ont pas la même longueur.

ou -

La longueur du paramètre <paramref name="nonce" /> n’est pas autorisée par <see cref="P:System.Security.Cryptography.AesCcm.NonceByteSizes" />.

ou -

La longueur du paramètre <paramref name="tag" /> n’est pas autorisée par <see cref="P:System.Security.Cryptography.AesCcm.TagByteSizes" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La valeur de balise n’a pas pu être vérifiée, ou l’opération de déchiffrement a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.AesCcm.Dispose">
      <summary>Libère les ressources utilisées par l'instance actuelle de la classe <see cref="T:System.Security.Cryptography.AesCcm" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AesCcm.Encrypt(System.Byte[],System.Byte[],System.Byte[],System.Byte[],System.Byte[])">
      <summary>Chiffre le texte en clair dans la mémoire tampon de destination du texte chiffré et génère la balise d’authentification dans une mémoire tampon distincte.</summary>
      <param name="nonce">Nonce associé à ce message, qui doit être une valeur unique pour chaque opération avec la même clé.</param>
      <param name="plaintext">Contenu à chiffrer.</param>
      <param name="ciphertext">Tableau d’octets devant recevoir le contenu chiffré.</param>
      <param name="tag">Tableau d’octets devant recevoir la balise d’authentification générée.</param>
      <param name="associatedData">Données supplémentaires associées à ce message, qui doivent également être fournies au cours du déchiffrement.</param>
      <exception cref="T:System.ArgumentException">Le paramètre <paramref name="plaintext" /> et le <paramref name="ciphertext" /> n’ont pas la même longueur.

ou -

La longueur du paramètre <paramref name="nonce" /> n’est pas autorisée par <see cref="P:System.Security.Cryptography.AesCcm.NonceByteSizes" />.

ou -

La longueur du paramètre <paramref name="tag" /> n’est pas autorisée par <see cref="P:System.Security.Cryptography.AesCcm.TagByteSizes" />.</exception>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="nonce" />, <paramref name="ciphertext" />, <paramref name="tag" /> ou <paramref name="plaintext" /> est <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">L’opération de chiffrement a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.AesCcm.Encrypt(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Span{System.Byte},System.ReadOnlySpan{System.Byte})">
      <summary>Chiffre le texte en clair dans la mémoire tampon de destination du texte chiffré et génère la balise d’authentification dans une mémoire tampon distincte.</summary>
      <param name="nonce">Nonce associé à ce message, qui doit être une valeur unique pour chaque opération avec la même clé.</param>
      <param name="plaintext">Contenu à chiffrer.</param>
      <param name="ciphertext">Plage d’octets devant recevoir le contenu chiffré.</param>
      <param name="tag">Plage d’octets devant recevoir la balise d’authentification générée.</param>
      <param name="associatedData">Données supplémentaires associées à ce message, qui doivent également être fournies au cours du déchiffrement.</param>
      <exception cref="T:System.ArgumentException">Le paramètre <paramref name="plaintext" /> et le <paramref name="ciphertext" /> n’ont pas la même longueur.
ou
La longueur du paramètre <paramref name="nonce" /> n’est pas autorisée par <see cref="P:System.Security.Cryptography.AesCcm.NonceByteSizes" />.

ou -

La longueur du paramètre <paramref name="tag" /> n’est pas autorisée par <see cref="P:System.Security.Cryptography.AesCcm.TagByteSizes" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">L’opération de chiffrement a échoué.</exception>
    </member>
    <member name="P:System.Security.Cryptography.AesCcm.NonceByteSizes">
      <summary>Obtient les tailles des nonces, en octets, prises en charge par cette instance.</summary>
      <returns>Tailles de nonce prises en charge par cette instance: 7, 8, 9, 10, 11, 12 ou 13 octets (56, 64, 72, 80, 88, 96 ou 104 bits).</returns>
    </member>
    <member name="P:System.Security.Cryptography.AesCcm.TagByteSizes">
      <summary>Obtient les tailles des balises, en octets, prises en charge par cette instance.</summary>
      <returns>Tailles des balises prises en charge par cette instance: 4, 6, 8, 10, 12, 14 ou 16 octets (32, 48, 64, 80, 96, 112 ou 128 bits).</returns>
    </member>
    <member name="T:System.Security.Cryptography.AesGcm">
      <summary>Représente une clé AES (Advanced Encryption Standard) à utiliser avec le mode de fonctionnement GCM (Galois/Counter Mode).</summary>
    </member>
    <member name="M:System.Security.Cryptography.AesGcm.#ctor(System.Byte[])">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.AesGcm" /> avec une clé fournie.</summary>
      <param name="key">Clé secrète à utiliser pour cette instance.</param>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="key" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La longueur du paramètre <paramref name="key" /> est autre que 16, 24 ou 32 octets (128, 192 ou 256 bits).</exception>
    </member>
    <member name="M:System.Security.Cryptography.AesGcm.#ctor(System.ReadOnlySpan{System.Byte})">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.AesGcm" /> avec une clé fournie.</summary>
      <param name="key">Clé secrète à utiliser pour cette instance.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La longueur du paramètre <paramref name="key" /> est autre que 16, 24 ou 32 octets (128, 192 ou 256 bits).</exception>
    </member>
    <member name="M:System.Security.Cryptography.AesGcm.Decrypt(System.Byte[],System.Byte[],System.Byte[],System.Byte[],System.Byte[])">
      <summary>Déchiffre le texte chiffré dans la mémoire tampon de destination fournie si la balise d’authentification peut être validée.</summary>
      <param name="nonce">Nonce associé à ce message, qui doit correspondre à la valeur fournie lors du chiffrement.</param>
      <param name="ciphertext">Contenu chiffré à déchiffrer.</param>
      <param name="tag">Balise d’authentification générée pour ce message lors du chiffrement.</param>
      <param name="plaintext">Tableau d’octets devant recevoir le contenu déchiffré.</param>
      <param name="associatedData">Données supplémentaires associées à ce message, qui doivent correspondre à la valeur fournie lors du chiffrement.</param>
      <exception cref="T:System.ArgumentException">Le paramètre <paramref name="plaintext" /> et le <paramref name="ciphertext" /> n’ont pas la même longueur.

ou -

La longueur du paramètre <paramref name="nonce" /> n’est pas autorisée par <see cref="P:System.Security.Cryptography.AesGcm.NonceByteSizes" />.
ou
La longueur du paramètre <paramref name="tag" /> n’est pas autorisée par <see cref="P:System.Security.Cryptography.AesGcm.TagByteSizes" />.</exception>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="nonce" />, <paramref name="ciphertext" />, <paramref name="tag" /> ou <paramref name="plaintext" /> est <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La valeur de balise n’a pas pu être vérifiée, ou l’opération de déchiffrement a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.AesGcm.Decrypt(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.ReadOnlySpan{System.Byte})">
      <summary>Déchiffre le texte chiffré dans la mémoire tampon de destination fournie si la balise d’authentification peut être validée.</summary>
      <param name="nonce">Nonce associé à ce message, qui doit correspondre à la valeur fournie lors du chiffrement.</param>
      <param name="ciphertext">Contenu chiffré à déchiffrer.</param>
      <param name="tag">Balise d’authentification générée pour ce message lors du chiffrement.</param>
      <param name="plaintext">Plage d’octets devant recevoir le contenu déchiffré.</param>
      <param name="associatedData">Données supplémentaires associées à ce message, qui doivent correspondre à la valeur fournie lors du chiffrement.</param>
      <exception cref="T:System.ArgumentException">Le paramètre <paramref name="plaintext" /> et le <paramref name="ciphertext" /> n’ont pas la même longueur.

ou -

La longueur du paramètre <paramref name="nonce" /> n’est pas autorisée par <see cref="P:System.Security.Cryptography.AesGcm.NonceByteSizes" />.

ou -

La longueur du paramètre <paramref name="tag" /> n’est pas autorisée par <see cref="P:System.Security.Cryptography.AesGcm.TagByteSizes" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La valeur de balise n’a pas pu être vérifiée, ou l’opération de déchiffrement a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.AesGcm.Dispose">
      <summary>Libère les ressources utilisées par l'instance actuelle de la classe <see cref="T:System.Security.Cryptography.AesGcm" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AesGcm.Encrypt(System.Byte[],System.Byte[],System.Byte[],System.Byte[],System.Byte[])">
      <summary>Chiffre le texte en clair dans la mémoire tampon de destination du texte chiffré et génère la balise d’authentification dans une mémoire tampon distincte.</summary>
      <param name="nonce">Nonce associé à ce message, qui doit être une valeur unique pour chaque opération avec la même clé.</param>
      <param name="plaintext">Contenu à chiffrer.</param>
      <param name="ciphertext">Tableau d’octets devant recevoir le contenu chiffré.</param>
      <param name="tag">Tableau d’octets devant recevoir la balise d’authentification générée.</param>
      <param name="associatedData">Données supplémentaires associées à ce message, qui doivent également être fournies au cours du déchiffrement.</param>
      <exception cref="T:System.ArgumentException">Le paramètre <paramref name="plaintext" /> et le <paramref name="ciphertext" /> n’ont pas la même longueur.
ou
La longueur du paramètre <paramref name="nonce" /> n’est pas autorisée par <see cref="P:System.Security.Cryptography.AesGcm.NonceByteSizes" />.

ou -

La longueur du paramètre <paramref name="tag" /> n’est pas autorisée par <see cref="P:System.Security.Cryptography.AesGcm.TagByteSizes" />.</exception>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="nonce" />, <paramref name="ciphertext" />, <paramref name="tag" /> ou <paramref name="plaintext" /> est <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">L’opération de chiffrement a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.AesGcm.Encrypt(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Span{System.Byte},System.ReadOnlySpan{System.Byte})">
      <summary>Chiffre le texte en clair dans la mémoire tampon de destination du texte chiffré et génère la balise d’authentification dans une mémoire tampon distincte.</summary>
      <param name="nonce">Nonce associé à ce message, qui doit être une valeur unique pour chaque opération avec la même clé.</param>
      <param name="plaintext">Contenu à chiffrer.</param>
      <param name="ciphertext">Tableau d’octets devant recevoir le contenu chiffré.</param>
      <param name="tag">Tableau d’octets devant recevoir la balise d’authentification générée.</param>
      <param name="associatedData">Données supplémentaires associées à ce message, qui doivent également être fournies au cours du déchiffrement.</param>
      <exception cref="T:System.ArgumentException">Le paramètre <paramref name="plaintext" /> et le <paramref name="ciphertext" /> n’ont pas la même longueur.
ou
La longueur du paramètre <paramref name="nonce" /> n’est pas autorisée par <see cref="P:System.Security.Cryptography.AesGcm.NonceByteSizes" />.
ou
La longueur du paramètre <paramref name="tag" /> n’est pas autorisée par <see cref="P:System.Security.Cryptography.AesGcm.TagByteSizes" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">L’opération de chiffrement a échoué.</exception>
    </member>
    <member name="P:System.Security.Cryptography.AesGcm.NonceByteSizes">
      <summary>Obtient les tailles des nonces, en octets, prises en charge par cette instance.</summary>
      <returns>Tailles de nonce prises en charge par cette instance: 12 octets (96 bits).</returns>
    </member>
    <member name="P:System.Security.Cryptography.AesGcm.TagByteSizes">
      <summary>Obtient les tailles des balises, en octets, prises en charge par cette instance.</summary>
      <returns>Tailles des balises prises en charge par cette instance: 12, 13, 14, 15 ou 16 octets (96, 104, 112, 120 ou 128 bits).</returns>
    </member>
    <member name="T:System.Security.Cryptography.AesManaged">
      <summary>Fournit une implémentation managée de l'algorithme symétrique AES (Advanced Encryption Standard).</summary>
    </member>
    <member name="M:System.Security.Cryptography.AesManaged.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.AesManaged" />.</summary>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le paramètre de stratégie de sécurité Windows pour FIPS est activé.</exception>
      <exception cref="T:System.InvalidOperationException">Cette implémentation ne fait pas partie des algorithmes de chiffrement validés FIPS pour les plateformes Windows.</exception>
    </member>
    <member name="P:System.Security.Cryptography.AesManaged.BlockSize">
      <summary>Obtient ou définit la taille de bloc, en bits, de l'opération de chiffrement.</summary>
      <returns>Taille de bloc, en bits, de l’opération de chiffrement. La valeur par défaut est 128 bits.</returns>
    </member>
    <member name="M:System.Security.Cryptography.AesManaged.CreateDecryptor">
      <summary>Crée un objet déchiffreur symétrique avec la clé et le vecteur d'initialisation actuels.</summary>
      <returns>Objet déchiffreur symétrique.</returns>
    </member>
    <member name="M:System.Security.Cryptography.AesManaged.CreateDecryptor(System.Byte[],System.Byte[])">
      <summary>Crée un objet déchiffreur symétrique avec la clé et le vecteur d'initialisation spécifiés.</summary>
      <param name="rgbKey">Clé secrète à utiliser pour l'algorithme symétrique.</param>
      <param name="rgbIV">Vecteur d'initialisation à utiliser pour l'algorithme symétrique.</param>
      <returns>Objet déchiffreur symétrique.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> ou <paramref name="iv" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="key" /> n'est pas valide.</exception>
    </member>
    <member name="M:System.Security.Cryptography.AesManaged.CreateEncryptor">
      <summary>Crée un objet chiffreur symétrique avec la clé et le vecteur d'initialisation actuels.</summary>
      <returns>Objet chiffreur symétrique.</returns>
    </member>
    <member name="M:System.Security.Cryptography.AesManaged.CreateEncryptor(System.Byte[],System.Byte[])">
      <summary>Crée un objet chiffreur symétrique avec la clé et le vecteur d'initialisation spécifiés.</summary>
      <param name="rgbKey">Clé secrète à utiliser pour l'algorithme symétrique.</param>
      <param name="rgbIV">Vecteur d'initialisation à utiliser pour l'algorithme symétrique.</param>
      <returns>Objet chiffreur symétrique.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> ou <paramref name="iv" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="key" /> n'est pas valide.</exception>
    </member>
    <member name="P:System.Security.Cryptography.AesManaged.FeedbackSize">
      <summary>Obtient ou définit le nombre de bits à utiliser en commentaires.</summary>
      <returns>Taille des commentaires, en bits.</returns>
    </member>
    <member name="M:System.Security.Cryptography.AesManaged.GenerateIV">
      <summary>Génère un vecteur d'initialisation aléatoire à utiliser pour l'algorithme symétrique.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AesManaged.GenerateKey">
      <summary>Génère une clé aléatoire à utiliser pour l'algorithme symétrique.</summary>
    </member>
    <member name="P:System.Security.Cryptography.AesManaged.IV">
      <summary>Obtient ou définit le vecteur d'initialisation à utiliser pour l'algorithme symétrique.</summary>
      <returns>Le vecteur d'initialisation à utiliser pour l'algorithme symétrique.</returns>
    </member>
    <member name="P:System.Security.Cryptography.AesManaged.Key">
      <summary>Obtient ou définit la clé secrète utilisée pour l'algorithme symétrique.</summary>
      <returns>La clé à utiliser pour l'algorithme symétrique.</returns>
    </member>
    <member name="P:System.Security.Cryptography.AesManaged.KeySize">
      <summary>Obtient ou définit la taille, en bits, de la clé secrète utilisée pour l'algorithme symétrique.</summary>
      <returns>Taille, en bits, de la clé utilisée par l'algorithme symétrique.</returns>
    </member>
    <member name="P:System.Security.Cryptography.AesManaged.LegalBlockSizes">
      <summary>Obtient les tailles de bloc, en octets, prises en charge par l'algorithme symétrique.</summary>
      <returns>Tailles de bloc, en bits, prises en charge par l’algorithme symétrique.</returns>
    </member>
    <member name="P:System.Security.Cryptography.AesManaged.LegalKeySizes">
      <summary>Obtient les tailles de clé, en octets, prises en charge par l'algorithme symétrique.</summary>
      <returns>Tailles de clé, en bits, prises en charge par l’algorithme symétrique.</returns>
    </member>
    <member name="P:System.Security.Cryptography.AesManaged.Mode">
      <summary>Obtient ou définit le mode de fonctionnement pour l'algorithme symétrique.</summary>
      <returns>Une des valeurs d'énumération qui spécifie le mode de chiffrement par blocs à utiliser pour le chiffrement. La valeur par défaut est <see cref="F:System.Security.Cryptography.CipherMode.CBC" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <see cref="P:System.Security.Cryptography.AesManaged.Mode" /> a la valeur <see cref="F:System.Security.Cryptography.CipherMode.CFB" /> ou <see cref="F:System.Security.Cryptography.CipherMode.OFB" />.</exception>
    </member>
    <member name="P:System.Security.Cryptography.AesManaged.Padding">
      <summary>Obtient ou définit le mode de remplissage utilisé dans l'algorithme symétrique.</summary>
      <returns>Une des valeurs d'énumération qui spécifie le type de remplissage à appliquer. La valeur par défaut est <see cref="F:System.Security.Cryptography.PaddingMode.PKCS7" />.</returns>
    </member>
    <member name="T:System.Security.Cryptography.AsymmetricKeyExchangeDeformatter">
      <summary>Représente la classe de base dont dérivent tous les déformateurs d’échange de clés asymétriques.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricKeyExchangeDeformatter.#ctor">
      <summary>Initialise une nouvelle instance de <see cref="T:System.Security.Cryptography.AsymmetricKeyExchangeDeformatter" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricKeyExchangeDeformatter.DecryptKeyExchange(System.Byte[])">
      <summary>En cas de substitution dans une classe dérivée, extrait des informations confidentielles à partir des données d’échange de clés chiffrées.</summary>
      <param name="rgb">Données d’échange de clés dans lesquelles les informations confidentielles sont cachées.</param>
      <returns>Informations confidentielles dérivées des données d’échange de clés.</returns>
    </member>
    <member name="P:System.Security.Cryptography.AsymmetricKeyExchangeDeformatter.Parameters">
      <summary>En cas de substitution dans une classe dérivée, obtient ou définit les paramètres pour l’échange de clés asymétriques.</summary>
      <returns>Chaîne au format XML contenant les paramètres de l’opération d’échange de clés asymétriques.</returns>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricKeyExchangeDeformatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>En cas de substitution dans une classe dérivée, définit la clé privée à utiliser pour déchiffrer les informations confidentielles.</summary>
      <param name="key">Instance de l'implémentation de <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" /> qui contient la clé privée.</param>
    </member>
    <member name="T:System.Security.Cryptography.AsymmetricKeyExchangeFormatter">
      <summary>Représente la classe de base dont dérivent tous les formateurs d’échange de clés asymétriques.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricKeyExchangeFormatter.#ctor">
      <summary>Initialise une nouvelle instance de <see cref="T:System.Security.Cryptography.AsymmetricKeyExchangeFormatter" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricKeyExchangeFormatter.CreateKeyExchange(System.Byte[])">
      <summary>En cas de substitution dans une classe dérivée, crée les données d’échange de clés chiffrées à partir des données d’entrée spécifiées.</summary>
      <param name="data">Informations confidentielles à passer dans l’échange de clés.</param>
      <returns>Données d’échange de clés chiffrées à envoyer au destinataire prévu.</returns>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricKeyExchangeFormatter.CreateKeyExchange(System.Byte[],System.Type)">
      <summary>En cas de substitution dans une classe dérivée, crée les données d’échange de clés chiffrées à partir des données d’entrée spécifiées.</summary>
      <param name="data">Informations confidentielles à passer dans l’échange de clés.</param>
      <param name="symAlgType">Ce paramètre n’est pas utilisé dans la version actuelle.</param>
      <returns>Données d’échange de clés chiffrées à envoyer au destinataire prévu.</returns>
    </member>
    <member name="P:System.Security.Cryptography.AsymmetricKeyExchangeFormatter.Parameters">
      <summary>En cas de substitution dans une classe dérivée, obtient les paramètres pour l'échange de clés asymétriques.</summary>
      <returns>Chaîne au format XML contenant les paramètres de l’opération d’échange de clés asymétriques.</returns>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricKeyExchangeFormatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>En cas de substitution dans une classe dérivée, définit la clé publique à utiliser pour chiffrer les informations confidentielles.</summary>
      <param name="key">Instance de l'implémentation de <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" /> qui contient la clé publique.</param>
    </member>
    <member name="T:System.Security.Cryptography.AsymmetricSignatureDeformatter">
      <summary>Représente la classe de base abstraite dont toutes les implémentations des modules de déformatage de signature asymétriques dérivent.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricSignatureDeformatter.#ctor">
      <summary>Initialise une nouvelle instance de <see cref="T:System.Security.Cryptography.AsymmetricSignatureDeformatter" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricSignatureDeformatter.SetHashAlgorithm(System.String)">
      <summary>En cas de substitution dans une classe dérivée, définit l'algorithme de hachage à utiliser pour vérifier la signature.</summary>
      <param name="strName">Nom de l'algorithme de hachage à utiliser pour vérifier la signature.</param>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricSignatureDeformatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>En cas de substitution dans une classe dérivée, définit la clé publique à utiliser pour vérifier la signature.</summary>
      <param name="key">Instance d'une implémentation de <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" /> qui contient la clé publique.</param>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricSignatureDeformatter.VerifySignature(System.Byte[],System.Byte[])">
      <summary>En cas de substitution dans une classe dérivée, vérifie la signature pour les données spécifiées.</summary>
      <param name="rgbHash">Données signées avec <paramref name="rgbSignature" />.</param>
      <param name="rgbSignature">Signature qui doit être vérifiée pour <paramref name="rgbHash" />.</param>
      <returns>
        <see langword="true" /> si <paramref name="rgbSignature" /> correspond à la signature calculée à l'aide de l'algorithme de hachage et de la clé spécifiés sur <paramref name="rgbHash" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricSignatureDeformatter.VerifySignature(System.Security.Cryptography.HashAlgorithm,System.Byte[])">
      <summary>Vérifie la signature à partir de la valeur de hachage spécifiée.</summary>
      <param name="hash">Algorithme de hachage à utiliser pour vérifier la signature.</param>
      <param name="rgbSignature">Signature qui doit être vérifiée.</param>
      <returns>
        <see langword="true" /> si la signature est valide pour le hachage ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="hash" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="T:System.Security.Cryptography.AsymmetricSignatureFormatter">
      <summary>Représente la classe de base dont toutes les implémentations des formateurs de signatures asymétriques dérivent.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricSignatureFormatter.#ctor">
      <summary>Initialise une nouvelle instance de <see cref="T:System.Security.Cryptography.AsymmetricSignatureFormatter" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricSignatureFormatter.CreateSignature(System.Byte[])">
      <summary>En cas de substitution dans une classe dérivée, crée la signature pour les données spécifiées.</summary>
      <param name="rgbHash">Données à signer.</param>
      <returns>Signature numérique pour le paramètre <paramref name="rgbHash" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricSignatureFormatter.CreateSignature(System.Security.Cryptography.HashAlgorithm)">
      <summary>Crée la signature à partir de la valeur de hachage spécifiée.</summary>
      <param name="hash">Algorithme de hachage à utiliser pour créer la signature.</param>
      <returns>Signature pour la valeur de hachage spécifiée.</returns>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="hash" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricSignatureFormatter.SetHashAlgorithm(System.String)">
      <summary>En cas de substitution dans une classe dérivée, définit l'algorithme de hachage à utiliser pour créer la signature.</summary>
      <param name="strName">Nom de l'algorithme de hachage à utiliser pour créer la signature.</param>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricSignatureFormatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>En cas de substitution dans une classe dérivée, définit l'algorithme asymétrique à utiliser pour créer la signature.</summary>
      <param name="key">Instance de l'implémentation de <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" /> à utiliser pour créer la signature.</param>
    </member>
    <member name="T:System.Security.Cryptography.CryptoConfig">
      <summary>Accède aux informations de configuration du chiffrement.</summary>
    </member>
    <member name="M:System.Security.Cryptography.CryptoConfig.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.CryptoConfig" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.CryptoConfig.AddAlgorithm(System.Type,System.String[])">
      <summary>Ajoute un ensemble de noms aux mappages d'algorithmes à utiliser pour le domaine d'application actuel.</summary>
      <param name="algorithm">Algorithme auquel mapper.</param>
      <param name="names">Tableau de noms à mapper à l'algorithme.</param>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="algorithm" /> ou <paramref name="names" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="algorithm" /> n'est pas accessible en dehors de l'assembly.  

ou - 
L'une des entrées dans le paramètre <paramref name="names" /> est vide ou <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.CryptoConfig.AddOID(System.String,System.String[])">
      <summary>Ajoute un ensemble de noms aux mappages d'identificateurs d'objets (OID) à utiliser pour le domaine d'application actuel.</summary>
      <param name="oid">Identificateur d'objet (OID) auquel mapper.</param>
      <param name="names">Tableau de noms à mapper à l'OID.</param>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="oid" /> ou <paramref name="names" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">L'une des entrées dans le paramètre <paramref name="names" /> est vide ou <see langword="null" />.</exception>
    </member>
    <member name="P:System.Security.Cryptography.CryptoConfig.AllowOnlyFipsAlgorithms">
      <summary>Indique si le runtime doit appliquer la stratégie pour créer uniquement des algorithmes certifiés FIPS (Federal Information Processing Standard).</summary>
      <returns>
        <see langword="true" /> pour appliquer la stratégie; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.CryptoConfig.CreateFromName(System.String)">
      <summary>Crée une nouvelle instance de l'objet de chiffrement spécifié.</summary>
      <param name="name">Nom simple de l'objet de chiffrement dont une instance doit être créée.</param>
      <returns>Nouvelle instance de l'objet de chiffrement spécifié.</returns>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="name" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">L'algorithme décrit par le paramètre <paramref name="name" /> a été utilisé avec mode FIPS activé, mais n'est pas compatible FIPS.</exception>
    </member>
    <member name="M:System.Security.Cryptography.CryptoConfig.CreateFromName(System.String,System.Object[])">
      <summary>Crée une nouvelle instance de l'objet de chiffrement spécifié avec les arguments spécifiés.</summary>
      <param name="name">Nom simple de l'objet de chiffrement dont une instance doit être créée.</param>
      <param name="args">Arguments utilisés pour créer l'objet de chiffrement spécifié.</param>
      <returns>Nouvelle instance de l'objet de chiffrement spécifié.</returns>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="name" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">L'algorithme décrit par le paramètre <paramref name="name" /> a été utilisé avec mode FIPS activé, mais n'est pas compatible FIPS.</exception>
    </member>
    <member name="M:System.Security.Cryptography.CryptoConfig.EncodeOID(System.String)">
      <summary>Encode l'identificateur de l'objet spécifié (OID, Object Identifier).</summary>
      <param name="str">OID à encoder.</param>
      <returns>Tableau d'octets contenant l'OID encodé.</returns>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="str" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicUnexpectedOperationException">Une erreur s'est produite lors de l'encodage de l'OID.</exception>
    </member>
    <member name="M:System.Security.Cryptography.CryptoConfig.MapNameToOID(System.String)">
      <summary>Obtient l'identificateur de l'objet (OID) de l'algorithme correspondant au nom simple spécifié.</summary>
      <param name="name">Nom simple de l'algorithme pour lequel l'OID doit être obtenu.</param>
      <returns>OID de l'algorithme spécifié.</returns>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="name" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="T:System.Security.Cryptography.DeriveBytes">
      <summary>Représente la classe de base abstraite dont héritent toutes les classes qui dérivent des séquences d'octets d'une longueur spécifiée.</summary>
    </member>
    <member name="M:System.Security.Cryptography.DeriveBytes.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.DeriveBytes" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.DeriveBytes.Dispose">
      <summary>En cas de substitution dans une classe dérivée, libère toutes les ressources utilisées par l’instance actuelle de la classe <see cref="T:System.Security.Cryptography.DeriveBytes" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.DeriveBytes.Dispose(System.Boolean)">
      <summary>En cas de substitution dans une classe dérivée, libère les ressources non managées utilisées par la classe <see cref="T:System.Security.Cryptography.DeriveBytes" /> et libère éventuellement les ressources managées.</summary>
      <param name="disposing">
        <see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour libérer uniquement les ressources non managées.</param>
    </member>
    <member name="M:System.Security.Cryptography.DeriveBytes.GetBytes(System.Int32)">
      <summary>En cas de substitution dans une classe dérivée, retourne des octets de clé pseudo-aléatoires.</summary>
      <param name="cb">Nombre d'octets de clé pseudo-aléatoires à générer.</param>
      <returns>Tableau d'octets rempli avec des octets de clé pseudo-aléatoires.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DeriveBytes.Reset">
      <summary>En cas de substitution dans une classe dérivée, rétablit l'état de l'opération.</summary>
    </member>
    <member name="T:System.Security.Cryptography.DES">
      <summary>Représente la classe de base pour l'algorithme DES (Data Encryption Standard) dont toutes les implémentations <see cref="T:System.Security.Cryptography.DES" /> doivent dériver.</summary>
    </member>
    <member name="M:System.Security.Cryptography.DES.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.DES" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.DES.Create">
      <summary>Crée une instance d’un objet de chiffrement pour exécuter l’algorithme Data Encryption Standard (<see cref="T:System.Security.Cryptography.DES" />).</summary>
      <returns>Objet de chiffrement.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DES.Create(System.String)">
      <summary>Crée une instance d'un objet de chiffrement pour exécuter l'implémentation spécifiée de l'algorithme Data Encryption Standard (<see cref="T:System.Security.Cryptography.DES" />).</summary>
      <param name="algName">Nom de l'implémentation spécifique de <see cref="T:System.Security.Cryptography.DES" /> à utiliser.</param>
      <returns>Objet de chiffrement.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DES.IsSemiWeakKey(System.Byte[])">
      <summary>Détermine si la clé spécifiée est semi-faible.</summary>
      <param name="rgbKey">Clé secrète dont la semi-faiblesse doit être testée.</param>
      <returns>
        <see langword="true" /> si la clé est semi-faible ; sinon <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La taille du paramètre <paramref name="rgbKey" /> n'est pas valide.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DES.IsWeakKey(System.Byte[])">
      <summary>Détermine si la clé spécifiée est faible.</summary>
      <param name="rgbKey">Clé secrète dont la faiblesse doit être testée.</param>
      <returns>
        <see langword="true" /> si la clé est faible ; sinon <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La taille du paramètre <paramref name="rgbKey" /> n'est pas valide.</exception>
    </member>
    <member name="P:System.Security.Cryptography.DES.Key">
      <summary>Obtient ou définit la clé secrète pour l'algorithme Data Encryption Standard (<see cref="T:System.Security.Cryptography.DES" />).</summary>
      <returns>Clé secrète pour l'algorithme <see cref="T:System.Security.Cryptography.DES" />.</returns>
      <exception cref="T:System.ArgumentNullException">Une tentative d'affecter la valeur <see langword="null" /> à la clé a été effectuée.</exception>
      <exception cref="T:System.ArgumentException">Une tentative de définition d'une clé dont la longueur n'est pas égale à <see cref="F:System.Security.Cryptography.SymmetricAlgorithm.BlockSizeValue" /> a été effectuée.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Une tentative de définition d'une clé faible (consultez <see cref="M:System.Security.Cryptography.DES.IsWeakKey(System.Byte[])" />) ou d'une clé semi-faible (consultez <see cref="M:System.Security.Cryptography.DES.IsSemiWeakKey(System.Byte[])" />) a été effectuée</exception>
    </member>
    <member name="T:System.Security.Cryptography.DSA">
      <summary>Représente la classe de base abstraite dont toutes les implémentations de Digital Signature Algorithm (<see cref="T:System.Security.Cryptography.DSA" />) doivent hériter.</summary>
    </member>
    <member name="M:System.Security.Cryptography.DSA.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.DSA" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.DSA.Create">
      <summary>Crée l'objet de chiffrement par défaut utilisé pour exécuter l'algorithme asymétrique.</summary>
      <returns>Objet de chiffrement utilisé pour exécuter l'algorithme asymétrique.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.Create(System.Int32)">
      <summary>Crée une clé DSA éphémère avec la taille de clé spécifiée.</summary>
      <param name="keySizeInBits">Taille de la clé, en bits.</param>
      <returns>Nouvelle clé DSA éphémère avec la taille de clé spécifiée.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="keySizeInBits" /> n’est pas autorisé par <see cref="P:System.Security.Cryptography.AsymmetricAlgorithm.LegalKeySizes" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.Create(System.Security.Cryptography.DSAParameters)">
      <summary>Crée une clé DSA éphémère avec les paramètres de clé DSA spécifiés.</summary>
      <param name="parameters">Paramètres pour l’algorithme <see cref="T:System.Security.Cryptography.DSA" />.</param>
      <returns>Nouvelle clé DSA éphémère.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.Create(System.String)">
      <summary>Crée l'objet de chiffrement spécifié utilisé pour exécuter l'algorithme asymétrique.</summary>
      <param name="algName">Nom de l'implémentation spécifique de <see cref="T:System.Security.Cryptography.DSA" /> à utiliser.</param>
      <returns>Objet de chiffrement utilisé pour exécuter l'algorithme asymétrique.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.CreateSignature(System.Byte[])">
      <summary>Substitué dans une classe dérivée, crée la signature <see cref="T:System.Security.Cryptography.DSA" /> pour les données spécifiées.</summary>
      <param name="rgbHash">Données à signer.</param>
      <returns>Signature numérique pour les données spécifiées.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.ExportParameters(System.Boolean)">
      <summary>En cas de remplacement dans une classe dérivée, exporte les éléments <see cref="T:System.Security.Cryptography.DSAParameters" />.</summary>
      <param name="includePrivateParameters">
        <see langword="true" /> pour inclure les paramètres privés ; sinon <see langword="false" />.</param>
      <returns>Paramètres pour <see cref="T:System.Security.Cryptography.DSA" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.FromXmlString(System.String)">
      <summary>Reconstruit un objet <see cref="T:System.Security.Cryptography.DSA" /> à partir d'une chaîne XML.</summary>
      <param name="xmlString">Chaîne XML à utiliser pour reconstruire l'objet <see cref="T:System.Security.Cryptography.DSA" />.</param>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="xmlString" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le format du paramètre <paramref name="xmlString" /> n’est pas valide.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.HashData(System.Byte[],System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName)">
      <summary>En cas de remplacement dans une classe dérivée, calcule la valeur de hachage de la partie spécifiée d’un tableau d’octets à l’aide d’un algorithme de hachage spécifié.</summary>
      <param name="data">Données à hacher.</param>
      <param name="offset">Index du premier octet dans les <paramref name="data" /> à hacher.</param>
      <param name="count">Nombre d’octets à hacher.</param>
      <param name="hashAlgorithm">Algorithme à utiliser pour hacher les données.</param>
      <returns>Données hachées.</returns>
      <exception cref="T:System.NotImplementedException">Une classe dérivée doit remplacer cette méthode.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.HashData(System.IO.Stream,System.Security.Cryptography.HashAlgorithmName)">
      <summary>En cas de remplacement dans une classe dérivée, calcule la valeur de hachage du flux binaire spécifié en utilisant un algorithme de hachage spécifié.</summary>
      <param name="data">Flux binaire à hacher.</param>
      <param name="hashAlgorithm">Algorithme à utiliser pour hacher les données.</param>
      <returns>Données hachées.</returns>
      <exception cref="T:System.NotImplementedException">Une classe dérivée doit remplacer cette méthode.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importe la paire de clés publique/privée à partir d’une structure PKCS#8 EncryptedPrivateKeyInfo après le déchiffrement avec un mot de passe basé sur l’octet, en remplaçant les clés de cet objet.</summary>
      <param name="passwordBytes">Octets à utiliser comme mot de passe lors du déchiffrement du matériel de clé.</param>
      <param name="source">Octets d’une structure PKCS#8 EncryptedPrivateKeyInfo dans l’encodage ASN.1-BER.</param>
      <param name="bytesRead">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets lus à partir de <paramref name="source" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le mot de passe est incorrect.

ou -

Le contenu de <paramref name="source" /> indique que la fonction de dérivation de clés (KDF) à appliquer est la fonction KDF PKCS#12 existante, qui nécessite des mots de passe basés sur <see cref="T:System.Char" />.

ou -

Le contenu de <paramref name="source" /> ne représente pas une structure PKCS#8 EncryptedPrivateKeyInfo encodée en ASN.1-BER.

ou -

Le contenu de <paramref name="source" /> indique que la clé est destinée à un algorithme autre que l’algorithme représenté par cette instance.

ou -

Le contenu de <paramref name="source" /> représente la clé dans un format qui n’est pas pris en charge.
ou
L’importation de clé propre à l’algorithme a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importe la paire de clés publique/privée à partir d’une structure PKCS#8 EncryptedPrivateKeyInfo après le déchiffrement avec un mot de passe basé sur char, en remplaçant les clés de cet objet.</summary>
      <param name="password">Mot de passe à utiliser pour déchiffrer le matériel de clé.</param>
      <param name="source">Octets d’une structure PKCS#8 EncryptedPrivateKeyInfo dans l’encodage ASN.1-BER.</param>
      <param name="bytesRead">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets lus à partir de <paramref name="source" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le mot de passe est incorrect.

ou -

Le contenu de <paramref name="source" /> ne représente pas une structure PKCS#8 EncryptedPrivateKeyInfo encodée en ASN.1-BER.
ou
Le contenu de <paramref name="source" /> indique que la clé est destinée à un algorithme autre que l’algorithme représenté par cette instance.

ou -

Le contenu de <paramref name="source" /> représente la clé dans un format qui n’est pas pris en charge.

ou -

L’importation de clé propre à l’algorithme a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.ImportParameters(System.Security.Cryptography.DSAParameters)">
      <summary>En cas de remplacement dans une classe dérivée, importe les éléments <see cref="T:System.Security.Cryptography.DSAParameters" /> spécifiés.</summary>
      <param name="parameters">Paramètres pour <see cref="T:System.Security.Cryptography.DSA" />.</param>
    </member>
    <member name="M:System.Security.Cryptography.DSA.ImportPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importe la paire de clés publique/privée à partir d’une structure PKCS#8 PrivateKeyInfo après le déchiffrement, en remplaçant les clés de cet objet.</summary>
      <param name="source">Octets d’une structure PKCS#8 PrivateKeyInfo dans l’encodage ASN.1-BER.</param>
      <param name="bytesRead">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets lus à partir de <paramref name="source" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le contenu de <paramref name="source" /> ne représente pas une structure PKCS#8 PrivateKeyInfo encodée en ASN.1-BER.

ou -

Le contenu de <paramref name="source" /> indique que la clé est destinée à un algorithme autre que l’algorithme représenté par cette instance.
ou
Le contenu de <paramref name="source" /> représente la clé dans un format qui n’est pas pris en charge.

ou -

L’importation de clé propre à l’algorithme a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.ImportSubjectPublicKeyInfo(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importe la clé publique à partir d’une structure X.509 SubjectPublicKeyInfo après le déchiffrement, en remplaçant les clés de cet objet.</summary>
      <param name="source">Octets d’une structure X.509 SubjectPublicKeyInfo dans l’encodage ASN.1-DER.</param>
      <param name="bytesRead">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets lus à partir de <paramref name="source" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le contenu de <paramref name="source" /> ne représente pas une structure X.509 SubjectPublicKeyInfo encodée en ASN.1-DER.
ou
Le contenu de <paramref name="source" /> indique que la clé est destinée à un algorithme autre que l’algorithme représenté par cette instance.
ou
Le contenu de <paramref name="source" /> représente la clé dans un format qui n’est pas pris en charge.

ou -

L’importation de clé propre à l’algorithme a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.SignData(System.Byte[],System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName)">
      <summary>Calcule la valeur de hachage d'une partie du tableau d'octets indiqué à l'aide de l'algorithme de hachage spécifié et signe la valeur de hachage obtenue.</summary>
      <param name="data">Données d'entrée pour lesquelles calculer le hachage.</param>
      <param name="offset">Décalage dans le tableau à partir duquel l’utilisation de données commence.</param>
      <param name="count">Nombre d'octets dans le tableau à utiliser comme données.</param>
      <param name="hashAlgorithm">Algorithme de hachage à utiliser pour créer la valeur de hachage.</param>
      <returns>Signature DSA pour les données spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="offset" /> est inférieur à zéro.  
ou 
 <paramref name="count" /> est inférieur à zéro.  

ou - 
<paramref name="offset" /> + <paramref name="count" /> - 1 génère un index qui dépasse la limite supérieure de <paramref name="data" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.SignData(System.Byte[],System.Security.Cryptography.HashAlgorithmName)">
      <summary>Calcule la valeur de hachage du tableau d'octets indiqué à l'aide de l'algorithme de hachage spécifié et signe la valeur de hachage obtenue.</summary>
      <param name="data">Données d'entrée pour lesquelles calculer le hachage.</param>
      <param name="hashAlgorithm">Algorithme de hachage à utiliser pour créer la valeur de hachage.</param>
      <returns>Signature DSA pour les données spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.SignData(System.IO.Stream,System.Security.Cryptography.HashAlgorithmName)">
      <summary>Calcule la valeur de hachage du flux indiqué à l'aide de l'algorithme de hachage spécifié et signe la valeur de hachage obtenue.</summary>
      <param name="data">Flux d'entrée pour lequel calculer le hachage.</param>
      <param name="hashAlgorithm">Algorithme de hachage à utiliser pour créer la valeur de hachage.</param>
      <returns>Signature DSA pour les données spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.ToXmlString(System.Boolean)">
      <summary>Crée et retourne une représentation de la chaîne XML de l'objet <see cref="T:System.Security.Cryptography.DSA" /> en cours.</summary>
      <param name="includePrivateParameters">
        <see langword="true" /> pour inclure les paramètres privés ; sinon <see langword="false" />.</param>
      <returns>Encodage de la chaîne XML de l'objet <see cref="T:System.Security.Cryptography.DSA" /> actuel.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.TryCreateSignature(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@)">
      <summary>Tente de créer la signature DSA pour le hachage spécifié dans la mémoire tampon fournie.</summary>
      <param name="hash">Hachage à signer.</param>
      <param name="destination">Plage d’octets pour la réception de la signature.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir le résultat ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Cette instance représente uniquement une clé publique.

ou -

Le type d’implémentation prend en charge uniquement le DSA hérité (FIPS 186-2), et <paramref name="hash" /> n’est pas une valeur de 20 octets.
ou
La création de la signature a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.Security.Cryptography.PbeParameters,System.Span{System.Byte},System.Int32@)">
      <summary>Tente d’exporter la clé actuelle au format PKCS#8 EncryptedPrivateKeyInfo dans une mémoire tampon fournie, à l’aide d’un mot de passe basé sur l’octet.</summary>
      <param name="passwordBytes">Octets à utiliser comme mot de passe lors du chiffrement du matériel de clé.</param>
      <param name="pbeParameters">Paramètres de chiffrement par mot de passe à utiliser lors du chiffrement du matériel de clé.</param>
      <param name="destination">Intervalle d’octets pour recevoir les données PKCS#8 EncryptedPrivateKeyInfo.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir la sortie ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La clé n’a pas pu être exportée.

ou -

<paramref name="pbeParameters" /> indique que <see cref="F:System.Security.Cryptography.PbeEncryptionAlgorithm.TripleDes3KeyPkcs12" /> doit être utilisé, ce qui nécessite des mots de passe basés sur <see cref="T:System.Char" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Char},System.Security.Cryptography.PbeParameters,System.Span{System.Byte},System.Int32@)">
      <summary>Tente d’exporter la clé actuelle au format PKCS#8 EncryptedPrivateKeyInfo dans une mémoire tampon fournie, à l’aide d’un mot de passe basé sur char.</summary>
      <param name="password">Mot de passe à utiliser lors du chiffrement du matériel de clé.</param>
      <param name="pbeParameters">Paramètres de chiffrement par mot de passe à utiliser lors du chiffrement du matériel de clé.</param>
      <param name="destination">Intervalle d’octets pour recevoir les données PKCS#8 EncryptedPrivateKeyInfo.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir la sortie ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La clé n’a pas pu être exportée.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.TryExportPkcs8PrivateKey(System.Span{System.Byte},System.Int32@)">
      <summary>Tente d’exporter la clé actuelle au format PKCS#8 PrivateKeyInfo dans une mémoire tampon fournie.</summary>
      <param name="destination">Intervalle d’octets pour recevoir les données PKCS#8 PrivateKeyInfo.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir la sortie ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La clé n’a pas pu être exportée.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.TryExportSubjectPublicKeyInfo(System.Span{System.Byte},System.Int32@)">
      <summary>Tente d’exporter la clé actuelle au format X.509 SubjectPublicKeyInfo dans une mémoire tampon fournie.</summary>
      <param name="destination">Intervalle d’octets pour recevoir les données X.509 SubjectPublicKeyInfo.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir la sortie ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La clé n’a pas pu être exportée.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.TryHashData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Int32@)">
      <summary>Tente de calculer la valeur de hachage des données fournies dans une mémoire tampon fournie.</summary>
      <param name="data">Données à hacher.</param>
      <param name="destination">Plage d’octets pour la réception de la valeur de hachage.</param>
      <param name="hashAlgorithm">Nom de l'algorithme de hachage à utiliser.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir le résultat ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.TrySignData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Int32@)">
      <summary>Tente de créer la signature DSA pour les données spécifiées dans la mémoire tampon fournie.</summary>
      <param name="data">Données à hacher et à signer.</param>
      <param name="destination">Plage d’octets pour la réception de la signature.</param>
      <param name="hashAlgorithm">Nom de l'algorithme de hachage à utiliser.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir le résultat ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.VerifyData(System.Byte[],System.Byte[],System.Security.Cryptography.HashAlgorithmName)">
      <summary>Vérifie qu'une signature numérique est valide en calculant la valeur de hachage des données indiquées à l'aide de l'algorithme de hachage spécifié et en la comparant à la signature fournie.</summary>
      <param name="data">Données signées.</param>
      <param name="signature">Données de la signature à vérifier.</param>
      <param name="hashAlgorithm">Algorithme de hachage utilisé pour créer la valeur de hachage des données.</param>
      <returns>
        <see langword="true" /> si la signature numérique est valide ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> a la valeur <see langword="null" />.  

ou - 
<paramref name="signature" /> est <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le type d’implémentation prend en charge uniquement le DSA hérité (FIPS 186-2), et l’algorithme de hachage n’est pas SHA-1.

ou -

La vérification de la signature a échoué.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.VerifyData(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Security.Cryptography.HashAlgorithmName)">
      <summary>Vérifie qu'une signature numérique est valide en calculant la valeur de hachage des données dans une partie d'un tableau d'octets à l'aide de l'algorithme de hachage spécifié et en la comparant à la signature fournie.</summary>
      <param name="data">Données signées.</param>
      <param name="offset">Index de départ à partir duquel calculer le hachage.</param>
      <param name="count">Nombre d’octets à hacher.</param>
      <param name="signature">Données de la signature à vérifier.</param>
      <param name="hashAlgorithm">Algorithme de hachage utilisé pour créer la valeur de hachage des données.</param>
      <returns>
        <see langword="true" /> si la signature numérique est valide ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> a la valeur <see langword="null" />.  

ou - 
<paramref name="signature" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="offset" /> est inférieur à zéro.  
ou 
 <paramref name="count" /> est inférieur à zéro.  

ou - 
<paramref name="offset" /> + <paramref name="count" /> - 1 génère un index qui dépasse la limite supérieure de <paramref name="data" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le type d’implémentation prend en charge uniquement le DSA hérité (FIPS 186-2), et l’algorithme de hachage n’est pas SHA-1.

ou -

La vérification de la signature a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.VerifyData(System.IO.Stream,System.Byte[],System.Security.Cryptography.HashAlgorithmName)">
      <summary>Vérifie qu'une signature numérique est valide en calculant la valeur de hachage du flux indiqué à l'aide de l'algorithme de hachage spécifié et en la comparant à la signature fournie.</summary>
      <param name="data">Données signées.</param>
      <param name="signature">Données de la signature à vérifier.</param>
      <param name="hashAlgorithm">Algorithme de hachage utilisé pour créer la valeur de hachage des données.</param>
      <returns>
        <see langword="true" /> si la signature numérique est valide ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> a la valeur <see langword="null" />.  

ou - 
<paramref name="signature" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le type d’implémentation prend en charge uniquement le DSA hérité (FIPS 186-2), et l’algorithme de hachage n’est pas SHA-1.

ou -

La vérification de la signature a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.VerifyData(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Security.Cryptography.HashAlgorithmName)">
      <summary>Vérifie qu’une signature numérique est valide en calculant la valeur de hachage des données dans une plage d’octets à l’aide de l’algorithme de hachage spécifié et en la comparant à la signature fournie.</summary>
      <param name="data">Données signées.</param>
      <param name="signature">Signature qui doit être vérifiée.</param>
      <param name="hashAlgorithm">Algorithme de hachage utilisé pour créer la valeur de hachage des données.</param>
      <returns>
        <see langword="true" /> si la signature numérique est valide ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le type d’implémentation prend en charge uniquement le DSA hérité (FIPS 186-2), et l’algorithme de hachage n’est pas SHA-1.
ou
La vérification de la signature a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.VerifySignature(System.Byte[],System.Byte[])">
      <summary>Substitué dans une classe dérivée, vérifie la signature <see cref="T:System.Security.Cryptography.DSA" /> pour les données spécifiées.</summary>
      <param name="rgbHash">Hachage des données signées avec <paramref name="rgbSignature" />.</param>
      <param name="rgbSignature">Signature à vérifier pour <c>rgbData</c>.</param>
      <returns>
        <see langword="true" /> si <paramref name="rgbSignature" /> correspond à la signature calculée à l'aide de l'algorithme de hachage et de la clé spécifiés sur <paramref name="rgbHash" /> ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le type d’implémentation prend en charge uniquement le DSA hérité (FIPS 186-2), et la valeur de hachage n’est pas égale à 20 octets.
ou
La vérification de la signature a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.VerifySignature(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
      <summary>Vérifie qu’une signature numérique est valide pour un hachage de données fourni.</summary>
      <param name="hash">Hachage des données à vérifier.</param>
      <param name="signature">Signature à vérifier.</param>
      <returns>
        <see langword="true" /> si la signature numérique est valide pour le hachage ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le type d’implémentation prend en charge uniquement le DSA hérité (FIPS 186-2), et la valeur de hachage n’est pas égale à 20 octets.
ou
La vérification de la signature a échoué.</exception>
    </member>
    <member name="T:System.Security.Cryptography.DSAParameters">
      <summary>Contient les paramètres standard de l'algorithme <see cref="T:System.Security.Cryptography.DSA" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.DSAParameters.Counter">
      <summary>Spécifie le compteur de l'algorithme <see cref="T:System.Security.Cryptography.DSA" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.DSAParameters.G">
      <summary>Spécifie le paramètre <see langword="G" /> pour l'algorithme <see cref="T:System.Security.Cryptography.DSA" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.DSAParameters.J">
      <summary>Spécifie le paramètre <see langword="J" /> pour l'algorithme <see cref="T:System.Security.Cryptography.DSA" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.DSAParameters.P">
      <summary>Spécifie le paramètre <see langword="P" /> pour l'algorithme <see cref="T:System.Security.Cryptography.DSA" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.DSAParameters.Q">
      <summary>Spécifie le paramètre <see langword="Q" /> pour l'algorithme <see cref="T:System.Security.Cryptography.DSA" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.DSAParameters.Seed">
      <summary>Spécifie la valeur initiale pour l'algorithme <see cref="T:System.Security.Cryptography.DSA" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.DSAParameters.X">
      <summary>Spécifie le paramètre <see langword="X" /> pour l'algorithme <see cref="T:System.Security.Cryptography.DSA" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.DSAParameters.Y">
      <summary>Spécifie le paramètre <see langword="Y" /> pour l'algorithme <see cref="T:System.Security.Cryptography.DSA" />.</summary>
    </member>
    <member name="T:System.Security.Cryptography.DSASignatureDeformatter">
      <summary>Vérifie une signature Digital Signature Algorithm (<see cref="T:System.Security.Cryptography.DSA" />) PKCS#1 v1.5.</summary>
    </member>
    <member name="M:System.Security.Cryptography.DSASignatureDeformatter.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.DSASignatureDeformatter" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.DSASignatureDeformatter.#ctor(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.DSASignatureDeformatter" /> avec la clé spécifiée.</summary>
      <param name="key">Instance de Digital Signature Algorithm (<see cref="T:System.Security.Cryptography.DSA" />) qui contient la clé.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSASignatureDeformatter.SetHashAlgorithm(System.String)">
      <summary>Spécifie l'algorithme de hachage pour le déformateur de signatures Digital Signature Algorithm (<see cref="T:System.Security.Cryptography.DSA" />).</summary>
      <param name="strName">Nom de l'algorithme de hachage à utiliser pour le déformateur de signatures.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicUnexpectedOperationException">Le paramètre <paramref name="strName" /> ne correspond pas à l'algorithme de hachage <see cref="T:System.Security.Cryptography.SHA1" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSASignatureDeformatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Spécifie la clé à utiliser pour le déformateur de signatures Digital Signature Algorithm (<see cref="T:System.Security.Cryptography.DSA" />).</summary>
      <param name="key">Instance de <see cref="T:System.Security.Cryptography.DSA" /> qui contient la clé.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> est <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSASignatureDeformatter.VerifySignature(System.Byte[],System.Byte[])">
      <summary>Vérifie la signature Digital Signature Algorithm (<see cref="T:System.Security.Cryptography.DSA" />) sur les données.</summary>
      <param name="rgbHash">Données de signature <paramref name="rgbSignature" />.</param>
      <param name="rgbSignature">Signature qui doit être vérifiée pour <paramref name="rgbHash" />.</param>
      <returns>
        <see langword="true" /> si la signature est valide pour les données ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="rgbHash" /> a la valeur <see langword="null" />.  

ou - 
<paramref name="rgbSignature" /> est <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicUnexpectedOperationException">La clé DSA est manquante.</exception>
    </member>
    <member name="T:System.Security.Cryptography.DSASignatureFormatter">
      <summary>Crée une signature Digital Signature Algorithm (<see cref="T:System.Security.Cryptography.DSA" />).</summary>
    </member>
    <member name="M:System.Security.Cryptography.DSASignatureFormatter.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.DSASignatureFormatter" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.DSASignatureFormatter.#ctor(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.DSASignatureFormatter" /> avec la clé spécifiée.</summary>
      <param name="key">Instance de Digital Signature Algorithm (<see cref="T:System.Security.Cryptography.DSA" />) qui contient la clé.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSASignatureFormatter.CreateSignature(System.Byte[])">
      <summary>Crée la signature Digital Signature Algorithm (<see cref="T:System.Security.Cryptography.DSA" />) PKCS #1 pour les données spécifiées.</summary>
      <param name="rgbHash">Données à signer.</param>
      <returns>Signature numérique pour les données spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="rgbHash" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicUnexpectedOperationException">L'identificateur d'objet (OID, Object Identifier) est <see langword="null" />.  
ou 
La clé DSA est <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSASignatureFormatter.SetHashAlgorithm(System.String)">
      <summary>Spécifie l'algorithme de hachage pour le formateur de signatures Digital Signature Algorithm (<see cref="T:System.Security.Cryptography.DSA" />).</summary>
      <param name="strName">Nom de l'algorithme de hachage à utiliser pour le formateur de signatures.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicUnexpectedOperationException">Le paramètre <paramref name="strName" /> ne correspond pas à l'algorithme de hachage <see cref="T:System.Security.Cryptography.SHA1" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSASignatureFormatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Spécifie la clé à utiliser pour le formateur de signatures Digital Signature Algorithm (<see cref="T:System.Security.Cryptography.DSA" />).</summary>
      <param name="key">Instance de <see cref="T:System.Security.Cryptography.DSA" /> qui contient la clé.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="T:System.Security.Cryptography.ECCurve">
      <summary>Représente une courbe elliptique.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.A">
      <summary>Le premier coefficient pour une courbe explicite. <c>A</c> pour les courbes Weierstrass, Montgomery et Edwards courtes.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.B">
      <summary>Le deuxième coefficient pour une courbe explicite. <c>B</c> pour les courbes Weierstrass et <c>d</c> pour les courbes d’Edwards courtes.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.Cofactor">
      <summary>Cofacteur de la courbe.</summary>
    </member>
    <member name="M:System.Security.Cryptography.ECCurve.CreateFromFriendlyName(System.String)">
      <summary>Crée une courbe nommée à l’aide du nom convivial spécifié de l’identificateur.</summary>
      <param name="oidFriendlyName">Nom convivial de l’identificateur.</param>
      <returns>Un objet représentant la courbe nommée.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="oidFriendlyName" /> est <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECCurve.CreateFromOid(System.Security.Cryptography.Oid)">
      <summary>Crée une courbe nommée à l'aide de l'objet <see cref="T:System.Security.Cryptography.Oid" /> spécifié.</summary>
      <param name="curveOid">L’identificateur d’objet à utiliser.</param>
      <returns>Un objet représentant la courbe nommée.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECCurve.CreateFromValue(System.String)">
      <summary>Crée une courbe nommée à l’aide de la représentation décimale spécifiée de l’identificateur.</summary>
      <param name="oidValue">Le nombre en pointillés de l’identificateur.</param>
      <returns>Un objet représentant la courbe nommée.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="oidValue" /> est <see langword="null" />.</exception>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.CurveType">
      <summary>Identifie la composition de l’objet <see cref="T:System.Security.Cryptography.ECCurve" />.</summary>
    </member>
    <member name="T:System.Security.Cryptography.ECCurve.ECCurveType">
      <summary>Indique comment interpréter les données contenues dans un objet <see cref="T:System.Security.Cryptography.ECCurve" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.ECCurveType.Characteristic2">
      <summary>Les paramètres de la courbe représentent une courbe caractéristique 2.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.ECCurveType.Implicit">
      <summary>Aucune donnée de courbe n’est interprétée. L’appelant est censé savoir quelle est la courbe.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.ECCurveType.Named">
      <summary>Les paramètres de la courbe représentent une courbe nommée.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.ECCurveType.PrimeMontgomery">
      <summary>Les paramètres de la courbe représentent une courbe avec la formule B*y^2 = x^3 + A*x^2 + x.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.ECCurveType.PrimeShortWeierstrass">
      <summary>Les paramètres de la courbe représentent une courbe avec la formule y^2 = x^3 + A*x + B dans le champ prime P.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.ECCurveType.PrimeTwistedEdwards">
      <summary>Les paramètres de la courbe représentent une courbe avec la formule A*x^2 + y^2 = 1 + B*x^2*y^2 dans le champ prime P.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.G">
      <summary>Le générateur, ou point de base, pour les opérations sur la courbe.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.Hash">
      <summary>Le nom de l’algorithme de hachage utilisé pour générer les coefficients de courbe (<see cref="F:System.Security.Cryptography.ECCurve.A" /> et <see cref="F:System.Security.Cryptography.ECCurve.B" />) à partir de la <see cref="F:System.Security.Cryptography.ECCurve.Seed" /> sous l’algorithme de génération ANSI X9.62. S’applique uniquement aux courbes explicites.</summary>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.IsCharacteristic2">
      <summary>Obtient une valeur qui indique si le type de courbe fait référence à une courbe explicite caractéristique 2.</summary>
      <returns>
        <see langword="true" /> si la courbe est une courbe explicite caractéristique 2 ; <see langword="false" /> si la courbe est une courbe implicite, prime ou caractéristique 2.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.IsExplicit">
      <summary>Obtient une valeur qui indique si le type de courbe fait référence à une courbe explicite (prime ou caractéristique 2).</summary>
      <returns>
        <see langword="true" /> si la courbe est une courbe explicite (prime ou caractéristique 2) ; <see langword="false" /> si la courbe est une courbe nommée ou implicite.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.IsNamed">
      <summary>Obtient une valeur qui indique si le type de courbe fait référence à une courbe nommée.</summary>
      <returns>
        <see langword="true" />Si la courbe est une courbe nommée; <see langword="false" /> si la courbe est une courbe implicite ou explicite (prime ou caractéristique 2).</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.IsPrime">
      <summary>Obtient une valeur qui indique si le type de courbe fait référence à une courbe explicite prime 2.</summary>
      <returns>
        <see langword="true" /> si la courbe est une courbe explicite prime ; <see langword="false" /> si la courbe est une courbe prime nommée, implicite ou caractéristique 2.</returns>
    </member>
    <member name="T:System.Security.Cryptography.ECCurve.NamedCurves">
      <summary>Représente une classe de fabrique pour la création de courbes nommées.</summary>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP160r1">
      <summary>Obtient une courbe nommée brainpoolP160r1.</summary>
      <returns>Une courbe nommée brainpoolP160r1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP160t1">
      <summary>Obtient une courbe nommée brainpoolP160t1.</summary>
      <returns>Une courbe nommée brainpoolP160t1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP192r1">
      <summary>Obtient une courbe nommée brainpoolP192r1.</summary>
      <returns>Une courbe nommée brainpoolP192r1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP192t1">
      <summary>Obtient une courbe nommée brainpoolP192t1.</summary>
      <returns>Une courbe nommée brainpoolP192t1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP224r1">
      <summary>Obtient une courbe nommée brainpoolP224r1.</summary>
      <returns>Une courbe nommée brainpoolP224r1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP224t1">
      <summary>Obtient une courbe nommée brainpoolP224t1.</summary>
      <returns>Une courbe nommée brainpoolP224t1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP256r1">
      <summary>Obtient une courbe nommée brainpoolP256r1.</summary>
      <returns>Une courbe nommée brainpoolP256r1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP256t1">
      <summary>Obtient une courbe nommée brainpoolP256t1.</summary>
      <returns>Une courbe nommée brainpoolP256t1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP320r1">
      <summary>Obtient une courbe nommée brainpoolP320r1.</summary>
      <returns>Une courbe nommée brainpoolP320r1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP320t1">
      <summary>Obtient une courbe nommée brainpoolP320t1.</summary>
      <returns>Une courbe nommée brainpoolP320t1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP384r1">
      <summary>Obtient une courbe nommée brainpoolP384r1.</summary>
      <returns>Une courbe nommée brainpoolP384r1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP384t1">
      <summary>Obtient une courbe nommée brainpoolP384t1.</summary>
      <returns>Une courbe nommée brainpoolP384t1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP512r1">
      <summary>Obtient une courbe nommée brainpoolP512r1.</summary>
      <returns>Une courbe nommée brainpoolP512r1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP512t1">
      <summary>Obtient une courbe nommée brainpoolP512t1.</summary>
      <returns>Une courbe nommée brainpoolP512t1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.nistP256">
      <summary>Obtient une courbe nommée nistP256.</summary>
      <returns>Une courbe nommée nistP256.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.nistP384">
      <summary>Obtient une courbe nommée nistP384.</summary>
      <returns>Une courbe nommée nistP384.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.nistP521">
      <summary>Obtient une courbe nommée nistP521.</summary>
      <returns>Une courbe nommée nistP521.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.Oid">
      <summary>Obtient l’identificateur d’une courbe nommée.</summary>
      <returns>L’identificateur d’une courbe nommée.</returns>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.Order">
      <summary>L’ordre de la courbe. S’applique uniquement aux courbes explicites.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.Polynomial">
      <summary>La courbe polynomiale. S’applique uniquement aux courbes de caractéristique 2.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.Prime">
      <summary>Prime spécifiant le champ de base. S’applique uniquement aux courbes prime.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.Seed">
      <summary>La valeur initiale pour la génération de coefficient sous l’algorithme de génération ANSI X9.62. S’applique uniquement aux courbes explicites.</summary>
    </member>
    <member name="M:System.Security.Cryptography.ECCurve.Validate">
      <summary>Valide l’intégrité de la courbe actuelle. Lève une exception <see cref="T:System.Security.Cryptography.CryptographicException" /> si la structure n’est pas valide.</summary>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Les paramètres de la courbe ne sont pas valides pour le type de courbe actuel.</exception>
    </member>
    <member name="T:System.Security.Cryptography.ECDiffieHellman">
      <summary>Fournit une classe de base abstraite de laquelle les implémentations de l'algorithme ECDH (Elliptic Curve Diffie-Hellman) peuvent dériver. Cette classe fournit le jeu d'opérations de base que toutes les implémentations ECDH doivent prendre en charge.</summary>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.ECDiffieHellman" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.Create">
      <summary>Crée une nouvelle instance de l'implémentation par défaut de l'algorithme ECDH (Elliptic Curve Diffie-Hellman).</summary>
      <returns>Une nouvelle instance de l'implémentation par défaut de cette classe.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.Create(System.Security.Cryptography.ECCurve)">
      <summary>Crée une nouvelle instance de l’implémentation par défaut de l’algorithme Elliptic Curve Diffie-Hellman (ECDH) avec une nouvelle paire de clés publique/privée générée sur la courbe spécifiée.</summary>
      <param name="curve">La courbe à utiliser pour générer une nouvelle paire de clés publique/privée.</param>
      <returns>Une nouvelle instance de l’implémentation par défaut de l’algorithme Elliptic Curve Diffie-Hellman (ECDH).</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="curve" /> ne valide pas.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.Create(System.Security.Cryptography.ECParameters)">
      <summary>Crée une nouvelle instance de l’implémentation par défaut de l’algorithme ECDH (Elliptic Curve Diffie-Hellman) avec la clé décrite par l’objet <see cref="T:System.Security.Cryptography.ECParameters" /> spécifié.</summary>
      <param name="parameters">Paramètres de l’algorithme ECC (Elliptic Curve Cryptography).</param>
      <returns>Une nouvelle instance de l’implémentation par défaut de l’algorithme Elliptic Curve Diffie-Hellman (ECDH).</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="parameters" /> ne valide pas.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.Create(System.String)">
      <summary>Crée une nouvelle instance de l’implémentation spécifiée de l’algorithme ECHD (Elliptic Curve Diffie-Hellman).</summary>
      <param name="algorithm">Nom d’une implémentation de l’algorithme ECDH.</param>
      <returns>Nouvelle instance de l'implémentation spécifiée de cette classe. Si le nom de l’algorithme spécifié ne correspond pas à une implémentation ECDH, cette méthode retourne <see langword="null" />.</returns>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="algorithm" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName)">
      <summary>Dérive des octets qui peuvent être utilisés comme une clé à l’aide d’une fonction de hachage, en fonction de la clé publique d’une autre partie et du nom de l’algorithme de hachage.</summary>
      <param name="otherPartyPublicKey">La clé publique de l’autre partie.</param>
      <param name="hashAlgorithm">Algorithme de hachage à utiliser pour dériver la clé.</param>
      <returns>Matériel de clé issu de l’échange de clés avec la clé publique de l’autre partie.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="otherPartyPublicKey" /> est sur une courbe différente de celle de cette clé.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[])">
      <summary>En cas d’implémentation dans une classe dérivée, dérive des octets qui peuvent être utilisés comme une clé à l’aide d’une fonction de hachage, en fonction de la clé publique d’une autre partie, le nom de l’algorithme de hachage, une valeur à ajouter au début et une valeur à ajouter à la fin.</summary>
      <param name="otherPartyPublicKey">La clé publique de l’autre partie.</param>
      <param name="hashAlgorithm">Algorithme de hachage à utiliser pour dériver la clé.</param>
      <param name="secretPrepend">Une valeur à ajouter avant la clé secrète dérivée avant le hachage.</param>
      <param name="secretAppend">Valeur à ajouter après la clé secrète dérivée avant le hachage.</param>
      <returns>Matériel de clé issu de l’échange de clés avec la clé publique de l’autre partie.</returns>
      <exception cref="T:System.NotImplementedException">Une classe dérivée doit remplacer cette méthode.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="otherPartyPublicKey" /> est sur une courbe différente de celle de cette clé.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[])">
      <summary>Dérive des octets qui peuvent être utilisés comme clé à l’aide d’un code d’authentification de message haché (HMAC).</summary>
      <param name="otherPartyPublicKey">La clé publique de l’autre partie.</param>
      <param name="hashAlgorithm">L’algorithme de hachage à utiliser pour dériver la clé.</param>
      <param name="hmacKey">La clé du HMAC.</param>
      <returns>Matériel de clé issu de l’échange de clés avec la clé publique de l’autre partie.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="otherPartyPublicKey" /> est sur une courbe différente de celle de cette clé.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[],System.Byte[])">
      <summary>En cas d’implémentation dans une classe dérivée, dérive des octets qui peuvent être utilisés comme clé à l’aide d’un code d'authentification de message haché (HMAC).</summary>
      <param name="otherPartyPublicKey">La clé publique de l’autre partie.</param>
      <param name="hashAlgorithm">L’algorithme de hachage à utiliser pour dériver la clé.</param>
      <param name="hmacKey">La clé du HMAC.</param>
      <param name="secretPrepend">Valeur à ajouter avant la clé secrète dérivée avant le hachage.</param>
      <param name="secretAppend">Valeur à ajouter après la clé secrète dérivée avant le hachage.</param>
      <returns>Matériel de clé issu de l’échange de clés avec la clé publique de l’autre partie.</returns>
      <exception cref="T:System.NotImplementedException">Une classe dérivée doit remplacer cette méthode.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="otherPartyPublicKey" /> est sur une courbe différente de celle de cette clé.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyMaterial(System.Security.Cryptography.ECDiffieHellmanPublicKey)">
      <summary>Dérive des octets qui peuvent être utilisés comme clé, étant donné la clé publique d'un autre correspondant.</summary>
      <param name="otherPartyPublicKey">La clé publique de l’autre partie.</param>
      <returns>Matériel de clé issu de l’échange de clés avec la clé publique de l’autre partie.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyTls(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Byte[],System.Byte[])">
      <summary>En cas d’implémentation dans une classe dérivée, dérive des octets qui peuvent être utilisés comme une clé à l’aide d’un algorithme de dérivation TLS (Transport Layer Security) PRF (Pseudo-Random Function).</summary>
      <param name="otherPartyPublicKey">La clé publique de l’autre partie.</param>
      <param name="prfLabel">L’étiquette PRF encodée en ASCII.</param>
      <param name="prfSeed">La valeur de départ PRF à 64 octets.</param>
      <returns>Matériel de clé issu de l’échange de clés avec la clé publique de l’autre partie.</returns>
      <exception cref="T:System.NotImplementedException">Une classe dérivée doit remplacer cette méthode.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="otherPartyPublicKey" /> est sur une courbe différente de celle de cette clé.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="prfLabel" /> ou <paramref name="prfSeed" /> est <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="prfSeed" /> ne compte pas exactement 64 octets.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.ExportECPrivateKey">
      <summary>Exporte la clé actuelle au format ECPrivateKey.</summary>
      <returns>Tableau d’octets contenant la représentation ECPrivateKey de cette clé.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La clé n’a pas pu être exportée.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.ExportExplicitParameters(System.Boolean)">
      <summary>En cas de substitution dans une classe dérivée, exporte les informations de clé publique ou des clés publique et privée d’une clé <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> valide à l’aide du formulaire de courbe explicite vers une structure <see cref="T:System.Security.Cryptography.ECParameters" /> pour qu’elle puisse être passée à la méthode <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" />.</summary>
      <param name="includePrivateParameters">
        <see langword="true" /> pour inclure les paramètres privés ; sinon <see langword="false" />.</param>
      <returns>Objet représentant le point sur la courbe pour cette clé, en utilisant le format de la courbe explicite.</returns>
      <exception cref="T:System.NotImplementedException">Une classe dérivée doit remplacer cette méthode.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.ExportParameters(System.Boolean)">
      <summary>En cas de substitution dans une classe dérivée, exporte les informations de clé publique ou des clés publique et privée d’une clé <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> valide vers une structure <see cref="T:System.Security.Cryptography.ECParameters" /> pour qu’elle puisse être passée à la méthode <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" />.</summary>
      <param name="includePrivateParameters">
        <see langword="true" /> pour inclure les paramètres privés. Sinon, <see langword="false" /> pour inclure les paramètres publics uniquement.</param>
      <returns>Objet représentant le point sur la courbe pour cette clé. Il peut être passé à la méthode <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" />.</returns>
      <exception cref="T:System.NotImplementedException">Une classe dérivée doit remplacer cette méthode.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.FromXmlString(System.String)">
      <summary>Cette méthode lève une exception dans tous les cas.</summary>
      <param name="xmlString">Chaîne XML à utiliser pour reconstruire l'objet <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" />.</param>
      <exception cref="T:System.NotImplementedException">Dans tous les cas.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.GenerateKey(System.Security.Cryptography.ECCurve)">
      <summary>En cas de substitution dans une classe dérivée, génère une nouvelle paire de clés publique/privée éphémère pour la courbe spécifiée.</summary>
      <param name="curve">La courbe utilisée pour générer une paire de clés publique/privée éphémère.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="curve" /> ne valide pas.</exception>
      <exception cref="T:System.NotImplementedException">Une classe dérivée doit remplacer cette méthode.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.ImportECPrivateKey(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importe la paire de clés publique/privée à partir d’une structure ECPrivateKey, en remplaçant les clés de cet objet.</summary>
      <param name="source">Octets d’une structure ECPrivateKey dans l’encodage ASN.1-BER.</param>
      <param name="bytesRead">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets lus à partir de <paramref name="source" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le contenu de <paramref name="source" /> ne représente pas une structure PKCS#8 ECPrivateKey encodée en ASN.1-BER.
ou
L’importation de clés a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importe la paire de clés publique/privée à partir d’une structure PKCS#8 EncryptedPrivateKeyInfo après le déchiffrement avec un mot de passe basé sur l’octet, en remplaçant les clés de cet objet.</summary>
      <param name="passwordBytes">Octets à utiliser comme mot de passe lors du déchiffrement du matériel de clé.</param>
      <param name="source">Octets d’une structure PKCS#8 EncryptedPrivateKeyInfo dans l’encodage ASN.1-BER.</param>
      <param name="bytesRead">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets lus à partir de <paramref name="source" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le mot de passe est incorrect.

ou -

Le contenu de <paramref name="source" /> indique que la fonction de dérivation de clés (KDF) à appliquer est la fonction KDF PKCS#12 existante, qui nécessite des mots de passe basés sur <see cref="T:System.Char" />.

ou -

Le contenu de <paramref name="source" /> ne représente pas une structure PKCS#8 EncryptedPrivateKeyInfo encodée en ASN.1-BER.

ou -

Le contenu de <paramref name="source" /> indique que la clé est destinée à un algorithme autre que l’algorithme représenté par cette instance.
ou
Le contenu de <paramref name="source" /> représente la clé dans un format qui n’est pas pris en charge.
ou
L’importation de clé propre à l’algorithme a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importe la paire de clés publique/privée à partir d’une structure PKCS#8 EncryptedPrivateKeyInfo après le déchiffrement avec un mot de passe basé sur char, en remplaçant les clés de cet objet.</summary>
      <param name="password">Mot de passe à utiliser pour déchiffrer le matériel de clé.</param>
      <param name="source">Octets d’une structure PKCS#8 EncryptedPrivateKeyInfo dans l’encodage ASN.1-BER.</param>
      <param name="bytesRead">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets lus à partir de <paramref name="source" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le mot de passe est incorrect.

ou -

Le contenu de <paramref name="source" /> ne représente pas une structure PKCS#8 EncryptedPrivateKeyInfo encodée en ASN.1-BER.

ou -

Le contenu de <paramref name="source" /> indique que la clé est destinée à un algorithme autre que l’algorithme représenté par cette instance.

ou -

Le contenu de <paramref name="source" /> représente la clé dans un format qui n’est pas pris en charge.

ou -

L’importation de clé propre à l’algorithme a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)">
      <summary>En cas de substitution dans une classe dérivée, importe les paramètres spécifiés pour une <see cref="T:System.Security.Cryptography.ECCurve" /> en tant que clé éphémère dans l’objet <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> actuel.</summary>
      <param name="parameters">Paramètres de la courbe à importer.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="parameters" /> ne valide pas.</exception>
      <exception cref="T:System.NotImplementedException">Une classe dérivée doit remplacer cette méthode.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.ImportPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importe la paire de clés publique/privée à partir d’une structure PKCS#8 PrivateKeyInfo après le déchiffrement, en remplaçant les clés de cet objet.</summary>
      <param name="source">Octets d’une structure PKCS#8 PrivateKeyInfo dans l’encodage ASN.1-BER.</param>
      <param name="bytesRead">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets lus à partir de <paramref name="source" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le contenu de <paramref name="source" /> ne représente pas une structure PKCS#8 PrivateKeyInfo encodée en ASN.1-BER.

ou -

Le contenu de <paramref name="source" /> indique que la clé est destinée à un algorithme autre que l’algorithme représenté par cette instance.

ou -

Le contenu de <paramref name="source" /> représente la clé dans un format qui n’est pas pris en charge.
ou
L’importation de clé propre à l’algorithme a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.ImportSubjectPublicKeyInfo(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importe la clé publique à partir d’une structure X.509 SubjectPublicKeyInfo après le déchiffrement, en remplaçant les clés de cet objet.</summary>
      <param name="source">Octets d’une structure X.509 SubjectPublicKeyInfo dans l’encodage ASN.1-DER.</param>
      <param name="bytesRead">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets lus à partir de <paramref name="source" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le contenu de <paramref name="source" /> ne représente pas une structure X.509 SubjectPublicKeyInfo encodée en ASN.1-DER.
ou
Le contenu de <paramref name="source" /> indique que la clé est destinée à un algorithme autre que l’algorithme représenté par cette instance.
ou
Le contenu de <paramref name="source" /> représente la clé dans un format qui n’est pas pris en charge.

ou -

L’importation de clé propre à l’algorithme a échoué.</exception>
    </member>
    <member name="P:System.Security.Cryptography.ECDiffieHellman.KeyExchangeAlgorithm">
      <summary>Obtient le nom de l'algorithme d'échange de clés.</summary>
      <returns>Nom de l'algorithme d'échange de clés.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECDiffieHellman.PublicKey">
      <summary>Obtient la clé publique utilisée par l'instance ECDH (Elliptic Curve Diffie-Hellman) actuelle.</summary>
      <returns>Partie publique de la paire de clés ECDH utilisée par cette instance <see cref="T:System.Security.Cryptography.ECDiffieHellman" />.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECDiffieHellman.SignatureAlgorithm">
      <summary>Obtient le nom de l'algorithme de signature.</summary>
      <returns>Toujours <see langword="null" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.ToXmlString(System.Boolean)">
      <summary>Cette méthode lève une exception dans tous les cas.</summary>
      <param name="includePrivateParameters">
        <see langword="true" /> pour inclure les paramètres privés ; sinon <see langword="false" />.</param>
      <returns>Cette méthode ne retourne pas de valeur.</returns>
      <exception cref="T:System.NotImplementedException">Dans tous les cas.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.TryExportECPrivateKey(System.Span{System.Byte},System.Int32@)">
      <summary>Tente d’exporter la clé actuelle au format ECPrivateKey dans une mémoire tampon fournie.</summary>
      <param name="destination">Étendue d’octets devant recevoir les données ECPrivateKey.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir la sortie ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La clé n’a pas pu être exportée.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.Security.Cryptography.PbeParameters,System.Span{System.Byte},System.Int32@)">
      <summary>Tente d’exporter la clé actuelle au format PKCS#8 EncryptedPrivateKeyInfo dans une mémoire tampon fournie, à l’aide d’un mot de passe basé sur l’octet.</summary>
      <param name="passwordBytes">Octets à utiliser comme mot de passe lors du chiffrement du matériel de clé.</param>
      <param name="pbeParameters">Paramètres de chiffrement par mot de passe à utiliser lors du chiffrement du matériel de clé.</param>
      <param name="destination">Intervalle d’octets pour recevoir les données PKCS#8 EncryptedPrivateKeyInfo.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir la sortie ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La clé n’a pas pu être exportée.

ou -

<paramref name="pbeParameters" /> indique que <see cref="F:System.Security.Cryptography.PbeEncryptionAlgorithm.TripleDes3KeyPkcs12" /> doit être utilisé, ce qui nécessite des mots de passe basés sur <see cref="T:System.Char" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Char},System.Security.Cryptography.PbeParameters,System.Span{System.Byte},System.Int32@)">
      <summary>Tente d’exporter la clé actuelle au format PKCS#8 EncryptedPrivateKeyInfo dans une mémoire tampon fournie, à l’aide d’un mot de passe basé sur char.</summary>
      <param name="password">Mot de passe à utiliser lors du chiffrement du matériel de clé.</param>
      <param name="pbeParameters">Paramètres de chiffrement par mot de passe à utiliser lors du chiffrement du matériel de clé.</param>
      <param name="destination">Intervalle d’octets pour recevoir les données PKCS#8 EncryptedPrivateKeyInfo.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir la sortie ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La clé n’a pas pu être exportée.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.TryExportPkcs8PrivateKey(System.Span{System.Byte},System.Int32@)">
      <summary>Tente d’exporter la clé actuelle au format PKCS#8 PrivateKeyInfo dans une mémoire tampon fournie.</summary>
      <param name="destination">Intervalle d’octets pour recevoir les données PKCS#8 PrivateKeyInfo.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir la sortie ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La clé n’a pas pu être exportée.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.TryExportSubjectPublicKeyInfo(System.Span{System.Byte},System.Int32@)">
      <summary>Tente d’exporter la clé actuelle au format X.509 SubjectPublicKeyInfo dans une mémoire tampon fournie.</summary>
      <param name="destination">Intervalle d’octets pour recevoir les données X.509 SubjectPublicKeyInfo.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir la sortie ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La clé n’a pas pu être exportée.</exception>
    </member>
    <member name="T:System.Security.Cryptography.ECDiffieHellmanPublicKey">
      <summary>Fournit une classe de base abstraite dont toutes les implémentations <see cref="T:System.Security.Cryptography.ECDiffieHellmanCngPublicKey" /> doivent hériter.</summary>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellmanPublicKey.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.ECDiffieHellmanPublicKey" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellmanPublicKey.#ctor(System.Byte[])">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.ECDiffieHellmanPublicKey" />.</summary>
      <param name="keyBlob">Un tableau d'octets qui représente un objet <see cref="T:System.Security.Cryptography.ECDiffieHellmanPublicKey" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="keyBlob" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellmanPublicKey.Dispose">
      <summary>Libère toutes les ressources utilisées par l'instance actuelle de la classe <see cref="T:System.Security.Cryptography.ECDiffieHellman" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellmanPublicKey.Dispose(System.Boolean)">
      <summary>Libère les ressources non managées utilisées par la classe <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> et libère éventuellement les ressources managées.</summary>
      <param name="disposing">
        <see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour libérer uniquement les ressources non managées.</param>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellmanPublicKey.ExportExplicitParameters">
      <summary>En cas de substitution dans une classe dérivée, exporte les <see cref="T:System.Security.Cryptography.ECParameters" /> explicites pour un objet <see cref="T:System.Security.Cryptography.ECCurve" />.</summary>
      <returns>Objet représentant le point sur la courbe pour cette clé, en utilisant le format de la courbe explicite.</returns>
      <exception cref="T:System.NotSupportedException">Une classe dérivée doit remplacer cette méthode.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellmanPublicKey.ExportParameters">
      <summary>En cas de substitution dans une classe dérivée, exporte les <see cref="T:System.Security.Cryptography.ECParameters" /> nommés ou explicites pour un objet <see cref="T:System.Security.Cryptography.ECCurve" />.</summary>
      <returns>Objet représentant le point sur la courbe pour cette clé.</returns>
      <exception cref="T:System.NotSupportedException">Une classe dérivée doit remplacer cette méthode.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellmanPublicKey.ToByteArray">
      <summary>Sérialise le BLOB de clé <see cref="T:System.Security.Cryptography.ECDiffieHellmanPublicKey" /> en un tableau d'octets.</summary>
      <returns>Un tableau d'octets qui contient la clé publique ECDH (Elliptic Curve Diffie-Hellman) sérialisée.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellmanPublicKey.ToXmlString">
      <summary>Sérialise la clé publique <see cref="T:System.Security.Cryptography.ECDiffieHellmanPublicKey" /> en une chaîne XML.</summary>
      <returns>Une chaîne XML qui contient la clé publique ECDH (Elliptic Curve Diffie-Hellman) sérialisée.</returns>
    </member>
    <member name="T:System.Security.Cryptography.ECDsa">
      <summary>Fournit une classe de base abstraite qui encapsule l’algorithme ECDSA (Elliptic Curve Digital Signature Algorithm).</summary>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.ECDsa" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.Create">
      <summary>Crée une nouvelle instance de l'implémentation par défaut de l'algorithme ECDSA (Elliptic Curve Digital Signature Algorithm).</summary>
      <returns>Nouvelle instance de l'implémentation par défaut (<see cref="T:System.Security.Cryptography.ECDsaCng" />) de cette classe.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.Create(System.Security.Cryptography.ECCurve)">
      <summary>Crée une nouvelle instance de l’implémentation par défaut de l’algorithme Elliptic Curve Digital Signature Algorithm (ECDSA) avec une nouvelle clé générée sur la courbe spécifiée.</summary>
      <param name="curve">La courbe à utiliser pour la génération de clé.</param>
      <returns>Nouvelle instance de l'implémentation par défaut (<see cref="T:System.Security.Cryptography.ECDsaCng" />) de cette classe.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.Create(System.Security.Cryptography.ECParameters)">
      <summary>Crée une nouvelle instance de l’implémentation par défaut de l’algorithme Elliptic Curve Digital Signature Algorithm (ECDSA) en utilisant les paramètres spécifiés en tant que clé.</summary>
      <param name="parameters">Les paramètres représentant la clé à utiliser.</param>
      <returns>Nouvelle instance de l'implémentation par défaut (<see cref="T:System.Security.Cryptography.ECDsaCng" />) de cette classe.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.Create(System.String)">
      <summary>Crée une nouvelle instance de l'implémentation spécifiée de l'algorithme ECDSA (Elliptic Curve Digital Signature Algorithm).</summary>
      <param name="algorithm">Le nom d'une implémentation ECDSA. Les chaînes suivantes font toutes référence à la même implémentation, qui est la seule implémentation actuellement prise en charge dans le .NET Framework : 
- « ECDsa » 
- « ECDsaCng » 
- « System.Security.Cryptography.ECDsaCng » 
Vous pouvez également fournir le nom d'une implémentation ECDSA personnalisée.</param>
      <returns>Nouvelle instance de l'implémentation spécifiée de cette classe. Si le nom de l'algorithme spécifié n'est pas mappé avec une implémentation ECDSA, cette méthode retourne <see langword="null" />.</returns>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="algorithm" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.ExportECPrivateKey">
      <summary>Exporte la clé actuelle au format ECPrivateKey.</summary>
      <returns>Tableau d’octets contenant la représentation ECPrivateKey de cette clé.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La clé n’a pas pu être exportée.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.ExportExplicitParameters(System.Boolean)">
      <summary>En cas de substitution dans une classe dérivée, exporte les paramètres explicites pour une courbe elliptique.</summary>
      <param name="includePrivateParameters">
        <see langword="true" /> pour inclure les paramètres privés ; sinon <see langword="false" />.</param>
      <returns>Les paramètres représentant le point sur la courbe pour cette clé, en utilisant le format de la courbe explicite.</returns>
      <exception cref="T:System.NotSupportedException">Une classe dérivée doit remplacer cette méthode.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.ExportParameters(System.Boolean)">
      <summary>En cas de substitution dans une classe dérivée, exporte les paramètres nommés ou explicites pour une courbe elliptique. Si la courbe a un nom, le champ <see cref="F:System.Security.Cryptography.ECParameters.Curve" /> contient les paramètres de la courbe nommée, sinon il contient des paramètres explicites.</summary>
      <param name="includePrivateParameters">
        <see langword="true" /> pour inclure les paramètres privés ; sinon <see langword="false" />.</param>
      <returns>Les paramètres représentant le point sur la courbe pour cette clé.</returns>
      <exception cref="T:System.NotSupportedException">Une classe dérivée doit remplacer cette méthode.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.FromXmlString(System.String)">
      <summary>Cette méthode lève une exception dans tous les cas.</summary>
      <param name="xmlString">Chaîne XML à utiliser pour reconstruire l'objet <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" />.</param>
      <exception cref="T:System.NotImplementedException">Dans tous les cas.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.GenerateKey(System.Security.Cryptography.ECCurve)">
      <summary>En cas de substitution dans une classe dérivée, génère une nouvelle paire de clés publique/privée pour la courbe spécifiée.</summary>
      <param name="curve">La courbe à utiliser.</param>
      <exception cref="T:System.NotSupportedException">Une classe dérivée doit remplacer cette méthode.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.HashData(System.Byte[],System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName)">
      <summary>En cas de substitution dans une classe dérivée, calcule la valeur de hachage de la partie indiquée d'un tableau d'octets à l'aide de l'algorithme de hachage spécifié.</summary>
      <param name="data">Données à hacher.</param>
      <param name="offset">Index du premier octet dans <paramref name="data" /> à hacher.</param>
      <param name="count">Nombre d'octets à hacher.</param>
      <param name="hashAlgorithm">Algorithme à utiliser pour hacher les données.</param>
      <returns>Données hachées.</returns>
      <exception cref="T:System.NotImplementedException">Une classe dérivée doit remplacer cette méthode.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.HashData(System.IO.Stream,System.Security.Cryptography.HashAlgorithmName)">
      <summary>En cas de substitution dans une classe dérivée, calcule la valeur de hachage du flux binaire indiqué à l'aide de l'algorithme de hachage spécifié.</summary>
      <param name="data">Flux binaire à hacher.</param>
      <param name="hashAlgorithm">Algorithme à utiliser pour hacher les données.</param>
      <returns>Données hachées.</returns>
      <exception cref="T:System.NotImplementedException">Une classe dérivée doit remplacer cette méthode.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.ImportECPrivateKey(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importe la paire de clés publique/privée à partir d’une structure ECPrivateKey, en remplaçant les clés de cet objet.</summary>
      <param name="source">Octets d’une structure ECPrivateKey dans l’encodage ASN.1-BER.</param>
      <param name="bytesRead">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets lus à partir de <paramref name="source" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le contenu de <paramref name="source" /> ne représente pas une structure PKCS#8 ECPrivateKey encodée en ASN.1-BER.
ou
L’importation de clés a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importe la paire de clés publique/privée à partir d’une structure PKCS#8 EncryptedPrivateKeyInfo après le déchiffrement avec un mot de passe basé sur l’octet, en remplaçant les clés de cet objet.</summary>
      <param name="passwordBytes">Octets à utiliser comme mot de passe lors du déchiffrement du matériel de clé.</param>
      <param name="source">Octets d’une structure PKCS#8 EncryptedPrivateKeyInfo dans l’encodage ASN.1-BER.</param>
      <param name="bytesRead">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets lus à partir de <paramref name="source" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le mot de passe est incorrect.

ou -

Le contenu de <paramref name="source" /> indique que la fonction de dérivation de clés (KDF) à appliquer est la fonction KDF PKCS#12 existante, qui nécessite des mots de passe basés sur <see cref="T:System.Char" />.
ou
Le contenu de <paramref name="source" /> ne représente pas une structure PKCS#8 EncryptedPrivateKeyInfo encodée en ASN.1-BER.

ou -

Le contenu de <paramref name="source" /> indique que la clé est destinée à un algorithme autre que l’algorithme représenté par cette instance.

ou -

Le contenu de <paramref name="source" /> représente la clé dans un format qui n’est pas pris en charge.

ou -

L’importation de clé propre à l’algorithme a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importe la paire de clés publique/privée à partir d’une structure PKCS#8 EncryptedPrivateKeyInfo après le déchiffrement avec un mot de passe basé sur char, en remplaçant les clés de cet objet.</summary>
      <param name="password">Mot de passe à utiliser pour déchiffrer le matériel de clé.</param>
      <param name="source">Octets d’une structure PKCS#8 EncryptedPrivateKeyInfo dans l’encodage ASN.1-BER.</param>
      <param name="bytesRead">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets lus à partir de <paramref name="source" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le mot de passe est incorrect.

ou -

Le contenu de <paramref name="source" /> ne représente pas une structure PKCS#8 EncryptedPrivateKeyInfo encodée en ASN.1-BER.

ou -

Le contenu de <paramref name="source" /> indique que la clé est destinée à un algorithme autre que l’algorithme représenté par cette instance.
ou
Le contenu de <paramref name="source" /> représente la clé dans un format qui n’est pas pris en charge.
ou
L’importation de clé propre à l’algorithme a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.ImportParameters(System.Security.Cryptography.ECParameters)">
      <summary>En cas de remplacement dans une classe dérivée, importe les paramètres spécifiés.</summary>
      <param name="parameters">Les paramètres de la courbe.</param>
      <exception cref="T:System.NotSupportedException">Une classe dérivée doit remplacer cette méthode.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.ImportPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importe la paire de clés publique/privée à partir d’une structure PKCS#8 PrivateKeyInfo après le déchiffrement, en remplaçant les clés de cet objet.</summary>
      <param name="source">Octets d’une structure PKCS#8 PrivateKeyInfo dans l’encodage ASN.1-BER.</param>
      <param name="bytesRead">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets lus à partir de <paramref name="source" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le contenu de <paramref name="source" /> ne représente pas une structure PKCS#8 PrivateKeyInfo encodée en ASN.1-BER.

ou -

Le contenu de <paramref name="source" /> indique que la clé est destinée à un algorithme autre que l’algorithme représenté par cette instance.
ou
Le contenu de <paramref name="source" /> représente la clé dans un format qui n’est pas pris en charge.

ou -

L’importation de clé propre à l’algorithme a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.ImportSubjectPublicKeyInfo(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importe la clé publique à partir d’une structure X.509 SubjectPublicKeyInfo après le déchiffrement, en remplaçant les clés de cet objet.</summary>
      <param name="source">Octets d’une structure X.509 SubjectPublicKeyInfo dans l’encodage ASN.1-DER.</param>
      <param name="bytesRead">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets lus à partir de <paramref name="source" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le contenu de <paramref name="source" /> ne représente pas une structure X.509 SubjectPublicKeyInfo encodée en ASN.1-DER.

ou -

Le contenu de <paramref name="source" /> indique que la clé est destinée à un algorithme autre que l’algorithme représenté par cette instance.

ou -

Le contenu de <paramref name="source" /> représente la clé dans un format qui n’est pas pris en charge.

ou -

L’importation de clé propre à l’algorithme a échoué.</exception>
    </member>
    <member name="P:System.Security.Cryptography.ECDsa.KeyExchangeAlgorithm">
      <summary>Obtient le nom de l'algorithme d'échange de clés.</summary>
      <returns>Toujours <see langword="null" />.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECDsa.SignatureAlgorithm">
      <summary>Obtient le nom de l'algorithme de signature.</summary>
      <returns>La chaîne "ECDsa".</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.SignData(System.Byte[],System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName)">
      <summary>Calcule la valeur de hachage d'une partie du tableau d'octets indiqué à l'aide de l'algorithme de hachage spécifié et signe la valeur de hachage obtenue.</summary>
      <param name="data">Données d'entrée pour lesquelles calculer le hachage.</param>
      <param name="offset">Décalage dans le tableau à partir duquel l’utilisation de données commence.</param>
      <param name="count">Nombre d'octets dans le tableau à utiliser comme données.</param>
      <param name="hashAlgorithm">Algorithme de hachage à utiliser pour créer la valeur de hachage.</param>
      <returns>Signature ECDSA pour les données spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="offset" /> est inférieur à zéro.  

ou - 
<paramref name="count" /> est inférieur à zéro.  

ou 
 <paramref name="offset" /> + <paramref name="count" /> - 1 génère un index qui dépasse la limite supérieure de <paramref name="data" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.SignData(System.Byte[],System.Security.Cryptography.HashAlgorithmName)">
      <summary>Calcule la valeur de hachage du tableau d'octets indiqué à l'aide de l'algorithme de hachage spécifié et signe la valeur de hachage obtenue.</summary>
      <param name="data">Données d'entrée pour lesquelles calculer le hachage.</param>
      <param name="hashAlgorithm">Algorithme de hachage à utiliser pour créer la valeur de hachage.</param>
      <returns>Signature ECDSA pour les données spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.SignData(System.IO.Stream,System.Security.Cryptography.HashAlgorithmName)">
      <summary>Calcule la valeur de hachage du flux indiqué à l'aide de l'algorithme de hachage spécifié et signe la valeur de hachage obtenue.</summary>
      <param name="data">Flux d'entrée pour lequel calculer le hachage.</param>
      <param name="hashAlgorithm">Algorithme de hachage à utiliser pour créer la valeur de hachage.</param>
      <returns>Signature ECDSA pour les données spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.SignHash(System.Byte[])">
      <summary>Génère une signature numérique pour la valeur de hachage spécifiée.</summary>
      <param name="hash">Valeur de hachage des données signées.</param>
      <returns>Une signature numérique qui se compose de la valeur de hachage donnée chiffrée avec la clé privée.</returns>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="hash" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.ToXmlString(System.Boolean)">
      <summary>Cette méthode lève une exception dans tous les cas.</summary>
      <param name="includePrivateParameters">
        <see langword="true" /> pour inclure les paramètres privés ; sinon <see langword="false" />.</param>
      <returns>Cette méthode ne retourne pas de valeur.</returns>
      <exception cref="T:System.NotImplementedException">Dans tous les cas.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.TryExportECPrivateKey(System.Span{System.Byte},System.Int32@)">
      <summary>Tente d’exporter la clé actuelle au format ECPrivateKey dans une mémoire tampon fournie.</summary>
      <param name="destination">Étendue d’octets devant recevoir les données ECPrivateKey.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir la sortie ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La clé n’a pas pu être exportée.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.Security.Cryptography.PbeParameters,System.Span{System.Byte},System.Int32@)">
      <summary>Tente d’exporter la clé actuelle au format PKCS#8 EncryptedPrivateKeyInfo dans une mémoire tampon fournie, à l’aide d’un mot de passe basé sur l’octet.</summary>
      <param name="passwordBytes">Octets à utiliser comme mot de passe lors du chiffrement du matériel de clé.</param>
      <param name="pbeParameters">Paramètres de chiffrement par mot de passe à utiliser lors du chiffrement du matériel de clé.</param>
      <param name="destination">Intervalle d’octets pour recevoir les données PKCS#8 EncryptedPrivateKeyInfo.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir la sortie ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La clé n’a pas pu être exportée.

ou -

<paramref name="pbeParameters" /> indique que <see cref="F:System.Security.Cryptography.PbeEncryptionAlgorithm.TripleDes3KeyPkcs12" /> doit être utilisé, ce qui nécessite des mots de passe basés sur <see cref="T:System.Char" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Char},System.Security.Cryptography.PbeParameters,System.Span{System.Byte},System.Int32@)">
      <summary>Tente d’exporter la clé actuelle au format PKCS#8 EncryptedPrivateKeyInfo dans une mémoire tampon fournie, à l’aide d’un mot de passe basé sur char.</summary>
      <param name="password">Mot de passe à utiliser lors du chiffrement du matériel de clé.</param>
      <param name="pbeParameters">Paramètres de chiffrement par mot de passe à utiliser lors du chiffrement du matériel de clé.</param>
      <param name="destination">Intervalle d’octets pour recevoir les données PKCS#8 EncryptedPrivateKeyInfo.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir la sortie ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La clé n’a pas pu être exportée.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.TryExportPkcs8PrivateKey(System.Span{System.Byte},System.Int32@)">
      <summary>Tente d’exporter la clé actuelle au format PKCS#8 PrivateKeyInfo dans une mémoire tampon fournie.</summary>
      <param name="destination">Intervalle d’octets pour recevoir les données PKCS#8 PrivateKeyInfo.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir la sortie ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La clé n’a pas pu être exportée.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.TryExportSubjectPublicKeyInfo(System.Span{System.Byte},System.Int32@)">
      <summary>Tente d’exporter la clé actuelle au format X.509 SubjectPublicKeyInfo dans une mémoire tampon fournie.</summary>
      <param name="destination">Intervalle d’octets pour recevoir les données X.509 SubjectPublicKeyInfo.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir la sortie ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La clé n’a pas pu être exportée.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.TryHashData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Int32@)">
      <param name="data" />
      <param name="destination" />
      <param name="hashAlgorithm" />
      <param name="bytesWritten" />
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.TrySignData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Int32@)">
      <param name="data" />
      <param name="destination" />
      <param name="hashAlgorithm" />
      <param name="bytesWritten" />
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.TrySignHash(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@)">
      <param name="hash" />
      <param name="destination" />
      <param name="bytesWritten" />
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.VerifyData(System.Byte[],System.Byte[],System.Security.Cryptography.HashAlgorithmName)">
      <summary>Vérifie qu'une signature numérique est valide en calculant la valeur de hachage des données indiquées à l'aide de l'algorithme de hachage spécifié et en la comparant à la signature fournie.</summary>
      <param name="data">Données signées.</param>
      <param name="signature">Données de la signature à vérifier.</param>
      <param name="hashAlgorithm">Algorithme de hachage utilisé pour créer la valeur de hachage des données.</param>
      <returns>
        <see langword="true" /> si la signature est valide ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> a la valeur <see langword="null" />.  

ou - 
<paramref name="signature" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.VerifyData(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Security.Cryptography.HashAlgorithmName)">
      <summary>Vérifie qu'une signature numérique est valide en calculant la valeur de hachage des données dans une partie d'un tableau d'octets à l'aide de l'algorithme de hachage spécifié et en la comparant à la signature fournie.</summary>
      <param name="data">Données signées.</param>
      <param name="offset">Index de départ à partir duquel calculer le hachage.</param>
      <param name="count">Nombre d’octets à hacher.</param>
      <param name="signature">Données de la signature à vérifier.</param>
      <param name="hashAlgorithm">Algorithme de hachage utilisé pour créer la valeur de hachage des données.</param>
      <returns>
        <see langword="true" /> si la signature est valide ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> est <see langword="null" />.  

ou - 
<paramref name="signature" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="offset" /> est inférieur à zéro.  
ou 
 <paramref name="count" /> est inférieur à zéro.  
ou 
 <paramref name="offset" /> + <paramref name="count" /> - 1 génère un index qui dépasse la limite supérieure de <paramref name="data" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.VerifyData(System.IO.Stream,System.Byte[],System.Security.Cryptography.HashAlgorithmName)">
      <summary>Vérifie qu'une signature numérique est valide en calculant la valeur de hachage du flux indiqué à l'aide de l'algorithme de hachage spécifié et en la comparant à la signature fournie.</summary>
      <param name="data">Données signées.</param>
      <param name="signature">Données de la signature à vérifier.</param>
      <param name="hashAlgorithm">Algorithme de hachage utilisé pour créer la valeur de hachage des données.</param>
      <returns>
        <see langword="true" /> si la signature est valide ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> est <see langword="null" />.  

ou - 
<paramref name="signature" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.VerifyData(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Security.Cryptography.HashAlgorithmName)">
      <param name="data" />
      <param name="signature" />
      <param name="hashAlgorithm" />
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.VerifyHash(System.Byte[],System.Byte[])">
      <summary>Vérifie une signature numérique par rapport à la valeur de hachage spécifiée.</summary>
      <param name="hash">Valeur de hachage d’un bloc de données.</param>
      <param name="signature">Signature numérique à vérifier.</param>
      <returns>
        <see langword="true" /> si la valeur de hachage est égale à la signature déchiffrée ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.VerifyHash(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
      <param name="hash" />
      <param name="signature" />
    </member>
    <member name="T:System.Security.Cryptography.ECParameters">
      <summary>Représente les paramètres standard pour l’algorithme de chiffrement ECC.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECParameters.Curve">
      <summary>Représente la courbe associée à la clé publique (<see cref="F:System.Security.Cryptography.ECParameters.Q" />) et la clé privée facultative (<see cref="F:System.Security.Cryptography.ECParameters.D" />).</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECParameters.D">
      <summary>Représente la clé privée <see langword="D" /> pour l’algorithme de chiffrement ECC, stockée au format big-endian.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECParameters.Q">
      <summary>Représente la clé publique <see langword="Q" /> pour l’algorithme de chiffrement ECC.</summary>
    </member>
    <member name="M:System.Security.Cryptography.ECParameters.Validate">
      <summary>Valide l’objet actuel.</summary>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Les paramètres de clé ou de courbe ne sont pas valides pour le type de courbe actuel.</exception>
    </member>
    <member name="T:System.Security.Cryptography.ECPoint">
      <summary>Représente une paire de coordonnées (X,Y) pour les structures de chiffrement à courbe elliptique.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECPoint.X">
      <summary>Représente la coordonnée X.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECPoint.Y">
      <summary>Représente la coordonnée Y.</summary>
    </member>
    <member name="T:System.Security.Cryptography.HMACMD5">
      <summary>Calcule un code HMAC (Hash-based Message Authentication Code) à l'aide de la fonction de hachage <see cref="T:System.Security.Cryptography.MD5" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.HMACMD5.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.HMACMD5" /> en utilisant une clé générée de manière aléatoire.</summary>
    </member>
    <member name="M:System.Security.Cryptography.HMACMD5.#ctor(System.Byte[])">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.HMACMD5" /> à l'aide de la clé spécifiée.</summary>
      <param name="key">Clé secrète pour le chiffrement <see cref="T:System.Security.Cryptography.HMACMD5" />. La clé peut avoir n'importe quelle longueur, mais si elle dépasse 64 octets, elle sera hachée (à l'aide de SHA-1) pour dériver une clé de 64 octets. Par conséquent, la taille recommandée pour la clé secrète est égale à 64 octets.</param>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="key" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.HMACMD5.Dispose(System.Boolean)">
      <param name="disposing" />
    </member>
    <member name="M:System.Security.Cryptography.HMACMD5.HashCore(System.Byte[],System.Int32,System.Int32)">
      <param name="rgb" />
      <param name="ib" />
      <param name="cb" />
    </member>
    <member name="M:System.Security.Cryptography.HMACMD5.HashCore(System.ReadOnlySpan{System.Byte})">
      <param name="source" />
    </member>
    <member name="M:System.Security.Cryptography.HMACMD5.HashFinal" />
    <member name="M:System.Security.Cryptography.HMACMD5.Initialize" />
    <member name="P:System.Security.Cryptography.HMACMD5.Key" />
    <member name="M:System.Security.Cryptography.HMACMD5.TryHashFinal(System.Span{System.Byte},System.Int32@)">
      <param name="destination" />
      <param name="bytesWritten" />
    </member>
    <member name="T:System.Security.Cryptography.HMACSHA1">
      <summary>Calcule un code HMAC (Hash-based Message Authentication Code) à l'aide de la fonction de hachage <see cref="T:System.Security.Cryptography.SHA1" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA1.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.HMACSHA1" /> avec une clé générée de manière aléatoire.</summary>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA1.#ctor(System.Byte[])">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.HMACSHA1" /> avec les données de clé spécifiées.</summary>
      <param name="key">Clé secrète pour le chiffrement <see cref="T:System.Security.Cryptography.HMACSHA1" />. La clé peut avoir n'importe quelle longueur, mais si elle dépasse 64 octets, elle est hachée (à l'aide de SHA-1) pour dériver une clé de 64 octets. Par conséquent, la taille recommandée pour la clé secrète est égale à 64 octets.</param>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="key" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA1.#ctor(System.Byte[],System.Boolean)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.HMACSHA1" /> avec les données de clés spécifiées et une valeur qui spécifie s'il faut utiliser la version managée de l'algorithme SHA1.</summary>
      <param name="key">Clé secrète pour le chiffrement <see cref="T:System.Security.Cryptography.HMACSHA1" />. La clé peut avoir n'importe quelle longueur, mais si elle dépasse 64 octets, elle est hachée (à l'aide de SHA-1) pour dériver une clé de 64 octets. Par conséquent, la taille recommandée pour la clé secrète est égale à 64 octets.</param>
      <param name="useManagedSha1">
        <see langword="true" /> pour utiliser l'implémentation managée de l'algorithme SHA1 (la classe <see cref="T:System.Security.Cryptography.SHA1Managed" />) ; <see langword="false" /> pour utiliser l'implémentation non managée (la classe <see cref="T:System.Security.Cryptography.SHA1CryptoServiceProvider" />).</param>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA1.Dispose(System.Boolean)">
      <summary>Ce membre substitue <see cref="M:System.Security.Cryptography.KeyedHashAlgorithm.Dispose(System.Boolean)" />. Une documentation plus complète est peut-être disponible dans cette rubrique.
Libère les ressources non managées utilisées par <see cref="T:System.Security.Cryptography.KeyedHashAlgorithm" /> et libère éventuellement les ressources managées.</summary>
      <param name="disposing">
        <see langword="true" /> pour libérer les ressources managées et non managées ; false pour libérer uniquement les ressources non managées.</param>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA1.HashCore(System.Byte[],System.Int32,System.Int32)">
      <summary>Route les données écrites dans l’objet vers l’algorithme de hachage SHA1 pour calculer le HMAC (code d’authentification de message basé sur un code de hachage).</summary>
      <param name="rgb">Données d'entrée.</param>
      <param name="ib">Offset dans le tableau d'octets à partir duquel l'utilisation de données commence.</param>
      <param name="cb">Nombre d'octets dans le tableau à utiliser comme données.</param>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA1.HashCore(System.ReadOnlySpan{System.Byte})">
      <param name="source" />
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA1.HashFinal" />
    <member name="M:System.Security.Cryptography.HMACSHA1.Initialize">
      <summary>Initialise une instance de <see cref="T:System.Security.Cryptography.HMACSHA1" />.</summary>
    </member>
    <member name="P:System.Security.Cryptography.HMACSHA1.Key">
      <summary>Obtient ou définit la clé à utiliser dans l'algorithme de hachage.</summary>
      <returns>Clé à utiliser dans l'algorithme de hachage.</returns>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA1.TryHashFinal(System.Span{System.Byte},System.Int32@)">
      <param name="destination" />
      <param name="bytesWritten" />
    </member>
    <member name="T:System.Security.Cryptography.HMACSHA256">
      <summary>Calcule un code HMAC (Hash-based Message Authentication Code) à l'aide de la fonction de hachage <see cref="T:System.Security.Cryptography.SHA256" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA256.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.HMACSHA256" /> avec une clé générée de manière aléatoire.</summary>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA256.#ctor(System.Byte[])">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.HMACSHA256" /> avec les données de clé spécifiées.</summary>
      <param name="key">Clé secrète pour le chiffrement <see cref="T:System.Security.Cryptography.HMACSHA256" />. La clé peut avoir n'importe quelle longueur. Toutefois, la taille recommandée est de 64 octets. Si la clé dépasse 64 octets, elle est hachée (à l'aide de SHA-256) pour dériver une clé de 64 octets. Si la valeur est inférieure à 64 octets, elle est complétée jusqu'à 64 octets.</param>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="key" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA256.Dispose(System.Boolean)">
      <param name="disposing" />
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA256.HashCore(System.Byte[],System.Int32,System.Int32)">
      <param name="rgb" />
      <param name="ib" />
      <param name="cb" />
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA256.HashCore(System.ReadOnlySpan{System.Byte})">
      <param name="source" />
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA256.HashFinal" />
    <member name="M:System.Security.Cryptography.HMACSHA256.Initialize" />
    <member name="P:System.Security.Cryptography.HMACSHA256.Key" />
    <member name="M:System.Security.Cryptography.HMACSHA256.TryHashFinal(System.Span{System.Byte},System.Int32@)">
      <param name="destination" />
      <param name="bytesWritten" />
    </member>
    <member name="T:System.Security.Cryptography.HMACSHA384">
      <summary>Calcule un code HMAC (Hash-based Message Authentication Code) à l'aide de la fonction de hachage <see cref="T:System.Security.Cryptography.SHA384" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA384.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.HMACSHA384" /> en utilisant une clé générée de manière aléatoire.</summary>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA384.#ctor(System.Byte[])">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.HMACSHA384" /> à l'aide des données de clé spécifiées.</summary>
      <param name="key">Clé secrète pour le chiffrement <see cref="T:System.Security.Cryptography.HMACSHA384" />. La clé peut avoir n'importe quelle longueur. Toutefois, la taille recommandée est de 128 octets. Si la clé dépasse 128 octets, elle est hachée (à l’aide de SHA-384) pour dériver une clé de 128 octets. Si la valeur est inférieure à 128 octets, elle est complétée jusqu’à 128 octets.</param>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="key" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA384.Dispose(System.Boolean)">
      <param name="disposing" />
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA384.HashCore(System.Byte[],System.Int32,System.Int32)">
      <param name="rgb" />
      <param name="ib" />
      <param name="cb" />
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA384.HashCore(System.ReadOnlySpan{System.Byte})">
      <param name="source" />
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA384.HashFinal" />
    <member name="M:System.Security.Cryptography.HMACSHA384.Initialize" />
    <member name="P:System.Security.Cryptography.HMACSHA384.Key" />
    <member name="P:System.Security.Cryptography.HMACSHA384.ProduceLegacyHmacValues">
      <summary>Fournit une solution de contournement pour l’implémentation .NET Framework 2.0 de l’algorithme <see cref="T:System.Security.Cryptography.HMACSHA384" />, qui est incohérent avec l’implémentation .NET Framework 2.0 Service Pack 1 de l’algorithme.</summary>
      <returns>
        <see langword="true" /> pour permettre aux applications .NET Framework 2.0 Service Pack 1 d'interagir avec les applications .NET Framework 2.0 ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA384.TryHashFinal(System.Span{System.Byte},System.Int32@)">
      <param name="destination" />
      <param name="bytesWritten" />
    </member>
    <member name="T:System.Security.Cryptography.HMACSHA512">
      <summary>Calcule un code HMAC (Hash-based Message Authentication Code) à l'aide de la fonction de hachage <see cref="T:System.Security.Cryptography.SHA512" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA512.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.HMACSHA512" /> avec une clé générée de manière aléatoire.</summary>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA512.#ctor(System.Byte[])">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.HMACSHA512" /> avec les données de clé spécifiées.</summary>
      <param name="key">Clé secrète pour le chiffrement <see cref="T:System.Security.Cryptography.HMACSHA512" />. La clé peut avoir n'importe quelle longueur. Toutefois, la taille recommandée est de 128 octets. Si la clé dépasse 128 octets, elle est hachée (à l’aide de SHA-512) pour dériver une clé de 128 octets. Si la valeur est inférieure à 128 octets, elle est complétée jusqu’à 128 octets.</param>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="key" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA512.Dispose(System.Boolean)">
      <param name="disposing" />
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA512.HashCore(System.Byte[],System.Int32,System.Int32)">
      <param name="rgb" />
      <param name="ib" />
      <param name="cb" />
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA512.HashCore(System.ReadOnlySpan{System.Byte})">
      <param name="source" />
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA512.HashFinal" />
    <member name="M:System.Security.Cryptography.HMACSHA512.Initialize" />
    <member name="P:System.Security.Cryptography.HMACSHA512.Key" />
    <member name="P:System.Security.Cryptography.HMACSHA512.ProduceLegacyHmacValues">
      <summary>Fournit une solution de contournement pour l'implémentation .NET Framework 2.0 de l'algorithme <see cref="T:System.Security.Cryptography.HMACSHA512" />, qui est incohérent avec l'implémentation .NET Framework 2.0 Service Pack 1.</summary>
      <returns>
        <see langword="true" /> pour permettre aux applications .NET Framework 2.0 Service Pack 1 d'interagir avec les applications .NET Framework 2.0 ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA512.TryHashFinal(System.Span{System.Byte},System.Int32@)">
      <param name="destination" />
      <param name="bytesWritten" />
    </member>
    <member name="T:System.Security.Cryptography.IncrementalHash">
      <summary>Fournit la prise en charge du calcul d’un hachage ou d’une valeur HMAC (Hash-based Message Authentication Code) incrémentielle sur plusieurs segments.</summary>
    </member>
    <member name="P:System.Security.Cryptography.IncrementalHash.AlgorithmName">
      <summary>Obtient le nom de l’algorithme exécuté. Les algorithmes HMAC sont précédés de « HMAC » pour les distinguer d’un code de hachage sans clé.</summary>
      <returns>Nom de l’algorithme exécuté.</returns>
    </member>
    <member name="M:System.Security.Cryptography.IncrementalHash.AppendData(System.Byte[])">
      <summary>Ajoute les données spécifiées aux données déjà traitées dans le hachage ou le code HMAC.</summary>
      <param name="data">Données à traiter.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ObjectDisposedException">L’objet <see cref="T:System.Security.Cryptography.IncrementalHash" /> a déjà été supprimé.</exception>
    </member>
    <member name="M:System.Security.Cryptography.IncrementalHash.AppendData(System.Byte[],System.Int32,System.Int32)">
      <summary>Ajoute le nombre spécifié d’octets à partir des données spécifiées, en commençant à l’offset spécifié, aux données déjà traitées dans le hachage ou le code HMAC (Hash-based Message Authentication Code).</summary>
      <param name="data">Données à traiter.</param>
      <param name="offset">Offset dans le tableau d'octets à partir duquel l'utilisation de données commence.</param>
      <param name="count">Nombre d’octets à utiliser à partir de <paramref name="data" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="count" /> ou <paramref name="offset" /> est un nombre négatif.  

ou - 
<paramref name="count" /> est supérieur à la longueur de <paramref name="data" />.</exception>
      <exception cref="T:System.ArgumentException">La somme de <paramref name="offset" /> et <paramref name="count" /> est supérieure à la longueur des données.</exception>
      <exception cref="T:System.ObjectDisposedException">L’objet <see cref="T:System.Security.Cryptography.IncrementalHash" /> a déjà été supprimé.</exception>
    </member>
    <member name="M:System.Security.Cryptography.IncrementalHash.AppendData(System.ReadOnlySpan{System.Byte})">
      <param name="data" />
    </member>
    <member name="M:System.Security.Cryptography.IncrementalHash.CreateHash(System.Security.Cryptography.HashAlgorithmName)">
      <summary>Crée un <see cref="T:System.Security.Cryptography.IncrementalHash" /> pour l’algorithme spécifié.</summary>
      <param name="hashAlgorithm">Nom de l’algorithme de hachage à exécuter.</param>
      <returns>Instance de <see cref="T:System.Security.Cryptography.IncrementalHash" /> prête pour le calcul de l’algorithme de hachage spécifié par <paramref name="hashAlgorithm" />.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> est soit <see langword="null" /> soit une chaîne vide.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="hashAlgorithm" /> n’est pas un algorithme de hachage connu.</exception>
    </member>
    <member name="M:System.Security.Cryptography.IncrementalHash.CreateHMAC(System.Security.Cryptography.HashAlgorithmName,System.Byte[])">
      <summary>Crée un <see cref="T:System.Security.Cryptography.IncrementalHash" /> pour l’algorithme HMAC (Hash-based Message Authentication Code) à l’aide de la clé et de l’algorithme de hachage spécifiés.</summary>
      <param name="hashAlgorithm">Nom de l’algorithme de hachage à exécuter dans le HMAC.</param>
      <param name="key">Clé secrète pour le HMAC. La clé peut être de n’importe quelle longueur, mais une clé dont la taille est supérieure à celle de la sortie de l’algorithme de hachage spécifié sera hachée pour dériver une clé de dimension correcte. Par conséquent, la taille recommandée de la clé secrète est la taille de la sortie de l’algorithme de hachage spécifié.</param>
      <returns>Instance de la classe <see cref="T:System.Security.Cryptography.IncrementalHash" /> prête pour le calcul de l’algorithme de hachage spécifié.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> est soit <see langword="null" /> soit une chaîne vide.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="hashAlgorithm" /> n’est pas un algorithme de hachage connu.</exception>
    </member>
    <member name="M:System.Security.Cryptography.IncrementalHash.Dispose">
      <summary>Libère les ressources utilisées par l'instance actuelle de la classe <see cref="T:System.Security.Cryptography.IncrementalHash" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.IncrementalHash.GetHashAndReset">
      <summary>Récupère le hachage ou le code HMAC (Hash-based Message Authentication Code) des données accumulées lors des appels précédents à la méthode <see cref="M:System.Security.Cryptography.IncrementalHash.AppendData(System.Byte[])" />, puis rétablit l’état initial de l’objet.</summary>
      <returns>Hachage ou code HMAC calculé.</returns>
      <exception cref="T:System.ObjectDisposedException">L’objet <see cref="T:System.Security.Cryptography.IncrementalHash" /> a déjà été supprimé.</exception>
    </member>
    <member name="M:System.Security.Cryptography.IncrementalHash.TryGetHashAndReset(System.Span{System.Byte},System.Int32@)">
      <param name="destination" />
      <param name="bytesWritten" />
    </member>
    <member name="T:System.Security.Cryptography.MaskGenerationMethod">
      <summary>Représente la classe abstraite dont tous les algorithmes du générateur de masques doivent dériver.</summary>
    </member>
    <member name="M:System.Security.Cryptography.MaskGenerationMethod.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.MaskGenerationMethod" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.MaskGenerationMethod.GenerateMask(System.Byte[],System.Int32)">
      <summary>En cas de substitution dans une classe dérivée, génère un masque de la longueur spécifiée à l'aide de la valeur initiale aléatoire indiquée.</summary>
      <param name="rgbSeed">Valeur initiale aléatoire à utiliser pour calculer le masque.</param>
      <param name="cbReturn">Longueur, en octets, du masque généré.</param>
      <returns>Masque généré de manière aléatoire dont la longueur est égale au paramètre <paramref name="cbReturn" />.</returns>
    </member>
    <member name="T:System.Security.Cryptography.MD5">
      <summary>Représente la classe abstraite dont toutes les implémentations de l'algorithme de hachage <see cref="T:System.Security.Cryptography.MD5" /> héritent.</summary>
    </member>
    <member name="M:System.Security.Cryptography.MD5.#ctor">
      <summary>Initialise une nouvelle instance de <see cref="T:System.Security.Cryptography.MD5" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.MD5.Create">
      <summary>Crée une instance de l'implémentation par défaut de l'algorithme de hachage <see cref="T:System.Security.Cryptography.MD5" />.</summary>
      <returns>Nouvelle instance de l'algorithme de hachage <see cref="T:System.Security.Cryptography.MD5" />.</returns>
      <exception cref="T:System.Reflection.TargetInvocationException">L’algorithme a été utilisé en mode FIPS (Federal Information Processing Standards), mais il n’est pas compatible avec la norme FIPS.</exception>
    </member>
    <member name="M:System.Security.Cryptography.MD5.Create(System.String)">
      <summary>Crée une instance de l'implémentation spécifiée de l'algorithme de hachage <see cref="T:System.Security.Cryptography.MD5" />.</summary>
      <param name="algName">Nom de l'implémentation spécifique de <see cref="T:System.Security.Cryptography.MD5" /> à utiliser.</param>
      <returns>Nouvelle instance de l'implémentation spécifiée de <see cref="T:System.Security.Cryptography.MD5" />.</returns>
      <exception cref="T:System.Reflection.TargetInvocationException">L'algorithme décrit par le paramètre <paramref name="algName" /> a été utilisé avec mode FIPS activé, mais n'est pas compatible FIPS.</exception>
    </member>
    <member name="T:System.Security.Cryptography.PKCS1MaskGenerationMethod">
      <summary>Calcule, en fonction du PKCS #1, les masques que les algorithmes d'échange de clés utilisent.</summary>
    </member>
    <member name="M:System.Security.Cryptography.PKCS1MaskGenerationMethod.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.PKCS1MaskGenerationMethod" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.PKCS1MaskGenerationMethod.GenerateMask(System.Byte[],System.Int32)">
      <summary>Génère et retourne un masque à partir de la valeur initiale aléatoire de la longueur spécifiée.</summary>
      <param name="rgbSeed">Valeur initiale aléatoire à utiliser pour calculer le masque.</param>
      <param name="cbReturn">Longueur, en octets, du masque généré.</param>
      <returns>Masque généré de manière aléatoire dont la longueur est égale au paramètre <paramref name="cbReturn" />.</returns>
    </member>
    <member name="P:System.Security.Cryptography.PKCS1MaskGenerationMethod.HashName">
      <summary>Obtient ou définit le nom de l’algorithme de hachage à utiliser pour générer le masque.</summary>
      <returns>Nom du type qui implémente l’algorithme de hachage à utiliser pour calculer le masque.</returns>
    </member>
    <member name="T:System.Security.Cryptography.RandomNumberGenerator">
      <summary>Représente la classe abstraite dont toutes les implémentations des générateurs de nombres aléatoires de chiffrement doivent hériter.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.#ctor">
      <summary>Initialise une nouvelle instance de <see cref="T:System.Security.Cryptography.RandomNumberGenerator" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.Create">
      <summary>Crée une instance de l’implémentation par défaut d’un générateur de nombres aléatoires de chiffrement permettant de générer des données aléatoires.</summary>
      <returns>Nouvelle instance d'un générateur de nombres aléatoires de chiffrement.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.Create(System.String)">
      <summary>Crée une instance de l’implémentation spécifiée d’un générateur de nombres aléatoires de chiffrement.</summary>
      <param name="rngName">Nom de l'implémentation du générateur de nombres aléatoires à utiliser.</param>
      <returns>Nouvelle instance d'un générateur de nombres aléatoires de chiffrement.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.Dispose">
      <summary>En cas de substitution dans une classe dérivée, libère toutes les ressources utilisées par l’instance actuelle de la classe <see cref="T:System.Security.Cryptography.RandomNumberGenerator" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.Dispose(System.Boolean)">
      <summary>En cas de substitution dans une classe dérivée, libère les ressources non managées utilisées par <see cref="T:System.Security.Cryptography.RandomNumberGenerator" /> et libère éventuellement les ressources managées.</summary>
      <param name="disposing">
        <see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour libérer uniquement les ressources non managées.</param>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.Fill(System.Span{System.Byte})">
      <summary>Remplit une étendue avec les octets aléatoires forts du point de vue du chiffrement.</summary>
      <param name="data">Étendue à remplir avec les octets aléatoires forts du point de vue du chiffrement.</param>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.GetBytes(System.Byte[])">
      <summary>En cas de substitution dans une classe dérivée, remplit un tableau d'octets avec une séquence de valeurs aléatoire et forte du point de vue du chiffrement.</summary>
      <param name="data">Tableau à remplir avec les octets aléatoires forts du point de vue du chiffrement.</param>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.GetBytes(System.Byte[],System.Int32,System.Int32)">
      <summary>Remplit le tableau d'octets spécifié avec une séquence de valeurs aléatoire et forte du point de vue du chiffrement.</summary>
      <param name="data">Tableau à remplir avec les octets aléatoires forts du point de vue du chiffrement.</param>
      <param name="offset">Index du tableau auquel commencer l'opération de remplissage.</param>
      <param name="count">Nombre d'octets à remplir.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="offset" /> ou <paramref name="count" /> est inférieur à 0.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="offset" /> plus <paramref name="count" /> excède la longueur de <paramref name="data" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.GetBytes(System.Span{System.Byte})">
      <summary>Remplit une étendue avec les octets aléatoires forts du point de vue du chiffrement.</summary>
      <param name="data">Étendue à remplir avec les octets aléatoires forts du point de vue du chiffrement.</param>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.GetInt32(System.Int32)">
      <summary>Génère un entier aléatoire compris entre 0 (inclus) et une limite supérieure exclue spécifiée à l’aide d’un générateur de nombres aléatoires forts du point de vue du chiffrement.</summary>
      <param name="toExclusive">Limite supérieure exclue de la plage aléatoire.</param>
      <returns>Entier aléatoire compris entre 0 (inclus) et <paramref name="toExclusive" /> (exclu).</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">Le paramètre <paramref name="toExclusive" /> est inférieur ou égal à 0.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.GetInt32(System.Int32,System.Int32)">
      <summary>Génère un entier aléatoire compris entre une limite inférieure incluse spécifiée et une limite supérieure exclue spécifiée à l’aide d’un générateur de nombres aléatoires forts du point de vue du chiffrement.</summary>
      <param name="fromInclusive">Limite inférieure incluse de la plage aléatoire.</param>
      <param name="toExclusive">Limite supérieure exclue de la plage aléatoire.</param>
      <returns>Entier aléatoire compris entre <paramref name="fromInclusive" /> (inclus) et <paramref name="toExclusive" /> (exclu).</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">Le paramètre <paramref name="toExclusive" /> est inférieur ou égal au paramètre <paramref name="fromInclusive" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.GetNonZeroBytes(System.Byte[])">
      <summary>En cas de substitution dans une classe dérivée, remplit un tableau d'octets avec une séquence de valeurs différentes de zéro, aléatoire et forte du point de vue du chiffrement.</summary>
      <param name="data">Tableau à remplir avec les octets aléatoires forts du point de vue du chiffrement, différents de zéro.</param>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.GetNonZeroBytes(System.Span{System.Byte})">
      <summary>Remplit une étendue d’octets avec une séquence aléatoire forte du point de vue du chiffrement de valeurs différentes de zéro.</summary>
      <param name="data">Étendue à remplir avec les octets aléatoires forts du point de vue du chiffrement, différents de zéro.</param>
    </member>
    <member name="T:System.Security.Cryptography.RC2">
      <summary>Représente la classe de base dont toutes les implémentations de l'algorithme <see cref="T:System.Security.Cryptography.RC2" /> doivent dériver.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RC2.#ctor">
      <summary>Initialise une nouvelle instance de <see cref="T:System.Security.Cryptography.RC2" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RC2.Create">
      <summary>Crée une instance d’un objet de chiffrement pour exécuter l’algorithme <see cref="T:System.Security.Cryptography.RC2" />.</summary>
      <returns>Instance d’un objet de chiffrement.</returns>
      <exception cref="T:System.Reflection.TargetInvocationException">L’algorithme a été utilisé en mode FIPS (Federal Information Processing Standards), mais il n’est pas compatible avec la norme FIPS.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RC2.Create(System.String)">
      <summary>Crée une instance d'un objet de chiffrement pour exécuter l'implémentation spécifiée de l'algorithme <see cref="T:System.Security.Cryptography.RC2" />.</summary>
      <param name="AlgName">Nom de l'implémentation spécifique de <see cref="T:System.Security.Cryptography.RC2" /> à utiliser.</param>
      <returns>Instance d’un objet de chiffrement.</returns>
      <exception cref="T:System.Reflection.TargetInvocationException">L'algorithme décrit par le paramètre <paramref name="algName" /> a été utilisé avec mode FIPS activé, mais n'est pas compatible FIPS.</exception>
    </member>
    <member name="P:System.Security.Cryptography.RC2.EffectiveKeySize">
      <summary>Obtient ou définit la taille effective de la clé secrète utilisée par l'algorithme <see cref="T:System.Security.Cryptography.RC2" />, en bits.</summary>
      <returns>Taille effective de la clé utilisée par l'algorithme <see cref="T:System.Security.Cryptography.RC2" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La taille effective de la clé n'est pas valide.</exception>
    </member>
    <member name="F:System.Security.Cryptography.RC2.EffectiveKeySizeValue">
      <summary>Représente la taille effective de la clé secrète utilisée par l'algorithme <see cref="T:System.Security.Cryptography.RC2" />, en bits.</summary>
    </member>
    <member name="P:System.Security.Cryptography.RC2.KeySize">
      <summary>Obtient ou définit la taille de la clé secrète utilisée par l'algorithme <see cref="T:System.Security.Cryptography.RC2" />, en bits.</summary>
      <returns>Taille de la clé secrète utilisée par l'algorithme <see cref="T:System.Security.Cryptography.RC2" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La valeur relative à la taille de la clé RC2 est inférieure à la valeur de la taille effective de la clé.</exception>
    </member>
    <member name="T:System.Security.Cryptography.Rfc2898DeriveBytes">
      <summary>Implémente une fonctionnalité de dérivation de clé basée sur mot de passe, PBKDF2, en utilisant un générateur de nombres pseudo-aléatoires basé sur <see cref="T:System.Security.Cryptography.HMACSHA1" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> à l'aide d'un mot de passe, d'un salt et d'un nombre d'itérations pour dériver la clé.</summary>
      <param name="password">Mot de passe utilisé pour dériver la clé.</param>
      <param name="salt">Salt de clé à utiliser pour dériver la clé.</param>
      <param name="iterations">Nombre d'itérations pour l'opération.</param>
      <exception cref="T:System.ArgumentException">La taille de salt spécifiée est inférieure à 8 octets ou le nombre d'itérations est inférieur à 1.</exception>
      <exception cref="T:System.ArgumentNullException">Le mot de passe ou le salt est <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32,System.Security.Cryptography.HashAlgorithmName)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> en utilisant le mot de passe, le salt, le nombre d’itérations et le nom de l’algorithme de hachage spécifiés pour dériver la clé.</summary>
      <param name="password">Mot de passe à utiliser pour dériver la clé.</param>
      <param name="salt">Salt de clé à utiliser pour dériver la clé.</param>
      <param name="iterations">Nombre d'itérations pour l'opération.</param>
      <param name="hashAlgorithm">Algorithme de hachage à utiliser pour dériver la clé.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="saltSize" /> est inférieur à zéro.</exception>
      <exception cref="T:System.ArgumentException">La propriété <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> de <paramref name="hashAlgorithm" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le nom de l’algorithme de hachage n’est pas valide.</exception>
    </member>
    <member name="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> à l'aide d'un mot de passe et d'un salt pour dériver la clé.</summary>
      <param name="password">Mot de passe utilisé pour dériver la clé.</param>
      <param name="salt">Salt de clé à utiliser pour dériver la clé.</param>
      <exception cref="T:System.ArgumentException">La taille de salt spécifiée est inférieure à 8 octets ou le nombre d'itérations est inférieur à 1.</exception>
      <exception cref="T:System.ArgumentNullException">Le mot de passe ou le salt est <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> à l'aide d'un mot de passe, d'un salt et d'un nombre d'itérations pour dériver la clé.</summary>
      <param name="password">Mot de passe utilisé pour dériver la clé.</param>
      <param name="salt">Salt de clé à utiliser pour dériver la clé.</param>
      <param name="iterations">Nombre d'itérations pour l'opération.</param>
      <exception cref="T:System.ArgumentException">La taille de salt spécifiée est inférieure à 8 octets ou le nombre d'itérations est inférieur à 1.</exception>
      <exception cref="T:System.ArgumentNullException">Le mot de passe ou le salt est <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32,System.Security.Cryptography.HashAlgorithmName)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> en utilisant le mot de passe, le salt, le nombre d’itérations et le nom de l’algorithme de hachage spécifiés pour dériver la clé.</summary>
      <param name="password">Mot de passe à utiliser pour dériver la clé.</param>
      <param name="salt">Salt de clé à utiliser pour dériver la clé.</param>
      <param name="iterations">Nombre d'itérations pour l'opération.</param>
      <param name="hashAlgorithm">Algorithme de hachage à utiliser pour dériver la clé.</param>
      <exception cref="T:System.ArgumentException">La propriété <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> de <paramref name="hashAlgorithm" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le nom de l’algorithme de hachage n’est pas valide.</exception>
    </member>
    <member name="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> à l'aide du mot de passe et de la taille de salt pour dériver la clé.</summary>
      <param name="password">Mot de passe utilisé pour dériver la clé.</param>
      <param name="saltSize">Taille du salt aléatoire que vous souhaitez que la classe génère.</param>
      <exception cref="T:System.ArgumentException">La taille de salt spécifiée est inférieure à 8 octets.</exception>
      <exception cref="T:System.ArgumentNullException">Le mot de passe ou le salt est <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> à l'aide d'un mot de passe, d'une taille de salt et d'un nombre d'itérations pour dériver la clé.</summary>
      <param name="password">Mot de passe utilisé pour dériver la clé.</param>
      <param name="saltSize">Taille du salt aléatoire que vous souhaitez que la classe génère.</param>
      <param name="iterations">Nombre d'itérations pour l'opération.</param>
      <exception cref="T:System.ArgumentException">La taille de salt spécifiée est inférieure à 8 octets ou le nombre d'itérations est inférieur à 1.</exception>
      <exception cref="T:System.ArgumentNullException">Le mot de passe ou le salt est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="iterations" /> est hors limites. Ce paramètre requiert un nombre non négatif.</exception>
    </member>
    <member name="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> en utilisant le mot de passe, la taille de salt, le nombre d’itérations et le nom de l’algorithme de hachage spécifiés pour dériver la clé.</summary>
      <param name="password">Mot de passe à utiliser pour dériver la clé.</param>
      <param name="saltSize">Taille du salt aléatoire que vous souhaitez que la classe génère.</param>
      <param name="iterations">Nombre d'itérations pour l'opération.</param>
      <param name="hashAlgorithm">Algorithme de hachage à utiliser pour dériver la clé.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="saltSize" /> est inférieur à zéro.</exception>
      <exception cref="T:System.ArgumentException">La propriété <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> de <paramref name="hashAlgorithm" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le nom de l’algorithme de hachage n’est pas valide.</exception>
    </member>
    <member name="M:System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])">
      <summary>Dérive une clé de chiffrement de l'objet <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" />.</summary>
      <param name="algname">Nom de l'algorithme pour lequel la clé doit être dérivée.</param>
      <param name="alghashname">Nom de l'algorithme de hachage à utiliser pour dériver la clé.</param>
      <param name="keySize">Taille de la clé à dériver, en bits.</param>
      <param name="rgbIV">Vecteur d'initialisation (IV) à utiliser pour dériver la clé.</param>
      <returns>Clé dérivée.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le paramètre <paramref name="keySize" /> est incorrect.  

ou - 
Le fournisseur de services de chiffrement ne peut pas être acquis.  

ou - 
Le paramètre <paramref name="algname" /> n'est pas un nom d'algorithme valide.  

ou - 
Le paramètre <paramref name="alghashname" /> n'est pas un nom d'algorithme de hachage valide.</exception>
    </member>
    <member name="M:System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(System.Boolean)">
      <summary>Libère les ressources non managées utilisées par la classe <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> et libère éventuellement les ressources managées.</summary>
      <param name="disposing">
        <see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour libérer uniquement les ressources non managées.</param>
    </member>
    <member name="M:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(System.Int32)">
      <summary>Retourne la clé pseudo-aléatoire de cet objet.</summary>
      <param name="cb">Nombre d'octets de clé pseudo-aléatoires à générer.</param>
      <returns>Tableau d'octets rempli avec des octets de clé pseudo-aléatoires.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="cb" /> est hors limites. Ce paramètre requiert un nombre non négatif.</exception>
    </member>
    <member name="P:System.Security.Cryptography.Rfc2898DeriveBytes.HashAlgorithm" />
    <member name="P:System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount">
      <summary>Obtient ou définit le nombre d'itérations pour l'opération.</summary>
      <returns>Nombre d'itérations pour l'opération.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">Le nombre d'itérations est inférieur à 1.</exception>
    </member>
    <member name="M:System.Security.Cryptography.Rfc2898DeriveBytes.Reset">
      <summary>Rétablit l'état de l'opération.</summary>
    </member>
    <member name="P:System.Security.Cryptography.Rfc2898DeriveBytes.Salt">
      <summary>Obtient ou définit la valeur salt de clé pour l'opération.</summary>
      <returns>Valeur salt de clé pour l'opération.</returns>
      <exception cref="T:System.ArgumentException">La taille de salt spécifiée est inférieure à 8 octets.</exception>
      <exception cref="T:System.ArgumentNullException">Le salt est <see langword="null" />.</exception>
    </member>
    <member name="T:System.Security.Cryptography.Rijndael">
      <summary>Représente la classe de base dont toutes les implémentations de l'algorithme de chiffrement symétrique <see cref="T:System.Security.Cryptography.Rijndael" /> doivent hériter.</summary>
    </member>
    <member name="M:System.Security.Cryptography.Rijndael.#ctor">
      <summary>Initialise une nouvelle instance de <see cref="T:System.Security.Cryptography.Rijndael" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.Rijndael.Create">
      <summary>Crée un objet de chiffrement pour exécuter l'algorithme <see cref="T:System.Security.Cryptography.Rijndael" />.</summary>
      <returns>Objet de chiffrement.</returns>
      <exception cref="T:System.Reflection.TargetInvocationException">L’algorithme a été utilisé en mode FIPS (Federal Information Processing Standards), mais il n’est pas compatible avec la norme FIPS.</exception>
    </member>
    <member name="M:System.Security.Cryptography.Rijndael.Create(System.String)">
      <summary>Crée un objet de chiffrement pour effectuer l'implémentation spécifiée de l'algorithme <see cref="T:System.Security.Cryptography.Rijndael" />.</summary>
      <param name="algName">Nom de l'implémentation spécifique de <see cref="T:System.Security.Cryptography.Rijndael" /> à créer.</param>
      <returns>Objet de chiffrement.</returns>
      <exception cref="T:System.Reflection.TargetInvocationException">L'algorithme décrit par le paramètre <paramref name="algName" /> a été utilisé avec mode FIPS activé, mais n'est pas compatible FIPS.</exception>
    </member>
    <member name="T:System.Security.Cryptography.RijndaelManaged">
      <summary>Accède à la version managée de l'algorithme <see cref="T:System.Security.Cryptography.Rijndael" />. Cette classe ne peut pas être héritée.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RijndaelManaged.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.RijndaelManaged" />.</summary>
      <exception cref="T:System.InvalidOperationException">Cette classe n'est pas compatible avec l'algorithme FIPS.</exception>
    </member>
    <member name="P:System.Security.Cryptography.RijndaelManaged.BlockSize">
      <summary>Obtient ou définit la taille de bloc, en bits, de l'opération de chiffrement.</summary>
      <returns>Taille de bloc, en bits, de l’opération de chiffrement. La valeur par défaut est 128 bits.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RijndaelManaged.CreateDecryptor" />
    <member name="M:System.Security.Cryptography.RijndaelManaged.CreateDecryptor(System.Byte[],System.Byte[])">
      <summary>Crée un objet déchiffreur <see cref="T:System.Security.Cryptography.Rijndael" /> symétrique avec le <see cref="P:System.Security.Cryptography.SymmetricAlgorithm.Key" /> spécifié et le vecteur d'initialisation (<see cref="P:System.Security.Cryptography.SymmetricAlgorithm.IV" />).</summary>
      <param name="rgbKey">Clé secrète à utiliser pour l'algorithme symétrique. La taille de la clé doit être de 128, 192 ou 256 bits.</param>
      <param name="rgbIV">Vecteur d'initialisation (IV) à utiliser pour l'algorithme symétrique.</param>
      <returns>Objet déchiffreur <see cref="T:System.Security.Cryptography.Rijndael" /> symétrique.</returns>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="rgbKey" /> a la valeur <see langword="null" />.  
ou 
Le paramètre <paramref name="rgbIV" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La valeur de la propriété <see cref="P:System.Security.Cryptography.SymmetricAlgorithm.Mode" /> n'est ni <see cref="F:System.Security.Cryptography.CipherMode.ECB" />, <see cref="F:System.Security.Cryptography.CipherMode.CBC" /> ni <see cref="F:System.Security.Cryptography.CipherMode.CFB" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RijndaelManaged.CreateEncryptor" />
    <member name="M:System.Security.Cryptography.RijndaelManaged.CreateEncryptor(System.Byte[],System.Byte[])">
      <summary>Crée un objet chiffreur <see cref="T:System.Security.Cryptography.Rijndael" /> symétrique avec le <see cref="P:System.Security.Cryptography.SymmetricAlgorithm.Key" /> spécifié et le vecteur d'initialisation (<see cref="P:System.Security.Cryptography.SymmetricAlgorithm.IV" />).</summary>
      <param name="rgbKey">Clé secrète à utiliser pour l'algorithme symétrique. La taille de la clé doit être de 128, 192 ou 256 bits.</param>
      <param name="rgbIV">Vecteur d'initialisation (IV) à utiliser pour l'algorithme symétrique.</param>
      <returns>Objet chiffreur <see cref="T:System.Security.Cryptography.Rijndael" /> symétrique.</returns>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="rgbKey" /> a la valeur <see langword="null" />.  

ou - 
Le paramètre <paramref name="rgbIV" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La valeur de la propriété <see cref="P:System.Security.Cryptography.SymmetricAlgorithm.Mode" /> n'est ni <see cref="F:System.Security.Cryptography.CipherMode.ECB" />, <see cref="F:System.Security.Cryptography.CipherMode.CBC" /> ni <see cref="F:System.Security.Cryptography.CipherMode.CFB" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RijndaelManaged.GenerateIV">
      <summary>Génère un vecteur d'initialisation aléatoire (<see cref="P:System.Security.Cryptography.SymmetricAlgorithm.IV" />) à utiliser pour l'algorithme.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RijndaelManaged.GenerateKey">
      <summary>Génère un <see cref="P:System.Security.Cryptography.SymmetricAlgorithm.Key" /> aléatoire à utiliser pour l'algorithme.</summary>
    </member>
    <member name="P:System.Security.Cryptography.RijndaelManaged.IV">
      <summary>Obtient ou définit le vecteur d'initialisation à utiliser pour l'algorithme symétrique.</summary>
      <returns>Vecteur d’initialisation à utiliser pour l’algorithme symétrique.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RijndaelManaged.Key">
      <summary>Obtient ou définit la clé secrète utilisée pour l'algorithme symétrique.</summary>
      <returns>Clé secrète utilisée pour l’algorithme symétrique.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RijndaelManaged.KeySize">
      <summary>Obtient ou définit la taille, en bits, de la clé secrète utilisée pour l'algorithme symétrique.</summary>
      <returns>Taille, en bits, de la clé secrète utilisée pour l’algorithme symétrique. La valeur par défaut est 256 bits.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RijndaelManaged.LegalKeySizes">
      <summary>Obtient les tailles de clé, en octets, prises en charge par l'algorithme symétrique.</summary>
      <returns>Tailles de clé, en bits, prises en charge par l’algorithme symétrique.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RijndaelManaged.Mode">
      <summary>Obtient ou définit le mode de fonctionnement pour l'algorithme symétrique.</summary>
      <returns>Mode de fonctionnement de l'algorithme symétrique. La valeur par défaut est <see cref="F:System.Security.Cryptography.CipherMode.CBC" />.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RijndaelManaged.Padding">
      <summary>Obtient ou définit le mode de remplissage utilisé dans l'algorithme symétrique.</summary>
      <returns>Mode de remplissage utilisé dans l'algorithme symétrique. La valeur par défaut est <see cref="F:System.Security.Cryptography.PaddingMode.PKCS7" />.</returns>
    </member>
    <member name="T:System.Security.Cryptography.RSA">
      <summary>Représente la classe de base dont toutes les implémentations de l'algorithme <see cref="T:System.Security.Cryptography.RSA" /> héritent.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSA.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.RSA" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSA.Create">
      <summary>Crée une instance de l'implémentation par défaut de l'algorithme <see cref="T:System.Security.Cryptography.RSA" />.</summary>
      <returns>Nouvelle instance de l'implémentation par défaut de <see cref="T:System.Security.Cryptography.RSA" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.Create(System.Int32)">
      <summary>Crée une clé RSA éphémère avec la taille de clé spécifiée.</summary>
      <param name="keySizeInBits">Taille de la clé, en bits.</param>
      <returns>Nouvelle clé RSA éphémère avec la taille de clé spécifiée.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="keySizeInBits" /> est différent de <see cref="P:System.Security.Cryptography.AsymmetricAlgorithm.KeySize" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.Create(System.Security.Cryptography.RSAParameters)">
      <summary>Crée une clé RSA éphémère avec les paramètres de clé RSA spécifiés.</summary>
      <param name="parameters">Paramètres pour l’algorithme <see cref="T:System.Security.Cryptography.RSA" />.</param>
      <returns>Nouvelle clé RSA éphémère.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.Create(System.String)">
      <summary>Crée une instance de l'implémentation spécifiée de <see cref="T:System.Security.Cryptography.RSA" />.</summary>
      <param name="algName">Nom de l'implémentation de <see cref="T:System.Security.Cryptography.RSA" /> à utiliser.</param>
      <returns>Nouvelle instance de l'implémentation spécifiée de <see cref="T:System.Security.Cryptography.RSA" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.Decrypt(System.Byte[],System.Security.Cryptography.RSAEncryptionPadding)">
      <summary>En cas de remplacement dans une classe dérivée, déchiffre les données d’entrée en utilisant le mode de remplissage spécifié.</summary>
      <param name="data">Données à déchiffrer.</param>
      <param name="padding">Mode de remplissage.</param>
      <returns>Données déchiffrées.</returns>
      <exception cref="T:System.NotImplementedException">Une classe dérivée doit remplacer cette méthode.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.DecryptValue(System.Byte[])">
      <summary>En cas de remplacement dans une classe dérivée, déchiffre les données d'entrée en utilisant la clé privée.</summary>
      <param name="rgb">Texte de chiffrement à déchiffrer.</param>
      <returns>Déchiffrement résultant du paramètre <paramref name="rgb" /> en texte brut.</returns>
      <exception cref="T:System.NotSupportedException">Cet appel de méthode n’est pas pris en charge. Cette exception est levée à partir du .NET Framework 4.6.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.Encrypt(System.Byte[],System.Security.Cryptography.RSAEncryptionPadding)">
      <summary>En cas de remplacement dans une classe dérivée, chiffre les données d’entrée en utilisant le mode de remplissage spécifié.</summary>
      <param name="data">Données à chiffrer.</param>
      <param name="padding">Mode de remplissage.</param>
      <returns>Données chiffrées.</returns>
      <exception cref="T:System.NotImplementedException">Une classe dérivée doit remplacer cette méthode.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.EncryptValue(System.Byte[])">
      <summary>En cas de remplacement dans une classe dérivée, chiffre les données d'entrée en utilisant la clé publique.</summary>
      <param name="rgb">Texte brut à chiffrer.</param>
      <returns>Chiffrement résultant du paramètre <paramref name="rgb" /> en texte chiffré.</returns>
      <exception cref="T:System.NotSupportedException">Cet appel de méthode n’est pas pris en charge. Cette exception est levée à partir du .NET Framework 4.6.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.ExportParameters(System.Boolean)">
      <summary>En cas de remplacement dans une classe dérivée, exporte les éléments <see cref="T:System.Security.Cryptography.RSAParameters" />.</summary>
      <param name="includePrivateParameters">
        <see langword="true" /> pour inclure les paramètres privés ; sinon <see langword="false" />.</param>
      <returns>Paramètres pour <see cref="T:System.Security.Cryptography.RSA" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.ExportRSAPrivateKey">
      <summary>Exporte la clé actuelle au format PKCS#1 RSAPrivateKey.</summary>
      <returns>Tableau d’octets contenant la représentation PKCS#1 RSAPrivateKey de cette clé.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La clé n’a pas pu être exportée.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.ExportRSAPublicKey">
      <summary>Exporte la partie clé publique de la clé actuelle au format PKCS#1 RSAPublicKey.</summary>
      <returns>Tableau d’octets contenant la représentation PKCS#1 RSAPublicKey de cette clé.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.FromXmlString(System.String)">
      <summary>Initialise un objet <see cref="T:System.Security.Cryptography.RSA" /> à partir des informations de clé d'une chaîne XML.</summary>
      <param name="xmlString">Chaîne XML qui contient les informations de clé de <see cref="T:System.Security.Cryptography.RSA" />.</param>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="xmlString" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le format du paramètre <paramref name="xmlString" /> n’est pas valide.</exception>
      <exception cref="T:System.PlatformNotSupportedException">.NET Core uniquement : ce membre n’est pas pris en charge.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.HashData(System.Byte[],System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName)">
      <summary>En cas de remplacement dans une classe dérivée, calcule la valeur de hachage de la partie spécifiée d’un tableau d’octets à l’aide d’un algorithme de hachage spécifié.</summary>
      <param name="data">Données à hacher.</param>
      <param name="offset">Index du premier octet dans les <paramref name="data" /> à hacher.</param>
      <param name="count">Nombre d’octets à hacher.</param>
      <param name="hashAlgorithm">Algorithme à utiliser pour hacher les données.</param>
      <returns>Données hachées.</returns>
      <exception cref="T:System.NotImplementedException">Une classe dérivée doit remplacer cette méthode.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.HashData(System.IO.Stream,System.Security.Cryptography.HashAlgorithmName)">
      <summary>En cas de remplacement dans une classe dérivée, calcule la valeur de hachage du flux binaire spécifié en utilisant un algorithme de hachage spécifié.</summary>
      <param name="data">Flux binaire à hacher.</param>
      <param name="hashAlgorithm">L'algorithme de hachage.</param>
      <returns>Données hachées.</returns>
      <exception cref="T:System.NotImplementedException">Une classe dérivée doit remplacer cette méthode.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importe la paire de clés publique/privée à partir d’une structure PKCS#8 EncryptedPrivateKeyInfo après le déchiffrement avec un mot de passe basé sur l’octet, en remplaçant les clés de cet objet.</summary>
      <param name="passwordBytes">Octets à utiliser comme mot de passe lors du déchiffrement du matériel de clé.</param>
      <param name="source">Octets d’une structure PKCS#8 EncryptedPrivateKeyInfo dans l’encodage ASN.1-BER.</param>
      <param name="bytesRead">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets lus à partir de <paramref name="source" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le mot de passe est incorrect.
ou
Le contenu de <paramref name="source" /> indique que la fonction de dérivation de clés (KDF) à appliquer est la fonction KDF PKCS#12 existante, qui nécessite des mots de passe basés sur <see cref="T:System.Char" />.
ou
Le contenu de <paramref name="source" /> ne représente pas une structure PKCS#8 EncryptedPrivateKeyInfo encodée en ASN.1-BER.

ou -

Le contenu de <paramref name="source" /> indique que la clé est destinée à un algorithme autre que l’algorithme représenté par cette instance.
ou
Le contenu de <paramref name="source" /> représente la clé dans un format qui n’est pas pris en charge.

ou -

L’importation de clé propre à l’algorithme a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importe la paire de clés publique/privée à partir d’une structure PKCS#8 EncryptedPrivateKeyInfo après le déchiffrement avec un mot de passe basé sur char, en remplaçant les clés de cet objet.</summary>
      <param name="password">Mot de passe à utiliser pour déchiffrer le matériel de clé.</param>
      <param name="source">Octets d’une structure PKCS#8 EncryptedPrivateKeyInfo dans l’encodage ASN.1-BER.</param>
      <param name="bytesRead">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets lus à partir de <paramref name="source" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le mot de passe est incorrect.

ou -

Le contenu de <paramref name="source" /> ne représente pas une structure PKCS#8 EncryptedPrivateKeyInfo encodée en ASN.1-BER.

ou -

Le contenu de <paramref name="source" /> indique que la clé est destinée à un algorithme autre que l’algorithme représenté par cette instance.

ou -

Le contenu de <paramref name="source" /> représente la clé dans un format qui n’est pas pris en charge.

ou -

L’importation de clé propre à l’algorithme a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.ImportParameters(System.Security.Cryptography.RSAParameters)">
      <summary>En cas de remplacement dans une classe dérivée, importe les éléments <see cref="T:System.Security.Cryptography.RSAParameters" /> spécifiés.</summary>
      <param name="parameters">Paramètres pour <see cref="T:System.Security.Cryptography.RSA" />.</param>
    </member>
    <member name="M:System.Security.Cryptography.RSA.ImportPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importe la paire de clés publique/privée à partir d’une structure PKCS#8 PrivateKeyInfo après le déchiffrement, en remplaçant les clés de cet objet.</summary>
      <param name="source">Octets d’une structure PKCS#8 PrivateKeyInfo dans l’encodage ASN.1-BER.</param>
      <param name="bytesRead">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets lus à partir de <paramref name="source" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le contenu de <paramref name="source" /> ne représente pas une structure PKCS#8 PrivateKeyInfo encodée en ASN.1-BER.

ou -

Le contenu de <paramref name="source" /> indique que la clé est destinée à un algorithme autre que l’algorithme représenté par cette instance.

ou -

Le contenu de <paramref name="source" /> représente la clé dans un format qui n’est pas pris en charge.

ou -

L’importation de clé propre à l’algorithme a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.ImportRSAPrivateKey(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importe la paire de clés publique/privée à partir d’une structure PKCS#1 RSAPrivateKey après le déchiffrement, en remplaçant les clés de cet objet.</summary>
      <param name="source">Octets d’une structure PKCS#1 RSAPrivateKey dans l’encodage ASN.1-BER.</param>
      <param name="bytesRead">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets lus à partir de <paramref name="source" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le contenu de <paramref name="source" /> ne représente pas une structure PKCS#1 RSAPrivateKey encodée en ASN.1-BER.

ou -

L’importation de clés a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.ImportRSAPublicKey(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importe la clé publique à partir d’une structure PKCS#1 RSAPublicKey après le déchiffrement, en remplaçant les clés de cet objet.</summary>
      <param name="source">Octets d’une structure PKCS#1 RSAPublicKey dans l’encodage ASN.1-BER.</param>
      <param name="bytesRead">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets lus à partir de <paramref name="source" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le contenu de <paramref name="source" /> ne représente pas une structure PKCS#1 RSAPublicKey encodée en ASN.1-BER.

ou -

L’importation de clés a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.ImportSubjectPublicKeyInfo(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importe la clé publique à partir d’une structure X.509 SubjectPublicKeyInfo après le déchiffrement, en remplaçant les clés de cet objet.</summary>
      <param name="source">Octets d’une structure X.509 SubjectPublicKeyInfo dans l’encodage ASN.1-DER.</param>
      <param name="bytesRead">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets lus à partir de <paramref name="source" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le contenu de <paramref name="source" /> ne représente pas une structure X.509 SubjectPublicKeyInfo encodée en ASN.1-DER.

ou -

Le contenu de <paramref name="source" /> indique que la clé est destinée à un algorithme autre que l’algorithme représenté par cette instance.

ou -

Le contenu de <paramref name="source" /> représente la clé dans un format qui n’est pas pris en charge.

ou -

L’importation de clé propre à l’algorithme a échoué.</exception>
    </member>
    <member name="P:System.Security.Cryptography.RSA.KeyExchangeAlgorithm">
      <summary>Obtient le nom de l’algorithme d’échange de clés disponible avec cette implémentation de <see cref="T:System.Security.Cryptography.RSA" />.</summary>
      <returns>Retourne « RSA ».</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSA.SignatureAlgorithm">
      <summary>Obtient le nom de l’algorithme de signature disponible avec cette implémentation de <see cref="T:System.Security.Cryptography.RSA" />.</summary>
      <returns>Retourne « RSA ».</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.SignData(System.Byte[],System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)">
      <summary>Calcule la valeur de hachage d’une partie du tableau d’octets indiqué à l’aide de l’algorithme de hachage et du mode de remplissage spécifiés, et signe la valeur de hachage obtenue.</summary>
      <param name="data">Données d'entrée pour lesquelles calculer le hachage.</param>
      <param name="offset">Décalage dans le tableau à partir duquel l’utilisation de données commence.</param>
      <param name="count">Nombre d'octets dans le tableau à utiliser comme données.</param>
      <param name="hashAlgorithm">Algorithme de hachage à utiliser pour créer la valeur de hachage.</param>
      <param name="padding">Mode de remplissage.</param>
      <returns>Signature RSA pour les données spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> est <see langword="null" />.  

ou - 
<paramref name="padding" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="offset" /> est inférieur à zéro.  

ou - 
<paramref name="count" /> est inférieur à zéro.  

ou 
 <paramref name="offset" /> + <paramref name="count" /> - 1 génère un index qui dépasse la limite supérieure de <paramref name="data" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.SignData(System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)">
      <summary>Calcule la valeur de hachage du tableau d’octets spécifié en utilisant l’algorithme de hachage et le mode de remplissage spécifiés, et signe la valeur de hachage obtenue.</summary>
      <param name="data">Données d'entrée pour lesquelles calculer le hachage.</param>
      <param name="hashAlgorithm">Algorithme de hachage à utiliser pour créer la valeur de hachage.</param>
      <param name="padding">Mode de remplissage.</param>
      <returns>Signature RSA pour les données spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> a la valeur <see langword="null" />.  

ou - 
<paramref name="padding" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.SignData(System.IO.Stream,System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)">
      <summary>Calcule la valeur de hachage du flux spécifié en utilisant l’algorithme de hachage et le mode de remplissage spécifiés, et signe la valeur de hachage obtenue.</summary>
      <param name="data">Flux d'entrée pour lequel calculer le hachage.</param>
      <param name="hashAlgorithm">Algorithme de hachage à utiliser pour créer la valeur de hachage.</param>
      <param name="padding">Mode de remplissage.</param>
      <returns>Signature RSA pour les données spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> a la valeur <see langword="null" />.  

ou - 
<paramref name="padding" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.SignHash(System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)">
      <summary>En cas de substitution dans une classe dérivée, calcule la signature pour la valeur de hachage spécifiée en la chiffrant avec la clé privée à l’aide du remplissage spécifié.</summary>
      <param name="hash">Valeur de hachage des données à signer.</param>
      <param name="hashAlgorithm">Algorithme de hachage utilisé pour créer la valeur de hachage des données.</param>
      <param name="padding">Remplissage.</param>
      <returns>Signature RSA pour la valeur de hachage spécifiée.</returns>
      <exception cref="T:System.NotImplementedException">Une classe dérivée doit remplacer cette méthode.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.ToXmlString(System.Boolean)">
      <summary>Crée et retourne une chaîne XML contenant la clé de l'objet <see cref="T:System.Security.Cryptography.RSA" /> actif.</summary>
      <param name="includePrivateParameters">
        <see langword="true" /> pour inclure une clé RSA publique et privée; <see langword="false" /> pour inclure uniquement la clé publique.</param>
      <returns>Chaîne XML contenant la clé de l'objet <see cref="T:System.Security.Cryptography.RSA" /> actif.</returns>
      <exception cref="T:System.PlatformNotSupportedException">.NET Core uniquement : ce membre n’est pas pris en charge.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.TryDecrypt(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.RSAEncryptionPadding,System.Int32@)">
      <param name="data" />
      <param name="destination" />
      <param name="padding" />
      <param name="bytesWritten" />
    </member>
    <member name="M:System.Security.Cryptography.RSA.TryEncrypt(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.RSAEncryptionPadding,System.Int32@)">
      <param name="data" />
      <param name="destination" />
      <param name="padding" />
      <param name="bytesWritten" />
    </member>
    <member name="M:System.Security.Cryptography.RSA.TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.Security.Cryptography.PbeParameters,System.Span{System.Byte},System.Int32@)">
      <summary>Tente d’exporter la clé actuelle au format PKCS#8 EncryptedPrivateKeyInfo dans une mémoire tampon fournie, à l’aide d’un mot de passe basé sur l’octet.</summary>
      <param name="passwordBytes">Octets à utiliser comme mot de passe lors du chiffrement du matériel de clé.</param>
      <param name="pbeParameters">Paramètres de chiffrement par mot de passe à utiliser lors du chiffrement du matériel de clé.</param>
      <param name="destination">Intervalle d’octets pour recevoir les données PKCS#8 EncryptedPrivateKeyInfo.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir la sortie ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La clé n’a pas pu être exportée.

ou -

<paramref name="pbeParameters" /> indique que <see cref="F:System.Security.Cryptography.PbeEncryptionAlgorithm.TripleDes3KeyPkcs12" /> doit être utilisé, ce qui nécessite des mots de passe basés sur <see cref="T:System.Char" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Char},System.Security.Cryptography.PbeParameters,System.Span{System.Byte},System.Int32@)">
      <summary>Tente d’exporter la clé actuelle au format PKCS#8 EncryptedPrivateKeyInfo dans une mémoire tampon fournie, à l’aide d’un mot de passe basé sur char.</summary>
      <param name="password">Mot de passe à utiliser lors du chiffrement du matériel de clé.</param>
      <param name="pbeParameters">Paramètres de chiffrement par mot de passe à utiliser lors du chiffrement du matériel de clé.</param>
      <param name="destination">Intervalle d’octets pour recevoir les données PKCS#8 EncryptedPrivateKeyInfo.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir la sortie ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La clé n’a pas pu être exportée.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.TryExportPkcs8PrivateKey(System.Span{System.Byte},System.Int32@)">
      <summary>Tente d’exporter la clé actuelle au format PKCS#8 PrivateKeyInfo dans une mémoire tampon fournie.</summary>
      <param name="destination">Intervalle d’octets pour recevoir les données PKCS#8 PrivateKeyInfo.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir la sortie ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La clé n’a pas pu être exportée.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.TryExportRSAPrivateKey(System.Span{System.Byte},System.Int32@)">
      <summary>Tente d’exporter la clé actuelle au format PKCS#1 RSAPrivateKey dans une mémoire tampon fournie.</summary>
      <param name="destination">Intervalle d’octets pour recevoir les données PKCS#1 RSAPrivateKey.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir la sortie ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La clé n’a pas pu être exportée.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.TryExportRSAPublicKey(System.Span{System.Byte},System.Int32@)">
      <summary>Tente d’exporter la clé actuelle au format PKCS#1 RSAPublicKey dans une mémoire tampon fournie.</summary>
      <param name="destination">Intervalle d’octets pour recevoir les données PKCS#1 RSAPublicKey.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir la sortie ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La clé n’a pas pu être exportée.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.TryExportSubjectPublicKeyInfo(System.Span{System.Byte},System.Int32@)">
      <summary>Tente d’exporter la clé actuelle au format X.509 SubjectPublicKeyInfo dans une mémoire tampon fournie.</summary>
      <param name="destination">Intervalle d’octets pour recevoir les données X.509 SubjectPublicKeyInfo.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir la sortie ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La clé n’a pas pu être exportée.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.TryHashData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Int32@)">
      <param name="data" />
      <param name="destination" />
      <param name="hashAlgorithm" />
      <param name="bytesWritten" />
    </member>
    <member name="M:System.Security.Cryptography.RSA.TrySignData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding,System.Int32@)">
      <param name="data" />
      <param name="destination" />
      <param name="hashAlgorithm" />
      <param name="padding" />
      <param name="bytesWritten" />
    </member>
    <member name="M:System.Security.Cryptography.RSA.TrySignHash(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding,System.Int32@)">
      <param name="hash" />
      <param name="destination" />
      <param name="hashAlgorithm" />
      <param name="padding" />
      <param name="bytesWritten" />
    </member>
    <member name="M:System.Security.Cryptography.RSA.VerifyData(System.Byte[],System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)">
      <summary>Vérifie qu’une signature numérique est valide en calculant la valeur de hachage des données indiquées à l’aide de l’algorithme de hachage et du remplissage spécifiés, et en la comparant à la signature fournie.</summary>
      <param name="data">Données signées.</param>
      <param name="signature">Données de la signature à vérifier.</param>
      <param name="hashAlgorithm">Algorithme de hachage utilisé pour créer la valeur de hachage des données.</param>
      <param name="padding">Mode de remplissage.</param>
      <returns>
        <see langword="true" /> si la signature est valide ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> a la valeur <see langword="null" />.  

ou - 
<paramref name="signature" /> est <see langword="null" />.  

ou - 
<paramref name="padding" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.VerifyData(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)">
      <summary>Vérifie qu’une signature numérique est valide en calculant la valeur de hachage des données dans une partie d’un tableau d’octets à l’aide de l’algorithme de hachage et du remplissage spécifiés, et en la comparant à la signature fournie.</summary>
      <param name="data">Données signées.</param>
      <param name="offset">Index de départ à partir duquel calculer le hachage.</param>
      <param name="count">Nombre d’octets à hacher.</param>
      <param name="signature">Données de la signature à vérifier.</param>
      <param name="hashAlgorithm">Algorithme de hachage utilisé pour créer la valeur de hachage des données.</param>
      <param name="padding">Mode de remplissage.</param>
      <returns>
        <see langword="true" /> si la signature est valide ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> est <see langword="null" />.  

ou - 
<paramref name="signature" /> a la valeur <see langword="null" />.  

ou - 
<paramref name="padding" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="offset" /> est inférieur à zéro.  

ou - 
<paramref name="count" /> est inférieur à zéro.  

ou - 
<paramref name="offset" /> + <paramref name="count" /> - 1 génère un index qui dépasse la limite supérieure de <paramref name="data" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.VerifyData(System.IO.Stream,System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)">
      <summary>Vérifie qu’une signature numérique est valide en calculant la valeur de hachage du flux spécifié en utilisant l’algorithme de hachage et le remplissage spécifiés, et en la comparant à la signature fournie.</summary>
      <param name="data">Données signées.</param>
      <param name="signature">Données de la signature à vérifier.</param>
      <param name="hashAlgorithm">Algorithme de hachage utilisé pour créer la valeur de hachage des données.</param>
      <param name="padding">Mode de remplissage.</param>
      <returns>
        <see langword="true" /> si la signature est valide ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> est <see langword="null" />.  

ou - 
<paramref name="signature" /> a la valeur <see langword="null" />.  

ou - 
<paramref name="padding" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.VerifyData(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)">
      <param name="data" />
      <param name="signature" />
      <param name="hashAlgorithm" />
      <param name="padding" />
    </member>
    <member name="M:System.Security.Cryptography.RSA.VerifyHash(System.Byte[],System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)">
      <summary>Vérifie qu’une signature numérique est valide en déterminant la valeur de hachage dans la signature en utilisant l’algorithme de hachage et le remplissage spécifiés, et en la comparant à la valeur de hachage fournie.</summary>
      <param name="hash">Valeur de hachage des données signées.</param>
      <param name="signature">Données de la signature à vérifier.</param>
      <param name="hashAlgorithm">Algorithme de hachage utilisé pour créer la valeur de hachage.</param>
      <param name="padding">Mode de remplissage.</param>
      <returns>
        <see langword="true" /> si la signature est valide ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.NotImplementedException">Une classe dérivée doit remplacer cette méthode.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.VerifyHash(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)">
      <param name="hash" />
      <param name="signature" />
      <param name="hashAlgorithm" />
      <param name="padding" />
    </member>
    <member name="T:System.Security.Cryptography.RSAEncryptionPadding">
      <summary>Spécifie le mode de remplissage et les paramètres à utiliser avec les opérations de chiffrement ou de déchiffrement RSA.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAEncryptionPadding.CreateOaep(System.Security.Cryptography.HashAlgorithmName)">
      <summary>Crée une instance de <see cref="T:System.Security.Cryptography.RSAEncryptionPadding" /> dont le <see cref="P:System.Security.Cryptography.RSAEncryptionPadding.Mode" /> est <see cref="F:System.Security.Cryptography.RSAEncryptionPaddingMode.Oaep" /> avec l’algorithme de hachage donné.</summary>
      <param name="hashAlgorithm">L'algorithme de hachage.</param>
      <returns>Un objet dont le mode est <see cref="P:System.Security.Cryptography.RSAEncryptionPadding.Mode" /> est <see cref="F:System.Security.Cryptography.RSAEncryptionPaddingMode.Oaep" /> avec l’algorithme de hachage spécifié par <paramref name="hashAlgorithm" />.</returns>
      <exception cref="T:System.ArgumentException">La propriété <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> de <paramref name="hashAlgorithm" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSAEncryptionPadding.Equals(System.Object)">
      <summary>Détermine si l’instance actuelle est égale à l’objet spécifié.</summary>
      <param name="obj">Objet à comparer.</param>
      <returns>
        <see langword="true" /> si <paramref name="obj" /> est égal à l'instance actuelle ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSAEncryptionPadding.Equals(System.Security.Cryptography.RSAEncryptionPadding)">
      <summary>Détermine si l’instance actuelle est égale à l’objet <see cref="T:System.Security.Cryptography.RSAEncryptionPadding" /> spécifié.</summary>
      <param name="other">Objet à comparer.</param>
      <returns>
        <see langword="true" /> si <paramref name="other" /> est égal à l'instance actuelle ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSAEncryptionPadding.GetHashCode">
      <summary>Retourne le code de hachage de cet objet <see cref="T:System.Security.Cryptography.RSAEncryptionPadding" />.</summary>
      <returns>Code de hachage de cette instance.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSAEncryptionPadding.Mode">
      <summary>Obtient le mode de remplissage représenté par cette instance <see cref="T:System.Security.Cryptography.RSAEncryptionPadding" />.</summary>
      <returns>Mode de remplissage.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSAEncryptionPadding.OaepHashAlgorithm">
      <summary>Obtient l’algorithme de hachage utilisé conjointement avec le mode de remplissage <see cref="F:System.Security.Cryptography.RSAEncryptionPaddingMode.Oaep" />.</summary>
      <returns>L'algorithme de hachage.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSAEncryptionPadding.OaepSHA1">
      <summary>Obtient un objet qui représente la norme de chiffrement OAEP (Optimal Asymmetric Encryption Padding) avec un algorithme de hachage SHA1.</summary>
      <returns>Objet qui représente la norme de chiffrement OAEP avec un algorithme de hachage SHA1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSAEncryptionPadding.OaepSHA256">
      <summary>Obtient un objet qui représente la norme de chiffrement OAEP (Optimal Asymmetric Encryption Padding) avec un algorithme de hachage SHA256.</summary>
      <returns>Objet qui représente la norme de chiffrement OAEP avec un algorithme de hachage SHA256.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSAEncryptionPadding.OaepSHA384">
      <summary>Obtient un objet qui représente la norme de chiffrement OAEP (Optimal Asymmetric Encryption Padding) avec un algorithme de hachage SHA-384.</summary>
      <returns>Objet qui représente la norme de chiffrement OAEP avec un algorithme de hachage SHA384.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSAEncryptionPadding.OaepSHA512">
      <summary>Obtient un objet qui représente la norme de chiffrement OAEP (Optimal Asymmetric Encryption Padding) avec un algorithme de hachage SHA512.</summary>
      <returns>Objet qui représente la norme de chiffrement OAEP avec un algorithme de hachage SHA512.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSAEncryptionPadding.op_Equality(System.Security.Cryptography.RSAEncryptionPadding,System.Security.Cryptography.RSAEncryptionPadding)">
      <summary>Indique si deux objets <see cref="T:System.Security.Cryptography.RSAEncryptionPadding" /> spécifiés sont égaux.</summary>
      <param name="left">Premier objet à comparer.</param>
      <param name="right">Deuxième objet à comparer.</param>
      <returns>
        <see langword="true" /> si <see langword="left" /> et <see langword="right" /> sont égales ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSAEncryptionPadding.op_Inequality(System.Security.Cryptography.RSAEncryptionPadding,System.Security.Cryptography.RSAEncryptionPadding)">
      <summary>Indique si deux objets <see cref="T:System.Security.Cryptography.RSAEncryptionPadding" /> spécifiés sont inégaux.</summary>
      <param name="left">Premier objet à comparer.</param>
      <param name="right">Deuxième objet à comparer.</param>
      <returns>
        <see langword="true" /> si <see langword="left" /> et <see langword="right" /> ne sont pas égales ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSAEncryptionPadding.Pkcs1">
      <summary>Obtient un objet qui représente la norme de chiffrement PKCS #1.</summary>
      <returns>Objet qui représente la norme de chiffrement PKCS #1.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSAEncryptionPadding.ToString">
      <summary>Retourne la représentation sous forme de chaîne de l'instance <see cref="T:System.Security.Cryptography.RSAEncryptionPadding" /> actuelle.</summary>
      <returns>Représentation sous forme de chaîne de l’objet actuel.</returns>
    </member>
    <member name="T:System.Security.Cryptography.RSAEncryptionPaddingMode">
      <summary>Spécifie le mode de remplissage à utiliser avec les opérations de chiffrement ou de déchiffrement RSA.</summary>
    </member>
    <member name="F:System.Security.Cryptography.RSAEncryptionPaddingMode.Oaep">
      <summary>OAEP (Optimal Asymmetric Encryption Padding). Il est recommandé pour les nouvelles applications.</summary>
    </member>
    <member name="F:System.Security.Cryptography.RSAEncryptionPaddingMode.Pkcs1">
      <summary>PKCS #1 v1.5. Il est pris en charge pour la compatibilité avec des applications existantes.</summary>
    </member>
    <member name="T:System.Security.Cryptography.RSAOAEPKeyExchangeDeformatter">
      <summary>Déchiffre les données d'échange de clés OAEP (Optimal Asymmetric Encryption Padding).</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAOAEPKeyExchangeDeformatter.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.RSAOAEPKeyExchangeDeformatter" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAOAEPKeyExchangeDeformatter.#ctor(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.RSAOAEPKeyExchangeDeformatter" /> avec la clé spécifiée.</summary>
      <param name="key">Instance de l'algorithme de <see cref="T:System.Security.Cryptography.RSA" /> qui contient la clé privée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSAOAEPKeyExchangeDeformatter.DecryptKeyExchange(System.Byte[])">
      <summary>Extrait les informations confidentielles à partir des données d'échange de clés chiffrées.</summary>
      <param name="rgbData">Données d’échange de clés dans lesquelles les informations confidentielles sont cachées.</param>
      <returns>Informations confidentielles dérivées des données d’échange de clés.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La vérification des données d'échange de clés a échoué.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicUnexpectedOperationException">La clé est manquante.</exception>
    </member>
    <member name="P:System.Security.Cryptography.RSAOAEPKeyExchangeDeformatter.Parameters">
      <summary>Obtient les paramètres pour l'échange de clés OAEP (Optimal Asymmetric Encryption Padding).</summary>
      <returns>Chaîne XML comportant les paramètres de l'opération d'échange de clés OAEP.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSAOAEPKeyExchangeDeformatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Définit la clé privée à utiliser pour déchiffrer les informations confidentielles.</summary>
      <param name="key">Instance de l'algorithme de <see cref="T:System.Security.Cryptography.RSA" /> qui contient la clé privée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> est <see langword="null" />.</exception>
    </member>
    <member name="T:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter">
      <summary>Crée les données d'échange de clés OAEP (Optimal Asymmetric Encryption Padding) à l'aide de <see cref="T:System.Security.Cryptography.RSA" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter.#ctor(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter" /> avec la clé spécifiée.</summary>
      <param name="key">Instance de l'algorithme de <see cref="T:System.Security.Cryptography.RSA" />  qui contient la clé publique.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> est <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter.CreateKeyExchange(System.Byte[])">
      <summary>Crée les données d’échange de clés chiffrées à partir des données d’entrée spécifiées.</summary>
      <param name="rgbData">Informations confidentielles à passer dans l’échange de clés.</param>
      <returns>Données d’échange de clés chiffrées à envoyer au destinataire prévu.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicUnexpectedOperationException">La clé est manquante.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter.CreateKeyExchange(System.Byte[],System.Type)">
      <summary>Crée les données d’échange de clés chiffrées à partir des données d’entrée spécifiées.</summary>
      <param name="rgbData">Informations confidentielles à passer dans l’échange de clés.</param>
      <param name="symAlgType">Ce paramètre n’est pas utilisé dans la version actuelle.</param>
      <returns>Données d’échange de clés chiffrées à envoyer au destinataire prévu.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter.Parameter">
      <summary>Obtient ou définit le paramètre utilisé pour créer le remplissage dans le processus de création d'échange de clés.</summary>
      <returns>La valeur de paramètre.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter.Parameters">
      <summary>Obtient les paramètres pour l'échange de clés OAEP (Optimal Asymmetric Encryption Padding).</summary>
      <returns>Chaîne XML comportant les paramètres de l'opération d'échange de clés OAEP.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter.Rng">
      <summary>Obtient ou définit l'algorithme du générateur de nombres aléatoires à utiliser dans la création d'échange de clés.</summary>
      <returns>Instance d'un algorithme du générateur de nombres aléatoires à utiliser.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Définit la clé publique à utiliser pour chiffrer les données d'échange de clés.</summary>
      <param name="key">Instance de l'algorithme de <see cref="T:System.Security.Cryptography.RSA" />  qui contient la clé publique.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="T:System.Security.Cryptography.RSAParameters">
      <summary>Représente les paramètres standard pour l'algorithme <see cref="T:System.Security.Cryptography.RSA" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.RSAParameters.D">
      <summary>Représente le paramètre <see langword="D" /> pour l'algorithme <see cref="T:System.Security.Cryptography.RSA" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.RSAParameters.DP">
      <summary>Représente le paramètre <see langword="DP" /> pour l'algorithme <see cref="T:System.Security.Cryptography.RSA" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.RSAParameters.DQ">
      <summary>Représente le paramètre <see langword="DQ" /> pour l'algorithme <see cref="T:System.Security.Cryptography.RSA" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.RSAParameters.Exponent">
      <summary>Représente le paramètre <see langword="Exponent" /> pour l'algorithme <see cref="T:System.Security.Cryptography.RSA" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.RSAParameters.InverseQ">
      <summary>Représente le paramètre <see langword="InverseQ" /> pour l'algorithme <see cref="T:System.Security.Cryptography.RSA" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.RSAParameters.Modulus">
      <summary>Représente le paramètre <see langword="Modulus" /> pour l'algorithme <see cref="T:System.Security.Cryptography.RSA" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.RSAParameters.P">
      <summary>Représente le paramètre <see langword="P" /> pour l'algorithme <see cref="T:System.Security.Cryptography.RSA" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.RSAParameters.Q">
      <summary>Représente le paramètre <see langword="Q" /> pour l'algorithme <see cref="T:System.Security.Cryptography.RSA" />.</summary>
    </member>
    <member name="T:System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter">
      <summary>Déchiffre les données d’échange de clés PKCS #1.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter.#ctor(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter" /> avec la clé spécifiée.</summary>
      <param name="key">Instance de l'algorithme de <see cref="T:System.Security.Cryptography.RSA" /> qui contient la clé privée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter.DecryptKeyExchange(System.Byte[])">
      <summary>Extrait les informations confidentielles à partir des données d'échange de clés chiffrées.</summary>
      <param name="rgbIn">Données d’échange de clés dans lesquelles les informations confidentielles sont cachées.</param>
      <returns>Informations confidentielles dérivées des données d’échange de clés.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicUnexpectedOperationException">La clé est manquante.</exception>
    </member>
    <member name="P:System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter.Parameters">
      <summary>Obtient les paramètres pour l'échange de clés PKCS #1.</summary>
      <returns>Chaîne XML comportant les paramètres de l'opération d'échange de clés PKCS #1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter.RNG">
      <summary>Obtient ou définit l'algorithme du générateur de nombres aléatoires à utiliser dans la création d'échange de clés.</summary>
      <returns>Instance d'un algorithme du générateur de nombres aléatoires à utiliser.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Définit la clé privée à utiliser pour déchiffrer les informations confidentielles.</summary>
      <param name="key">Instance de l'algorithme de <see cref="T:System.Security.Cryptography.RSA" /> qui contient la clé privée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="T:System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter">
      <summary>Crée les données d'échange de clés PKCS #1 à l'aide de <see cref="T:System.Security.Cryptography.RSA" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter.#ctor(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter" /> avec la clé spécifiée.</summary>
      <param name="key">Instance de l'algorithme de <see cref="T:System.Security.Cryptography.RSA" />  qui contient la clé publique.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter.CreateKeyExchange(System.Byte[])">
      <summary>Crée les données d’échange de clés chiffrées à partir des données d’entrée spécifiées.</summary>
      <param name="rgbData">Informations confidentielles à passer dans l’échange de clés.</param>
      <returns>Données d’échange de clés chiffrées à envoyer au destinataire prévu.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="rgbData" /> est trop volumineux.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicUnexpectedOperationException">La clé est <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter.CreateKeyExchange(System.Byte[],System.Type)">
      <summary>Crée les données d’échange de clés chiffrées à partir des données d’entrée spécifiées.</summary>
      <param name="rgbData">Informations confidentielles à passer dans l’échange de clés.</param>
      <param name="symAlgType">Ce paramètre n’est pas utilisé dans la version actuelle.</param>
      <returns>Données d’échange de clés chiffrées à envoyer au destinataire prévu.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter.Parameters">
      <summary>Obtient les paramètres pour l'échange de clés PKCS #1.</summary>
      <returns>Chaîne XML comportant les paramètres de l'opération d'échange de clés PKCS #1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter.Rng">
      <summary>Obtient ou définit l'algorithme du générateur de nombres aléatoires à utiliser dans la création d'échange de clés.</summary>
      <returns>Instance d'un algorithme du générateur de nombres aléatoires à utiliser.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Définit la clé publique à utiliser pour chiffrer les données d'échange de clés.</summary>
      <param name="key">Instance de l'algorithme de <see cref="T:System.Security.Cryptography.RSA" />  qui contient la clé publique.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="T:System.Security.Cryptography.RSAPKCS1SignatureDeformatter">
      <summary>Vérifie une signature PKCS #1 version 1.5 <see cref="T:System.Security.Cryptography.RSA" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1SignatureDeformatter.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.RSAPKCS1SignatureDeformatter" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1SignatureDeformatter.#ctor(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.RSAPKCS1SignatureDeformatter" /> avec la clé spécifiée.</summary>
      <param name="key">Instance de <see cref="T:System.Security.Cryptography.RSA" /> qui contient la clé publique.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1SignatureDeformatter.SetHashAlgorithm(System.String)">
      <summary>Définit l'algorithme de hachage à utiliser pour vérifier la signature.</summary>
      <param name="strName">Nom de l'algorithme de hachage à utiliser pour vérifier la signature.</param>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1SignatureDeformatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Définit la clé publique à utiliser pour vérifier la signature.</summary>
      <param name="key">Instance de <see cref="T:System.Security.Cryptography.RSA" /> qui contient la clé publique.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1SignatureDeformatter.VerifySignature(System.Byte[],System.Byte[])">
      <summary>Vérifie la signature PKCS#1 <see cref="T:System.Security.Cryptography.RSA" /> pour les données spécifiées.</summary>
      <param name="rgbHash">Données de signature <paramref name="rgbSignature" />.</param>
      <param name="rgbSignature">Signature qui doit être vérifiée pour <paramref name="rgbHash" />.</param>
      <returns>
        <see langword="true" /> si <paramref name="rgbSignature" /> correspond à la signature calculée à l'aide de l'algorithme de hachage et de la clé spécifiés sur <paramref name="rgbHash" /> ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicUnexpectedOperationException">La clé est <see langword="null" />.  

ou - 
L'algorithme de hachage est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="rgbHash" /> a la valeur <see langword="null" />.  

ou - 
Le paramètre <paramref name="rgbSignature" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="T:System.Security.Cryptography.RSAPKCS1SignatureFormatter">
      <summary>Crée une signature PKCS #1 version 1.5 <see cref="T:System.Security.Cryptography.RSA" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1SignatureFormatter.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.RSAPKCS1SignatureFormatter" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1SignatureFormatter.#ctor(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.RSAPKCS1SignatureFormatter" /> avec la clé spécifiée.</summary>
      <param name="key">Instance de l'algorithme de <see cref="T:System.Security.Cryptography.RSA" /> qui contient la clé privée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> est <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1SignatureFormatter.CreateSignature(System.Byte[])">
      <summary>Crée la signature PKCS #1 <see cref="T:System.Security.Cryptography.RSA" /> pour les données spécifiées.</summary>
      <param name="rgbHash">Données à signer.</param>
      <returns>Signature numérique pour <paramref name="rgbHash" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicUnexpectedOperationException">La clé est <see langword="null" />.  
ou 
L'algorithme de hachage est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="rgbHash" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1SignatureFormatter.SetHashAlgorithm(System.String)">
      <summary>Définit l'algorithme de hachage à utiliser pour créer la signature.</summary>
      <param name="strName">Nom de l'algorithme de hachage à utiliser pour créer la signature.</param>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1SignatureFormatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Définit la clé privée à utiliser pour créer la signature.</summary>
      <param name="key">Instance de l'algorithme de <see cref="T:System.Security.Cryptography.RSA" /> qui contient la clé privée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="T:System.Security.Cryptography.RSASignaturePadding">
      <summary>Spécifie le mode de remplissage et les paramètres à utiliser avec les opérations de création ou de vérification de signature RSA.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSASignaturePadding.Equals(System.Object)">
      <summary>Retourne une valeur qui indique si cette instance est égale à un objet spécifié.</summary>
      <param name="obj">Objet à comparer à l'instance actuelle.</param>
      <returns>
        <see langword="true" /> si l’objet spécifié est égal à l’objet actuel ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSASignaturePadding.Equals(System.Security.Cryptography.RSASignaturePadding)">
      <summary>Retourne une valeur indiquant si cette instance équivaut à un objet <see cref="T:System.Security.Cryptography.RSASignaturePadding" /> spécifié.</summary>
      <param name="other">Objet à comparer à l'instance actuelle.</param>
      <returns>
        <see langword="true" /> si l’objet spécifié est égal à l’objet actuel ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSASignaturePadding.GetHashCode">
      <summary>Retourne le code de hachage de cette instance <see cref="T:System.Security.Cryptography.RSASignaturePadding" />.</summary>
      <returns>Code de hachage pour cette instance de <see cref="T:System.Security.Cryptography.RSASignaturePadding" />.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSASignaturePadding.Mode">
      <summary>Obtient le mode de remplissage de cette instance de <see cref="T:System.Security.Cryptography.RSASignaturePadding" />.</summary>
      <returns>Mode de remplissage (<see cref="F:System.Security.Cryptography.RSASignaturePaddingMode.Pkcs1" /> ou <see cref="F:System.Security.Cryptography.RSASignaturePaddingMode.Pss" />) de cette instance.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSASignaturePadding.op_Equality(System.Security.Cryptography.RSASignaturePadding,System.Security.Cryptography.RSASignaturePadding)">
      <summary>Indique si deux objets <see cref="T:System.Security.Cryptography.RSASignaturePadding" /> spécifiés sont égaux.</summary>
      <param name="left">Premier objet à comparer.</param>
      <param name="right">Deuxième objet à comparer.</param>
      <returns>
        <see langword="true" /> si <see langword="left" /> et <see langword="right" /> sont égales ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSASignaturePadding.op_Inequality(System.Security.Cryptography.RSASignaturePadding,System.Security.Cryptography.RSASignaturePadding)">
      <summary>Indique si deux objets <see cref="T:System.Security.Cryptography.RSASignaturePadding" /> spécifiés sont inégaux.</summary>
      <param name="left">Premier objet à comparer.</param>
      <param name="right">Deuxième objet à comparer.</param>
      <returns>
        <see langword="true" /> si <see langword="left" /> et <see langword="right" /> sont inégaux ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSASignaturePadding.Pkcs1">
      <summary>Obtient un objet qui utilise le mode de remplissage PKCS #1 v1.5.</summary>
      <returns>Objet qui utilise le mode de remplissage <see cref="F:System.Security.Cryptography.RSASignaturePaddingMode.Pkcs1" />.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSASignaturePadding.Pss">
      <summary>Obtient un objet qui utilise le mode de remplissage PSS.</summary>
      <returns>Objet qui utilise le mode de remplissage <see cref="F:System.Security.Cryptography.RSASignaturePaddingMode.Pss" /> avec le nombre d’octets de salt égal à la taille du hachage.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSASignaturePadding.ToString">
      <summary>Retourne la représentation sous forme de chaîne de l'instance <see cref="T:System.Security.Cryptography.RSASignaturePadding" /> actuelle.</summary>
      <returns>Représentation sous forme de chaîne de l’objet actuel.</returns>
    </member>
    <member name="T:System.Security.Cryptography.RSASignaturePaddingMode">
      <summary>Spécifie le mode de remplissage à utiliser avec les opérations de création ou de vérification de signature RSA.</summary>
    </member>
    <member name="F:System.Security.Cryptography.RSASignaturePaddingMode.Pkcs1">
      <summary>PKCS #1 v1.5</summary>
    </member>
    <member name="F:System.Security.Cryptography.RSASignaturePaddingMode.Pss">
      <summary>Schéma de signature probabiliste</summary>
    </member>
    <member name="T:System.Security.Cryptography.SHA1">
      <summary>Calcule le hachage <see cref="T:System.Security.Cryptography.SHA1" /> pour les données d'entrée.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA1.#ctor">
      <summary>Initialise une nouvelle instance de <see cref="T:System.Security.Cryptography.SHA1" />.</summary>
      <exception cref="T:System.InvalidOperationException">La stratégie de cet objet n'est pas compatible avec l'algorithme FIPS.</exception>
    </member>
    <member name="M:System.Security.Cryptography.SHA1.Create">
      <summary>Crée une instance de l'implémentation par défaut de <see cref="T:System.Security.Cryptography.SHA1" />.</summary>
      <returns>Nouvelle instance de <see cref="T:System.Security.Cryptography.SHA1" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SHA1.Create(System.String)">
      <summary>Crée une instance de l'implémentation spécifiée de <see cref="T:System.Security.Cryptography.SHA1" />.</summary>
      <param name="hashName">Nom de l'implémentation spécifique de <see cref="T:System.Security.Cryptography.SHA1" /> à utiliser.</param>
      <returns>Nouvelle instance de <see cref="T:System.Security.Cryptography.SHA1" /> à l'aide de l'implémentation spécifiée.</returns>
    </member>
    <member name="T:System.Security.Cryptography.SHA1Managed">
      <summary>Calcule le hachage <see cref="T:System.Security.Cryptography.SHA1" /> pour les données d'entrée à l'aide de la bibliothèque managée.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA1Managed.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.SHA1Managed" />.</summary>
      <exception cref="T:System.InvalidOperationException">Cette classe n'est pas compatible avec l'algorithme FIPS.</exception>
    </member>
    <member name="M:System.Security.Cryptography.SHA1Managed.Dispose(System.Boolean)">
      <summary>Libère les ressources non managées utilisées par l’objet <see cref="T:System.Security.Cryptography.SHA1Managed" /> et libère éventuellement les ressources managées.</summary>
      <param name="disposing">
        <see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour libérer uniquement les ressources non managées.</param>
    </member>
    <member name="M:System.Security.Cryptography.SHA1Managed.HashCore(System.Byte[],System.Int32,System.Int32)">
      <summary>Achemine les données écrites dans l'objet vers l'algorithme de hachage <see cref="T:System.Security.Cryptography.SHA1Managed" /> pour le calcul du hachage.</summary>
      <param name="array">Données d'entrée.</param>
      <param name="ibStart">Offset dans le tableau d'octets à partir duquel l'utilisation de données commence.</param>
      <param name="cbSize">Nombre d'octets dans le tableau à utiliser comme données.</param>
    </member>
    <member name="M:System.Security.Cryptography.SHA1Managed.HashCore(System.ReadOnlySpan{System.Byte})">
      <param name="source" />
    </member>
    <member name="M:System.Security.Cryptography.SHA1Managed.HashFinal">
      <summary>Retourne la valeur de hachage <see cref="T:System.Security.Cryptography.SHA1" /> calculée une fois toutes les données écrites dans l'objet.</summary>
      <returns>Code de hachage calculé.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SHA1Managed.Initialize">
      <summary>Initialise une instance de <see cref="T:System.Security.Cryptography.SHA1Managed" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA1Managed.TryHashFinal(System.Span{System.Byte},System.Int32@)">
      <param name="destination" />
      <param name="bytesWritten" />
    </member>
    <member name="T:System.Security.Cryptography.SHA256">
      <summary>Calcule le hachage <see cref="T:System.Security.Cryptography.SHA256" /> pour les données d'entrée.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA256.#ctor">
      <summary>Initialise une nouvelle instance de <see cref="T:System.Security.Cryptography.SHA256" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA256.Create">
      <summary>Crée une instance de l'implémentation par défaut de <see cref="T:System.Security.Cryptography.SHA256" />.</summary>
      <returns>Nouvelle instance de <see cref="T:System.Security.Cryptography.SHA256" />. Sur le .NET Framework, cette méthode crée une instance de la classe <see cref="T:System.Security.Cryptography.SHA256Managed" /> si le mode FIPS n’est pas actif ; si le mode FIPS est actif, elle crée une instance de la classe <see cref="T:System.Security.Cryptography.SHA256Cng" />. Sur .NET Core, elle retourne une instance d’une classe privée dérivée de <see cref="T:System.Security.Cryptography.SHA256" />.</returns>
      <exception cref="T:System.Reflection.TargetInvocationException">Dans .NET Framework 4.6.1 et les versions antérieures uniquement : L’algorithme a été utilisé en mode FIPS (Federal Information Processing Standards), mais il n’est pas compatible avec la norme FIPS.</exception>
    </member>
    <member name="M:System.Security.Cryptography.SHA256.Create(System.String)">
      <summary>Crée une instance de l'implémentation spécifiée de <see cref="T:System.Security.Cryptography.SHA256" />.</summary>
      <param name="hashName">Nom de l'implémentation spécifique de <see cref="T:System.Security.Cryptography.SHA256" /> à utiliser.</param>
      <returns>Nouvelle instance de <see cref="T:System.Security.Cryptography.SHA256" /> à l'aide de l'implémentation spécifiée.</returns>
      <exception cref="T:System.Reflection.TargetInvocationException">Dans .NET Framework uniquement : Le mode FIPS est activé, mais <paramref name="hashName" /> demande <see cref="T:System.Security.Cryptography.SHA256Managed" />, qui n’est pas compatible avec la norme FIPS.</exception>
    </member>
    <member name="T:System.Security.Cryptography.SHA256Managed">
      <summary>Calcule le hachage <see cref="T:System.Security.Cryptography.SHA256" /> pour les données d'entrée à l'aide de la bibliothèque managée.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA256Managed.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.SHA256Managed" /> à l'aide de la bibliothèque managée.</summary>
      <exception cref="T:System.InvalidOperationException">Le paramètre de sécurité FIPS (Federal Information Processing Standards) est activé. Cette implémentation ne fait pas partie des algorithmes de chiffrement validés FIPS pour les plateformes Windows.</exception>
    </member>
    <member name="M:System.Security.Cryptography.SHA256Managed.Dispose(System.Boolean)">
      <summary>Libère les ressources non managées utilisées par l’objet <see cref="T:System.Security.Cryptography.SHA256Managed" /> et libère éventuellement les ressources managées.</summary>
      <param name="disposing">
        <see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour libérer uniquement les ressources non managées.</param>
    </member>
    <member name="M:System.Security.Cryptography.SHA256Managed.HashCore(System.Byte[],System.Int32,System.Int32)">
      <summary>En cas de substitution dans une classe dérivée, achemine les données écrites dans l'objet vers l'algorithme de hachage <see cref="T:System.Security.Cryptography.SHA256" /> pour calculer le hachage.</summary>
      <param name="array">Données d'entrée.</param>
      <param name="ibStart">Offset dans le tableau d'octets à partir duquel l'utilisation de données commence.</param>
      <param name="cbSize">Nombre d'octets dans le tableau à utiliser comme données.</param>
    </member>
    <member name="M:System.Security.Cryptography.SHA256Managed.HashCore(System.ReadOnlySpan{System.Byte})">
      <param name="source" />
    </member>
    <member name="M:System.Security.Cryptography.SHA256Managed.HashFinal">
      <summary>En cas de substitution dans une classe dérivée, finalise le calcul de hachage une fois les dernières données traitées par l'objet de flux de chiffrement.</summary>
      <returns>Code de hachage calculé.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SHA256Managed.Initialize">
      <summary>Initialise une instance de <see cref="T:System.Security.Cryptography.SHA256Managed" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA256Managed.TryHashFinal(System.Span{System.Byte},System.Int32@)">
      <param name="destination" />
      <param name="bytesWritten" />
    </member>
    <member name="T:System.Security.Cryptography.SHA384">
      <summary>Calcule le hachage <see cref="T:System.Security.Cryptography.SHA384" /> pour les données d'entrée.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA384.#ctor">
      <summary>Initialise une nouvelle instance de <see cref="T:System.Security.Cryptography.SHA384" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA384.Create">
      <summary>Crée une instance de l'implémentation par défaut de <see cref="T:System.Security.Cryptography.SHA384" />.</summary>
      <returns>Nouvelle instance de <see cref="T:System.Security.Cryptography.SHA384" />.</returns>
      <exception cref="T:System.Reflection.TargetInvocationException">L’algorithme a été utilisé en mode FIPS (Federal Information Processing Standards), mais il n’est pas compatible avec la norme FIPS.</exception>
    </member>
    <member name="M:System.Security.Cryptography.SHA384.Create(System.String)">
      <summary>Crée une instance de l'implémentation spécifiée de <see cref="T:System.Security.Cryptography.SHA384" />.</summary>
      <param name="hashName">Nom de l'implémentation spécifique de <see cref="T:System.Security.Cryptography.SHA384" /> à utiliser.</param>
      <returns>Nouvelle instance de <see cref="T:System.Security.Cryptography.SHA384" /> à l'aide de l'implémentation spécifiée.</returns>
      <exception cref="T:System.Reflection.TargetInvocationException">L'algorithme décrit par le paramètre <paramref name="hashName" /> a été utilisé avec mode FIPS activé, mais n'est pas compatible FIPS.</exception>
    </member>
    <member name="T:System.Security.Cryptography.SHA384Managed">
      <summary>Calcule le hachage <see cref="T:System.Security.Cryptography.SHA384" /> pour les données d'entrée à l'aide de la bibliothèque managée.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA384Managed.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.SHA384Managed" />.</summary>
      <exception cref="T:System.InvalidOperationException">Le paramètre de sécurité FIPS (Federal Information Processing Standards) est activé. Cette implémentation ne fait pas partie des algorithmes de chiffrement validés FIPS pour les plateformes Windows.</exception>
    </member>
    <member name="M:System.Security.Cryptography.SHA384Managed.Dispose(System.Boolean)">
      <summary>Libère les ressources non managées utilisées par l’objet <see cref="T:System.Security.Cryptography.SHA384Managed" /> et libère éventuellement les ressources managées.</summary>
      <param name="disposing">
        <see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour libérer uniquement les ressources non managées.</param>
    </member>
    <member name="M:System.Security.Cryptography.SHA384Managed.HashCore(System.Byte[],System.Int32,System.Int32)">
      <summary>En cas de substitution dans une classe dérivée, achemine les données écrites dans l'objet vers l'algorithme de hachage <see cref="T:System.Security.Cryptography.SHA384Managed" /> pour calculer le hachage.</summary>
      <param name="array">Données d'entrée.</param>
      <param name="ibStart">Offset dans le tableau d'octets à partir duquel l'utilisation de données commence.</param>
      <param name="cbSize">Nombre d'octets dans le tableau à utiliser comme données.</param>
    </member>
    <member name="M:System.Security.Cryptography.SHA384Managed.HashCore(System.ReadOnlySpan{System.Byte})">
      <param name="source" />
    </member>
    <member name="M:System.Security.Cryptography.SHA384Managed.HashFinal">
      <summary>En cas de substitution dans une classe dérivée, finalise le calcul de hachage une fois les dernières données traitées par l'objet de flux de chiffrement.</summary>
      <returns>Code de hachage calculé.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SHA384Managed.Initialize">
      <summary>Initialise une instance de <see cref="T:System.Security.Cryptography.SHA384Managed" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA384Managed.TryHashFinal(System.Span{System.Byte},System.Int32@)">
      <param name="destination" />
      <param name="bytesWritten" />
    </member>
    <member name="T:System.Security.Cryptography.SHA512">
      <summary>Calcule le hachage <see cref="T:System.Security.Cryptography.SHA512" /> pour les données d'entrée.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA512.#ctor">
      <summary>Initialise une nouvelle instance de <see cref="T:System.Security.Cryptography.SHA512" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA512.Create">
      <summary>Crée une instance de l'implémentation par défaut de <see cref="T:System.Security.Cryptography.SHA512" />.</summary>
      <returns>Nouvelle instance de <see cref="T:System.Security.Cryptography.SHA512" />.</returns>
      <exception cref="T:System.Reflection.TargetInvocationException">L’algorithme a été utilisé en mode FIPS (Federal Information Processing Standards), mais il n’est pas compatible avec la norme FIPS.</exception>
    </member>
    <member name="M:System.Security.Cryptography.SHA512.Create(System.String)">
      <summary>Crée une instance de l'implémentation spécifiée de <see cref="T:System.Security.Cryptography.SHA512" />.</summary>
      <param name="hashName">Nom de l'implémentation spécifique de <see cref="T:System.Security.Cryptography.SHA512" /> à utiliser.</param>
      <returns>Nouvelle instance de <see cref="T:System.Security.Cryptography.SHA512" /> à l'aide de l'implémentation spécifiée.</returns>
      <exception cref="T:System.Reflection.TargetInvocationException">L'algorithme décrit par le paramètre <paramref name="hashName" /> a été utilisé avec mode FIPS activé, mais n'est pas compatible FIPS.</exception>
    </member>
    <member name="T:System.Security.Cryptography.SHA512Managed">
      <summary>Calcule l'algorithme de hachage <see cref="T:System.Security.Cryptography.SHA512" /> pour les données d'entrée à l'aide de la bibliothèque managée.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA512Managed.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.SHA512Managed" />.</summary>
      <exception cref="T:System.InvalidOperationException">Le paramètre de sécurité FIPS (Federal Information Processing Standards) est activé. Cette implémentation ne fait pas partie des algorithmes de chiffrement validés FIPS pour les plateformes Windows.</exception>
    </member>
    <member name="M:System.Security.Cryptography.SHA512Managed.Dispose(System.Boolean)">
      <summary>Libère les ressources non managées utilisées par l’objet <see cref="T:System.Security.Cryptography.SHA512Managed" /> et libère éventuellement les ressources managées.</summary>
      <param name="disposing">
        <see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour libérer uniquement les ressources non managées.</param>
    </member>
    <member name="M:System.Security.Cryptography.SHA512Managed.HashCore(System.Byte[],System.Int32,System.Int32)">
      <summary>En cas de substitution dans une classe dérivée, achemine les données écrites dans l'objet vers l'algorithme de hachage <see cref="T:System.Security.Cryptography.SHA512Managed" /> pour calculer le hachage.</summary>
      <param name="array">Données d'entrée.</param>
      <param name="ibStart">Offset dans le tableau d'octets à partir duquel l'utilisation de données commence.</param>
      <param name="cbSize">Nombre d'octets dans le tableau à utiliser comme données.</param>
    </member>
    <member name="M:System.Security.Cryptography.SHA512Managed.HashCore(System.ReadOnlySpan{System.Byte})">
      <param name="source" />
    </member>
    <member name="M:System.Security.Cryptography.SHA512Managed.HashFinal">
      <summary>En cas de substitution dans une classe dérivée, finalise le calcul de hachage une fois les dernières données traitées par l'objet de flux de chiffrement.</summary>
      <returns>Code de hachage calculé.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SHA512Managed.Initialize">
      <summary>Initialise une instance de la classe <see cref="T:System.Security.Cryptography.SHA512Managed" /> à l'aide de la bibliothèque managée.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA512Managed.TryHashFinal(System.Span{System.Byte},System.Int32@)">
      <param name="destination" />
      <param name="bytesWritten" />
    </member>
    <member name="T:System.Security.Cryptography.SignatureDescription">
      <summary>Contient des informations relatives aux propriétés d'une signature numérique.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SignatureDescription.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.SignatureDescription" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SignatureDescription.#ctor(System.Security.SecurityElement)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.SignatureDescription" /> à partir du <see cref="T:System.Security.SecurityElement" /> spécifié.</summary>
      <param name="el">
        <see cref="T:System.Security.SecurityElement" /> à partir duquel obtenir les algorithmes pour la description de signature.</param>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="el" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.SignatureDescription.CreateDeformatter(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Crée une instance de <see cref="T:System.Security.Cryptography.AsymmetricSignatureDeformatter" /> avec la clé spécifiée en utilisant la propriété <see cref="P:System.Security.Cryptography.SignatureDescription.DeformatterAlgorithm" />.</summary>
      <param name="key">Clé à utiliser dans <see cref="T:System.Security.Cryptography.AsymmetricSignatureDeformatter" />.</param>
      <returns>Instance nouvellement créée de <see cref="T:System.Security.Cryptography.AsymmetricSignatureDeformatter" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SignatureDescription.CreateDigest">
      <summary>Crée une instance de <see cref="T:System.Security.Cryptography.HashAlgorithm" /> en utilisant la propriété <see cref="P:System.Security.Cryptography.SignatureDescription.DigestAlgorithm" />.</summary>
      <returns>Instance nouvellement créée de <see cref="T:System.Security.Cryptography.HashAlgorithm" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SignatureDescription.CreateFormatter(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Crée une instance de <see cref="T:System.Security.Cryptography.AsymmetricSignatureFormatter" /> avec la clé spécifiée en utilisant la propriété <see cref="P:System.Security.Cryptography.SignatureDescription.FormatterAlgorithm" />.</summary>
      <param name="key">Clé à utiliser dans <see cref="T:System.Security.Cryptography.AsymmetricSignatureFormatter" />.</param>
      <returns>Instance nouvellement créée de <see cref="T:System.Security.Cryptography.AsymmetricSignatureFormatter" />.</returns>
    </member>
    <member name="P:System.Security.Cryptography.SignatureDescription.DeformatterAlgorithm">
      <summary>Obtient ou définit l'algorithme du déformateur pour la description de signature.</summary>
      <returns>Algorithme du déformateur pour la description de signature.</returns>
    </member>
    <member name="P:System.Security.Cryptography.SignatureDescription.DigestAlgorithm">
      <summary>Obtient ou définit l'algorithme Digest pour la description de signature.</summary>
      <returns>Algorithme Digest pour la description de signature.</returns>
    </member>
    <member name="P:System.Security.Cryptography.SignatureDescription.FormatterAlgorithm">
      <summary>Obtient ou définit l'algorithme du formateur pour la description de signature.</summary>
      <returns>Algorithme du formateur pour la description de signature.</returns>
    </member>
    <member name="P:System.Security.Cryptography.SignatureDescription.KeyAlgorithm">
      <summary>Obtient ou définit l'algorithme à clé pour la description de signature.</summary>
      <returns>Algorithme à clé pour la description de signature.</returns>
    </member>
    <member name="T:System.Security.Cryptography.TripleDES">
      <summary>Représente la classe de base pour les algorithmes Triple Data Encryption Standard (norme de chiffrement des données triple) dont toutes les implémentations <see cref="T:System.Security.Cryptography.TripleDES" /> doivent dériver.</summary>
    </member>
    <member name="M:System.Security.Cryptography.TripleDES.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.TripleDES" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.TripleDES.Create">
      <summary>Crée une instance d’un objet de chiffrement pour exécuter l’algorithme <see cref="T:System.Security.Cryptography.TripleDES" />.</summary>
      <returns>Instance d’un objet de chiffrement.</returns>
    </member>
    <member name="M:System.Security.Cryptography.TripleDES.Create(System.String)">
      <summary>Crée une instance d'un objet de chiffrement pour exécuter l'implémentation spécifiée de l'algorithme <see cref="T:System.Security.Cryptography.TripleDES" />.</summary>
      <param name="str">Nom de l'implémentation spécifique de <see cref="T:System.Security.Cryptography.TripleDES" /> à utiliser.</param>
      <returns>Instance d’un objet de chiffrement.</returns>
    </member>
    <member name="M:System.Security.Cryptography.TripleDES.IsWeakKey(System.Byte[])">
      <summary>Détermine si la clé spécifiée est faible.</summary>
      <param name="rgbKey">Clé secrète dont la faiblesse doit être testée.</param>
      <returns>
        <see langword="true" /> si la clé est faible ; sinon <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La taille du paramètre <paramref name="rgbKey" /> n'est pas valide.</exception>
    </member>
    <member name="P:System.Security.Cryptography.TripleDES.Key">
      <summary>Obtient ou définit la clé secrète pour l'algorithme <see cref="T:System.Security.Cryptography.TripleDES" />.</summary>
      <returns>Clé secrète pour l'algorithme <see cref="T:System.Security.Cryptography.TripleDES" />.</returns>
      <exception cref="T:System.ArgumentNullException">Une tentative d'affecter la valeur <see langword="null" /> à la clé a été effectuée.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Une tentative a été faite de définir une clé dont la longueur n'est pas valide.  

ou - 
Une tentative a été faite de définir une clé faible (consultez <see cref="M:System.Security.Cryptography.TripleDES.IsWeakKey(System.Byte[])" />).</exception>
    </member>
  </members>
</doc>