<?xml version="1.0" encoding="utf-8"?>
<doc xmlns:vsli="https://github.com/sk-0520/vs-localized-intellisense/tree/master/schema/2024">
  <assembly>
    <name>System.Linq.Expressions</name>
  </assembly>
  <members>
    <member name="T:System.Dynamic.BinaryOperationBinder">
      <summary vsli:raw="Represents the binary dynamic operation at the call site, providing the binding semantic and the details about the operation.">Représente l’opération dynamique binaire sur le site d’appel, en fournissant la sémantique de liaison et les détails de l’opération.</summary>
    </member>
    <member name="M:System.Dynamic.BinaryOperationBinder.#ctor(System.Linq.Expressions.ExpressionType)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Dynamic.BinaryOperationBinder&quot; /&gt; class.">Initialise une nouvelle instance de la classe <see cref="T:System.Dynamic.BinaryOperationBinder" />.</summary>
      <param name="operation" vsli:raw="The binary operation kind.">Type d'opération binaire.</param>
    </member>
    <member name="M:System.Dynamic.BinaryOperationBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic binary operation.">Exécute la liaison de l'opération binaire dynamique.</summary>
      <param name="target" vsli:raw="The target of the dynamic operation.">Cible de l'opération dynamique.</param>
      <param name="args" vsli:raw="An array of arguments of the dynamic operation.">Tableau d'arguments de l'opération dynamique.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.BinaryOperationBinder.FallbackBinaryOperation(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="Performs the binding of the binary dynamic operation if the target dynamic object cannot bind.">Effectue la liaison de l'opération dynamique binaire si l'objet dynamique cible ne peut pas être lié.</summary>
      <param name="target" vsli:raw="The target of the dynamic binary operation.">Cible de l'opération binaire dynamique.</param>
      <param name="arg" vsli:raw="The right hand side operand of the dynamic binary operation.">Opérande droit de l'opération binaire dynamique.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.BinaryOperationBinder.FallbackBinaryOperation(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="When overridden in the derived class, performs the binding of the binary dynamic operation if the target dynamic object cannot bind.">En cas de substitution dans la classe dérivée, exécute la liaison de l'opération dynamique binaire si l'objet dynamique cible ne peut pas être lié.</summary>
      <param name="target" vsli:raw="The target of the dynamic binary operation.">Cible de l'opération binaire dynamique.</param>
      <param name="arg" vsli:raw="The right hand side operand of the dynamic binary operation.">Opérande droit de l'opération binaire dynamique.</param>
      <param name="errorSuggestion" vsli:raw="The binding result if the binding fails, or null.">Résultat de liaison si la liaison échoue, ou Null.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="P:System.Dynamic.BinaryOperationBinder.Operation">
      <summary vsli:raw="The binary operation kind.">Type d'opération binaire.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; object representing the kind of binary operation.">Objet <see cref="T:System.Linq.Expressions.ExpressionType" /> représentant le type d'opération binaire.</returns>
    </member>
    <member name="P:System.Dynamic.BinaryOperationBinder.ReturnType">
      <summary vsli:raw="The result type of the operation.">Type de résultat de l'opération.</summary>
      <returns vsli:raw="The result type of the operation.">Type de résultat de l'opération.</returns>
    </member>
    <member name="T:System.Dynamic.BindingRestrictions">
      <summary vsli:raw="Represents a set of binding restrictions on the &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; under which the dynamic binding is valid.">Représente un jeu de restrictions de liaison sur le <see cref="T:System.Dynamic.DynamicMetaObject" /> sous lequel la liaison dynamique est valide.</summary>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.Combine(System.Collections.Generic.IList{System.Dynamic.DynamicMetaObject})">
      <summary vsli:raw="Combines binding restrictions from the list of &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; instances into one set of restrictions.">Combine les restrictions de liaison de la liste d'instances de <see cref="T:System.Dynamic.DynamicMetaObject" /> en un jeu de restrictions.</summary>
      <param name="contributingObjects" vsli:raw="The list of &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; instances from which to combine restrictions.">Liste des instances de <see cref="T:System.Dynamic.DynamicMetaObject" /> à partir desquelles combiner les restrictions.</param>
      <returns vsli:raw="The new set of binding restrictions.">Nouveau jeu de restrictions de liaison.</returns>
    </member>
    <member name="F:System.Dynamic.BindingRestrictions.Empty">
      <summary vsli:raw="Represents an empty set of binding restrictions. This field is read only.">Représente un jeu de restrictions de liaison vide. Ce champ est en lecture seule.</summary>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.GetExpressionRestriction(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates the binding restriction that checks the expression for arbitrary immutable properties.">Crée la restriction de liaison qui vérifie si l'expression contient des propriétés immuables arbitraires.</summary>
      <param name="expression" vsli:raw="The expression representing the restrictions.">Expression qui représente les restrictions.</param>
      <returns vsli:raw="The new binding restrictions.">Restrictions applicables à la nouvelle liaison.</returns>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.GetInstanceRestriction(System.Linq.Expressions.Expression,System.Object)">
      <summary vsli:raw="Creates the binding restriction that checks the expression for object instance identity.">Crée la restriction de liaison qui vérifie l'identité de l'instance de l'objet dans l'expression.</summary>
      <param name="expression" vsli:raw="The expression to test.">Expression à tester.</param>
      <param name="instance" vsli:raw="The exact object instance to test.">Instance exacte de l'objet à tester.</param>
      <returns vsli:raw="The new binding restrictions.">Restrictions applicables à la nouvelle liaison.</returns>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.GetTypeRestriction(System.Linq.Expressions.Expression,System.Type)">
      <summary vsli:raw="Creates the binding restriction that check the expression for runtime type identity.">Crée la restriction de liaison qui vérifie l'identité du type au moment de l'exécution dans l'expression.</summary>
      <param name="expression" vsli:raw="The expression to test.">Expression à tester.</param>
      <param name="type" vsli:raw="The exact type to test.">Type exact à tester.</param>
      <returns vsli:raw="The new binding restrictions.">Restrictions applicables à la nouvelle liaison.</returns>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.Merge(System.Dynamic.BindingRestrictions)">
      <summary vsli:raw="Merges the set of binding restrictions with the current binding restrictions.">Fusionne le jeu de restrictions de liaison avec les restrictions de liaison actuelles.</summary>
      <param name="restrictions" vsli:raw="The set of restrictions with which to merge the current binding restrictions.">Jeu de restrictions à fusionner avec les restrictions de liaison actuelles.</param>
      <returns vsli:raw="The new set of binding restrictions.">Nouveau jeu de restrictions de liaison.</returns>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.ToExpression">
      <summary vsli:raw="Creates the &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; representing the binding restrictions.">Crée le <see cref="T:System.Linq.Expressions.Expression" /> qui représente les restrictions de liaison.</summary>
      <returns vsli:raw="The expression tree representing the restrictions.">Arborescence de l'expression qui représente les restrictions.</returns>
    </member>
    <member name="T:System.Dynamic.CallInfo">
      <summary vsli:raw="Describes arguments in the dynamic binding process.">Décrit les arguments dans le processus de liaison dynamique.</summary>
    </member>
    <member name="M:System.Dynamic.CallInfo.#ctor(System.Int32,System.Collections.Generic.IEnumerable{System.String})">
      <summary vsli:raw="Creates a new CallInfo that represents arguments in the dynamic binding process.">Crée un nouveau CallInfo qui représente des arguments dans le processus de liaison dynamique.</summary>
      <param name="argCount" vsli:raw="The number of arguments.">Le nombre d’arguments.</param>
      <param name="argNames" vsli:raw="The argument names.">Noms d'arguments.</param>
    </member>
    <member name="M:System.Dynamic.CallInfo.#ctor(System.Int32,System.String[])">
      <summary vsli:raw="Creates a new &lt;c&gt;PositionalArgumentInfo&lt;/c&gt;.">Crée un <c>PositionalArgumentInfo</c>.</summary>
      <param name="argCount" vsli:raw="The number of arguments.">Le nombre d’arguments.</param>
      <param name="argNames" vsli:raw="The argument names.">Noms d'arguments.</param>
    </member>
    <member name="P:System.Dynamic.CallInfo.ArgumentCount">
      <summary vsli:raw="The number of arguments.">Le nombre d’arguments.</summary>
      <returns vsli:raw="The number of arguments.">Le nombre d’arguments.</returns>
    </member>
    <member name="P:System.Dynamic.CallInfo.ArgumentNames">
      <summary vsli:raw="The argument names.">Noms d'arguments.</summary>
      <returns vsli:raw="The read-only collection of argument names.">Collection en lecture seule de noms d'arguments.</returns>
    </member>
    <member name="M:System.Dynamic.CallInfo.Equals(System.Object)">
      <summary vsli:raw="Determines whether the specified CallInfo instance is considered equal to the current.">Détermine si l'instance de CallInfo spécifiée est considérée comme étant égale à l'instance en cours.</summary>
      <param name="obj" vsli:raw="The instance of &lt;see cref=&quot;T:System.Dynamic.CallInfo&quot; /&gt; to compare with the current instance.">Instance de <see cref="T:System.Dynamic.CallInfo" /> à comparer avec l'instance actuelle.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the specified instance is equal to the current one otherwise, &lt;see langword=&quot;false&quot; /&gt;.">True si l'instance spécifiée est égale à l'instance actuelle ; sinon, false.</returns>
    </member>
    <member name="M:System.Dynamic.CallInfo.GetHashCode">
      <summary vsli:raw="Serves as a hash function for the current &lt;see cref=&quot;T:System.Dynamic.CallInfo&quot; /&gt;.">Sert de fonction de hachage pour le <see cref="T:System.Dynamic.CallInfo" /> actuel.</summary>
      <returns vsli:raw="A hash code for the current &lt;see cref=&quot;T:System.Dynamic.CallInfo&quot; /&gt;.">Code de hachage du <see cref="T:System.Dynamic.CallInfo" /> actuel.</returns>
    </member>
    <member name="T:System.Dynamic.ConvertBinder">
      <summary vsli:raw="Represents the convert dynamic operation at the call site, providing the binding semantic and the details about the operation.">Représente l’opération dynamique de conversion sur le site d’appel, en fournissant la sémantique de liaison et les détails de l’opération.</summary>
    </member>
    <member name="M:System.Dynamic.ConvertBinder.#ctor(System.Type,System.Boolean)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Dynamic.ConvertBinder&quot; /&gt;.">Initialise une nouvelle instance de l'objet <see cref="T:System.Dynamic.ConvertBinder" />.</summary>
      <param name="type" vsli:raw="The type to convert to.">Type vers lequel effectuer la conversion.</param>
      <param name="explicit" vsli:raw="Is true if the conversion should consider explicit conversions; otherwise, false.">A la valeur true si la conversion doit prendre en compte les conversions de type explicite ; sinon, false.</param>
    </member>
    <member name="M:System.Dynamic.ConvertBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic convert operation.">Exécute la liaison de l'opération de conversion dynamique.</summary>
      <param name="target" vsli:raw="The target of the dynamic convert operation.">Cible de l'opération de conversion dynamique.</param>
      <param name="args" vsli:raw="An array of arguments of the dynamic convert operation.">Tableau d'arguments de l'opération de conversion dynamique.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="P:System.Dynamic.ConvertBinder.Explicit">
      <summary vsli:raw="Gets the value indicating if the conversion should consider explicit conversions.">Obtient la valeur qui indique si la conversion doit prendre en compte les conversions de type explicite.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if there is an explicit conversion; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />s’il existe une conversion explicite; Sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Dynamic.ConvertBinder.FallbackConvert(System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="Performs the binding of the dynamic convert operation if the target dynamic object cannot bind.">Effectue la liaison de l'opération de conversion dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <param name="target" vsli:raw="The target of the dynamic convert operation.">Cible de l'opération de conversion dynamique.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.ConvertBinder.FallbackConvert(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="When overridden in the derived class, performs the binding of the dynamic convert operation if the target dynamic object cannot bind.">En cas de substitution dans la classe dérivée, exécute la liaison de l'opération de conversion dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <param name="target" vsli:raw="The target of the dynamic convert operation.">Cible de l'opération de conversion dynamique.</param>
      <param name="errorSuggestion" vsli:raw="The binding result to use if binding fails, or null.">Résultat de liaison à utiliser si la liaison échoue, ou Null.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="P:System.Dynamic.ConvertBinder.ReturnType">
      <summary vsli:raw="The result type of the operation.">Type de résultat de l'opération.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the result type of the operation.">Objet <see cref="T:System.Type" /> représentant le type de résultat de l'opération.</returns>
    </member>
    <member name="P:System.Dynamic.ConvertBinder.Type">
      <summary vsli:raw="The type to convert to.">Type vers lequel effectuer la conversion.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents the type to convert to.">Objet <see cref="T:System.Type" /> qui représente le type vers lequel effectuer la conversion.</returns>
    </member>
    <member name="T:System.Dynamic.CreateInstanceBinder">
      <summary vsli:raw="Represents the dynamic create operation at the call site, providing the binding semantic and the details about the operation.">Représente l’opération de création dynamique sur le site d’appel, en fournissant la sémantique de liaison et les détails de l’opération.</summary>
    </member>
    <member name="M:System.Dynamic.CreateInstanceBinder.#ctor(System.Dynamic.CallInfo)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Dynamic.CreateInstanceBinder&quot; /&gt;.">Initialise une nouvelle instance de l'objet <see cref="T:System.Dynamic.CreateInstanceBinder" />.</summary>
      <param name="callInfo" vsli:raw="The signature of the arguments at the call site.">Signature des arguments au niveau du site d’appel.</param>
    </member>
    <member name="M:System.Dynamic.CreateInstanceBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic create operation.">Exécute la liaison de l'opération de création dynamique.</summary>
      <param name="target" vsli:raw="The target of the dynamic create operation.">Cible de l'opération de création dynamique.</param>
      <param name="args" vsli:raw="An array of arguments of the dynamic create operation.">Tableau d'arguments de l'opération de création dynamique.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="P:System.Dynamic.CreateInstanceBinder.CallInfo">
      <summary vsli:raw="Gets the signature of the arguments at the call site.">Obtient la signature des arguments au niveau du site d’appel.</summary>
      <returns vsli:raw="The signature of the arguments at the call site.">Signature des arguments au niveau du site d’appel.</returns>
    </member>
    <member name="M:System.Dynamic.CreateInstanceBinder.FallbackCreateInstance(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic create operation if the target dynamic object cannot bind.">Effectue la liaison de l'opération de création dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <param name="target" vsli:raw="The target of the dynamic create operation.">Cible de l'opération de création dynamique.</param>
      <param name="args" vsli:raw="The arguments of the dynamic create operation.">Arguments de l'opération de création dynamique.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.CreateInstanceBinder.FallbackCreateInstance(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="When overridden in the derived class, performs the binding of the dynamic create operation if the target dynamic object cannot bind.">En cas de substitution dans la classe dérivée, exécute la liaison de l'opération de création dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <param name="target" vsli:raw="The target of the dynamic create operation.">Cible de l'opération de création dynamique.</param>
      <param name="args" vsli:raw="The arguments of the dynamic create operation.">Arguments de l'opération de création dynamique.</param>
      <param name="errorSuggestion" vsli:raw="The binding result to use if binding fails, or null.">Résultat de liaison à utiliser si la liaison échoue, ou Null.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="P:System.Dynamic.CreateInstanceBinder.ReturnType">
      <summary vsli:raw="The result type of the operation.">Type de résultat de l'opération.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the result type of the operation.">Objet <see cref="T:System.Type" /> représentant le type de résultat de l'opération.</returns>
    </member>
    <member name="T:System.Dynamic.DeleteIndexBinder">
      <summary vsli:raw="Represents the dynamic delete index operation at the call site, providing the binding semantic and the details about the operation.">Représente l'opération de suppression d'index dynamique au site d'appel, en fournissant la sémantique de liaison et les détails de l'opération.</summary>
    </member>
    <member name="M:System.Dynamic.DeleteIndexBinder.#ctor(System.Dynamic.CallInfo)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Dynamic.DeleteIndexBinder&quot; /&gt;.">Initialise une nouvelle instance de l'objet <see cref="T:System.Dynamic.DeleteIndexBinder" />.</summary>
      <param name="callInfo" vsli:raw="The signature of the arguments at the call site.">Signature des arguments au niveau du site d’appel.</param>
    </member>
    <member name="M:System.Dynamic.DeleteIndexBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic delete index operation.">Exécute la liaison de l'opération de suppression d'index dynamique.</summary>
      <param name="target" vsli:raw="The target of the dynamic delete index operation.">Cible de l'opération de suppression d'index dynamique.</param>
      <param name="args" vsli:raw="An array of arguments of the dynamic delete index operation.">Tableau d'arguments de l'opération de suppression d'index dynamique.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="P:System.Dynamic.DeleteIndexBinder.CallInfo">
      <summary vsli:raw="Gets the signature of the arguments at the call site.">Obtient la signature des arguments au niveau du site d’appel.</summary>
      <returns vsli:raw="The signature of the arguments at the call site.">Signature des arguments au niveau du site d’appel.</returns>
    </member>
    <member name="M:System.Dynamic.DeleteIndexBinder.FallbackDeleteIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic delete index operation if the target dynamic object cannot bind.">Effectue la liaison de l'opération de suppression d'index dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <param name="target" vsli:raw="The target of the dynamic delete index operation.">Cible de l'opération de suppression d'index dynamique.</param>
      <param name="indexes" vsli:raw="The arguments of the dynamic delete index operation.">Arguments de l'opération de suppression d'index dynamique.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.DeleteIndexBinder.FallbackDeleteIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="When overridden in the derived class, performs the binding of the dynamic delete index operation if the target dynamic object cannot bind.">En cas de substitution dans la classe dérivée, exécute la liaison de l'opération de suppression d'index dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <param name="target" vsli:raw="The target of the dynamic delete index operation.">Cible de l'opération de suppression d'index dynamique.</param>
      <param name="indexes" vsli:raw="The arguments of the dynamic delete index operation.">Arguments de l'opération de suppression d'index dynamique.</param>
      <param name="errorSuggestion" vsli:raw="The binding result to use if binding fails, or null.">Résultat de liaison à utiliser si la liaison échoue, ou Null.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="P:System.Dynamic.DeleteIndexBinder.ReturnType">
      <summary vsli:raw="The result type of the operation.">Type de résultat de l'opération.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the result type of the operation.">Objet <see cref="T:System.Type" /> représentant le type de résultat de l'opération.</returns>
    </member>
    <member name="T:System.Dynamic.DeleteMemberBinder">
      <summary vsli:raw="Represents the dynamic delete member operation at the call site, providing the binding semantic and the details about the operation.">Représente l'opération de suppression de membre dynamique au site d'appel, en fournissant la sémantique de liaison et les détails de l'opération.</summary>
    </member>
    <member name="M:System.Dynamic.DeleteMemberBinder.#ctor(System.String,System.Boolean)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Dynamic.DeleteIndexBinder&quot; /&gt;.">Initialise une nouvelle instance de l'objet <see cref="T:System.Dynamic.DeleteIndexBinder" />.</summary>
      <param name="name" vsli:raw="The name of the member to delete.">Nom du membre à supprimer.</param>
      <param name="ignoreCase" vsli:raw="Is true if the name should be matched ignoring case; false otherwise.">True si la correspondance avec le nom doit ignorer la casse ; sinon, False.</param>
    </member>
    <member name="M:System.Dynamic.DeleteMemberBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic delete member operation.">Exécute la liaison de l'opération de suppression de membre dynamique.</summary>
      <param name="target" vsli:raw="The target of the dynamic delete member operation.">Cible de l'opération de suppression de membre dynamique.</param>
      <param name="args" vsli:raw="An array of arguments of the dynamic delete member operation.">Tableau d'arguments de l'opération de suppression de membre dynamique.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.DeleteMemberBinder.FallbackDeleteMember(System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="Performs the binding of the dynamic delete member operation if the target dynamic object cannot bind.">Effectue la liaison de l'opération de suppression de membre dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <param name="target" vsli:raw="The target of the dynamic delete member operation.">Cible de l'opération de suppression de membre dynamique.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.DeleteMemberBinder.FallbackDeleteMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="When overridden in the derived class, performs the binding of the dynamic delete member operation if the target dynamic object cannot bind.">En cas de substitution dans la classe dérivée, exécute la liaison de l'opération de suppression de membre dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <param name="target" vsli:raw="The target of the dynamic delete member operation.">Cible de l'opération de suppression de membre dynamique.</param>
      <param name="errorSuggestion" vsli:raw="The binding result to use if binding fails, or null.">Résultat de liaison à utiliser si la liaison échoue, ou Null.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="P:System.Dynamic.DeleteMemberBinder.IgnoreCase">
      <summary vsli:raw="Gets the value indicating if the string comparison should ignore the case of the member name.">Obtient la valeur indiquant si la comparaison de chaîne doit ignorer la casse du nom du membre.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the string comparison should ignore case; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />Si la comparaison de chaînes doit ignorer la casse; Sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Dynamic.DeleteMemberBinder.Name">
      <summary vsli:raw="Gets the name of the member to delete.">Obtient le nom du membre à supprimer.</summary>
      <returns vsli:raw="The name of the member to delete.">Nom du membre à supprimer.</returns>
    </member>
    <member name="P:System.Dynamic.DeleteMemberBinder.ReturnType">
      <summary vsli:raw="The result type of the operation.">Type de résultat de l'opération.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the result type of the operation.">Objet <see cref="T:System.Type" /> représentant le type de résultat de l'opération.</returns>
    </member>
    <member name="T:System.Dynamic.DynamicMetaObject">
      <summary vsli:raw="Represents the dynamic binding and a binding logic of an object participating in the dynamic binding.">Représente la liaison dynamique et une logique de liaison d'un objet qui participe à la liaison dynamique.</summary>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.#ctor(System.Linq.Expressions.Expression,System.Dynamic.BindingRestrictions)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; class.">Initialise une nouvelle instance de la classe <see cref="T:System.Dynamic.DynamicMetaObject" />.</summary>
      <param name="expression" vsli:raw="The expression representing this &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; during the dynamic binding process.">Expression représentant cet objet <see cref="T:System.Dynamic.DynamicMetaObject" /> durant le processus de liaison dynamique.</param>
      <param name="restrictions" vsli:raw="The set of binding restrictions under which the binding is valid.">Ensemble de restrictions de liaisons sous lequel la liaison est valide.</param>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.#ctor(System.Linq.Expressions.Expression,System.Dynamic.BindingRestrictions,System.Object)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; class.">Initialise une nouvelle instance de la classe <see cref="T:System.Dynamic.DynamicMetaObject" />.</summary>
      <param name="expression" vsli:raw="The expression representing this &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; during the dynamic binding process.">Expression représentant cet objet <see cref="T:System.Dynamic.DynamicMetaObject" /> durant le processus de liaison dynamique.</param>
      <param name="restrictions" vsli:raw="The set of binding restrictions under which the binding is valid.">Ensemble de restrictions de liaisons sous lequel la liaison est valide.</param>
      <param name="value" vsli:raw="The runtime value represented by the &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt;.">Valeur d'exécution représentée par <see cref="T:System.Dynamic.DynamicMetaObject" />.</param>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="Performs the binding of the dynamic binary operation.">Exécute la liaison de l'opération binaire dynamique.</summary>
      <param name="binder" vsli:raw="An instance of the &lt;see cref=&quot;T:System.Dynamic.BinaryOperationBinder&quot; /&gt; that represents the details of the dynamic operation.">Instance du <see cref="T:System.Dynamic.BinaryOperationBinder" /> qui représente les détails de l'opération dynamique.</param>
      <param name="arg" vsli:raw="An instance of the &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the right hand side of the binary operation.">Instance de <see cref="T:System.Dynamic.DynamicMetaObject" /> qui représente le côté droit de l'opération binaire.</param>
      <returns vsli:raw="The new &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">Nouveau <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindConvert(System.Dynamic.ConvertBinder)">
      <summary vsli:raw="Performs the binding of the dynamic conversion operation.">Exécute la liaison de l'opération de conversion dynamique.</summary>
      <param name="binder" vsli:raw="An instance of the &lt;see cref=&quot;T:System.Dynamic.ConvertBinder&quot; /&gt; that represents the details of the dynamic operation.">Instance du <see cref="T:System.Dynamic.ConvertBinder" /> qui représente les détails de l'opération dynamique.</param>
      <returns vsli:raw="The new &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">Nouveau <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindCreateInstance(System.Dynamic.CreateInstanceBinder,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic create instance operation.">Exécute la liaison de l'opération de création d'instance dynamique.</summary>
      <param name="binder" vsli:raw="An instance of the &lt;see cref=&quot;T:System.Dynamic.CreateInstanceBinder&quot; /&gt; that represents the details of the dynamic operation.">Instance du <see cref="T:System.Dynamic.CreateInstanceBinder" /> qui représente les détails de l'opération dynamique.</param>
      <param name="args" vsli:raw="An array of &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; instances - arguments to the create instance operation.">Tableau d'instances <see cref="T:System.Dynamic.DynamicMetaObject" />, arguments de l'opération de création d'instance.</param>
      <returns vsli:raw="The new &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">Nouveau <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic delete index operation.">Exécute la liaison de l'opération de suppression d'index dynamique.</summary>
      <param name="binder" vsli:raw="An instance of the &lt;see cref=&quot;T:System.Dynamic.DeleteIndexBinder&quot; /&gt; that represents the details of the dynamic operation.">Instance du <see cref="T:System.Dynamic.DeleteIndexBinder" /> qui représente les détails de l'opération dynamique.</param>
      <param name="indexes" vsli:raw="An array of &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; instances - indexes for the delete index operation.">Tableau d'instances de <see cref="T:System.Dynamic.DynamicMetaObject" />, index pour l'opération de suppression d'index.</param>
      <returns vsli:raw="The new &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">Nouveau <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindDeleteMember(System.Dynamic.DeleteMemberBinder)">
      <summary vsli:raw="Performs the binding of the dynamic delete member operation.">Exécute la liaison de l'opération de suppression de membre dynamique.</summary>
      <param name="binder" vsli:raw="An instance of the &lt;see cref=&quot;T:System.Dynamic.DeleteMemberBinder&quot; /&gt; that represents the details of the dynamic operation.">Instance du <see cref="T:System.Dynamic.DeleteMemberBinder" /> qui représente les détails de l'opération dynamique.</param>
      <returns vsli:raw="The new &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">Nouveau <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindGetIndex(System.Dynamic.GetIndexBinder,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic get index operation.">Exécute la liaison de l'opération d'obtention d'index dynamique.</summary>
      <param name="binder" vsli:raw="An instance of the &lt;see cref=&quot;T:System.Dynamic.GetIndexBinder&quot; /&gt; that represents the details of the dynamic operation.">Instance du <see cref="T:System.Dynamic.GetIndexBinder" /> qui représente les détails de l'opération dynamique.</param>
      <param name="indexes" vsli:raw="An array of &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; instances - indexes for the get index operation.">Tableau d'instances de <see cref="T:System.Dynamic.DynamicMetaObject" />, index pour l'opération d'obtention d'index.</param>
      <returns vsli:raw="The new &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">Nouveau <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindGetMember(System.Dynamic.GetMemberBinder)">
      <summary vsli:raw="Performs the binding of the dynamic get member operation.">Exécute la liaison de l'opération d'obtention de membre dynamique.</summary>
      <param name="binder" vsli:raw="An instance of the &lt;see cref=&quot;T:System.Dynamic.GetMemberBinder&quot; /&gt; that represents the details of the dynamic operation.">Instance du <see cref="T:System.Dynamic.GetMemberBinder" /> qui représente les détails de l'opération dynamique.</param>
      <returns vsli:raw="The new &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">Nouveau <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindInvoke(System.Dynamic.InvokeBinder,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic invoke operation.">Effectue la liaison de l’opération d’appel dynamique.</summary>
      <param name="binder" vsli:raw="An instance of the &lt;see cref=&quot;T:System.Dynamic.InvokeBinder&quot; /&gt; that represents the details of the dynamic operation.">Instance du <see cref="T:System.Dynamic.InvokeBinder" /> qui représente les détails de l'opération dynamique.</param>
      <param name="args" vsli:raw="An array of &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; instances - arguments to the invoke operation.">Tableau d'instances <see cref="T:System.Dynamic.DynamicMetaObject" />, arguments de l'opération d'appel.</param>
      <returns vsli:raw="The new &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">Nouveau <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindInvokeMember(System.Dynamic.InvokeMemberBinder,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic invoke member operation.">Exécute la liaison de l'opération d'appel de membre dynamique.</summary>
      <param name="binder" vsli:raw="An instance of the &lt;see cref=&quot;T:System.Dynamic.InvokeMemberBinder&quot; /&gt; that represents the details of the dynamic operation.">Instance du <see cref="T:System.Dynamic.InvokeMemberBinder" /> qui représente les détails de l'opération dynamique.</param>
      <param name="args" vsli:raw="An array of &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; instances - arguments to the invoke member operation.">Tableau d'instances <see cref="T:System.Dynamic.DynamicMetaObject" />, arguments de l'opération d'appel de membres.</param>
      <returns vsli:raw="The new &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">Nouveau <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindSetIndex(System.Dynamic.SetIndexBinder,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="Performs the binding of the dynamic set index operation.">Exécute la liaison de l'opération de définition d'index dynamique.</summary>
      <param name="binder" vsli:raw="An instance of the &lt;see cref=&quot;T:System.Dynamic.SetIndexBinder&quot; /&gt; that represents the details of the dynamic operation.">Instance du <see cref="T:System.Dynamic.SetIndexBinder" /> qui représente les détails de l'opération dynamique.</param>
      <param name="indexes" vsli:raw="An array of &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; instances - indexes for the set index operation.">Tableau d'instances de <see cref="T:System.Dynamic.DynamicMetaObject" />, index pour l'opération de définition d'index.</param>
      <param name="value" vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the value for the set index operation.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant la valeur pour l'opération de définition d'index.</param>
      <returns vsli:raw="The new &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">Nouveau <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindSetMember(System.Dynamic.SetMemberBinder,System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="Performs the binding of the dynamic set member operation.">Exécute la liaison de l'opération de définition de membre dynamique.</summary>
      <param name="binder" vsli:raw="An instance of the &lt;see cref=&quot;T:System.Dynamic.SetMemberBinder&quot; /&gt; that represents the details of the dynamic operation.">Instance du <see cref="T:System.Dynamic.SetMemberBinder" /> qui représente les détails de l'opération dynamique.</param>
      <param name="value" vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the value for the set member operation.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant la valeur pour l'opération de définition de membre.</param>
      <returns vsli:raw="The new &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">Nouveau <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindUnaryOperation(System.Dynamic.UnaryOperationBinder)">
      <summary vsli:raw="Performs the binding of the dynamic unary operation.">Exécute la liaison de l'opération unaire dynamique.</summary>
      <param name="binder" vsli:raw="An instance of the &lt;see cref=&quot;T:System.Dynamic.UnaryOperationBinder&quot; /&gt; that represents the details of the dynamic operation.">Instance du <see cref="T:System.Dynamic.UnaryOperationBinder" /> qui représente les détails de l'opération dynamique.</param>
      <returns vsli:raw="The new &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">Nouveau <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.Create(System.Object,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a meta-object for the specified object.">Crée un objet méta pour l'objet spécifié.</summary>
      <param name="value" vsli:raw="The object to get a meta-object for.">Objet pour lequel obtenir un objet méta.</param>
      <param name="expression" vsli:raw="The expression representing this &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; during the dynamic binding process.">Expression représentant cet objet <see cref="T:System.Dynamic.DynamicMetaObject" /> durant le processus de liaison dynamique.</param>
      <returns vsli:raw="If the given object implements &lt;see cref=&quot;T:System.Dynamic.IDynamicMetaObjectProvider&quot; /&gt; and is not a remote object from outside the current AppDomain, returns the object's specific meta-object returned by &lt;see cref=&quot;M:System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(System.Linq.Expressions.Expression)&quot; /&gt;. Otherwise a plain new meta-object with no restrictions is created and returned.">Si l'objet spécifié implémente <see cref="T:System.Dynamic.IDynamicMetaObjectProvider" /> et n'est pas un objet distant extérieur au AppDomain actuel, retourne l'objet méta spécifique à l'objet retourné par <see cref="M:System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(System.Linq.Expressions.Expression)" />. Sinon, un nouvel objet méta brut sans restrictions est créé et retourné.</returns>
    </member>
    <member name="F:System.Dynamic.DynamicMetaObject.EmptyMetaObjects">
      <summary vsli:raw="Represents an empty array of type &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt;. This field is read only.">Représente un tableau vide du type <see cref="T:System.Dynamic.DynamicMetaObject" />. Ce champ est en lecture seule.</summary>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.Expression">
      <summary vsli:raw="The expression representing the &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; during the dynamic binding process.">Expression représentant <see cref="T:System.Dynamic.DynamicMetaObject" /> durant le processus de liaison dynamique.</summary>
      <returns vsli:raw="The expression representing the &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; during the dynamic binding process.">Expression représentant <see cref="T:System.Dynamic.DynamicMetaObject" /> durant le processus de liaison dynamique.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.GetDynamicMemberNames">
      <summary vsli:raw="Returns the enumeration of all dynamic member names.">Retourne l'énumération de tous les noms de membres dynamiques.</summary>
      <returns vsli:raw="The list of dynamic member names.">Liste des noms de membres dynamiques.</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.HasValue">
      <summary vsli:raw="Gets a value indicating whether the &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; has the runtime value.">Obtient une valeur indiquant si <see cref="T:System.Dynamic.DynamicMetaObject" /> a la valeur d'exécution.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; has the runtime value; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />Si le <see cref="T:System.Dynamic.DynamicMetaObject" /> a la valeur d’exécution; sinon <see langword="false" />,.</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.LimitType">
      <summary vsli:raw="Gets the limit type of the &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt;.">Obtient le type de limite de <see cref="T:System.Dynamic.DynamicMetaObject" />.</summary>
      <returns vsli:raw="&lt;see cref=&quot;P:System.Dynamic.DynamicMetaObject.RuntimeType&quot; /&gt; if runtime value is available, a type of the &lt;see cref=&quot;P:System.Dynamic.DynamicMetaObject.Expression&quot; /&gt; otherwise.">
        <see cref="P:System.Dynamic.DynamicMetaObject.RuntimeType" /> si la valeur d'exécution est disponible, sinon type de <see cref="P:System.Dynamic.DynamicMetaObject.Expression" />.</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.Restrictions">
      <summary vsli:raw="The set of binding restrictions under which the binding is valid.">Ensemble de restrictions de liaisons sous lequel la liaison est valide.</summary>
      <returns vsli:raw="The set of binding restrictions.">Jeu des restrictions de liaison.</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.RuntimeType">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Type&quot; /&gt; of the runtime value or null if the &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; has no value associated with it.">Obtient le <see cref="T:System.Type" /> de la valeur d'exécution ou null si <see cref="T:System.Dynamic.DynamicMetaObject" /> n'est associé à aucune valeur.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; of the runtime value or null.">
        <see cref="T:System.Type" /> de la valeur d'exécution ou null.</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.Value">
      <summary vsli:raw="The runtime value represented by this &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt;.">Valeur d'exécution représentée par <see cref="T:System.Dynamic.DynamicMetaObject" />.</summary>
      <returns vsli:raw="The runtime value represented by this &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt;.">Valeur d'exécution représentée par <see cref="T:System.Dynamic.DynamicMetaObject" />.</returns>
    </member>
    <member name="T:System.Dynamic.DynamicMetaObjectBinder">
      <summary vsli:raw="The dynamic call site binder that participates in the &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; binding protocol.">Binder de site d'appel dynamique qui participe au protocole de liaison <see cref="T:System.Dynamic.DynamicMetaObject" />.</summary>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObjectBinder&quot; /&gt; class.">Initialise une nouvelle instance de la classe <see cref="T:System.Dynamic.DynamicMetaObjectBinder" />.</summary>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="When overridden in the derived class, performs the binding of the dynamic operation.">En cas de substitution dans la classe dérivée, exécute la liaison de l'opération dynamique.</summary>
      <param name="target" vsli:raw="The target of the dynamic operation.">Cible de l'opération dynamique.</param>
      <param name="args" vsli:raw="An array of arguments of the dynamic operation.">Tableau d'arguments de l'opération dynamique.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.Bind(System.Object[],System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.LabelTarget)">
      <summary vsli:raw="Performs the runtime binding of the dynamic operation on a set of arguments.">Exécute la liaison au moment de l'exécution de l'opération dynamique sur un jeu d'arguments.</summary>
      <param name="args" vsli:raw="An array of arguments to the dynamic operation.">Tableau d'arguments de l'opération dynamique.</param>
      <param name="parameters" vsli:raw="The array of &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; instances that represent the parameters of the call site in the binding process.">Tableau des instances <see cref="T:System.Linq.Expressions.ParameterExpression" /> qui représentent les paramètres du site d'appel dans le processus de liaison.</param>
      <param name="returnLabel" vsli:raw="A LabelTarget used to return the result of the dynamic binding.">LabelTarget utilisé pour retourner le résultat de la liaison dynamique.</param>
      <returns vsli:raw="An Expression that performs tests on the dynamic operation arguments, and performs the dynamic operation if the tests are valid. If the tests fail on subsequent occurrences of the dynamic operation, Bind will be called again to produce a new &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; for the new argument types.">Expression qui exécute des tests sur les arguments d'opération dynamique, et exécute l'opération dynamique si les tests sont valides. Si les tests échouent sur les occurrences suivantes de l'opération dynamique, Bind est à nouveau appelé pour produire un nouveau <see cref="T:System.Linq.Expressions.Expression" /> pour les nouveaux types d'arguments.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.Defer(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Defers the binding of the operation until later time when the runtime values of all dynamic operation arguments have been computed.">Diffère la liaison de l'opération jusqu'à ce que les valeurs d'exécution de tous les arguments d'opération dynamique soient calculées.</summary>
      <param name="target" vsli:raw="The target of the dynamic operation.">Cible de l'opération dynamique.</param>
      <param name="args" vsli:raw="An array of arguments of the dynamic operation.">Tableau d'arguments de l'opération dynamique.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.Defer(System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Defers the binding of the operation until later time when the runtime values of all dynamic operation arguments have been computed.">Diffère la liaison de l'opération jusqu'à ce que les valeurs d'exécution de tous les arguments d'opération dynamique soient calculées.</summary>
      <param name="args" vsli:raw="An array of arguments of the dynamic operation.">Tableau d'arguments de l'opération dynamique.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.GetUpdateExpression(System.Type)">
      <summary vsli:raw="Gets an expression that will cause the binding to be updated. It indicates that the expression's binding is no longer valid. This is typically used when the &quot;version&quot; of a dynamic object has changed.">Obtient une expression qui entraîne la mise à jour de la liaison. Indique que la liaison de l'expression n'est plus valide. Cela est utilisé en général lorsque la « version » d'un objet dynamique a changé.</summary>
      <param name="type" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of the resulting expression; any type is allowed.">Propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de l'expression résultante ; tous les types sont autorisés.</param>
      <returns vsli:raw="The update expression.">Expression de mise à jour.</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObjectBinder.ReturnType">
      <summary vsli:raw="The result type of the operation.">Type de résultat de l'opération.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the result type of the operation.">Objet <see cref="T:System.Type" /> représentant le type de résultat de l'opération.</returns>
    </member>
    <member name="T:System.Dynamic.DynamicObject">
      <summary vsli:raw="Provides a base class for specifying dynamic behavior at run time. This class must be inherited from; you cannot instantiate it directly.">Fournit une classe de base pour la spécification du comportement dynamique pendant l'exécution. Cette classe doit être héritée ;vous ne pouvez pas l'instancier directement.</summary>
    </member>
    <member name="M:System.Dynamic.DynamicObject.#ctor">
      <summary vsli:raw="Enables derived types to initialize a new instance of the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; type.">Permet aux types dérivés d'initialiser une nouvelle instance du type <see cref="T:System.Dynamic.DynamicObject" />.</summary>
    </member>
    <member name="M:System.Dynamic.DynamicObject.GetDynamicMemberNames">
      <summary vsli:raw="Returns the enumeration of all dynamic member names.">Retourne l'énumération de tous les noms de membres dynamiques.</summary>
      <returns vsli:raw="A sequence that contains dynamic member names.">Séquence qui contient des noms de membre dynamiques.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.GetMetaObject(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Provides a &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; that dispatches to the dynamic virtual methods. The object can be encapsulated inside another &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; to provide custom behavior for individual actions. This method supports the Dynamic Language Runtime infrastructure for language implementers and it is not intended to be used directly from your code.">Fournit un <see cref="T:System.Dynamic.DynamicMetaObject" /> qui distribue aux méthodes virtuelles dynamiques. L'objet peut être encapsulé dans un autre <see cref="T:System.Dynamic.DynamicMetaObject" /> pour définir un comportement personnalisé pour des actions individuelles. Cette méthode prend en charge l'infrastructure Dynamic Language Runtime pour les implémenteurs de langage et n'est pas conçue pour être utilisée directement dans votre code.</summary>
      <param name="parameter" vsli:raw="The expression that represents &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; to dispatch to the dynamic virtual methods.">Expression qui représente le <see cref="T:System.Dynamic.DynamicMetaObject" /> à distribuer aux méthodes virtuelles dynamiques.</param>
      <returns vsli:raw="An object of the &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; type.">Objet de type <see cref="T:System.Dynamic.DynamicMetaObject" />.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
      <summary vsli:raw="Provides implementation for binary operations. Classes derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class can override this method to specify dynamic behavior for operations such as addition and multiplication.">Fournit une implémentation pour les opérations binaires. Les classes dérivées de la classe <see cref="T:System.Dynamic.DynamicObject" /> peuvent substituer cette méthode afin de spécifier le comportement dynamique pour certaines opérations telles que l'addition et la multiplication.</summary>
      <param name="binder" vsli:raw="Provides information about the binary operation. The &lt;c&gt;binder.Operation&lt;/c&gt; property returns an &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; object. For example, for the &lt;c&gt;sum = first + second&lt;/c&gt; statement, where &lt;c&gt;first&lt;/c&gt; and &lt;c&gt;second&lt;/c&gt; are derived from the &lt;see langword=&quot;DynamicObject&quot; /&gt; class, &lt;c&gt;binder.Operation&lt;/c&gt; returns &lt;c&gt;ExpressionType.Add&lt;/c&gt;.">Fournit des informations sur l'opération binaire. La propriété <c>binder.Operation</c> retourne un objet <see cref="T:System.Linq.Expressions.ExpressionType" />. Par exemple, pour l’instruction <c>sum = first + second</c>, où <c>first</c> et <c>second</c> sont dérivés de la classe <see langword="DynamicObject" />, <c>binder.Operation</c> retourne <c>ExpressionType.Add</c>.</param>
      <param name="arg" vsli:raw="The right operand for the binary operation. For example, for the &lt;c&gt;sum = first + second&lt;/c&gt; statement, where &lt;c&gt;first&lt;/c&gt; and &lt;c&gt;second&lt;/c&gt; are derived from the &lt;see langword=&quot;DynamicObject&quot; /&gt; class, &lt;paramref name=&quot;arg&quot; /&gt; is equal to &lt;c&gt;second&lt;/c&gt;.">Opérande droit pour l'opération binaire. Par exemple, pour l’instruction <c>sum = first + second</c>, où <c>first</c> et <c>second</c> sont dérivés de la classe <see langword="DynamicObject" />, <paramref name="arg" /> est égal à <c>second</c>.</param>
      <param name="result" vsli:raw="The result of the binary operation.">Résultat de l'opération binaire.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operation is successful; otherwise, &lt;see langword=&quot;false&quot; /&gt;. If this method returns &lt;see langword=&quot;false&quot; /&gt;, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.)">
        <see langword="true" /> si l'opération réussit ; sinon <see langword="false" />. Si cette méthode retourne <see langword="false" />, le binder d'exécution du langage détermine le comportement. (Dans la plupart des cas, une exception runtime spécifique au langage est levée.)</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
      <summary vsli:raw="Provides implementation for type conversion operations. Classes derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class can override this method to specify dynamic behavior for operations that convert an object from one type to another.">Fournit l'implémentation pour les opérations de conversion de type. Les classes dérivées de la classe <see cref="T:System.Dynamic.DynamicObject" /> peuvent substituer cette méthode pour spécifier le comportement dynamique pour certaines opérations qui convertissent un objet d'un type en un autre.</summary>
      <param name="binder" vsli:raw="Provides information about the conversion operation. The &lt;c&gt;binder.Type&lt;/c&gt; property provides the type to which the object must be converted. For example, for the statement &lt;c&gt;(String)sampleObject&lt;/c&gt; in C# (&lt;c&gt;CType(sampleObject, Type)&lt;/c&gt; in Visual Basic), where &lt;c&gt;sampleObject&lt;/c&gt; is an instance of the class derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class, &lt;c&gt;binder.Type&lt;/c&gt; returns the &lt;see cref=&quot;T:System.String&quot; /&gt; type. The &lt;c&gt;binder.Explicit&lt;/c&gt; property provides information about the kind of conversion that occurs. It returns &lt;see langword=&quot;true&quot; /&gt; for explicit conversion and &lt;see langword=&quot;false&quot; /&gt; for implicit conversion.">Fournit des informations sur l'opération de conversion. La propriété <c>binder.Type</c> fournit le type dans lequel l’objet doit être converti. Par exemple, pour l’instruction <c>(String)sampleObject</c> en C# (<c>CType(sampleObject, Type)</c> en Visual Basic), où <c>sampleObject</c> est une instance de la classe dérivée de la classe <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Type</c> retourne le type <see cref="T:System.String" />. La propriété <c>binder.Explicit</c> fournit des informations sur le genre de conversion qui se produit. Elle retourne la valeur <see langword="true" /> pour la conversion explicite et la valeur <see langword="false" /> pour la conversion implicite.</param>
      <param name="result" vsli:raw="The result of the type conversion operation.">Résultat de l'opération de conversion de type.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operation is successful; otherwise, &lt;see langword=&quot;false&quot; /&gt;. If this method returns &lt;see langword=&quot;false&quot; /&gt;, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.)">
        <see langword="true" /> si l'opération réussit ; sinon <see langword="false" />. Si cette méthode retourne <see langword="false" />, le binder d'exécution du langage détermine le comportement. (Dans la plupart des cas, une exception runtime spécifique au langage est levée.)</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)">
      <summary vsli:raw="Provides the implementation for operations that initialize a new instance of a dynamic object. This method is not intended for use in C# or Visual Basic.">Fournit l'implémentation pour les opérations qui initialisent une nouvelle instance d'un objet dynamique. Cette méthode n'est pas destinée à être utilisée en C# ou en Visual Basic.</summary>
      <param name="binder" vsli:raw="Provides information about the initialization operation.">Fournit des informations sur l'opération d'initialisation.</param>
      <param name="args" vsli:raw="The arguments that are passed to the object during initialization. For example, for the &lt;c&gt;new SampleType(100)&lt;/c&gt; operation, where &lt;c&gt;SampleType&lt;/c&gt; is the type derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class, &lt;c&gt;args[0]&lt;/c&gt; is equal to 100.">Arguments passés à l'objet pendant l'initialisation. Par exemple, pour l’opération <c>new SampleType(100)</c>, où <c>SampleType</c> est le type dérivé la classe <see cref="T:System.Dynamic.DynamicObject" />, <c>args[0]</c> est égal à 100.</param>
      <param name="result" vsli:raw="The result of the initialization.">Résultat de l'initialisation.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operation is successful; otherwise, &lt;see langword=&quot;false&quot; /&gt;. If this method returns &lt;see langword=&quot;false&quot; /&gt;, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.)">
        <see langword="true" /> si l'opération réussit ; sinon <see langword="false" />. Si cette méthode retourne <see langword="false" />, le binder d'exécution du langage détermine le comportement. (Dans la plupart des cas, une exception runtime spécifique au langage est levée.)</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Object[])">
      <summary vsli:raw="Provides the implementation for operations that delete an object by index. This method is not intended for use in C# or Visual Basic.">Fournit l'implémentation pour les opérations qui suppriment un objet par index. Cette méthode n'est pas destinée à être utilisée en C# ou en Visual Basic.</summary>
      <param name="binder" vsli:raw="Provides information about the deletion.">Fournit des informations sur la suppression.</param>
      <param name="indexes" vsli:raw="The indexes to be deleted.">Index à supprimer.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operation is successful; otherwise, &lt;see langword=&quot;false&quot; /&gt;. If this method returns &lt;see langword=&quot;false&quot; /&gt;, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.)">
        <see langword="true" /> si l'opération réussit ; sinon <see langword="false" />. Si cette méthode retourne <see langword="false" />, le binder d'exécution du langage détermine le comportement. (Dans la plupart des cas, une exception runtime spécifique au langage est levée.)</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryDeleteMember(System.Dynamic.DeleteMemberBinder)">
      <summary vsli:raw="Provides the implementation for operations that delete an object member. This method is not intended for use in C# or Visual Basic.">Fournit l'implémentation pour les opérations qui suppriment un membre objet. Cette méthode n'est pas destinée à être utilisée en C# ou en Visual Basic.</summary>
      <param name="binder" vsli:raw="Provides information about the deletion.">Fournit des informations sur la suppression.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operation is successful; otherwise, &lt;see langword=&quot;false&quot; /&gt;. If this method returns &lt;see langword=&quot;false&quot; /&gt;, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.)">
        <see langword="true" /> si l'opération réussit ; sinon <see langword="false" />. Si cette méthode retourne <see langword="false" />, le binder d'exécution du langage détermine le comportement. (Dans la plupart des cas, une exception runtime spécifique au langage est levée.)</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)">
      <summary vsli:raw="Provides the implementation for operations that get a value by index. Classes derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class can override this method to specify dynamic behavior for indexing operations.">Fournit l'implémentation pour les opérations qui obtiennent une valeur par index. Les classes dérivées de la classe <see cref="T:System.Dynamic.DynamicObject" /> peuvent substituer cette méthode afin de spécifier le comportement dynamique pour les opérations d'indexation.</summary>
      <param name="binder" vsli:raw="Provides information about the operation.">Fournit des informations sur l'opération.</param>
      <param name="indexes" vsli:raw="The indexes that are used in the operation. For example, for the &lt;c&gt;sampleObject[3]&lt;/c&gt; operation in C# (&lt;c&gt;sampleObject(3)&lt;/c&gt; in Visual Basic), where &lt;c&gt;sampleObject&lt;/c&gt; is derived from the &lt;see langword=&quot;DynamicObject&quot; /&gt; class, &lt;c&gt;indexes[0]&lt;/c&gt; is equal to 3.">Index utilisés pendant l'opération. Par exemple, pour l’opération <c>sampleObject[3]</c> en C# (<c>sampleObject(3)</c> en Visual Basic), où <c>sampleObject</c> est dérivé de la classe <see langword="DynamicObject" />, <c>index[0]</c> est égal à 3.</param>
      <param name="result" vsli:raw="The result of the index operation.">Résultat de l'opération d'indexation.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operation is successful; otherwise, &lt;see langword=&quot;false&quot; /&gt;. If this method returns &lt;see langword=&quot;false&quot; /&gt;, the run-time binder of the language determines the behavior. (In most cases, a run-time exception is thrown.)">
        <see langword="true" /> si l'opération réussit ; sinon <see langword="false" />. Si cette méthode retourne <see langword="false" />, le binder d'exécution du langage détermine le comportement. (Dans la plupart des cas, une exception runtime est levée.)</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
      <summary vsli:raw="Provides the implementation for operations that get member values. Classes derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class can override this method to specify dynamic behavior for operations such as getting a value for a property.">Fournit l'implémentation pour les opérations qui obtiennent des valeurs de membre. Les classes dérivées de la classe <see cref="T:System.Dynamic.DynamicObject" /> peuvent substituer cette méthode afin de spécifier le comportement dynamique pour certaines opérations telles que l'obtention d'une valeur pour une propriété.</summary>
      <param name="binder" vsli:raw="Provides information about the object that called the dynamic operation. The &lt;c&gt;binder.Name&lt;/c&gt; property provides the name of the member on which the dynamic operation is performed. For example, for the &lt;c&gt;Console.WriteLine(sampleObject.SampleProperty)&lt;/c&gt; statement, where &lt;c&gt;sampleObject&lt;/c&gt; is an instance of the class derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class, &lt;c&gt;binder.Name&lt;/c&gt; returns &quot;SampleProperty&quot;. The &lt;c&gt;binder.IgnoreCase&lt;/c&gt; property specifies whether the member name is case-sensitive.">Fournit des informations sur l'objet qui a appelé l'opération dynamique. La propriété <c>binder.Name</c> fournit le nom du membre sur lequel l’opération dynamique est exécutée. Par exemple, pour l’instruction <c>console.WriteLine(sampleObject.SampleProperty)</c>, où <c>sampleObject</c> est une instance de la classe dérivée de la classe <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Name</c> retourne " SampleProperty ". La propriété <c>binder.IgnoreCase</c> spécifie si le nom du membre respecte la casse.</param>
      <param name="result" vsli:raw="The result of the get operation. For example, if the method is called for a property, you can assign the property value to &lt;paramref name=&quot;result&quot; /&gt;.">Résultat de l'opération d'extraction. Par exemple, si la méthode est appelée pour une propriété, vous pouvez assigner la valeur de la propriété à <paramref name="result" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operation is successful; otherwise, &lt;see langword=&quot;false&quot; /&gt;. If this method returns &lt;see langword=&quot;false&quot; /&gt;, the run-time binder of the language determines the behavior. (In most cases, a run-time exception is thrown.)">
        <see langword="true" /> si l'opération réussit ; sinon <see langword="false" />. Si cette méthode retourne <see langword="false" />, le binder d'exécution du langage détermine le comportement. (Dans la plupart des cas, une exception runtime est levée.)</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
      <summary vsli:raw="Provides the implementation for operations that invoke an object. Classes derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class can override this method to specify dynamic behavior for operations such as invoking an object or a delegate.">Fournit l'implémentation pour les opérations qui appellent un objet. Les classes dérivées de la classe <see cref="T:System.Dynamic.DynamicObject" /> peuvent substituer cette méthode afin de spécifier le comportement dynamique pour certaines opérations telles que l'appel d'un objet ou d'un délégué.</summary>
      <param name="binder" vsli:raw="Provides information about the invoke operation.">Fournit des informations sur l'opération d'appel.</param>
      <param name="args" vsli:raw="The arguments that are passed to the object during the invoke operation. For example, for the &lt;c&gt;sampleObject(100)&lt;/c&gt; operation, where &lt;c&gt;sampleObject&lt;/c&gt; is derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class, &lt;c&gt;args[0]&lt;/c&gt; is equal to 100.">Arguments passés à l'objet pendant l'opération d'appel. Par exemple, pour l’opération <c>sampleObject[100]</c>, où <c>sampleObject</c> est dérivé de la classe <see cref="T:System.Dynamic.DynamicObject" />, <c>args[0]</c> est égal à 100.</param>
      <param name="result" vsli:raw="The result of the object invocation.">Résultat de l'appel de l'objet.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operation is successful; otherwise, &lt;see langword=&quot;false&quot; /&gt;. If this method returns &lt;see langword=&quot;false&quot; /&gt;, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.">
        <see langword="true" /> si l'opération réussit ; sinon <see langword="false" />. Si cette méthode retourne <see langword="false" />, le binder d'exécution du langage détermine le comportement. (Dans la plupart des cas, une exception runtime spécifique au langage est levée.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
      <summary vsli:raw="Provides the implementation for operations that invoke a member. Classes derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class can override this method to specify dynamic behavior for operations such as calling a method.">Fournit l'implémentation pour les opérations qui appellent un membre. Les classes dérivées de la classe <see cref="T:System.Dynamic.DynamicObject" /> peuvent substituer cette méthode afin de spécifier le comportement dynamique pour certaines opérations telles que l'appel d'une méthode.</summary>
      <param name="binder" vsli:raw="Provides information about the dynamic operation. The &lt;c&gt;binder.Name&lt;/c&gt; property provides the name of the member on which the dynamic operation is performed. For example, for the statement &lt;c&gt;sampleObject.SampleMethod(100)&lt;/c&gt;, where &lt;c&gt;sampleObject&lt;/c&gt; is an instance of the class derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class, &lt;c&gt;binder.Name&lt;/c&gt; returns &quot;SampleMethod&quot;. The &lt;c&gt;binder.IgnoreCase&lt;/c&gt; property specifies whether the member name is case-sensitive.">Fournit des informations sur l'opération dynamique. La propriété <c>binder.Name</c> fournit le nom du membre sur lequel l’opération dynamique est exécutée. Par exemple, pour l’instruction <c>sampleObject.SampleMethod(100)</c>, où <c>sampleObject</c> est une instance de la classe dérivée de la classe <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Name</c> retourne " SampleMethod ". La propriété <c>binder.IgnoreCase</c> spécifie si le nom du membre respecte la casse.</param>
      <param name="args" vsli:raw="The arguments that are passed to the object member during the invoke operation. For example, for the statement &lt;c&gt;sampleObject.SampleMethod(100)&lt;/c&gt;, where &lt;c&gt;sampleObject&lt;/c&gt; is derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class, &lt;c&gt;args[0]&lt;/c&gt; is equal to 100.">Arguments passés au membre d'objet pendant l'opération d'appel. Par exemple, pour l’instruction <c>sampleObject.SampleMethod(100)</c>, où <c>sampleObject</c> est dérivé de la classe <see cref="T:System.Dynamic.DynamicObject" />, <c>args[0]</c> est égal à 100.</param>
      <param name="result" vsli:raw="The result of the member invocation.">Résultat de l'appel du membre.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operation is successful; otherwise, &lt;see langword=&quot;false&quot; /&gt;. If this method returns &lt;see langword=&quot;false&quot; /&gt;, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.)">
        <see langword="true" /> si l'opération réussit ; sinon <see langword="false" />. Si cette méthode retourne <see langword="false" />, le binder d'exécution du langage détermine le comportement. (Dans la plupart des cas, une exception runtime spécifique au langage est levée.)</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
      <summary vsli:raw="Provides the implementation for operations that set a value by index. Classes derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class can override this method to specify dynamic behavior for operations that access objects by a specified index.">Fournit l'implémentation pour les opérations qui définissent une valeur par index. Les classes dérivées de la classe <see cref="T:System.Dynamic.DynamicObject" /> peuvent substituer cette méthode pour spécifier le comportement dynamique pour certaines opérations qui accèdent aux objets par un index spécifié.</summary>
      <param name="binder" vsli:raw="Provides information about the operation.">Fournit des informations sur l'opération.</param>
      <param name="indexes" vsli:raw="The indexes that are used in the operation. For example, for the &lt;c&gt;sampleObject[3] = 10&lt;/c&gt; operation in C# (&lt;c&gt;sampleObject(3) = 10&lt;/c&gt; in Visual Basic), where &lt;c&gt;sampleObject&lt;/c&gt; is derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class, &lt;c&gt;indexes[0]&lt;/c&gt; is equal to 3.">Index utilisés pendant l'opération. Par exemple, pour l’opération <c>sampleObject[3] = 10</c> en C# (<c>sampleObject(3) = 10</c> en Visual Basic), où <c>sampleObject</c> est dérivé de la classe <see cref="T:System.Dynamic.DynamicObject" />, <c>index[0]</c> est égal à 3.</param>
      <param name="value" vsli:raw="The value to set to the object that has the specified index. For example, for the &lt;c&gt;sampleObject[3] = 10&lt;/c&gt; operation in C# (&lt;c&gt;sampleObject(3) = 10&lt;/c&gt; in Visual Basic), where &lt;c&gt;sampleObject&lt;/c&gt; is derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class, &lt;paramref name=&quot;value&quot; /&gt; is equal to 10.">Valeur à définir pour l'objet qui a l'index spécifié. Par exemple, pour l’opération <c>sampleObject[3] = 10</c> en C# (<c>sampleObject(3) = 10</c> en Visual Basic), où <c>sampleObject</c> est dérivé de la classe <see cref="T:System.Dynamic.DynamicObject" />, <paramref name="value" /> est égal à 10.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operation is successful; otherwise, &lt;see langword=&quot;false&quot; /&gt;. If this method returns &lt;see langword=&quot;false&quot; /&gt;, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.">
        <see langword="true" /> si l'opération réussit ; sinon <see langword="false" />. Si cette méthode retourne <see langword="false" />, le binder d'exécution du langage détermine le comportement. (Dans la plupart des cas, une exception runtime spécifique au langage est levée.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
      <summary vsli:raw="Provides the implementation for operations that set member values. Classes derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class can override this method to specify dynamic behavior for operations such as setting a value for a property.">Fournit l'implémentation pour les opérations qui définissent des valeurs de membre. Les classes dérivées de la classe <see cref="T:System.Dynamic.DynamicObject" /> peuvent substituer cette méthode afin de spécifier le comportement dynamique pour certaines opérations telles que la définition d'une valeur pour une propriété.</summary>
      <param name="binder" vsli:raw="Provides information about the object that called the dynamic operation. The &lt;c&gt;binder.Name&lt;/c&gt; property provides the name of the member to which the value is being assigned. For example, for the statement &lt;c&gt;sampleObject.SampleProperty = &quot;Test&quot;&lt;/c&gt;, where &lt;c&gt;sampleObject&lt;/c&gt; is an instance of the class derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class, &lt;c&gt;binder.Name&lt;/c&gt; returns &quot;SampleProperty&quot;. The &lt;c&gt;binder.IgnoreCase&lt;/c&gt; property specifies whether the member name is case-sensitive.">Fournit des informations sur l'objet qui a appelé l'opération dynamique. La propriété <c>binder.Name</c> fournit le nom du membre auquel la valeur est attribuée. Par exemple, pour l’instruction <c>sampleObject.SampleProperty = "Test"</c>, où <c>sampleObject</c> est une instance de la classe dérivée de la classe <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Name</c> retourne " SampleProperty ". La propriété <c>binder.IgnoreCase</c> spécifie si le nom du membre respecte la casse.</param>
      <param name="value" vsli:raw="The value to set to the member. For example, for &lt;c&gt;sampleObject.SampleProperty = &quot;Test&quot;&lt;/c&gt;, where &lt;c&gt;sampleObject&lt;/c&gt; is an instance of the class derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class, the &lt;paramref name=&quot;value&quot; /&gt; is &quot;Test&quot;.">Valeur à affecter au membre. Par exemple, pour <c>sampleObject.SampleProperty = "Test"</c>, où <c>sampleObject</c> est une instance de la classe dérivée de la classe <see cref="T:System.Dynamic.DynamicObject" />, <paramref name="value" /> est " Test ".</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operation is successful; otherwise, &lt;see langword=&quot;false&quot; /&gt;. If this method returns &lt;see langword=&quot;false&quot; /&gt;, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.)">
        <see langword="true" /> si l'opération réussit ; sinon <see langword="false" />. Si cette méthode retourne <see langword="false" />, le binder d'exécution du langage détermine le comportement. (Dans la plupart des cas, une exception runtime spécifique au langage est levée.)</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
      <summary vsli:raw="Provides implementation for unary operations. Classes derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class can override this method to specify dynamic behavior for operations such as negation, increment, or decrement.">Fournit l'implémentation pour les opérations unaires. Les classes dérivées de la classe <see cref="T:System.Dynamic.DynamicObject" /> peuvent substituer cette méthode afin de spécifier le comportement dynamique pour certaines opérations telles que la négation, l'incrémentation ou la décrémentation.</summary>
      <param name="binder" vsli:raw="Provides information about the unary operation. The &lt;c&gt;binder.Operation&lt;/c&gt; property returns an &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; object. For example, for the &lt;c&gt;negativeNumber = -number&lt;/c&gt; statement, where &lt;c&gt;number&lt;/c&gt; is derived from the &lt;see langword=&quot;DynamicObject&quot; /&gt; class, &lt;c&gt;binder.Operation&lt;/c&gt; returns &quot;Negate&quot;.">Fournit des informations sur l'opération unaire. La propriété <c>binder.Operation</c> retourne un objet <see cref="T:System.Linq.Expressions.ExpressionType" />. Par exemple, pour l’instruction <c>negativeNumber = -number</c>, où <c>number</c> est dérivé de la classe <see langword="DynamicObject" />, <c>binder.Operation</c> retourne "Negate".</param>
      <param name="result" vsli:raw="The result of the unary operation.">Résultat de l'opération unaire.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operation is successful; otherwise, &lt;see langword=&quot;false&quot; /&gt;. If this method returns &lt;see langword=&quot;false&quot; /&gt;, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.)">
        <see langword="true" /> si l'opération réussit ; sinon <see langword="false" />. Si cette méthode retourne <see langword="false" />, le binder d'exécution du langage détermine le comportement. (Dans la plupart des cas, une exception runtime spécifique au langage est levée.)</returns>
    </member>
    <member name="T:System.Dynamic.ExpandoObject">
      <summary vsli:raw="Represents an object whose members can be dynamically added and removed at run time.">Représente un objet dont les membres peuvent être ajoutés et supprimés de manière dynamique au moment de l'exécution.</summary>
    </member>
    <member name="M:System.Dynamic.ExpandoObject.#ctor">
      <summary vsli:raw="Initializes a new &lt;see langword=&quot;ExpandoObject&quot; /&gt; that does not have members.">Initialise un nouveau <see langword="ExpandoObject" /> qui n'a pas de membres.</summary>
    </member>
    <member name="M:System.Dynamic.ExpandoObject.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Retourne un énumérateur qui itère au sein de la collection.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; that can be used to iterate through the collection.">
        <see cref="T:System.Collections.IEnumerator" /> qui peut être utilisé pour itérer la collection.</returns>
    </member>
    <member name="E:System.Dynamic.ExpandoObject.System#ComponentModel#INotifyPropertyChanged#PropertyChanged">
      <summary vsli:raw="Occurs when a property value changes.">Se produit en cas de modification d'une valeur de propriété.</summary>
    </member>
    <member name="M:System.Dynamic.ExpandoObject.System#Dynamic#IDynamicMetaObjectProvider#GetMetaObject(System.Linq.Expressions.Expression)">
      <summary vsli:raw="The provided MetaObject will dispatch to the dynamic virtual methods. The object can be encapsulated inside another MetaObject to provide custom behavior for individual actions.">Le MetaObject fourni est distribué aux méthodes virtuelles dynamiques. L'objet peut être encapsulé dans un autre MetaObject pour définir un comportement personnalisé pour des actions individuelles.</summary>
      <param name="parameter" vsli:raw="The expression that represents the MetaObject to dispatch to the Dynamic virtual methods.">Expression qui représente le MetaObject à distribuer aux méthodes virtuelles dynamiques.</param>
      <returns vsli:raw="The object of the &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; type.">Objet de type <see cref="T:System.Dynamic.DynamicMetaObject" />.</returns>
    </member>
    <member name="T:System.Dynamic.GetIndexBinder">
      <summary vsli:raw="Represents the dynamic get index operation at the call site, providing the binding semantic and the details about the operation.">Représente l'opération d'obtention d'index dynamique au site d'appel, en fournissant la sémantique de liaison et les détails de l'opération.</summary>
    </member>
    <member name="M:System.Dynamic.GetIndexBinder.#ctor(System.Dynamic.CallInfo)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Dynamic.GetIndexBinder&quot; /&gt;.">Initialise une nouvelle instance de l'objet <see cref="T:System.Dynamic.GetIndexBinder" />.</summary>
      <param name="callInfo" vsli:raw="The signature of the arguments at the call site.">Signature des arguments au niveau du site d’appel.</param>
    </member>
    <member name="M:System.Dynamic.GetIndexBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic get index operation.">Exécute la liaison de l'opération d'obtention d'index dynamique.</summary>
      <param name="target" vsli:raw="The target of the dynamic get index operation.">Cible de l'opération d'obtention d'index dynamique.</param>
      <param name="args" vsli:raw="An array of arguments of the dynamic get index operation.">Tableau d'arguments de l'opération d'obtention d'index dynamique.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="P:System.Dynamic.GetIndexBinder.CallInfo">
      <summary vsli:raw="Gets the signature of the arguments at the call site.">Obtient la signature des arguments au niveau du site d’appel.</summary>
      <returns vsli:raw="The signature of the arguments at the call site.">Signature des arguments au niveau du site d’appel.</returns>
    </member>
    <member name="M:System.Dynamic.GetIndexBinder.FallbackGetIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic get index operation if the target dynamic object cannot bind.">Effectue la liaison de l'opération d'obtention d'index dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <param name="target" vsli:raw="The target of the dynamic get index operation.">Cible de l'opération d'obtention d'index dynamique.</param>
      <param name="indexes" vsli:raw="The arguments of the dynamic get index operation.">Arguments de l'opération d'obtention d'index dynamique.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.GetIndexBinder.FallbackGetIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="When overridden in the derived class, performs the binding of the dynamic get index operation if the target dynamic object cannot bind.">En cas de substitution dans la classe dérivée, exécute la liaison de l'opération d'obtention d'index dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <param name="target" vsli:raw="The target of the dynamic get index operation.">Cible de l'opération d'obtention d'index dynamique.</param>
      <param name="indexes" vsli:raw="The arguments of the dynamic get index operation.">Arguments de l'opération d'obtention d'index dynamique.</param>
      <param name="errorSuggestion" vsli:raw="The binding result to use if binding fails, or null.">Résultat de liaison à utiliser si la liaison échoue, ou Null.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="P:System.Dynamic.GetIndexBinder.ReturnType">
      <summary vsli:raw="The result type of the operation.">Type de résultat de l'opération.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the result type of the operation.">Objet <see cref="T:System.Type" /> représentant le type de résultat de l'opération.</returns>
    </member>
    <member name="T:System.Dynamic.GetMemberBinder">
      <summary vsli:raw="Represents the dynamic get member operation at the call site, providing the binding semantic and the details about the operation.">Représente l'opération d'obtention de membre dynamique au site d'appel, en fournissant la sémantique de liaison et les détails de l'opération.</summary>
    </member>
    <member name="M:System.Dynamic.GetMemberBinder.#ctor(System.String,System.Boolean)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Dynamic.GetMemberBinder&quot; /&gt;.">Initialise une nouvelle instance de l'objet <see cref="T:System.Dynamic.GetMemberBinder" />.</summary>
      <param name="name" vsli:raw="The name of the member to obtain.">Nom du membre à obtenir.</param>
      <param name="ignoreCase" vsli:raw="Is true if the name should be matched ignoring case; false otherwise.">True si la correspondance avec le nom doit ignorer la casse ; sinon, False.</param>
    </member>
    <member name="M:System.Dynamic.GetMemberBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic get member operation.">Exécute la liaison de l'opération d'obtention de membre dynamique.</summary>
      <param name="target" vsli:raw="The target of the dynamic get member operation.">Cible de l'opération d'obtention de membre dynamique.</param>
      <param name="args" vsli:raw="An array of arguments of the dynamic get member operation.">Tableau d'arguments de l'opération d'obtention de membre dynamique.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.GetMemberBinder.FallbackGetMember(System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="Performs the binding of the dynamic get member operation if the target dynamic object cannot bind.">Effectue la liaison de l'opération d'obtention de membre dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <param name="target" vsli:raw="The target of the dynamic get member operation.">Cible de l'opération d'obtention de membre dynamique.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.GetMemberBinder.FallbackGetMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="When overridden in the derived class, performs the binding of the dynamic get member operation if the target dynamic object cannot bind.">En cas de substitution dans la classe dérivée, exécute la liaison de l'opération d'obtention de membre dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <param name="target" vsli:raw="The target of the dynamic get member operation.">Cible de l'opération d'obtention de membre dynamique.</param>
      <param name="errorSuggestion" vsli:raw="The binding result to use if binding fails, or null.">Résultat de liaison à utiliser si la liaison échoue, ou Null.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="P:System.Dynamic.GetMemberBinder.IgnoreCase">
      <summary vsli:raw="Gets the value indicating if the string comparison should ignore the case of the member name.">Obtient la valeur indiquant si la comparaison de chaîne doit ignorer la casse du nom du membre.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if case is ignored; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />Si la casse est ignorée; Sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Dynamic.GetMemberBinder.Name">
      <summary vsli:raw="Gets the name of the member to obtain.">Obtient le nom du membre à obtenir.</summary>
      <returns vsli:raw="The name of the member to obtain.">Nom du membre à obtenir.</returns>
    </member>
    <member name="P:System.Dynamic.GetMemberBinder.ReturnType">
      <summary vsli:raw="The result type of the operation.">Type de résultat de l'opération.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the result type of the operation.">Objet <see cref="T:System.Type" /> représentant le type de résultat de l'opération.</returns>
    </member>
    <member name="T:System.Dynamic.IDynamicMetaObjectProvider">
      <summary vsli:raw="Represents a dynamic object, that can have its operations bound at runtime.">Représente un objet dynamique, dont les opérations peuvent être liées pendant l'exécution.</summary>
    </member>
    <member name="M:System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Returns the &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; responsible for binding operations performed on this object.">Retourne le <see cref="T:System.Dynamic.DynamicMetaObject" /> responsable de la liaison des opérations effectuées sur cet objet.</summary>
      <param name="parameter" vsli:raw="The expression tree representation of the runtime value.">Représentation de l'arborescence de l'expression de la valeur d'exécution.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; to bind this object.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> à lier à cet objet.</returns>
    </member>
    <member name="T:System.Dynamic.IInvokeOnGetBinder">
      <summary vsli:raw="Represents information about a dynamic get member operation that indicates if the get member should invoke properties when they perform the get operation.">Représente les informations relatives à une opération d'obtention de membre dynamique qui indique si l'obtention de membre doit appeler des propriétés lorsqu'elles exécutent l'opération d'extraction.</summary>
    </member>
    <member name="P:System.Dynamic.IInvokeOnGetBinder.InvokeOnGet">
      <summary vsli:raw="Gets the value indicating if this get member operation should invoke properties when they perform the get operation. The default value when this interface is not present is true.">Obtient la valeur indiquant si cette opération d'obtention de membre doit appeler des propriétés lorsqu'elles exécutent l'opération d'extraction. La valeur par défaut lorsque cette interface n'est pas présente est True.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if this get member operation should invoke properties when they perform the get operation; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />Si cette opération d’extraction de membre doit appeler des propriétés lorsqu’elles exécutent l’opération d’extraction; Sinon, <see langword="false" />.</returns>
    </member>
    <member name="T:System.Dynamic.InvokeBinder">
      <summary vsli:raw="Represents the invoke dynamic operation at the call site, providing the binding semantic and the details about the operation.">Représente l'opération d'appel dynamique au site d'appel, en fournissant la sémantique de liaison et les détails de l'opération.</summary>
    </member>
    <member name="M:System.Dynamic.InvokeBinder.#ctor(System.Dynamic.CallInfo)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Dynamic.InvokeBinder&quot; /&gt;.">Initialise une nouvelle instance de l'objet <see cref="T:System.Dynamic.InvokeBinder" />.</summary>
      <param name="callInfo" vsli:raw="The signature of the arguments at the call site.">Signature des arguments au niveau du site d’appel.</param>
    </member>
    <member name="M:System.Dynamic.InvokeBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic invoke operation.">Effectue la liaison de l’opération d’appel dynamique.</summary>
      <param name="target" vsli:raw="The target of the dynamic invoke operation.">Cible de l’opération d’appel dynamique.</param>
      <param name="args" vsli:raw="An array of arguments of the dynamic invoke operation.">Tableau d’arguments de l’opération d’appel dynamique.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="P:System.Dynamic.InvokeBinder.CallInfo">
      <summary vsli:raw="Gets the signature of the arguments at the call site.">Obtient la signature des arguments au niveau du site d’appel.</summary>
      <returns vsli:raw="The signature of the arguments at the call site.">Signature des arguments au niveau du site d’appel.</returns>
    </member>
    <member name="M:System.Dynamic.InvokeBinder.FallbackInvoke(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic invoke operation if the target dynamic object cannot bind.">Effectue la liaison de l'opération d'appel dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <param name="target" vsli:raw="The target of the dynamic invoke operation.">Cible de l’opération d’appel dynamique.</param>
      <param name="args" vsli:raw="The arguments of the dynamic invoke operation.">Arguments de l'opération d'appel dynamique.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.InvokeBinder.FallbackInvoke(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="Performs the binding of the dynamic invoke operation if the target dynamic object cannot bind.">Effectue la liaison de l'opération d'appel dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <param name="target" vsli:raw="The target of the dynamic invoke operation.">Cible de l’opération d’appel dynamique.</param>
      <param name="args" vsli:raw="The arguments of the dynamic invoke operation.">Arguments de l'opération d'appel dynamique.</param>
      <param name="errorSuggestion" vsli:raw="The binding result to use if binding fails, or null.">Résultat de liaison à utiliser si la liaison échoue, ou Null.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="P:System.Dynamic.InvokeBinder.ReturnType">
      <summary vsli:raw="The result type of the operation.">Type de résultat de l'opération.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the result type of the operation.">Objet <see cref="T:System.Type" /> représentant le type de résultat de l'opération.</returns>
    </member>
    <member name="T:System.Dynamic.InvokeMemberBinder">
      <summary vsli:raw="Represents the invoke member dynamic operation at the call site, providing the binding semantic and the details about the operation.">Représente l'opération d'appel de membre dynamique au site d'appel, en fournissant la sémantique de liaison et les détails de l'opération.</summary>
    </member>
    <member name="M:System.Dynamic.InvokeMemberBinder.#ctor(System.String,System.Boolean,System.Dynamic.CallInfo)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Dynamic.InvokeMemberBinder&quot; /&gt;.">Initialise une nouvelle instance de l'objet <see cref="T:System.Dynamic.InvokeMemberBinder" />.</summary>
      <param name="name" vsli:raw="The name of the member to invoke.">Nom du membre à appeler.</param>
      <param name="ignoreCase" vsli:raw="true if the name should be matched ignoring case; false otherwise.">True si la correspondance avec le nom doit ignorer la casse ; sinon, false.</param>
      <param name="callInfo" vsli:raw="The signature of the arguments at the call site.">Signature des arguments au niveau du site d’appel.</param>
    </member>
    <member name="M:System.Dynamic.InvokeMemberBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic invoke member operation.">Exécute la liaison de l'opération d'appel de membre dynamique.</summary>
      <param name="target" vsli:raw="The target of the dynamic invoke member operation.">Cible de l'opération d'appel de membre dynamique.</param>
      <param name="args" vsli:raw="An array of arguments of the dynamic invoke member operation.">Tableau d'arguments de l'opération d'appel de membre dynamique.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="P:System.Dynamic.InvokeMemberBinder.CallInfo">
      <summary vsli:raw="Gets the signature of the arguments at the call site.">Obtient la signature des arguments au niveau du site d’appel.</summary>
      <returns vsli:raw="The signature of the arguments at the call site.">Signature des arguments au niveau du site d’appel.</returns>
    </member>
    <member name="M:System.Dynamic.InvokeMemberBinder.FallbackInvoke(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="When overridden in the derived class, performs the binding of the dynamic invoke operation if the target dynamic object cannot bind.">En cas de substitution dans la classe dérivée, exécute la liaison de l'opération d'appel dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <param name="target" vsli:raw="The target of the dynamic invoke operation.">Cible de l’opération d’appel dynamique.</param>
      <param name="args" vsli:raw="The arguments of the dynamic invoke operation.">Arguments de l'opération d'appel dynamique.</param>
      <param name="errorSuggestion" vsli:raw="The binding result to use if binding fails, or null.">Résultat de liaison à utiliser si la liaison échoue, ou Null.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.InvokeMemberBinder.FallbackInvokeMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic invoke member operation if the target dynamic object cannot bind.">Effectue la liaison de l'opération d'appel de membre dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <param name="target" vsli:raw="The target of the dynamic invoke member operation.">Cible de l'opération d'appel de membre dynamique.</param>
      <param name="args" vsli:raw="The arguments of the dynamic invoke member operation.">Arguments de l'opération d'appel de membre dynamique.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.InvokeMemberBinder.FallbackInvokeMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="When overridden in the derived class, performs the binding of the dynamic invoke member operation if the target dynamic object cannot bind.">En cas de substitution dans la classe dérivée, exécute la liaison de l'opération d'appel de membre dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <param name="target" vsli:raw="The target of the dynamic invoke member operation.">Cible de l'opération d'appel de membre dynamique.</param>
      <param name="args" vsli:raw="The arguments of the dynamic invoke member operation.">Arguments de l'opération d'appel de membre dynamique.</param>
      <param name="errorSuggestion" vsli:raw="The binding result to use if binding fails, or null.">Résultat de liaison à utiliser si la liaison échoue, ou Null.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="P:System.Dynamic.InvokeMemberBinder.IgnoreCase">
      <summary vsli:raw="Gets the value indicating if the string comparison should ignore the case of the member name.">Obtient la valeur indiquant si la comparaison de chaîne doit ignorer la casse du nom du membre.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if case is ignored; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />Si la casse est ignorée; Sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Dynamic.InvokeMemberBinder.Name">
      <summary vsli:raw="Gets the name of the member to invoke.">Obtient le nom du membre à appeler.</summary>
      <returns vsli:raw="The name of the member to invoke.">Nom du membre à appeler.</returns>
    </member>
    <member name="P:System.Dynamic.InvokeMemberBinder.ReturnType">
      <summary vsli:raw="The result type of the operation.">Type de résultat de l'opération.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the result type of the operation.">Objet <see cref="T:System.Type" /> représentant le type de résultat de l'opération.</returns>
    </member>
    <member name="T:System.Dynamic.SetIndexBinder">
      <summary vsli:raw="Represents the dynamic set index operation at the call site, providing the binding semantic and the details about the operation.">Représente l'opération de définition d'index dynamique au site d'appel, en fournissant la sémantique de liaison et les détails de l'opération.</summary>
    </member>
    <member name="M:System.Dynamic.SetIndexBinder.#ctor(System.Dynamic.CallInfo)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Dynamic.SetIndexBinder&quot; /&gt;.">Initialise une nouvelle instance de l'objet <see cref="T:System.Dynamic.SetIndexBinder" />.</summary>
      <param name="callInfo" vsli:raw="The signature of the arguments at the call site.">Signature des arguments au niveau du site d’appel.</param>
    </member>
    <member name="M:System.Dynamic.SetIndexBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic set index operation.">Exécute la liaison de l'opération de définition d'index dynamique.</summary>
      <param name="target" vsli:raw="The target of the dynamic set index operation.">Cible de l'opération de définition d'index dynamique.</param>
      <param name="args" vsli:raw="An array of arguments of the dynamic set index operation.">Tableau d'arguments de l'opération de définition d'index dynamique.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="P:System.Dynamic.SetIndexBinder.CallInfo">
      <summary vsli:raw="Gets the signature of the arguments at the call site.">Obtient la signature des arguments au niveau du site d’appel.</summary>
      <returns vsli:raw="The signature of the arguments at the call site.">Signature des arguments au niveau du site d’appel.</returns>
    </member>
    <member name="M:System.Dynamic.SetIndexBinder.FallbackSetIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="Performs the binding of the dynamic set index operation if the target dynamic object cannot bind.">Effectue la liaison de l'opération de définition d'index dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <param name="target" vsli:raw="The target of the dynamic set index operation.">Cible de l'opération de définition d'index dynamique.</param>
      <param name="indexes" vsli:raw="The arguments of the dynamic set index operation.">Arguments de l'opération de définition d'index dynamique.</param>
      <param name="value" vsli:raw="The value to set to the collection.">Valeur à affecter à la collection.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.SetIndexBinder.FallbackSetIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="When overridden in the derived class, performs the binding of the dynamic set index operation if the target dynamic object cannot bind.">En cas de substitution dans la classe dérivée, exécute la liaison de l'opération de définition d'index dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <param name="target" vsli:raw="The target of the dynamic set index operation.">Cible de l'opération de définition d'index dynamique.</param>
      <param name="indexes" vsli:raw="The arguments of the dynamic set index operation.">Arguments de l'opération de définition d'index dynamique.</param>
      <param name="value" vsli:raw="The value to set to the collection.">Valeur à affecter à la collection.</param>
      <param name="errorSuggestion" vsli:raw="The binding result to use if binding fails, or null.">Résultat de liaison à utiliser si la liaison échoue, ou Null.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="P:System.Dynamic.SetIndexBinder.ReturnType">
      <summary vsli:raw="The result type of the operation.">Type de résultat de l'opération.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the result type of the operation.">Objet <see cref="T:System.Type" /> représentant le type de résultat de l'opération.</returns>
    </member>
    <member name="T:System.Dynamic.SetMemberBinder">
      <summary vsli:raw="Represents the dynamic set member operation at the call site, providing the binding semantic and the details about the operation.">Représente l’opération dynamique de définition de membre sur le site d’appel, en fournissant la sémantique de liaison et les détails de l’opération.</summary>
    </member>
    <member name="M:System.Dynamic.SetMemberBinder.#ctor(System.String,System.Boolean)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Dynamic.SetMemberBinder&quot; /&gt;.">Initialise une nouvelle instance de l'objet <see cref="T:System.Dynamic.SetMemberBinder" />.</summary>
      <param name="name" vsli:raw="The name of the member to obtain.">Nom du membre à obtenir.</param>
      <param name="ignoreCase" vsli:raw="Is true if the name should be matched ignoring case; false otherwise.">True si la correspondance avec le nom doit ignorer la casse ; sinon, False.</param>
    </member>
    <member name="M:System.Dynamic.SetMemberBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic set member operation.">Exécute la liaison de l'opération de définition de membre dynamique.</summary>
      <param name="target" vsli:raw="The target of the dynamic set member operation.">Cible de l'opération de définition de membre dynamique.</param>
      <param name="args" vsli:raw="An array of arguments of the dynamic set member operation.">Tableau d'arguments de l'opération de définition de membre dynamique.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.SetMemberBinder.FallbackSetMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="Performs the binding of the dynamic set member operation if the target dynamic object cannot bind.">Effectue la liaison de l'opération de définition de membre dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <param name="target" vsli:raw="The target of the dynamic set member operation.">Cible de l'opération de définition de membre dynamique.</param>
      <param name="value" vsli:raw="The value to set to the member.">Valeur à affecter au membre.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.SetMemberBinder.FallbackSetMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="Performs the binding of the dynamic set member operation if the target dynamic object cannot bind.">Effectue la liaison de l'opération de définition de membre dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <param name="target" vsli:raw="The target of the dynamic set member operation.">Cible de l'opération de définition de membre dynamique.</param>
      <param name="value" vsli:raw="The value to set to the member.">Valeur à affecter au membre.</param>
      <param name="errorSuggestion" vsli:raw="The binding result to use if binding fails, or null.">Résultat de la liaison à utiliser si la liaison échoue, ou null.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="P:System.Dynamic.SetMemberBinder.IgnoreCase">
      <summary vsli:raw="Gets the value indicating if the string comparison should ignore the case of the member name.">Obtient la valeur indiquant si la comparaison de chaîne doit ignorer la casse du nom du membre.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if case is ignored; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />Si la casse est ignorée; Sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Dynamic.SetMemberBinder.Name">
      <summary vsli:raw="Gets the name of the member to obtain.">Obtient le nom du membre à obtenir.</summary>
      <returns vsli:raw="The name of the member to obtain.">Nom du membre à obtenir.</returns>
    </member>
    <member name="P:System.Dynamic.SetMemberBinder.ReturnType">
      <summary vsli:raw="The result type of the operation.">Type de résultat de l'opération.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the result type of the operation.">Objet <see cref="T:System.Type" /> représentant le type de résultat de l'opération.</returns>
    </member>
    <member name="T:System.Dynamic.UnaryOperationBinder">
      <summary vsli:raw="Represents the unary dynamic operation at the call site, providing the binding semantic and the details about the operation.">Représente l'opération dynamique unaire au site d'appel, en fournissant la sémantique de liaison et les détails de l'opération.</summary>
    </member>
    <member name="M:System.Dynamic.UnaryOperationBinder.#ctor(System.Linq.Expressions.ExpressionType)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Dynamic.BinaryOperationBinder&quot; /&gt; class.">Initialise une nouvelle instance de la classe <see cref="T:System.Dynamic.BinaryOperationBinder" />.</summary>
      <param name="operation" vsli:raw="The unary operation kind.">Type d'opération unaire.</param>
    </member>
    <member name="M:System.Dynamic.UnaryOperationBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic unary operation.">Exécute la liaison de l'opération unaire dynamique.</summary>
      <param name="target" vsli:raw="The target of the dynamic operation.">Cible de l'opération dynamique.</param>
      <param name="args" vsli:raw="An array of arguments of the dynamic operation.">Tableau d'arguments de l'opération dynamique.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.UnaryOperationBinder.FallbackUnaryOperation(System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="Performs the binding of the unary dynamic operation if the target dynamic object cannot bind.">Effectue la liaison de l'opération dynamique unaire si l'objet dynamique cible ne peut pas être lié.</summary>
      <param name="target" vsli:raw="The target of the dynamic unary operation.">Cible de l'opération unaire dynamique.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.UnaryOperationBinder.FallbackUnaryOperation(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="Performs the binding of the unary dynamic operation if the target dynamic object cannot bind.">Effectue la liaison de l'opération dynamique unaire si l'objet dynamique cible ne peut pas être lié.</summary>
      <param name="target" vsli:raw="The target of the dynamic unary operation.">Cible de l'opération unaire dynamique.</param>
      <param name="errorSuggestion" vsli:raw="The binding result in case the binding fails, or null.">Résultat de la liaison en cas d'échec, ou null.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="P:System.Dynamic.UnaryOperationBinder.Operation">
      <summary vsli:raw="The unary operation kind.">Type d'opération unaire.</summary>
      <returns vsli:raw="The object of the &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that represents the unary operation kind.">Objet de <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente le type d'opération unaire.</returns>
    </member>
    <member name="P:System.Dynamic.UnaryOperationBinder.ReturnType">
      <summary vsli:raw="The result type of the operation.">Type de résultat de l'opération.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the result type of the operation.">Objet <see cref="T:System.Type" /> représentant le type de résultat de l'opération.</returns>
    </member>
    <member name="T:System.Linq.Expressions.BinaryExpression">
      <summary vsli:raw="Represents an expression that has a binary operator.">Représente une expression qui comporte un opérateur binaire.</summary>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary vsli:raw="Dispatches to the specific visit method for this node type. For example, &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; calls the &lt;see cref=&quot;M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)&quot; /&gt;.">Distribue à la méthode de visite spécifique à ce type de nœud. Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor" vsli:raw="The visitor to visit this node with.">Visiteur avec lequel visiter ce nœud.</param>
      <returns vsli:raw="The result of visiting this node.">Résultat de la visite de ce nœud.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.CanReduce">
      <summary vsli:raw="Gets a value that indicates whether the expression tree node can be reduced.">Obtient une valeur qui indique si le nœud d’arborescence de l’expression peut être réduit.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the expression tree node can be reduced; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />Si le nœud d’arborescence d’expression peut être réduit; Sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Conversion">
      <summary vsli:raw="Gets the type conversion function that is used by a coalescing or compound assignment operation.">Obtient la fonction de conversion de type utilisée par une opération de fusion ou d’assignation composée.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; that represents a type conversion function.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> qui représente une fonction de conversion de type.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.IsLifted">
      <summary vsli:raw="Gets a value that indicates whether the expression tree node represents a lifted call to an operator.">Obtient une valeur qui indique si le nœud d’arborescence de l’expression représente un appel levé vers un opérateur.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the node represents a lifted call; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si le nœud représente un appel levé ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull">
      <summary vsli:raw="Gets a value that indicates whether the expression tree node represents a lifted call to an operator whose return type is lifted to a nullable type.">Obtient une valeur qui indique si le nœud d’arborescence de l’expression représente un appel levé vers un opérateur dont le type de retour est levé vers un type nullable.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operator's return type is lifted to a nullable type; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si le type de retour de l'opérateur est levé vers un type nullable ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Left">
      <summary vsli:raw="Gets the left operand of the binary operation.">Obtient l’opérande gauche de l’opération binaire.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the left operand of the binary operation.">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande gauche de l'opération binaire.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Method">
      <summary vsli:raw="Gets the implementing method for the binary operation.">Obtient la méthode d’implémentation pour l’opération binaire.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the implementing method.">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Reduce">
      <summary vsli:raw="Reduces the binary expression node to a simpler expression.">Réduit le nœud d’expression binaire en une expression plus simple.</summary>
      <returns vsli:raw="The reduced expression.">Expression réduite.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Right">
      <summary vsli:raw="Gets the right operand of the binary operation.">Obtient l’opérande droit de l’opération binaire.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the right operand of the binary operation.">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande droit de l'opération binaire.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Update(System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="left" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property of the result.">Propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> du résultat.</param>
      <param name="conversion" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; property of the result.">Propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> du résultat.</param>
      <param name="right" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property of the result.">Propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> du résultat.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="T:System.Linq.Expressions.BlockExpression">
      <summary vsli:raw="Represents a block that contains a sequence of expressions where variables can be defined.">Représente un bloc qui contient une séquence d'expressions où des variables peuvent être définies.</summary>
    </member>
    <member name="M:System.Linq.Expressions.BlockExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary vsli:raw="Dispatches to the specific visit method for this node type. For example, &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; calls the &lt;see cref=&quot;M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)&quot; /&gt;.">Distribue à la méthode de visite spécifique à ce type de nœud. Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor" vsli:raw="The visitor to visit this node with.">Visiteur avec lequel visiter ce nœud.</param>
      <returns vsli:raw="The result of visiting this node.">Résultat de la visite de ce nœud.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Expressions">
      <summary vsli:raw="Gets the expressions in this block.">Obtient les expressions contenues dans ce bloc.</summary>
      <returns vsli:raw="The read-only collection containing all the expressions in this block.">Collection en lecture seule qui contient toutes les expressions contenues dans ce bloc.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.NodeType">
      <summary vsli:raw="Returns the node type of this expression. Extension nodes should return &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Extension&quot; /&gt; when overriding this method.">Retourne le type de nœud de cette expression. Les nœuds d’extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; of the expression.">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Result">
      <summary vsli:raw="Gets the last expression in this block.">Obtient la dernière expression contenue dans ce bloc.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; object representing the last expression in this block.">Objet <see cref="T:System.Linq.Expressions.Expression" /> qui représente la dernière expression contenue dans ce bloc.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.BlockExpression.Type&quot; /&gt; that represents the static type of the expression.">
        <see cref="P:System.Linq.Expressions.BlockExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BlockExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="variables" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.BlockExpression.Variables&quot; /&gt; property of the result.">Propriété <see cref="P:System.Linq.Expressions.BlockExpression.Variables" /> du résultat.</param>
      <param name="expressions" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.BlockExpression.Expressions&quot; /&gt; property of the result.">Propriété <see cref="P:System.Linq.Expressions.BlockExpression.Expressions" /> du résultat.</param>
      <returns vsli:raw="This expression if no children changed, or an expression with the updated children.">Cette expression si aucun enfant n’est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Variables">
      <summary vsli:raw="Gets the variables defined in this block.">Obtient les variables définies dans ce bloc.</summary>
      <returns vsli:raw="The read-only collection containing all the variables defined in this block.">Collection en lecture seule qui contient toutes les variables définies dans ce bloc.</returns>
    </member>
    <member name="T:System.Linq.Expressions.CatchBlock">
      <summary vsli:raw="Represents a catch statement in a try block.">Représente une instruction catch dans un bloc try.</summary>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Body">
      <summary vsli:raw="Gets the body of the catch block.">Obtient le corps du bloc catch.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; object representing the catch body.">Objet <see cref="T:System.Linq.Expressions.Expression" /> représentant le corps du bloc catch.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Filter">
      <summary vsli:raw="Gets the body of the &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt; filter.">Obtient le corps du filtre <see cref="T:System.Linq.Expressions.CatchBlock" />.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; object representing the body of the &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt; filter.">Objet <see cref="T:System.Linq.Expressions.Expression" /> représentant le corps du filtre <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Test">
      <summary vsli:raw="Gets the type of &lt;see cref=&quot;T:System.Exception&quot; /&gt; this handler catches.">Obtient le type de <see cref="T:System.Exception" /> que ce gestionnaire intercepte.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the type of &lt;see cref=&quot;T:System.Exception&quot; /&gt; this handler catches.">Objet <see cref="T:System.Type" /> représentant le type de <see cref="T:System.Exception" /> que ce gestionnaire intercepte.</returns>
    </member>
    <member name="M:System.Linq.Expressions.CatchBlock.ToString">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.String&quot; /&gt; that represents the current &lt;see cref=&quot;T:System.Object&quot; /&gt;.">Retourne une <see cref="T:System.String" /> qui représente l'<see cref="T:System.Object" /> actuel.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.String&quot; /&gt; that represents the current &lt;see cref=&quot;T:System.Object&quot; /&gt;.">
        <see cref="T:System.String" /> qui représente le <see cref="T:System.Object" /> actuel.</returns>
    </member>
    <member name="M:System.Linq.Expressions.CatchBlock.Update(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="variable" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.CatchBlock.Variable&quot; /&gt; property of the result.">Propriété <see cref="P:System.Linq.Expressions.CatchBlock.Variable" /> du résultat.</param>
      <param name="filter" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.CatchBlock.Filter&quot; /&gt; property of the result.">Propriété <see cref="P:System.Linq.Expressions.CatchBlock.Filter" /> du résultat.</param>
      <param name="body" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.CatchBlock.Body&quot; /&gt; property of the result.">Propriété <see cref="P:System.Linq.Expressions.CatchBlock.Body" /> du résultat.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Variable">
      <summary vsli:raw="Gets a reference to the &lt;see cref=&quot;T:System.Exception&quot; /&gt; object caught by this handler.">Obtient une référence à l’objet <see cref="T:System.Exception" /> intercepté par ce gestionnaire.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; object representing a reference to the &lt;see cref=&quot;T:System.Exception&quot; /&gt; object caught by this handler.">Objet <see cref="T:System.Linq.Expressions.ParameterExpression" /> représentant une référence à l'objet <see cref="T:System.Exception" /> intercepté par ce gestionnaire.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ConditionalExpression">
      <summary vsli:raw="Represents an expression that has a conditional operator.">Représente une expression qui comporte un opérateur conditionnel.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ConditionalExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary vsli:raw="Dispatches to the specific visit method for this node type. For example, &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; calls the &lt;see cref=&quot;M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)&quot; /&gt;.">Distribue à la méthode de visite spécifique à ce type de nœud. Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor" vsli:raw="The visitor to visit this node with.">Visiteur avec lequel visiter ce nœud.</param>
      <returns vsli:raw="The result of visiting this node.">Résultat de la visite de ce nœud.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.IfFalse">
      <summary vsli:raw="Gets the expression to execute if the test evaluates to &lt;see langword=&quot;false&quot; /&gt;.">Obtient l'expression à exécuter si le test a la valeur <see langword="false" />.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the expression to execute if the test is &lt;see langword=&quot;false&quot; /&gt;.">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'expression à exécuter si le test a la valeur <see langword="false" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.IfTrue">
      <summary vsli:raw="Gets the expression to execute if the test evaluates to &lt;see langword=&quot;true&quot; /&gt;.">Obtient l'expression à exécuter si le test a la valeur <see langword="true" />.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the expression to execute if the test is &lt;see langword=&quot;true&quot; /&gt;.">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'expression à exécuter si le test a la valeur <see langword="true" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.NodeType">
      <summary vsli:raw="Returns the node type of this expression. Extension nodes should return &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Extension&quot; /&gt; when overriding this method.">Retourne le type de nœud de cette expression. Les nœuds d’extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; of the expression.">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.Test">
      <summary vsli:raw="Gets the test of the conditional operation.">Obtient le test de l'opération conditionnelle.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the test of the conditional operation.">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le test de l'opération conditionnelle.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.Type&quot; /&gt; that represents the static type of the expression.">
        <see cref="P:System.Linq.Expressions.ConditionalExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ConditionalExpression.Update(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée</summary>
      <param name="test" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.Test&quot; /&gt; property of the result.">Propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> du résultat.</param>
      <param name="ifTrue" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfTrue&quot; /&gt; property of the result.">Propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> du résultat.</param>
      <param name="ifFalse" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfFalse&quot; /&gt; property of the result.">Propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> du résultat.</param>
      <returns vsli:raw="This expression if no children changed, or an expression with the updated children.">Cette expression si aucun enfant n’est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ConstantExpression">
      <summary vsli:raw="Represents an expression that has a constant value.">Représente une expression qui comporte une valeur de constante.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ConstantExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary vsli:raw="Dispatches to the specific visit method for this node type. For example, &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; calls the &lt;see cref=&quot;M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)&quot; /&gt;.">Distribue à la méthode de visite spécifique à ce type de nœud. Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor" vsli:raw="The visitor to visit this node with.">Visiteur avec lequel visiter ce nœud.</param>
      <returns vsli:raw="The result of visiting this node.">Résultat de la visite de ce nœud.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.NodeType">
      <summary vsli:raw="Returns the node type of this Expression. Extension nodes should return &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Extension&quot; /&gt; when overriding this method.">Retourne le type de nœud de cette expression. Les nœuds d’extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; of the expression.">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.ConstantExpression.Type&quot; /&gt; that represents the static type of the expression.">
        <see cref="P:System.Linq.Expressions.ConstantExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.Value">
      <summary vsli:raw="Gets the value of the constant expression.">Obtient la valeur de l'expression constante.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Object&quot; /&gt; equal to the value of the represented expression.">
        <see cref="T:System.Object" /> égal à la valeur de l'expression représentée.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DebugInfoExpression">
      <summary vsli:raw="Emits or clears a sequence point for debug information. This allows the debugger to highlight the correct source code when debugging.">Émet ou efface un point de séquence pour les informations de débogage. Cela permet au débogueur de mettre en surbrillance le code source correct lors du débogage.</summary>
    </member>
    <member name="M:System.Linq.Expressions.DebugInfoExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary vsli:raw="Dispatches to the specific visit method for this node type. For example, &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; calls the &lt;see cref=&quot;M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)&quot; /&gt;.">Distribue à la méthode de visite spécifique à ce type de nœud. Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor" vsli:raw="The visitor to visit this node with.">Visiteur avec lequel visiter ce nœud.</param>
      <returns vsli:raw="The result of visiting this node.">Résultat de la visite de ce nœud.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.Document">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Linq.Expressions.SymbolDocumentInfo&quot; /&gt; that represents the source file.">Obtient le <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> qui représente le fichier source.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.SymbolDocumentInfo&quot; /&gt; that represents the source file.">
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> qui représente le fichier source.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.EndColumn">
      <summary vsli:raw="Gets the end column of this &lt;see cref=&quot;T:System.Linq.Expressions.DebugInfoExpression&quot; /&gt;.">Obtient la colonne de fin de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns vsli:raw="The number of the end column of the code that was used to generate the wrapped expression.">Numéro de la colonne de fin du code qui a été utilisé pour générer l'expression incluse dans un wrapper.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.EndLine">
      <summary vsli:raw="Gets the end line of this &lt;see cref=&quot;T:System.Linq.Expressions.DebugInfoExpression&quot; /&gt;.">Obtient la ligne de fin de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns vsli:raw="The number of the end line of the code that was used to generate the wrapped expression.">Numéro de la ligne de fin du code qui a été utilisé pour générer l'expression incluse dans un wrapper.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.IsClear">
      <summary vsli:raw="Gets the value to indicate if the &lt;see cref=&quot;T:System.Linq.Expressions.DebugInfoExpression&quot; /&gt; is for clearing a sequence point.">Obtient la valeur qui indique si <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> a pour but d'effacer un point de séquence.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Linq.Expressions.DebugInfoExpression&quot; /&gt; is for clearing a sequence point; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />Si le <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> est destiné à l’effacement d’un point <see langword="false" />de séquence; sinon,.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.NodeType">
      <summary vsli:raw="Returns the node type of this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that represents this expression.">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.StartColumn">
      <summary vsli:raw="Gets the start column of this &lt;see cref=&quot;T:System.Linq.Expressions.DebugInfoExpression&quot; /&gt;.">Obtient la colonne de début de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns vsli:raw="The number of the start column of the code that was used to generate the wrapped expression.">Numéro de la colonne de début du code qui a été utilisé pour générer l'expression incluse dans un wrapper.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.StartLine">
      <summary vsli:raw="Gets the start line of this &lt;see cref=&quot;T:System.Linq.Expressions.DebugInfoExpression&quot; /&gt;.">Obtient la ligne de début de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns vsli:raw="The number of the start line of the code that was used to generate the wrapped expression.">Numéro de la ligne de début du code qui a été utilisé pour générer l'expression incluse dans un wrapper.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.DebugInfoExpression.Type&quot; /&gt; that represents the static type of the expression.">
        <see cref="P:System.Linq.Expressions.DebugInfoExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DefaultExpression">
      <summary vsli:raw="Represents the default value of a type or an empty expression.">Représente la valeur par défaut d'un type ou une expression vide.</summary>
    </member>
    <member name="P:System.Linq.Expressions.DefaultExpression.NodeType">
      <summary vsli:raw="Returns the node type of this expression. Extension nodes should return &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Extension&quot; /&gt; when overriding this method.">Retourne le type de nœud de cette expression. Les nœuds d’extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; of the expression.">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DefaultExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.DefaultExpression.Type&quot; /&gt; that represents the static type of the expression.">
        <see cref="P:System.Linq.Expressions.DefaultExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DynamicExpression">
      <summary vsli:raw="Represents a dynamic operation.">Représente une opération dynamique.</summary>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary vsli:raw="Dispatches to the specific visit method for this node type. For example, &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; calls the &lt;see cref=&quot;M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)&quot; /&gt;.">Distribue à la méthode de visite spécifique à ce type de nœud. Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor" vsli:raw="The visitor to visit this node with.">Visiteur avec lequel visiter ce nœud.</param>
      <returns vsli:raw="The result of visiting this node.">Résultat de la visite de ce nœud.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.Arguments">
      <summary vsli:raw="Gets the arguments to the dynamic operation.">Obtient les arguments de l’opération dynamique.</summary>
      <returns vsli:raw="The read-only collections containing the arguments to the dynamic operation.">Collections en lecture seule contenant  les arguments de l’opération dynamique.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.Binder">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;, which determines the run-time behavior of the dynamic site.">Obtient le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />, qui détermine le comportement au moment de l’exécution du site dynamique.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;, which determines the run-time behavior of the dynamic site.">
        <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />, qui détermine le comportement au moment de l’exécution du site dynamique.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.DelegateType">
      <summary vsli:raw="Gets the type of the delegate used by the &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSite&quot; /&gt;.">Obtient le type de délégué utilisé par <see cref="T:System.Runtime.CompilerServices.CallSite" />.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the type of the delegate used by the &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSite&quot; /&gt;.">Objet <see cref="T:System.Type" /> représentant le type de délégué utilisé par <see cref="T:System.Runtime.CompilerServices.CallSite" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;.">Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</summary>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">Classeur de runtime de l'opération dynamique.</param>
      <param name="returnType" vsli:raw="The result type of the dynamic expression.">Type de résultat de l'expression dynamique.</param>
      <param name="arguments" vsli:raw="The arguments to the dynamic operation.">Arguments de l’opération dynamique.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt;,  and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;.">Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</summary>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">Classeur de runtime de l'opération dynamique.</param>
      <param name="returnType" vsli:raw="The result type of the dynamic expression.">Type de résultat de l'expression dynamique.</param>
      <param name="arg0" vsli:raw="The first argument to the dynamic operation.">Premier argument de l’opération dynamique.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt;,  and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;.">Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</summary>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">Classeur de runtime de l'opération dynamique.</param>
      <param name="returnType" vsli:raw="The result type of the dynamic expression.">Type de résultat de l'expression dynamique.</param>
      <param name="arg0" vsli:raw="The first argument to the dynamic operation.">Premier argument de l’opération dynamique.</param>
      <param name="arg1" vsli:raw="The second argument to the dynamic operation.">Deuxième argument de l'opération dynamique.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt;, and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;.">Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</summary>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">Classeur de runtime de l'opération dynamique.</param>
      <param name="returnType" vsli:raw="The result type of the dynamic expression.">Type de résultat de l'expression dynamique.</param>
      <param name="arg0" vsli:raw="The first argument to the dynamic operation.">Premier argument de l’opération dynamique.</param>
      <param name="arg1" vsli:raw="The second argument to the dynamic operation.">Deuxième argument de l'opération dynamique.</param>
      <param name="arg2" vsli:raw="The third argument to the dynamic operation.">Troisième argument de l'opération dynamique.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt;, and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;.">Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</summary>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">Classeur de runtime de l'opération dynamique.</param>
      <param name="returnType" vsli:raw="The result type of the dynamic expression.">Type de résultat de l'expression dynamique.</param>
      <param name="arg0" vsli:raw="The first argument to the dynamic operation.">Premier argument de l’opération dynamique.</param>
      <param name="arg1" vsli:raw="The second argument to the dynamic operation.">Deuxième argument de l'opération dynamique.</param>
      <param name="arg2" vsli:raw="The third argument to the dynamic operation.">Troisième argument de l'opération dynamique.</param>
      <param name="arg3" vsli:raw="The fourth argument to the dynamic operation.">Quatrième argument de l’opération dynamique.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt;, and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;.">Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</summary>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">Classeur de runtime de l'opération dynamique.</param>
      <param name="returnType" vsli:raw="The result type of the dynamic expression.">Type de résultat de l'expression dynamique.</param>
      <param name="arguments" vsli:raw="The arguments to the dynamic operation.">Arguments de l’opération dynamique.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt;, and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;.">Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</summary>
      <param name="delegateType" vsli:raw="The type of the delegate used by the &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSite&quot; /&gt;.">Type du délégué utilisé par l'objet <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">Classeur de runtime de l'opération dynamique.</param>
      <param name="arguments" vsli:raw="The arguments to the dynamic operation.">Arguments de l’opération dynamique.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt;, and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.DelegateType&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt; and one argument.">Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni et un argument.</summary>
      <param name="delegateType" vsli:raw="The type of the delegate used by the &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSite&quot; /&gt;.">Type du délégué utilisé par l'objet <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">Classeur de runtime de l'opération dynamique.</param>
      <param name="arg0" vsli:raw="The argument to the dynamic operation.">Argument de l'opération dynamique.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt;, and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.DelegateType&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt; and two arguments.">Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni et deux arguments.</summary>
      <param name="delegateType" vsli:raw="The type of the delegate used by the &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSite&quot; /&gt;.">Type du délégué utilisé par l'objet <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">Classeur de runtime de l'opération dynamique.</param>
      <param name="arg0" vsli:raw="The first argument to the dynamic operation.">Premier argument de l’opération dynamique.</param>
      <param name="arg1" vsli:raw="The second argument to the dynamic operation.">Deuxième argument de l'opération dynamique.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt;, and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.DelegateType&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt; and three arguments.">Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni et trois arguments.</summary>
      <param name="delegateType" vsli:raw="The type of the delegate used by the &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSite&quot; /&gt;.">Type du délégué utilisé par l'objet <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">Classeur de runtime de l'opération dynamique.</param>
      <param name="arg0" vsli:raw="The first argument to the dynamic operation.">Premier argument de l’opération dynamique.</param>
      <param name="arg1" vsli:raw="The second argument to the dynamic operation.">Deuxième argument de l'opération dynamique.</param>
      <param name="arg2" vsli:raw="The third argument to the dynamic operation.">Troisième argument de l'opération dynamique.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt;, and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.DelegateType&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt; and four arguments.">Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni et quatre arguments.</summary>
      <param name="delegateType" vsli:raw="The type of the delegate used by the &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSite&quot; /&gt;.">Type du délégué utilisé par l'objet <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">Classeur de runtime de l'opération dynamique.</param>
      <param name="arg0" vsli:raw="The first argument to the dynamic operation.">Premier argument de l’opération dynamique.</param>
      <param name="arg1" vsli:raw="The second argument to the dynamic operation.">Deuxième argument de l'opération dynamique.</param>
      <param name="arg2" vsli:raw="The third argument to the dynamic operation.">Troisième argument de l'opération dynamique.</param>
      <param name="arg3" vsli:raw="The fourth argument to the dynamic operation.">Quatrième argument de l’opération dynamique.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt;, and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.DelegateType&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;.">Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</summary>
      <param name="delegateType" vsli:raw="The type of the delegate used by the &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSite&quot; /&gt;.">Type du délégué utilisé par l'objet <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">Classeur de runtime de l'opération dynamique.</param>
      <param name="arguments" vsli:raw="The arguments to the dynamic operation.">Arguments de l’opération dynamique.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt;, and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.DelegateType&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.NodeType">
      <summary vsli:raw="Returns the node type of this expression. Extension nodes should return &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Extension&quot; /&gt; when overriding this method.">Retourne le type de nœud de cette expression. Les nœuds d’extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; of the expression.">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount">
      <summary vsli:raw="Returns the number of arguments to the expression tree node. You should not use this member. It is only public due to assembly refactoring, and it is used internally for performance optimizations.">Retourne le nombre d’arguments du nœud d’arborescence d’expression. Vous ne devez pas utiliser ce membre. Il est public uniquement en raison de la refactorisation de l’assembly, et il est utilisé en interne pour optimiser les performances.</summary>
      <returns vsli:raw="Returns &lt;see cref=&quot;T:System.Int32&quot; /&gt;.">retourne <see cref="T:System.Int32" /> ;</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)">
      <summary vsli:raw="Returns the argument at index, throwing if index is out of bounds. You should not use this member. It is only public due to assembly refactoring, and it is used internally for performance optimizations.">Retourne l’argument à l’index, en levant une exception si l’index est hors limites. Vous ne devez pas utiliser ce membre. Il est public uniquement en raison de la refactorisation de l’assembly, et il est utilisé en interne pour optimiser les performances.</summary>
      <param name="index" vsli:raw="The index of the argument.">Index de l’argument.</param>
      <returns vsli:raw="Returns &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">retourne <see cref="T:System.Linq.Expressions.Expression" /> ;</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.System#Linq#Expressions#IDynamicExpression#CreateCallSite">
      <summary vsli:raw="Optionally creates the CallSite and returns the CallSite for the DynamicExpression's polymorphic inline cache. You should not use this member. It is only public due to assembly refactoring, and it is used internally for performance optimizations.">Crée éventuellement CallSite et retourne CallSite pour le cache inline polymorphe de DynamicExpression. Vous ne devez pas utiliser ce membre. Il est public uniquement en raison de la refactorisation de l’assembly, et il est utilisé en interne pour optimiser les performances.</summary>
      <returns vsli:raw="Returns &lt;see cref=&quot;T:System.Object&quot; /&gt;.">retourne <see cref="T:System.Object" /> ;</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.System#Linq#Expressions#IDynamicExpression#Rewrite(System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Rewrite this node replacing the dynamic expression's arguments with the provided values. The number of &lt;paramref name=&quot;args&quot; /&gt; needs to match the number of the current expression. You should not use this type. It is only public due to assembly refactoring, and it is used internally for performance optimizations. This helper method allows re-writing of nodes to be independent of the specific implementation class deriving from DynamicExpression that is being used at the call site.">Réécrit ce nœud en remplaçant les arguments de l’expression dynamique par les valeurs fournies. Le nombre de <paramref name="args" /> doit correspondre au nombre de l’expression actuelle. Vous ne devez pas utiliser ce type. Il est public uniquement en raison de la refactorisation de l’assembly, et il est utilisé en interne pour optimiser les performances. Cette méthode d’assistance permet la réécriture de nœuds pour qu’ils soient indépendants de la classe d’implémentation spécifique dérivant de l’expression dynamique qui est utilisée sur le site d’appel.</summary>
      <param name="args" vsli:raw="The arguments.">Arguments.</param>
      <returns vsli:raw="Returns &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;, the rewritten expression.">Retourne <see cref="T:System.Linq.Expressions.Expression" />, l’expression réécrite.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Type&quot; /&gt; that represents the static type of the expression.">
        <see cref="P:System.Linq.Expressions.DynamicExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Compares the value sent to the parameter, &lt;paramref name=&quot;arguments&quot; /&gt;, to the &lt;see langword=&quot;Arguments&quot; /&gt; property of the current instance of &lt;see langword=&quot;DynamicExpression&quot; /&gt;. If the values of the parameter and the property are equal, the current instance is returned. If they are not equal, a new &lt;see langword=&quot;DynamicExpression&quot; /&gt; instance is returned that is identical to the current instance except that the &lt;see langword=&quot;Arguments&quot; /&gt; property is set to the value of parameter &lt;paramref name=&quot;arguments&quot; /&gt;.">Compare la valeur envoyée au paramètre, <paramref name="arguments" />, à la propriété <see langword="Arguments" /> de l'instance actuelle de <see langword="DynamicExpression" />. Si les valeurs du paramètre et de la propriété sont égales, l'instance actuelle est retournée. Si elles ne sont pas identiques, une nouvelle instance de <see langword="DynamicExpression" /> identique à l'instance actuelle est retournée, hormis le fait que la propriété <see langword="Arguments" /> a la valeur du paramètre <paramref name="arguments" />.</summary>
      <param name="arguments" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; property of the result.">Propriété <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> du résultat.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DynamicExpressionVisitor">
      <summary vsli:raw="Represents a visitor or rewriter for dynamic expression trees.">Représente un visiteur ou un module de réécriture pour les arborescences d'expression dynamiques.</summary>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpressionVisitor.#ctor">
      <summary vsli:raw="Initializes a new instance of &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpressionVisitor&quot; /&gt;.">Initialise une nouvelle instance de <see cref="T:System.Linq.Expressions.DynamicExpressionVisitor" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpressionVisitor.VisitDynamic(System.Linq.Expressions.DynamicExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt;.">Visite les enfants de <see cref="T:System.Linq.Expressions.DynamicExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expression à visiter.</param>
      <returns vsli:raw="Returns &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;, the modified expression, if it or any subexpression is modified; otherwise, returns the original expression.">Retourne <see cref="T:System.Linq.Expressions.Expression" />, l'expression modifiée, si celle-ci ou toute sous-expression est modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ElementInit">
      <summary vsli:raw="Represents an initializer for a single element of an &lt;see cref=&quot;T:System.Collections.IEnumerable&quot; /&gt; collection.">Représente un initialiseur pour un élément unique d'une collection <see cref="T:System.Collections.IEnumerable" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.AddMethod">
      <summary vsli:raw="Gets the instance method that is used to add an element to an &lt;see cref=&quot;T:System.Collections.IEnumerable&quot; /&gt; collection.">Obtient la méthode d’instance qui est utilisée pour ajouter un élément à une collection <see cref="T:System.Collections.IEnumerable" />.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents an instance method that adds an element to a collection.">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d’instance qui ajoute un élément à une collection.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.Arguments">
      <summary vsli:raw="Gets the collection of arguments that are passed to a method that adds an element to an &lt;see cref=&quot;T:System.Collections.IEnumerable&quot; /&gt; collection.">Obtient la collection d’arguments passés à une méthode qui ajoute un élément à une collection <see cref="T:System.Collections.IEnumerable" />.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Collections.ObjectModel.ReadOnlyCollection`1&quot; /&gt; of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects that represent the arguments for a method that adds an element to a collection.">Une <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d’objets <see cref="T:System.Linq.Expressions.Expression" /> qui représentent les arguments d’une méthode qui ajoute un élément à une collection.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.System#Linq#Expressions#IArgumentProvider#ArgumentCount">
      <summary vsli:raw="Returns the number of arguments to the expression tree node.  You should not use this member.  It is only public due to assembly refactoring, and it is used internally for performance optimizations.">Retourne le nombre d’arguments du nœud d’arborescence d’expression.  Vous ne devez pas utiliser ce membre.  Il est public uniquement en raison de la refactorisation de l’assembly, et il est utilisé en interne pour optimiser les performances.</summary>
      <returns vsli:raw="Returns &lt;see cref=&quot;T:System.Int32&quot; /&gt;.">retourne <see cref="T:System.Int32" /> ;</returns>
    </member>
    <member name="M:System.Linq.Expressions.ElementInit.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)">
      <summary vsli:raw="Returns the argument at index, throwing if index is out of bounds.  You should not use this member.  It is only public due to assembly refactoring, and it is used internally for performance optimizations.">Retourne l’argument à l’index, en levant une exception si l’index est hors limites.  Vous ne devez pas utiliser ce membre.  Il est public uniquement en raison de la refactorisation de l’assembly, et il est utilisé en interne pour optimiser les performances.</summary>
      <param name="index" vsli:raw="The index of the argument.">Index de l’argument.</param>
      <returns vsli:raw="Returns &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">retourne <see cref="T:System.Linq.Expressions.Expression" /> ;</returns>
    </member>
    <member name="M:System.Linq.Expressions.ElementInit.ToString">
      <summary vsli:raw="Returns a textual representation of an &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt; object.">Retourne une représentation textuelle d'un objet <see cref="T:System.Linq.Expressions.ElementInit" />.</summary>
      <returns vsli:raw="A textual representation of the &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt; object.">Représentation textuelle de l'objet <see cref="T:System.Linq.Expressions.ElementInit" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ElementInit.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="arguments" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.ElementInit.Arguments&quot; /&gt; property of the result.">Propriété <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> du résultat.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="T:System.Linq.Expressions.Expression">
      <summary vsli:raw="Provides the base class from which the classes that represent expression tree nodes are derived. It also contains &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic) factory methods to create the various node types. This is an &lt;see langword=&quot;abstract&quot; /&gt; class.">Fournit la classe de base de laquelle sont dérivées les classes qui représentent des nœuds d'arborescence d'expression. Contient également des méthodes de fabrique <see langword="static" /> (<see langword="Shared" /> en Visual Basic) pour créer les divers types de nœuds. Il s'agit d'une classe <see langword="abstract" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.Expression.#ctor">
      <summary vsli:raw="Constructs a new instance of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Construit une nouvelle instance de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.Expression.#ctor(System.Linq.Expressions.ExpressionType,System.Type)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; class.">Initialise une nouvelle instance de la classe <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <param name="nodeType" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; to set as the node type.">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> à définir comme type de nœud.</param>
      <param name="type" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; of this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary vsli:raw="Dispatches to the specific visit method for this node type. For example, &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; calls the &lt;see cref=&quot;M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)&quot; /&gt;.">Distribue à la méthode de visite spécifique à ce type de nœud. Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor" vsli:raw="The visitor to visit this node with.">Visiteur avec lequel visiter ce nœud.</param>
      <returns vsli:raw="The result of visiting this node.">Résultat de la visite de ce nœud.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an arithmetic addition operation that does not have overflow checking.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'addition arithmétique qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <param name="left" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Add&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The addition operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">L'opérateur d'addition n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an arithmetic addition operation that does not have overflow checking. The implementing method can be specified.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'addition arithmétique qui ne dispose pas d'une vérification de dépassement de capacité. La méthode d'implémentation peut être spécifiée.</summary>
      <param name="left" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Add&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the addition operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> est <see langword="null" /> et l’opérateur d’addition n’est pas défini pour les types <paramref name="left" />. et <paramref name="right" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an addition assignment operation that does not have overflow checking.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation d'addition qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.AddAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an addition assignment operation that does not have overflow checking.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation d'addition qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.AddAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an addition assignment operation that does not have overflow checking.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation d'addition qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.AddAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an addition assignment operation that has overflow checking.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation d'addition qui dispose d'une vérification de dépassement de capacité.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.AddAssignChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an addition assignment operation that has overflow checking.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation d'addition qui dispose d'une vérification de dépassement de capacité.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.AddAssignChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an addition assignment operation that has overflow checking.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation d'addition qui dispose d'une vérification de dépassement de capacité.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.AddAssignChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an arithmetic addition operation that has overflow checking.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'addition arithmétique qui dispose d'une vérification de dépassement de capacité.</summary>
      <param name="left" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.AddChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The addition operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">L'opérateur d'addition n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an arithmetic addition operation that has overflow checking. The implementing method can be specified.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'addition arithmétique qui dispose d'une vérification de dépassement de capacité. La méthode d'implémentation peut être spécifiée.</summary>
      <param name="left" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.AddChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the addition operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> est <see langword="null" /> et l’opérateur d’addition n’est pas défini pour les types <paramref name="left" />. et <paramref name="right" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise &lt;see langword=&quot;AND&quot; /&gt; operation.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération <see langword="AND" /> au niveau du bit.</summary>
      <param name="left" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.And&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.And" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The bitwise &lt;see langword=&quot;AND&quot; /&gt; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">L'opérateur de bits <see langword="AND" /> n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise &lt;see langword=&quot;AND&quot; /&gt; operation. The implementing method can be specified.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération <see langword="AND" /> au niveau du bit. La méthode d'implémentation peut être spécifiée.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.And&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.And" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, pas <see langword="static" /> (<see langword="Shared" /> dans Visual Basic) ou ne prend pas exactement deux arguments.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the bitwise &lt;see langword=&quot;AND&quot; /&gt; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> est <see langword="null" /> et l’opérateur <see langword="AND" /> au niveau du bit n’est pas défini pour les types <paramref name="left" />.et <paramref name="right" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a conditional &lt;see langword=&quot;AND&quot; /&gt; operation that evaluates the second operand only if the first operand evaluates to &lt;see langword=&quot;true&quot; /&gt;.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération <see langword="AND" /> conditionnelle évaluant la deuxième opérande uniquement si la première opérande a la valeur <see langword="true" />.</summary>
      <param name="left" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.AndAlso&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The bitwise &lt;see langword=&quot;AND&quot; /&gt; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type are not the same Boolean type.">L'opérateur de bits <see langword="AND" /> n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.  
ou 
 <paramref name="left" />.Type et <paramref name="right" />.Type ne sont pas du même type booléen.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a conditional &lt;see langword=&quot;AND&quot; /&gt; operation that evaluates the second operand only if the first operand is resolved to true. The implementing method can be specified.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération <see langword="AND" /> conditionnelle évaluant la deuxième opérande uniquement si la première opérande a la valeur true. La méthode d'implémentation peut être spécifiée.</summary>
      <param name="left" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.AndAlso&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, pas <see langword="static" /> (<see langword="Shared" /> dans Visual Basic) ou ne prend pas exactement deux arguments.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the bitwise &lt;see langword=&quot;AND&quot; /&gt; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type are not the same Boolean type.">
        <paramref name="method" /> est <see langword="null" /> et l’opérateur <see langword="AND" /> au niveau du bit n’est pas défini pour les types <paramref name="left" />.et <paramref name="right" />.  
ou 
 <paramref name="method" /> est <see langword="null" /> et <paramref name="left" />.Type et <paramref name="right" />.Type ne sont pas du même type booléen.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise AND assignment operation.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation AND au niveau du bit.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.AndAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise AND assignment operation.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation AND au niveau du bit.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.AndAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise AND assignment operation.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation AND au niveau du bit.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.AndAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Linq.Expressions.IndexExpression&quot; /&gt; to access a multidimensional array.">Crée un <see cref="T:System.Linq.Expressions.IndexExpression" /> pour accéder à un tableau multidimensionnel.</summary>
      <param name="array" vsli:raw="An expression that represents the multidimensional array.">Expression qui représente le tableau multidimensionnel.</param>
      <param name="indexes" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; containing expressions used to index the array.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des expressions utilisées pour indexer le tableau.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.IndexExpression&quot; /&gt;.">Élément <see cref="T:System.Linq.Expressions.IndexExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Linq.Expressions.IndexExpression&quot; /&gt; to access an array.">Crée un <see cref="T:System.Linq.Expressions.IndexExpression" /> pour accéder à un tableau.</summary>
      <param name="array" vsli:raw="An expression representing the array to index.">Expression qui représente le tableau à indexer.</param>
      <param name="indexes" vsli:raw="An array that contains expressions used to index the array.">Tableau qui contient des expressions utilisées pour indexer le tableau.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.IndexExpression&quot; /&gt;.">Élément <see cref="T:System.Linq.Expressions.IndexExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that represents applying an array index operator to an array of rank more than one.">Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente l'application d'un opérateur index de tableau à un tableau de rang supérieur à un.</summary>
      <param name="array" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> doit être égale.</param>
      <param name="indexes" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Arguments&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Call&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Arguments&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt; or &lt;paramref name=&quot;indexes&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="array" /> ou <paramref name="indexes" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt;.Type does not represent an array type.  &#xA;  &#xA; -or-  &#xA;  &#xA; The rank of &lt;paramref name=&quot;array&quot; /&gt;.Type does not match the number of elements in &lt;paramref name=&quot;indexes&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of one or more elements of &lt;paramref name=&quot;indexes&quot; /&gt; does not represent the &lt;see cref=&quot;T:System.Int32&quot; /&gt; type.">
        <paramref name="array" />.Type ne représente pas un type de tableau.  

ou - 
Le rang de <paramref name="array" />.Type ne correspond pas au nombre d'éléments dans <paramref name="indexes" />.  

ou - 
La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un ou plusieurs éléments de <paramref name="indexes" /> ne représente pas le type <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents applying an array index operator to an array of rank one.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente l'application d'un opérateur index de tableau à un tableau de rang un.</summary>
      <param name="array" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="index" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ArrayIndex&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ArrayIndex" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt; or &lt;paramref name=&quot;index&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="array" /> ou <paramref name="index" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt;.Type does not represent an array type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;array&quot; /&gt;.Type represents an array type whose rank is not 1.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;index&quot; /&gt;.Type does not represent the &lt;see cref=&quot;T:System.Int32&quot; /&gt; type.">
        <paramref name="array" />.Type ne représente pas un type de tableau.  
ou 
 <paramref name="array" />.Type représente un type de tableau dont le rang n'est pas 1.  

ou - 
<paramref name="index" />.Type ne représente pas le type <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that represents applying an array index operator to a multidimensional array.">Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente l'application d'un opérateur index de tableau à un tableau multidimensionnel.</summary>
      <param name="array" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; instances - indexes for the array index operation.">Tableau d'instances <see cref="T:System.Linq.Expressions.Expression" />, index pour l'opération d'index de tableau.</param>
      <param name="indexes" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Arguments&quot; /&gt; collection.">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Call&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Arguments&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt; or &lt;paramref name=&quot;indexes&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="array" /> ou <paramref name="indexes" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt;.Type does not represent an array type.  &#xA;  &#xA; -or-  &#xA;  &#xA; The rank of &lt;paramref name=&quot;array&quot; /&gt;.Type does not match the number of elements in &lt;paramref name=&quot;indexes&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of one or more elements of &lt;paramref name=&quot;indexes&quot; /&gt; does not represent the &lt;see cref=&quot;T:System.Int32&quot; /&gt; type.">
        <paramref name="array" />.Type ne représente pas un type de tableau.  
ou 
Le rang de <paramref name="array" />.Type ne correspond pas au nombre d'éléments dans <paramref name="indexes" />.  

ou - 
La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un ou plusieurs éléments de <paramref name="indexes" /> ne représente pas le type <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayLength(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents an expression for obtaining the length of a one-dimensional array.">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une expression permettant d'obtenir la longueur d'un tableau unidimensionnel.</summary>
      <param name="array" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ArrayLength&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property equal to &lt;paramref name=&quot;array&quot; /&gt;.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ArrayLength" /> et la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> est égale à <paramref name="array" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="array" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt;.Type does not represent an array type.">
        <paramref name="array" />.Type ne représente pas un type de tableau.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Assign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an assignment operation.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Assign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Assign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MemberInfo,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberAssignment&quot; /&gt; that represents the initialization of a field or property.">Crée un <see cref="T:System.Linq.Expressions.MemberAssignment" /> qui représente l'initialisation d'un champ ou d'une propriété.</summary>
      <param name="member" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MemberInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> doit être égale.</param>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MemberAssignment.Expression&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberAssignment&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.BindingType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.MemberBindingType.Assignment&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MemberAssignment.Expression&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.MemberAssignment" /> dont <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égal à <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" /> et dont <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> et <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;member&quot; /&gt; or &lt;paramref name=&quot;expression&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="member" /> ou <paramref name="expression" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;member&quot; /&gt; does not represent a field or property.  &#xA;  &#xA; -or-  &#xA;  &#xA; The property represented by &lt;paramref name=&quot;member&quot; /&gt; does not have a &lt;see langword=&quot;set&quot; /&gt; accessor.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;expression&quot; /&gt;.Type is not assignable to the type of the field or property that &lt;paramref name=&quot;member&quot; /&gt; represents.">
        <paramref name="member" /> ne représente pas un champ ou une propriété.  

ou - 
La propriété représentée par <paramref name="member" /> n'a pas d'accesseur <see langword="set" />.  

ou - 
<paramref name="expression" />. Le type n’est pas assignable au type de champ ou à la propriété que <paramref name="member" /> représente.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberAssignment&quot; /&gt; that represents the initialization of a member by using a property accessor method.">Crée un <see cref="T:System.Linq.Expressions.MemberAssignment" /> qui représente l'initialisation d'un membre à l'aide d'une méthode d'accesseur de propriété.</summary>
      <param name="propertyAccessor" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents a property accessor method.">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'accesseur de propriété.</param>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MemberAssignment.Expression&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberAssignment&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.BindingType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.MemberBindingType.Assignment&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; property set to the &lt;see cref=&quot;T:System.Reflection.PropertyInfo&quot; /&gt; that represents the property accessed in &lt;paramref name=&quot;propertyAccessor&quot; /&gt;, and the &lt;see cref=&quot;P:System.Linq.Expressions.MemberAssignment.Expression&quot; /&gt; property set to &lt;paramref name=&quot;expression&quot; /&gt;.">
        <see cref="T:System.Linq.Expressions.MemberAssignment" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" />, dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> a pour valeur le <see cref="T:System.Reflection.PropertyInfo" /> qui représente la propriété accessible dans <paramref name="propertyAccessor" />, et dont la propriété <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> a la valeur <paramref name="expression" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;propertyAccessor&quot; /&gt; or &lt;paramref name=&quot;expression&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="propertyAccessor" /> ou <paramref name="expression" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;propertyAccessor&quot; /&gt; does not represent a property accessor method.  &#xA;  &#xA; -or-  &#xA;  &#xA; The property accessed by &lt;paramref name=&quot;propertyAccessor&quot; /&gt; does not have a &lt;see langword=&quot;set&quot; /&gt; accessor.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;expression&quot; /&gt;.Type is not assignable to the type of the field or property that &lt;paramref name=&quot;member&quot; /&gt; represents.">
        <paramref name="propertyAccessor" /> ne représente pas une méthode d'accesseur de propriété.  

ou - 
La propriété à laquelle <paramref name="propertyAccessor" /> accède n’a pas d’accesseur <see langword="set" />.  

ou - 
<paramref name="expression" />. Le type n’est pas assignable au type de champ ou à la propriété que <paramref name="member" /> représente.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt; that contains the given expressions and has no variables.">Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les expressions données et aucune variable.</summary>
      <param name="expressions" vsli:raw="The expressions in the block.">Expressions contenues dans le bloc.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt;.">Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt; that contains the given variables and expressions.">Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les variables et expressions données.</summary>
      <param name="variables" vsli:raw="The variables in the block.">Variables contenues dans le bloc.</param>
      <param name="expressions" vsli:raw="The expressions in the block.">Expressions contenues dans le bloc.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt;.">Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt; that contains the given variables and expressions.">Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les variables et expressions données.</summary>
      <param name="variables" vsli:raw="The variables in the block.">Variables contenues dans le bloc.</param>
      <param name="expressions" vsli:raw="The expressions in the block.">Expressions contenues dans le bloc.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt;.">Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt; that contains two expressions and has no variables.">Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient deux expressions et aucune variable.</summary>
      <param name="arg0" vsli:raw="The first expression in the block.">Première expression contenue dans le bloc.</param>
      <param name="arg1" vsli:raw="The second expression in the block.">Deuxième expression contenue dans le bloc.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt;.">Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt; that contains three expressions and has no variables.">Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient trois expressions et aucune variable.</summary>
      <param name="arg0" vsli:raw="The first expression in the block.">Première expression contenue dans le bloc.</param>
      <param name="arg1" vsli:raw="The second expression in the block.">Deuxième expression contenue dans le bloc.</param>
      <param name="arg2" vsli:raw="The third expression in the block.">Troisième expression contenue dans le bloc.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt;.">Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt; that contains four expressions and has no variables.">Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient quatre expressions et aucune variable.</summary>
      <param name="arg0" vsli:raw="The first expression in the block.">Première expression contenue dans le bloc.</param>
      <param name="arg1" vsli:raw="The second expression in the block.">Deuxième expression contenue dans le bloc.</param>
      <param name="arg2" vsli:raw="The third expression in the block.">Troisième expression contenue dans le bloc.</param>
      <param name="arg3" vsli:raw="The fourth expression in the block.">Quatrième expression contenue dans le bloc.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt;.">Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt; that contains five expressions and has no variables.">Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient deux expressions et aucune variable.</summary>
      <param name="arg0" vsli:raw="The first expression in the block.">Première expression contenue dans le bloc.</param>
      <param name="arg1" vsli:raw="The second expression in the block.">Deuxième expression contenue dans le bloc.</param>
      <param name="arg2" vsli:raw="The third expression in the block.">Troisième expression contenue dans le bloc.</param>
      <param name="arg3" vsli:raw="The fourth expression in the block.">Quatrième expression contenue dans le bloc.</param>
      <param name="arg4" vsli:raw="The fifth expression in the block.">Cinquième expression contenue dans le bloc.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt;.">Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt; that contains the given expressions and has no variables.">Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les expressions données et aucune variable.</summary>
      <param name="expressions" vsli:raw="The expressions in the block.">Expressions contenues dans le bloc.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt;.">Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt; that contains the given expressions, has no variables and has specific result type.">Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les expressions données, aucune variable et a un type de résultat spécifique.</summary>
      <param name="type" vsli:raw="The result type of the block.">Type de résultat du bloc.</param>
      <param name="expressions" vsli:raw="The expressions in the block.">Expressions contenues dans le bloc.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt;.">Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt; that contains the given variables and expressions.">Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les variables et expressions données.</summary>
      <param name="type" vsli:raw="The result type of the block.">Type de résultat du bloc.</param>
      <param name="variables" vsli:raw="The variables in the block.">Variables contenues dans le bloc.</param>
      <param name="expressions" vsli:raw="The expressions in the block.">Expressions contenues dans le bloc.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt;.">Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt; that contains the given variables and expressions.">Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les variables et expressions données.</summary>
      <param name="type" vsli:raw="The result type of the block.">Type de résultat du bloc.</param>
      <param name="variables" vsli:raw="The variables in the block.">Variables contenues dans le bloc.</param>
      <param name="expressions" vsli:raw="The expressions in the block.">Expressions contenues dans le bloc.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt;.">Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt; that contains the given expressions, has no variables and has specific result type.">Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les expressions données, aucune variable et a un type de résultat spécifique.</summary>
      <param name="type" vsli:raw="The result type of the block.">Type de résultat du bloc.</param>
      <param name="expressions" vsli:raw="The expressions in the block.">Expressions contenues dans le bloc.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt;.">Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; representing a break statement.">Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Break.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; will jump to.">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; with &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Kind&quot; /&gt; equal to Break, the &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Target&quot; /&gt; property set to &lt;paramref name=&quot;target&quot; /&gt;, and a null value to be passed to the target label upon jumping.">
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Break, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et une valeur null à passer à l'étiquette cible au moment du saut.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; representing a break statement. The value passed to the label upon jumping can be specified.">Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Break. La valeur passée à l'étiquette au moment du saut peut être spécifiée.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; will jump to.">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="value" vsli:raw="The value that will be passed to the associated label upon jumping.">Valeur qui sera passée à l'étiquette associée au moment du saut.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; with &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Kind&quot; /&gt; equal to Break, the &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Target&quot; /&gt; property set to &lt;paramref name=&quot;target&quot; /&gt;, and &lt;paramref name=&quot;value&quot; /&gt; to be passed to the target label upon jumping.">
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Break, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; representing a break statement with the specified type. The value passed to the label upon jumping can be specified.">Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Break avec le type spécifié. La valeur passée à l'étiquette au moment du saut peut être spécifiée.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; will jump to.">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="value" vsli:raw="The value that will be passed to the associated label upon jumping.">Valeur qui sera passée à l'étiquette associée au moment du saut.</param>
      <param name="type" vsli:raw="An &lt;see cref=&quot;T:System.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property equal to.">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; with &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Kind&quot; /&gt; equal to Break, the &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Target&quot; /&gt; property set to &lt;paramref name=&quot;target&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property set to &lt;paramref name=&quot;type&quot; /&gt;, and &lt;paramref name=&quot;value&quot; /&gt; to be passed to the target label upon jumping.">
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Break, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" />, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; representing a break statement with the specified type.">Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Break avec le type spécifié.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; will jump to.">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="type" vsli:raw="An &lt;see cref=&quot;T:System.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property equal to.">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; with &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Kind&quot; /&gt; equal to Break, the &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Target&quot; /&gt; property set to &lt;paramref name=&quot;target&quot; /&gt;, and the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property set to &lt;paramref name=&quot;type&quot; /&gt;.">
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Break, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that represents a call to a method that takes no arguments.">Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode qui ne prend aucun argument.</summary>
      <param name="instance" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that specifies the instance for an instance method call (pass &lt;see langword=&quot;null&quot; /&gt; for a &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic) method).">
        <see cref="T:System.Linq.Expressions.Expression" /> qui spécifie l'instance d'un appel de méthode d'instance (passez <see langword="null" /> pour une méthode <see langword="static" /> (<see langword="Shared" /> en Visual Basic)).</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Call&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;instance&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and &lt;paramref name=&quot;method&quot; /&gt; represents an instance method.">
        <paramref name="method" /> a la valeur <see langword="null" />.  
ou 
 <paramref name="instance" /> est <see langword="null" /> et <paramref name="method" /> représente une méthode d’instance.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;instance&quot; /&gt;.Type is not assignable to the declaring type of the method represented by &lt;paramref name=&quot;method&quot; /&gt;.">
        <paramref name="instance" />. Le type ne peut pas être affecté au type de la méthode représentée par <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that represents a call to a method that takes arguments.">Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode qui prend des arguments.</summary>
      <param name="instance" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt; property equal to (pass &lt;see langword=&quot;null&quot; /&gt; for a &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic) method).">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> doit être égale (passez <see langword="null" /> pour une méthode <see langword="static" /> (<see langword="Shared" /> en Visual Basic)).</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <param name="arguments" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Arguments&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Call&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Arguments&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;instance&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and &lt;paramref name=&quot;method&quot; /&gt; represents an instance method.">
        <paramref name="method" /> est <see langword="null" />.  
ou 
 <paramref name="instance" /> est <see langword="null" /> et <paramref name="method" /> représente une méthode d’instance.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;instance&quot; /&gt;.Type is not assignable to the declaring type of the method represented by &lt;paramref name=&quot;method&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The number of elements in &lt;paramref name=&quot;arguments&quot; /&gt; does not equal the number of parameters for the method represented by &lt;paramref name=&quot;method&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more of the elements of &lt;paramref name=&quot;arguments&quot; /&gt; is not assignable to the corresponding parameter for the method represented by &lt;paramref name=&quot;method&quot; /&gt;.">
        <paramref name="instance" />. Le type ne peut pas être affecté au type de la méthode représentée par <paramref name="method" />.  
ou 
Le nombre d’éléments dans <paramref name="arguments" /> ne correspond pas au nombre de paramètres pour la méthode représentée par <paramref name="method" />.  

ou - 
Un ou plusieurs des éléments des <paramref name="arguments" /> n’est pas assignable au paramètre correspondant pour la méthode représentée par <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that represents a call to a method that takes two arguments.">Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode qui prend deux arguments.</summary>
      <param name="instance" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that specifies the instance for an instance call. (pass null for a static (Shared in Visual Basic) method).">
        <see cref="T:System.Linq.Expressions.Expression" /> qui spécifie l'instance d'un appel d'instance. (Passez la valeur Null pour une méthode statique (méthode partagée en Visual Basic.)</param>
      <param name="method" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the target method.">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode cible.</param>
      <param name="arg0" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the first argument.">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</param>
      <param name="arg1" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the second argument.">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le deuxième argument.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Call&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that represents a call to a method that takes three arguments.">Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode qui prend trois arguments.</summary>
      <param name="instance" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that specifies the instance for an instance call. (pass null for a static (Shared in Visual Basic) method).">
        <see cref="T:System.Linq.Expressions.Expression" /> qui spécifie l'instance d'un appel d'instance. (Passez la valeur Null pour une méthode statique (méthode partagée en Visual Basic.)</param>
      <param name="method" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the target method.">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode cible.</param>
      <param name="arg0" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the first argument.">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</param>
      <param name="arg1" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the second argument.">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le deuxième argument.</param>
      <param name="arg2" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the third argument.">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le troisième argument.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Call&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that represents a call to a method that takes arguments.">Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode qui prend des arguments.</summary>
      <param name="instance" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that specifies the instance for an instance method call (pass &lt;see langword=&quot;null&quot; /&gt; for a &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic) method).">
        <see cref="T:System.Linq.Expressions.Expression" /> qui spécifie l'instance d'un appel de méthode d'instance (passez <see langword="null" /> pour une méthode <see langword="static" /> (<see langword="Shared" /> en Visual Basic)).</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <param name="arguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Arguments&quot; /&gt; collection.">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Call&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Arguments&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;instance&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and &lt;paramref name=&quot;method&quot; /&gt; represents an instance method.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;arguments&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and one or more of its elements is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="method" /> a la valeur <see langword="null" />.  

ou - 
<paramref name="instance" /> est <see langword="null" /> et <paramref name="method" /> représente une méthode d’instance.  

ou 
 <paramref name="arguments" /> n’est pas <see langword="null" /> et un ou plusieurs de ses éléments sont <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;instance&quot; /&gt;.Type is not assignable to the declaring type of the method represented by &lt;paramref name=&quot;method&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The number of elements in &lt;paramref name=&quot;arguments&quot; /&gt; does not equal the number of parameters for the method represented by &lt;paramref name=&quot;method&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more of the elements of &lt;paramref name=&quot;arguments&quot; /&gt; is not assignable to the corresponding parameter for the method represented by &lt;paramref name=&quot;method&quot; /&gt;.">
        <paramref name="instance" />. Le type ne peut pas être affecté au type de la méthode représentée par <paramref name="method" />.  

ou - 
Le nombre d’éléments dans <paramref name="arguments" /> ne correspond pas au nombre de paramètres pour la méthode représentée par <paramref name="method" />.  

ou - 
Un ou plusieurs des éléments des <paramref name="arguments" /> n’est pas assignable au paramètre correspondant pour la méthode représentée par <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.String,System.Type[],System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that represents a call to a method by calling the appropriate factory method.">Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode en appelant la méthode de fabrique appropriée.</summary>
      <param name="instance" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; whose &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property value will be searched for a specific method.">
        <see cref="T:System.Linq.Expressions.Expression" /> dont la valeur de propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> fera l'objet d'une recherche de méthode spécifique.</param>
      <param name="methodName" vsli:raw="The name of the method.">Nom de la méthode.</param>
      <param name="typeArguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Type&quot; /&gt; objects that specify the type parameters of the generic method. This argument should be null when methodName specifies a non-generic method.">Tableau d'objets <see cref="T:System.Type" /> spécifiant les paramètres de type de la méthode générique. Cet argument doit être null lorsque methodName spécifie une méthode non générique.</param>
      <param name="arguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects that represents the arguments to the method.">Tableau d’objets <see cref="T:System.Linq.Expressions.Expression" /> représentant les arguments de la méthode.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Call&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt; property equal to &lt;paramref name=&quot;instance&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; set to the &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the specified instance method, and &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Arguments&quot; /&gt; set to the specified arguments.">
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, dont la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> est égale à <paramref name="instance" />, dont <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> a pour valeur <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'instance spécifiée, et dont <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> a pour valeur les arguments spécifiés.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;instance&quot; /&gt; or &lt;paramref name=&quot;methodName&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="instance" /> ou <paramref name="methodName" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="No method whose name is &lt;paramref name=&quot;methodName&quot; /&gt;, whose type parameters match &lt;paramref name=&quot;typeArguments&quot; /&gt;, and whose parameter types match &lt;paramref name=&quot;arguments&quot; /&gt; is found in &lt;paramref name=&quot;instance&quot; /&gt;.Type or its base types.  &#xA;  &#xA; -or-  &#xA;  &#xA; More than one method whose name is &lt;paramref name=&quot;methodName&quot; /&gt;, whose type parameters match &lt;paramref name=&quot;typeArguments&quot; /&gt;, and whose parameter types match &lt;paramref name=&quot;arguments&quot; /&gt; is found in &lt;paramref name=&quot;instance&quot; /&gt;.Type or its base types.">Aucune méthode appelée <paramref name="methodName" />, dont les paramètres de type correspondent à <paramref name="typeArguments" /> et dont les types de paramètres correspondent à <paramref name="arguments" /> n'est trouvée dans <paramref name="instance" />.Type ou ses types de base.  
ou 
Plusieurs méthodes appelées <paramref name="methodName" />, dont les paramètres de type correspondent à <paramref name="typeArguments" /> et dont les types de paramètres correspondent à <paramref name="arguments" /> sont trouvées dans <paramref name="instance" />.Type ou ses types de base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that represents a call to a static (Shared in Visual Basic) method.">Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode statique (méthode partagée en Visual Basic).</summary>
      <param name="method" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the target method.">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode cible.</param>
      <param name="arguments" vsli:raw="A collection of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the call arguments.">Collection de <see cref="T:System.Linq.Expressions.Expression" /> qui représente les arguments de l'appel.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Call&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that represents a call to a &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic) method that takes one argument.">Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode <see langword="static" /> (<see langword="Shared" /> en Visual Basic) qui prend un seul argument.</summary>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <param name="arg0" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the first argument.">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Call&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is null.">
        <paramref name="method" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that represents a call to a static method that takes two arguments.">Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode statique prenant deux arguments.</summary>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <param name="arg0" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the first argument.">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</param>
      <param name="arg1" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the second argument.">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le deuxième argument.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Call&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is null.">
        <paramref name="method" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that represents a call to a static method that takes three arguments.">Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode statique prenant trois arguments.</summary>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <param name="arg0" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the first argument.">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</param>
      <param name="arg1" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the second argument.">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le deuxième argument.</param>
      <param name="arg2" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the third argument.">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le troisième argument.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Call&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is null.">
        <paramref name="method" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that represents a call to a static method that takes four arguments.">Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode statique prenant quatre arguments.</summary>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <param name="arg0" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the first argument.">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</param>
      <param name="arg1" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the second argument.">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le deuxième argument.</param>
      <param name="arg2" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the third argument.">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le troisième argument.</param>
      <param name="arg3" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the fourth argument.">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le quatrième argument.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Call&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is null.">
        <paramref name="method" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that represents a call to a static method that takes five arguments.">Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode statique prenant cinq arguments.</summary>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <param name="arg0" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the first argument.">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</param>
      <param name="arg1" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the second argument.">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le deuxième argument.</param>
      <param name="arg2" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the third argument.">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le troisième argument.</param>
      <param name="arg3" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the fourth argument.">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le quatrième argument.</param>
      <param name="arg4" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the fifth argument.">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Call&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is null.">
        <paramref name="method" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that represents a call to a &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic) method that has arguments.">Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode <see langword="static" /> (<see langword="Shared" /> en Visual Basic) comportant des arguments.</summary>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents a &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic) method to set the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode <see langword="static" /> (<see langword="Shared" /> en Visual Basic) à laquelle la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <param name="arguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Arguments&quot; /&gt; collection.">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Call&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Arguments&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="method" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The number of elements in &lt;paramref name=&quot;arguments&quot; /&gt; does not equal the number of parameters for the method represented by &lt;paramref name=&quot;method&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more of the elements of &lt;paramref name=&quot;arguments&quot; /&gt; is not assignable to the corresponding parameter for the method represented by &lt;paramref name=&quot;method&quot; /&gt;.">Le nombre d’éléments dans <paramref name="arguments" /> ne correspond pas au nombre de paramètres pour la méthode représentée par <paramref name="method" />.  

ou - 
Un ou plusieurs des éléments des <paramref name="arguments" /> n’est pas assignable au paramètre correspondant pour la méthode représentée par <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Type,System.String,System.Type[],System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that represents a call to a &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic) method by calling the appropriate factory method.">Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode <see langword="static" /> (<see langword="Shared" /> en Visual Basic) en appelant la méthode de fabrique appropriée.</summary>
      <param name="type" vsli:raw="The type that contains the specified &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic) method.">Type contenant la méthode <see langword="static" /> (<see langword="Shared" /> dans Visual Basic) spécifiée.</param>
      <param name="methodName" vsli:raw="The name of the method.">Nom de la méthode.</param>
      <param name="typeArguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Type&quot; /&gt; objects that specify the type parameters of the generic method. This argument should be null when methodName specifies a non-generic method.">Tableau d'objets <see cref="T:System.Type" /> spécifiant les paramètres de type de la méthode générique. Cet argument doit être null lorsque methodName spécifie une méthode non générique.</param>
      <param name="arguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects that represent the arguments to the method.">Tableau d’objets <see cref="T:System.Linq.Expressions.Expression" /> représentant les arguments de la méthode.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Call&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; property set to the &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the specified &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic) method, and the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Arguments&quot; /&gt; property set to the specified arguments.">
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, dont la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> a pour valeur <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode <see langword="static" /> (<see langword="Shared" /> en Visual Basic) spécifiée, et dont la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> a pour valeur les arguments spécifiés.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;type&quot; /&gt; or &lt;paramref name=&quot;methodName&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="type" /> ou <paramref name="methodName" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="No method whose name is &lt;paramref name=&quot;methodName&quot; /&gt;, whose type parameters match &lt;paramref name=&quot;typeArguments&quot; /&gt;, and whose parameter types match &lt;paramref name=&quot;arguments&quot; /&gt; is found in &lt;paramref name=&quot;type&quot; /&gt; or its base types.  &#xA;  &#xA; -or-  &#xA;  &#xA; More than one method whose name is &lt;paramref name=&quot;methodName&quot; /&gt;, whose type parameters match &lt;paramref name=&quot;typeArguments&quot; /&gt;, and whose parameter types match &lt;paramref name=&quot;arguments&quot; /&gt; is found in &lt;paramref name=&quot;type&quot; /&gt; or its base types.">Aucune méthode appelée <paramref name="methodName" />, dont les paramètres de type correspondent à <paramref name="typeArguments" /> et dont les types de paramètres correspondent à <paramref name="arguments" /> n'est trouvée dans <paramref name="type" /> ou ses types de base.  

ou - 
Plusieurs méthodes appelées <paramref name="methodName" />, dont les paramètres de type correspondent à <paramref name="typeArguments" /> et dont les types de paramètres correspondent à <paramref name="arguments" /> sont trouvées dans <paramref name="type" /> ou ses types de base.</exception>
    </member>
    <member name="P:System.Linq.Expressions.Expression.CanReduce">
      <summary vsli:raw="Indicates that the node can be reduced to a simpler node. If this returns true, Reduce() can be called to produce the reduced form.">Indique que le nœud peut être réduit à un nœud plus simple. Si la valeur retournée est true, Reduce() peut être appelé pour produire la forme réduite.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the node can be reduced; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />Si le nœud peut être réduit; Sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt; representing a catch statement with a reference to the caught &lt;see cref=&quot;T:System.Exception&quot; /&gt; object for use in the handler body.">Crée un <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente une instruction Catch avec une référence à l'objet <see cref="T:System.Exception" /> intercepté pour une utilisation dans le corps du gestionnaire.</summary>
      <param name="variable" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; representing a reference to the &lt;see cref=&quot;T:System.Exception&quot; /&gt; object caught by this handler.">
        <see cref="T:System.Linq.Expressions.ParameterExpression" /> représentant une référence à l'objet <see cref="T:System.Exception" /> intercepté par ce gestionnaire.</param>
      <param name="body" vsli:raw="The body of the catch statement.">Corps de l'instruction Catch.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt;.">Élément <see cref="T:System.Linq.Expressions.CatchBlock" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt; representing a catch statement with an &lt;see cref=&quot;T:System.Exception&quot; /&gt; filter and a reference to the caught &lt;see cref=&quot;T:System.Exception&quot; /&gt; object.">Crée un <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente une instruction Catch avec un filtre <see cref="T:System.Exception" /> et une référence à l'objet <see cref="T:System.Exception" /> intercepté.</summary>
      <param name="variable" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; representing a reference to the &lt;see cref=&quot;T:System.Exception&quot; /&gt; object caught by this handler.">
        <see cref="T:System.Linq.Expressions.ParameterExpression" /> représentant une référence à l'objet <see cref="T:System.Exception" /> intercepté par ce gestionnaire.</param>
      <param name="body" vsli:raw="The body of the catch statement.">Corps de l'instruction Catch.</param>
      <param name="filter" vsli:raw="The body of the &lt;see cref=&quot;T:System.Exception&quot; /&gt; filter.">Corps du filtre <see cref="T:System.Exception" />.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt;.">Élément <see cref="T:System.Linq.Expressions.CatchBlock" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt; representing a catch statement.">Crée un <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente une instruction Catch.</summary>
      <param name="type" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; of &lt;see cref=&quot;T:System.Exception&quot; /&gt; this &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt; will handle.">Propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que <see cref="T:System.Linq.Expressions.CatchBlock" /> traitera.</param>
      <param name="body" vsli:raw="The body of the catch statement.">Corps de l'instruction Catch.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt;.">Élément <see cref="T:System.Linq.Expressions.CatchBlock" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt; representing a catch statement with an &lt;see cref=&quot;T:System.Exception&quot; /&gt; filter but no reference to the caught &lt;see cref=&quot;T:System.Exception&quot; /&gt; object.">Crée un <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente une instruction Catch avec un filtre <see cref="T:System.Exception" />, sans référence à l'objet <see cref="T:System.Exception" /> intercepté.</summary>
      <param name="type" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; of &lt;see cref=&quot;T:System.Exception&quot; /&gt; this &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt; will handle.">Propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que <see cref="T:System.Linq.Expressions.CatchBlock" /> traitera.</param>
      <param name="body" vsli:raw="The body of the catch statement.">Corps de l'instruction Catch.</param>
      <param name="filter" vsli:raw="The body of the &lt;see cref=&quot;T:System.Exception&quot; /&gt; filter.">Corps du filtre <see cref="T:System.Exception" />.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt;.">Élément <see cref="T:System.Linq.Expressions.CatchBlock" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ClearDebugInfo(System.Linq.Expressions.SymbolDocumentInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DebugInfoExpression&quot; /&gt; for clearing a sequence point.">Crée un <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> pour la suppression d'un point de séquence.</summary>
      <param name="document" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.SymbolDocumentInfo&quot; /&gt; that represents the source file.">
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> qui représente le fichier source.</param>
      <returns vsli:raw="An instance of &lt;see cref=&quot;T:System.Linq.Expressions.DebugInfoExpression&quot; /&gt; for clearing a sequence point.">Instance de <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> pour le nettoyage d’un point de séquence.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a coalescing operation.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de fusion.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Coalesce&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of &lt;paramref name=&quot;left&quot; /&gt; does not represent a reference type or a nullable value type.">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="left" /> ne représente pas un type référence ou un type valeur Nullable.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type are not convertible to each other.">
        <paramref name="left" />.Type ne peut pas être converti en <paramref name="right" />.Type, et inversement.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a coalescing operation, given a conversion function.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de fusion, à partir d'une fonction de conversion.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="conversion" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Coalesce&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type are not convertible to each other.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;conversion&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and &lt;paramref name=&quot;conversion&quot; /&gt;.Type is a delegate type that does not take exactly one argument.">
        <paramref name="left" />.Type ne peut pas être converti en <paramref name="right" />.Type, et inversement.  

ou - 
<paramref name="conversion" /> n'est pas <see langword="null" /> et <paramref name="conversion" />.Type est un type délégué qui ne prend pas exactement un argument.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of &lt;paramref name=&quot;left&quot; /&gt; does not represent a reference type or a nullable value type.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of &lt;paramref name=&quot;left&quot; /&gt; represents a type that is not assignable to the parameter type of the delegate type &lt;paramref name=&quot;conversion&quot; /&gt;.Type.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of &lt;paramref name=&quot;right&quot; /&gt; is not equal to the return type of the delegate type &lt;paramref name=&quot;conversion&quot; /&gt;.Type.">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="left" /> ne représente pas un type référence ou un type valeur Nullable.  
ou 
La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="left" /> représente un type qui ne peut pas être assigné au type de paramètre du type délégué <paramref name="conversion" />.Type.  
ou 
La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="right" /> n'est pas égale au type de retour du type délégué <paramref name="conversion" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.ConditionalExpression&quot; /&gt; that represents a conditional statement.">Crée un <see cref="T:System.Linq.Expressions.ConditionalExpression" /> qui représente une instruction conditionnelle.</summary>
      <param name="test" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.Test&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> doit être égale.</param>
      <param name="ifTrue" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfTrue&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> doit être égale.</param>
      <param name="ifFalse" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfFalse&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ConditionalExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Conditional&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.Test&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfTrue&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfFalse&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.ConditionalExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> et <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;test&quot; /&gt; or &lt;paramref name=&quot;ifTrue&quot; /&gt; or &lt;paramref name=&quot;ifFalse&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="test" /> ou <paramref name="ifTrue" /> ou <paramref name="ifFalse" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;test&quot; /&gt;.Type is not &lt;see cref=&quot;T:System.Boolean&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;ifTrue&quot; /&gt;.Type is not equal to &lt;paramref name=&quot;ifFalse&quot; /&gt;.Type.">
        <paramref name="test" />.Type n'est pas <see cref="T:System.Boolean" />.  

ou - 
<paramref name="ifTrue" />.Type n'est pas égal à <paramref name="ifFalse" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.ConditionalExpression&quot; /&gt; that represents a conditional statement.">Crée un <see cref="T:System.Linq.Expressions.ConditionalExpression" /> qui représente une instruction conditionnelle.</summary>
      <param name="test" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.Test&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> doit être égale.</param>
      <param name="ifTrue" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfTrue&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> doit être égale.</param>
      <param name="ifFalse" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfFalse&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> doit être égale.</param>
      <param name="type" vsli:raw="A &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property equal to.">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ConditionalExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Conditional&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.Test&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfTrue&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfFalse&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.ConditionalExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> et <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Constant(System.Object)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.ConstantExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.ConstantExpression.Value&quot; /&gt; property set to the specified value.">Crée un <see cref="T:System.Linq.Expressions.ConstantExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> a la valeur spécifiée.</summary>
      <param name="value" vsli:raw="An &lt;see cref=&quot;T:System.Object&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ConstantExpression.Value&quot; /&gt; property equal to.">
        <see cref="T:System.Object" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ConstantExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Constant&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.ConstantExpression.Value&quot; /&gt; property set to the specified value.">
        <see cref="T:System.Linq.Expressions.ConstantExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> et dont la propriété <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> a la valeur spécifiée.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Constant(System.Object,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.ConstantExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.ConstantExpression.Value&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; properties set to the specified values.">Crée un <see cref="T:System.Linq.Expressions.ConstantExpression" /> dont les propriétés <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> et <see cref="P:System.Linq.Expressions.Expression.Type" /> ont les valeurs spécifiées.</summary>
      <param name="value" vsli:raw="An &lt;see cref=&quot;T:System.Object&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ConstantExpression.Value&quot; /&gt; property equal to.">
        <see cref="T:System.Object" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> doit être égale.</param>
      <param name="type" vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property equal to.">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ConstantExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Constant&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.ConstantExpression.Value&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.ConstantExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> et <see cref="P:System.Linq.Expressions.Expression.Type" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;type&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="type" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and &lt;paramref name=&quot;type&quot; /&gt; is not assignable from the dynamic type of &lt;paramref name=&quot;value&quot; /&gt;.">
        <paramref name="value" /> n'est pas <see langword="null" /> et <paramref name="type" /> ne peut pas être assigné à partir du type dynamique de <paramref name="value" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; representing a continue statement.">Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Continue.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; will jump to.">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; with &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Kind&quot; /&gt; equal to Continue, the &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Target&quot; /&gt; property set to &lt;paramref name=&quot;target&quot; /&gt;, and a null value to be passed to the target label upon jumping.">
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Continue, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et une valeur null à passer à l'étiquette cible au moment du saut.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; representing a continue statement with the specified type.">Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Continue avec le type spécifié.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; will jump to.">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="type" vsli:raw="An &lt;see cref=&quot;T:System.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property equal to.">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; with &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Kind&quot; /&gt; equal to Continue, the &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Target&quot; /&gt; property set to &lt;paramref name=&quot;target&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property set to &lt;paramref name=&quot;type&quot; /&gt;, and a null value to be passed to the target label upon jumping.">
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Continue, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" />, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et une valeur null à passer à l'étiquette cible au moment du saut.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents a type conversion operation.">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de conversion de type.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="type" vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property equal to.">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Convert&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.Expression.Type" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; or &lt;paramref name=&quot;type&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> ou <paramref name="type" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="No conversion operator is defined between &lt;paramref name=&quot;expression&quot; /&gt;.Type and &lt;paramref name=&quot;type&quot; /&gt;.">Aucun opérateur de conversion n'est défini entre <paramref name="expression" />.Type et <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents a conversion operation for which the implementing method is specified.">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de conversion pour laquelle la méthode d'implémentation est spécifiée.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="type" vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property equal to.">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Convert&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> et <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; or &lt;paramref name=&quot;type&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> ou <paramref name="type" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly one argument.">
        <paramref name="method" /> n'est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas un argument exactement.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="No conversion operator is defined between &lt;paramref name=&quot;expression&quot; /&gt;.Type and &lt;paramref name=&quot;type&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;expression&quot; /&gt;.Type is not assignable to the argument type of the method represented by &lt;paramref name=&quot;method&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The return type of the method represented by &lt;paramref name=&quot;method&quot; /&gt; is not assignable to &lt;paramref name=&quot;type&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;expression&quot; /&gt;.Type or &lt;paramref name=&quot;type&quot; /&gt; is a nullable value type and the corresponding non-nullable value type does not equal the argument type or the return type, respectively, of the method represented by &lt;paramref name=&quot;method&quot; /&gt;.">Aucun opérateur de conversion n'est défini entre <paramref name="expression" />.Type et <paramref name="type" />.  

ou - 
<paramref name="expression" />.Type ne peut pas être assigné au type d'argument de la méthode représentée par <paramref name="method" />.  

ou 
Le type de retour de la méthode représentée par <paramref name="method" /> ne peut pas être assigné à <paramref name="type" />.  

ou - 
<paramref name="expression" />.Type ou <paramref name="type" /> est un type valeur Nullable et le type valeur autre que Nullable correspondant n'est pas égal au type d'argument ou au type de retour, respectivement, de la méthode représentée par <paramref name="method" />.</exception>
      <exception cref="T:System.Reflection.AmbiguousMatchException" vsli:raw="More than one method that matches the &lt;paramref name=&quot;method&quot; /&gt; description was found.">Plusieurs méthodes correspondant à la description <paramref name="method" /> ont été trouvées.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents a conversion operation that throws an exception if the target type is overflowed.">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de conversion qui lève une exception en cas de dépassement du type cible.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="type" vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property equal to.">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ConvertChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.Expression.Type" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; or &lt;paramref name=&quot;type&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> ou <paramref name="type" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="No conversion operator is defined between &lt;paramref name=&quot;expression&quot; /&gt;.Type and &lt;paramref name=&quot;type&quot; /&gt;.">Aucun opérateur de conversion n'est défini entre <paramref name="expression" />.Type et <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents a conversion operation that throws an exception if the target type is overflowed and for which the implementing method is specified.">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de conversion qui lève une exception en cas de dépassement du type cible et pour lequel la méthode d'implémentation est spécifiée.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="type" vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property equal to.">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ConvertChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> et <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; or &lt;paramref name=&quot;type&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> ou <paramref name="type" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly one argument.">
        <paramref name="method" /> n'est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas un argument exactement.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="No conversion operator is defined between &lt;paramref name=&quot;expression&quot; /&gt;.Type and &lt;paramref name=&quot;type&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;expression&quot; /&gt;.Type is not assignable to the argument type of the method represented by &lt;paramref name=&quot;method&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The return type of the method represented by &lt;paramref name=&quot;method&quot; /&gt; is not assignable to &lt;paramref name=&quot;type&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;expression&quot; /&gt;.Type or &lt;paramref name=&quot;type&quot; /&gt; is a nullable value type and the corresponding non-nullable value type does not equal the argument type or the return type, respectively, of the method represented by &lt;paramref name=&quot;method&quot; /&gt;.">Aucun opérateur de conversion n'est défini entre <paramref name="expression" />.Type et <paramref name="type" />.  
ou 
 <paramref name="expression" />.Type ne peut pas être assigné au type d'argument de la méthode représentée par <paramref name="method" />.  

ou - 
Le type de retour de la méthode représentée par <paramref name="method" /> ne peut pas être assigné à <paramref name="type" />.  

ou 
 <paramref name="expression" />.Type ou <paramref name="type" /> est un type valeur Nullable et le type valeur autre que Nullable correspondant n'est pas égal au type d'argument ou au type de retour, respectivement, de la méthode représentée par <paramref name="method" />.</exception>
      <exception cref="T:System.Reflection.AmbiguousMatchException" vsli:raw="More than one method that matches the &lt;paramref name=&quot;method&quot; /&gt; description was found.">Plusieurs méthodes correspondant à la description <paramref name="method" /> ont été trouvées.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DebugInfo(System.Linq.Expressions.SymbolDocumentInfo,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DebugInfoExpression&quot; /&gt; with the specified span.">Crée un <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> avec l'étendue spécifiée.</summary>
      <param name="document" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.SymbolDocumentInfo&quot; /&gt; that represents the source file.">
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> qui représente le fichier source.</param>
      <param name="startLine" vsli:raw="The start line of this &lt;see cref=&quot;T:System.Linq.Expressions.DebugInfoExpression&quot; /&gt;. Must be greater than 0.">Ligne de début de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Doit être supérieure à 0.</param>
      <param name="startColumn" vsli:raw="The start column of this &lt;see cref=&quot;T:System.Linq.Expressions.DebugInfoExpression&quot; /&gt;. Must be greater than 0.">Colonne de début de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Doit être supérieure à 0.</param>
      <param name="endLine" vsli:raw="The end line of this &lt;see cref=&quot;T:System.Linq.Expressions.DebugInfoExpression&quot; /&gt;. Must be greater or equal than the start line.">Ligne de fin de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Doit être supérieure ou égale à la ligne de début.</param>
      <param name="endColumn" vsli:raw="The end column of this &lt;see cref=&quot;T:System.Linq.Expressions.DebugInfoExpression&quot; /&gt;. If the end line is the same as the start line, it must be greater or equal than the start column. In any case, must be greater than 0.">Colonne de fin de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Si la ligne de fin est la même que la ligne de début, elle doit être supérieure ou égale à la colonne de début. Dans tous les cas, elle doit être supérieure à 0.</param>
      <returns vsli:raw="An instance of &lt;see cref=&quot;T:System.Linq.Expressions.DebugInfoExpression&quot; /&gt;.">Instance de <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the decrementing of the expression by 1.">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente la décrémentation de l'expression par 1.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to decrement.">
        <see cref="T:System.Linq.Expressions.Expression" /> à décrémenter.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the decremented expression.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression décrémentée.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the decrementing of the expression by 1.">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente la décrémentation de l'expression par 1.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to decrement.">
        <see cref="T:System.Linq.Expressions.Expression" /> à décrémenter.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the implementing method.">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the decremented expression.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression décrémentée.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Default(System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DefaultExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property set to the specified type.">Crée un <see cref="T:System.Linq.Expressions.DefaultExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> a le type spécifié.</summary>
      <param name="type" vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property equal to.">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DefaultExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Default&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property set to the specified type.">
        <see cref="T:System.Linq.Expressions.DefaultExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> et dont la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> a la valeur spécifiée.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an arithmetic division operation.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de division arithmétique.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property to.">
        <see cref="T:System.Linq.Expressions.Expression" /> à affecter à la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property to.">
        <see cref="T:System.Linq.Expressions.Expression" /> à affecter à la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Divide&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The division operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">L'opérateur de division n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an arithmetic division operation. The implementing method can be specified.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de division arithmétique. La méthode d'implémentation peut être spécifiée.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Divide&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the division operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> est <see langword="null" /> et l’opérateur de division n’est pas défini pour les types <paramref name="left" />. et <paramref name="right" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a division assignment operation that does not have overflow checking.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de division qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.DivideAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a division assignment operation that does not have overflow checking.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de division qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.DivideAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a division assignment operation that does not have overflow checking.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de division qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.DivideAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;.">Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</summary>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">Classeur de runtime de l'opération dynamique.</param>
      <param name="returnType" vsli:raw="The result type of the dynamic expression.">Type de résultat de l'expression dynamique.</param>
      <param name="arguments" vsli:raw="The arguments to the dynamic operation.">Arguments de l’opération dynamique.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt; and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;.">Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</summary>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">Classeur de runtime de l'opération dynamique.</param>
      <param name="returnType" vsli:raw="The result type of the dynamic expression.">Type de résultat de l'expression dynamique.</param>
      <param name="arg0" vsli:raw="The first argument to the dynamic operation.">Premier argument de l’opération dynamique.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt; and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;.">Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</summary>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">Classeur de runtime de l'opération dynamique.</param>
      <param name="returnType" vsli:raw="The result type of the dynamic expression.">Type de résultat de l'expression dynamique.</param>
      <param name="arg0" vsli:raw="The first argument to the dynamic operation.">Premier argument de l’opération dynamique.</param>
      <param name="arg1" vsli:raw="The second argument to the dynamic operation.">Deuxième argument de l'opération dynamique.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt; and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;.">Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</summary>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">Classeur de runtime de l'opération dynamique.</param>
      <param name="returnType" vsli:raw="The result type of the dynamic expression.">Type de résultat de l'expression dynamique.</param>
      <param name="arg0" vsli:raw="The first argument to the dynamic operation.">Premier argument de l’opération dynamique.</param>
      <param name="arg1" vsli:raw="The second argument to the dynamic operation.">Deuxième argument de l'opération dynamique.</param>
      <param name="arg2" vsli:raw="The third argument to the dynamic operation.">Troisième argument de l'opération dynamique.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt; and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;.">Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</summary>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">Classeur de runtime de l'opération dynamique.</param>
      <param name="returnType" vsli:raw="The result type of the dynamic expression.">Type de résultat de l'expression dynamique.</param>
      <param name="arg0" vsli:raw="The first argument to the dynamic operation.">Premier argument de l’opération dynamique.</param>
      <param name="arg1" vsli:raw="The second argument to the dynamic operation.">Deuxième argument de l'opération dynamique.</param>
      <param name="arg2" vsli:raw="The third argument to the dynamic operation.">Troisième argument de l'opération dynamique.</param>
      <param name="arg3" vsli:raw="The fourth argument to the dynamic operation.">Quatrième argument de l’opération dynamique.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt; and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;.">Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</summary>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">Classeur de runtime de l'opération dynamique.</param>
      <param name="returnType" vsli:raw="The result type of the dynamic expression.">Type de résultat de l'expression dynamique.</param>
      <param name="arguments" vsli:raw="The arguments to the dynamic operation.">Arguments de l’opération dynamique.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt; and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt;, given an &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; as the second argument.">Crée un <see cref="T:System.Linq.Expressions.ElementInit" />, à partir d'un <see cref="T:System.Collections.Generic.IEnumerable`1" /> comme deuxième argument.</summary>
      <param name="addMethod" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ElementInit.AddMethod&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> doit être égale.</param>
      <param name="arguments" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to set the &lt;see cref=&quot;P:System.Linq.Expressions.ElementInit.Arguments&quot; /&gt; property equal to.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> doit être égale.</param>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.ElementInit.AddMethod&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.ElementInit.Arguments&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.ElementInit" /> dont les propriétés <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> et <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;addMethod&quot; /&gt; or &lt;paramref name=&quot;arguments&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="addMethod" /> ou <paramref name="arguments" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The method that &lt;paramref name=&quot;addMethod&quot; /&gt; represents is not named &quot;Add&quot; (case insensitive).  &#xA;  &#xA; -or-  &#xA;  &#xA; The method that &lt;paramref name=&quot;addMethod&quot; /&gt; represents is not an instance method.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;arguments&quot; /&gt; does not contain the same number of elements as the number of parameters for the method that &lt;paramref name=&quot;addMethod&quot; /&gt; represents.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of one or more elements of &lt;paramref name=&quot;arguments&quot; /&gt; is not assignable to the type of the corresponding parameter of the method that &lt;paramref name=&quot;addMethod&quot; /&gt; represents.">La méthode représentée par <paramref name="addMethod" /> n’est pas nommée « Add » (non-respect de la casse).  

ou - 
La méthode représentée par <paramref name="addMethod" /> n’est pas une méthode d’instance.  

ou - 
Le nombre d’éléments que contient <paramref name="arguments" /> ne correspond pas au nombre de paramètres de la méthode représentée par <paramref name="addMethod" />.  


ou 
La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d’un ou plusieurs éléments de <paramref name="arguments" /> n’est pas affectable au type du paramètre correspondant de la méthode représentée par <paramref name="addMethod" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt;, given an array of values as the second argument.">Crée un <see cref="T:System.Linq.Expressions.ElementInit" />, à partir d'un tableau de valeurs comme deuxième argument.</summary>
      <param name="addMethod" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ElementInit.AddMethod&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> doit être égale.</param>
      <param name="arguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to set the &lt;see cref=&quot;P:System.Linq.Expressions.ElementInit.Arguments&quot; /&gt; property equal to.">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> doit être égale.</param>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.ElementInit.AddMethod&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.ElementInit.Arguments&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.ElementInit" /> dont les propriétés <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> et <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;addMethod&quot; /&gt; or &lt;paramref name=&quot;arguments&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="addMethod" /> ou <paramref name="arguments" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The method that addMethod represents is not named &quot;Add&quot; (case insensitive).  &#xA;  &#xA; -or-  &#xA;  &#xA; The method that addMethod represents is not an instance method.  &#xA;  &#xA; -or-  &#xA;  &#xA; arguments does not contain the same number of elements as the number of parameters for the method that addMethod represents.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of one or more elements of &lt;paramref name=&quot;arguments&quot; /&gt; is not assignable to the type of the corresponding parameter of the method that &lt;paramref name=&quot;addMethod&quot; /&gt; represents.">La méthode représentée par addMethod n'est pas nommée "Add" (non respect de la casse).  

ou - 
La méthode représentée par addMethod n'est pas une méthode d'instance.  

ou 
arguments ne contient pas le même nombre d'éléments que le nombre de paramètres pour la méthode représentée par addMethod.  
ou 
La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d’un ou plusieurs éléments de <paramref name="arguments" /> n’est pas affectable au type du paramètre correspondant de la méthode représentée par <paramref name="addMethod" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Empty">
      <summary vsli:raw="Creates an empty expression that has &lt;see cref=&quot;T:System.Void&quot; /&gt; type.">Crée une expression vide qui a le type <see cref="T:System.Void" />.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DefaultExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Default&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property set to &lt;see cref=&quot;T:System.Void&quot; /&gt;.">
        <see cref="T:System.Linq.Expressions.DefaultExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> et la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> est égale à <see cref="T:System.Void" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an equality comparison.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison d'égalité.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Equal&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The equality operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">L'opérateur d'égalité n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an equality comparison. The implementing method can be specified.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison d'égalité. La méthode d'implémentation peut être spécifiée.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="liftToNull" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt; to &lt;see langword=&quot;true&quot; /&gt;; &lt;see langword=&quot;false&quot; /&gt; to set &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt; to &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="true" /> ; <see langword="false" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="false" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Equal&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the equality operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> est <see langword="null" /> et l'opérateur d'égalité n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise &lt;see langword=&quot;XOR&quot; /&gt; operation, using &lt;c&gt;op_ExclusiveOr&lt;/c&gt; for user-defined types.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d’assignation <see langword="XOR" /> au niveau du bit, en utilisant <c>op_ExclusiveOr</c> pour les types définis par l’utilisateur.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ExclusiveOr&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &lt;see langword=&quot;XOR&quot; /&gt; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">L'opérateur <see langword="XOR" /> n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise &lt;see langword=&quot;XOR&quot; /&gt; operation, using &lt;c&gt;op_ExclusiveOr&lt;/c&gt; for user-defined types. The implementing method can be specified.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d’assignation <see langword="XOR" /> au niveau du bit, en utilisant <c>op_ExclusiveOr</c> pour les types définis par l’utilisateur. La méthode d'implémentation peut être spécifiée.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ExclusiveOr&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the &lt;see langword=&quot;XOR&quot; /&gt; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> est <see langword="null" /> et l’opérateur <see langword="XOR" /> n’est pas défini pour les types <paramref name="left" />.et <paramref name="right" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise XOR assignment operation, using &lt;c&gt;op_ExclusiveOr&lt;/c&gt; for user-defined types.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d’assignation XOR au niveau du bit, en utilisant <c>op_ExclusiveOr</c> pour les types définis par l’utilisateur.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise XOR assignment operation, using &lt;c&gt;op_ExclusiveOr&lt;/c&gt; for user-defined types.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d’assignation XOR au niveau du bit, en utilisant <c>op_ExclusiveOr</c> pour les types définis par l’utilisateur.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise XOR assignment operation, using &lt;c&gt;op_ExclusiveOr&lt;/c&gt; for user-defined types.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d’assignation XOR au niveau du bit, en utilisant <c>op_ExclusiveOr</c> pour les types définis par l’utilisateur.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Reflection.FieldInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt; that represents accessing a field.">Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à un champ.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Expression&quot; /&gt; property equal to. For &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), &lt;paramref name=&quot;expression&quot; /&gt; must be &lt;see langword=&quot;null&quot; /&gt;.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> doit être égale. Pour <see langword="static" /> (<see langword="Shared" /> en Visual Basic), <paramref name="expression" /> doit être <see langword="null" />.</param>
      <param name="field" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.FieldInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Member&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.FieldInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.MemberAccess&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Expression&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Member&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.MemberExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> et <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;field&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The field represented by &lt;paramref name=&quot;field&quot; /&gt; is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic) and &lt;paramref name=&quot;expression&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="field" /> a la valeur <see langword="null" />.  

ou - 
Le champ représenté par <paramref name="field" /> n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) et <paramref name="expression" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt;.Type is not assignable to the declaring type of the field represented by &lt;paramref name=&quot;field&quot; /&gt;.">
        <paramref name="expression" />.Type ne peut pas être assigné au type de déclaration du champ représenté par <paramref name="field" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.String)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt; that represents accessing a field given the name of the field.">Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à un champ à partir du nom du champ.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; whose &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; contains a field named &lt;paramref name=&quot;fieldName&quot; /&gt;. This can be null for static fields.">
        <see cref="T:System.Linq.Expressions.Expression" /> dont <see cref="P:System.Linq.Expressions.Expression.Type" /> contient un champ nommé <paramref name="fieldName" />. Cette valeur peut être null pour les champs statiques.</param>
      <param name="fieldName" vsli:raw="The name of a field to be accessed.">Nom d'un champ auquel accéder.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.MemberAccess&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Expression&quot; /&gt; property set to &lt;paramref name=&quot;expression&quot; /&gt;, and the &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Member&quot; /&gt; property set to the &lt;see cref=&quot;T:System.Reflection.FieldInfo&quot; /&gt; that represents the field denoted by &lt;paramref name=&quot;fieldName&quot; /&gt;.">
        <see cref="T:System.Linq.Expressions.MemberExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, dont la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> a pour valeur <paramref name="expression" /> et dont la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> a pour valeur le <see cref="T:System.Reflection.FieldInfo" /> qui représente le champ désigné par <paramref name="fieldName" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; or &lt;paramref name=&quot;fieldName&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> ou <paramref name="fieldName" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="No field named &lt;paramref name=&quot;fieldName&quot; /&gt; is defined in &lt;paramref name=&quot;expression&quot; /&gt;.Type or its base types.">Aucun champ nommé <paramref name="fieldName" /> n'est défini dans <paramref name="expression" />.Type ou ses types de base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Type,System.String)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt; that represents accessing a field.">Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à un champ.</summary>
      <param name="expression" vsli:raw="The containing object of the field. This can be null for static fields.">Objet conteneur du champ. Cette valeur peut être null pour les champs statiques.</param>
      <param name="type" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; that contains the field.">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> qui contient le champ.</param>
      <param name="fieldName" vsli:raw="The field to be accessed.">Champ auquel accéder.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt;.">Élément <see cref="T:System.Linq.Expressions.MemberExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetActionType(System.Type[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents a generic &lt;see cref=&quot;T:System.Action&quot; /&gt; delegate type that has specific type arguments.">Crée un objet <see cref="T:System.Type" /> qui représente un type délégué <c>System.Action</c> générique ayant des arguments de type spécifiques.</summary>
      <param name="typeArgs" vsli:raw="An array of up to sixteen &lt;see cref=&quot;T:System.Type&quot; /&gt; objects that specify the type arguments for the &lt;see cref=&quot;T:System.Action&quot; /&gt; delegate type.">Tableau contenant jusqu’à seize objets <see cref="T:System.Type" /> qui spécifient les arguments de type pour le type délégué <see langword="System.Action" />.</param>
      <returns vsli:raw="The type of a &lt;see cref=&quot;T:System.Action&quot; /&gt; delegate that has the specified type arguments.">Type d’un délégué <c>System.Action</c> qui a les arguments de type spécifiés.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;typeArgs&quot; /&gt; contains more than sixteen elements.">
        <paramref name="typeArgs" /> contient plus de seize éléments.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;typeArgs&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="typeArgs" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetDelegateType(System.Type[])">
      <summary vsli:raw="Gets a &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; object that represents a generic &lt;see cref=&quot;T:System.Func`1&quot; /&gt; or &lt;see cref=&quot;T:System.Action&quot; /&gt; delegate type that has specific type arguments.">Obtient un objet <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente un type délégué <c>System.Func</c> ou <c>System.Action</c> générique ayant des arguments de type spécifiques.</summary>
      <param name="typeArgs" vsli:raw="The type arguments of the delegate.">Arguments de type du délégué.</param>
      <returns vsli:raw="The delegate type.">Type de délégué.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetFuncType(System.Type[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; object that represents a generic &lt;see cref=&quot;T:System.Func`1&quot; /&gt; delegate type that has specific type arguments. The last type argument specifies the return type of the created delegate.">Crée un objet <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente un type délégué <c>System.Func</c> générique ayant des arguments de type spécifiques. Le dernier argument de type spécifie le type de retour du délégué créé.</summary>
      <param name="typeArgs" vsli:raw="An array of one to seventeen &lt;see cref=&quot;T:System.Type&quot; /&gt; objects that specify the type arguments for the &lt;see langword=&quot;System.Func&quot; /&gt; delegate type.">Tableau contenant entre un et dix-sept objets <see cref="T:System.Type" /> qui spécifient les arguments de type pour le type délégué <see langword="System.Func" />.</param>
      <returns vsli:raw="The type of a &lt;see cref=&quot;T:System.Func`1&quot; /&gt; delegate that has the specified type arguments.">Type d’un délégué <c>System.Func</c> qui a les arguments de type spécifiés.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;typeArgs&quot; /&gt; contains fewer than one or more than seventeen elements.">
        <paramref name="typeArgs" /> contient moins d'un élément ou plus de dix sept éléments.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;typeArgs&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="typeArgs" /> est <see langword="null" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; representing a &quot;go to&quot; statement.">Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction GoTo.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; will jump to.">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; with &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Kind&quot; /&gt; equal to Goto, the &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Target&quot; /&gt; property set to the specified value, and a null value to be passed to the target label upon jumping.">
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à GoTo, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à la valeur spécifiée et une valeur Null à passer à l'étiquette cible au moment du saut.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; representing a &quot;go to&quot; statement. The value passed to the label upon jumping can be specified.">Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction GoTo. La valeur passée à l'étiquette au moment du saut peut être spécifiée.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; will jump to.">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="value" vsli:raw="The value that will be passed to the associated label upon jumping.">Valeur qui sera passée à l'étiquette associée au moment du saut.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; with &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Kind&quot; /&gt; equal to Goto, the &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Target&quot; /&gt; property set to &lt;paramref name=&quot;target&quot; /&gt;, and &lt;paramref name=&quot;value&quot; /&gt; to be passed to the target label upon jumping.">
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à GoTo, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; representing a &quot;go to&quot; statement with the specified type. The value passed to the label upon jumping can be specified.">Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction GoTo avec le type spécifié. La valeur passée à l'étiquette au moment du saut peut être spécifiée.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; will jump to.">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="value" vsli:raw="The value that will be passed to the associated label upon jumping.">Valeur qui sera passée à l'étiquette associée au moment du saut.</param>
      <param name="type" vsli:raw="An &lt;see cref=&quot;T:System.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property equal to.">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; with &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Kind&quot; /&gt; equal to Goto, the &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Target&quot; /&gt; property set to &lt;paramref name=&quot;target&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property set to &lt;paramref name=&quot;type&quot; /&gt;, and &lt;paramref name=&quot;value&quot; /&gt; to be passed to the target label upon jumping.">
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à GoTo, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" />, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; representing a &quot;go to&quot; statement with the specified type.">Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction GoTo avec le type spécifié.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; will jump to.">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="type" vsli:raw="An &lt;see cref=&quot;T:System.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property equal to.">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; with &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Kind&quot; /&gt; equal to Goto, the &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Target&quot; /&gt; property set to the specified value, the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property set to &lt;paramref name=&quot;type&quot; /&gt;, and a null value to be passed to the target label upon jumping.">
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à GoTo, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à la valeur spécifiée, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et une valeur Null à passer à l'étiquette cible au moment du saut.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a &quot;greater than&quot; numeric comparison.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique « supérieur à ».</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.GreaterThan&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &quot;greater than&quot; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">L'opérateur "supérieur à" n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a &quot;greater than&quot; numeric comparison. The implementing method can be specified.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique « supérieur à ». La méthode d'implémentation peut être spécifiée.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="liftToNull" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt; to &lt;see langword=&quot;true&quot; /&gt;; &lt;see langword=&quot;false&quot; /&gt; to set &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt; to &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="true" /> ; <see langword="false" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="false" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.GreaterThan&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the &quot;greater than&quot; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> est <see langword="null" /> et l'opérateur "supérieur à" n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a &quot;greater than or equal&quot; numeric comparison.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique « supérieur ou égal à ».</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &quot;greater than or equal&quot; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">L'opérateur "supérieur ou égal à" n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a &quot;greater than or equal&quot; numeric comparison.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique « supérieur ou égal à ».</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="liftToNull" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt; to &lt;see langword=&quot;true&quot; /&gt;; &lt;see langword=&quot;false&quot; /&gt; to set &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt; to &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="true" /> ; <see langword="false" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="false" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the &quot;greater than or equal&quot; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> est <see langword="null" /> et l’opérateur “supérieur à ou égal à” n'est pas défini pour les types <paramref name="left" />et <paramref name="right" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.ConditionalExpression&quot; /&gt; that represents a conditional block with an &lt;see langword=&quot;if&quot; /&gt; statement.">Crée un <see cref="T:System.Linq.Expressions.ConditionalExpression" /> qui représente un bloc conditionnel avec une instruction <see langword="if" />.</summary>
      <param name="test" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.Test&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> doit être égale.</param>
      <param name="ifTrue" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfTrue&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ConditionalExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Conditional&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.Test&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfTrue&quot; /&gt;, properties set to the specified values. The &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfFalse&quot; /&gt; property is set to default expression and the type of the resulting &lt;see cref=&quot;T:System.Linq.Expressions.ConditionalExpression&quot; /&gt; returned by this method is &lt;see cref=&quot;T:System.Void&quot; /&gt;.">
        <see cref="T:System.Linq.Expressions.ConditionalExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> et <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> ont les valeurs spécifiées. Propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> ayant pour valeur l'expression par défaut et dont le type du <see cref="T:System.Linq.Expressions.ConditionalExpression" /> résultant retourné par cette méthode est <see cref="T:System.Void" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.ConditionalExpression&quot; /&gt; that represents a conditional block with &lt;see langword=&quot;if&quot; /&gt; and &lt;see langword=&quot;else&quot; /&gt; statements.">Crée un <see cref="T:System.Linq.Expressions.ConditionalExpression" /> qui représente un bloc conditionnel avec des instructions <see langword="if" /> et <see langword="else" />.</summary>
      <param name="test" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.Test&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> doit être égale.</param>
      <param name="ifTrue" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfTrue&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> doit être égale.</param>
      <param name="ifFalse" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfFalse&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ConditionalExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Conditional&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.Test&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfTrue&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfFalse&quot; /&gt; properties set to the specified values. The type of the resulting &lt;see cref=&quot;T:System.Linq.Expressions.ConditionalExpression&quot; /&gt; returned by this method is &lt;see cref=&quot;T:System.Void&quot; /&gt;.">
        <see cref="T:System.Linq.Expressions.ConditionalExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> et <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> ont les valeurs spécifiées. Le type du <see cref="T:System.Linq.Expressions.ConditionalExpression" /> résultant retourné par cette méthode est <see cref="T:System.Void" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the incrementing of the expression value by 1.">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'incrémentation de la valeur de l'expression par 1.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to increment.">
        <see cref="T:System.Linq.Expressions.Expression" /> à incrémenter.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the incremented expression.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression incrémentée.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the incrementing of the expression by 1.">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'incrémentation de l'expression par 1.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to increment.">
        <see cref="T:System.Linq.Expressions.Expression" /> à incrémenter.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the implementing method.">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the incremented expression.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression incrémentée.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Linq.Expressions.InvocationExpression&quot; /&gt; that applies a delegate or lambda expression to a list of argument expressions.">Crée un <see cref="T:System.Linq.Expressions.InvocationExpression" /> qui applique un délégué ou une expression lambda à une liste d'expressions d'arguments.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the delegate or lambda expression to be applied to.">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'expression lambda ou le délégué auquel appliquer.</param>
      <param name="arguments" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects that represent the arguments that the delegate or lambda expression is applied to.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> représentant les arguments auxquels le délégué ou l'expression lambda sont appliqués.</param>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.InvocationExpression&quot; /&gt; that applies the specified delegate or lambda expression to the provided arguments.">
        <see cref="T:System.Linq.Expressions.InvocationExpression" /> qui applique le délégué ou l’expression lambda spécifiés aux arguments fournis.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt;.Type does not represent a delegate type or an &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of an element of &lt;paramref name=&quot;arguments&quot; /&gt; is not assignable to the type of the corresponding parameter of the delegate represented by &lt;paramref name=&quot;expression&quot; /&gt;.">
        <paramref name="expression" />.Type ne représente pas un type délégué ou un <see cref="T:System.Linq.Expressions.Expression`1" />.  

ou - 
La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="arguments" /> ne peut pas être assignée au type du paramètre correspondant du délégué représenté par <paramref name="expression" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;arguments&quot; /&gt; does not contain the same number of elements as the list of parameters for the delegate represented by &lt;paramref name=&quot;expression&quot; /&gt;.">
        <paramref name="arguments" /> ne contient pas le même nombre d'éléments que la liste de paramètres pour le délégué représenté par <paramref name="expression" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Linq.Expressions.InvocationExpression&quot; /&gt; that applies a delegate or lambda expression to a list of argument expressions.">Crée un <see cref="T:System.Linq.Expressions.InvocationExpression" /> qui applique un délégué ou une expression lambda à une liste d'expressions d'arguments.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the delegate or lambda expression to be applied.">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le délégué ou l’expression lambda à appliquer.</param>
      <param name="arguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects that represent the arguments that the delegate or lambda expression is applied to.">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> qui représentent les arguments auxquels le délégué ou l'expression lambda est appliquée.</param>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.InvocationExpression&quot; /&gt; that applies the specified delegate or lambda expression to the provided arguments.">
        <see cref="T:System.Linq.Expressions.InvocationExpression" /> qui applique le délégué ou l’expression lambda spécifiés aux arguments fournis.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt;.Type does not represent a delegate type or an &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of an element of &lt;paramref name=&quot;arguments&quot; /&gt; is not assignable to the type of the corresponding parameter of the delegate represented by &lt;paramref name=&quot;expression&quot; /&gt;.">
        <paramref name="expression" />.Type ne représente pas un type délégué ou un <see cref="T:System.Linq.Expressions.Expression`1" />.  

ou - 
La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="arguments" /> ne peut pas être assignée au type du paramètre correspondant du délégué représenté par <paramref name="expression" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;arguments&quot; /&gt; does not contain the same number of elements as the list of parameters for the delegate represented by &lt;paramref name=&quot;expression&quot; /&gt;.">
        <paramref name="arguments" /> ne contient pas le même nombre d'éléments que la liste de paramètres pour le délégué représenté par <paramref name="expression" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Returns whether the expression evaluates to false.">Indique si l'expression prend la valeur false.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to evaluate.">
        <see cref="T:System.Linq.Expressions.Expression" /> à évaluer.</param>
      <returns vsli:raw="An instance of &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt;.">Instance de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Returns whether the expression evaluates to false.">Indique si l'expression prend la valeur false.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to evaluate.">
        <see cref="T:System.Linq.Expressions.Expression" /> à évaluer.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the implementing method.">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
      <returns vsli:raw="An instance of &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt;.">Instance de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Returns whether the expression evaluates to true.">Indique si l'expression prend la valeur true.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to evaluate.">
        <see cref="T:System.Linq.Expressions.Expression" /> à évaluer.</param>
      <returns vsli:raw="An instance of &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt;.">Instance de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Returns whether the expression evaluates to true.">Indique si l'expression prend la valeur true.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to evaluate.">
        <see cref="T:System.Linq.Expressions.Expression" /> à évaluer.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the implementing method.">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
      <returns vsli:raw="An instance of &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt;.">Instance de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; representing a label with void type and no name.">Crée un <see cref="T:System.Linq.Expressions.LabelTarget" /> qui représente une étiquette avec le type void et aucun nom.</summary>
      <returns vsli:raw="The new &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt;.">Nouvelle <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LabelExpression&quot; /&gt; representing a label without a default value.">Crée un <see cref="T:System.Linq.Expressions.LabelExpression" /> qui représente une étiquette sans valeur par défaut.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; which this &lt;see cref=&quot;T:System.Linq.Expressions.LabelExpression&quot; /&gt; will be associated with.">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.LabelExpression" /> sera associé.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LabelExpression&quot; /&gt; without a default value.">
        <see cref="T:System.Linq.Expressions.LabelExpression" /> sans valeur par défaut.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LabelExpression&quot; /&gt; representing a label with the given default value.">Crée un <see cref="T:System.Linq.Expressions.LabelExpression" /> qui représente une étiquette avec la valeur par défaut donnée.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; which this &lt;see cref=&quot;T:System.Linq.Expressions.LabelExpression&quot; /&gt; will be associated with.">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.LabelExpression" /> sera associé.</param>
      <param name="defaultValue" vsli:raw="The value of this &lt;see cref=&quot;T:System.Linq.Expressions.LabelExpression&quot; /&gt; when the label is reached through regular control flow.">Valeur de ce <see cref="T:System.Linq.Expressions.LabelExpression" /> lorsque l'étiquette est atteinte via un flux de contrôle normal.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LabelExpression&quot; /&gt; with the given default value.">
        <see cref="T:System.Linq.Expressions.LabelExpression" /> avec la valeur par défaut donnée.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.String)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; representing a label with void type and the given name.">Crée un <see cref="T:System.Linq.Expressions.LabelTarget" /> représentant une étiquette avec le type void et le nom donné.</summary>
      <param name="name" vsli:raw="The name of the label.">Nom de l'étiquette.</param>
      <returns vsli:raw="The new &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt;.">Nouvelle <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; representing a label with the given type.">Crée un <see cref="T:System.Linq.Expressions.LabelTarget" /> représentant une étiquette avec le type donné.</summary>
      <param name="type" vsli:raw="The type of value that is passed when jumping to the label.">Type de valeur passée lors de l'accès à l'étiquette.</param>
      <returns vsli:raw="The new &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt;.">Nouvelle <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Type,System.String)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; representing a label with the given type and name.">Crée un <see cref="T:System.Linq.Expressions.LabelTarget" /> qui représente une étiquette avec le type et le nom donnés.</summary>
      <param name="type" vsli:raw="The type of value that is passed when jumping to the label.">Type de valeur passée lors de l'accès à l'étiquette.</param>
      <param name="name" vsli:raw="The name of the label.">Nom de l'étiquette.</param>
      <returns vsli:raw="The new &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt;.">Nouvelle <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; by first constructing a delegate type from the expression body, a parameter that indicates whether tail call optimization will be applied, and an enumerable collection of parameter expressions. It can be used when the delegate type is not known at compile time.">Crée un <see cref="T:System.Linq.Expressions.LambdaExpression" /> en commençant par construire un type de délégué à partir du corps d’expression, un paramètre qui indique si l’optimisation d’appel tail est appliquée et une collection énumérable d’expressions de paramètre. Peut être utilisé lorsque le type délégué n'est pas connu au moment de la compilation.</summary>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="tailCall" vsli:raw="A &lt;see cref=&quot;T:System.Boolean&quot; /&gt; that indicates if tail call optimization will be applied when compiling the created expression.">
        <see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée.</param>
      <param name="parameters" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.NodeType&quot; /&gt; property equal to Lambda and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; by first constructing a delegate type from the expression body, a parameter that indicates whether tail call optimization will be applied, and an array of parameter expressions. It can be used when the delegate type is not known at compile time.">Crée un <see cref="T:System.Linq.Expressions.LambdaExpression" /> en commençant par construire un type de délégué à partir du corps d’expression, un paramètre qui indique si l’optimisation d’appel tail est appliquée et un tableau d’expressions de paramètre. Peut être utilisé lorsque le type délégué n'est pas connu au moment de la compilation.</summary>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="tailCall" vsli:raw="A &lt;see cref=&quot;T:System.Boolean&quot; /&gt; that indicates if tail call optimization will be applied when compiling the created expression.">
        <see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée.</param>
      <param name="parameters" vsli:raw="An array that contains &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">Tableau qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.NodeType&quot; /&gt; property equal to Lambda and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; by first constructing a delegate type from the expression body, and an enumerable collection of parameter expressions. It can be used when the delegate type is not known at compile time.">Crée un <see cref="T:System.Linq.Expressions.LambdaExpression" /> en commençant par construire un type de délégué à partir du corps d’expression et une collection énumérable d’expressions de paramètre. Peut être utilisé lorsque le type délégué n'est pas connu au moment de la compilation.</summary>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="parameters" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.NodeType&quot; /&gt; property equal to Lambda and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; by first constructing a delegate type from the expression body, and an array of parameter expressions. It can be used when the delegate type is not known at compile time.">Crée un <see cref="T:System.Linq.Expressions.LambdaExpression" /> en commençant par construire un type de délégué à partir du corps d’expression et un tableau d’expressions de paramètre. Peut être utilisé lorsque le type délégué n'est pas connu au moment de la compilation.</summary>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="parameters" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">Tableau d'objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Lambda&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;body&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more elements of &lt;paramref name=&quot;parameters&quot; /&gt; are &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="body" /> a la valeur <see langword="null" />.  
ou 
Un ou plusieurs éléments de <paramref name="parameters" /> sont <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;parameters&quot; /&gt; contains more than sixteen elements.">
        <paramref name="parameters" /> contient plus de seize éléments.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; by first constructing a delegate type from the expression body, the name for the lambda, a parameter that indicates whether tail call optimization will be applied, and an enumerable collection of parameter expressions. It can be used when the delegate type is not known at compile time.">Crée un <see cref="T:System.Linq.Expressions.LambdaExpression" /> en commençant par construire un type de délégué à partir du corps d’expression, le nom de l’expression lambda, un paramètre qui indique si l’optimisation d’appel tail est appliquée et une collection énumérable d’expressions de paramètre. Peut être utilisé lorsque le type délégué n'est pas connu au moment de la compilation.</summary>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="name" vsli:raw="The name for the lambda. Used for emitting debug information.">Nom de l'expression lambda. Utilisé pour l'émission des informations de débogage.</param>
      <param name="tailCall" vsli:raw="A &lt;see cref=&quot;T:System.Boolean&quot; /&gt; that indicates if tail call optimization will be applied when compiling the created expression.">
        <see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée.</param>
      <param name="parameters" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.NodeType&quot; /&gt; property equal to Lambda and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; by first constructing a delegate type from the expression body, the name for the lambda, and an enumerable collection of parameter expressions. It can be used when the delegate type is not known at compile time.">Crée un <see cref="T:System.Linq.Expressions.LambdaExpression" /> en commençant par construire un type de délégué à partir du corps d’expression, le nom de l’expression lambda et une collection énumérable d’expressions de paramètre. Peut être utilisé lorsque le type délégué n'est pas connu au moment de la compilation.</summary>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="name" vsli:raw="The name for the lambda. Used for emitting debug information.">Nom de l'expression lambda. Utilisé pour l'émission des informations de débogage.</param>
      <param name="parameters" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.NodeType&quot; /&gt; property equal to Lambda and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; where the delegate type is known at compile time, with a parameter that indicates whether tail call optimization will be applied, and an enumerable collection of parameter expressions.">Crée un <see cref="T:System.Linq.Expressions.LambdaExpression" /> où le type de délégué est connu au moment de la compilation, avec un paramètre qui indique si l’optimisation d’appel tail est appliquée et une collection énumérable d’expressions de paramètre.</summary>
      <param name="delegateType" vsli:raw="A &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; representing the delegate signature for the lambda.">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente la signature du délégué de l'expression lambda.</param>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="tailCall" vsli:raw="A &lt;see cref=&quot;T:System.Boolean&quot; /&gt; that indicates if tail call optimization will be applied when compiling the created expression.">
        <see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée.</param>
      <param name="parameters" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.NodeType&quot; /&gt; property equal to Lambda and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; where the delegate type is known at compile time, with a parameter that indicates whether tail call optimization will be applied, and an array of parameter expressions.">Crée un <see cref="T:System.Linq.Expressions.LambdaExpression" /> où le type de délégué est connu au moment de la compilation, avec un paramètre qui indique si l’optimisation d’appel tail est appliquée et un tableau d’expressions de paramètre.</summary>
      <param name="delegateType" vsli:raw="A &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; representing the delegate signature for the lambda.">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente la signature du délégué de l'expression lambda.</param>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="tailCall" vsli:raw="A &lt;see cref=&quot;T:System.Boolean&quot; /&gt; that indicates if tail call optimization will be applied when compiling the created expression.">
        <see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée.</param>
      <param name="parameters" vsli:raw="An array that contains &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">Tableau qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.NodeType&quot; /&gt; property equal to Lambda and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; where the delegate type is known at compile time, with an enumerable collection of parameter expressions.">Crée un <see cref="T:System.Linq.Expressions.LambdaExpression" /> où le type de délégué est connu au moment de la compilation, avec une collection énumérable d’expressions de paramètre.</summary>
      <param name="delegateType" vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; that represents a delegate signature for the lambda.">
        <see cref="T:System.Type" /> qui représente une signature de délégué pour l'expression lambda.</param>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="parameters" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns vsli:raw="An object that represents a lambda expression which has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Lambda&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">Objet qui représente une expression lambda dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;delegateType&quot; /&gt; or &lt;paramref name=&quot;body&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more elements in &lt;paramref name=&quot;parameters&quot; /&gt; are &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="delegateType" /> ou <paramref name="body" /> est <see langword="null" />.  
ou 
Un ou plusieurs éléments dans <paramref name="parameters" /> sont <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;delegateType&quot; /&gt; does not represent a delegate type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;body&quot; /&gt;.Type represents a type that is not assignable to the return type of the delegate type represented by &lt;paramref name=&quot;delegateType&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;parameters&quot; /&gt; does not contain the same number of elements as the list of parameters for the delegate type represented by &lt;paramref name=&quot;delegateType&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of an element of &lt;paramref name=&quot;parameters&quot; /&gt; is not assignable from the type of the corresponding parameter type of the delegate type represented by &lt;paramref name=&quot;delegateType&quot; /&gt;.">
        <paramref name="delegateType" /> ne représente pas un type délégué.  

ou - 
<paramref name="body" />.Type représente un type qui ne peut pas être assigné au type de retour du type délégué représenté par <paramref name="delegateType" />.  

ou - 
<paramref name="parameters" /> ne contient pas le même nombre d'éléments que la liste de paramètres pour le type délégué représenté par <paramref name="delegateType" />.  

ou - 
La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="parameters" /> ne peut pas être assignée à partir du type du paramètre correspondant du type délégué représenté par <paramref name="delegateType" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; where the delegate type is known at compile time, with an array of parameter expressions.">Crée un <see cref="T:System.Linq.Expressions.LambdaExpression" /> où le type de délégué est connu au moment de la compilation, avec un tableau d’expressions de paramètre.</summary>
      <param name="delegateType" vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; that represents a delegate signature for the lambda.">
        <see cref="T:System.Type" /> qui représente une signature de délégué pour l'expression lambda.</param>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="parameters" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">Tableau d'objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns vsli:raw="An object that represents a lambda expression which has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Lambda&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">Objet qui représente une expression lambda dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;delegateType&quot; /&gt; or &lt;paramref name=&quot;body&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more elements in &lt;paramref name=&quot;parameters&quot; /&gt; are &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="delegateType" /> ou <paramref name="body" /> a la valeur <see langword="null" />.  

ou - 
Un ou plusieurs éléments dans <paramref name="parameters" /> sont <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;delegateType&quot; /&gt; does not represent a delegate type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;body&quot; /&gt;.Type represents a type that is not assignable to the return type of the delegate type represented by &lt;paramref name=&quot;delegateType&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;parameters&quot; /&gt; does not contain the same number of elements as the list of parameters for the delegate type represented by &lt;paramref name=&quot;delegateType&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of an element of &lt;paramref name=&quot;parameters&quot; /&gt; is not assignable from the type of the corresponding parameter type of the delegate type represented by &lt;paramref name=&quot;delegateType&quot; /&gt;.">
        <paramref name="delegateType" /> ne représente pas un type délégué.  

ou - 
<paramref name="body" />.Type représente un type qui ne peut pas être assigné au type de retour du type délégué représenté par <paramref name="delegateType" />.  

ou - 
<paramref name="parameters" /> ne contient pas le même nombre d'éléments que la liste de paramètres pour le type délégué représenté par <paramref name="delegateType" />.  


ou 
La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="parameters" /> ne peut pas être assignée à partir du type du paramètre correspondant du type délégué représenté par <paramref name="delegateType" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; where the delegate type is known at compile time, with the name for the lambda, a parameter that indicates whether tail call optimization will be applied, and an enumerable collection of parameter expressions.">Crée un <see cref="T:System.Linq.Expressions.LambdaExpression" /> où le type de délégué est connu au moment de la compilation, avec le nom de l’expression lambda, un paramètre qui indique si l’optimisation d’appel tail est appliquée et une collection énumérable d’expressions de paramètre.</summary>
      <param name="delegateType" vsli:raw="A &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; representing the delegate signature for the lambda.">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente la signature du délégué de l'expression lambda.</param>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="name" vsli:raw="The name for the lambda. Used for emitting debug information.">Nom de l'expression lambda. Utilisé pour l'émission des informations de débogage.</param>
      <param name="tailCall" vsli:raw="A &lt;see cref=&quot;T:System.Boolean&quot; /&gt; that indicates if tail call optimization will be applied when compiling the created expression.">
        <see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée.</param>
      <param name="parameters" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.NodeType&quot; /&gt; property equal to Lambda and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; where the delegate type is known at compile time, with the name for the lambda, and an enumerable collection of parameter expressions.">Crée un <see cref="T:System.Linq.Expressions.LambdaExpression" /> où le type de délégué est connu au moment de la compilation, avec le nom de l’expression lambda et une collection énumérable d’expressions de paramètre.</summary>
      <param name="delegateType" vsli:raw="A &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; representing the delegate signature for the lambda.">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente la signature du délégué de l'expression lambda.</param>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="name" vsli:raw="The name for the lambda. Used for emitting debug information.">Nom de l'expression lambda. Utilisé pour l'émission des informations de débogage.</param>
      <param name="parameters" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.NodeType&quot; /&gt; property equal to Lambda and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt; where the delegate type is known at compile time, with a parameter that indicates whether tail call optimization will be applied, and an enumerable collection of parameter expressions.">Crée un <see cref="T:System.Linq.Expressions.Expression`1" /> où le type de délégué est connu au moment de la compilation, avec un paramètre qui indique si l’optimisation d’appel tail est appliquée et une collection énumérable d’expressions de paramètre.</summary>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="tailCall" vsli:raw="A &lt;see cref=&quot;T:System.Boolean&quot; /&gt; that indicates if tail call optimization will be applied when compiling the created expression.">
        <see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée.</param>
      <param name="parameters" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate" vsli:raw="The delegate type.">Type de délégué.</typeparam>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Lambda&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.Expression`1" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt; where the delegate type is known at compile time, with a parameter that indicates whether tail call optimization will be applied, and an array of parameter expressions.">Crée un <see cref="T:System.Linq.Expressions.Expression`1" /> où le type de délégué est connu au moment de la compilation, avec un paramètre qui indique si l’optimisation d’appel tail est appliquée et un tableau d’expressions de paramètre.</summary>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="tailCall" vsli:raw="A &lt;see cref=&quot;T:System.Boolean&quot; /&gt; that indicates if tail call optimization will be applied when compiling the created expression.">
        <see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée.</param>
      <param name="parameters" vsli:raw="An array that contains &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">Tableau qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate" vsli:raw="The delegate type.">Type de délégué.</typeparam>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Lambda&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.Expression`1" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt; where the delegate type is known at compile time, with an enumerable collection of parameter expressions.">Crée un <see cref="T:System.Linq.Expressions.Expression`1" /> où le type de délégué est connu au moment de la compilation, avec une collection énumérable d’expressions de paramètre.</summary>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="parameters" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate" vsli:raw="A delegate type.">Type délégué.</typeparam>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Lambda&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.Expression`1" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;body&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more elements in &lt;paramref name=&quot;parameters&quot; /&gt; are &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="body" /> a la valeur <see langword="null" />.  
ou 
Un ou plusieurs éléments dans <paramref name="parameters" /> sont <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;TDelegate&quot; /&gt; is not a delegate type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;body&quot; /&gt;.Type represents a type that is not assignable to the return type of &lt;paramref name=&quot;TDelegate&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;parameters&quot; /&gt; does not contain the same number of elements as the list of parameters for &lt;paramref name=&quot;TDelegate&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of an element of &lt;paramref name=&quot;parameters&quot; /&gt; is not assignable from the type of the corresponding parameter type of &lt;paramref name=&quot;TDelegate&quot; /&gt;.">
        <paramref name="TDelegate" /> n'est pas un type délégué.  

ou - 
<paramref name="body" />.Type représente un type qui ne peut pas être assigné au type de retour de <paramref name="TDelegate" />.  

ou - 
<paramref name="parameters" /> ne contient pas le même nombre d'éléments que la liste de paramètres pour <paramref name="TDelegate" />.  

ou - 
La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="parameters" /> ne peut pas être assignée à partir du type du paramètre correspondant de <paramref name="TDelegate" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt; where the delegate type is known at compile time, with an array of parameter expressions.">Crée un <see cref="T:System.Linq.Expressions.Expression`1" /> où le type de délégué est connu au moment de la compilation, avec un tableau d’expressions de paramètre.</summary>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="parameters" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">Tableau d'objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate" vsli:raw="A delegate type.">Type délégué.</typeparam>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Lambda&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.Expression`1" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;body&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more elements in &lt;paramref name=&quot;parameters&quot; /&gt; are &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="body" /> a la valeur <see langword="null" />.  

ou - 
Un ou plusieurs éléments dans <paramref name="parameters" /> sont <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;TDelegate&quot; /&gt; is not a delegate type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;body&quot; /&gt;.Type represents a type that is not assignable to the return type of &lt;paramref name=&quot;TDelegate&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;parameters&quot; /&gt; does not contain the same number of elements as the list of parameters for &lt;paramref name=&quot;TDelegate&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of an element of &lt;paramref name=&quot;parameters&quot; /&gt; is not assignable from the type of the corresponding parameter type of &lt;paramref name=&quot;TDelegate&quot; /&gt;.">
        <paramref name="TDelegate" /> n'est pas un type délégué.  
ou 
 <paramref name="body" />.Type représente un type qui ne peut pas être assigné au type de retour de <paramref name="TDelegate" />.  

ou - 
<paramref name="parameters" /> ne contient pas le même nombre d'éléments que la liste de paramètres pour <paramref name="TDelegate" />.  

ou 
La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="parameters" /> ne peut pas être assignée à partir du type du paramètre correspondant de <paramref name="TDelegate" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt; where the delegate type is known at compile time, with the name for the lambda, a parameter that indicates whether tail call optimization will be applied, and an enumerable collection of parameter expressions.">Crée un <see cref="T:System.Linq.Expressions.Expression`1" /> où le type de délégué est connu au moment de la compilation, avec le nom de l’expression lambda, un paramètre qui indique si l’optimisation d’appel tail est appliquée et une collection énumérable d’expressions de paramètre.</summary>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="name" vsli:raw="The name of the lambda. Used for generating debugging info.">Nom de l'expression lambda. Utilisé pour la génération des informations de débogage.</param>
      <param name="tailCall" vsli:raw="A &lt;see cref=&quot;T:System.Boolean&quot; /&gt; that indicates if tail call optimization will be applied when compiling the created expression.">
        <see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée.</param>
      <param name="parameters" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate" vsli:raw="The delegate type.">Type de délégué.</typeparam>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Lambda&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.Expression`1" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt; where the delegate type is known at compile time, with the name for the lambda, and an enumerable collection of parameter expressions.">Crée un <see cref="T:System.Linq.Expressions.Expression`1" /> où le type de délégué est connu au moment de la compilation, avec le nom de l’expression lambda et une collection énumérable d’expressions de paramètre.</summary>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="name" vsli:raw="The name of the lambda. Used for generating debugging information.">Nom de l'expression lambda. Utilisé pour la génération des informations de débogage.</param>
      <param name="parameters" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate" vsli:raw="The delegate type.">Type de délégué.</typeparam>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Lambda&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.Expression`1" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise left-shift operation.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de bits de décalage vers la gauche.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.LeftShift&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The left-shift operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">L'opérateur de décalage vers la gauche n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise left-shift operation.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de bits de décalage vers la gauche.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.LeftShift&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the left-shift operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> est <see langword="null" /> et l'opérateur de décalage vers la gauche n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise left-shift assignment operation.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de décalage vers la gauche au niveau du bit.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.LeftShiftAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise left-shift assignment operation.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de décalage vers la gauche au niveau du bit.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.LeftShiftAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise left-shift assignment operation.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de décalage vers la gauche au niveau du bit.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.LeftShiftAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a &quot;less than&quot; numeric comparison.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique « inférieur à ».</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.LessThan&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &quot;less than&quot; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">L'opérateur "inférieur à" n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a &quot;less than&quot; numeric comparison.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique « inférieur à ».</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="liftToNull" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt; to &lt;see langword=&quot;true&quot; /&gt;; &lt;see langword=&quot;false&quot; /&gt; to set &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt; to &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="true" /> ; <see langword="false" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="false" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.LessThan&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the &quot;less than&quot; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> a la valeur <see langword="null" /> et l’opérateur « inférieur à » n’est pas défini pour <paramref name="left" />.Type. et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a &quot; less than or equal&quot; numeric comparison.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique « inférieur ou égal à ».</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.LessThanOrEqual&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &quot;less than or equal&quot; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">L'opérateur "inférieur ou égal à" n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a &quot;less than or equal&quot; numeric comparison.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique « inférieur ou égal à ».</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="liftToNull" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt; to &lt;see langword=&quot;true&quot; /&gt;; &lt;see langword=&quot;false&quot; /&gt; to set &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt; to &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="true" /> ; <see langword="false" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="false" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.LessThanOrEqual&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the &quot;less than or equal&quot; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> est <see langword="null" /> et l'opérateur "inférieur ou égal à" n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberListBinding&quot; /&gt; where the member is a field or property.">Crée un <see cref="T:System.Linq.Expressions.MemberListBinding" /> dans lequel le membre est un champ ou une propriété.</summary>
      <param name="member" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; that represents a field or property to set the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MemberInfo" /> qui représente un champ ou une propriété auquel la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> doit être égale.</param>
      <param name="initializers" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.MemberListBinding.Initializers&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ElementInit" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberListBinding&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.BindingType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.MemberBindingType.ListBinding&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MemberListBinding.Initializers&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.MemberListBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> et <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;member&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more elements of &lt;paramref name=&quot;initializers&quot; /&gt; are &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="member" /> est <see langword="null" />.  

ou - 
Un ou plusieurs éléments de <paramref name="initializers" /> sont <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;member&quot; /&gt; does not represent a field or property.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Reflection.FieldInfo.FieldType&quot; /&gt; or &lt;see cref=&quot;P:System.Reflection.PropertyInfo.PropertyType&quot; /&gt; of the field or property that &lt;paramref name=&quot;member&quot; /&gt; represents does not implement &lt;see cref=&quot;T:System.Collections.IEnumerable&quot; /&gt;.">
        <paramref name="member" /> ne représente pas un champ ou une propriété.  

ou - 
Le <see cref="P:System.Reflection.FieldInfo.FieldType" /> ou <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> du champ ou de la propriété que <paramref name="member" /> représente n'implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Linq.Expressions.ElementInit[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberListBinding&quot; /&gt; where the member is a field or property.">Crée un <see cref="T:System.Linq.Expressions.MemberListBinding" /> dans lequel le membre est un champ ou une propriété.</summary>
      <param name="member" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; that represents a field or property to set the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MemberInfo" /> qui représente un champ ou une propriété auquel la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> doit être égale.</param>
      <param name="initializers" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.MemberListBinding.Initializers&quot; /&gt; collection.">Tableau d'objets <see cref="T:System.Linq.Expressions.ElementInit" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberListBinding&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.BindingType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.MemberBindingType.ListBinding&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MemberListBinding.Initializers&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.MemberListBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> et <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;member&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more elements of &lt;paramref name=&quot;initializers&quot; /&gt; are &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="member" /> a la valeur <see langword="null" />.  

ou - 
Un ou plusieurs éléments de <paramref name="initializers" /> sont <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;member&quot; /&gt; does not represent a field or property.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Reflection.FieldInfo.FieldType&quot; /&gt; or &lt;see cref=&quot;P:System.Reflection.PropertyInfo.PropertyType&quot; /&gt; of the field or property that &lt;paramref name=&quot;member&quot; /&gt; represents does not implement &lt;see cref=&quot;T:System.Collections.IEnumerable&quot; /&gt;.">
        <paramref name="member" /> ne représente pas un champ ou une propriété.  

ou - 
Le <see cref="P:System.Reflection.FieldInfo.FieldType" /> ou <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> du champ ou de la propriété que <paramref name="member" /> représente n'implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberListBinding&quot; /&gt; based on a specified property accessor method.">Crée un objet <see cref="T:System.Linq.Expressions.MemberListBinding" /> basé sur une méthode d’accesseur de propriété spécifiée.</summary>
      <param name="propertyAccessor" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents a property accessor method.">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'accesseur de propriété.</param>
      <param name="initializers" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.MemberListBinding.Initializers&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ElementInit" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberListBinding&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.BindingType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.MemberBindingType.ListBinding&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; property set to the &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; that represents the property accessed in &lt;paramref name=&quot;propertyAccessor&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.MemberListBinding.Initializers&quot; /&gt; populated with the elements of &lt;paramref name=&quot;initializers&quot; /&gt;.">
        <see cref="T:System.Linq.Expressions.MemberListBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> a pour valeur le <see cref="T:System.Reflection.MemberInfo" /> qui représente la propriété accessible dans <paramref name="propertyAccessor" />, et dont <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> est rempli avec les éléments de <paramref name="initializers" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;propertyAccessor&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more elements of &lt;paramref name=&quot;initializers&quot; /&gt; are &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="propertyAccessor" /> a la valeur <see langword="null" />.  

ou - 
Un ou plusieurs éléments de <paramref name="initializers" /> sont <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;propertyAccessor&quot; /&gt; does not represent a property accessor method.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Reflection.PropertyInfo.PropertyType&quot; /&gt; of the property that the method represented by &lt;paramref name=&quot;propertyAccessor&quot; /&gt; accesses does not implement &lt;see cref=&quot;T:System.Collections.IEnumerable&quot; /&gt;.">
        <paramref name="propertyAccessor" /> ne représente pas une méthode d'accesseur de propriété.  

ou - 
Le <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> de la propriété à laquelle accède la méthode représentée par <paramref name="propertyAccessor" /> n'implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Linq.Expressions.ElementInit[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberListBinding&quot; /&gt; object based on a specified property accessor method.">Crée un objet <see cref="T:System.Linq.Expressions.MemberListBinding" /> basé sur une méthode d'accesseur de propriété spécifiée.</summary>
      <param name="propertyAccessor" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents a property accessor method.">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'accesseur de propriété.</param>
      <param name="initializers" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.MemberListBinding.Initializers&quot; /&gt; collection.">Tableau d'objets <see cref="T:System.Linq.Expressions.ElementInit" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberListBinding&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.BindingType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.MemberBindingType.ListBinding&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; property set to the &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; that represents the property accessed in &lt;paramref name=&quot;propertyAccessor&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.MemberListBinding.Initializers&quot; /&gt; populated with the elements of &lt;paramref name=&quot;initializers&quot; /&gt;.">
        <see cref="T:System.Linq.Expressions.MemberListBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> a pour valeur le <see cref="T:System.Reflection.MemberInfo" /> qui représente la propriété accessible dans <paramref name="propertyAccessor" />, et dont <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> est rempli avec les éléments de <paramref name="initializers" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;propertyAccessor&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more elements of &lt;paramref name=&quot;initializers&quot; /&gt; are &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="propertyAccessor" /> est <see langword="null" />.  

ou - 
Un ou plusieurs éléments de <paramref name="initializers" /> sont <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;propertyAccessor&quot; /&gt; does not represent a property accessor method.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Reflection.PropertyInfo.PropertyType&quot; /&gt; of the property that the method represented by &lt;paramref name=&quot;propertyAccessor&quot; /&gt; accesses does not implement &lt;see cref=&quot;T:System.Collections.IEnumerable&quot; /&gt;.">
        <paramref name="propertyAccessor" /> ne représente pas une méthode d'accesseur de propriété.  
ou 
Le <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> de la propriété à laquelle accède la méthode représentée par <paramref name="propertyAccessor" /> n'implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.ListInitExpression&quot; /&gt; that uses specified &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt; objects to initialize a collection.">Crée un <see cref="T:System.Linq.Expressions.ListInitExpression" /> qui utilise des objets <see cref="T:System.Linq.Expressions.ElementInit" /> spécifiés pour initialiser une collection.</summary>
      <param name="newExpression" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.NewExpression&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> doit être égale.</param>
      <param name="initializers" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.Initializers&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ElementInit" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ListInitExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ListInit&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.NewExpression&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.Initializers&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> et <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;newExpression&quot; /&gt; or &lt;paramref name=&quot;initializers&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more elements of &lt;paramref name=&quot;initializers&quot; /&gt; are &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="newExpression" /> ou <paramref name="initializers" /> est <see langword="null" />.  
ou 
Un ou plusieurs éléments de <paramref name="initializers" /> sont <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;newExpression&quot; /&gt;.Type does not implement &lt;see cref=&quot;T:System.Collections.IEnumerable&quot; /&gt;.">
        <paramref name="newExpression" />.Type n’implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.ListInitExpression&quot; /&gt; that uses a method named &quot;Add&quot; to add elements to a collection.">Crée un <see cref="T:System.Linq.Expressions.ListInitExpression" /> qui utilise une méthode nommée « Add » pour ajouter des éléments à une collection.</summary>
      <param name="newExpression" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.NewExpression&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> doit être égale.</param>
      <param name="initializers" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.Initializers&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ListInitExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ListInit&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.NewExpression&quot; /&gt; property set to the specified value.">
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> et dont la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> a la valeur spécifiée.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;newExpression&quot; /&gt; or &lt;paramref name=&quot;initializers&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more elements of &lt;paramref name=&quot;initializers&quot; /&gt; are &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="newExpression" /> ou <paramref name="initializers" /> est <see langword="null" />.  

ou - 
Un ou plusieurs éléments de <paramref name="initializers" /> sont <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;newExpression&quot; /&gt;.Type does not implement &lt;see cref=&quot;T:System.Collections.IEnumerable&quot; /&gt;.">
        <paramref name="newExpression" />.Type n’implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="There is no instance method named &quot;Add&quot; (case insensitive) declared in &lt;paramref name=&quot;newExpression&quot; /&gt;.Type or its base type.  &#xA;  &#xA; -or-  &#xA;  &#xA; The add method on &lt;paramref name=&quot;newExpression&quot; /&gt;.Type or its base type does not take exactly one argument.  &#xA;  &#xA; -or-  &#xA;  &#xA; The type represented by the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of the first element of &lt;paramref name=&quot;initializers&quot; /&gt; is not assignable to the argument type of the add method on &lt;paramref name=&quot;newExpression&quot; /&gt;.Type or its base type.  &#xA;  &#xA; -or-  &#xA;  &#xA; More than one argument-compatible method named &quot;Add&quot; (case-insensitive) exists on &lt;paramref name=&quot;newExpression&quot; /&gt;.Type and/or its base type.">Il n’existe aucune méthode d’instance nommée « Add » (non-respect de la casse) déclaré dans <paramref name="newExpression" />.Type ou son type de base.  
ou 
La méthode add sur <paramref name="newExpression" />.Type ou son type de base ne prend pas exactement un argument.  

ou - 
Le type représenté par la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> du premier élément de <paramref name="initializers" /> n’est pas affectable au type d’argument de la méthode add sur <paramref name="newExpression" />.Type ou son type de base.  

ou - 
Plusieurs méthodes compatibles avec des arguments nommées « Add » (non-respect de la casse) existent sur <paramref name="newExpression" />.Type et/ou son type de base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.ElementInit[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.ListInitExpression&quot; /&gt; that uses specified &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt; objects to initialize a collection.">Crée un <see cref="T:System.Linq.Expressions.ListInitExpression" /> qui utilise des objets <see cref="T:System.Linq.Expressions.ElementInit" /> spécifiés pour initialiser une collection.</summary>
      <param name="newExpression" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.NewExpression&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> doit être égale.</param>
      <param name="initializers" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.Initializers&quot; /&gt; collection.">Tableau d'objets <see cref="T:System.Linq.Expressions.ElementInit" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ListInitExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ListInit&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.NewExpression&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.Initializers&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> et <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;newExpression&quot; /&gt; or &lt;paramref name=&quot;initializers&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more elements of &lt;paramref name=&quot;initializers&quot; /&gt; are &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="newExpression" /> ou <paramref name="initializers" /> est <see langword="null" />.  

ou - 
Un ou plusieurs éléments de <paramref name="initializers" /> sont <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;newExpression&quot; /&gt;.Type does not implement &lt;see cref=&quot;T:System.Collections.IEnumerable&quot; /&gt;.">
        <paramref name="newExpression" />.Type n’implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.ListInitExpression&quot; /&gt; that uses a method named &quot;Add&quot; to add elements to a collection.">Crée un <see cref="T:System.Linq.Expressions.ListInitExpression" /> qui utilise une méthode nommée « Add » pour ajouter des éléments à une collection.</summary>
      <param name="newExpression" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.NewExpression&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> doit être égale.</param>
      <param name="initializers" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.Initializers&quot; /&gt; collection.">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ListInitExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ListInit&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.NewExpression&quot; /&gt; property set to the specified value.">
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> et dont la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> a la valeur spécifiée.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;newExpression&quot; /&gt; or &lt;paramref name=&quot;initializers&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more elements of &lt;paramref name=&quot;initializers&quot; /&gt; are &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="newExpression" /> ou <paramref name="initializers" /> est <see langword="null" />.  
ou 
Un ou plusieurs éléments de <paramref name="initializers" /> sont <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;newExpression&quot; /&gt;.Type does not implement &lt;see cref=&quot;T:System.Collections.IEnumerable&quot; /&gt;.">
        <paramref name="newExpression" />.Type n’implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="There is no instance method named &quot;Add&quot; (case insensitive) declared in &lt;paramref name=&quot;newExpression&quot; /&gt;.Type or its base type.  &#xA;  &#xA; -or-  &#xA;  &#xA; The add method on &lt;paramref name=&quot;newExpression&quot; /&gt;.Type or its base type does not take exactly one argument.  &#xA;  &#xA; -or-  &#xA;  &#xA; The type represented by the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of the first element of &lt;paramref name=&quot;initializers&quot; /&gt; is not assignable to the argument type of the add method on &lt;paramref name=&quot;newExpression&quot; /&gt;.Type or its base type.  &#xA;  &#xA; -or-  &#xA;  &#xA; More than one argument-compatible method named &quot;Add&quot; (case-insensitive) exists on &lt;paramref name=&quot;newExpression&quot; /&gt;.Type and/or its base type.">Il n’existe aucune méthode d’instance nommée « Add » (non-respect de la casse) déclaré dans <paramref name="newExpression" />.Type ou son type de base.  
ou 
La méthode add sur <paramref name="newExpression" />.Type ou son type de base ne prend pas exactement un argument.  
ou 
Le type représenté par la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> du premier élément de <paramref name="initializers" /> n’est pas affectable au type d’argument de la méthode add sur <paramref name="newExpression" />.Type ou son type de base.  

ou - 
Plusieurs méthodes compatibles avec des arguments nommées « Add » (non-respect de la casse) existent sur <paramref name="newExpression" />.Type et/ou son type de base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.ListInitExpression&quot; /&gt; that uses a specified method to add elements to a collection.">Crée un <see cref="T:System.Linq.Expressions.ListInitExpression" /> qui utilise une méthode spécifiée pour ajouter des éléments à une collection.</summary>
      <param name="newExpression" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.NewExpression&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> doit être égale.</param>
      <param name="addMethod" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents an instance method named &quot;Add&quot; (case insensitive), that adds an element to a collection.">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'instance nommée "Add" (non respect de la casse), qui ajoute un élément à une collection.</param>
      <param name="initializers" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.Initializers&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ListInitExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ListInit&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.NewExpression&quot; /&gt; property set to the specified value.">
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> et dont la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> a la valeur spécifiée.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;newExpression&quot; /&gt; or &lt;paramref name=&quot;initializers&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more elements of &lt;paramref name=&quot;initializers&quot; /&gt; are &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="newExpression" /> ou <paramref name="initializers" /> a la valeur <see langword="null" />.  

ou - 
Un ou plusieurs éléments de <paramref name="initializers" /> sont <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;newExpression&quot; /&gt;.Type does not implement &lt;see cref=&quot;T:System.Collections.IEnumerable&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;addMethod&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and it does not represent an instance method named &quot;Add&quot; (case insensitive) that takes exactly one argument.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;addMethod&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the type represented by the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of one or more elements of &lt;paramref name=&quot;initializers&quot; /&gt; is not assignable to the argument type of the method that &lt;paramref name=&quot;addMethod&quot; /&gt; represents.">
        <paramref name="newExpression" />.Type n’implémente pas <see cref="T:System.Collections.IEnumerable" />.  

ou - 
<paramref name="addMethod" /> n'est pas <see langword="null" /> et ne représente pas une méthode d'instance nommée "Add" (non respect de la casse) qui prend exactement un argument.  

ou - 
<paramref name="addMethod" /> n'est pas <see langword="null" /> et le type représenté par la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un ou plusieurs éléments de <paramref name="initializers" /> ne peut pas être assigné au type d'argument de la méthode que <paramref name="addMethod" /> représente.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;addMethod&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and no instance method named &quot;Add&quot; that takes one type-compatible argument exists on &lt;paramref name=&quot;newExpression&quot; /&gt;.Type or its base type.">
        <paramref name="addMethod" /> est <see langword="null" /> et il n'existe aucune méthode d'instance nommée "Add" prenant un argument compatible avec le type sur <paramref name="newExpression" />.Type ou son type de base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.ListInitExpression&quot; /&gt; that uses a specified method to add elements to a collection.">Crée un <see cref="T:System.Linq.Expressions.ListInitExpression" /> qui utilise une méthode spécifiée pour ajouter des éléments à une collection.</summary>
      <param name="newExpression" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.NewExpression&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> doit être égale.</param>
      <param name="addMethod" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents an instance method that takes one argument, that adds an element to a collection.">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'instance prenant un argument, qui ajoute un élément à une collection.</param>
      <param name="initializers" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.Initializers&quot; /&gt; collection.">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ListInitExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ListInit&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.NewExpression&quot; /&gt; property set to the specified value.">
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> et dont la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> a la valeur spécifiée.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;newExpression&quot; /&gt; or &lt;paramref name=&quot;initializers&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more elements of &lt;paramref name=&quot;initializers&quot; /&gt; are &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="newExpression" /> ou <paramref name="initializers" /> a la valeur <see langword="null" />.  

ou - 
Un ou plusieurs éléments de <paramref name="initializers" /> sont <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;newExpression&quot; /&gt;.Type does not implement &lt;see cref=&quot;T:System.Collections.IEnumerable&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;addMethod&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and it does not represent an instance method named &quot;Add&quot; (case insensitive) that takes exactly one argument.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;addMethod&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the type represented by the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of one or more elements of &lt;paramref name=&quot;initializers&quot; /&gt; is not assignable to the argument type of the method that &lt;paramref name=&quot;addMethod&quot; /&gt; represents.">
        <paramref name="newExpression" />.Type n’implémente pas <see cref="T:System.Collections.IEnumerable" />.  
ou 
 <paramref name="addMethod" /> n'est pas <see langword="null" /> et ne représente pas une méthode d'instance nommée "Add" (non respect de la casse) qui prend exactement un argument.  
ou 
 <paramref name="addMethod" /> n'est pas <see langword="null" /> et le type représenté par la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un ou plusieurs éléments de <paramref name="initializers" /> ne peut pas être assigné au type d'argument de la méthode que <paramref name="addMethod" /> représente.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;addMethod&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and no instance method named &quot;Add&quot; that takes one type-compatible argument exists on &lt;paramref name=&quot;newExpression&quot; /&gt;.Type or its base type.">
        <paramref name="addMethod" /> est <see langword="null" /> et il n'existe aucune méthode d'instance nommée "Add" prenant un argument compatible avec le type sur <paramref name="newExpression" />.Type ou son type de base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LoopExpression&quot; /&gt; with the given body.">Crée un <see cref="T:System.Linq.Expressions.LoopExpression" /> avec le corps donné.</summary>
      <param name="body" vsli:raw="The body of the loop.">Corps de la boucle.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.LoopExpression&quot; /&gt;.">Élément <see cref="T:System.Linq.Expressions.LoopExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LoopExpression&quot; /&gt; with the given body and break target.">Crée un objet <see cref="T:System.Linq.Expressions.LoopExpression" /> avec le corps et la cible d'instruction Break donnés.</summary>
      <param name="body" vsli:raw="The body of the loop.">Corps de la boucle.</param>
      <param name="break" vsli:raw="The break target used by the loop body.">Cible d'instruction Break utilisée par le corps de la boucle.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.LoopExpression&quot; /&gt;.">Élément <see cref="T:System.Linq.Expressions.LoopExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LoopExpression&quot; /&gt; with the given body.">Crée un <see cref="T:System.Linq.Expressions.LoopExpression" /> avec le corps donné.</summary>
      <param name="body" vsli:raw="The body of the loop.">Corps de la boucle.</param>
      <param name="break" vsli:raw="The break target used by the loop body.">Cible d'instruction Break utilisée par le corps de la boucle.</param>
      <param name="continue" vsli:raw="The continue target used by the loop body.">Cible d'instruction Continue utilisée par le corps de la boucle.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.LoopExpression&quot; /&gt;.">Élément <see cref="T:System.Linq.Expressions.LoopExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt;, given the left and right operands, by calling an appropriate factory method.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" />, à partir des opérandes gauche et droit, en appelant une méthode de fabrique appropriée.</summary>
      <param name="binaryType" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that specifies the type of binary operation.">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui spécifie le type d'opération binaire.</param>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the left operand.">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande gauche.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the right operand.">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande droit.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that results from calling the appropriate factory method.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui résulte de l'appel de la méthode de fabrique appropriée.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;binaryType&quot; /&gt; does not correspond to a binary expression node.">
        <paramref name="binaryType" /> ne correspond pas à un nœud d'expression binaire.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt;, given the left operand, right operand and implementing method, by calling the appropriate factory method.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" />, avec l'opérande gauche, l'opérande droit et la méthode d'implémentation, en appelant la méthode de fabrique appropriée.</summary>
      <param name="binaryType" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that specifies the type of binary operation.">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui spécifie le type d'opération binaire.</param>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the left operand.">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande gauche.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the right operand.">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande droit.</param>
      <param name="liftToNull" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt; to &lt;see langword=&quot;true&quot; /&gt;; &lt;see langword=&quot;false&quot; /&gt; to set &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt; to &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="true" /> ; <see langword="false" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="false" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that specifies the implementing method.">
        <see cref="T:System.Reflection.MethodInfo" /> qui spécifie la méthode d'implémentation.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that results from calling the appropriate factory method.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui résulte de l'appel de la méthode de fabrique appropriée.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;binaryType&quot; /&gt; does not correspond to a binary expression node.">
        <paramref name="binaryType" /> ne correspond pas à un nœud d'expression binaire.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt;, given the left operand, right operand, implementing method and type conversion function, by calling the appropriate factory method.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" />, avec l’opérande gauche, l’opérande droit, la méthode d’implémentation et la fonction de conversion de type, en appelant la méthode de fabrique appropriée.</summary>
      <param name="binaryType" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that specifies the type of binary operation.">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui spécifie le type d'opération binaire.</param>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the left operand.">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande gauche.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the right operand.">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande droit.</param>
      <param name="liftToNull" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt; to &lt;see langword=&quot;true&quot; /&gt;; &lt;see langword=&quot;false&quot; /&gt; to set &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt; to &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="true" /> ; <see langword="false" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="false" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that specifies the implementing method.">
        <see cref="T:System.Reflection.MethodInfo" /> qui spécifie la méthode d'implémentation.</param>
      <param name="conversion" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; that represents a type conversion function. This parameter is used only if &lt;paramref name=&quot;binaryType&quot; /&gt; is &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Coalesce&quot; /&gt; or compound assignment.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> qui représente une fonction de conversion de type. Ce paramètre est utilisé uniquement si <paramref name="binaryType" /> a la valeur <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> ou une assignation composée.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that results from calling the appropriate factory method.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui résulte de l'appel de la méthode de fabrique appropriée.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;binaryType&quot; /&gt; does not correspond to a binary expression node.">
        <paramref name="binaryType" /> ne correspond pas à un nœud d'expression binaire.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeCatchBlock(System.Type,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt; representing a catch statement with the specified elements.">Crée un <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente une instruction Catch avec les éléments spécifiés.</summary>
      <param name="type" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; of &lt;see cref=&quot;T:System.Exception&quot; /&gt; this &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt; will handle.">Propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que <see cref="T:System.Linq.Expressions.CatchBlock" /> traitera.</param>
      <param name="variable" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; representing a reference to the &lt;see cref=&quot;T:System.Exception&quot; /&gt; object caught by this handler.">
        <see cref="T:System.Linq.Expressions.ParameterExpression" /> représentant une référence à l'objet <see cref="T:System.Exception" /> intercepté par ce gestionnaire.</param>
      <param name="body" vsli:raw="The body of the catch statement.">Corps de l'instruction Catch.</param>
      <param name="filter" vsli:raw="The body of the &lt;see cref=&quot;T:System.Exception&quot; /&gt; filter.">Corps du filtre <see cref="T:System.Exception" />.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt;.">Élément <see cref="T:System.Linq.Expressions.CatchBlock" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;.">Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</summary>
      <param name="delegateType" vsli:raw="The type of the delegate used by the &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSite&quot; /&gt;.">Type du délégué utilisé par l'objet <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">Classeur de runtime de l'opération dynamique.</param>
      <param name="arguments" vsli:raw="The arguments to the dynamic operation.">Arguments de l’opération dynamique.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt; and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.DelegateType&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt; and one argument.">Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni et un argument.</summary>
      <param name="delegateType" vsli:raw="The type of the delegate used by the &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSite&quot; /&gt;.">Type du délégué utilisé par l'objet <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">Classeur de runtime de l'opération dynamique.</param>
      <param name="arg0" vsli:raw="The argument to the dynamic operation.">Argument de l'opération dynamique.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt; and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.DelegateType&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt; and two arguments.">Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni et deux arguments.</summary>
      <param name="delegateType" vsli:raw="The type of the delegate used by the &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSite&quot; /&gt;.">Type du délégué utilisé par l'objet <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">Classeur de runtime de l'opération dynamique.</param>
      <param name="arg0" vsli:raw="The first argument to the dynamic operation.">Premier argument de l’opération dynamique.</param>
      <param name="arg1" vsli:raw="The second argument to the dynamic operation.">Deuxième argument de l'opération dynamique.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt; and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.DelegateType&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt; and three arguments.">Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni et trois arguments.</summary>
      <param name="delegateType" vsli:raw="The type of the delegate used by the &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSite&quot; /&gt;.">Type du délégué utilisé par l'objet <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">Classeur de runtime de l'opération dynamique.</param>
      <param name="arg0" vsli:raw="The first argument to the dynamic operation.">Premier argument de l’opération dynamique.</param>
      <param name="arg1" vsli:raw="The second argument to the dynamic operation.">Deuxième argument de l'opération dynamique.</param>
      <param name="arg2" vsli:raw="The third argument to the dynamic operation.">Troisième argument de l'opération dynamique.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt; and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.DelegateType&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt; and four arguments.">Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni et quatre arguments.</summary>
      <param name="delegateType" vsli:raw="The type of the delegate used by the &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSite&quot; /&gt;.">Type du délégué utilisé par l'objet <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">Classeur de runtime de l'opération dynamique.</param>
      <param name="arg0" vsli:raw="The first argument to the dynamic operation.">Premier argument de l’opération dynamique.</param>
      <param name="arg1" vsli:raw="The second argument to the dynamic operation.">Deuxième argument de l'opération dynamique.</param>
      <param name="arg2" vsli:raw="The third argument to the dynamic operation.">Troisième argument de l'opération dynamique.</param>
      <param name="arg3" vsli:raw="The fourth argument to the dynamic operation.">Quatrième argument de l’opération dynamique.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt; and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.DelegateType&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;.">Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</summary>
      <param name="delegateType" vsli:raw="The type of the delegate used by the &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSite&quot; /&gt;.">Type du délégué utilisé par l'objet <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">Classeur de runtime de l'opération dynamique.</param>
      <param name="arguments" vsli:raw="The arguments to the dynamic operation.">Arguments de l’opération dynamique.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt; and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.DelegateType&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeGoto(System.Linq.Expressions.GotoExpressionKind,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; representing a jump of the specified &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpressionKind&quot; /&gt;. The value passed to the label upon jumping can also be specified.">Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente un saut du <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> spécifié. La valeur passée à l'étiquette au moment du saut peut également être spécifiée.</summary>
      <param name="kind" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpressionKind&quot; /&gt; of the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt;.">
        <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> du <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; will jump to.">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="value" vsli:raw="The value that will be passed to the associated label upon jumping.">Valeur qui sera passée à l'étiquette associée au moment du saut.</param>
      <param name="type" vsli:raw="An &lt;see cref=&quot;T:System.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property equal to.">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; with &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Kind&quot; /&gt; equal to &lt;paramref name=&quot;kind&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Target&quot; /&gt; property set to &lt;paramref name=&quot;target&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property set to &lt;paramref name=&quot;type&quot; /&gt;, and &lt;paramref name=&quot;value&quot; /&gt; to be passed to the target label upon jumping.">
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à <paramref name="kind" />, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" />, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeIndex(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Linq.Expressions.IndexExpression&quot; /&gt; that represents accessing an indexed property in an object.">Crée un <see cref="T:System.Linq.Expressions.IndexExpression" /> qui représente l'accès à une propriété indexée dans un objet.</summary>
      <param name="instance" vsli:raw="The object to which the property belongs. It should be null if the property is &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;shared&quot; /&gt; in Visual Basic).">Objet auquel la propriété appartient. Doit avoir la valeur Null si la propriété est <see langword="static" /> (<see langword="shared" /> en Visual Basic).</param>
      <param name="indexer" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; representing the property to index.">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente la propriété à indexer.</param>
      <param name="arguments" vsli:raw="An &lt;c&gt;IEnumerable&amp;lt;Expression&amp;gt;&lt;/c&gt; (&lt;c&gt;IEnumerable (Of Expression)&lt;/c&gt; in Visual Basic) that contains the arguments that will be used to index the property.">
        <c>IEnumerable&lt;Expression&gt;</c> (<c>IEnumerable (Of Expression)</c> en Visual Basic) contenant les arguments qui seront utilisés pour indexer la propriété.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.IndexExpression&quot; /&gt;.">Élément <see cref="T:System.Linq.Expressions.IndexExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeMemberAccess(System.Linq.Expressions.Expression,System.Reflection.MemberInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt; that represents accessing either a field or a property.">Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à un champ ou à une propriété.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the object that the member belongs to. This can be null for static members.">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'objet auquel appartient le membre. Cette valeur peut être null pour les membres statiques.</param>
      <param name="member" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; that describes the field or property to be accessed.">
        <see cref="T:System.Reflection.MemberInfo" /> qui décrit le champ ou la propriété auquel accéder.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt; that results from calling the appropriate factory method.">
        <see cref="T:System.Linq.Expressions.MemberExpression" /> qui résulte de l'appel de la méthode de fabrique appropriée.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;member&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="member" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;member&quot; /&gt; does not represent a field or property.">
        <paramref name="member" /> ne représente pas un champ ou une propriété.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeTry(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.TryExpression&quot; /&gt; representing a try block with the specified elements.">Crée un <see cref="T:System.Linq.Expressions.TryExpression" /> représentant un bloc Try avec les éléments spécifiés.</summary>
      <param name="type" vsli:raw="The result type of the try expression. If null, body and all handlers must have identical type.">Type de résultat de l'expression Try. Si Null, le corps et tous les gestionnaires doivent avoir le même type.</param>
      <param name="body" vsli:raw="The body of the try block.">Corps du bloc Try.</param>
      <param name="finally" vsli:raw="The body of the finally block. Pass null if the try block has no finally block associated with it.">Corps du bloc Finally. Passez la valeur Null si aucun bloc Finally n'est associé au bloc Try.</param>
      <param name="fault" vsli:raw="The body of the fault block. Pass null if the try block has no fault block associated with it.">Corps du bloc Fault. Passez la valeur Null si aucun bloc Fault n'est associé au bloc Try.</param>
      <param name="handlers" vsli:raw="A collection of &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt;s representing the catch statements to be associated with the try block.">Collection de <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente les instructions catch à associer au bloc Try.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.TryExpression&quot; /&gt;.">Élément <see cref="T:System.Linq.Expressions.TryExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt;, given an operand, by calling the appropriate factory method.">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" />, avec un opérande, en appelant la méthode de fabrique appropriée.</summary>
      <param name="unaryType" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that specifies the type of unary operation.">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui spécifie le type d'opération unaire.</param>
      <param name="operand" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the operand.">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande.</param>
      <param name="type" vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; that specifies the type to be converted to (pass &lt;see langword=&quot;null&quot; /&gt; if not applicable).">
        <see cref="T:System.Type" /> qui spécifie le type de conversion (passez <see langword="null" /> le cas échéant).</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that results from calling the appropriate factory method.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui résulte de l'appel de la méthode de fabrique appropriée.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;operand&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="operand" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;unaryType&quot; /&gt; does not correspond to a unary expression node.">
        <paramref name="unaryType" /> ne correspond pas à un nœud d'expression unaire.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt;, given an operand and implementing method, by calling the appropriate factory method.">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" />, avec un opérande et une méthode d'implémentation, en appelant la méthode de fabrique appropriée.</summary>
      <param name="unaryType" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that specifies the type of unary operation.">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui spécifie le type d'opération unaire.</param>
      <param name="operand" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the operand.">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande.</param>
      <param name="type" vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; that specifies the type to be converted to (pass &lt;see langword=&quot;null&quot; /&gt; if not applicable).">
        <see cref="T:System.Type" /> qui spécifie le type de conversion (passez <see langword="null" /> le cas échéant).</param>
      <param name="method" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the implementing method.">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that results from calling the appropriate factory method.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui résulte de l'appel de la méthode de fabrique appropriée.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;operand&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="operand" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;unaryType&quot; /&gt; does not correspond to a unary expression node.">
        <paramref name="unaryType" /> ne correspond pas à un nœud d'expression unaire.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberMemberBinding&quot; /&gt; that represents the recursive initialization of members of a field or property.">Crée un <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> qui représente l'initialisation récursive des membres d'un champ ou d'une propriété.</summary>
      <param name="member" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MemberInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> doit être égale.</param>
      <param name="bindings" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.MemberBinding&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.MemberMemberBinding.Bindings&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.MemberBinding" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberMemberBinding&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.BindingType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.MemberBindingType.MemberBinding&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MemberMemberBinding.Bindings&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> et <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;member&quot; /&gt; or &lt;paramref name=&quot;bindings&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="member" /> ou <paramref name="bindings" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;member&quot; /&gt; does not represent a field or property.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; property of an element of &lt;paramref name=&quot;bindings&quot; /&gt; does not represent a member of the type of the field or property that &lt;paramref name=&quot;member&quot; /&gt; represents.">
        <paramref name="member" /> ne représente pas un champ ou une propriété.  

ou - 
La propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> d'un élément <paramref name="bindings" /> ne représente pas un membre du type du champ ou de la propriété représenté par <paramref name="member" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Linq.Expressions.MemberBinding[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberMemberBinding&quot; /&gt; that represents the recursive initialization of members of a field or property.">Crée un <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> qui représente l'initialisation récursive des membres d'un champ ou d'une propriété.</summary>
      <param name="member" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MemberInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> doit être égale.</param>
      <param name="bindings" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.MemberBinding&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.MemberMemberBinding.Bindings&quot; /&gt; collection.">Tableau d'objets <see cref="T:System.Linq.Expressions.MemberBinding" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberMemberBinding&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.BindingType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.MemberBindingType.MemberBinding&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MemberMemberBinding.Bindings&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> et <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;member&quot; /&gt; or &lt;paramref name=&quot;bindings&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="member" /> ou <paramref name="bindings" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;member&quot; /&gt; does not represent a field or property.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; property of an element of &lt;paramref name=&quot;bindings&quot; /&gt; does not represent a member of the type of the field or property that &lt;paramref name=&quot;member&quot; /&gt; represents.">
        <paramref name="member" /> ne représente pas un champ ou une propriété.  

ou - 
La propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> d'un élément <paramref name="bindings" /> ne représente pas un membre du type du champ ou de la propriété représenté par <paramref name="member" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberMemberBinding&quot; /&gt; that represents the recursive initialization of members of a member that is accessed by using a property accessor method.">Crée un <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> qui représente l'initialisation récursive des membres d'un membre accessible via une méthode d'accesseur de propriété.</summary>
      <param name="propertyAccessor" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents a property accessor method.">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'accesseur de propriété.</param>
      <param name="bindings" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.MemberBinding&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.MemberMemberBinding.Bindings&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.MemberBinding" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberMemberBinding&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.BindingType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.MemberBindingType.MemberBinding&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; property set to the &lt;see cref=&quot;T:System.Reflection.PropertyInfo&quot; /&gt; that represents the property accessed in &lt;paramref name=&quot;propertyAccessor&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.MemberMemberBinding.Bindings&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> est égale à <see cref="T:System.Reflection.PropertyInfo" /> qui représente la propriété accessible dans <paramref name="propertyAccessor" />, et dont les propriétés <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;propertyAccessor&quot; /&gt; or &lt;paramref name=&quot;bindings&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="propertyAccessor" /> ou <paramref name="bindings" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;propertyAccessor&quot; /&gt; does not represent a property accessor method.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; property of an element of &lt;paramref name=&quot;bindings&quot; /&gt; does not represent a member of the type of the property accessed by the method that &lt;paramref name=&quot;propertyAccessor&quot; /&gt; represents.">
        <paramref name="propertyAccessor" /> ne représente pas une méthode d'accesseur de propriété.  

ou - 
La propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> d'un élément <paramref name="bindings" /> ne représente pas un membre du type de la propriété à laquelle accède la méthode représentée par <paramref name="propertyAccessor" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Linq.Expressions.MemberBinding[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberMemberBinding&quot; /&gt; that represents the recursive initialization of members of a member that is accessed by using a property accessor method.">Crée un <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> qui représente l'initialisation récursive des membres d'un membre accessible via une méthode d'accesseur de propriété.</summary>
      <param name="propertyAccessor" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents a property accessor method.">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'accesseur de propriété.</param>
      <param name="bindings" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.MemberBinding&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.MemberMemberBinding.Bindings&quot; /&gt; collection.">Tableau d'objets <see cref="T:System.Linq.Expressions.MemberBinding" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberMemberBinding&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.BindingType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.MemberBindingType.MemberBinding&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; property set to the &lt;see cref=&quot;T:System.Reflection.PropertyInfo&quot; /&gt; that represents the property accessed in &lt;paramref name=&quot;propertyAccessor&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.MemberMemberBinding.Bindings&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> est égale à <see cref="T:System.Reflection.PropertyInfo" /> qui représente la propriété accessible dans <paramref name="propertyAccessor" />, et dont les propriétés <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;propertyAccessor&quot; /&gt; or &lt;paramref name=&quot;bindings&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="propertyAccessor" /> ou <paramref name="bindings" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;propertyAccessor&quot; /&gt; does not represent a property accessor method.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; property of an element of &lt;paramref name=&quot;bindings&quot; /&gt; does not represent a member of the type of the property accessed by the method that &lt;paramref name=&quot;propertyAccessor&quot; /&gt; represents.">
        <paramref name="propertyAccessor" /> ne représente pas une méthode d'accesseur de propriété.  

ou - 
La propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> d'un élément <paramref name="bindings" /> ne représente pas un membre du type de la propriété à laquelle accède la méthode représentée par <paramref name="propertyAccessor" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary vsli:raw="Represents an expression that creates a new object and initializes a property of the object.">Représente une expression qui crée un nouvel objet et initialise une propriété de l'objet.</summary>
      <param name="newExpression" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MemberInitExpression.NewExpression&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> doit être égale.</param>
      <param name="bindings" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.MemberBinding&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.MemberInitExpression.Bindings&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.MemberBinding" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberInitExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.MemberInit&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MemberInitExpression.NewExpression&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MemberInitExpression.Bindings&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.MemberInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> et <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;newExpression&quot; /&gt; or &lt;paramref name=&quot;bindings&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="newExpression" /> ou <paramref name="bindings" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; property of an element of &lt;paramref name=&quot;bindings&quot; /&gt; does not represent a member of the type that &lt;paramref name=&quot;newExpression&quot; /&gt;.Type represents.">La propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> d'un élément <paramref name="bindings" /> ne représente pas un membre du type représenté par <paramref name="newExpression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.MemberBinding[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberInitExpression&quot; /&gt;.">Crée un <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
      <param name="newExpression" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MemberInitExpression.NewExpression&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> doit être égale.</param>
      <param name="bindings" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.MemberBinding&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.MemberInitExpression.Bindings&quot; /&gt; collection.">Tableau d'objets <see cref="T:System.Linq.Expressions.MemberBinding" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberInitExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.MemberInit&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MemberInitExpression.NewExpression&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MemberInitExpression.Bindings&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.MemberInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> et <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;newExpression&quot; /&gt; or &lt;paramref name=&quot;bindings&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="newExpression" /> ou <paramref name="bindings" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; property of an element of &lt;paramref name=&quot;bindings&quot; /&gt; does not represent a member of the type that &lt;paramref name=&quot;newExpression&quot; /&gt;.Type represents.">La propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> d'un élément <paramref name="bindings" /> ne représente pas un membre du type représenté par <paramref name="newExpression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an arithmetic remainder operation.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération arithmétique relative au reste.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Modulo&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The modulus operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">L'opérateur modulo n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an arithmetic remainder operation.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération arithmétique relative au reste.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Modulo&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the modulus operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> est <see langword="null" /> et l’opérateur modulus n’est pas défini pour les types <paramref name="left" /> et <paramref name="right" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a remainder assignment operation.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de reste.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ModuloAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a remainder assignment operation.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de reste.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ModuloAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a remainder assignment operation.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de reste.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ModuloAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an arithmetic multiplication operation that does not have overflow checking.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de multiplication arithmétique qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Multiply&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The multiplication operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">L'opérateur de multiplication n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an arithmetic multiplication operation that does not have overflow checking.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de multiplication arithmétique qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Multiply&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the multiplication operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> est <see langword="null" /> et l'opérateur de multiplication n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a multiplication assignment operation that does not have overflow checking.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de multiplication qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.MultiplyAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a multiplication assignment operation that does not have overflow checking.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de multiplication qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.MultiplyAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a multiplication assignment operation that does not have overflow checking.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de multiplication qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.MultiplyAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a multiplication assignment operation that has overflow checking.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de multiplication qui dispose d'une vérification de dépassement de capacité.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a multiplication assignment operation that has overflow checking.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de multiplication qui dispose d'une vérification de dépassement de capacité.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a multiplication assignment operation that has overflow checking.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de multiplication qui dispose d'une vérification de dépassement de capacité.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an arithmetic multiplication operation that has overflow checking.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de multiplication arithmétique qui dispose d'une vérification de dépassement de capacité.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.MultiplyChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The multiplication operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">L'opérateur de multiplication n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an arithmetic multiplication operation that has overflow checking.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de multiplication arithmétique qui dispose d'une vérification de dépassement de capacité.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.MultiplyChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the multiplication operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> est <see langword="null" /> et l'opérateur de multiplication n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents an arithmetic negation operation.">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de négation arithmétique.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Negate&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property set to the specified value.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> et dont la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> a la valeur spécifiée.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The unary minus operator is not defined for &lt;paramref name=&quot;expression&quot; /&gt;.Type.">L'opérateur moins unaire n'est pas défini pour <paramref name="expression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents an arithmetic negation operation.">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de négation arithmétique.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Negate&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly one argument.">
        <paramref name="method" /> n'est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas un argument exactement.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the unary minus operator is not defined for &lt;paramref name=&quot;expression&quot; /&gt;.Type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;expression&quot; /&gt;.Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by &lt;paramref name=&quot;method&quot; /&gt;.">
        <paramref name="method" /> est <see langword="null" /> et l'opérateur moins unaire n'est pas défini pour <paramref name="expression" />.Type.  

ou - 
<paramref name="expression" />.Type (ou son type non Nullable correspondant s'il s'agit d'un type valeur Nullable) ne peut pas être assigné au type d'argument de la méthode représentée par <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents an arithmetic negation operation that has overflow checking.">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de négation arithmétique qui dispose d'une vérification de dépassement de capacité.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.NegateChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property set to the specified value.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> et dont la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> a la valeur spécifiée.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The unary minus operator is not defined for &lt;paramref name=&quot;expression&quot; /&gt;.Type.">L'opérateur moins unaire n'est pas défini pour <paramref name="expression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents an arithmetic negation operation that has overflow checking. The implementing method can be specified.">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de négation arithmétique qui dispose d'une vérification de dépassement de capacité. La méthode d'implémentation peut être spécifiée.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.NegateChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly one argument.">
        <paramref name="method" /> n'est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas un argument exactement.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the unary minus operator is not defined for &lt;paramref name=&quot;expression&quot; /&gt;.Type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;expression&quot; /&gt;.Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by &lt;paramref name=&quot;method&quot; /&gt;.">
        <paramref name="method" /> est <see langword="null" /> et l'opérateur moins unaire n'est pas défini pour <paramref name="expression" />.Type.  
ou 
 <paramref name="expression" />.Type (ou son type non Nullable correspondant s'il s'agit d'un type valeur Nullable) ne peut pas être assigné au type d'argument de la méthode représentée par <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; that represents calling the specified constructor that takes no arguments.">Crée un <see cref="T:System.Linq.Expressions.NewExpression" /> qui représente l'appel du constructeur spécifié qui ne prend pas d'arguments.</summary>
      <param name="constructor" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.ConstructorInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Constructor&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.ConstructorInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.New&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Constructor&quot; /&gt; property set to the specified value.">
        <see cref="T:System.Linq.Expressions.NewExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.New" /> et dont la propriété <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> a la valeur spécifiée.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;constructor&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="constructor" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The constructor that &lt;paramref name=&quot;constructor&quot; /&gt; represents has at least one parameter.">Le constructeur représenté par <paramref name="constructor" /> a au moins un paramètre.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; that represents calling the specified constructor with the specified arguments.">Crée un <see cref="T:System.Linq.Expressions.NewExpression" /> qui représente l'appel du constructeur spécifié avec les arguments spécifiés.</summary>
      <param name="constructor" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.ConstructorInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Constructor&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.ConstructorInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> doit être égale.</param>
      <param name="arguments" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Arguments&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.New&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Constructor&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Arguments&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.NewExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.New" /> et dont les propriétés <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> et <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;constructor&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; An element of &lt;paramref name=&quot;arguments&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="constructor" /> a la valeur <see langword="null" />.  

ou - 
Un élément de <paramref name="arguments" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;arguments&quot; /&gt; parameter does not contain the same number of elements as the number of parameters for the constructor that &lt;paramref name=&quot;constructor&quot; /&gt; represents.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of an element of &lt;paramref name=&quot;arguments&quot; /&gt; is not assignable to the type of the corresponding parameter of the constructor that &lt;paramref name=&quot;constructor&quot; /&gt; represents.">Le paramètre <paramref name="arguments" /> ne contient pas le même nombre d'éléments que le nombre de paramètres pour le constructeur représenté par <paramref name="constructor" />.  
ou 
La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d’un élément de <paramref name="arguments" /> n’est pas attribuable au type du paramètre correspondant du constructeur que <paramref name="constructor" /> représente.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; that represents calling the specified constructor with the specified arguments. The members that access the constructor initialized fields are specified.">Crée un <see cref="T:System.Linq.Expressions.NewExpression" /> qui représente l'appel du constructeur spécifié avec les arguments spécifiés. Les membres qui accèdent aux champs initialisés du constructeur sont spécifiés.</summary>
      <param name="constructor" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.ConstructorInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Constructor&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.ConstructorInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> doit être égale.</param>
      <param name="arguments" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Arguments&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <param name="members" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Members&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Reflection.MemberInfo" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewExpression.Members" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.New&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Constructor&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Arguments&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Members&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.NewExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.New" /> et dont les propriétés <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> et <see cref="P:System.Linq.Expressions.NewExpression.Members" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;constructor&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; An element of &lt;paramref name=&quot;arguments&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; An element of &lt;paramref name=&quot;members&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="constructor" /> est <see langword="null" />.  

ou - 
Un élément de <paramref name="arguments" /> est <see langword="null" />.  

ou - 
Un élément de <paramref name="members" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;arguments&quot; /&gt; parameter does not contain the same number of elements as the number of parameters for the constructor that &lt;paramref name=&quot;constructor&quot; /&gt; represents.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of an element of &lt;paramref name=&quot;arguments&quot; /&gt; is not assignable to the type of the corresponding parameter of the constructor that &lt;paramref name=&quot;constructor&quot; /&gt; represents.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;paramref name=&quot;members&quot; /&gt; parameter does not have the same number of elements as &lt;paramref name=&quot;arguments&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; An element of &lt;paramref name=&quot;arguments&quot; /&gt; has a &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property that represents a type that is not assignable to the type of the member that is represented by the corresponding element of &lt;paramref name=&quot;members&quot; /&gt;.">Le paramètre <paramref name="arguments" /> ne contient pas le même nombre d'éléments que le nombre de paramètres pour le constructeur représenté par <paramref name="constructor" />.  
ou 
La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d’un élément de <paramref name="arguments" /> n’est pas attribuable au type du paramètre correspondant du constructeur que <paramref name="constructor" /> représente.  

ou - 
Le paramètre <paramref name="members" /> n'a pas le même nombre d'éléments que le paramètre <paramref name="arguments" />.  

ou - 
Un élément du paramètre <paramref name="arguments" /> a une propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente un type qui ne peut pas être assigné au type du membre représenté par l'élément correspondant du paramètre <paramref name="members" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Reflection.MemberInfo[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; that represents calling the specified constructor with the specified arguments. The members that access the constructor initialized fields are specified as an array.">Crée un <see cref="T:System.Linq.Expressions.NewExpression" /> qui représente l'appel du constructeur spécifié avec les arguments spécifiés. Les membres qui accèdent aux champs initialisés du constructeur sont spécifiés sous forme de tableau.</summary>
      <param name="constructor" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.ConstructorInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Constructor&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.ConstructorInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> doit être égale.</param>
      <param name="arguments" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Arguments&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <param name="members" vsli:raw="An array of &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Members&quot; /&gt; collection.">Tableau d'objets <see cref="T:System.Reflection.MemberInfo" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewExpression.Members" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.New&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Constructor&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Arguments&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Members&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.NewExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.New" /> et dont les propriétés <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> et <see cref="P:System.Linq.Expressions.NewExpression.Members" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;constructor&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; An element of &lt;paramref name=&quot;arguments&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; An element of &lt;paramref name=&quot;members&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="constructor" /> a la valeur <see langword="null" />.  
ou 
Un élément de <paramref name="arguments" /> est <see langword="null" />.  
ou 
Un élément de <paramref name="members" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;arguments&quot; /&gt; parameter does not contain the same number of elements as the number of parameters for the constructor that &lt;paramref name=&quot;constructor&quot; /&gt; represents.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of an element of &lt;paramref name=&quot;arguments&quot; /&gt; is not assignable to the type of the corresponding parameter of the constructor that &lt;paramref name=&quot;constructor&quot; /&gt; represents.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;paramref name=&quot;members&quot; /&gt; parameter does not have the same number of elements as &lt;paramref name=&quot;arguments&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; An element of &lt;paramref name=&quot;arguments&quot; /&gt; has a &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property that represents a type that is not assignable to the type of the member that is represented by the corresponding element of &lt;paramref name=&quot;members&quot; /&gt;.">Le paramètre <paramref name="arguments" /> ne contient pas le même nombre d'éléments que le nombre de paramètres pour le constructeur représenté par <paramref name="constructor" />.  
ou 
La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d’un élément de <paramref name="arguments" /> n’est pas attribuable au type du paramètre correspondant du constructeur que <paramref name="constructor" /> représente.  
ou 
Le paramètre <paramref name="members" /> n'a pas le même nombre d'éléments que le paramètre <paramref name="arguments" />.  
ou 
Un élément du paramètre <paramref name="arguments" /> a une propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente un type qui ne peut pas être assigné au type du membre représenté par l'élément correspondant du paramètre <paramref name="members" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; that represents calling the specified constructor with the specified arguments.">Crée un <see cref="T:System.Linq.Expressions.NewExpression" /> qui représente l'appel du constructeur spécifié avec les arguments spécifiés.</summary>
      <param name="constructor" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.ConstructorInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Constructor&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.ConstructorInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> doit être égale.</param>
      <param name="arguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Arguments&quot; /&gt; collection.">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.New&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Constructor&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Arguments&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.NewExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.New" /> et dont les propriétés <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> et <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;constructor&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; An element of &lt;paramref name=&quot;arguments&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="constructor" /> est <see langword="null" />.  
ou 
Un élément de <paramref name="arguments" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The length of &lt;paramref name=&quot;arguments&quot; /&gt; does match the number of parameters for the constructor that &lt;paramref name=&quot;constructor&quot; /&gt; represents.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of an element of &lt;paramref name=&quot;arguments&quot; /&gt; is not assignable to the type of the corresponding parameter of the constructor that &lt;paramref name=&quot;constructor&quot; /&gt; represents.">La longueur de <paramref name="arguments" /> correspond au nombre de paramètres du constructeur que <paramref name="constructor" /> représente.  

ou - 
La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d’un élément de <paramref name="arguments" /> n’est pas attribuable au type du paramètre correspondant du constructeur que <paramref name="constructor" /> représente.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; that represents calling the parameterless constructor of the specified type.">Crée un <see cref="T:System.Linq.Expressions.NewExpression" /> qui représente l'appel du constructeur sans paramètre du type spécifié.</summary>
      <param name="type" vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; that has a constructor that takes no arguments.">
        <see cref="T:System.Type" /> ayant un constructeur qui ne prend pas d'arguments.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.New&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Constructor&quot; /&gt; property set to the &lt;see cref=&quot;T:System.Reflection.ConstructorInfo&quot; /&gt; that represents the constructor without parameters for the specified type.">
        <see cref="T:System.Linq.Expressions.NewExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.New" /> et la propriété <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> égale à <see cref="T:System.Reflection.ConstructorInfo" />, laquelle représente le constructeur sans paramètre pour le type spécifié.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;type&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="type" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The type that &lt;paramref name=&quot;type&quot; /&gt; represents does not have a constructor without parameters.">Le type représenté par <paramref name="type" /> n'a pas de constructeur sans paramètres.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.NewArrayExpression&quot; /&gt; that represents creating an array that has a specified rank.">Crée un <see cref="T:System.Linq.Expressions.NewArrayExpression" /> qui représente la création d'un tableau ayant un rang spécifié.</summary>
      <param name="type" vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; that represents the element type of the array.">
        <see cref="T:System.Type" /> qui représente le type d'élément du tableau.</param>
      <param name="bounds" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.NewArrayExpression.Expressions&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewArrayExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.NewArrayBounds&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.NewArrayExpression.Expressions&quot; /&gt; property set to the specified value.">
        <see cref="T:System.Linq.Expressions.NewArrayExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> et dont la propriété <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> a la valeur spécifiée.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;type&quot; /&gt; or &lt;paramref name=&quot;bounds&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; An element of &lt;paramref name=&quot;bounds&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="type" /> ou <paramref name="bounds" /> est <see langword="null" />.  

ou - 
Un élément de <paramref name="bounds" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of an element of &lt;paramref name=&quot;bounds&quot; /&gt; does not represent an integral type.">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="bounds" /> ne représente pas un type intégral.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.NewArrayExpression&quot; /&gt; that represents creating an array that has a specified rank.">Crée un <see cref="T:System.Linq.Expressions.NewArrayExpression" /> qui représente la création d'un tableau ayant un rang spécifié.</summary>
      <param name="type" vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; that represents the element type of the array.">
        <see cref="T:System.Type" /> qui représente le type d'élément du tableau.</param>
      <param name="bounds" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.NewArrayExpression.Expressions&quot; /&gt; collection.">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewArrayExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.NewArrayBounds&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.NewArrayExpression.Expressions&quot; /&gt; property set to the specified value.">
        <see cref="T:System.Linq.Expressions.NewArrayExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> et dont la propriété <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> a la valeur spécifiée.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;type&quot; /&gt; or &lt;paramref name=&quot;bounds&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; An element of &lt;paramref name=&quot;bounds&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="type" /> ou <paramref name="bounds" /> a la valeur <see langword="null" />.  

ou - 
Un élément de <paramref name="bounds" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of an element of &lt;paramref name=&quot;bounds&quot; /&gt; does not represent an integral type.">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="bounds" /> ne représente pas un type intégral.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.NewArrayExpression&quot; /&gt; that represents creating a one-dimensional array and initializing it from a list of elements.">Crée un <see cref="T:System.Linq.Expressions.NewArrayExpression" /> qui représente la création d'un tableau unidimensionnel et son initialisation à partir d'une liste d'éléments.</summary>
      <param name="type" vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; that represents the element type of the array.">
        <see cref="T:System.Type" /> qui représente le type d'élément du tableau.</param>
      <param name="initializers" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.NewArrayExpression.Expressions&quot; /&gt; collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewArrayExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.NewArrayInit&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.NewArrayExpression.Expressions&quot; /&gt; property set to the specified value.">
        <see cref="T:System.Linq.Expressions.NewArrayExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> et dont la propriété <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> a la valeur spécifiée.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;type&quot; /&gt; or &lt;paramref name=&quot;initializers&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; An element of &lt;paramref name=&quot;initializers&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="type" /> ou <paramref name="initializers" /> est <see langword="null" />.  

ou - 
Un élément de <paramref name="initializers" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of an element of &lt;paramref name=&quot;initializers&quot; /&gt; represents a type that is not assignable to the type that &lt;paramref name=&quot;type&quot; /&gt; represents.">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément du paramètre <paramref name="initializers" /> représente un type qui ne peut pas être assigné au type représenté par <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.NewArrayExpression&quot; /&gt; that represents creating a one-dimensional array and initializing it from a list of elements.">Crée un <see cref="T:System.Linq.Expressions.NewArrayExpression" /> qui représente la création d'un tableau unidimensionnel et son initialisation à partir d'une liste d'éléments.</summary>
      <param name="type" vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; that represents the element type of the array.">
        <see cref="T:System.Type" /> qui représente le type d'élément du tableau.</param>
      <param name="initializers" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.NewArrayExpression.Expressions&quot; /&gt; collection.">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewArrayExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.NewArrayInit&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.NewArrayExpression.Expressions&quot; /&gt; property set to the specified value.">
        <see cref="T:System.Linq.Expressions.NewArrayExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> et dont la propriété <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> a la valeur spécifiée.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;type&quot; /&gt; or &lt;paramref name=&quot;initializers&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; An element of &lt;paramref name=&quot;initializers&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="type" /> ou <paramref name="initializers" /> est <see langword="null" />.  

ou - 
Un élément de <paramref name="initializers" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of an element of &lt;paramref name=&quot;initializers&quot; /&gt; represents a type that is not assignable to the type &lt;paramref name=&quot;type&quot; /&gt;.">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="initializers" /> représente un type qui ne peut pas être assigné au type <paramref name="type" />.</exception>
    </member>
    <member name="P:System.Linq.Expressions.Expression.NodeType">
      <summary vsli:raw="Gets the node type of this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Obtient le type de nœud de ce <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns vsli:raw="One of the &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; values.">Une des valeurs de l'objet <see cref="T:System.Linq.Expressions.ExpressionType" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents a bitwise complement operation.">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de bits de complément.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Not&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property set to the specified value.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> et dont la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> a la valeur spécifiée.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The unary not operator is not defined for &lt;paramref name=&quot;expression&quot; /&gt;.Type.">L'opérateur NOT unaire n'est pas défini pour <paramref name="expression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents a bitwise complement operation. The implementing method can be specified.">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de bits de complément. La méthode d'implémentation peut être spécifiée.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Not&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly one argument.">
        <paramref name="method" /> n'est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas un argument exactement.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the unary not operator is not defined for &lt;paramref name=&quot;expression&quot; /&gt;.Type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;expression&quot; /&gt;.Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by &lt;paramref name=&quot;method&quot; /&gt;.">
        <paramref name="method" /> est <see langword="null" /> et l'opérateur NOT unaire n'est pas défini pour <paramref name="expression" />.Type.  

ou - 
<paramref name="expression" />.Type (ou son type non Nullable correspondant s'il s'agit d'un type valeur Nullable) ne peut pas être assigné au type d'argument de la méthode représentée par <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an inequality comparison.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison d'inégalité.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.NotEqual&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The inequality operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">L'opérateur d'inégalité n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an inequality comparison.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison d'inégalité.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="liftToNull" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt; to &lt;see langword=&quot;true&quot; /&gt;; &lt;see langword=&quot;false&quot; /&gt; to set &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt; to &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="true" /> ; <see langword="false" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="false" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.NotEqual&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the inequality operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> est <see langword="null" /> et l'opérateur d'inégalité n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Returns the expression representing the ones complement.">Retourne l'expression qui représente le complément à 1.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Élément <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <returns vsli:raw="An instance of &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt;.">Instance de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Returns the expression representing the ones complement.">Retourne l'expression qui représente le complément à 1.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Élément <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the implementing method.">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
      <returns vsli:raw="An instance of &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt;.">Instance de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise &lt;see langword=&quot;OR&quot; /&gt; operation.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération <see langword="OR" /> au niveau du bit.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Or&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The bitwise &lt;see langword=&quot;OR&quot; /&gt; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">L'opérateur de bits <see langword="OR" /> n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise &lt;see langword=&quot;OR&quot; /&gt; operation.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération <see langword="OR" /> au niveau du bit.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Or&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, pas <see langword="static" /> (<see langword="Shared" /> dans Visual Basic) ou ne prend pas exactement deux arguments.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the bitwise &lt;see langword=&quot;OR&quot; /&gt; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> est <see langword="null" /> et l’opérateur <see langword="OR" /> au niveau du bit n’est pas défini pour les types <paramref name="left" />.et <paramref name="right" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise OR assignment operation.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation OR au niveau du bit.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.OrAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise OR assignment operation.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation OR au niveau du bit.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.OrAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise OR assignment operation.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation OR au niveau du bit.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.OrAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a conditional &lt;see langword=&quot;OR&quot; /&gt; operation that evaluates the second operand only if the first operand evaluates to &lt;see langword=&quot;false&quot; /&gt;.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération <see langword="OR" /> conditionnelle évaluant la deuxième opérande uniquement si la première opérande a la valeur <see langword="false" />.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.OrElse&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The bitwise &lt;see langword=&quot;OR&quot; /&gt; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type are not the same Boolean type.">L'opérateur de bits <see langword="OR" /> n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.  

ou - 
<paramref name="left" />.Type et <paramref name="right" />.Type ne sont pas du même type booléen.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a conditional &lt;see langword=&quot;OR&quot; /&gt; operation that evaluates the second operand only if the first operand evaluates to &lt;see langword=&quot;false&quot; /&gt;.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération <see langword="OR" /> conditionnelle évaluant la deuxième opérande uniquement si la première opérande a la valeur <see langword="false" />.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.OrElse&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, pas <see langword="static" /> (<see langword="Shared" /> dans Visual Basic) ou ne prend pas exactement deux arguments.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the bitwise &lt;see langword=&quot;OR&quot; /&gt; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type are not the same Boolean type.">
        <paramref name="method" /> est <see langword="null" /> et l’opérateur <see langword="OR" /> au niveau du bit n’est pas défini pour les types <paramref name="left" />.et <paramref name="right" />.  
ou 
 <paramref name="method" /> est <see langword="null" /> et <paramref name="left" />.Type et <paramref name="right" />.Type ne sont pas du même type booléen.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Parameter(System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; node that can be used to identify a parameter or a variable in an expression tree.">Crée un nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> qui peut être utilisé pour identifier un paramètre ou une variable dans une arborescence d’expression.</summary>
      <param name="type" vsli:raw="The type of the parameter or variable.">Type du paramètre ou de la variable.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; node with the specified name and type.">Nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> avec le nom et le type spécifiés.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Parameter(System.Type,System.String)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; node that can be used to identify a parameter or a variable in an expression tree.">Crée un nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> qui peut être utilisé pour identifier un paramètre ou une variable dans une arborescence d’expression.</summary>
      <param name="type" vsli:raw="The type of the parameter or variable.">Type du paramètre ou de la variable.</param>
      <param name="name" vsli:raw="The name of the parameter or variable, used for debugging or printing purpose only.">Nom du paramètre ou de la variable, utilisé à des fins de débogage ou d'impression uniquement.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Parameter&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.ParameterExpression.Name&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.ParameterExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Parameter" /> et dont les propriétés <see cref="P:System.Linq.Expressions.Expression.Type" /> et <see cref="P:System.Linq.Expressions.ParameterExpression.Name" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;type&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="type" /> est <see langword="null" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the assignment of the expression followed by a subsequent decrement by 1 of the original expression.">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'assignation de l'expression suivie d'une décrémentation de 1 de l'expression d'origine.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to apply the operations on.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the resultant expression.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the assignment of the expression followed by a subsequent decrement by 1 of the original expression.">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'assignation de l'expression suivie d'une décrémentation de 1 de l'expression d'origine.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to apply the operations on.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the implementing method.">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the resultant expression.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the assignment of the expression followed by a subsequent increment by 1 of the original expression.">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'assignation de l'expression suivie d'une incrémentation de 1 de l'expression d'origine.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to apply the operations on.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the resultant expression.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the assignment of the expression followed by a subsequent increment by 1 of the original expression.">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'assignation de l'expression suivie d'une incrémentation de 1 de l'expression d'origine.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to apply the operations on.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the implementing method.">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the resultant expression.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents raising a number to a power.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente l'élévation d'un nombre à une puissance.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Power&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The exponentiation operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;left&quot; /&gt;.Type and/or &lt;paramref name=&quot;right&quot; /&gt;.Type are not &lt;see cref=&quot;T:System.Double&quot; /&gt;.">L'opérateur d'exponentiation n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.  

ou - 
<paramref name="left" />.Type et/ou <paramref name="right" />.Type ne sont pas <see cref="T:System.Double" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents raising a number to a power.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente l'élévation d'un nombre à une puissance.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Power&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the exponentiation operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and &lt;paramref name=&quot;left&quot; /&gt;.Type and/or &lt;paramref name=&quot;right&quot; /&gt;.Type are not &lt;see cref=&quot;T:System.Double&quot; /&gt;.">
        <paramref name="method" /> a la valeur <see langword="null" /> et l’opérateur d’élévation à une puissance n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.  

ou - 
<paramref name="method" /> a la valeur <see langword="null" /> et <paramref name="left" />.Type et/ou <paramref name="right" />.Type ne sont pas <see cref="T:System.Double" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents raising an expression to a power and assigning the result back to the expression.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente l'élévation d'une expression à une puissance et la réassignation du résultat à l'expression.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.PowerAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents raising an expression to a power and assigning the result back to the expression.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente l'élévation d'une expression à une puissance et la réassignation du résultat à l'expression.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.PowerAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents raising an expression to a power and assigning the result back to the expression.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente l'élévation d'une expression à une puissance et la réassignation du résultat à l'expression.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.PowerAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that decrements the expression by 1 and assigns the result back to the expression.">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui décrémente l'expression de 1 et réassigne le résultat à l'expression.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to apply the operations on.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the resultant expression.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that decrements the expression by 1 and assigns the result back to the expression.">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui décrémente l'expression de 1 et réassigne le résultat à l'expression.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to apply the operations on.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the implementing method.">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the resultant expression.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that increments the expression by 1 and assigns the result back to the expression.">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui incrémente l'expression de 1 et réassigne le résultat à l'expression.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to apply the operations on.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the resultant expression.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that increments the expression by 1 and assigns the result back to the expression.">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui incrémente l'expression de 1 et réassigne le résultat à l'expression.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to apply the operations on.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the implementing method.">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the resultant expression.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt; that represents accessing a property by using a property accessor method.">Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à une propriété à l'aide d'une méthode d'accesseur de propriété.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Expression&quot; /&gt; property equal to. This can be null for static properties.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> doit être égale. Cette valeur peut être null pour les propriétés statiques.</param>
      <param name="propertyAccessor" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents a property accessor method.">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'accesseur de propriété.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.MemberAccess&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Expression&quot; /&gt; property set to &lt;paramref name=&quot;expression&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Member&quot; /&gt; property set to the &lt;see cref=&quot;T:System.Reflection.PropertyInfo&quot; /&gt; that represents the property accessed in &lt;paramref name=&quot;propertyAccessor&quot; /&gt;.">
        <see cref="T:System.Linq.Expressions.MemberExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> a pour valeur <paramref name="expression" /> et la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> a pour valeur le <see cref="T:System.Reflection.PropertyInfo" /> qui représente la propriété accessible dans <paramref name="propertyAccessor" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;propertyAccessor&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The method that &lt;paramref name=&quot;propertyAccessor&quot; /&gt; represents is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic) and &lt;paramref name=&quot;expression&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="propertyAccessor" /> a la valeur <see langword="null" />.  

ou - 
La méthode représentée par <paramref name="propertyAccessor" /> n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) et <paramref name="expression" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt;.Type is not assignable to the declaring type of the method represented by &lt;paramref name=&quot;propertyAccessor&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The method that &lt;paramref name=&quot;propertyAccessor&quot; /&gt; represents is not a property accessor method.">
        <paramref name="expression" />. Le type ne peut pas être affecté au type de la méthode représentée par <paramref name="propertyAccessor" />.  

ou - 
La méthode représentée par <paramref name="propertyAccessor" /> n'est pas une méthode d'accesseur de propriété.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt; that represents accessing a property.">Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à une propriété.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Expression&quot; /&gt; property equal to. This can be null for static properties.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> doit être égale. Cette valeur peut être null pour les propriétés statiques.</param>
      <param name="property" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.PropertyInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Member&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.PropertyInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.MemberAccess&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Expression&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Member&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.MemberExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> et <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;property&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The property that &lt;paramref name=&quot;property&quot; /&gt; represents is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic) and &lt;paramref name=&quot;expression&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="property" /> a la valeur <see langword="null" />.  

ou - 
La propriété représentée par <paramref name="property" /> n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) et <paramref name="expression" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt;.Type is not assignable to the declaring type of the property that &lt;paramref name=&quot;property&quot; /&gt; represents.">
        <paramref name="expression" />.Type ne peut pas être assigné au type de déclaration de la propriété que <paramref name="property" /> représente.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Linq.Expressions.IndexExpression&quot; /&gt; representing the access to an indexed property.">Crée un <see cref="T:System.Linq.Expressions.IndexExpression" /> qui représente l'accès à une propriété indexée.</summary>
      <param name="instance" vsli:raw="The object to which the property belongs. If the property is static/shared, it must be null.">Objet auquel la propriété appartient. Si la propriété est statique/partagée, doit avoir la valeur Null.</param>
      <param name="indexer" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.PropertyInfo&quot; /&gt; that represents the property to index.">
        <see cref="T:System.Reflection.PropertyInfo" /> qui représente la propriété à indexer.</param>
      <param name="arguments" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects that are used to index the property.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> d'objets <see cref="T:System.Linq.Expressions.Expression" /> utilisés pour indexer la propriété.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.IndexExpression&quot; /&gt;.">Élément <see cref="T:System.Linq.Expressions.IndexExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Linq.Expressions.IndexExpression&quot; /&gt; representing the access to an indexed property.">Crée un <see cref="T:System.Linq.Expressions.IndexExpression" /> qui représente l'accès à une propriété indexée.</summary>
      <param name="instance" vsli:raw="The object to which the property belongs. If the property is static/shared, it must be null.">Objet auquel la propriété appartient. Si la propriété est statique/partagée, doit avoir la valeur Null.</param>
      <param name="indexer" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.PropertyInfo&quot; /&gt; that represents the property to index.">
        <see cref="T:System.Reflection.PropertyInfo" /> qui représente la propriété à indexer.</param>
      <param name="arguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects that are used to index the property.">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> utilisés pour indexer la propriété.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.IndexExpression&quot; /&gt;.">Élément <see cref="T:System.Linq.Expressions.IndexExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt; that represents accessing a property.">Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à une propriété.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; whose &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; contains a property named &lt;paramref name=&quot;propertyName&quot; /&gt;. This can be &lt;see langword=&quot;null&quot; /&gt; for static properties.">
        <see cref="T:System.Linq.Expressions.Expression" /> dont <see cref="P:System.Linq.Expressions.Expression.Type" /> contient une propriété nommée <paramref name="propertyName" />. Cette valeur peut être <see langword="null" /> pour les propriétés statiques.</param>
      <param name="propertyName" vsli:raw="The name of a property to be accessed.">Nom d'une propriété à laquelle accéder.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.MemberAccess&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Expression&quot; /&gt; property set to &lt;paramref name=&quot;expression&quot; /&gt;, and the &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Member&quot; /&gt; property set to the &lt;see cref=&quot;T:System.Reflection.PropertyInfo&quot; /&gt; that represents the property denoted by &lt;paramref name=&quot;propertyName&quot; /&gt;.">
        <see cref="T:System.Linq.Expressions.MemberExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, dont la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> a pour valeur <paramref name="expression" /> et dont la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> a pour valeur le <see cref="T:System.Reflection.PropertyInfo" /> qui représente le champ désigné par <paramref name="propertyName" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; or &lt;paramref name=&quot;propertyName&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> ou <paramref name="propertyName" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="No property named &lt;paramref name=&quot;propertyName&quot; /&gt; is defined in &lt;paramref name=&quot;expression&quot; /&gt;.Type or its base types.">Aucune propriété nommée <paramref name="propertyName" /> n'est définie dans <paramref name="expression" />.Type ou ses types de base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Linq.Expressions.IndexExpression&quot; /&gt; representing the access to an indexed property.">Crée un <see cref="T:System.Linq.Expressions.IndexExpression" /> qui représente l'accès à une propriété indexée.</summary>
      <param name="instance" vsli:raw="The object to which the property belongs. If the property is static/shared, it must be null.">Objet auquel la propriété appartient. Si la propriété est statique/partagée, doit avoir la valeur Null.</param>
      <param name="propertyName" vsli:raw="The name of the indexer.">Nom de l'indexeur.</param>
      <param name="arguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects that are used to index the property.">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> utilisés pour indexer la propriété.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.IndexExpression&quot; /&gt;.">Élément <see cref="T:System.Linq.Expressions.IndexExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Type,System.String)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt; accessing a property.">Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui accède à une propriété.</summary>
      <param name="expression" vsli:raw="The containing object of the property. This can be null for static properties.">Objet contenant la propriété. Cette valeur peut être null pour les propriétés statiques.</param>
      <param name="type" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; that contains the property.">Objet <see cref="P:System.Linq.Expressions.Expression.Type" /> qui contient la propriété.</param>
      <param name="propertyName" vsli:raw="The property to be accessed.">Propriété à laquelle accéder.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt;.">Élément <see cref="T:System.Linq.Expressions.MemberExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PropertyOrField(System.Linq.Expressions.Expression,System.String)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt; that represents accessing a property or field.">Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à une propriété ou un champ.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; whose &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; contains a property or field named &lt;paramref name=&quot;propertyOrFieldName&quot; /&gt;.">
        <see cref="T:System.Linq.Expressions.Expression" /> dont <see cref="P:System.Linq.Expressions.Expression.Type" /> contient une propriété ou un champ nommé <paramref name="propertyOrFieldName" />. Cette valeur peut être null pour les membres statiques.</param>
      <param name="propertyOrFieldName" vsli:raw="The name of a property or field to be accessed.">Nom d'une propriété ou d'un champ auquel accéder.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.MemberAccess&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Expression&quot; /&gt; property set to &lt;paramref name=&quot;expression&quot; /&gt;, and the &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Member&quot; /&gt; property set to the &lt;see cref=&quot;T:System.Reflection.PropertyInfo&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.FieldInfo&quot; /&gt; that represents the property or field denoted by &lt;paramref name=&quot;propertyOrFieldName&quot; /&gt;.">
        <see cref="T:System.Linq.Expressions.MemberExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> est égale à <paramref name="expression" />, et la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> est égale à <see cref="T:System.Reflection.PropertyInfo" /> ou à <see cref="T:System.Reflection.FieldInfo" /> qui représente la propriété ou le champ désigné par <paramref name="propertyOrFieldName" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; or &lt;paramref name=&quot;propertyOrFieldName&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> ou <paramref name="propertyOrFieldName" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="No property or field named &lt;paramref name=&quot;propertyOrFieldName&quot; /&gt; is defined in &lt;paramref name=&quot;expression&quot; /&gt;.Type or its base types.">Aucune propriété ou aucun champ nommé <paramref name="propertyOrFieldName" /> n'est défini dans <paramref name="expression" />.Type ou ses types de base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Quote(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents an expression that has a constant value of type &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une expression ayant une valeur de constante de type <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Quote&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property set to the specified value.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> et dont la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> a la valeur spécifiée.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> est <see langword="null" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Reduce">
      <summary vsli:raw="Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.">Réduit le nœud en une expression plus simple. Si CanReduce retourne la valeur true, cela doit retourner une expression valide. Cette méthode peut retourner un autre nœud qui doit lui-même être réduit.</summary>
      <returns vsli:raw="The reduced expression.">Expression réduite.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReduceAndCheck">
      <summary vsli:raw="Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.">Réduit le nœud en une expression plus simple. Si CanReduce retourne la valeur true, cela doit retourner une expression valide. Cette méthode peut retourner un autre nœud qui doit lui-même être réduit.</summary>
      <returns vsli:raw="The reduced expression.">Expression réduite.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReduceExtensions">
      <summary vsli:raw="Reduces the expression to a known node type (that is not an Extension node) or just returns the expression if it is already a known type.">Réduit l'expression à un type de nœud connu (qui n'est pas un nœud Extension) ou retourne simplement l'expression s'il s'agit d'un type déjà connu.</summary>
      <returns vsli:raw="The reduced expression.">Expression réduite.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReferenceEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a reference equality comparison.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison d'égalité des références.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Equal&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReferenceNotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a reference inequality comparison.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison d'inégalité des références.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.NotEqual&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Rethrow">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents a rethrowing of an exception.">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une nouvelle levée d'exception.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents a rethrowing of an exception.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une nouvelle levée d'exception.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Rethrow(System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents a rethrowing of an exception with a given type.">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une nouvelle levée d'une exception avec un type donné.</summary>
      <param name="type" vsli:raw="The new &lt;see cref=&quot;T:System.Type&quot; /&gt; of the expression.">Nouveau <see cref="T:System.Type" /> d'une expression.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents a rethrowing of an exception.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une nouvelle levée d'exception.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; representing a return statement.">Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Return.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; will jump to.">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; with &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Kind&quot; /&gt; equal to Return, the &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Target&quot; /&gt; property set to &lt;paramref name=&quot;target&quot; /&gt;, and a null value to be passed to the target label upon jumping.">
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Return, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et une valeur null à passer à l'étiquette cible au moment du saut.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; representing a return statement. The value passed to the label upon jumping can be specified.">Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Return. La valeur passée à l'étiquette au moment du saut peut être spécifiée.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; will jump to.">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="value" vsli:raw="The value that will be passed to the associated label upon jumping.">Valeur qui sera passée à l'étiquette associée au moment du saut.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; with &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Kind&quot; /&gt; equal to Continue, the &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Target&quot; /&gt; property set to &lt;paramref name=&quot;target&quot; /&gt;, and &lt;paramref name=&quot;value&quot; /&gt; to be passed to the target label upon jumping.">
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Continue, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; representing a return statement with the specified type. The value passed to the label upon jumping can be specified.">Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Return avec le type spécifié. La valeur passée à l'étiquette au moment du saut peut être spécifiée.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; will jump to.">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="value" vsli:raw="The value that will be passed to the associated label upon jumping.">Valeur qui sera passée à l'étiquette associée au moment du saut.</param>
      <param name="type" vsli:raw="An &lt;see cref=&quot;T:System.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property equal to.">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; with &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Kind&quot; /&gt; equal to Continue, the &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Target&quot; /&gt; property set to &lt;paramref name=&quot;target&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property set to &lt;paramref name=&quot;type&quot; /&gt;, and &lt;paramref name=&quot;value&quot; /&gt; to be passed to the target label upon jumping.">
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Continue, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" />, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; representing a return statement with the specified type.">Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Return avec le type spécifié.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; will jump to.">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="type" vsli:raw="An &lt;see cref=&quot;T:System.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property equal to.">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; with &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Kind&quot; /&gt; equal to Return, the &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Target&quot; /&gt; property set to &lt;paramref name=&quot;target&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property set to &lt;paramref name=&quot;type&quot; /&gt;, and a null value to be passed to the target label upon jumping.">
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Return, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" />, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et une valeur null à passer à l'étiquette cible au moment du saut.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise right-shift operation.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de bits de décalage vers la droite.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.RightShift&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The right-shift operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">L'opérateur de décalage vers la droite n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise right-shift operation.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de bits de décalage vers la droite.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.RightShift&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the right-shift operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> est <see langword="null" /> et l'opérateur de décalage vers la droite n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise right-shift assignment operation.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de décalage vers la droite au niveau du bit.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.RightShiftAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise right-shift assignment operation.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de décalage vers la droite au niveau du bit.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.RightShiftAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise right-shift assignment operation.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de décalage vers la droite au niveau du bit.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.RightShiftAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary vsli:raw="Creates an instance of &lt;see cref=&quot;T:System.Linq.Expressions.RuntimeVariablesExpression&quot; /&gt;.">Crée une instance de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <param name="variables" vsli:raw="A collection of &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.RuntimeVariablesExpression.Variables&quot; /&gt; collection.">Collection d'objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />.</param>
      <returns vsli:raw="An instance of &lt;see cref=&quot;T:System.Linq.Expressions.RuntimeVariablesExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.RuntimeVariables&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.RuntimeVariablesExpression.Variables&quot; /&gt; property set to the specified value.">Instance de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> et la propriété <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> égale à la valeur spécifiée.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Linq.Expressions.ParameterExpression[])">
      <summary vsli:raw="Creates an instance of &lt;see cref=&quot;T:System.Linq.Expressions.RuntimeVariablesExpression&quot; /&gt;.">Crée une instance de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <param name="variables" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.RuntimeVariablesExpression.Variables&quot; /&gt; collection.">Tableau d'objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />.</param>
      <returns vsli:raw="An instance of &lt;see cref=&quot;T:System.Linq.Expressions.RuntimeVariablesExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.RuntimeVariables&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.RuntimeVariablesExpression.Variables&quot; /&gt; property set to the specified value.">Instance de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> et la propriété <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> égale à la valeur spécifiée.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an arithmetic subtraction operation that does not have overflow checking.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de soustraction arithmétique qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Subtract&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The subtraction operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">L'opérateur de soustraction n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an arithmetic subtraction operation that does not have overflow checking.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de soustraction arithmétique qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <param name="left" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Subtract&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, pas <see langword="static" /> (<see langword="Shared" /> dans Visual Basic) ou ne prend pas exactement deux arguments.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the subtraction operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> est <see langword="null" /> et l’opérateur de soustraction n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a subtraction assignment operation that does not have overflow checking.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de soustraction qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.SubtractAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a subtraction assignment operation that does not have overflow checking.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de soustraction qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.SubtractAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a subtraction assignment operation that does not have overflow checking.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de soustraction qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.SubtractAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a subtraction assignment operation that has overflow checking.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de soustraction qui dispose d'une vérification de dépassement de capacité.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a subtraction assignment operation that has overflow checking.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de soustraction qui dispose d'une vérification de dépassement de capacité.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a subtraction assignment operation that has overflow checking.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de soustraction qui dispose d'une vérification de dépassement de capacité.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an arithmetic subtraction operation that has overflow checking.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de soustraction arithmétique qui dispose d'une vérification de dépassement de capacité.</summary>
      <param name="left" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.SubtractChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The subtraction operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">L'opérateur de soustraction n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an arithmetic subtraction operation that has overflow checking.">Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de soustraction arithmétique qui dispose d'une vérification de dépassement de capacité.</summary>
      <param name="left" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.SubtractChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, pas <see langword="static" /> (<see langword="Shared" /> dans Visual Basic) ou ne prend pas exactement deux arguments.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the subtraction operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> est <see langword="null" /> et l’opérateur de soustraction n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.SwitchExpression&quot; /&gt; that represents a &lt;see langword=&quot;switch&quot; /&gt; statement that has a default case.">Crée un <see cref="T:System.Linq.Expressions.SwitchExpression" /> qui représente une instruction <see langword="switch" /> avec la casse par défaut.</summary>
      <param name="switchValue" vsli:raw="The value to be tested against each case.">Valeur à tester pour chaque cas.</param>
      <param name="defaultBody" vsli:raw="The result of the switch if &lt;paramref name=&quot;switchValue&quot; /&gt; does not match any of the cases.">Résultat du commutateur si <paramref name="switchValue" /> ne correspond à aucun des cas.</param>
      <param name="cases" vsli:raw="The set of cases for this switch expression.">Ensemble de cas pour cette expression de switch.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.SwitchExpression&quot; /&gt;.">Élément <see cref="T:System.Linq.Expressions.SwitchExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.SwitchExpression&quot; /&gt; that represents a &lt;see langword=&quot;switch&quot; /&gt; statement that has a default case.">Crée un <see cref="T:System.Linq.Expressions.SwitchExpression" /> qui représente une instruction <see langword="switch" /> avec la casse par défaut.</summary>
      <param name="switchValue" vsli:raw="The value to be tested against each case.">Valeur à tester pour chaque cas.</param>
      <param name="defaultBody" vsli:raw="The result of the switch if &lt;paramref name=&quot;switchValue&quot; /&gt; does not match any of the cases.">Résultat du commutateur si <paramref name="switchValue" /> ne correspond à aucun des cas.</param>
      <param name="comparison" vsli:raw="The equality comparison method to use.">Méthode de comparaison d'égalité à utiliser.</param>
      <param name="cases" vsli:raw="The set of cases for this switch expression.">Ensemble de cas pour cette expression de switch.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.SwitchExpression&quot; /&gt;.">Élément <see cref="T:System.Linq.Expressions.SwitchExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.SwitchExpression&quot; /&gt; that represents a &lt;see langword=&quot;switch&quot; /&gt; statement that has a default case.">Crée un <see cref="T:System.Linq.Expressions.SwitchExpression" /> qui représente une instruction <see langword="switch" /> avec la casse par défaut.</summary>
      <param name="switchValue" vsli:raw="The value to be tested against each case.">Valeur à tester pour chaque cas.</param>
      <param name="defaultBody" vsli:raw="The result of the switch if &lt;paramref name=&quot;switchValue&quot; /&gt; does not match any of the cases.">Résultat du commutateur si <paramref name="switchValue" /> ne correspond à aucun des cas.</param>
      <param name="comparison" vsli:raw="The equality comparison method to use.">Méthode de comparaison d'égalité à utiliser.</param>
      <param name="cases" vsli:raw="The set of cases for this switch expression.">Ensemble de cas pour cette expression de switch.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.SwitchExpression&quot; /&gt;.">Élément <see cref="T:System.Linq.Expressions.SwitchExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.SwitchExpression&quot; /&gt; that represents a &lt;see langword=&quot;switch&quot; /&gt; statement without a default case.">Crée un <see cref="T:System.Linq.Expressions.SwitchExpression" /> qui représente une instruction <see langword="switch" /> sans casse par défaut.</summary>
      <param name="switchValue" vsli:raw="The value to be tested against each case.">Valeur à tester pour chaque cas.</param>
      <param name="cases" vsli:raw="The set of cases for this switch expression.">Ensemble de cas pour cette expression de switch.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.SwitchExpression&quot; /&gt;.">Élément <see cref="T:System.Linq.Expressions.SwitchExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.SwitchExpression&quot; /&gt; that represents a &lt;see langword=&quot;switch&quot; /&gt; statement that has a default case.">Crée un <see cref="T:System.Linq.Expressions.SwitchExpression" /> qui représente une instruction <see langword="switch" /> avec la casse par défaut.</summary>
      <param name="type" vsli:raw="The result type of the switch.">Type de résultat du commutateur.</param>
      <param name="switchValue" vsli:raw="The value to be tested against each case.">Valeur à tester pour chaque cas.</param>
      <param name="defaultBody" vsli:raw="The result of the switch if &lt;paramref name=&quot;switchValue&quot; /&gt; does not match any of the cases.">Résultat du commutateur si <paramref name="switchValue" /> ne correspond à aucun des cas.</param>
      <param name="comparison" vsli:raw="The equality comparison method to use.">Méthode de comparaison d'égalité à utiliser.</param>
      <param name="cases" vsli:raw="The set of cases for this switch expression.">Ensemble de cas pour cette expression de switch.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.SwitchExpression&quot; /&gt;.">Élément <see cref="T:System.Linq.Expressions.SwitchExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.SwitchExpression&quot; /&gt; that represents a &lt;see langword=&quot;switch&quot; /&gt; statement that has a default case.">Crée un <see cref="T:System.Linq.Expressions.SwitchExpression" /> qui représente une instruction <see langword="switch" /> avec la casse par défaut.</summary>
      <param name="type" vsli:raw="The result type of the switch.">Type de résultat du commutateur.</param>
      <param name="switchValue" vsli:raw="The value to be tested against each case.">Valeur à tester pour chaque cas.</param>
      <param name="defaultBody" vsli:raw="The result of the switch if &lt;paramref name=&quot;switchValue&quot; /&gt; does not match any of the cases.">Résultat du commutateur si <paramref name="switchValue" /> ne correspond à aucun des cas.</param>
      <param name="comparison" vsli:raw="The equality comparison method to use.">Méthode de comparaison d'égalité à utiliser.</param>
      <param name="cases" vsli:raw="The set of cases for this switch expression.">Ensemble de cas pour cette expression de switch.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.SwitchExpression&quot; /&gt;.">Élément <see cref="T:System.Linq.Expressions.SwitchExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.SwitchCase&quot; /&gt; object to be used in a &lt;see cref=&quot;T:System.Linq.Expressions.SwitchExpression&quot; /&gt; object.">Crée un objet <see cref="T:System.Linq.Expressions.SwitchCase" /> à utiliser dans un objet <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <param name="body" vsli:raw="The body of the case.">Corps du cas.</param>
      <param name="testValues" vsli:raw="The test values of the case.">Valeurs de test du cas.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.SwitchCase&quot; /&gt;.">Élément <see cref="T:System.Linq.Expressions.SwitchCase" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.SwitchCase&quot; /&gt; for use in a &lt;see cref=&quot;T:System.Linq.Expressions.SwitchExpression&quot; /&gt;.">Crée un <see cref="T:System.Linq.Expressions.SwitchCase" /> pour une utilisation dans un <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <param name="body" vsli:raw="The body of the case.">Corps du cas.</param>
      <param name="testValues" vsli:raw="The test values of the case.">Valeurs de test du cas.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.SwitchCase&quot; /&gt;.">Élément <see cref="T:System.Linq.Expressions.SwitchCase" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String)">
      <summary vsli:raw="Creates an instance of &lt;see cref=&quot;T:System.Linq.Expressions.SymbolDocumentInfo&quot; /&gt;.">Crée une instance de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <param name="fileName" vsli:raw="A &lt;see cref=&quot;T:System.String&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.FileName&quot; /&gt; equal to.">
        <see cref="T:System.String" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.SymbolDocumentInfo&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.FileName&quot; /&gt; property set to the specified value.">
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> dont la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> a la valeur spécifiée.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid)">
      <summary vsli:raw="Creates an instance of &lt;see cref=&quot;T:System.Linq.Expressions.SymbolDocumentInfo&quot; /&gt;.">Crée une instance de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <param name="fileName" vsli:raw="A &lt;see cref=&quot;T:System.String&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.FileName&quot; /&gt; equal to.">
        <see cref="T:System.String" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> doit être égale.</param>
      <param name="language" vsli:raw="A &lt;see cref=&quot;T:System.Guid&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.Language&quot; /&gt; equal to.">
        <see cref="T:System.Guid" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.SymbolDocumentInfo&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.FileName&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.Language&quot; /&gt; properties set to the specified value.">
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> dont les propriétés <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> et <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> ont la valeur spécifiée.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid)">
      <summary vsli:raw="Creates an instance of &lt;see cref=&quot;T:System.Linq.Expressions.SymbolDocumentInfo&quot; /&gt;.">Crée une instance de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <param name="fileName" vsli:raw="A &lt;see cref=&quot;T:System.String&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.FileName&quot; /&gt; equal to.">
        <see cref="T:System.String" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> doit être égale.</param>
      <param name="language" vsli:raw="A &lt;see cref=&quot;T:System.Guid&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.Language&quot; /&gt; equal to.">
        <see cref="T:System.Guid" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> doit être égale.</param>
      <param name="languageVendor" vsli:raw="A &lt;see cref=&quot;T:System.Guid&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor&quot; /&gt; equal to.">
        <see cref="T:System.Guid" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.SymbolDocumentInfo&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.FileName&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.Language&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor&quot; /&gt; properties set to the specified value.">
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> dont les propriétés <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> et <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> ont la valeur spécifiée.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid,System.Guid)">
      <summary vsli:raw="Creates an instance of &lt;see cref=&quot;T:System.Linq.Expressions.SymbolDocumentInfo&quot; /&gt;.">Crée une instance de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <param name="fileName" vsli:raw="A &lt;see cref=&quot;T:System.String&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.FileName&quot; /&gt; equal to.">
        <see cref="T:System.String" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> doit être égale.</param>
      <param name="language" vsli:raw="A &lt;see cref=&quot;T:System.Guid&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.Language&quot; /&gt; equal to.">
        <see cref="T:System.Guid" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> doit être égale.</param>
      <param name="languageVendor" vsli:raw="A &lt;see cref=&quot;T:System.Guid&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor&quot; /&gt; equal to.">
        <see cref="T:System.Guid" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> doit être égale.</param>
      <param name="documentType" vsli:raw="A &lt;see cref=&quot;T:System.Guid&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType&quot; /&gt; equal to.">
        <see cref="T:System.Guid" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.SymbolDocumentInfo&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.FileName&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.Language&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType&quot; /&gt; properties set to the specified value.">
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> dont les propriétés <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> et <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> ont la valeur spécifiée.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents a throwing of an exception.">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une levée d'exception.</summary>
      <param name="value" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Élément <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the exception.">Objet <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant l'exception.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents a throwing of an exception with a given type.">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente la levée d'une exception avec un type donné.</summary>
      <param name="value" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Élément <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="type" vsli:raw="The new &lt;see cref=&quot;T:System.Type&quot; /&gt; of the expression.">Nouveau <see cref="T:System.Type" /> d'une expression.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the exception.">Objet <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant l'exception.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ToString">
      <summary vsli:raw="Returns a textual representation of the &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Retourne une représentation textuelle de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns vsli:raw="A textual representation of the &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Représentation textuelle de <see cref="T:System.Linq.Expressions.Expression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryCatch(System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.TryExpression&quot; /&gt; representing a try block with any number of catch statements and neither a fault nor finally block.">Crée un <see cref="T:System.Linq.Expressions.TryExpression" /> qui représente un bloc Try avec un nombre quelconque d'instructions Catch mais ni une erreur, ni un bloc Finally.</summary>
      <param name="body" vsli:raw="The body of the try block.">Corps du bloc Try.</param>
      <param name="handlers" vsli:raw="The array of zero or more &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt; expressions representing the catch statements to be associated with the try block.">Tableau de zéro ou plusieurs expressions <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente les instructions Catch à associer au bloc Try.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.TryExpression&quot; /&gt;.">Élément <see cref="T:System.Linq.Expressions.TryExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryCatchFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.TryExpression&quot; /&gt; representing a try block with any number of catch statements and a finally block.">Crée un <see cref="T:System.Linq.Expressions.TryExpression" /> qui représente un bloc Try avec un nombre quelconque d'instructions Catch et un bloc Finally.</summary>
      <param name="body" vsli:raw="The body of the try block.">Corps du bloc Try.</param>
      <param name="finally" vsli:raw="The body of the finally block.">Corps du bloc Finally.</param>
      <param name="handlers" vsli:raw="The array of zero or more &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt; expressions representing the catch statements to be associated with the try block.">Tableau de zéro ou plusieurs expressions <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente les instructions Catch à associer au bloc Try.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.TryExpression&quot; /&gt;.">Élément <see cref="T:System.Linq.Expressions.TryExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryFault(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.TryExpression&quot; /&gt; representing a try block with a fault block and no catch statements.">Crée un <see cref="T:System.Linq.Expressions.TryExpression" /> qui représente un bloc Try avec un bloc Fault et aucune instruction Catch.</summary>
      <param name="body" vsli:raw="The body of the try block.">Corps du bloc Try.</param>
      <param name="fault" vsli:raw="The body of the fault block.">Corps du bloc Fault.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.TryExpression&quot; /&gt;.">Élément <see cref="T:System.Linq.Expressions.TryExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.TryExpression&quot; /&gt; representing a try block with a finally block and no catch statements.">Crée un <see cref="T:System.Linq.Expressions.TryExpression" /> qui représente un bloc Try avec un bloc Finally et aucune instruction Catch.</summary>
      <param name="body" vsli:raw="The body of the try block.">Corps du bloc Try.</param>
      <param name="finally" vsli:raw="The body of the finally block.">Corps du bloc Finally.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.TryExpression&quot; /&gt;.">Élément <see cref="T:System.Linq.Expressions.TryExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryGetActionType(System.Type[],System.Type@)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; object that represents a generic System.Action delegate type that has specific type arguments.">Crée un objet <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente un type délégué System.Action générique comportant des arguments de type spécifiques.</summary>
      <param name="typeArgs" vsli:raw="An array of Type objects that specify the type arguments for the System.Action delegate type.">Tableau d’objets Type qui spécifient les arguments de type pour le type délégué System.Action.</param>
      <param name="actionType" vsli:raw="When this method returns, contains the generic System.Action delegate type that has specific type arguments. Contains null if there is no generic System.Action delegate that matches the &lt;paramref name=&quot;typeArgs&quot; /&gt;. This parameter is passed uninitialized.">Cette méthode retourne le type délégué System.Action générique qui comporte des arguments de type spécifiques. Contient la valeur Null s'il n'y a aucun délégué System.Action générique qui correspond au <paramref name="typeArgs" />. Ce paramètre est passé sans être initialisé.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if generic System.Action delegate type was created for specific &lt;paramref name=&quot;typeArgs&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si le type délégué System.Action générique a été créé pour un <paramref name="typeArgs" /> spécifique, sinon <see langword="false" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryGetFuncType(System.Type[],System.Type@)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; object that represents a generic System.Func delegate type that has specific type arguments. The last type argument specifies the return type of the created delegate.">Crée un objet <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente un type délégué System.Func générique comportant des arguments de type spécifiques. Le dernier argument de type spécifie le type de retour du délégué créé.</summary>
      <param name="typeArgs" vsli:raw="An array of Type objects that specify the type arguments for the System.Func delegate type.">Tableau d'objets Type qui spécifient les arguments de type pour le type délégué System.Func.</param>
      <param name="funcType" vsli:raw="When this method returns, contains the generic System.Func delegate type that has specific type arguments. Contains null if there is no generic System.Func delegate that matches the &lt;paramref name=&quot;typeArgs&quot; /&gt;. This parameter is passed uninitialized.">Cette méthode retourne le type délégué System.Func générique qui comporte des arguments de type spécifiques. Contient la valeur null s'il n'existe aucun délégué System.Func générique qui correspond au <paramref name="typeArgs" />. Ce paramètre est passé sans être initialisé.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if generic System.Func delegate type was created for specific &lt;paramref name=&quot;typeArgs&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si le type délégué System.Func générique a été créé pour un <paramref name="typeArgs" /> spécifique, sinon <see langword="false" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.Expression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; that represents the static type of the expression.">
        <see cref="T:System.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeAs(System.Linq.Expressions.Expression,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents an explicit reference or boxing conversion where &lt;see langword=&quot;null&quot; /&gt; is supplied if the conversion fails.">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une référence explicite ou une conversion boxing où la valeur <see langword="null" /> est fournie en cas d'échec de la conversion.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="type" vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property equal to.">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.TypeAs&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.TypeAs" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.Expression.Type" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; or &lt;paramref name=&quot;type&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> ou <paramref name="type" /> est <see langword="null" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.TypeBinaryExpression&quot; /&gt; that compares run-time type identity.">Crée un <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> qui compare l'identité de type à l'exécution.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="T:System.Linq.Expressions.Expression" /> doit être égale.</param>
      <param name="type" vsli:raw="A &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand&quot; /&gt; property equal to.">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.TypeBinaryExpression&quot; /&gt; for which the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property is equal to &lt;see cref=&quot;M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)&quot; /&gt; and for which the &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand&quot; /&gt; properties are set to the specified values.">
        <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" /> et dont les propriétés <see cref="T:System.Linq.Expressions.Expression" /> et <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeIs(System.Linq.Expressions.Expression,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.TypeBinaryExpression&quot; /&gt;.">Crée un <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.TypeBinaryExpression.Expression&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> doit être égale.</param>
      <param name="type" vsli:raw="A &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand&quot; /&gt; property equal to.">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.TypeBinaryExpression&quot; /&gt; for which the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property is equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.TypeIs&quot; /&gt; and for which the &lt;see cref=&quot;P:System.Linq.Expressions.TypeBinaryExpression.Expression&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand&quot; /&gt; properties are set to the specified values.">
        <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.TypeIs" /> et dont les propriétés <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> et <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; or &lt;paramref name=&quot;type&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> ou <paramref name="type" /> est <see langword="null" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents a unary plus operation.">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération plus unaire.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.UnaryPlus&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property set to the specified value.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> et dont la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> a la valeur spécifiée.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The unary plus operator is not defined for &lt;paramref name=&quot;expression&quot; /&gt;.Type.">L'opérateur plus unaire n'est pas défini pour <paramref name="expression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents a unary plus operation.">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération plus unaire.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property equal to.">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Method&quot; /&gt; property equal to.">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> doit être égale.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.UnaryPlus&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Method&quot; /&gt; properties set to the specified values.">
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly one argument.">
        <paramref name="method" /> n'est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas un argument exactement.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the unary plus operator is not defined for &lt;paramref name=&quot;expression&quot; /&gt;.Type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;expression&quot; /&gt;.Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by &lt;paramref name=&quot;method&quot; /&gt;.">
        <paramref name="method" /> est <see langword="null" /> et l'opérateur plus unaire n'est pas défini pour <paramref name="expression" />.Type.  

ou - 
<paramref name="expression" />.Type (ou son type non Nullable correspondant s'il s'agit d'un type valeur Nullable) ne peut pas être assigné au type d'argument de la méthode représentée par <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Unbox(System.Linq.Expressions.Expression,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents an explicit unboxing.">Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente un unboxing explicite.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to unbox.">Objet <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer un unboxing.</param>
      <param name="type" vsli:raw="The new &lt;see cref=&quot;T:System.Type&quot; /&gt; of the expression.">Nouveau <see cref="T:System.Type" /> d'une expression.</param>
      <returns vsli:raw="An instance of &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt;.">Instance de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Variable(System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; node that can be used to identify a parameter or a variable in an expression tree.">Crée un nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> qui peut être utilisé pour identifier un paramètre ou une variable dans une arborescence d’expression.</summary>
      <param name="type" vsli:raw="The type of the parameter or variable.">Type du paramètre ou de la variable.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; node with the specified name and type.">Nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> avec le nom et le type spécifiés.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Variable(System.Type,System.String)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; node that can be used to identify a parameter or a variable in an expression tree.">Crée un nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> qui peut être utilisé pour identifier un paramètre ou une variable dans une arborescence d’expression.</summary>
      <param name="type" vsli:raw="The type of the parameter or variable.">Type du paramètre ou de la variable.</param>
      <param name="name" vsli:raw="The name of the parameter or variable. This name is used for debugging or printing purpose only.">Nom du paramètre ou de la variable. Ce nom est utilisé à des fins de débogage ou d'impression uniquement.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; node with the specified name and type.">Nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> avec le nom et le type spécifiés.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.VisitChildren(System.Linq.Expressions.ExpressionVisitor)">
      <summary vsli:raw="Reduces the node and then calls the visitor delegate on the reduced expression. The method throws an exception if the node is not reducible.">Réduit le nœud puis appelle le délégué visiteur sur l'expression réduite. La méthode lève une exception si le nœud n'est pas réductible.</summary>
      <param name="visitor" vsli:raw="An instance of &lt;see cref=&quot;T:System.Func`2&quot; /&gt;.">Instance de <see cref="T:System.Func`2" />.</param>
      <returns vsli:raw="The expression being visited, or an expression which should replace it in the tree.">Expression qui est visitée ou expression qui doit la remplacer dans l’arborescence.</returns>
    </member>
    <member name="T:System.Linq.Expressions.Expression`1">
      <summary vsli:raw="Represents a strongly typed lambda expression as a data structure in the form of an expression tree. This class cannot be inherited.">Représente une expression lambda fortement typée comme une structure de données sous forme d'arborescence de l'expression. Cette classe ne peut pas être héritée.</summary>
      <typeparam name="TDelegate" vsli:raw="The type of the delegate that the &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt; represents.">Type du délégué représenté par le <see cref="T:System.Linq.Expressions.Expression`1" />.</typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Compile">
      <summary vsli:raw="Compiles the lambda expression described by the expression tree into executable code and produces a delegate that represents the lambda expression.">Compile l'expression lambda décrite par l'arborescence de l'expression dans le code exécutable et produit un délégué qui représente l'expression lambda.</summary>
      <returns vsli:raw="A delegate of type &lt;paramref name=&quot;TDelegate&quot; /&gt; that represents the compiled lambda expression described by the &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt;.">Délégué de type <paramref name="TDelegate" /> qui représente l'expression lambda compilée décrite par <see cref="T:System.Linq.Expressions.Expression`1" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Compile(System.Boolean)">
      <summary vsli:raw="Compiles the lambda expression described by the expression tree into interpreted or compiled code and produces a delegate that represents the lambda expression.">Compile l’expression lambda décrite par l’arborescence de l’expression dans du code interprété ou compilé, et produit un délégué qui représente l’expression lambda.</summary>
      <param name="preferInterpretation" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to indicate that the expression should be compiled to an interpreted form, if it is available; &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" /> pour indiquer que l’expression doit être compilée en un formulaire interprété, si disponible ; <see langword="false" /> dans le cas contraire.</param>
      <returns vsli:raw="A delegate that represents the compiled lambda expression described by the &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt;.">Délégué qui représente l’expression lambda compilée décrite par <see cref="T:System.Linq.Expressions.Expression`1" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Compile(System.Runtime.CompilerServices.DebugInfoGenerator)">
      <summary vsli:raw="Produces a delegate that represents the lambda expression.">Produit un délégué qui représente l'expression lambda.</summary>
      <param name="debugInfoGenerator" vsli:raw="Debugging information generator used by the compiler to mark sequence points and annotate local variables.">Générateur d'informations de débogage utilisé par le compilateur pour marquer les points de séquence et annoter les variables locales.</param>
      <returns vsli:raw="A delegate containing the compiled version of the lambda.">Délégué qui contient la version compilée du lambda.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="body" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property of the result.">Propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> du résultat.</param>
      <param name="parameters" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; property of the result.">Propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> du résultat.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ExpressionType">
      <summary vsli:raw="Describes the node types for the nodes of an expression tree.">Décrit les types de nœuds d'une arborescence d'expression.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Add">
      <summary vsli:raw="An addition operation, such as &lt;c&gt;a + b&lt;/c&gt;, without overflow checking, for numeric operands.">Opération d’addition, telle que <c>a + b</c>, sans contrôle de dépassement de capacité, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddAssign">
      <summary vsli:raw="An addition compound assignment operation, such as &lt;c&gt;(a += b)&lt;/c&gt;, without overflow checking, for numeric operands.">Opération d’assignation composée d’addition, telle que <c>(a += b)</c>, sans contrôle de dépassement de capacité, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddAssignChecked">
      <summary vsli:raw="An addition compound assignment operation, such as &lt;c&gt;(a += b)&lt;/c&gt;, with overflow checking, for numeric operands.">Opération d’assignation composée d’addition, telle que <c>(a += b)</c>, avec contrôle de dépassement de capacité, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddChecked">
      <summary vsli:raw="An addition operation, such as &lt;c&gt;(a + b)&lt;/c&gt;, with overflow checking, for numeric operands.">Opération d’addition telle que <c>(a + b)</c>, avec contrôle de dépassement de capacité, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.And">
      <summary vsli:raw="A bitwise or logical &lt;see langword=&quot;AND&quot; /&gt; operation, such as &lt;c&gt;(a &amp;amp; b)&lt;/c&gt; in C# and &lt;c&gt;(a And b)&lt;/c&gt; in Visual Basic.">Opération <see langword="AND" /> logique ou au niveau du bit, telle que <c>(a &amp;b)</c> en C# et <c>(a And b)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AndAlso">
      <summary vsli:raw="A conditional &lt;see langword=&quot;AND&quot; /&gt; operation that evaluates the second operand only if the first operand evaluates to &lt;see langword=&quot;true&quot; /&gt;. It corresponds to &lt;c&gt;(a &amp;amp;&amp;amp; b)&lt;/c&gt; in C# and &lt;c&gt;(a AndAlso b)&lt;/c&gt; in Visual Basic.">Opération <see langword="AND" /> conditionnelle qui évalue la deuxième opérande uniquement si la première opérande a la valeur <see langword="true" />. Correspond à <c>(a &amp;&amp; b)</c> en C# et <c>(a AndAlso b)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AndAssign">
      <summary vsli:raw="A bitwise or logical &lt;see langword=&quot;AND&quot; /&gt; compound assignment operation, such as &lt;c&gt;(a &amp;amp;= b)&lt;/c&gt; in C#.">Opération d’assignation composée <see langword="AND" /> logique ou au niveau du bit, telle que <c>(a &amp;= b)</c> en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ArrayIndex">
      <summary vsli:raw="An indexing operation in a one-dimensional array, such as &lt;c&gt;array[index]&lt;/c&gt; in C# or &lt;c&gt;array(index)&lt;/c&gt; in Visual Basic.">Opération d’indexation dans un tableau unidimensionnel, telle que <c>array[index]</c> en C# ou <c>array(index)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ArrayLength">
      <summary vsli:raw="An operation that obtains the length of a one-dimensional array, such as &lt;c&gt;array.Length&lt;/c&gt;.">Opération qui obtient la longueur d’un tableau unidimensionnel, telle que <c>array.Length</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Assign">
      <summary vsli:raw="An assignment operation, such as &lt;c&gt;(a = b)&lt;/c&gt;.">Opération d’assignation telle que <c>(a = b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Block">
      <summary vsli:raw="A block of expressions.">Bloc d'expressions.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Call">
      <summary vsli:raw="A method call, such as in the &lt;c&gt;obj.sampleMethod()&lt;/c&gt; expression.">Appel de méthode, comme dans l’expression <c>obj.sampleMethod()</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Coalesce">
      <summary vsli:raw="A node that represents a null coalescing operation, such as &lt;c&gt;(a ?? b)&lt;/c&gt; in C# or &lt;c&gt;If(a, b)&lt;/c&gt; in Visual Basic.">Nœud qui représente une opération de fusion nulle, telle que <c>(a ?? b)</c> en C# ou <c>If(a, b)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Conditional">
      <summary vsli:raw="A conditional operation, such as &lt;c&gt;a &amp;gt; b ? a : b&lt;/c&gt; in C# or &lt;c&gt;If(a &amp;gt; b, a, b)&lt;/c&gt; in Visual Basic.">Opération conditionnelle, telle que <c>a &gt; b ? a : b</c> en C# ou <c>If(a &gt;b, a, b)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Constant">
      <summary vsli:raw="A constant value.">Valeur de constante.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Convert">
      <summary vsli:raw="A cast or conversion operation, such as &lt;c&gt;(SampleType)obj&lt;/c&gt; in C#or &lt;c&gt;CType(obj, SampleType)&lt;/c&gt; in Visual Basic. For a numeric conversion, if the converted value is too large for the destination type, no exception is thrown.">Opération de cast ou de conversion, telle que <c>(SampleType)obj</c> en C# ou <c>CType(obj, SampleType)</c> en Visual Basic. Pour une conversion numérique, si la valeur convertie est trop grande pour le type de destination, aucune exception n'est levée.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ConvertChecked">
      <summary vsli:raw="A cast or conversion operation, such as &lt;c&gt;(SampleType)obj&lt;/c&gt; in C#or &lt;c&gt;CType(obj, SampleType)&lt;/c&gt; in Visual Basic. For a numeric conversion, if the converted value does not fit the destination type, an exception is thrown.">Opération de cast ou de conversion, telle que <c>(SampleType)obj</c> en C# ou <c>CType(obj, SampleType)</c> en Visual Basic. Pour une conversion numérique, si la valeur convertie ne correspond pas au type cible, une exception est levée.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.DebugInfo">
      <summary vsli:raw="Debugging information.">Informations de débogage.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Decrement">
      <summary vsli:raw="A unary decrement operation, such as &lt;c&gt;(a - 1)&lt;/c&gt; in C# and Visual Basic. The object &lt;c&gt;a&lt;/c&gt; should not be modified in place.">Opération de décrémentation unaire, telle que <c>(a - 1)</c> en C# et Visual Basic. L’objet <c>a</c> ne doit pas être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Default">
      <summary vsli:raw="A default value.">Valeur par défaut.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Divide">
      <summary vsli:raw="A division operation, such as &lt;c&gt;(a / b)&lt;/c&gt;, for numeric operands.">Opération de division, telle que <c>(a / b)</c>, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.DivideAssign">
      <summary vsli:raw="An division compound assignment operation, such as &lt;c&gt;(a /= b)&lt;/c&gt;, for numeric operands.">Opération d’assignation composée de division, telle que <c>(a /= b)</c>, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Dynamic">
      <summary vsli:raw="A dynamic operation.">Opération dynamique.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Equal">
      <summary vsli:raw="A node that represents an equality comparison, such as &lt;c&gt;(a == b)&lt;/c&gt; in C# or &lt;c&gt;(a = b)&lt;/c&gt; in Visual Basic.">Nœud qui représente une comparaison d’égalité, telle que <c>(a == b)</c> en C# ou <c>(a = b)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ExclusiveOr">
      <summary vsli:raw="A bitwise or logical &lt;see langword=&quot;XOR&quot; /&gt; operation, such as &lt;c&gt;(a ^ b)&lt;/c&gt; in C# or &lt;c&gt;(a Xor b)&lt;/c&gt; in Visual Basic.">Opération <see langword="XOR" /> logique ou au niveau du bit, telle que <c>(a ^ b)</c> en C# ou <c>(a Xor b)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign">
      <summary vsli:raw="A bitwise or logical &lt;see langword=&quot;XOR&quot; /&gt; compound assignment operation, such as &lt;c&gt;(a ^= b)&lt;/c&gt; in C#.">Opération d’assignation composée <see langword="XOR" /> logique ou au niveau du bit, telle que <c>(a ^= b)</c> en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Extension">
      <summary vsli:raw="An extension expression.">Expression d'extension.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Goto">
      <summary vsli:raw="A &quot;go to&quot; expression, such as &lt;c&gt;goto Label&lt;/c&gt; in C# or &lt;c&gt;GoTo Label&lt;/c&gt; in Visual Basic.">Expression " go to ", telle que <c>goto Label</c> en C# ou <c>GoTo Label</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.GreaterThan">
      <summary vsli:raw="A &quot;greater than&quot; comparison, such as &lt;c&gt;(a &amp;gt; b)&lt;/c&gt;.">Comparaison numérique " supérieur à ", telle que <c>(a &gt;b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual">
      <summary vsli:raw="A &quot;greater than or equal to&quot; comparison, such as &lt;c&gt;(a &amp;gt;= b)&lt;/c&gt;.">Comparaison " supérieur ou égal à ", telle que <c>(a &gt;= b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Increment">
      <summary vsli:raw="A unary increment operation, such as &lt;c&gt;(a + 1)&lt;/c&gt; in C# and Visual Basic. The object &lt;c&gt;a&lt;/c&gt; should not be modified in place.">Opération d’incrémentation unaire, telle que <c>(a + 1)</c> en C# et Visual Basic. L’objet <c>a</c> ne doit pas être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Index">
      <summary vsli:raw="An index operation or an operation that accesses a property that takes arguments.">Opération d'index ou opération qui accède à une propriété qui prend des arguments.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Invoke">
      <summary vsli:raw="An operation that invokes a delegate or lambda expression, such as &lt;c&gt;sampleDelegate.Invoke()&lt;/c&gt;.">Opération qui appelle un délégué ou une expression lambda, telle que <c>sampleDelegate.Invoke()</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.IsFalse">
      <summary vsli:raw="A &lt;see langword=&quot;false&quot; /&gt; condition value.">Valeur de condition <see langword="false" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.IsTrue">
      <summary vsli:raw="A &lt;see langword=&quot;true&quot; /&gt; condition value.">Valeur de condition <see langword="true" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Label">
      <summary vsli:raw="A label.">Étiquette.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Lambda">
      <summary vsli:raw="A lambda expression, such as &lt;c&gt;a =&amp;gt; a + a&lt;/c&gt; in C# or &lt;c&gt;Function(a) a + a&lt;/c&gt; in Visual Basic.">Expression lambda, telle que <c>a =&gt;a + a</c> en C# ou <c>Function(a) a + a</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LeftShift">
      <summary vsli:raw="A bitwise left-shift operation, such as &lt;c&gt;(a &amp;lt;&amp;lt; b)&lt;/c&gt;.">Opération de décalage vers la gauche au niveau du bit, telle que <c>(a &lt;&lt;b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign">
      <summary vsli:raw="A bitwise left-shift compound assignment, such as &lt;c&gt;(a &amp;lt;&amp;lt;= b)&lt;/c&gt;.">Assignation composée de décalage vers la gauche au niveau du bit, telle que <c>(a &lt;&lt;= b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LessThan">
      <summary vsli:raw="A &quot;less than&quot; comparison, such as &lt;c&gt;(a &amp;lt; b)&lt;/c&gt;.">Comparaison " inférieur à ", telle que <c>(a &lt;b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual">
      <summary vsli:raw="A &quot;less than or equal to&quot; comparison, such as &lt;c&gt;(a &amp;lt;= b)&lt;/c&gt;.">Comparaison " inférieur ou égal à ", telle que <c>(a &lt;= b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ListInit">
      <summary vsli:raw="An operation that creates a new &lt;see cref=&quot;T:System.Collections.IEnumerable&quot; /&gt; object and initializes it from a list of elements, such as &lt;c&gt;new List&amp;lt;SampleType&amp;gt;(){ a, b, c }&lt;/c&gt; in C# or &lt;c&gt;Dim sampleList = { a, b, c }&lt;/c&gt; in Visual Basic.">Opération qui crée un objet <see cref="T:System.Collections.IEnumerable" /> et l’initialise à partir d’une liste d’éléments, telle que <c>new List&lt;SampleType&gt;(){ a, b, c }</c> en C# ou <c>Dim sampleList = { a, b, c }</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Loop">
      <summary vsli:raw="A loop, such as &lt;c&gt;for&lt;/c&gt; or &lt;c&gt;while&lt;/c&gt;.">Boucle, telle que <c>for</c> ou <c>while</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MemberAccess">
      <summary vsli:raw="An operation that reads from a field or property, such as &lt;c&gt;obj.SampleProperty&lt;/c&gt;.">Opération qui lit un champ ou une propriété, telle que <c>obj.SampleProperty</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MemberInit">
      <summary vsli:raw="An operation that creates a new object and initializes one or more of its members, such as &lt;c&gt;new Point { X = 1, Y = 2 }&lt;/c&gt; in C# or &lt;c&gt;New Point With {.X = 1, .Y = 2}&lt;/c&gt; in Visual Basic.">Opération qui crée un objet et initialise un ou plusieurs de ses membres, telle que <c>new Point { X = 1, Y = 2 }</c> en C# ou <c>New Point With {.X = 1, .Y = 2}</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Modulo">
      <summary vsli:raw="An arithmetic remainder operation, such as &lt;c&gt;(a % b)&lt;/c&gt; in C# or &lt;c&gt;(a Mod b)&lt;/c&gt; in Visual Basic.">Opération arithmétique relative au reste, telle que <c>(a % b)</c> en C# ou <c>(a Mod b)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ModuloAssign">
      <summary vsli:raw="An arithmetic remainder compound assignment operation, such as &lt;c&gt;(a %= b)&lt;/c&gt; in C#.">Opération arithmétique d’assignation composée du reste, telle que <c>(a %= b)</c> en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Multiply">
      <summary vsli:raw="A multiplication operation, such as &lt;c&gt;(a * b)&lt;/c&gt;, without overflow checking, for numeric operands.">Opération de multiplication, telle que <c>(a * b)</c>, sans contrôle de dépassement de capacité, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyAssign">
      <summary vsli:raw="A multiplication compound assignment operation, such as &lt;c&gt;(a *= b)&lt;/c&gt;, without overflow checking, for numeric operands.">Opération d’assignation composée de multiplication, telle que <c>(a *= b)</c>, sans contrôle de dépassement de capacité, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked">
      <summary vsli:raw="A multiplication compound assignment operation, such as &lt;c&gt;(a *= b)&lt;/c&gt;, that has overflow checking, for numeric operands.">Opération d’assignation composée de multiplication, telle que <c>(a *= b)</c>, avec contrôle de dépassement de capacité, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyChecked">
      <summary vsli:raw="An multiplication operation, such as &lt;c&gt;(a * b)&lt;/c&gt;, that has overflow checking, for numeric operands.">Opération de multiplication, telle que <c>(a * b)</c>, avec contrôle de dépassement de capacité, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Negate">
      <summary vsli:raw="An arithmetic negation operation, such as &lt;c&gt;(-a)&lt;/c&gt;. The object &lt;c&gt;a&lt;/c&gt; should not be modified in place.">Opération arithmétique de négation, telle que <c>(-a)</c>. L’objet <c>a</c> ne doit pas être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NegateChecked">
      <summary vsli:raw="An arithmetic negation operation, such as &lt;c&gt;(-a)&lt;/c&gt;, that has overflow checking. The object &lt;c&gt;a&lt;/c&gt; should not be modified in place.">Opération arithmétique de négation, telle que <c>(-a)</c>, avec contrôle de dépassement de capacité. L’objet <c>a</c> ne doit pas être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.New">
      <summary vsli:raw="An operation that calls a constructor to create a new object, such as &lt;c&gt;new SampleType()&lt;/c&gt;.">Opération qui appelle un constructeur pour créer un objet, telle que <c>new SampleType()</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NewArrayBounds">
      <summary vsli:raw="An operation that creates a new array, in which the bounds for each dimension are specified, such as &lt;c&gt;new SampleType[dim1, dim2]&lt;/c&gt; in C# or &lt;c&gt;New SampleType(dim1, dim2)&lt;/c&gt; in Visual Basic.">Opération qui crée un tableau dans lequel les limites de chaque dimension sont spécifiées, telle que <c>new SampleType[dim1, dim2]</c> en C# ou <c>New SampleType(dim1, dim2)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NewArrayInit">
      <summary vsli:raw="An operation that creates a new one-dimensional array and initializes it from a list of elements, such as &lt;c&gt;new SampleType[]{a, b, c}&lt;/c&gt; in C# or &lt;c&gt;New SampleType(){a, b, c}&lt;/c&gt; in Visual Basic.">Opération qui crée un tableau unidimensionnel et l’initialise à partir d’une liste d’éléments, telle que <c>new SampleType[]{a, b, c}</c> en C# ou <c>New SampleType(){a, b, c}</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Not">
      <summary vsli:raw="A bitwise complement or logical negation operation. In C#, it is equivalent to &lt;c&gt;(~a)&lt;/c&gt; for integral types and to &lt;c&gt;(!a)&lt;/c&gt; for Boolean values. In Visual Basic, it is equivalent to &lt;c&gt;(Not a)&lt;/c&gt;. The object &lt;c&gt;a&lt;/c&gt; should not be modified in place.">Complément de bits ou opération de négation logique. En C#, équivaut à <c>(~a)</c> pour les types intégraux et à <c>(!a)</c> pour les valeurs booléennes. En Visual Basic, équivaut à <c>(Not a)</c>. L’objet <c>a</c> ne doit pas être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NotEqual">
      <summary vsli:raw="An inequality comparison, such as &lt;c&gt;(a != b)&lt;/c&gt; in C# or &lt;c&gt;(a &amp;lt;&amp;gt; b)&lt;/c&gt; in Visual Basic.">Comparaison d’inégalité, telle que <c>(a != b)</c> en C# ou <c>(a &lt;&gt;b)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OnesComplement">
      <summary vsli:raw="A ones complement operation, such as &lt;c&gt;(~a)&lt;/c&gt; in C#.">Opération de complément à 1, telle que <c>(~a)</c> en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Or">
      <summary vsli:raw="A bitwise or logical &lt;see langword=&quot;OR&quot; /&gt; operation, such as &lt;c&gt;(a | b)&lt;/c&gt; in C# or &lt;c&gt;(a Or b)&lt;/c&gt; in Visual Basic.">Opération <see langword="OR" /> logique ou au niveau du bit, telle que <c>(a | b)</c> en C# ou <c>(a Or b)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OrAssign">
      <summary vsli:raw="A bitwise or logical &lt;see langword=&quot;OR&quot; /&gt; compound assignment, such as &lt;c&gt;(a |= b)&lt;/c&gt; in C#.">Assignation composée <see langword="OR" /> logique ou au niveau du bit, telle que <c>(a |= b)</c> en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OrElse">
      <summary vsli:raw="A short-circuiting conditional &lt;see langword=&quot;OR&quot; /&gt; operation, such as &lt;c&gt;(a || b)&lt;/c&gt; in C# or &lt;c&gt;(a OrElse b)&lt;/c&gt; in Visual Basic.">Opération <see langword="OR" /> conditionnelle de court-circuit, telle que <c>(a || b)</c> en C# ou <c>(a OrElse b)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Parameter">
      <summary vsli:raw="A reference to a parameter or variable that is defined in the context of the expression. For more information, see &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt;.">Référence à un paramètre ou une variable défini(e) dans le contexte de l'expression. Pour plus d'informations, consultez <see cref="T:System.Linq.Expressions.ParameterExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PostDecrementAssign">
      <summary vsli:raw="A unary postfix decrement, such as &lt;c&gt;(a--)&lt;/c&gt;. The object &lt;c&gt;a&lt;/c&gt; should be modified in place.">Décrément suffixé unaire, tel que <c>(a--)</c>. L’objet <c>a</c> doit être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PostIncrementAssign">
      <summary vsli:raw="A unary postfix increment, such as &lt;c&gt;(a++)&lt;/c&gt;. The object &lt;c&gt;a&lt;/c&gt; should be modified in place.">Incrément suffixé unaire, tel que <c>(a++)</c>. L’objet <c>a</c> doit être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Power">
      <summary vsli:raw="A mathematical operation that raises a number to a power, such as &lt;c&gt;(a ^ b)&lt;/c&gt; in Visual Basic.">Opération mathématique qui élève un nombre à une puissance, telle que <c>(a ^ b)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PowerAssign">
      <summary vsli:raw="A compound assignment operation that raises a number to a power, such as &lt;c&gt;(a ^= b)&lt;/c&gt; in Visual Basic.">Opération d’assignation composée qui élève un nombre à une puissance, telle que <c>(a ^= b)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PreDecrementAssign">
      <summary vsli:raw="A unary prefix decrement, such as &lt;c&gt;(--a)&lt;/c&gt;. The object &lt;c&gt;a&lt;/c&gt; should be modified in place.">Décrément préfixé unaire, tel que <c>(--a)</c>. L’objet <c>a</c> doit être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PreIncrementAssign">
      <summary vsli:raw="A unary prefix increment, such as &lt;c&gt;(++a)&lt;/c&gt;. The object &lt;c&gt;a&lt;/c&gt; should be modified in place.">Incrément préfixé unaire, tel que <c>(++a)</c>. L’objet <c>a</c> doit être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Quote">
      <summary vsli:raw="An expression that has a constant value of type &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;. A &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Quote&quot; /&gt; node can contain references to parameters that are defined in the context of the expression it represents.">Expression comportant une valeur constante de type <see cref="T:System.Linq.Expressions.Expression" />. Un nœud <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> peut contenir les références aux paramètres définis dans le contexte de l'expression qu'il représente.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RightShift">
      <summary vsli:raw="A bitwise right-shift operation, such as &lt;c&gt;(a &amp;gt;&amp;gt; b)&lt;/c&gt;.">Opération de décalage vers la droite au niveau du bit, telle que <c>(a &gt;&gt; b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RightShiftAssign">
      <summary vsli:raw="A bitwise right-shift compound assignment operation, such as &lt;c&gt;(a &amp;gt;&amp;gt;= b)&lt;/c&gt;.">Opération d’assignation composée de décalage vers la droite au niveau du bit, telle que <c>(a &gt;&gt;= b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RuntimeVariables">
      <summary vsli:raw="A list of run-time variables. For more information, see &lt;see cref=&quot;T:System.Linq.Expressions.RuntimeVariablesExpression&quot; /&gt;.">Liste de variables d'exécution. Pour plus d'informations, consultez <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Subtract">
      <summary vsli:raw="A subtraction operation, such as &lt;c&gt;(a - b)&lt;/c&gt;, without overflow checking, for numeric operands.">Opération de soustraction, telle que <c>(a - b)</c>, sans contrôle de dépassement de capacité, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractAssign">
      <summary vsli:raw="A subtraction compound assignment operation, such as &lt;c&gt;(a -= b)&lt;/c&gt;, without overflow checking, for numeric operands.">Opération d’assignation composée de soustraction, telle que <c>(a -= b)</c>, sans contrôle de dépassement de capacité, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked">
      <summary vsli:raw="A subtraction compound assignment operation, such as &lt;c&gt;(a -= b)&lt;/c&gt;, that has overflow checking, for numeric operands.">Opération d’assignation composée de soustraction, telle que <c>(a -= b)</c>, avec contrôle de dépassement de capacité, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractChecked">
      <summary vsli:raw="An arithmetic subtraction operation, such as &lt;c&gt;(a - b)&lt;/c&gt;, that has overflow checking, for numeric operands.">Opération de soustraction arithmétique, telle que <c>(a - b)</c>, avec contrôle de dépassement de capacité, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Switch">
      <summary vsli:raw="A switch operation, such as &lt;see langword=&quot;switch&quot; /&gt; in C# or &lt;see langword=&quot;Select Case&quot; /&gt; in Visual Basic.">Opération de commutateur, telle que <see langword="switch" /> en C# ou <see langword="Select Case" /> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Throw">
      <summary vsli:raw="An operation that throws an exception, such as &lt;c&gt;throw new Exception()&lt;/c&gt;.">Opération qui lève une exception, telle que <c>throw new Exception()</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Try">
      <summary vsli:raw="A &lt;see langword=&quot;try-catch&quot; /&gt; expression.">Expression <see langword="try-catch" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeAs">
      <summary vsli:raw="An explicit reference or boxing conversion in which &lt;see langword=&quot;null&quot; /&gt; is supplied if the conversion fails, such as &lt;c&gt;(obj as SampleType)&lt;/c&gt; in C# or &lt;c&gt;TryCast(obj, SampleType)&lt;/c&gt; in Visual Basic.">Référence explicite ou conversion boxing dans laquelle la valeur <see langword="null" /> est fournie si la conversion échoue, telle que <c>(obj as SampleType)</c> en C# ou <c>TryCast(obj, SampleType)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeEqual">
      <summary vsli:raw="An exact type test.">Test de type exact.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeIs">
      <summary vsli:raw="A type test, such as &lt;c&gt;obj is SampleType&lt;/c&gt; in C# or &lt;c&gt;TypeOf obj is SampleType&lt;/c&gt; in Visual Basic.">Test de type, tel que <c>obj is SampleType</c> en C# ou <c>TypeOf obj is SampleType</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.UnaryPlus">
      <summary vsli:raw="A unary plus operation, such as &lt;c&gt;(+a)&lt;/c&gt;. The result of a predefined unary plus operation is the value of the operand, but user-defined implementations might have unusual results.">Opération plus unaire, telle que <c>(+a)</c>. Le résultat d'une opération plus unaire prédéfinie est la valeur de l'opérande, mais les implémentations définies par l'utilisateur peuvent avoir des résultats inhabituels.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Unbox">
      <summary vsli:raw="An unbox value type operation, such as &lt;see langword=&quot;unbox&quot; /&gt; and &lt;see langword=&quot;unbox.any&quot; /&gt; instructions in MSIL.">Opération de type valeur unbox, telle que les instructions <see langword="unbox" /> et <see langword="unbox.any" /> en MSIL.</summary>
    </member>
    <member name="T:System.Linq.Expressions.ExpressionVisitor">
      <summary vsli:raw="Represents a visitor or rewriter for expression trees.">Représente un visiteur ou un module de réécriture pour les arborescences d'expression.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.#ctor">
      <summary vsli:raw="Initializes a new instance of &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionVisitor&quot; /&gt;.">Initialise une nouvelle instance de <see cref="T:System.Linq.Expressions.ExpressionVisitor" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit(System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Dispatches the list of expressions to one of the more specialized visit methods in this class.">Distribue la liste des expressions à l'une des méthodes de visite les plus spécialisées dans cette classe.</summary>
      <param name="nodes" vsli:raw="The expressions to visit.">Expressions à visiter.</param>
      <returns vsli:raw="The modified expression list, if any one of the elements were modified; otherwise, returns the original expression list.">Liste d'expressions modifiées, si l'un des éléments a été modifié ; sinon, retourne la liste d'expressions d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Dispatches the expression to one of the more specialized visit methods in this class.">Distribue l'expression à l'une des méthodes de visite les plus spécialisées dans cette classe.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expression à visiter.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.Func{``0,``0})">
      <summary vsli:raw="Visits all nodes in the collection using a specified element visitor.">Visite tous les nœuds dans la collection à l'aide d'un visiteur d'élément spécifié.</summary>
      <param name="nodes" vsli:raw="The nodes to visit.">Nœuds à visiter.</param>
      <param name="elementVisitor" vsli:raw="A delegate that visits a single element, optionally replacing it with a new element.">Délégué qui visite un élément unique, éventuellement le remplaçant par un nouvel élément.</param>
      <typeparam name="T" vsli:raw="The type of the nodes.">Type des nœuds.</typeparam>
      <returns vsli:raw="The modified node list, if any of the elements were modified; otherwise, returns the original node list.">Liste de nœuds modifiés, si des éléments ont été modifiés ; sinon, retourne la liste de nœuds d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitAndConvert``1(``0,System.String)">
      <summary vsli:raw="Visits an expression, casting the result back to the original expression type.">Visite une expression, en effectuant un cast arrière du résultat vers le type d'expression d'origine.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expression à visiter.</param>
      <param name="callerName" vsli:raw="The name of the calling method; used to report to report a better error message.">Nom de la méthode d'appel ; utilisé pour signaler un meilleur message d'erreur.</param>
      <typeparam name="T" vsli:raw="The type of the expression.">Type de l'expression.</typeparam>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The visit method for this node returned a different type.">La méthode de visite pour ce nœud a retourné un type différent.</exception>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitAndConvert``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.String)">
      <summary vsli:raw="Visits all expressions in the collection, casting the results back to the original expression type.">Visite toutes les expressions de la collection, en effectuant un cast des résultats vers le type d’expression d’origine.</summary>
      <param name="nodes" vsli:raw="The expressions to visit.">Expressions à visiter.</param>
      <param name="callerName" vsli:raw="The name of the calling method; used to report a better error message.">Nom de la méthode d’appel ; utilisé pour signaler un meilleur message d’erreur.</param>
      <typeparam name="T" vsli:raw="The type of the expressions.">Type des expressions.</typeparam>
      <returns vsli:raw="The modified expression collection, if any expression was modified; otherwise, returns the original expression collection.">Collection de l’expression modifiée, si une expression a été modifiée ; sinon, retourne la collection de l’expression d’origine.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The visit method for one of the expressions returned a different type.">La méthode de visite pour l’une des expressions a retourné un type différent.</exception>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitBinary(System.Linq.Expressions.BinaryExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt;.">Visite les enfants de <see cref="T:System.Linq.Expressions.BinaryExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expression à visiter.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitBlock(System.Linq.Expressions.BlockExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt;.">Visite les enfants de <see cref="T:System.Linq.Expressions.BlockExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expression à visiter.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitCatchBlock(System.Linq.Expressions.CatchBlock)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt;.">Visite les enfants de <see cref="T:System.Linq.Expressions.CatchBlock" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expression à visiter.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitConditional(System.Linq.Expressions.ConditionalExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.ConditionalExpression&quot; /&gt;.">Visite les enfants de <see cref="T:System.Linq.Expressions.ConditionalExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expression à visiter.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitConstant(System.Linq.Expressions.ConstantExpression)">
      <summary vsli:raw="Visits the &lt;see cref=&quot;T:System.Linq.Expressions.ConstantExpression&quot; /&gt;.">Visite <see cref="T:System.Linq.Expressions.ConstantExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expression à visiter.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitDebugInfo(System.Linq.Expressions.DebugInfoExpression)">
      <summary vsli:raw="Visits the &lt;see cref=&quot;T:System.Linq.Expressions.DebugInfoExpression&quot; /&gt;.">Visite <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expression à visiter.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitDefault(System.Linq.Expressions.DefaultExpression)">
      <summary vsli:raw="Visits the &lt;see cref=&quot;T:System.Linq.Expressions.DefaultExpression&quot; /&gt;.">Visite <see cref="T:System.Linq.Expressions.DefaultExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expression à visiter.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitDynamic(System.Linq.Expressions.DynamicExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt;.">Visite les enfants de <see cref="T:System.Linq.Expressions.DynamicExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expression à visiter.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitElementInit(System.Linq.Expressions.ElementInit)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt;.">Visite les enfants de <see cref="T:System.Linq.Expressions.ElementInit" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expression à visiter.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitExtension(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Visits the children of the extension expression.">Visite les enfants de l'expression d'extension.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expression à visiter.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitGoto(System.Linq.Expressions.GotoExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt;.">Visite les enfants de <see cref="T:System.Linq.Expressions.GotoExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expression à visiter.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitIndex(System.Linq.Expressions.IndexExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.IndexExpression&quot; /&gt;.">Visite les enfants de <see cref="T:System.Linq.Expressions.IndexExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expression à visiter.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitInvocation(System.Linq.Expressions.InvocationExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.InvocationExpression&quot; /&gt;.">Visite les enfants de <see cref="T:System.Linq.Expressions.InvocationExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expression à visiter.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLabel(System.Linq.Expressions.LabelExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.LabelExpression&quot; /&gt;.">Visite les enfants de <see cref="T:System.Linq.Expressions.LabelExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expression à visiter.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLabelTarget(System.Linq.Expressions.LabelTarget)">
      <summary vsli:raw="Visits the &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt;.">Visite <see cref="T:System.Linq.Expressions.LabelTarget" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expression à visiter.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLambda``1(System.Linq.Expressions.Expression{``0})">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt;.">Visite les enfants de <see cref="T:System.Linq.Expressions.Expression`1" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expression à visiter.</param>
      <typeparam name="T" vsli:raw="The type of the delegate.">Type du délégué.</typeparam>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitListInit(System.Linq.Expressions.ListInitExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.ListInitExpression&quot; /&gt;.">Visite les enfants de <see cref="T:System.Linq.Expressions.ListInitExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expression à visiter.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLoop(System.Linq.Expressions.LoopExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.LoopExpression&quot; /&gt;.">Visite les enfants de <see cref="T:System.Linq.Expressions.LoopExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expression à visiter.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMember(System.Linq.Expressions.MemberExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt;.">Visite les enfants de <see cref="T:System.Linq.Expressions.MemberExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expression à visiter.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberAssignment(System.Linq.Expressions.MemberAssignment)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.MemberAssignment&quot; /&gt;.">Visite les enfants de <see cref="T:System.Linq.Expressions.MemberAssignment" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expression à visiter.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberBinding(System.Linq.Expressions.MemberBinding)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.MemberBinding&quot; /&gt;.">Visite les enfants de <see cref="T:System.Linq.Expressions.MemberBinding" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expression à visiter.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberInit(System.Linq.Expressions.MemberInitExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.MemberInitExpression&quot; /&gt;.">Visite les enfants de <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expression à visiter.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberListBinding(System.Linq.Expressions.MemberListBinding)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.MemberListBinding&quot; /&gt;.">Visite les enfants de <see cref="T:System.Linq.Expressions.MemberListBinding" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expression à visiter.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberMemberBinding(System.Linq.Expressions.MemberMemberBinding)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.MemberMemberBinding&quot; /&gt;.">Visite les enfants de <see cref="T:System.Linq.Expressions.MemberMemberBinding" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expression à visiter.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt;.">Visite les enfants de <see cref="T:System.Linq.Expressions.MethodCallExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expression à visiter.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitNew(System.Linq.Expressions.NewExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt;.">Visite les enfants de <see cref="T:System.Linq.Expressions.NewExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expression à visiter.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitNewArray(System.Linq.Expressions.NewArrayExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.NewArrayExpression&quot; /&gt;.">Visite les enfants de <see cref="T:System.Linq.Expressions.NewArrayExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expression à visiter.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitParameter(System.Linq.Expressions.ParameterExpression)">
      <summary vsli:raw="Visits the &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt;.">Visite <see cref="T:System.Linq.Expressions.ParameterExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expression à visiter.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitRuntimeVariables(System.Linq.Expressions.RuntimeVariablesExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.RuntimeVariablesExpression&quot; /&gt;.">Visite les enfants de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expression à visiter.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitSwitch(System.Linq.Expressions.SwitchExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.SwitchExpression&quot; /&gt;.">Visite les enfants de <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expression à visiter.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitSwitchCase(System.Linq.Expressions.SwitchCase)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.SwitchCase&quot; /&gt;.">Visite les enfants de <see cref="T:System.Linq.Expressions.SwitchCase" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expression à visiter.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitTry(System.Linq.Expressions.TryExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.TryExpression&quot; /&gt;.">Visite les enfants de <see cref="T:System.Linq.Expressions.TryExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expression à visiter.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitTypeBinary(System.Linq.Expressions.TypeBinaryExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.TypeBinaryExpression&quot; /&gt;.">Visite les enfants de <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expression à visiter.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitUnary(System.Linq.Expressions.UnaryExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt;.">Visite les enfants de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">Expression à visiter.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="T:System.Linq.Expressions.GotoExpression">
      <summary vsli:raw="Represents an unconditional jump. This includes return statements, break and continue statements, and other jumps.">Représente un saut inconditionnel. Cela inclut des instructions return, des instructions break et continue et d'autres sauts.</summary>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Kind">
      <summary vsli:raw="The kind of the &quot;go to&quot; expression. Serves information purposes only.">Type d'expression « go to ». Sert uniquement à des fins d'information.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpressionKind&quot; /&gt; object representing the kind of the &quot;go to&quot; expression.">Objet <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> qui représente le type d'expression « go to ».</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.NodeType">
      <summary vsli:raw="Returns the node type of this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that represents this expression.">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Target">
      <summary vsli:raw="The target label where this node jumps to.">Étiquette cible à laquelle ce nœud accède.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; object representing the target label for this node.">Objet <see cref="T:System.Linq.Expressions.LabelTarget" /> qui représente l'étiquette cible pour ce nœud.</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Type&quot; /&gt; that represents the static type of the expression.">
        <see cref="P:System.Linq.Expressions.GotoExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.GotoExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Target&quot; /&gt; property of the result.">Propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> du résultat.</param>
      <param name="value" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Value&quot; /&gt; property of the result.">Propriété <see cref="P:System.Linq.Expressions.GotoExpression.Value" /> du résultat.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Value">
      <summary vsli:raw="The value passed to the target, or null if the target is of type System.Void.">Valeur passée à la cible, ou null si la cible est de type System.Void.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; object representing the value passed to the target or null.">Objet <see cref="T:System.Linq.Expressions.Expression" /> qui représente la valeur passée à la cible ou null.</returns>
    </member>
    <member name="T:System.Linq.Expressions.GotoExpressionKind">
      <summary vsli:raw="Specifies what kind of jump this &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; represents.">Spécifie le type de saut que <see cref="T:System.Linq.Expressions.GotoExpression" /> représente.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Break">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; that represents a break statement.">
        <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction break.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Continue">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; that represents a continue statement.">
        <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction continue.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Goto">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; that represents a jump to some location.">
        <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente un saut vers un emplacement.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Return">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; that represents a return statement.">
        <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction return.</summary>
    </member>
    <member name="T:System.Linq.Expressions.IArgumentProvider">
      <summary vsli:raw="Provides an internal interface for accessing the arguments of multiple tree nodes (DynamicExpression, ElementInit, MethodCallExpression, InvocationExpression, NewExpression, and IndexExpression).  This API is for internal use only.">Fournit une interface interne pour accéder aux arguments de plusieurs nœuds d’arborescence (DynamicExpression, ElementInit, MethodCallExpression, InvocationExpression, NewExpression et IndexExpression).  Cette API est destinée à un usage interne uniquement.</summary>
    </member>
    <member name="P:System.Linq.Expressions.IArgumentProvider.ArgumentCount">
      <summary vsli:raw="Returns the number of arguments to the expression tree node. This API is for internal use only.">Retourne le nombre d’arguments du nœud d’arborescence d’expression. Cette API est destinée à un usage interne uniquement.</summary>
      <returns vsli:raw="The number of arguments to the expression tree node as &lt;see cref=&quot;T:System.Int32&quot; /&gt;.">Nombre d’arguments du nœud d’arborescence d’expression, au format <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.IArgumentProvider.GetArgument(System.Int32)">
      <summary vsli:raw="Returns the argument at &lt;paramref name=&quot;index&quot; /&gt;, throwing if &lt;paramref name=&quot;index&quot; /&gt; is out of bounds. This API is for internal use only.">Retourne l’argument à l’<paramref name="index" />, en levant une exception si l’<paramref name="index" /> est hors limites. Cette API est destinée à un usage interne uniquement.</summary>
      <param name="index" vsli:raw="The index of the argument.">Index de l’argument.</param>
      <returns vsli:raw="The argument at index.">Argument à l’index.</returns>
    </member>
    <member name="T:System.Linq.Expressions.IDynamicExpression">
      <summary vsli:raw="Provides an internal interface for accessing the arguments of DynamicExpression tree nodes as well as CallSite and Rewriting functionality.  You should not use this API.  It is only public due to DLL refactoring and exists only for internal performance optimizations.">Fournit une interface interne pour accéder aux arguments des nœuds d’arborescence DynamicExpression, ainsi qu’aux fonctionnalités CallSite et Rewriting.  Vous ne devez pas utiliser cette API.  Elle est publique uniquement en raison de la refactorisation de la DLL, et existe seulement pour optimiser les performances internes.</summary>
    </member>
    <member name="M:System.Linq.Expressions.IDynamicExpression.CreateCallSite">
      <summary vsli:raw="Optionally creates the CallSite and returns the CallSite for the DynamicExpression's polymorphic inline cache.  You should not use this type.  It is only public due to assembly refactoring, and it is used internally for performance optimizations.">Crée éventuellement CallSite et retourne CallSite pour le cache inline polymorphe de DynamicExpression.  Vous ne devez pas utiliser ce type.  Il est public uniquement en raison de la refactorisation de l’assembly, et il est utilisé en interne pour optimiser les performances.</summary>
      <returns vsli:raw="The CallSite for the DynamicExpression's polymorphic inline cache.">CallSite du cache inline polymorphe de DynamicExpression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IDynamicExpression.DelegateType">
      <summary vsli:raw="Gets the delegate type used by the CallSite, which is the type of the rules used in the dynamic expression's polymorphic inline cache.">Obtient le type délégué utilisé par CallSite, qui représente le type des règles utilisées dans le cache inline polymorphe de l’expression dynamique.</summary>
      <returns vsli:raw="The delegate type used by the CallSite.">Le type de délégué utilisé par le CallSite.</returns>
    </member>
    <member name="M:System.Linq.Expressions.IDynamicExpression.Rewrite(System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Rewrites this node replacing the dynamic expression's arguments with the provided values.  The number of &lt;paramref name=&quot;args&quot; /&gt; needs to match the number of the current expression.  You should not use this type.  It is only public due to assembly refactoring, and it is used internally for performance optimizations.  This helper method allows re-writing of nodes to be independent of the specific implementation class deriving from DynamicExpression that is being used at the call site.">Réécrit ce nœud en remplaçant les arguments de l’expression dynamique par les valeurs fournies.  Le nombre de <paramref name="args" /> doit correspondre au nombre de l’expression actuelle.  Vous ne devez pas utiliser ce type.  Il est public uniquement en raison de la refactorisation de l’assembly, et il est utilisé en interne pour optimiser les performances.  Cette méthode d’assistance permet la réécriture de nœuds pour qu’ils soient indépendants de la classe d’implémentation spécifique dérivant de l’expression dynamique qui est utilisée sur le site d’appel.</summary>
      <param name="args" vsli:raw="The arguments used to replace this node.">Arguments utilisés pour remplacer ce nœud.</param>
      <returns vsli:raw="The rewritten node, but if no changes were made, then returns the same node.">Nœud réécrit, mais retourne le même nœud si aucune modification n’a été apportée.</returns>
    </member>
    <member name="T:System.Linq.Expressions.IndexExpression">
      <summary vsli:raw="Represents indexing a property or array.">Représente l'indexation d'une propriété ou d'un tableau.</summary>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Arguments">
      <summary vsli:raw="Gets the arguments that will be used to index the property or array.">Obtient les arguments qui seront utilisés pour indexer la propriété ou le tableau.</summary>
      <returns vsli:raw="The read-only collection containing the arguments that will be used to index the property or array.">Collection en lecture seule contenant les arguments qui seront utilisés pour indexer la propriété ou le tableau.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Indexer">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Reflection.PropertyInfo&quot; /&gt; for the property if the expression represents an indexed property, returns null otherwise.">Obtient le <see cref="T:System.Reflection.PropertyInfo" /> pour la propriété si l'expression représente une propriété indexée, sinon retourne null.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Reflection.PropertyInfo&quot; /&gt; for the property if the expression represents an indexed property, otherwise null.">
        <see cref="T:System.Reflection.PropertyInfo" /> pour la propriété si l'expression représente une propriété indexée, sinon null.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.NodeType">
      <summary vsli:raw="Returns the node type of this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that represents this expression.">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Object">
      <summary vsli:raw="An object to index.">Objet à indexer.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; representing the object to index.">
        <see cref="T:System.Linq.Expressions.Expression" /> représentant l'objet à indexer.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount">
      <summary vsli:raw="Returns the number of arguments to the expression tree node.  You should not use this member.  It is only public due to assembly refactoring, and it is used internally for performance optimizations.">Retourne le nombre d’arguments du nœud d’arborescence d’expression.  Vous ne devez pas utiliser ce membre.  Il est public uniquement en raison de la refactorisation de l’assembly, et il est utilisé en interne pour optimiser les performances.</summary>
      <returns vsli:raw="Returns &lt;see cref=&quot;T:System.Int32&quot; /&gt;.">retourne <see cref="T:System.Int32" /> ;</returns>
    </member>
    <member name="M:System.Linq.Expressions.IndexExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)">
      <summary vsli:raw="Returns the argument at index, throwing if index is out of bounds.  You should not use this member.  It is only public due to assembly refactoring, and it is used internally for performance optimizations.">Retourne l’argument à l’index, en levant une exception si l’index est hors limites.  Vous ne devez pas utiliser ce membre.  Il est public uniquement en raison de la refactorisation de l’assembly, et il est utilisé en interne pour optimiser les performances.</summary>
      <param name="index" vsli:raw="The index of the argument.">Index de l’argument.</param>
      <returns vsli:raw="Returns &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">retourne <see cref="T:System.Linq.Expressions.Expression" /> ;</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.IndexExpression.Type&quot; /&gt; that represents the static type of the expression.">
        <see cref="P:System.Linq.Expressions.IndexExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.IndexExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="object" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.IndexExpression.Object&quot; /&gt; property of the result.">Propriété <see cref="P:System.Linq.Expressions.IndexExpression.Object" /> du résultat.</param>
      <param name="arguments" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.IndexExpression.Arguments&quot; /&gt; property of the result.">Propriété <see cref="P:System.Linq.Expressions.IndexExpression.Arguments" /> du résultat.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="T:System.Linq.Expressions.InvocationExpression">
      <summary vsli:raw="Represents an expression that applies a delegate or lambda expression to a list of argument expressions.">Représente une expression qui applique un délégué ou une expression lambda à une liste d'expressions d'arguments.</summary>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Arguments">
      <summary vsli:raw="Gets the arguments that the delegate or lambda expression is applied to.">Obtient les arguments auxquels le délégué ou l’expression lambda s’applique.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Collections.ObjectModel.ReadOnlyCollection`1&quot; /&gt; of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects which represent the arguments that the delegate is applied to.">
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d’objets <see cref="T:System.Linq.Expressions.Expression" /> qui représentent les arguments auxquels le délégué est appliqué.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Expression">
      <summary vsli:raw="Gets the delegate or lambda expression to be applied.">Obtient le délégué ou l'expression lambda à appliquer.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the delegate to be applied.">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le délégué à appliquer.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.NodeType">
      <summary vsli:raw="Returns the node type of this expression. Extension nodes should return &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Extension&quot; /&gt; when overriding this method.">Retourne le type de nœud de cette expression. Les nœuds d’extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; of the expression.">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount">
      <summary vsli:raw="Returns the number of arguments to the expression tree node.  You should not use this member.  It is only public due to assembly refactoring, and it is used internally for performance optimizations.">Retourne le nombre d’arguments du nœud d’arborescence d’expression.  Vous ne devez pas utiliser ce membre.  Il est public uniquement en raison de la refactorisation de l’assembly, et il est utilisé en interne pour optimiser les performances.</summary>
      <returns vsli:raw="The number of arguments to the expression tree node as &lt;see cref=&quot;T:System.Int32&quot; /&gt;.">Nombre d’arguments du nœud d’arborescence d’expression, au format <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.InvocationExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)">
      <summary vsli:raw="Returns the argument at index, throwing if index is out of bounds.  You should not use this member.  It is only public due to assembly refactoring, and it is used internally for performance optimizations.">Retourne l’argument à l’index, en levant une exception si l’index est hors limites.  Vous ne devez pas utiliser ce membre.  Il est public uniquement en raison de la refactorisation de l’assembly, et il est utilisé en interne pour optimiser les performances.</summary>
      <param name="index" vsli:raw="The index of the argument.">Index de l’argument.</param>
      <returns vsli:raw="The argument at index, throwing if index is out of bounds, as &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Argument à l’index, avec une exception levée si l’index est hors limites, comme <see cref="T:System.Linq.Expressions.Expression" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;P:System.Linq.Expressions.InvocationExpression.Expression&quot; /&gt; represents.">Obtient le type statique de l'expression que ce <see cref="P:System.Linq.Expressions.InvocationExpression.Expression" /> représente.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.InvocationExpression.Type&quot; /&gt; that represents the static type of the expression.">
        <see cref="P:System.Linq.Expressions.InvocationExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.InvocationExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="expression" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.InvocationExpression.Expression&quot; /&gt; property of the result.">Propriété <see cref="P:System.Linq.Expressions.InvocationExpression.Expression" /> du résultat.</param>
      <param name="arguments" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.InvocationExpression.Arguments&quot; /&gt; property of the result.">Propriété <see cref="P:System.Linq.Expressions.InvocationExpression.Arguments" /> du résultat.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="T:System.Linq.Expressions.LabelExpression">
      <summary vsli:raw="Represents a label, which can be put in any &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; context. If it is jumped to, it will get the value provided by the corresponding &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt;. Otherwise, it receives the value in &lt;see cref=&quot;P:System.Linq.Expressions.LabelExpression.DefaultValue&quot; /&gt;. If the &lt;see cref=&quot;T:System.Type&quot; /&gt; equals System.Void, no value should be provided.">Représente une étiquette, qui peut être placée dans tout contexte <see cref="T:System.Linq.Expressions.Expression" />. En cas de saut à cette étiquette, elle a la valeur fournie par le <see cref="T:System.Linq.Expressions.GotoExpression" /> correspondant. Sinon, elle reçoit la valeur indiquée dans <see cref="P:System.Linq.Expressions.LabelExpression.DefaultValue" />. Si <see cref="T:System.Type" /> est System.Void, aucune valeur ne doit être fournie.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.DefaultValue">
      <summary vsli:raw="The value of the &lt;see cref=&quot;T:System.Linq.Expressions.LabelExpression&quot; /&gt; when the label is reached through regular control flow (for example, is not jumped to).">La valeur de <see cref="T:System.Linq.Expressions.LabelExpression" /> lorsque l'étiquette est atteinte via le flux de contrôle normal (par exemple, sans saut).</summary>
      <returns vsli:raw="The Expression object representing the value of the &lt;see cref=&quot;T:System.Linq.Expressions.LabelExpression&quot; /&gt;.">Objet Expression représentant la valeur de <see cref="T:System.Linq.Expressions.LabelExpression" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.NodeType">
      <summary vsli:raw="Returns the node type of this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that represents this expression.">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.Target">
      <summary vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; which this label is associated with.">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel cette étiquette est associée.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; which this label is associated with.">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel cette étiquette est associée.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.LabelExpression.Type&quot; /&gt; that represents the static type of the expression.">
        <see cref="P:System.Linq.Expressions.LabelExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LabelExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.LabelExpression.Target&quot; /&gt; property of the result.">Propriété <see cref="P:System.Linq.Expressions.LabelExpression.Target" /> du résultat.</param>
      <param name="defaultValue" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.LabelExpression.DefaultValue&quot; /&gt; property of the result.">Propriété <see cref="P:System.Linq.Expressions.LabelExpression.DefaultValue" /> du résultat.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="T:System.Linq.Expressions.LabelTarget">
      <summary vsli:raw="Used to represent the target of a &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt;.">Utilisé pour représenter la cible d'un <see cref="T:System.Linq.Expressions.GotoExpression" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LabelTarget.Name">
      <summary vsli:raw="Gets the name of the label.">Obtient le nom de l'étiquette.</summary>
      <returns vsli:raw="The name of the label.">Nom de l'étiquette.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LabelTarget.ToString">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.String&quot; /&gt; that represents the current &lt;see cref=&quot;T:System.Object&quot; /&gt;.">Retourne une <see cref="T:System.String" /> qui représente l'<see cref="T:System.Object" /> actuel.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.String&quot; /&gt; that represents the current &lt;see cref=&quot;T:System.Object&quot; /&gt;.">
        <see cref="T:System.String" /> qui représente le <see cref="T:System.Object" /> actuel.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelTarget.Type">
      <summary vsli:raw="The type of value that is passed when jumping to the label (or &lt;see cref=&quot;T:System.Void&quot; /&gt; if no value should be passed).">Type de valeur passée lors de l'accès à l'étiquette (ou <see cref="T:System.Void" /> si aucune valeur ne doit être passée).</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the type of the value that is passed when jumping to the label or &lt;see cref=&quot;T:System.Void&quot; /&gt; if no value should be passed.">Objet <see cref="T:System.Type" /> qui représente le type de la valeur passée lors de l'accès à l'étiquette ou <see cref="T:System.Void" /> si aucune valeur ne doit être passée.</returns>
    </member>
    <member name="T:System.Linq.Expressions.LambdaExpression">
      <summary vsli:raw="Describes a lambda expression. This captures a block of code that is similar to a .NET method body.">Décrit une expression lambda. Capture un bloc de code semblable au corps d'une méthode .NET.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Body">
      <summary vsli:raw="Gets the body of the lambda expression.">Obtient le corps de l'expression lambda.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the body of the lambda expression.">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le corps de l'expression lambda.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LambdaExpression.Compile">
      <summary vsli:raw="Produces a delegate that represents the lambda expression.">Produit un délégué qui représente l'expression lambda.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Delegate&quot; /&gt; that contains the compiled version of the lambda expression.">
        <see cref="T:System.Delegate" /> qui contient la version compilée de l'expression lambda.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LambdaExpression.Compile(System.Boolean)">
      <summary vsli:raw="Produces an interpreted or compiled delegate that represents the lambda expression.">Produit un délégué interprété ou compilé qui représente l’expression lambda.</summary>
      <param name="preferInterpretation" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to indicate that the expression should be compiled to an interpreted form, if it's available; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> pour indiquer que l’expression doit être compilée en formulaire interprété, si disponible ; sinon, <see langword="false" />.</param>
      <returns vsli:raw="A delegate that represents the compiled lambda expression described by the &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; object.">Délégué qui représente l’expression lambda compilée décrite par l’objet <see cref="T:System.Linq.Expressions.LambdaExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LambdaExpression.Compile(System.Runtime.CompilerServices.DebugInfoGenerator)">
      <summary vsli:raw="Produces a delegate that represents the lambda expression.">Produit un délégué qui représente l'expression lambda.</summary>
      <param name="debugInfoGenerator" vsli:raw="Debugging information generator used by the compiler to mark sequence points and annotate local variables.">Générateur d'informations de débogage utilisé par le compilateur pour marquer les points de séquence et annoter les variables locales.</param>
      <returns vsli:raw="A delegate containing the compiled version of the lambda.">Délégué qui contient la version compilée du lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Name">
      <summary vsli:raw="Gets the name of the lambda expression.">Obtient le nom de l'expression lambda.</summary>
      <returns vsli:raw="The name of the lambda expression.">Nom de l'expression lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.NodeType">
      <summary vsli:raw="Returns the node type of this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that represents this expression.">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Parameters">
      <summary vsli:raw="Gets the parameters of the lambda expression.">Obtient les paramètres de l'expression lambda.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Collections.ObjectModel.ReadOnlyCollection`1&quot; /&gt; of &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects that represent the parameters of the lambda expression.">
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d'objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> qui représentent les paramètres de l'expression lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.ReturnType">
      <summary vsli:raw="Gets the return type of the lambda expression.">Obtient le type de retour de l'expression lambda.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the type of the lambda expression.">Objet <see cref="T:System.Type" /> représentant le type de l'expression lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.TailCall">
      <summary vsli:raw="Gets the value that indicates if the lambda expression will be compiled with the tail call optimization.">Obtient la valeur qui indique si l'expression lambda doit être compilée avec l'optimisation d'appel tail.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the lambda expression will be compiled with the tail call optimization; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />Si l’expression lambda doit être compilée avec l’optimisation d’appel tail; Sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Type&quot; /&gt; that represents the static type of the expression.">
        <see cref="P:System.Linq.Expressions.LambdaExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ListInitExpression">
      <summary vsli:raw="Represents a constructor call that has a collection initializer.">Représente un appel de constructeur ayant un initialiseur de collection.</summary>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.CanReduce">
      <summary vsli:raw="Gets a value that indicates whether the expression tree node can be reduced.">Obtient une valeur qui indique si le nœud d’arborescence de l’expression peut être réduit.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the node can be reduced; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />Si le nœud peut être réduit; Sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.Initializers">
      <summary vsli:raw="Gets the element initializers that are used to initialize a collection.">Obtient les initialiseurs de l'élément utilisés pour initialiser une collection.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Collections.ObjectModel.ReadOnlyCollection`1&quot; /&gt; of &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt; objects which represent the elements that are used to initialize the collection.">
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d'objets <see cref="T:System.Linq.Expressions.ElementInit" /> qui représentent les éléments utilisés pour initialiser la collection.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.NewExpression">
      <summary vsli:raw="Gets the expression that contains a call to the constructor of a collection type.">Obtient l'expression qui contient un appel au constructeur d'un type de collection.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; that represents the call to the constructor of a collection type.">
        <see cref="T:System.Linq.Expressions.NewExpression" /> qui représente l'appel au constructeur d'un type de collection.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.NodeType">
      <summary vsli:raw="Returns the node type of this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that represents this expression.">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ListInitExpression.Reduce">
      <summary vsli:raw="Reduces the binary expression node to a simpler expression.">Réduit le nœud d’expression binaire en une expression plus simple.</summary>
      <returns vsli:raw="The reduced expression.">Expression réduite.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.Type&quot; /&gt; that represents the static type of the expression.">
        <see cref="P:System.Linq.Expressions.ListInitExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ListInitExpression.Update(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="newExpression" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.NewExpression&quot; /&gt; property of the result.">Propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> du résultat.</param>
      <param name="initializers" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.Initializers&quot; /&gt; property of the result.">Propriété <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> du résultat.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="T:System.Linq.Expressions.LoopExpression">
      <summary vsli:raw="Represents an infinite loop. It can be exited with &quot;break&quot;.">Représente une boucle infinie. Elle peut être quittée avec « break ».</summary>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.Body">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that is the body of the loop.">Obtient le <see cref="T:System.Linq.Expressions.Expression" /> qui correspond au corps de la boucle.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that is the body of the loop.">
        <see cref="T:System.Linq.Expressions.Expression" /> qui correspond au corps de la boucle.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.BreakLabel">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that is used by the loop body as a break statement target.">Obtient le <see cref="T:System.Linq.Expressions.LabelTarget" /> utilisé par le corps de la boucle comme cible d'instruction break.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that is used by the loop body as a break statement target.">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> utilisé par le corps de la boucle comme cible d'instruction break.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.ContinueLabel">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that is used by the loop body as a continue statement target.">Obtient le <see cref="T:System.Linq.Expressions.LabelTarget" /> utilisé par le corps de la boucle comme cible d'instruction continue.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that is used by the loop body as a continue statement target.">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> utilisé par le corps de la boucle comme cible d'instruction continue.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.NodeType">
      <summary vsli:raw="Returns the node type of this expression. Extension nodes should return &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Extension&quot; /&gt; when overriding this method.">Retourne le type de nœud de cette expression. Les nœuds d’extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; of the expression.">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.LoopExpression.Type&quot; /&gt; that represents the static type of the expression.">
        <see cref="P:System.Linq.Expressions.LoopExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LoopExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="breakLabel" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.LoopExpression.BreakLabel&quot; /&gt; property of the result.">Propriété <see cref="P:System.Linq.Expressions.LoopExpression.BreakLabel" /> du résultat.</param>
      <param name="continueLabel" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.LoopExpression.ContinueLabel&quot; /&gt; property of the result.">Propriété <see cref="P:System.Linq.Expressions.LoopExpression.ContinueLabel" /> du résultat.</param>
      <param name="body" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.LoopExpression.Body&quot; /&gt; property of the result.">Propriété <see cref="P:System.Linq.Expressions.LoopExpression.Body" /> du résultat.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberAssignment">
      <summary vsli:raw="Represents assignment operation for a field or property of an object.">Représente l'opération d'assignation d'un champ ou d'une propriété à un objet.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberAssignment.Expression">
      <summary vsli:raw="Gets the expression to assign to the field or property.">Obtient l'expression à assigner au champ ou à la propriété.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the value to assign to the field or property.">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente la valeur à assigner au champ ou à la propriété.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberAssignment.Update(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="expression" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.MemberAssignment.Expression&quot; /&gt; property of the result.">Propriété <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> du résultat.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberBinding">
      <summary vsli:raw="Provides the base class from which the classes that represent bindings that are used to initialize members of a newly created object derive.">Fournit la classe de base à partir de laquelle sont dérivées les classes qui représentent les liaisons utilisées pour initialiser les membres d'un objet nouvellement créé.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MemberBinding.#ctor(System.Linq.Expressions.MemberBindingType,System.Reflection.MemberInfo)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Linq.Expressions.MemberBinding&quot; /&gt; class.">Initialise une nouvelle instance de la classe <see cref="T:System.Linq.Expressions.MemberBinding" />.</summary>
      <param name="type" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.MemberBindingType&quot; /&gt; that discriminates the type of binding that is represented.">
        <see cref="T:System.Linq.Expressions.MemberBindingType" /> qui discrimine le type de liaison représenté.</param>
      <param name="member" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; that represents a field or property to be initialized.">
        <see cref="T:System.Reflection.MemberInfo" /> qui représente un champ ou une propriété à initialiser.</param>
    </member>
    <member name="P:System.Linq.Expressions.MemberBinding.BindingType">
      <summary vsli:raw="Gets the type of binding that is represented.">Obtient le type de liaison représenté.</summary>
      <returns vsli:raw="One of the &lt;see cref=&quot;T:System.Linq.Expressions.MemberBindingType&quot; /&gt; values.">Une des valeurs de l'objet <see cref="T:System.Linq.Expressions.MemberBindingType" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberBinding.Member">
      <summary vsli:raw="Gets the field or property to be initialized.">Obtient le champ ou la propriété à initialiser.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; that represents the field or property to be initialized.">
        <see cref="T:System.Reflection.MemberInfo" /> qui représente le champ ou la propriété à initialiser.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberBinding.ToString">
      <summary vsli:raw="Returns a textual representation of the &lt;see cref=&quot;T:System.Linq.Expressions.MemberBinding&quot; /&gt;.">Retourne une représentation textuelle de <see cref="T:System.Linq.Expressions.MemberBinding" />.</summary>
      <returns vsli:raw="A textual representation of the &lt;see cref=&quot;T:System.Linq.Expressions.MemberBinding&quot; /&gt;.">Représentation textuelle de <see cref="T:System.Linq.Expressions.MemberBinding" />.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberBindingType">
      <summary vsli:raw="Describes the binding types that are used in &lt;see cref=&quot;T:System.Linq.Expressions.MemberInitExpression&quot; /&gt; objects.">Décrit les types de liaison utilisés dans les objets <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.Assignment">
      <summary vsli:raw="A binding that represents initializing a member with the value of an expression.">Liaison qui représente l'initialisation d'un membre avec la valeur d'une expression.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.ListBinding">
      <summary vsli:raw="A binding that represents initializing a member of type &lt;see cref=&quot;T:System.Collections.IList&quot; /&gt; or &lt;see cref=&quot;T:System.Collections.Generic.ICollection`1&quot; /&gt; from a list of elements.">Liaison qui représente l'initialisation d'un membre de type <see cref="T:System.Collections.IList" /> ou <see cref="T:System.Collections.Generic.ICollection`1" /> dans une liste d'éléments.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.MemberBinding">
      <summary vsli:raw="A binding that represents recursively initializing members of a member.">Liaison qui représente l'initialisation récurrente des membres d'un membre.</summary>
    </member>
    <member name="T:System.Linq.Expressions.MemberExpression">
      <summary vsli:raw="Represents accessing a field or property.">Représente l'accès à un champ ou à une propriété.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MemberExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary vsli:raw="Dispatches to the specific visit method for this node type. For example, &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; calls the &lt;see cref=&quot;M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)&quot; /&gt;.">Distribue à la méthode de visite spécifique à ce type de nœud. Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor" vsli:raw="The visitor to visit this node with.">Visiteur avec lequel visiter ce nœud.</param>
      <returns vsli:raw="The result of visiting this node.">Résultat de la visite de ce nœud.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.Expression">
      <summary vsli:raw="Gets the containing object of the field or property.">Obtient l'objet contenant du champ ou de la propriété.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the containing object of the field or property.">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'objet contenant du champ ou de la propriété.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.Member">
      <summary vsli:raw="Gets the field or property to be accessed.">Obtient le champ ou la propriété auquel accéder.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; that represents the field or property to be accessed.">
        <see cref="T:System.Reflection.MemberInfo" /> qui représente le champ ou la propriété auquel accéder.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.NodeType">
      <summary vsli:raw="Returns the node type of this &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Expression&quot; /&gt;.">Retourne le type de nœud de cet objet <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that represents this expression.">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberExpression.Update(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="expression" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Expression&quot; /&gt; property of the result.">Propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> du résultat.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberInitExpression">
      <summary vsli:raw="Represents calling a constructor and initializing one or more members of the new object.">Représente l'appel d'un constructeur et l'initialisation d'un ou de plusieurs membres du nouvel objet.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.Bindings">
      <summary vsli:raw="Gets the bindings that describe how to initialize the members of the newly created object.">Obtient les liaisons qui décrivent comment initialiser les membres de l'objet nouvellement créé.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Collections.ObjectModel.ReadOnlyCollection`1&quot; /&gt; of &lt;see cref=&quot;T:System.Linq.Expressions.MemberBinding&quot; /&gt; objects which describe how to initialize the members.">
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d'objets <see cref="T:System.Linq.Expressions.MemberBinding" /> qui décrivent comment initialiser les membres.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.CanReduce">
      <summary vsli:raw="Gets a value that indicates whether the expression tree node can be reduced.">Obtient une valeur qui indique si le nœud d’arborescence de l’expression peut être réduit.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the node can be reduced; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />Si le nœud peut être réduit; Sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.NewExpression">
      <summary vsli:raw="Gets the expression that represents the constructor call.">Obtient l'expression qui représente l'appel de constructeur.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; that represents the constructor call.">
        <see cref="T:System.Linq.Expressions.NewExpression" /> qui représente l'appel de constructeur.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.NodeType">
      <summary vsli:raw="Returns the node type of this Expression. Extension nodes should return &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Extension&quot; /&gt; when overriding this method.">Retourne le type de nœud de cette expression. Les nœuds d’extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; of the expression.">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberInitExpression.Reduce">
      <summary vsli:raw="Reduces the &lt;see cref=&quot;T:System.Linq.Expressions.MemberInitExpression&quot; /&gt; to a simpler expression.">Réduit <see cref="T:System.Linq.Expressions.MemberInitExpression" /> à une expression plus simple.</summary>
      <returns vsli:raw="The reduced expression.">Expression réduite.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.MemberInitExpression.Type&quot; /&gt; that represents the static type of the expression.">
        <see cref="P:System.Linq.Expressions.MemberInitExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberInitExpression.Update(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="newExpression" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.MemberInitExpression.NewExpression&quot; /&gt; property of the result.">Propriété <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> du résultat.</param>
      <param name="bindings" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.MemberInitExpression.Bindings&quot; /&gt; property of the result.">Propriété <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> du résultat.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberListBinding">
      <summary vsli:raw="Represents initializing the elements of a collection member of a newly created object.">Représente l'initialisation des éléments d'un membre de collection d'un objet nouvellement créé.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberListBinding.Initializers">
      <summary vsli:raw="Gets the element initializers for initializing a collection member of a newly created object.">Obtient les initialiseurs de l'élément pour initialiser un membre de collection d'un objet nouvellement créé.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Collections.ObjectModel.ReadOnlyCollection`1&quot; /&gt; of &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt; objects to initialize a collection member with.">
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d'objets <see cref="T:System.Linq.Expressions.ElementInit" /> avec lequel initialiser un membre de collection.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberListBinding.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="initializers" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.MemberListBinding.Initializers&quot; /&gt; property of the result.">Propriété <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> du résultat.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberMemberBinding">
      <summary vsli:raw="Represents initializing members of a member of a newly created object.">Représente l'initialisation des membres d'un membre d'un objet nouvellement créé.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberMemberBinding.Bindings">
      <summary vsli:raw="Gets the bindings that describe how to initialize the members of a member.">Obtient les liaisons qui décrivent comment initialiser les membres d'un membre.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Collections.ObjectModel.ReadOnlyCollection`1&quot; /&gt; of &lt;see cref=&quot;T:System.Linq.Expressions.MemberBinding&quot; /&gt; objects that describe how to initialize the members of the member.">
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d'objets <see cref="T:System.Linq.Expressions.MemberBinding" /> qui décrivent comment initialiser les membres du membre.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberMemberBinding.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="bindings" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.MemberMemberBinding.Bindings&quot; /&gt; property of the result.">Propriété <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> du résultat.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MethodCallExpression">
      <summary vsli:raw="Represents a call to either static or an instance method.">Représente un appel à une méthode statique ou une méthode d'instance.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary vsli:raw="Dispatches to the specific visit method for this node type. For example, &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; calls the &lt;see cref=&quot;M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)&quot; /&gt;.">Distribue à la méthode de visite spécifique à ce type de nœud. Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor" vsli:raw="The visitor to visit this node with.">Visiteur avec lequel visiter ce nœud.</param>
      <returns vsli:raw="The result of visiting this node.">Résultat de la visite de ce nœud.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Arguments">
      <summary vsli:raw="Gets a collection of expressions that represent arguments of the called method.">Obtient une collection d'expressions qui représentent les arguments de la méthode appelée.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Collections.ObjectModel.ReadOnlyCollection`1&quot; /&gt; of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects which represent the arguments to the called method.">
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d'objets <see cref="T:System.Linq.Expressions.Expression" /> qui représentent les arguments de la méthode appelée.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Method">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; for the method to be called.">Obtient l'objet <see cref="T:System.Reflection.MethodInfo" /> pour la méthode à appeler.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the called method.">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode appelée.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.NodeType">
      <summary vsli:raw="Returns the node type of this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that represents this expression.">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Object">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the instance for instance method calls or null for static method calls.">Obtient l'objet <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'instance pour les appels de méthode d'instance ou null pour les appels de méthode statique.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the receiving object of the method.">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'objet de réception de la méthode.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount">
      <summary vsli:raw="Returns the number of arguments to the expression tree node.  You should not use this member.  It is only public due to assembly refactoring, and it is used internally for performance optimizations.">Retourne le nombre d’arguments du nœud d’arborescence d’expression.  Vous ne devez pas utiliser ce membre.  Il est public uniquement en raison de la refactorisation de l’assembly, et il est utilisé en interne pour optimiser les performances.</summary>
      <returns vsli:raw="The number of arguments to the expression tree node as  &lt;see cref=&quot;T:System.Int32&quot; /&gt;.">Nombre d’arguments du nœud d’arborescence d’expression sous <see cref="T:System.Int32" />la forme.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)">
      <summary vsli:raw="Returns the argument at index, throwing if index is out of bounds.  You should not use this member.  It is only public due to assembly refactoring, and it is used internally for performance optimizations.">Retourne l’argument à l’index, en levant une exception si l’index est hors limites.  Vous ne devez pas utiliser ce membre.  Il est public uniquement en raison de la refactorisation de l’assembly, et il est utilisé en interne pour optimiser les performances.</summary>
      <param name="index" vsli:raw="The index of the argument.">Index de l’argument.</param>
      <returns vsli:raw="Returns &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">retourne <see cref="T:System.Linq.Expressions.Expression" /> ;</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Type&quot; /&gt; that represents the static type of the expression.">
        <see cref="P:System.Linq.Expressions.MethodCallExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="object" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt; property of the result.">Propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> du résultat.</param>
      <param name="arguments" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Arguments&quot; /&gt; property of the result.">Propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> du résultat.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="T:System.Linq.Expressions.NewArrayExpression">
      <summary vsli:raw="Represents creating a new array and possibly initializing the elements of the new array.">Représente la création d'un tableau et l'éventuelle initialisation des éléments du nouveau tableau.</summary>
    </member>
    <member name="M:System.Linq.Expressions.NewArrayExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary vsli:raw="Dispatches to the specific visit method for this node type. For example, &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; calls the &lt;see cref=&quot;M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)&quot; /&gt;.">Distribue à la méthode de visite spécifique à ce type de nœud. Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor" vsli:raw="The visitor to visit this node with.">Visiteur avec lequel visiter ce nœud.</param>
      <returns vsli:raw="The result of visiting this node.">Résultat de la visite de ce nœud.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewArrayExpression.Expressions">
      <summary vsli:raw="Gets the bounds of the array if the value of the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property is &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.NewArrayBounds&quot; /&gt;, or the values to initialize the elements of the new array if the value of the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property is &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.NewArrayInit&quot; /&gt;.">Obtient les limites du tableau si la valeur de la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" />, ou les valeurs pour initialiser les éléments du nouveau tableau si la valeur de la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" />.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Collections.ObjectModel.ReadOnlyCollection`1&quot; /&gt; of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects which represent either the bounds of the array or the initialization values.">
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d'objets <see cref="T:System.Linq.Expressions.Expression" /> qui représentent les limites du tableau ou les valeurs d'initialisation.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewArrayExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.NewArrayExpression.Type&quot; /&gt; that represents the static type of the expression.">
        <see cref="P:System.Linq.Expressions.NewArrayExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.NewArrayExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="expressions" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.NewArrayExpression.Expressions&quot; /&gt; property of the result.">Propriété <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> du résultat.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="T:System.Linq.Expressions.NewExpression">
      <summary vsli:raw="Represents a constructor call.">Représente un appel de constructeur.</summary>
    </member>
    <member name="M:System.Linq.Expressions.NewExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary vsli:raw="Dispatches to the specific visit method for this node type. For example, &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; calls the &lt;see cref=&quot;M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)&quot; /&gt;.">Distribue à la méthode de visite spécifique à ce type de nœud. Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor" vsli:raw="The visitor to visit this node with.">Visiteur avec lequel visiter ce nœud.</param>
      <returns vsli:raw="The result of visiting this node.">Résultat de la visite de ce nœud.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Arguments">
      <summary vsli:raw="Gets the arguments to the constructor.">Obtient les arguments pour le constructeur.</summary>
      <returns vsli:raw="A collection of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects that represent the arguments to the constructor.">Collection d’objets <see cref="T:System.Linq.Expressions.Expression" /> qui représentent les arguments pour le constructeur.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Constructor">
      <summary vsli:raw="Gets the called constructor.">Obtient le constructeur appelé.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Reflection.ConstructorInfo&quot; /&gt; that represents the called constructor.">
        <see cref="T:System.Reflection.ConstructorInfo" /> qui représente le constructeur appelé.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Members">
      <summary vsli:raw="Gets the members that can retrieve the values of the fields that were initialized with constructor arguments.">Obtient les membres qui peuvent récupérer les valeurs des champs initialisés avec les arguments de constructeur.</summary>
      <returns vsli:raw="A collection of &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; objects that represent the members that can retrieve the values of the fields that were initialized with constructor arguments.">Collection d'objets <see cref="T:System.Reflection.MemberInfo" /> qui représentent les membres qui peuvent récupérer les valeurs des champs initialisés avec les arguments de constructeur.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.NodeType">
      <summary vsli:raw="Returns the node type of this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that represents this expression.">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount">
      <summary vsli:raw="Gets the number of arguments to the expression tree node.">Obtient le nombre d’arguments du nœud d’arborescence d’expression.</summary>
      <returns vsli:raw="The number of arguments to the expression tree node.">Nombre d’arguments du nœud d’arborescence d’expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.NewExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)">
      <summary vsli:raw="Returns the argument at index, throwing if index is out of bounds.">Retourne l’argument à l’index, en levant une exception si l’index est hors limites.</summary>
      <param name="index" vsli:raw="The index of the argument.">Index de l’argument.</param>
      <returns vsli:raw="The argument at index, throwing if index is out of bounds.">L’argument à l’index, avec une exception levée si l’index est hors limites.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Type&quot; /&gt; that represents the static type of the expression.">
        <see cref="P:System.Linq.Expressions.NewExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.NewExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="arguments" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Arguments&quot; /&gt; property of the result.">Propriété <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> du résultat.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ParameterExpression">
      <summary vsli:raw="Represents a named parameter expression.">Représente une expression de paramètre nommée.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ParameterExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary vsli:raw="Dispatches to the specific visit method for this node type. For example, &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; calls the &lt;see cref=&quot;M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)&quot; /&gt;.">Distribue à la méthode de visite spécifique à ce type de nœud. Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor" vsli:raw="The visitor to visit this node with.">Visiteur avec lequel visiter ce nœud.</param>
      <returns vsli:raw="The result of visiting this node.">Résultat de la visite de ce nœud.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.IsByRef">
      <summary vsli:raw="Indicates that this &lt;c&gt;ParameterExpression&lt;/c&gt; is to be treated as a &lt;see langword=&quot;ByRef&quot; /&gt; parameter.">Indique que <c>ParameterExpression</c> doit être traité comme un paramètre <see langword="ByRef" />.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if this &lt;c&gt;ParameterExpression&lt;/c&gt; is a &lt;see langword=&quot;ByRef&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />Si ce <c>ParameterExpression</c> est un <see langword="ByRef" /> paramètre; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.Name">
      <summary vsli:raw="Gets the name of the parameter or variable.">Obtient le nom du paramètre ou de la variable.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.String&quot; /&gt; that contains the name of the parameter.">
        <see cref="T:System.String" /> qui contient le nom du paramètre.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.NodeType">
      <summary vsli:raw="Returns the node type of this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that represents this expression.">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.ParameterExpression.Type&quot; /&gt; that represents the static type of the expression.">
        <see cref="P:System.Linq.Expressions.ParameterExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="T:System.Linq.Expressions.RuntimeVariablesExpression">
      <summary vsli:raw="An expression that provides runtime read/write permission for variables.">Expression qui fournit l'autorisation de lecture/écriture d'exécution pour les variables.</summary>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.NodeType">
      <summary vsli:raw="Returns the node type of this Expression. Extension nodes should return &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Extension&quot; /&gt; when overriding this method.">Retourne le type de nœud de cette expression. Les nœuds d’extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; of the expression.">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.RuntimeVariablesExpression.Type&quot; /&gt; that represents the static type of the expression.">
        <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.RuntimeVariablesExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="variables" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.RuntimeVariablesExpression.Variables&quot; /&gt; property of the result.">Propriété <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> du résultat.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables">
      <summary vsli:raw="The variables or parameters to which to provide runtime access.">Variables ou paramètres auxquels fournir l'accès d'exécution.</summary>
      <returns vsli:raw="The read-only collection containing parameters that will be provided the runtime access.">Collection en lecture seule qui contient des paramètres qui se verront octroyer l'accès d'exécution.</returns>
    </member>
    <member name="T:System.Linq.Expressions.SwitchCase">
      <summary vsli:raw="Represents one case of a &lt;see cref=&quot;T:System.Linq.Expressions.SwitchExpression&quot; /&gt;.">Représente le cas d'un <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SwitchCase.Body">
      <summary vsli:raw="Gets the body of this case.">Obtient le corps de ce cas.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; object that represents the body of the case block.">Objet <see cref="T:System.Linq.Expressions.Expression" /> qui représente le corps du bloc case.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchCase.TestValues">
      <summary vsli:raw="Gets the values of this case. This case is selected for execution when the &lt;see cref=&quot;P:System.Linq.Expressions.SwitchExpression.SwitchValue&quot; /&gt; matches any of these values.">Obtient les valeurs de ce cas. Ce cas est sélectionné pour être exécuté lorsque le <see cref="P:System.Linq.Expressions.SwitchExpression.SwitchValue" /> correspond à chacune de ces valeurs.</summary>
      <returns vsli:raw="The read-only collection of the values for this case block.">Collection en lecture seule des valeurs de ce bloc case.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchCase.ToString">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.String&quot; /&gt; that represents the current &lt;see cref=&quot;T:System.Object&quot; /&gt;.">Retourne une <see cref="T:System.String" /> qui représente l'<see cref="T:System.Object" /> actuel.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.String&quot; /&gt; that represents the current &lt;see cref=&quot;T:System.Object&quot; /&gt;.">
        <see cref="T:System.String" /> qui représente le <see cref="T:System.Object" /> actuel.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchCase.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="testValues" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.SwitchCase.TestValues&quot; /&gt; property of the result.">Propriété <see cref="P:System.Linq.Expressions.SwitchCase.TestValues" /> du résultat.</param>
      <param name="body" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.SwitchCase.Body&quot; /&gt; property of the result.">Propriété <see cref="P:System.Linq.Expressions.SwitchCase.Body" /> du résultat.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="T:System.Linq.Expressions.SwitchExpression">
      <summary vsli:raw="Represents a control expression that handles multiple selections by passing control to &lt;see cref=&quot;T:System.Linq.Expressions.SwitchCase&quot; /&gt;.">Représente une expression de contrôle qui gère des sélections multiples en transmettant le contrôle à <see cref="T:System.Linq.Expressions.SwitchCase" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Cases">
      <summary vsli:raw="Gets the collection of &lt;see cref=&quot;T:System.Linq.Expressions.SwitchCase&quot; /&gt; objects for the switch.">Obtient la collection d'objets <see cref="T:System.Linq.Expressions.SwitchCase" /> pour le commutateur.</summary>
      <returns vsli:raw="The collection of &lt;see cref=&quot;T:System.Linq.Expressions.SwitchCase&quot; /&gt; objects.">Collection d'objets <see cref="T:System.Linq.Expressions.SwitchCase" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Comparison">
      <summary vsli:raw="Gets the equality comparison method, if any.">Obtient la méthode de comparaison d'égalité, le cas échéant.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; object representing the equality comparison method.">Objet <see cref="T:System.Reflection.MethodInfo" /> représentant la méthode de comparaison d'égalité.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.DefaultBody">
      <summary vsli:raw="Gets the test for the switch.">Obtient le test pour le commutateur.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; object representing the test for the switch.">Objet <see cref="T:System.Linq.Expressions.Expression" /> qui représente le test pour le commutateur.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.NodeType">
      <summary vsli:raw="Returns the node type of this Expression. Extension nodes should return &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Extension&quot; /&gt; when overriding this method.">Retourne le type de nœud de cette expression. Les nœuds d’extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; of the expression.">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.SwitchValue">
      <summary vsli:raw="Gets the test for the switch.">Obtient le test pour le commutateur.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; object representing the test for the switch.">Objet <see cref="T:System.Linq.Expressions.Expression" /> qui représente le test pour le commutateur.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.SwitchExpression.Type&quot; /&gt; that represents the static type of the expression.">
        <see cref="P:System.Linq.Expressions.SwitchExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase},System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="switchValue" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.SwitchExpression.SwitchValue&quot; /&gt; property of the result.">Propriété <see cref="P:System.Linq.Expressions.SwitchExpression.SwitchValue" /> du résultat.</param>
      <param name="cases" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.SwitchExpression.Cases&quot; /&gt; property of the result.">Propriété <see cref="P:System.Linq.Expressions.SwitchExpression.Cases" /> du résultat.</param>
      <param name="defaultBody" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.SwitchExpression.DefaultBody&quot; /&gt; property of the result.">Propriété <see cref="P:System.Linq.Expressions.SwitchExpression.DefaultBody" /> du résultat.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="T:System.Linq.Expressions.SymbolDocumentInfo">
      <summary vsli:raw="Stores information necessary to emit debugging symbol information for a source file, in particular the file name and unique language identifier.">Stocke les informations nécessaires pour émettre les informations de symboles de débogage pour un fichier source, en particulier le nom de fichier et l'identificateur de langue unique.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType">
      <summary vsli:raw="Returns the document type's unique identifier, if any.">Retourne l'identificateur unique du type de document, le cas échéant. La valeur par défaut est le GUID pour un fichier texte.</summary>
      <returns vsli:raw="The document type's unique identifier. The default is the GUID for a text file.">Identificateur unique du type de document.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.FileName">
      <summary vsli:raw="The source file name.">Nom du fichier source.</summary>
      <returns vsli:raw="The string representing the source file name.">Chaîne représentant le nom du fichier source.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.Language">
      <summary vsli:raw="Returns the language's unique identifier, if any.">Retourne l'identificateur unique de langue, le cas échéant.</summary>
      <returns vsli:raw="The language's unique identifier.">Identificateur unique de langue.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor">
      <summary vsli:raw="Returns the language vendor's unique identifier, if any.">Retourne l'identificateur unique du fournisseur de langue, le cas échéant.</summary>
      <returns vsli:raw="The language vendor's unique identifier.">Identificateur unique du fournisseur de langue.</returns>
    </member>
    <member name="T:System.Linq.Expressions.TryExpression">
      <summary vsli:raw="Represents a try/catch/finally/fault block.">Représente un bloc try/catch/finally/fault.</summary>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Body">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; representing the body of the try block.">Obtient le <see cref="T:System.Linq.Expressions.Expression" /> représentant le corps du bloc try.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; representing the body of the try block.">
        <see cref="T:System.Linq.Expressions.Expression" /> représentant le corps du bloc try.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Fault">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; representing the fault block.">Obtient le <see cref="T:System.Linq.Expressions.Expression" /> qui représente le bloc fault.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; representing the fault block.">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le bloc fault.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Finally">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; representing the finally block.">Obtient le <see cref="T:System.Linq.Expressions.Expression" /> qui représente le bloc finally.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; representing the finally block.">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le bloc finally.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Handlers">
      <summary vsli:raw="Gets the collection of &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt; expressions associated with the try block.">Obtient la collection d'expressions <see cref="T:System.Linq.Expressions.CatchBlock" /> associée au bloc try.</summary>
      <returns vsli:raw="The collection of &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt; expressions associated with the try block.">Collection d'expressions <see cref="T:System.Linq.Expressions.CatchBlock" /> associée au bloc try.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.NodeType">
      <summary vsli:raw="Returns the node type of this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that represents this expression.">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.TryExpression.Type&quot; /&gt; that represents the static type of the expression.">
        <see cref="P:System.Linq.Expressions.TryExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.TryExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock},System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="body" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.TryExpression.Body&quot; /&gt; property of the result.">Propriété <see cref="P:System.Linq.Expressions.TryExpression.Body" /> du résultat.</param>
      <param name="handlers" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.TryExpression.Handlers&quot; /&gt; property of the result.">Propriété <see cref="P:System.Linq.Expressions.TryExpression.Handlers" /> du résultat.</param>
      <param name="finally" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.TryExpression.Finally&quot; /&gt; property of the result.">Propriété <see cref="P:System.Linq.Expressions.TryExpression.Finally" /> du résultat.</param>
      <param name="fault" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.TryExpression.Fault&quot; /&gt; property of the result.">Propriété <see cref="P:System.Linq.Expressions.TryExpression.Fault" /> du résultat.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="T:System.Linq.Expressions.TypeBinaryExpression">
      <summary vsli:raw="Represents an operation between an expression and a type.">Représente une opération entre une expression et un type.</summary>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.Expression">
      <summary vsli:raw="Gets the expression operand of a type test operation.">Obtient l'opérande d'expression d'une opération de test de type.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the expression operand of a type test operation.">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande d'expression d'une opération de test de type.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.NodeType">
      <summary vsli:raw="Returns the node type of this Expression. Extension nodes should return &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Extension&quot; /&gt; when overriding this method.">Retourne le type de nœud de cette expression. Les nœuds d’extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; of the expression.">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;P:System.Linq.Expressions.TypeBinaryExpression.Expression&quot; /&gt; represents.">Obtient le type statique de l'expression que ce <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> représente.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.TypeBinaryExpression.Type&quot; /&gt; that represents the static type of the expression.">
        <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand">
      <summary vsli:raw="Gets the type operand of a type test operation.">Obtient l'opérande de type d'une opération de test de type.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; that represents the type operand of a type test operation.">
        <see cref="T:System.Type" /> qui représente l'opérande de type d'une opération de test de type.</returns>
    </member>
    <member name="M:System.Linq.Expressions.TypeBinaryExpression.Update(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="expression" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.TypeBinaryExpression.Expression&quot; /&gt; property of the result.">Propriété <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> du résultat.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="T:System.Linq.Expressions.UnaryExpression">
      <summary vsli:raw="Represents an expression that has a unary operator.">Représente une expression qui comporte un opérateur unaire.</summary>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.CanReduce">
      <summary vsli:raw="Gets a value that indicates whether the expression tree node can be reduced.">Obtient une valeur qui indique si le nœud d’arborescence de l’expression peut être réduit.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if a node can be reduced; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />Si un nœud peut être réduit; Sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.IsLifted">
      <summary vsli:raw="Gets a value that indicates whether the expression tree node represents a lifted call to an operator.">Obtient une valeur qui indique si le nœud d'arborescence d'expression représente un appel levé vers un opérateur.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the node represents a lifted call; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si le nœud représente un appel levé ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.IsLiftedToNull">
      <summary vsli:raw="Gets a value that indicates whether the expression tree node represents a lifted call to an operator whose return type is lifted to a nullable type.">Obtient une valeur qui indique si le nœud d'arborescence d'expression représente un appel levé vers un opérateur dont le type de retour est levé vers un type nullable.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operator's return type is lifted to a nullable type; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si le type de retour de l'opérateur est levé vers un type nullable ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Method">
      <summary vsli:raw="Gets the implementing method for the unary operation.">Obtient la méthode d'implémentation pour l'opération unaire.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the implementing method.">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.NodeType">
      <summary vsli:raw="Returns the node type of this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that represents this expression.">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Operand">
      <summary vsli:raw="Gets the operand of the unary operation.">Obtient l'opérande de l'opération unaire.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the operand of the unary operation.">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande de l'opération unaire.</returns>
    </member>
    <member name="M:System.Linq.Expressions.UnaryExpression.Reduce">
      <summary vsli:raw="Reduces the expression node to a simpler expression.">Réduit le nœud d'expression en une expression plus simple.</summary>
      <returns vsli:raw="The reduced expression.">Expression réduite.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Type&quot; /&gt; that represents the static type of the expression.">
        <see cref="P:System.Linq.Expressions.UnaryExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.UnaryExpression.Update(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="operand" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property of the result.">Propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> du résultat.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="T:System.Linq.IOrderedQueryable">
      <summary vsli:raw="Represents the result of a sorting operation.">Représente le résultat d'une opération de tri.</summary>
    </member>
    <member name="T:System.Linq.IOrderedQueryable`1">
      <summary vsli:raw="Represents the result of a sorting operation.">Représente le résultat d'une opération de tri.</summary>
      <typeparam name="T" vsli:raw="The type of the content of the data source.">Le type de contenu de la source de données.</typeparam>
    </member>
    <member name="T:System.Linq.IQueryable">
      <summary vsli:raw="Provides functionality to evaluate queries against a specific data source wherein the type of the data is not specified.">Fournit les fonctionnalités permettant d'évaluer les requêtes appliquées à une source de données spécifique dont le type de données n'est pas défini.</summary>
    </member>
    <member name="P:System.Linq.IQueryable.ElementType">
      <summary vsli:raw="Gets the type of the element(s) that are returned when the expression tree associated with this instance of &lt;see cref=&quot;T:System.Linq.IQueryable&quot; /&gt; is executed.">Obtient le type des éléments retournés lors de l'exécution de l'arborescence d'expression associée à cette instance de <see cref="T:System.Linq.IQueryable" />.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; that represents the type of the element(s) that are returned when the expression tree associated with this object is executed.">
        <see cref="T:System.Type" /> qui représente le type des éléments retournés lorsque l'arborescence d'expression associé à cet objet est exécutée.</returns>
    </member>
    <member name="P:System.Linq.IQueryable.Expression">
      <summary vsli:raw="Gets the expression tree that is associated with the instance of &lt;see cref=&quot;T:System.Linq.IQueryable&quot; /&gt;.">Obtient l'arborescence d'expression associée à l'instance de <see cref="T:System.Linq.IQueryable" />.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that is associated with this instance of &lt;see cref=&quot;T:System.Linq.IQueryable&quot; /&gt;.">Classe <see cref="T:System.Linq.Expressions.Expression" /> associée à cette instance de l'interface <see cref="T:System.Linq.IQueryable" />.</returns>
    </member>
    <member name="P:System.Linq.IQueryable.Provider">
      <summary vsli:raw="Gets the query provider that is associated with this data source.">Obtient le fournisseur de requêtes associé à cette source de données.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.IQueryProvider&quot; /&gt; that is associated with this data source.">
        <see cref="T:System.Linq.IQueryProvider" /> associé à cette source de données.</returns>
    </member>
    <member name="T:System.Linq.IQueryable`1">
      <summary vsli:raw="Provides functionality to evaluate queries against a specific data source wherein the type of the data is known.">Fournit les fonctionnalités permettant d'évaluer les requêtes appliquées à une source de données spécifique dont le type de données est connu.</summary>
      <typeparam name="T" vsli:raw="The type of the data in the data source.">Type des données contenues dans la source de données.</typeparam>
    </member>
    <member name="T:System.Linq.IQueryProvider">
      <summary vsli:raw="Defines methods to create and execute queries that are described by an &lt;see cref=&quot;T:System.Linq.IQueryable&quot; /&gt; object.">Définit des méthodes destinées à créer et exécuter des requêtes décrites par un objet <see cref="T:System.Linq.IQueryable" />.</summary>
    </member>
    <member name="M:System.Linq.IQueryProvider.CreateQuery(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Constructs an &lt;see cref=&quot;T:System.Linq.IQueryable&quot; /&gt; object that can evaluate the query represented by a specified expression tree.">Construit un objet <see cref="T:System.Linq.IQueryable" /> capable d'évaluer la requête représentée par une arborescence d'expression spécifiée.</summary>
      <param name="expression" vsli:raw="An expression tree that represents a LINQ query.">Arborescence d'expression qui représente une requête LINQ.</param>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.IQueryable&quot; /&gt; that can evaluate the query represented by the specified expression tree.">Objet <see cref="T:System.Linq.IQueryable" /> capable d'évaluer la requête représentée par l'arborescence d'expression spécifiée.</returns>
    </member>
    <member name="M:System.Linq.IQueryProvider.CreateQuery``1(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Constructs an &lt;see cref=&quot;T:System.Linq.IQueryable`1&quot; /&gt; object that can evaluate the query represented by a specified expression tree.">Construit un objet <see cref="T:System.Linq.IQueryable`1" /> capable d'évaluer la requête représentée par une arborescence d'expression spécifiée.</summary>
      <param name="expression" vsli:raw="An expression tree that represents a LINQ query.">Arborescence d'expression qui représente une requête LINQ.</param>
      <typeparam name="TElement" vsli:raw="The type of the elements of the &lt;see cref=&quot;T:System.Linq.IQueryable`1&quot; /&gt; that is returned.">Type des éléments du <see cref="T:System.Linq.IQueryable`1" /> retourné.</typeparam>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.IQueryable`1&quot; /&gt; that can evaluate the query represented by the specified expression tree.">Objet <see cref="T:System.Linq.IQueryable`1" /> capable d'évaluer la requête représentée par l'arborescence d'expression spécifiée.</returns>
    </member>
    <member name="M:System.Linq.IQueryProvider.Execute(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Executes the query represented by a specified expression tree.">Exécute la requête représentée par une arborescence d'expression spécifiée.</summary>
      <param name="expression" vsli:raw="An expression tree that represents a LINQ query.">Arborescence d'expression qui représente une requête LINQ.</param>
      <returns vsli:raw="The value that results from executing the specified query.">Valeur qui résulte de l'exécution de la requête spécifiée.</returns>
    </member>
    <member name="M:System.Linq.IQueryProvider.Execute``1(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Executes the strongly-typed query represented by a specified expression tree.">Exécute la requête fortement typée représentée par une arborescence d'expression spécifiée.</summary>
      <param name="expression" vsli:raw="An expression tree that represents a LINQ query.">Arborescence d'expression qui représente une requête LINQ.</param>
      <typeparam name="TResult" vsli:raw="The type of the value that results from executing the query.">Type de la valeur qui résulte de l'exécution de la requête.</typeparam>
      <returns vsli:raw="The value that results from executing the specified query.">Valeur qui résulte de l'exécution de la requête spécifiée.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.CallSite">
      <summary vsli:raw="A dynamic call site base class. This type is used as a parameter type to the dynamic site targets.">Classe de base d'un site d'appel dynamique. Ce type est utilisé comme type de paramètre pour les cibles d'un site dynamique.</summary>
    </member>
    <member name="P:System.Runtime.CompilerServices.CallSite.Binder">
      <summary vsli:raw="Class responsible for binding dynamic operations on the dynamic site.">Classe responsable de la liaison des opérations dynamiques sur le site dynamique.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt; object responsible for binding dynamic operations.">Objet <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> responsable de la liaison des opérations dynamiques.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSite.Create(System.Type,System.Runtime.CompilerServices.CallSiteBinder)">
      <summary vsli:raw="Creates a call site with the given delegate type and binder.">Crée un site d'appel à l'aide du type délégué et du binder donnés.</summary>
      <param name="delegateType" vsli:raw="The call site delegate type.">Type délégué du site d'appel.</param>
      <param name="binder" vsli:raw="The call site binder.">Binder du site d'appel.</param>
      <returns vsli:raw="The new call site.">Nouveau site d'appel.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.CallSite`1">
      <summary vsli:raw="Dynamic site type.">Type de site dynamique.</summary>
      <typeparam name="T" vsli:raw="The delegate type.">Type de délégué.</typeparam>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSite`1.Create(System.Runtime.CompilerServices.CallSiteBinder)">
      <summary vsli:raw="Creates an instance of the dynamic call site, initialized with the binder responsible for the runtime binding of the dynamic operations at this call site.">Crée une instance du site d'appel dynamique, initialisée à l'aide du binder responsable de la liaison au moment de l'exécution des opérations dynamiques sur ce site d'appel.</summary>
      <param name="binder" vsli:raw="The binder responsible for the runtime binding of the dynamic operations at this call site.">Binder responsable de la liaison au moment de l'exécution des opérations dynamiques sur ce site d'appel.</param>
      <returns vsli:raw="The new instance of dynamic call site.">Nouvelle instance du site d'appel dynamique.</returns>
    </member>
    <member name="F:System.Runtime.CompilerServices.CallSite`1.Target">
      <summary vsli:raw="The Level 0 cache - a delegate specialized based on the site history.">Cache de niveau 0 - Délégué spécialisé basé sur l'historique du site.</summary>
    </member>
    <member name="P:System.Runtime.CompilerServices.CallSite`1.Update">
      <summary vsli:raw="The update delegate. Called when the dynamic site experiences cache miss.">Délégué de mise à jour. Appelée lorsque le site dynamique rencontre des échecs dans le cache.</summary>
      <returns vsli:raw="The update delegate.">Délégué de mise à jour.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.CallSiteBinder">
      <summary vsli:raw="Class responsible for runtime binding of the dynamic operations on the dynamic call site.">Classe responsable de la liaison au moment de l'exécution des opérations dynamiques sur le site d'appel dynamique.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSiteBinder.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt; class.">Initialise une nouvelle instance de la classe <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSiteBinder.Bind(System.Object[],System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.LabelTarget)">
      <summary vsli:raw="Performs the runtime binding of the dynamic operation on a set of arguments.">Exécute la liaison au moment de l'exécution de l'opération dynamique sur un jeu d'arguments.</summary>
      <param name="args" vsli:raw="An array of arguments to the dynamic operation.">Tableau d'arguments de l'opération dynamique.</param>
      <param name="parameters" vsli:raw="The array of &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; instances that represent the parameters of the call site in the binding process.">Tableau des instances <see cref="T:System.Linq.Expressions.ParameterExpression" /> qui représentent les paramètres du site d'appel dans le processus de liaison.</param>
      <param name="returnLabel" vsli:raw="A LabelTarget used to return the result of the dynamic binding.">LabelTarget utilisé pour retourner le résultat de la liaison dynamique.</param>
      <returns vsli:raw="An Expression that performs tests on the dynamic operation arguments, and performs the dynamic operation if the tests are valid. If the tests fail on subsequent occurrences of the dynamic operation, Bind will be called again to produce a new &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; for the new argument types.">Expression qui exécute des tests sur les arguments d'opération dynamique, et exécute l'opération dynamique si les tests sont valides. Si les tests échouent sur les occurrences suivantes de l'opération dynamique, Bind est à nouveau appelé pour produire un nouveau <see cref="T:System.Linq.Expressions.Expression" /> pour les nouveaux types d'arguments.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSiteBinder.BindDelegate``1(System.Runtime.CompilerServices.CallSite{``0},System.Object[])">
      <summary vsli:raw="Provides low-level runtime binding support. Classes can override this and provide a direct delegate for the implementation of rule. This can enable saving rules to disk, having specialized rules available at runtime, or providing a different caching policy.">Fournit une prise en charge de bas niveau de la liaison au moment de l'exécution. Les classes peuvent substituer ceci et fournir un délégué direct pour l'implémentation de la règle. Cela permet d'enregistrer des règles sur disque, de disposer de règles spécialisées au moment de l'exécution ou de fournir une stratégie de mise en cache différente.</summary>
      <param name="site" vsli:raw="The CallSite the bind is being performed for.">CallSite pour lequel la liaison est exécutée.</param>
      <param name="args" vsli:raw="The arguments for the binder.">Arguments du binder.</param>
      <typeparam name="T" vsli:raw="The target type of the CallSite.">Type cible de CallSite.</typeparam>
      <returns vsli:raw="A new delegate which replaces the CallSite Target.">Nouveau délégué qui remplace la cible de CallSite.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSiteBinder.CacheTarget``1(``0)">
      <summary vsli:raw="Adds a target to the cache of known targets. The cached targets will be scanned before calling BindDelegate to produce the new rule.">Ajoute une cible au cache des cibles connues. Les cibles mises en cache sont analysées avant d'appeler BindDelegate pour produire la nouvelle règle.</summary>
      <param name="target" vsli:raw="The target delegate to be added to the cache.">Délégué cible à ajouter au cache.</param>
      <typeparam name="T" vsli:raw="The type of target being added.">Type de cible ajouté.</typeparam>
    </member>
    <member name="P:System.Runtime.CompilerServices.CallSiteBinder.UpdateLabel">
      <summary vsli:raw="Gets a label that can be used to cause the binding to be updated. It indicates that the expression's binding is no longer valid. This is typically used when the &quot;version&quot; of a dynamic object has changed.">Obtient une étiquette qui peut être utilisée pour provoquer la mise à jour de la liaison. Indique que la liaison de l'expression n'est plus valide. Cela est utilisé en général lorsque la « version » d'un objet dynamique a changé.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; object representing a label that can be used to trigger the binding update.">Objet <see cref="T:System.Linq.Expressions.LabelTarget" /> représentant une étiquette qui peut être utilisée pour déclencher la mise à jour de la liaison.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.CallSiteHelpers">
      <summary vsli:raw="Class that contains helper methods for DLR CallSites.">Classe qui contient des méthodes d'assistance pour les CallSites DLR.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSiteHelpers.IsInternalFrame(System.Reflection.MethodBase)">
      <summary vsli:raw="Checks if a &lt;see cref=&quot;T:System.Reflection.MethodBase&quot; /&gt; is internally used by DLR and should not be displayed on the language code's stack.">Vérifie si <see cref="T:System.Reflection.MethodBase" /> est utilisé en interne par DLR et s'il ne doit pas être affiché dans la pile du code de langue.</summary>
      <param name="mb" vsli:raw="The input &lt;see cref=&quot;T:System.Reflection.MethodBase&quot; /&gt;.">
        <see cref="T:System.Reflection.MethodBase" /> d'entrée.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the input &lt;see cref=&quot;T:System.Reflection.MethodBase&quot; /&gt; is internally used by DLR and should not be displayed on the language code's stack. Otherwise, &lt;see langword=&quot;false&quot; /&gt;.">True si le <see cref="T:System.Reflection.MethodBase" /> d'entrée est utilisé en interne par DLR et s'il ne doit pas être affiché dans la pile du code de langue. Sinon, false.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.DebugInfoGenerator">
      <summary vsli:raw="Generates debug information for lambda expressions in an expression tree.">Génère des informations de débogage pour les expressions lambda dans une arborescence d’expression.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.DebugInfoGenerator.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Runtime.CompilerServices.DebugInfoGenerator&quot; /&gt; class.">Initialise une nouvelle instance de la classe <see cref="T:System.Runtime.CompilerServices.DebugInfoGenerator" />.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.DebugInfoGenerator.CreatePdbGenerator">
      <summary vsli:raw="Creates a program database (PDB) symbol generator.">Crée un générateur de symboles de base de données de programme (PDB).</summary>
      <returns vsli:raw="A PDB symbol generator.">Générateur de symboles PDB.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.DebugInfoGenerator.MarkSequencePoint(System.Linq.Expressions.LambdaExpression,System.Int32,System.Linq.Expressions.DebugInfoExpression)">
      <summary vsli:raw="Marks a sequence point in Microsoft intermediate language (MSIL) code.">Marque un point de séquence dans du code MSIL (Microsoft Intermediate Language).</summary>
      <param name="method" vsli:raw="The lambda expression that is generated.">Expression lambda générée.</param>
      <param name="ilOffset" vsli:raw="The offset within MSIL code at which to mark the sequence point.">Décalage dans le code MSIL où marquer le point de séquence.</param>
      <param name="sequencePoint" vsli:raw="Debug information that corresponds to the sequence point.">Informations de débogage qui correspondent au point de séquence.</param>
    </member>
    <member name="T:System.Runtime.CompilerServices.DynamicAttribute">
      <summary vsli:raw="Indicates that the use of &lt;see cref=&quot;T:System.Object&quot; /&gt; on a member is meant to be treated as a dynamically dispatched type.">Indique que l'utilisation de <see cref="T:System.Object" /> sur un membre doit être traitée en tant que type distribué dynamiquement.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.DynamicAttribute.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Runtime.CompilerServices.DynamicAttribute&quot; /&gt; class.">Initialise une nouvelle instance de la classe <see cref="T:System.Runtime.CompilerServices.DynamicAttribute" />.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.DynamicAttribute.#ctor(System.Boolean[])">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Runtime.CompilerServices.DynamicAttribute&quot; /&gt; class.">Initialise une nouvelle instance de la classe <see cref="T:System.Runtime.CompilerServices.DynamicAttribute" />.</summary>
      <param name="transformFlags" vsli:raw="Specifies, in a prefix traversal of a type's construction, which &lt;see cref=&quot;T:System.Object&quot; /&gt; occurrences are meant to be treated as a dynamically dispatched type.">Spécifie, dans le parcours d'un préfixe de la construction d'un type, que les occurrences de <see cref="T:System.Object" /> doivent être traitées en tant que type distribué dynamiquement.</param>
    </member>
    <member name="P:System.Runtime.CompilerServices.DynamicAttribute.TransformFlags">
      <summary vsli:raw="Specifies, in a prefix traversal of a type's construction, which &lt;see cref=&quot;T:System.Object&quot; /&gt; occurrences are meant to be treated as a dynamically dispatched type.">Spécifie, dans le parcours d'un préfixe de la construction d'un type, que les occurrences de <see cref="T:System.Object" /> doivent être traitées en tant que type distribué dynamiquement.</summary>
      <returns vsli:raw="The list of &lt;see cref=&quot;T:System.Object&quot; /&gt; occurrences that are meant to be treated as a dynamically dispatched type.">Liste des occurrences de <see cref="T:System.Object" /> qui doivent être traitées en tant que type distribué dynamiquement.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.IRuntimeVariables">
      <summary vsli:raw="Represents the values of run-time variables.">Représente les valeurs des variables au moment de l'exécution.</summary>
    </member>
    <member name="P:System.Runtime.CompilerServices.IRuntimeVariables.Count">
      <summary vsli:raw="Gets a count of the run-time variables.">Obtient le nombre des variables au moment de l'exécution.</summary>
      <returns vsli:raw="The number of run-time variables.">Nombre des variables au moment de l'exécution.</returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.IRuntimeVariables.Item(System.Int32)">
      <summary vsli:raw="Gets the value of the run-time variable at the specified index.">Obtient la valeur de la variable au moment de l'exécution à l'index spécifié.</summary>
      <param name="index" vsli:raw="The zero-based index of the run-time variable whose value is to be returned.">Index de base zéro de la variable au moment de l'exécution dont la valeur doit être retournée.</param>
      <returns vsli:raw="The value of the run-time variable.">Valeur de la variable au moment de l'exécution.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1">
      <summary vsli:raw="The builder for read only collection.">Générateur pour la collection en lecture seule.</summary>
      <typeparam name="T" vsli:raw="The type of the collection element.">Type de l'élément de la collection.</typeparam>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.#ctor">
      <summary vsli:raw="Constructs a &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;.">Construit un objet <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary vsli:raw="Constructs a &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;, copying the contents of the given collection.">Construit <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> en copiant le contenu de la collection donnée.</summary>
      <param name="collection" vsli:raw="Collection to copy elements from.">Collection à partir de laquelle copier les éléments.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.#ctor(System.Int32)">
      <summary vsli:raw="Constructs a &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt; with a given initial capacity. The contents are empty but builder will have reserved room for the given number of elements before any reallocations are required.">Construit <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> avec une capacité initiale donnée. Le contenu est vide mais le générateur réserve de l’espace pour un nombre donné d’éléments avant que des réallocations ne soient nécessaires.</summary>
      <param name="capacity" vsli:raw="Initial capacity.">Capacité initiale.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Add(`0)">
      <summary vsli:raw="Adds an item to the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;.">Ajoute un élément à <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
      <param name="item" vsli:raw="The object to add to the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;.">Objet à ajouter à <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</param>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Capacity">
      <summary vsli:raw="Gets or sets the capacity of this &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;.">Obtient ou définit la capacité de ce <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
      <returns vsli:raw="The capacity of this &lt;c&gt;ReadOnlyCollectionBuilder.&lt;/c&gt;">Capacité de ce <c>ReadOnlyCollectionBuilder.</c></returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Clear">
      <summary vsli:raw="Removes all items from the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;.">Supprime tous les éléments de <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Contains(`0)">
      <summary vsli:raw="Determines whether the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt; contains a specific value.">Détermine si <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> contient une valeur spécifique</summary>
      <param name="item" vsli:raw="the object to locate in the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;.">Objet à localiser dans <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if item is found in the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">true si l’élément se trouve dans <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> ; sinon, false.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.CopyTo(`0[],System.Int32)">
      <summary vsli:raw="Copies the elements of the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt; to an &lt;see cref=&quot;T:System.Array&quot; /&gt;, starting at particular &lt;see cref=&quot;T:System.Array&quot; /&gt; index.">Copie les éléments de <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> dans <see cref="T:System.Array" />, en commençant à un index particulier de <see cref="T:System.Array" />.</summary>
      <param name="array" vsli:raw="The one-dimensional &lt;see cref=&quot;T:System.Array&quot; /&gt; that is the destination of the elements copied from &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;.">
        <see cref="T:System.Array" /> unidimensionnel qui constitue la destination des éléments copiés à partir de <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</param>
      <param name="arrayIndex" vsli:raw="The zero-based index in array at which copying begins.">Index de base zéro dans un tableau au niveau duquel commencer la copie.</param>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Count">
      <summary vsli:raw="Gets the number of elements in the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;.">Obtient le nombre d’éléments dans <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
      <returns vsli:raw="The number of elements in the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;.">Nombre d'éléments dans <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Retourne un énumérateur qui itère au sein de la collection.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Collections.Generic.IEnumerator`1&quot; /&gt; that can be used to iterate through the collection.">
        <see cref="T:System.Collections.Generic.IEnumerator`1" /> pouvant être utilisé pour itérer au sein de la collection.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.IndexOf(`0)">
      <summary vsli:raw="Returns the index of the first occurrence of a given value in the builder.">Retourne l’index de la première occurrence d’une valeur donnée dans le générateur.</summary>
      <param name="item" vsli:raw="An item to search for.">Élément à rechercher.</param>
      <returns vsli:raw="The index of the first occurrence of an item.">Index de la première occurrence d’un élément.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Insert(System.Int32,`0)">
      <summary vsli:raw="Inserts an item to the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt; at the specified index.">Insère un élément dans <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> à l'index spécifié.</summary>
      <param name="index" vsli:raw="The zero-based index at which item should be inserted.">Index de base zéro au niveau duquel l'élément doit être inséré.</param>
      <param name="item" vsli:raw="The object to insert into the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;.">Objet à insérer dans <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</param>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Item(System.Int32)">
      <summary vsli:raw="Gets or sets the element at the specified index.">Obtient ou définit l'élément au niveau de l'index spécifié.</summary>
      <param name="index" vsli:raw="The zero-based index of the element to get or set.">Index de base zéro de l'élément à obtenir ou à définir.</param>
      <returns vsli:raw="The element at the specified index.">Élément au niveau de l'index spécifié.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Remove(`0)">
      <summary vsli:raw="Removes the first occurrence of a specific object from the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;.">Supprime la première occurrence d'un objet spécifique de <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
      <param name="item" vsli:raw="The object to remove from the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;.">Objet à supprimer de <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if item was successfully removed from the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;; otherwise, false. This method also returns false if item is not found in the original &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;.">true si l’élément a pu être supprimé de <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> ; sinon, false. Cette méthode retourne également false si l’élément est introuvable dans le <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> d’origine.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.RemoveAt(System.Int32)">
      <summary vsli:raw="Removes the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt; item at the specified index.">Supprime l'élément <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> au niveau de l'index spécifié.</summary>
      <param name="index" vsli:raw="The zero-based index of the item to remove.">Index de base zéro de l'élément à supprimer.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Reverse">
      <summary vsli:raw="Reverses the order of the elements in the entire &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;.">Inverse l'ordre des éléments dans l'ensemble de <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Reverse(System.Int32,System.Int32)">
      <summary vsli:raw="Reverses the order of the elements in the specified range.">Inverse l'ordre des éléments dans la plage spécifiée.</summary>
      <param name="index" vsli:raw="The zero-based starting index of the range to reverse.">Index de début de base zéro de la plage à inverser.</param>
      <param name="count" vsli:raw="The number of elements in the range to reverse.">Nombre d'éléments à inverser dans la plage.</param>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
      <summary vsli:raw="Gets a value indicating whether the &lt;see cref=&quot;T:System.Collections.Generic.ICollection`1&quot; /&gt; is read-only.">Obtient une valeur indiquant si <see cref="T:System.Collections.Generic.ICollection`1" /> est en lecture seule.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Collections.Generic.ICollection`1&quot; /&gt; is read-only; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si <see cref="T:System.Collections.Generic.ICollection`1" /> est en lecture seule ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
      <summary vsli:raw="Copies the elements of the &lt;see cref=&quot;T:System.Collections.Generic.ICollection`1&quot; /&gt; to an array, starting at the specified array index.">Copie les éléments de l'objet <see cref="T:System.Collections.Generic.ICollection`1" /> dans un tableau, en commençant au niveau d'un index de tableau spécifié.</summary>
      <param name="array" vsli:raw="The one-dimensional array that is the destination of the elements copied from &lt;see cref=&quot;T:System.Collections.Generic.ICollection`1&quot; /&gt;. The array must have zero-based indexing.">Tableau unidimensionnel correspondant à la destination des éléments copiés à partir depuis <see cref="T:System.Collections.Generic.ICollection`1" />. Ce tableau doit avoir une indexation de base zéro.</param>
      <param name="index" vsli:raw="The zero-based index in &lt;paramref name=&quot;array&quot; /&gt; at which copying begins.">Index de base zéro dans l'<paramref name="array" /> à partir duquel la copie commence.</param>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#ICollection#IsSynchronized">
      <summary vsli:raw="Gets a value indicating whether access to the &lt;see cref=&quot;T:System.Collections.ICollection&quot; /&gt; is synchronized (thread safe).">Obtient une valeur indiquant si l'accès à <see cref="T:System.Collections.ICollection" /> est synchronisé (thread-safe).</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if access to the &lt;see cref=&quot;T:System.Collections.ICollection&quot; /&gt; is synchronized (thread safe); otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si l'accès à <see cref="T:System.Collections.ICollection" /> est synchronisé (thread-safe) ; sinon <see langword="false" />.</returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#ICollection#SyncRoot">
      <summary vsli:raw="Gets an object that can be used to synchronize access to the &lt;see cref=&quot;T:System.Collections.ICollection&quot; /&gt;.">Obtient un objet qui peut être utilisé pour synchroniser l'accès à <see cref="T:System.Collections.ICollection" />.</summary>
      <returns vsli:raw="An object that can be used to synchronize access to the &lt;see cref=&quot;T:System.Collections.ICollection&quot; /&gt;.">Objet qui peut être utilisé pour synchroniser l'accès à <see cref="T:System.Collections.ICollection" />.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Retourne un énumérateur qui itère au sein de la collection.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; that can be used to iterate through the collection.">
        <see cref="T:System.Collections.IEnumerator" /> qui peut être utilisé pour itérer au sein de la collection.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#Add(System.Object)">
      <summary vsli:raw="Adds an item to the &lt;see cref=&quot;T:System.Collections.IList&quot; /&gt;.">Ajoute un élément à <see cref="T:System.Collections.IList" />.</summary>
      <param name="value" vsli:raw="The &lt;see cref=&quot;T:System.Object&quot; /&gt; to add to the &lt;see cref=&quot;T:System.Collections.IList&quot; /&gt;.">
        <see cref="T:System.Object" /> à ajouter à <see cref="T:System.Collections.IList" />.</param>
      <returns vsli:raw="The position into which the new element was inserted.">Position à laquelle le nouvel élément est inséré.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#Contains(System.Object)">
      <summary vsli:raw="Determines whether the &lt;see cref=&quot;T:System.Collections.IList&quot; /&gt; contains a specific value.">Détermine si <see cref="T:System.Collections.IList" /> contient une valeur spécifique.</summary>
      <param name="value" vsli:raw="The &lt;see cref=&quot;T:System.Object&quot; /&gt; to locate in the &lt;see cref=&quot;T:System.Collections.IList&quot; /&gt;.">
        <see cref="T:System.Object" /> à rechercher dans <see cref="T:System.Collections.IList" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;item&quot; /&gt; is found in the &lt;see cref=&quot;T:System.Collections.IList&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si <paramref name="item" /> existe dans <see cref="T:System.Collections.IList" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#IndexOf(System.Object)">
      <summary vsli:raw="Determines the index of a specific item in the &lt;see cref=&quot;T:System.Collections.IList&quot; /&gt;.">Détermine l'index d'un élément spécifique d'<see cref="T:System.Collections.IList" />.</summary>
      <param name="value" vsli:raw="The object to locate in the &lt;see cref=&quot;T:System.Collections.IList&quot; /&gt;.">Objet à rechercher dans <see cref="T:System.Collections.IList" />.</param>
      <returns vsli:raw="The index of &lt;paramref name=&quot;item&quot; /&gt; if found in the list; otherwise, -1.">Index de <paramref name="item" /> s'il figure dans la liste ; sinon, -1.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#Insert(System.Int32,System.Object)">
      <summary vsli:raw="Inserts an item to the &lt;see cref=&quot;T:System.Collections.IList&quot; /&gt; at the specified index.">Insère un élément dans <see cref="T:System.Collections.IList" /> à l'index spécifié.</summary>
      <param name="index" vsli:raw="The zero-based index at which &lt;paramref name=&quot;item&quot; /&gt; should be inserted.">Index de base zéro au niveau duquel <paramref name="item" /> doit être inséré.</param>
      <param name="value" vsli:raw="The object to insert into the &lt;see cref=&quot;T:System.Collections.IList&quot; /&gt;.">Objet à insérer dans <see cref="T:System.Collections.IList" />.</param>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#IsFixedSize">
      <summary vsli:raw="Gets a value indicating whether the &lt;see cref=&quot;T:System.Collections.IList&quot; /&gt; has a fixed size.">Obtient une valeur indiquant si <see cref="T:System.Collections.IList" /> est de taille fixe.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Collections.IList&quot; /&gt; has a fixed size; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si <see cref="T:System.Collections.IList" /> est de taille fixe ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#IsReadOnly">
      <summary vsli:raw="Gets a value indicating whether the &lt;see cref=&quot;T:System.Collections.IList&quot; /&gt; is read-only.">Obtient une valeur indiquant si <see cref="T:System.Collections.IList" /> est en lecture seule.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Collections.IList&quot; /&gt; is read-only; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si <see cref="T:System.Collections.IList" /> est en lecture seule ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#Item(System.Int32)">
      <summary vsli:raw="Gets or sets the element at the specified index.">Obtient ou définit l'élément au niveau de l'index spécifié.</summary>
      <param name="index" vsli:raw="The zero-based index of the element to get or set.">Index de base zéro de l'élément à obtenir ou à définir.</param>
      <returns vsli:raw="The element at the specified index.">Élément au niveau de l'index spécifié.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#Remove(System.Object)">
      <summary vsli:raw="Removes the first occurrence of a specific object from the &lt;see cref=&quot;T:System.Collections.IList&quot; /&gt;.">Supprime la première occurrence d'un objet spécifique de <see cref="T:System.Collections.IList" />.</summary>
      <param name="value" vsli:raw="The object to remove from the &lt;see cref=&quot;T:System.Collections.IList&quot; /&gt;.">Objet à supprimer de <see cref="T:System.Collections.IList" />.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.ToArray">
      <summary vsli:raw="Copies the elements of the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt; to a new array.">Copie les éléments de <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> dans un nouveau tableau.</summary>
      <returns vsli:raw="An array containing copies of the elements of the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;.">Tableau contenant les copies des éléments du <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.ToReadOnlyCollection">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Collections.ObjectModel.ReadOnlyCollection`1&quot; /&gt; containing all of the elements of the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;, avoiding copying the elements to the new array if possible. Resets the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt; after the &lt;see cref=&quot;T:System.Collections.ObjectModel.ReadOnlyCollection`1&quot; /&gt; has been created.">Crée un <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> qui contient tous les éléments de <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />, en évitant si possible de copier les éléments vers le nouveau tableau. Réinitialise <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> après la création de <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</summary>
      <returns vsli:raw="A new instance of &lt;see cref=&quot;T:System.Collections.ObjectModel.ReadOnlyCollection`1&quot; /&gt;.">Nouvelle instance de <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.RuleCache`1">
      <summary vsli:raw="Represents a cache of runtime binding rules.">Représente un cache des règles de liaison au moment de l'exécution.</summary>
      <typeparam name="T" vsli:raw="The delegate type.">Type de délégué.</typeparam>
    </member>
  </members>
</doc>