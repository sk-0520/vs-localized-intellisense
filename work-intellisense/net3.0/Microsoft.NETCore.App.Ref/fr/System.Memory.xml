<?xml version="1.0" encoding="utf-8"?>
<doc xmlns:vsli="https://github.com/sk-0520/vs-localized-intellisense/tree/master/schema/2024">
  <assembly>
    <name>System.Memory</name>
  </assembly>
  <members>
    <member name="T:System.Buffers.ArrayBufferWriter`1">
      <summary vsli:raw="Represents a heap-based, array-backed output sink into which &lt;typeparamref name=&quot;T&quot; /&gt; data can be written.">Représente un récepteur de sortie avec tableau et basé sur le tas, dans lequel <typeparam name="T" /> des données peuvent être écrites.</summary>
      <typeparam name="T" vsli:raw="The type of the items in this &lt;see cref=&quot;T:System.Buffers.ArrayBufferWriter`1&quot; /&gt; instance.">Type des éléments de cette <see cref="T:System.Buffers.ArrayBufferWriter`1" /> instance.</typeparam>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.#ctor">
      <summary vsli:raw="Creates an instance of an &lt;see cref=&quot;T:System.Buffers.ArrayBufferWriter`1&quot; /&gt; to which data can be written, with the default initial capacity.">Crée une instance d’un <see cref="T:System.Buffers.ArrayBufferWriter`1" /> dans lequel des données peuvent être écrites, avec la capacité initiale par défaut.</summary>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.#ctor(System.Int32)">
      <summary vsli:raw="Creates an instance of an &lt;see cref=&quot;T:System.Buffers.ArrayBufferWriter`1&quot; /&gt; to which data can be written, with a specified initial capacity.">Crée une instance d’un <see cref="T:System.Buffers.ArrayBufferWriter`1" /> dans lequel des données peuvent être écrites, avec une capacité initiale spécifiée.</summary>
      <param name="initialCapacity" vsli:raw="The minimum capacity with which to initialize the underlying buffer.">La capacité minimale avec laquelle initialiser la mémoire tampon sous-jacente.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;initialCapacity&quot; /&gt; is less than or equal to 0.">
        <paramref name="initialCapacity" /> est inférieur ou égal à 0.</exception>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.Advance(System.Int32)">
      <summary vsli:raw="Notifies the &lt;see cref=&quot;T:System.Buffers.IBufferWriter`1&quot; /&gt; that &lt;paramref name=&quot;count&quot; /&gt; items were written to the output &lt;see cref=&quot;T:System.Span`1&quot; /&gt;/&lt;see cref=&quot;T:System.Memory`1&quot; /&gt;.">Indique au <see cref="T:System.Buffers.IBufferWriter`1" /> que des éléments <paramref name="count" /> ont été écrits dans la <see cref="T:System.Span`1" />/<see cref="T:System.Memory`1" /> de sortie.</summary>
      <param name="count" vsli:raw="The number of items written.">Nombre d’éléments écrits.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;count&quot; /&gt; is negative.">
        <paramref name="count" /> est un nombre négatif.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method call attempts to advance past the end of the underlying buffer.">L’appel de méthode tente d’avancer jusqu’après la fin de la mémoire tampon sous-jacente.</exception>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.Capacity">
      <summary vsli:raw="Gets the total amount of space within the underlying buffer.">Obtient la quantité totale d’espace dans la mémoire tampon sous-jacente.</summary>
      <returns vsli:raw="The total capacity of the underlying buffer.">Capacité totale de la mémoire tampon sous-jacente.</returns>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.Clear">
      <summary vsli:raw="Clears the data written to the underlying buffer.">Efface les données écrites dans la mémoire tampon sous-jacente.</summary>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.FreeCapacity">
      <summary vsli:raw="Gets the amount of available space that can be written to without forcing the underlying buffer to grow.">Obtient la quantité d’espace disponible où il est possible d’écrire sans forcer l’accroissement de la mémoire tampon sous-jacente.</summary>
      <returns vsli:raw="The space available for writing without forcing the underlying buffer to grow.">Espace disponible pour l’écriture sans forcer la croissance de la mémoire tampon sous-jacente.</returns>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.GetMemory(System.Int32)">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Memory`1&quot; /&gt; to write to that is at least the length specified by &lt;paramref name=&quot;sizeHint&quot; /&gt;.">Retourne une <see cref="T:System.Memory`1" /> où écrire, qui a au moins la longueur spécifiée par <paramref name="sizeHint" />.</summary>
      <param name="sizeHint" vsli:raw="The minimum requested length of the &lt;see cref=&quot;T:System.Memory`1&quot; /&gt;.">Longueur minimale demandée de la <see cref="T:System.Memory`1" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Memory`1&quot; /&gt; whose length is at least &lt;paramref name=&quot;sizeHint&quot; /&gt;.  If &lt;paramref name=&quot;sizeHint&quot; /&gt; is not provided or is equal to 0, some non-empty buffer is returned.">
        <see cref="T:System.Memory`1" /> dont la longueur est d’au moins <paramref name="sizeHint" />.  Si <paramref name="sizeHint" /> n’est pas fourni ou est égal à 0, une mémoire tampon non vide est retournée.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;sizeHint&quot; /&gt; is negative.">
        <paramref name="sizeHint" /> est un nombre négatif.</exception>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.GetSpan(System.Int32)">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Span`1&quot; /&gt; to write to that is at least a specified length.">Retourne une <see cref="T:System.Span`1" /> où écrire, qui a au moins une longueur spécifiée.</summary>
      <param name="sizeHint" vsli:raw="The minimum requested length of the &lt;see cref=&quot;T:System.Span`1&quot; /&gt;.">Longueur minimale demandée de la <see cref="T:System.Span`1" />.</param>
      <returns vsli:raw="A span of at least &lt;paramref name=&quot;sizeHint&quot; /&gt; in length. If &lt;paramref name=&quot;sizeHint&quot; /&gt; is not provided or is equal to 0, some non-empty buffer is returned.">Une plage dont la longueur est d’au moins <paramref name="sizeHint" />. Si <paramref name="sizeHint" /> n’est pas fourni ou est égal à 0, une mémoire tampon non vide est retournée.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;sizeHint&quot; /&gt; is negative.">
        <paramref name="sizeHint" /> est un nombre négatif.</exception>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.WrittenCount">
      <summary vsli:raw="Gets the amount of data written to the underlying buffer.">Obtient la quantité de données écrites dans la mémoire tampon sous-jacente.</summary>
      <returns vsli:raw="The amount of data written to the underlying buffer.">Quantité de données écrites dans la mémoire tampon sous-jacente.</returns>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.WrittenMemory">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt; that contains the data written to the underlying buffer so far.">Obtient une <see cref="T:System.ReadOnlyMemory`1" /> qui contient les données écrites jusqu’à présent dans la mémoire tampon sous-jacente.</summary>
      <returns vsli:raw="The data written to the underlying buffer.">Données écrites dans la mémoire tampon sous-jacente.</returns>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.WrittenSpan">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; that contains the data written to the underlying buffer so far.">Obtient une <see cref="T:System.ReadOnlySpan`1" /> qui contient les données écrites jusqu’à présent dans la mémoire tampon sous-jacente.</summary>
      <returns vsli:raw="The data written to the underlying buffer.">Données écrites dans la mémoire tampon sous-jacente.</returns>
    </member>
    <member name="T:System.Buffers.Binary.BinaryPrimitives">
      <summary vsli:raw="Reads bytes as primitives with specific endianness.">Lit les octets en tant que primitives avec un endianness spécifique.</summary>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt16BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int16&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Lit un <see cref="T:System.Int16" /> à partir du début d’une étendue en lecture seule d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="source" vsli:raw="The read-only span to read.">Étendue en lecture seule à lire.</param>
      <returns vsli:raw="The big endian value.">Valeur avec primauté des octets de poids fort (big-endian).</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int16&quot; /&gt;.">
        <paramref name="source" /> est trop petit pour contenir un <see cref="T:System.Int16" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt16LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int16&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Lit un <see cref="T:System.Int16" /> à partir du début d’une étendue en lecture seule d’octets, en mode Little Endian.</summary>
      <param name="source" vsli:raw="The read-only span to read.">Étendue en lecture seule à lire.</param>
      <returns vsli:raw="The little endian value.">Valeur en mode Little Endian.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int16&quot; /&gt;.">
        <paramref name="source" /> est trop petit pour contenir un <see cref="T:System.Int16" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt32BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int32&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Lit un <see cref="T:System.Int32" /> à partir du début d’une étendue en lecture seule d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="source" vsli:raw="The read-only span to read.">Étendue en lecture seule à lire.</param>
      <returns vsli:raw="The big endian value.">Valeur avec primauté des octets de poids fort (big-endian).</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int32&quot; /&gt;.">
        <paramref name="source" /> est trop petit pour contenir un <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt32LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int32&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Lit un <see cref="T:System.Int32" /> à partir du début d’une étendue en lecture seule d’octets, en mode Little Endian.</summary>
      <param name="source" vsli:raw="The read-only span to read.">Étendue en lecture seule à lire.</param>
      <returns vsli:raw="The little endian value.">Valeur en mode Little Endian.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int32&quot; /&gt;.">
        <paramref name="source" /> est trop petit pour contenir un <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt64BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int64&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Lit un <see cref="T:System.Int64" /> à partir du début d’une étendue en lecture seule d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="source" vsli:raw="The read-only span to read.">Étendue en lecture seule à lire.</param>
      <returns vsli:raw="The big endian value.">Valeur avec primauté des octets de poids fort (big-endian).</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int64&quot; /&gt;.">
        <paramref name="source" /> est trop petit pour contenir un <see cref="T:System.Int64" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt64LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int64&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Lit un <see cref="T:System.Int64" /> à partir du début d’une étendue en lecture seule d’octets, en mode Little Endian.</summary>
      <param name="source" vsli:raw="The read-only span to read.">Étendue en lecture seule à lire.</param>
      <returns vsli:raw="The little endian value.">Valeur en mode Little Endian.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int64&quot; /&gt;.">
        <paramref name="source" /> est trop petit pour contenir un <see cref="T:System.Int64" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt16BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Lit un <see cref="T:System.UInt16" /> à partir du début d’une étendue en lecture seule d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="source" vsli:raw="The read-only span to read.">Étendue en lecture seule à lire.</param>
      <returns vsli:raw="The big endian value.">Valeur avec primauté des octets de poids fort (big-endian).</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt16&quot; /&gt;.">
        <paramref name="source" /> est trop petit pour contenir un <see cref="T:System.UInt16" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt16LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Lit un <see cref="T:System.UInt16" /> à partir du début d’une étendue en lecture seule d’octets, en mode Little Endian.</summary>
      <param name="source" vsli:raw="The read-only span to read.">Étendue en lecture seule à lire.</param>
      <returns vsli:raw="The little endian value.">Valeur en mode Little Endian.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt16&quot; /&gt;.">
        <paramref name="source" /> est trop petit pour contenir un <see cref="T:System.UInt16" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt32BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Lit un <see cref="T:System.UInt32" /> à partir du début d’une étendue en lecture seule d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="source" vsli:raw="The read-only span to read.">Étendue en lecture seule à lire.</param>
      <returns vsli:raw="The big endian value.">Valeur avec primauté des octets de poids fort (big-endian).</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt32&quot; /&gt;.">
        <paramref name="source" /> est trop petit pour contenir un <see cref="T:System.UInt32" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt32LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Lit un <see cref="T:System.UInt32" /> à partir du début d’une étendue en lecture seule d’octets, en mode Little Endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Étendue en lecture seule d’octets à lire.</param>
      <returns vsli:raw="The little endian value.">Valeur en mode Little Endian.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt32&quot; /&gt;.">
        <paramref name="source" /> est trop petit pour contenir un <see cref="T:System.UInt32" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt64BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Lit un <see cref="T:System.UInt64" /> à partir du début d’une étendue en lecture seule d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Étendue en lecture seule d’octets à lire.</param>
      <returns vsli:raw="The big endian value.">Valeur avec primauté des octets de poids fort (big-endian).</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt64&quot; /&gt;.">
        <paramref name="source" /> est trop petit pour contenir un <see cref="T:System.UInt64" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt64LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Lit un <see cref="T:System.UInt64" /> à partir du début d’une étendue en lecture seule d’octets, en mode Little Endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Étendue en lecture seule d’octets à lire.</param>
      <returns vsli:raw="The little endian value.">Valeur en mode Little Endian.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt64&quot; /&gt;.">
        <paramref name="source" /> est trop petit pour contenir un <see cref="T:System.UInt64" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Byte)">
      <summary vsli:raw="Reverses a primitive value by performing an endianness swap of the specified &lt;see cref=&quot;T:System.Byte&quot; /&gt; value, which effectively does nothing for a &lt;see cref=&quot;T:System.Byte&quot; /&gt;.">Inverse une valeur primitive en effectuant une permutation endianness de la valeur <see cref="T:System.Byte" /> spécifiée, ce qui n’a aucun effet pour un <see cref="T:System.Byte" />.</summary>
      <param name="value" vsli:raw="The value to reverse.">Valeur à inverser.</param>
      <returns vsli:raw="The passed-in value, unmodified.">Valeur passée, non modifiée.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int16)">
      <summary vsli:raw="Reverses a primitive value by performing an endianness swap of the specified &lt;see cref=&quot;T:System.Int16&quot; /&gt; value.">Inverse une valeur primitive en effectuant une permutation endianness de la valeur <see cref="T:System.Int16" /> spécifiée.</summary>
      <param name="value" vsli:raw="The value to reverse.">Valeur à inverser.</param>
      <returns vsli:raw="The reversed value.">Valeur inversée.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int32)">
      <summary vsli:raw="Reverses a primitive value by performing an endianness swap of the specified &lt;see cref=&quot;T:System.Int32&quot; /&gt; value.">Inverse une valeur primitive en effectuant une permutation endianness de la valeur <see cref="T:System.Int32" /> spécifiée.</summary>
      <param name="value" vsli:raw="The value to reverse.">Valeur à inverser.</param>
      <returns vsli:raw="The reversed value.">Valeur inversée.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int64)">
      <summary vsli:raw="Reverses a primitive value by performing an endianness swap of the specified &lt;see cref=&quot;T:System.Int64&quot; /&gt; value.">Inverse une valeur primitive en effectuant une permutation endianness de la valeur <see cref="T:System.Int64" /> spécifiée.</summary>
      <param name="value" vsli:raw="The value to reverse.">Valeur à inverser.</param>
      <returns vsli:raw="The reversed value.">Valeur inversée.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.SByte)">
      <summary vsli:raw="Reverses a primitive value by performing an endianness swap of the specified &lt;see cref=&quot;T:System.SByte&quot; /&gt; value, which effectively does nothing for an &lt;see cref=&quot;T:System.SByte&quot; /&gt;.">Inverse une valeur primitive en effectuant une permutation endianness de la valeur <see cref="T:System.SByte" /> spécifiée, ce qui n’a aucun effet pour un <see cref="T:System.SByte" />.</summary>
      <param name="value" vsli:raw="The value to reverse.">Valeur à inverser.</param>
      <returns vsli:raw="The passed-in value, unmodified.">Valeur passée, non modifiée.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt16)">
      <summary vsli:raw="Reverses a primitive value by performing an endianness swap of the specified &lt;see cref=&quot;T:System.UInt16&quot; /&gt; value.">Inverse une valeur primitive en effectuant une permutation endianness de la valeur <see cref="T:System.UInt16" /> spécifiée.</summary>
      <param name="value" vsli:raw="The value to reverse.">Valeur à inverser.</param>
      <returns vsli:raw="The reversed value.">Valeur inversée.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt32)">
      <summary vsli:raw="Reverses a primitive value by performing an endianness swap of the specified &lt;see cref=&quot;T:System.UInt32&quot; /&gt; value.">Inverse une valeur primitive en effectuant une permutation endianness de la valeur <see cref="T:System.UInt32" /> spécifiée.</summary>
      <param name="value" vsli:raw="The value to reverse.">Valeur à inverser.</param>
      <returns vsli:raw="The reversed value.">Valeur inversée.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt64)">
      <summary vsli:raw="Reverses a primitive value by performing an endianness swap of the specified &lt;see cref=&quot;T:System.UInt64&quot; /&gt; value.">Inverse une valeur primitive en effectuant une permutation endianness de la valeur <see cref="T:System.UInt64" /> spécifiée.</summary>
      <param name="value" vsli:raw="The value to reverse.">Valeur à inverser.</param>
      <returns vsli:raw="The reversed value.">Valeur inversée.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt16BigEndian(System.ReadOnlySpan{System.Byte},System.Int16@)">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int16&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Lit un <see cref="T:System.Int16" /> à partir du début d’une étendue en lecture seule d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Étendue en lecture seule d’octets à lire.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as big endian.">Lorsque cette méthode est retournée, valeur lue à partir de l’étendue en lecture seule d’octets, avec primauté des octets de poids fort (big-endian).</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int16&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.Int16" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt16LittleEndian(System.ReadOnlySpan{System.Byte},System.Int16@)">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int16&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Lit un <see cref="T:System.Int16" /> à partir du début d’une étendue en lecture seule d’octets, en mode Little Endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Étendue en lecture seule d’octets à lire.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as little endian.">Lorsque cette méthode est retournée, valeur lue à partir de l’étendue en lecture seule d’octets, en mode Little Endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int16&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.Int16" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt32BigEndian(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int32&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Lit un <see cref="T:System.Int32" /> à partir du début d’une étendue en lecture seule d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Étendue en lecture seule d’octets à lire.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as big endian.">Lorsque cette méthode est retournée, valeur lue à partir de l’étendue en lecture seule d’octets, avec primauté des octets de poids fort (big-endian).</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int32&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.Int32" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt32LittleEndian(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int32&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Lit un <see cref="T:System.Int32" /> à partir du début d’une étendue en lecture seule d’octets, en mode Little Endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Étendue en lecture seule d’octets à lire.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as little endian.">Lorsque cette méthode est retournée, valeur lue à partir de l’étendue en lecture seule d’octets, en mode Little Endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int32&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.Int32" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt64BigEndian(System.ReadOnlySpan{System.Byte},System.Int64@)">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int64&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Lit un <see cref="T:System.Int64" /> à partir du début d’une étendue en lecture seule d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Étendue en lecture seule d’octets à lire.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as big endian.">Lorsque cette méthode est retournée, valeur lue à partir de l’étendue en lecture seule d’octets, avec primauté des octets de poids fort (big-endian).</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int64&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.Int64" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt64LittleEndian(System.ReadOnlySpan{System.Byte},System.Int64@)">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int64&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Lit un <see cref="T:System.Int64" /> à partir du début d’une étendue en lecture seule d’octets, en mode Little Endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Étendue en lecture seule d’octets à lire.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as little endian.">Lorsque cette méthode est retournée, valeur lue à partir de l’étendue en lecture seule d’octets, en mode Little Endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int64&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.Int64" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt16BigEndian(System.ReadOnlySpan{System.Byte},System.UInt16@)">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Lit un <see cref="T:System.UInt16" /> à partir du début d’une étendue en lecture seule d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Étendue en lecture seule d’octets à lire.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as big endian.">Lorsque cette méthode est retournée, valeur lue à partir de l’étendue en lecture seule d’octets, avec primauté des octets de poids fort (big-endian).</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt16&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.UInt16" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt16LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt16@)">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Lit un <see cref="T:System.UInt16" /> à partir du début d’une étendue en lecture seule d’octets, en mode Little Endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Étendue en lecture seule d’octets à lire.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as little endian.">Lorsque cette méthode est retournée, valeur lue à partir de l’étendue en lecture seule d’octets, en mode Little Endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt16&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.UInt16" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt32BigEndian(System.ReadOnlySpan{System.Byte},System.UInt32@)">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Lit un <see cref="T:System.UInt32" /> à partir du début d’une étendue en lecture seule d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Étendue en lecture seule d’octets à lire.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as big endian.">Lorsque cette méthode est retournée, valeur lue à partir de l’étendue en lecture seule d’octets, avec primauté des octets de poids fort (big-endian).</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt32&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.UInt32" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt32LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt32@)">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Lit un <see cref="T:System.UInt32" /> à partir du début d’une étendue en lecture seule d’octets, en mode Little Endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Étendue en lecture seule d’octets à lire.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as little endian.">Lorsque cette méthode est retournée, valeur lue à partir de l’étendue en lecture seule d’octets, en mode Little Endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt32&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.UInt32" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt64BigEndian(System.ReadOnlySpan{System.Byte},System.UInt64@)">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Lit un <see cref="T:System.UInt64" /> à partir du début d’une étendue en lecture seule d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Étendue en lecture seule d’octets à lire.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as big endian.">Lorsque cette méthode est retournée, valeur lue à partir de l’étendue en lecture seule d’octets, avec primauté des octets de poids fort (big-endian).</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt64&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.UInt64" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt64LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt64@)">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Lit un <see cref="T:System.UInt64" /> à partir du début d’une étendue en lecture seule d’octets, en mode Little Endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Étendue en lecture seule d’octets à lire.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as little endian.">Lorsque cette méthode est retournée, valeur lue à partir de l’étendue en lecture seule d’octets, en mode Little Endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt64&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.UInt64" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt16BigEndian(System.Span{System.Byte},System.Int16)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int16&quot; /&gt; into a span of bytes, as big endian.">Écrit un <see cref="T:System.Int16" /> dans une étendue d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Étendue d’octets dans laquelle la valeur doit être écrite, avec primauté des octets de poids fort (big-endian).</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valeur à écrire dans l’étendue d’octets.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int16&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.Int16" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt16LittleEndian(System.Span{System.Byte},System.Int16)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int16&quot; /&gt; into a span of bytes, as little endian.">Écrit un <see cref="T:System.Int16" /> dans une étendue d’octets, en mode Little Endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Étendue d’octets dans laquelle la valeur doit être écrite, en mode Little Endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valeur à écrire dans l’étendue d’octets.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int16&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.Int16" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt32BigEndian(System.Span{System.Byte},System.Int32)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int32&quot; /&gt; into a span of bytes, as big endian.">Écrit un <see cref="T:System.Int32" /> dans une étendue d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Étendue d’octets dans laquelle la valeur doit être écrite, avec primauté des octets de poids fort (big-endian).</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valeur à écrire dans l’étendue d’octets.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int32&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.Int32" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt32LittleEndian(System.Span{System.Byte},System.Int32)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int32&quot; /&gt; into a span of bytes, as little endian.">Écrit un <see cref="T:System.Int32" /> dans une étendue d’octets, en mode Little Endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Étendue d’octets dans laquelle la valeur doit être écrite, en mode Little Endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valeur à écrire dans l’étendue d’octets.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int32&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.Int32" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt64BigEndian(System.Span{System.Byte},System.Int64)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int64&quot; /&gt; into a span of bytes, as big endian.">Écrit un <see cref="T:System.Int64" /> dans une étendue d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Étendue d’octets dans laquelle la valeur doit être écrite, avec primauté des octets de poids fort (big-endian).</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valeur à écrire dans l’étendue d’octets.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int64&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.Int64" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt64LittleEndian(System.Span{System.Byte},System.Int64)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int64&quot; /&gt; into a span of bytes, as little endian.">Écrit un <see cref="T:System.Int64" /> dans une étendue d’octets, en mode Little Endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Étendue d’octets dans laquelle la valeur doit être écrite, en mode Little Endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valeur à écrire dans l’étendue d’octets.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int64&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.Int64" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt16BigEndian(System.Span{System.Byte},System.UInt16)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; into a span of bytes, as big endian.">Écrit un <see cref="T:System.UInt16" /> dans une étendue d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Étendue d’octets dans laquelle la valeur doit être écrite, avec primauté des octets de poids fort (big-endian).</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valeur à écrire dans l’étendue d’octets.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt16&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.UInt16" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt16LittleEndian(System.Span{System.Byte},System.UInt16)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; into a span of bytes, as little endian.">Écrit un <see cref="T:System.UInt16" /> dans une étendue d’octets, en mode Little Endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Étendue d’octets dans laquelle la valeur doit être écrite, en mode Little Endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valeur à écrire dans l’étendue d’octets.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt16&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.UInt16" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt32BigEndian(System.Span{System.Byte},System.UInt32)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; into a span of bytes, as big endian.">Écrit un <see cref="T:System.UInt32" /> dans une étendue d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Étendue d’octets dans laquelle la valeur doit être écrite, avec primauté des octets de poids fort (big-endian).</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valeur à écrire dans l’étendue d’octets.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt32&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.UInt32" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt32LittleEndian(System.Span{System.Byte},System.UInt32)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; into a span of bytes, as little endian.">Écrit un <see cref="T:System.UInt32" /> dans une étendue d’octets, en mode Little Endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Étendue d’octets dans laquelle la valeur doit être écrite, en mode Little Endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valeur à écrire dans l’étendue d’octets.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt32&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.UInt32" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt64BigEndian(System.Span{System.Byte},System.UInt64)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; into a span of bytes, as big endian.">Écrit un <see cref="T:System.UInt64" /> dans une étendue d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Étendue d’octets dans laquelle la valeur doit être écrite, avec primauté des octets de poids fort (big-endian).</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valeur à écrire dans l’étendue d’octets.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt64&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.UInt64" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt64LittleEndian(System.Span{System.Byte},System.UInt64)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; into a span of bytes, as little endian.">Écrit un <see cref="T:System.UInt64" /> dans une étendue d’octets, en mode Little Endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Étendue d’octets dans laquelle la valeur doit être écrite, en mode Little Endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valeur à écrire dans l’étendue d’octets.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt64&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.UInt64" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt16BigEndian(System.Span{System.Byte},System.Int16)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int16&quot; /&gt; into a span of bytes, as big endian.">Écrit un <see cref="T:System.Int16" /> dans une étendue d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Étendue d’octets dans laquelle la valeur doit être écrite, avec primauté des octets de poids fort (big-endian).</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valeur à écrire dans l’étendue d’octets.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int16&quot; /&gt;.">
        <paramref name="destination" /> est trop petit pour contenir un <see cref="T:System.Int16" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt16LittleEndian(System.Span{System.Byte},System.Int16)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int16&quot; /&gt; into a span of bytes, as little endian.">Écrit un <see cref="T:System.Int16" /> dans une étendue d’octets, en mode Little Endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Étendue d’octets dans laquelle la valeur doit être écrite, en mode Little Endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valeur à écrire dans l’étendue d’octets.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int16&quot; /&gt;.">
        <paramref name="destination" /> est trop petit pour contenir un <see cref="T:System.Int16" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt32BigEndian(System.Span{System.Byte},System.Int32)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int32&quot; /&gt; into a span of bytes, as big endian.">Écrit un <see cref="T:System.Int32" /> dans une étendue d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Étendue d’octets dans laquelle la valeur doit être écrite, avec primauté des octets de poids fort (big-endian).</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valeur à écrire dans l’étendue d’octets.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int32&quot; /&gt;.">
        <paramref name="destination" /> est trop petit pour contenir un <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt32LittleEndian(System.Span{System.Byte},System.Int32)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int32&quot; /&gt; into a span of bytes, as little endian.">Écrit un <see cref="T:System.Int32" /> dans une étendue d’octets, en mode Little Endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Étendue d’octets dans laquelle la valeur doit être écrite, en mode Little Endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valeur à écrire dans l’étendue d’octets.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int32&quot; /&gt;.">
        <paramref name="destination" /> est trop petit pour contenir un <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt64BigEndian(System.Span{System.Byte},System.Int64)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int64&quot; /&gt; into a span of bytes, as big endian.">Écrit un <see cref="T:System.Int64" /> dans une étendue d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Étendue d’octets dans laquelle la valeur doit être écrite, avec primauté des octets de poids fort (big-endian).</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valeur à écrire dans l’étendue d’octets.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int64&quot; /&gt;.">
        <paramref name="destination" /> est trop petit pour contenir un <see cref="T:System.Int64" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt64LittleEndian(System.Span{System.Byte},System.Int64)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int64&quot; /&gt; into a span of bytes, as little endian.">Écrit un <see cref="T:System.Int64" /> dans une étendue d’octets, en mode Little Endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Étendue d’octets dans laquelle la valeur doit être écrite, en mode Little Endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valeur à écrire dans l’étendue d’octets.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int64&quot; /&gt;.">
        <paramref name="destination" /> est trop petit pour contenir un <see cref="T:System.Int64" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt16BigEndian(System.Span{System.Byte},System.UInt16)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; into a span of bytes, as big endian.">Écrit un <see cref="T:System.UInt16" /> dans une étendue d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Étendue d’octets dans laquelle la valeur doit être écrite, avec primauté des octets de poids fort (big-endian).</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valeur à écrire dans l’étendue d’octets.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt16&quot; /&gt;.">
        <paramref name="destination" /> est trop petit pour contenir un <see cref="T:System.UInt16" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt16LittleEndian(System.Span{System.Byte},System.UInt16)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; into a span of bytes, as little endian.">Écrit un <see cref="T:System.UInt16" /> dans une étendue d’octets, en mode Little Endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Étendue d’octets dans laquelle la valeur doit être écrite, en mode Little Endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valeur à écrire dans l’étendue d’octets.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt16&quot; /&gt;.">
        <paramref name="destination" /> est trop petit pour contenir un <see cref="T:System.UInt16" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt32BigEndian(System.Span{System.Byte},System.UInt32)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; into a span of bytes, as big endian.">Écrit un <see cref="T:System.UInt32" /> dans une étendue d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Étendue d’octets dans laquelle la valeur doit être écrite, avec primauté des octets de poids fort (big-endian).</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valeur à écrire dans l’étendue d’octets.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt32&quot; /&gt;.">
        <paramref name="destination" /> est trop petit pour contenir un <see cref="T:System.UInt32" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt32LittleEndian(System.Span{System.Byte},System.UInt32)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; into a span of bytes, as little endian.">Écrit un <see cref="T:System.UInt32" /> dans une étendue d’octets, en mode Little Endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Étendue d’octets dans laquelle la valeur doit être écrite, en mode Little Endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valeur à écrire dans l’étendue d’octets.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt32&quot; /&gt;.">
        <paramref name="destination" /> est trop petit pour contenir un <see cref="T:System.UInt32" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt64BigEndian(System.Span{System.Byte},System.UInt64)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; into a span of bytes, as big endian.">Écrit un <see cref="T:System.UInt64" /> dans une étendue d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Étendue d’octets dans laquelle la valeur doit être écrite, avec primauté des octets de poids fort (big-endian).</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valeur à écrire dans l’étendue d’octets.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt64&quot; /&gt;.">
        <paramref name="destination" /> est trop petit pour contenir un <see cref="T:System.UInt64" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt64LittleEndian(System.Span{System.Byte},System.UInt64)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; into a span of bytes, as little endian.">Écrit un <see cref="T:System.UInt64" /> dans une étendue d’octets, en mode Little Endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Étendue d’octets dans laquelle la valeur doit être écrite, en mode Little Endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valeur à écrire dans l’étendue d’octets.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt64&quot; /&gt;.">
        <paramref name="destination" /> est trop petit pour contenir un <see cref="T:System.UInt64" />.</exception>
    </member>
    <member name="T:System.Buffers.BuffersExtensions">
      <summary vsli:raw="Provides extension methods for &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Fournit des méthodes d'extension pour <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
    </member>
    <member name="M:System.Buffers.BuffersExtensions.CopyTo``1(System.Buffers.ReadOnlySequence{``0},System.Span{``0})">
      <summary vsli:raw="Copies the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; to the specified &lt;see cref=&quot;T:System.Span`1&quot; /&gt;.">Copie le <see cref="T:System.Buffers.ReadOnlySequence`1" /> dans le <see cref="T:System.Span`1" /> spécifié.</summary>
      <param name="source" vsli:raw="The source &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">
        <see cref="T:System.Buffers.ReadOnlySequence`1" /> source.</param>
      <param name="destination" vsli:raw="The destination &lt;see cref=&quot;T:System.Span`1&quot; /&gt;.">
        <see cref="T:System.Span`1" /> de destination.</param>
      <typeparam name="T" vsli:raw="The type of the items in the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Type des éléments de <see cref="T:System.Buffers.ReadOnlySequence`1" />.</typeparam>
    </member>
    <member name="M:System.Buffers.BuffersExtensions.PositionOf``1(System.Buffers.ReadOnlySequence{``0},``0)">
      <summary vsli:raw="Returns the position of the first occurrence of &lt;paramref name=&quot;item&quot; /&gt; in the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Retourne la position de la première occurrence de <paramref name="item" /> dans <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
      <param name="source" vsli:raw="The source &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">
        <see cref="T:System.Buffers.ReadOnlySequence`1" /> source.</param>
      <param name="value" vsli:raw="The item to find in the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">L’élément à rechercher dans <see cref="T:System.Buffers.ReadOnlySequence`1" />.</param>
      <typeparam name="T" vsli:raw="The type of the items in the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Type des éléments de <see cref="T:System.Buffers.ReadOnlySequence`1" />.</typeparam>
      <returns vsli:raw="An object whose &lt;see cref=&quot;M:System.SequencePosition.GetInteger&quot; /&gt; method returns the position of the first occurrence of &lt;paramref name=&quot;item&quot; /&gt;, or an object whose &lt;see langword=&quot;Nullable&amp;lt;SequencePosition&amp;gt;.HasValue&quot; /&gt; property is &lt;see langword=&quot;false&quot; /&gt; .">Un objet dont la méthode <see cref="M:System.SequencePosition.GetInteger" /> retourne la position de la première occurrence de <paramref name="item" />, ou un objet dont la propriété <see langword="Nullable&lt;SequencePosition&gt;.HasValue" /> est <see langword="false" /> .</returns>
    </member>
    <member name="M:System.Buffers.BuffersExtensions.ToArray``1(System.Buffers.ReadOnlySequence{``0})">
      <summary vsli:raw="Converts the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; to an array.">Convertit <see cref="T:System.Buffers.ReadOnlySequence`1" /> en tableau.</summary>
      <param name="sequence" vsli:raw="The read-only sequence to convert to an array.">La séquence en lecture seule à convertir en tableau.</param>
      <typeparam name="T" vsli:raw="The type of the items in the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Type des éléments de <see cref="T:System.Buffers.ReadOnlySequence`1" />.</typeparam>
      <returns vsli:raw="An array containing the data in the current read-only sequence.">Tableau contenant les données dans la séquence en lecture seule actuelle.</returns>
    </member>
    <member name="M:System.Buffers.BuffersExtensions.Write``1(System.Buffers.IBufferWriter{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Writes the contents of &lt;paramref name=&quot;value&quot; /&gt; to &lt;paramref name=&quot;writer&quot; /&gt;.">Écrit le contenu de <paramref name="value" /> dans <paramref name="writer" />.</summary>
      <param name="writer" vsli:raw="The buffer writer to which to write &lt;paramref name=&quot;value&quot; /&gt;.">L’enregistreur de la mémoire tampon dans lequel écrire <paramref name="value" />.</param>
      <param name="value" vsli:raw="The read-only span to be written to &lt;paramref name=&quot;writer&quot; /&gt;.">L’étendue en lecture seule à écrire dans <paramref name="writer" />.</param>
      <typeparam name="T" vsli:raw="The type of the items in the &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt;.">Type des éléments de <see cref="T:System.ReadOnlySpan`1" />.</typeparam>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;writer&quot; /&gt; is shorter than &lt;paramref name=&quot;value&quot; /&gt;.">
        <paramref name="writer" /> est plus court que <paramref name="value" />.</exception>
    </member>
    <member name="T:System.Buffers.IBufferWriter`1">
      <summary vsli:raw="Represents an output sink into which &lt;typeparamref name=&quot;T&quot; /&gt; data can be written.">Représente un récepteur de sortie dans lequel des données <typeparamref name="T" /> peuvent être écrites.</summary>
      <typeparam name="T" vsli:raw="The type of the items in the &lt;see cref=&quot;T:System.Buffers.IBufferWriter`1&quot; /&gt;.">Type des éléments de <see cref="T:System.Buffers.IBufferWriter`1" />.</typeparam>
    </member>
    <member name="M:System.Buffers.IBufferWriter`1.Advance(System.Int32)">
      <summary vsli:raw="Notifies the &lt;see cref=&quot;T:System.Buffers.IBufferWriter`1&quot; /&gt; that &lt;paramref name=&quot;count&quot; /&gt; data items were written to the output &lt;see cref=&quot;T:System.Span`1&quot; /&gt; or &lt;see cref=&quot;T:System.Memory`1&quot; /&gt;.">Indique à <see cref="T:System.Buffers.IBufferWriter`1" /> que des éléments de données <paramref name="count" /> ont été écrits dans les sorties <see cref="T:System.Span`1" /> ou <see cref="T:System.Memory`1" />.</summary>
      <param name="count" vsli:raw="The number of data items written to the &lt;see cref=&quot;T:System.Span`1&quot; /&gt; or &lt;see cref=&quot;T:System.Memory`1&quot; /&gt;.">Nombre d'éléments de données écrits dans <see cref="T:System.Span`1" /> ou <see cref="T:System.Memory`1" />.</param>
    </member>
    <member name="M:System.Buffers.IBufferWriter`1.GetMemory(System.Int32)">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Memory`1&quot; /&gt; to write to that is at least the requested size (specified by &lt;paramref name=&quot;sizeHint&quot; /&gt;).">Renvoie un élément <see cref="T:System.Memory`1" /> à écrire d’au moins la taille requise (spécifiée par <paramref name="sizeHint" />).</summary>
      <param name="sizeHint" vsli:raw="The minimum length of the returned &lt;see cref=&quot;T:System.Memory`1&quot; /&gt;. If 0, a non-empty buffer is returned.">La longueur minimale de l’élément <see cref="T:System.Memory`1" /> retourné. Si 0, une mémoire tampon est renvoyé.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Memory`1&quot; /&gt; of at least the size &lt;paramref name=&quot;sizeHint&quot; /&gt;. If &lt;paramref name=&quot;sizeHint&quot; /&gt; is 0, returns a non-empty buffer.">Un élément <see cref="T:System.Memory`1" /> d’au moins <paramref name="sizeHint" />. Si <paramref name="sizeHint" /> est 0, renvoie une mémoire tampon non vide.</returns>
      <exception cref="T:System.OutOfMemoryException" vsli:raw="The requested buffer size is not available.">La mémoire tampon demandée n'est pas disponible.</exception>
    </member>
    <member name="M:System.Buffers.IBufferWriter`1.GetSpan(System.Int32)">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Span`1&quot; /&gt; to write to that is at least the requested size (specified by &lt;paramref name=&quot;sizeHint&quot; /&gt;).">Renvoie un élément <see cref="T:System.Span`1" /> à écrire d’au moins la taille requise (spécifiée par <paramref name="sizeHint" />).</summary>
      <param name="sizeHint" vsli:raw="The minimum length of the returned &lt;see cref=&quot;T:System.Span`1&quot; /&gt;. If 0, a non-empty buffer is returned.">La longueur minimale de l’élément <see cref="T:System.Span`1" /> retourné. Si 0, une mémoire tampon est renvoyé.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Span`1&quot; /&gt; of at least the size &lt;paramref name=&quot;sizeHint&quot; /&gt;. If &lt;paramref name=&quot;sizeHint&quot; /&gt; is 0, returns a non-empty buffer.">Un élément <see cref="T:System.Span`1" /> d’au moins <paramref name="sizeHint" />. Si <paramref name="sizeHint" /> est 0, renvoie une mémoire tampon non vide.</returns>
    </member>
    <member name="T:System.Buffers.MemoryPool`1">
      <summary vsli:raw="Represents a pool of memory blocks.">Représente un pool de blocs de mémoire.</summary>
      <typeparam name="T" vsli:raw="The type of the items in the memory pool.">Type des éléments dans le pool de mémoire.</typeparam>
    </member>
    <member name="M:System.Buffers.MemoryPool`1.#ctor">
      <summary vsli:raw="Constructs a new instance of a memory pool.">Construit une nouvelle instance de pool de mémoire.</summary>
    </member>
    <member name="M:System.Buffers.MemoryPool`1.Dispose">
      <summary vsli:raw="Frees all resources used by the memory pool.">Libère toutes les ressources utilisées par le pool de mémoire.</summary>
    </member>
    <member name="M:System.Buffers.MemoryPool`1.Dispose(System.Boolean)">
      <summary vsli:raw="Frees the unmanaged resources used by the memory pool and optionally releases the managed resources.">Libère les ressources non managées utilisées par le pool de mémoire, et de façon facultative les ressources managées.</summary>
      <param name="disposing" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to release both managed and unmanaged resources; &lt;see langword=&quot;false&quot; /&gt; to release only unmanaged resources.">
        <see langword="true" /> pour libérer les ressources managées et non managées ;  pour libérer uniquement les ressources non managées.</param>
    </member>
    <member name="P:System.Buffers.MemoryPool`1.MaxBufferSize">
      <summary vsli:raw="Gets the maximum buffer size supported by this pool.">Récupère la taille maximale de la mémoire tampon prise en charge par ce pool.</summary>
      <returns vsli:raw="The maximum buffer size supported by this pool.">Taille maximale de la mémoire tampon prise en charge par ce pool.</returns>
    </member>
    <member name="M:System.Buffers.MemoryPool`1.Rent(System.Int32)">
      <summary vsli:raw="Returns a memory block capable of holding at least &lt;paramref name=&quot;minBufferSize&quot; /&gt; elements of T.">Retourne un bloc de mémoire capable de contenir au moins <paramref name="minBufferSize" /> éléments de T.</summary>
      <param name="minBufferSize" vsli:raw="The minimum number of elements of &lt;typeparamref name=&quot;T&quot; /&gt; that the memory pool can hold. A value of -1 returns a memory pool set to the default size for the pool.">Le nombre minimal d’éléments de <typeparamref name="T" /> que peut contenir le pool de mémoire. La valeur -1 retourne un pool de mémoire défini sur la taille par défaut du pool.</param>
      <returns vsli:raw="A memory block capable of holding at least &lt;paramref name=&quot;minBufferSize&quot; /&gt; elements of T.">Un bloc de mémoire capable de contenir au moins <paramref name="minBufferSize" /> éléments de T.</returns>
    </member>
    <member name="P:System.Buffers.MemoryPool`1.Shared">
      <summary vsli:raw="Gets a singleton instance of a memory pool based on arrays.">Récupère une instance singleton d’un pool de mémoire basé sur des tableaux.</summary>
      <returns vsli:raw="A singleton instance of a memory pool.">Instance singleton d’un pool de mémoire.</returns>
    </member>
    <member name="T:System.Buffers.OperationStatus">
      <summary>Définit les valeurs qui peuvent être retournées à partir d’opérations basées sur l’étendue qui prennent en charge le traitement de l’entrée contenue dans plusieurs mémoires tampons non contiguës.</summary>
    </member>
    <member name="F:System.Buffers.OperationStatus.DestinationTooSmall">
      <summary>L’entrée est partiellement traitée, jusqu’à ce qui peut tenir dans la mémoire tampon de destination. L’appelant peut agrandir la mémoire tampon de destination, découper les mémoires tampons de manière appropriée, puis réessayer.</summary>
    </member>
    <member name="F:System.Buffers.OperationStatus.Done">
      <summary>La mémoire tampon d’entrée entière a été traitée et l’opération est terminée.</summary>
    </member>
    <member name="F:System.Buffers.OperationStatus.InvalidData">
      <summary>L’entrée contenait des octets non valides qui n’ont pas pu être traités. Si l’entrée est partiellement traitée, la destination contient le résultat partiel. Cela garantit qu’aucune donnée supplémentaire ajoutée à l’entrée ne rendra valide la séquence non valide.</summary>
    </member>
    <member name="F:System.Buffers.OperationStatus.NeedMoreData">
      <summary>L’entrée est partiellement traitée, jusqu’au dernier segment valide de l’entrée qui a pu être consommé. L’appelant peut assembler l’entrée restante non traitée avec davantage de données, découper les mémoires tampons de manière appropriée, puis réessayer.</summary>
    </member>
    <member name="T:System.Buffers.ReadOnlySequence`1">
      <summary vsli:raw="Represents a sequence that can read a sequential series of &lt;typeparamref name=&quot;T&quot; /&gt;.">Représente une séquence capable de lire une série séquentielle de <typeparamref name="T" />.</summary>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only sequence." />
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(`0[])">
      <summary vsli:raw="Creates an instance of &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; from the &lt;paramref name=&quot;array&quot; /&gt;.">Crée une instance de <see cref="T:System.Buffers.ReadOnlySequence`1" /> à partir de <paramref name="array" />.</summary>
      <param name="array" vsli:raw="The array from which to create a read-only sequence.">Le tableau à partir duquel créer une séquence en lecture seule.</param>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(`0[],System.Int32,System.Int32)">
      <summary vsli:raw="Creates an instance of a &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; from a section of an array.">Crée une instance d’un <see cref="T:System.Buffers.ReadOnlySequence`1" /> à partir d’une section d’un tableau.</summary>
      <param name="array" vsli:raw="The array from which to create the read-only sequence.">Le tableau à partir duquel créer la séquence en lecture seule.</param>
      <param name="start" vsli:raw="The zero-based index of the first element in the array to include in the read-only sequence.">L’index basé sur zéro du premier élément du tableau à inclure dans la séquence en lecture seule.</param>
      <param name="length" vsli:raw="The number of elements to include in the read-only sequence.">Le nombre d’éléments à inclure dans la séquence en lecture seule.</param>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(System.Buffers.ReadOnlySequenceSegment{`0},System.Int32,System.Buffers.ReadOnlySequenceSegment{`0},System.Int32)">
      <summary vsli:raw="Creates an instance of a &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; from a linked memory list represented by start and end segments and the corresponding indexes in them.">Crée une instance d’un <see cref="T:System.Buffers.ReadOnlySequence`1" /> à partir d’une liste de mémoire liée représentée par les segments de début et de fin et les index correspondants.</summary>
      <param name="startSegment" vsli:raw="The initial node of the linked memory list." />
      <param name="startIndex" vsli:raw="The position to the start of the sequence inside &lt;paramref name=&quot;startSegment&quot; /&gt;." />
      <param name="endSegment" vsli:raw="The final node of the linked memory list." />
      <param name="endIndex" vsli:raw="The position to the end of the sequence inside &lt;paramref name=&quot;endSegment&quot; /&gt;." />
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(System.ReadOnlyMemory{`0})">
      <summary vsli:raw="Creates an instance of &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; from a &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt;.">Crée une instance de <see cref="T:System.Buffers.ReadOnlySequence`1" /> à partir de <see cref="T:System.ReadOnlyMemory`1" />.</summary>
      <param name="memory" vsli:raw="A read-only block of memory of elements of type &lt;typeparamref name=&quot;T&quot; /&gt;." />
    </member>
    <member name="F:System.Buffers.ReadOnlySequence`1.Empty">
      <summary vsli:raw="Returns an empty &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Retourne un <see cref="T:System.Buffers.ReadOnlySequence`1" /> vide</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.End">
      <summary vsli:raw="Gets the position at the end of the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Obtient la position à la fin de <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
    </member>
    <member name="T:System.Buffers.ReadOnlySequence`1.Enumerator">
      <summary vsli:raw="Represents an enumerator over a &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Représente un énumérateur sur une <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
      <typeparam name="T" vsli:raw="" />
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Enumerator.#ctor(System.Buffers.ReadOnlySequence{`0}@)">
      <summary vsli:raw="Initializes the enumerator.">Initialise l'énumérateur.</summary>
      <param name="sequence" vsli:raw="The &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; to enumerate.">
        <see cref="T:System.Buffers.ReadOnlySequence`1" /> à énumérer.</param>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.Enumerator.Current">
      <summary vsli:raw="Gets the current &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt;.">Obtient le <see cref="T:System.ReadOnlyMemory`1" /> actuel.</summary>
      <returns vsli:raw="The current &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt;.">
        <see cref="T:System.ReadOnlyMemory`1" /> actuel.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Enumerator.MoveNext">
      <summary vsli:raw="Moves to the next &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt; in the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Passe à la <see cref="T:System.ReadOnlyMemory`1" /> suivante de la <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator successfully advanced to the next item; &lt;see langword=&quot;false&quot; /&gt; if the end of the sequence has been reached.">
        <see langword="true" /> si l’énumérateur a avancé jusqu’à l’élément suivant ; <see langword="false" /> si la fin de la séquence a été atteinte.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.First">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt; from the first segment.">Obtient <see cref="T:System.ReadOnlyMemory`1" /> à partir du premier segment.</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.FirstSpan">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; from the first segment.">Obtient <see cref="T:System.ReadOnlySpan`1" /> à partir du premier segment.</summary>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.GetEnumerator">
      <summary vsli:raw="Returns an enumerator over the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Retourne un énumérateur sur <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
      <returns vsli:raw="Returns an enumerator over the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Retourne un énumérateur sur <see cref="T:System.Buffers.ReadOnlySequence`1" />.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.GetPosition(System.Int64)">
      <summary vsli:raw="Returns a new &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; at an &lt;paramref name=&quot;offset&quot; /&gt; from the start of the sequence.">Retourne un nouvel <see cref="T:System.SequencePosition" /> à un <paramref name="offset" /> à partir du début de la séquence.</summary>
      <param name="offset" vsli:raw="The offset from the start of the sequence." />
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.GetPosition(System.Int64,System.SequencePosition)">
      <summary vsli:raw="Returns a new &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; starting at the specified offset from the &lt;paramref name=&quot;origin&quot; /&gt; position.">Retourne un nouvel <see cref="T:System.SequencePosition" /> à un <paramref name="offset" /> à partir de <paramref name="origin" />.</summary>
      <param name="offset" vsli:raw="The offset from the specified &lt;paramref name=&quot;origin&quot; /&gt; sequence position." />
      <param name="origin" vsli:raw="A sequence position representing the point from which to initiate the offset." />
      <returns vsli:raw="An object representing the sequence position that starts at the &lt;paramref name=&quot;offset&quot; /&gt; position of the specified &lt;paramref name=&quot;origin&quot; /&gt; position object.">Un nouvel objet qui commence à la position <paramref name="offset" /> de l’objet d’origine.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.IsEmpty">
      <summary vsli:raw="Gets a value that indicates whether the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; is empty.">Obtient une valeur qui indique si le <see cref="T:System.Buffers.ReadOnlySequence`1" /> est vide.</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.IsSingleSegment">
      <summary vsli:raw="Gets a value that indicates whether the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; contains a single &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt; segment.">Obtient une valeur qui indique si <see cref="T:System.Buffers.ReadOnlySequence`1" /> contient un segment <see cref="T:System.ReadOnlyMemory`1" /> unique.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the read-only sequence is empty; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />Si la séquence en lecture seule est vide; Sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.Length">
      <summary vsli:raw="Gets the length of the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Obtient la longueur de <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
      <returns vsli:raw="The length of the read-only sequence.">Longueur de la séquence en lecture seule.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int32,System.Int32)">
      <summary vsli:raw="Forms a slice out of the current &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;, beginning at &lt;paramref name=&quot;start&quot; /&gt;, with &lt;paramref name=&quot;length&quot; /&gt; items.">Constitue une section du <see cref="T:System.Buffers.ReadOnlySequence`1" /> actuel, qui commence à l’index <paramref name="start" /> et contient <paramref name="length" /> éléments.</summary>
      <param name="start" vsli:raw="The index at which to begin this slice.">Index auquel commence cette section.</param>
      <param name="length" vsli:raw="The length of the slice.">La longueur de la section.</param>
      <returns vsli:raw="A slice that consists of &lt;paramref name=&quot;length&quot; /&gt; elements from the current instance starting at index &lt;paramref name=&quot;start&quot; /&gt;.">Une section constituée de <paramref name="length" /> éléments à partir de l’instance actuelle commençant à l’index <paramref name="start" />.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int32,System.SequencePosition)">
      <summary vsli:raw="Forms a slice out of the current &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;, beginning at &lt;paramref name=&quot;start&quot; /&gt; and ending at &lt;paramref name=&quot;end&quot; /&gt; (exclusive).">Constitue une section du <see cref="T:System.Buffers.ReadOnlySequence`1" /> actuel, qui commence à l’index <paramref name="start" /> et se termine à la position <paramref name="end" /> (exclue).</summary>
      <param name="start" vsli:raw="The index at which to begin this slice.">Index auquel commence cette section.</param>
      <param name="end" vsli:raw="The end (exclusive) &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; of the slice.">Position <see cref="T:System.SequencePosition" /> de fin (exclue) de la section.</param>
      <returns vsli:raw="A slice that consists of items from the &lt;paramref name=&quot;start&quot; /&gt; index to, but not including, the &lt;paramref name=&quot;end&quot; /&gt; sequence position in the current read-only sequence.">Section constituée des éléments entre l’index <paramref name="start" /> et la position de séquence <paramref name="end" /> (exclue) dans la séquence en lecture seule actuelle.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int64)">
      <summary vsli:raw="Forms a slice out of the current &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;, beginning at a specified index and continuing to the end of the read-only sequence.">Constitue une section du <see cref="T:System.Buffers.ReadOnlySequence`1" /> actuel, entre l’index spécifié et la fin de la séquence en lecture seule.</summary>
      <param name="start" vsli:raw="The start index at which to begin this slice.">Index de début auquel commence cette section.</param>
      <returns vsli:raw="A slice starting at index &lt;paramref name=&quot;start&quot; /&gt; and continuing to the end of the current read-only sequence.">Section entre l’index <paramref name="start" /> et la fin de la séquence en lecture seule actuelle.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int64,System.Int64)">
      <summary vsli:raw="Forms a slice out of the given &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;, beginning at &lt;paramref name=&quot;start&quot; /&gt;, with &lt;paramref name=&quot;length&quot; /&gt; items.">Constitue une section de <see cref="T:System.Buffers.ReadOnlySequence`1" /> donné, en commençant par <paramref name="start" />, avec <paramref name="length" /> éléments.</summary>
      <param name="start" vsli:raw="The index at which to begin this slice.">Index auquel commence cette section.</param>
      <param name="length" vsli:raw="The length of the slice.">La longueur de la section.</param>
      <returns vsli:raw="A slice that consists of &lt;paramref name=&quot;length&quot; /&gt; elements from the current instance starting at index &lt;paramref name=&quot;start&quot; /&gt;.">Une section constituée de <paramref name="length" /> éléments à partir de l’instance actuelle commençant à l’index <paramref name="start" />.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int64,System.SequencePosition)">
      <summary vsli:raw="Forms a slice out of the current &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;, beginning at &lt;paramref name=&quot;start&quot; /&gt; and ending at &lt;paramref name=&quot;end&quot; /&gt; (exclusive).">Constitue une section du <see cref="T:System.Buffers.ReadOnlySequence`1" /> actuel, qui commence à l’index <paramref name="start" /> et se termine à la position <paramref name="end" /> (exclue).</summary>
      <param name="start" vsli:raw="The index at which to begin this slice.">Index auquel commence cette section.</param>
      <param name="end" vsli:raw="The end (exclusive) of the slice.">Position de fin (exclue) de la section.</param>
      <returns vsli:raw="A slice that consists of items from the &lt;paramref name=&quot;start&quot; /&gt; index to, but not including, the &lt;paramref name=&quot;end&quot; /&gt; sequence position in the current read-only sequence.">Section constituée des éléments entre l’index <paramref name="start" /> et la position de séquence <paramref name="end" /> (exclue) dans la séquence en lecture seule actuelle.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition)">
      <summary vsli:raw="Forms a slice out of the current &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;, beginning at a specified sequence position and continuing to the end of the read-only sequence.">Constitue une section du <see cref="T:System.Buffers.ReadOnlySequence`1" /> actuel, entre la position de séquence spécifiée et la fin de la séquence en lecture seule.</summary>
      <param name="start" vsli:raw="The starting (inclusive) &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; at which to begin this slice.">Le <see cref="T:System.SequencePosition" /> de début (inclus) où démarrer cette section.</param>
      <returns vsli:raw="A slice starting at sequence position &lt;paramref name=&quot;start&quot; /&gt; and continuing to the end of the current read-only sequence.">Section entre la position de séquence <paramref name="start" /> et la fin de la séquence en lecture seule actuelle.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition,System.Int32)">
      <summary vsli:raw="Forms a slice out of the current &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;, beginning at &lt;paramref name=&quot;start&quot; /&gt;, with &lt;paramref name=&quot;length&quot; /&gt; items.">Constitue une section du <see cref="T:System.Buffers.ReadOnlySequence`1" /> actuel, qui commence à l’index <paramref name="start" /> et contient <paramref name="length" /> éléments.</summary>
      <param name="start" vsli:raw="The starting (inclusive) &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; at which to begin this slice.">Le <see cref="T:System.SequencePosition" /> de début (inclus) où démarrer cette section.</param>
      <param name="length" vsli:raw="The length of the slice.">La longueur de la section.</param>
      <returns vsli:raw="A slice that consists of &lt;paramref name=&quot;length&quot; /&gt; elements from the current instance starting at sequence position &lt;paramref name=&quot;start&quot; /&gt;.">Section constituée de <paramref name="length" /> éléments de l’instance actuelle commençant à la position de séquence <paramref name="start" />.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition,System.Int64)">
      <summary vsli:raw="Forms a slice out of the current &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;, beginning at &lt;paramref name=&quot;start&quot; /&gt;, with &lt;paramref name=&quot;length&quot; /&gt; items.">Constitue une section du <see cref="T:System.Buffers.ReadOnlySequence`1" /> actuel, qui commence à l’index <paramref name="start" /> et contient <paramref name="length" /> éléments.</summary>
      <param name="start" vsli:raw="The starting (inclusive) &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; at which to begin this slice.">Le <see cref="T:System.SequencePosition" /> de début (inclus) où démarrer cette section.</param>
      <param name="length" vsli:raw="The length of the slice.">La longueur de la section.</param>
      <returns vsli:raw="A slice that consists of &lt;paramref name=&quot;length&quot; /&gt; elements from the current instance starting at sequence position &lt;paramref name=&quot;start&quot; /&gt;.">Section constituée de <paramref name="length" /> éléments de l’instance actuelle commençant à la position de séquence <paramref name="start" />.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition,System.SequencePosition)">
      <summary vsli:raw="Forms a slice out of the current &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;, beginning at &lt;paramref name=&quot;start&quot; /&gt; and ending at &lt;paramref name=&quot;end&quot; /&gt; (exclusive).">Constitue une section du <see cref="T:System.Buffers.ReadOnlySequence`1" /> actuel, qui commence à l’index <paramref name="start" /> et se termine à la position <paramref name="end" /> (exclue).</summary>
      <param name="start" vsli:raw="The starting (inclusive) &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; at which to begin this slice.">Le <see cref="T:System.SequencePosition" /> de début (inclus) où démarrer cette section.</param>
      <param name="end" vsli:raw="The ending (exclusive) &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; of the slice.">Position <see cref="T:System.SequencePosition" /> de fin (exclue) de la section.</param>
      <returns vsli:raw="A slice that consists of items from the &lt;paramref name=&quot;start&quot; /&gt; sequence position to, but not including, the &lt;paramref name=&quot;end&quot; /&gt; sequence position in the current read-only sequence.">Section constituée des éléments entre la position de séquence <paramref name="start" /> et la position de séquence <paramref name="end" /> (exclue) dans la séquence en lecture seule actuelle.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.Start">
      <summary vsli:raw="Gets the position to the start of the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Obtient la position au début de <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.ToString" />
    <member name="M:System.Buffers.ReadOnlySequence`1.TryGet(System.SequencePosition@,System.ReadOnlyMemory{`0}@,System.Boolean)">
      <summary vsli:raw="Tries to retrieve the next segment after &lt;paramref name=&quot;position&quot; /&gt; and returns a value that indicates whether the operation succeeded.">Tente de récupérer le segment suivant après <paramref name="position" /> et retourne une valeur qui indique si l’opération a réussi.</summary>
      <param name="position" vsli:raw="The current sequence position.">La position de séquence actuelle.</param>
      <param name="memory" vsli:raw="A read-only memory span that contains the next segment after &lt;paramref name=&quot;position&quot; /&gt;.">Une étendue de mémoire en lecture seule qui contient le segment suivant après <paramref name="position" />.</param>
      <param name="advance" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;position&quot; /&gt; should to the beginning of next segment; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si <paramref name="position" /> doit être au début du segment suivant ; sinon, <see langword="false" />.</param>
      <returns vsli:raw="Returns &lt;see langword=&quot;true&quot; /&gt; if the method returned the next segment, or &lt;see langword=&quot;false&quot; /&gt; if the end of the read-only sequence was reached.">Retourne <see langword="true" /> si la méthode a retourné le segment suivant, ou <see langword="false" /> si la fin de la séquence en lecture seule a été atteinte.</returns>
    </member>
    <member name="T:System.Buffers.ReadOnlySequenceSegment`1">
      <summary vsli:raw="Represents a linked list of &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt; nodes.">Représente une liste liée de nœuds <see cref="T:System.ReadOnlyMemory`1" />.</summary>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only sequence segment." />
    </member>
    <member name="M:System.Buffers.ReadOnlySequenceSegment`1.#ctor" />
    <member name="P:System.Buffers.ReadOnlySequenceSegment`1.Memory">
      <summary vsli:raw="Gets or sets a &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt; value for the current node.">Récupère ou définit une valeur <see cref="T:System.ReadOnlyMemory`1" /> pour le nœud actuel.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt; value for the current node.">
        <see cref="T:System.ReadOnlyMemory`1" /> Valeur pour le nœud actuel.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequenceSegment`1.Next">
      <summary vsli:raw="Gets or sets the next node.">Récupère ou définit le nœud suivant.</summary>
      <returns vsli:raw="The next node.">Nœud suivant.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequenceSegment`1.RunningIndex">
      <summary vsli:raw="Gets or sets the sum of node lengths before the current node.">Récupère ou définit la somme des longueurs de nœud avant le nœud actuel.</summary>
      <returns vsli:raw="The sum of node lengths before the current node.">Somme des longueurs de nœuds avant le nœud actuel.</returns>
    </member>
    <member name="T:System.Buffers.SequenceReader`1">
      <summary vsli:raw="Provides methods for reading binary and text data out of a &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; with a focus on performance and minimal or zero heap allocations.">Fournit des méthodes de lecture de données binaires et texte à partir d’un <see cref="T:System.Buffers.ReadOnlySequence`1" /> en ciblant les performances et les allocations de tas minimales ou égales à zéro.</summary>
      <typeparam name="T" vsli:raw="The type of the read-only sequence.">Type de la séquence en lecture seule.</typeparam>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.#ctor(System.Buffers.ReadOnlySequence{`0})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Buffers.SequenceReader`1&quot; /&gt; over a given &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Crée un <see cref="T:System.Buffers.SequenceReader`1" /> sur une <see cref="T:System.Buffers.ReadOnlySequence`1" /> donnée.</summary>
      <param name="sequence" vsli:raw="The read-only sequence over which to create the &lt;see cref=&quot;T:System.Buffers.SequenceReader`1&quot; /&gt;.">Séquence en lecture seule sur laquelle créer <see cref="T:System.Buffers.SequenceReader`1" />.</param>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.Advance(System.Int64)">
      <summary vsli:raw="Moves the reader ahead a specified number of items.">Déplace le lecteur vers l’avant, d’un nombre d’éléments spécifié.</summary>
      <param name="count" vsli:raw="The number of items to advance.">Nombre d’éléments à avancer.</param>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePast(`0)">
      <summary vsli:raw="Advances past consecutive instances of the given &lt;paramref name=&quot;value&quot; /&gt;.">Avance jusqu’après des instances consécutives de <paramref name="value" />.</summary>
      <param name="value" vsli:raw="The value past which the reader is to advance.">Valeur après laquelle le lecteur doit avancer.</param>
      <returns vsli:raw="The number of positions the reader has advanced.">Nombre de positions dont le lecteur a avancé.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(`0,`0)">
      <summary vsli:raw="Advances past consecutive instances of either of two specified values.">Avance jusqu’après des instances consécutives de l’une ou l’autre de deux valeurs spécifiées.</summary>
      <param name="value0" vsli:raw="The first value to skip.">Première valeur à ignorer.</param>
      <param name="value1" vsli:raw="The second value to skip.">Deuxième valeur à ignorer.</param>
      <returns vsli:raw="The number of positions the reader has advanced.">Nombre de positions dont le lecteur a avancé.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(`0,`0,`0)">
      <summary vsli:raw="Advances past consecutive instances of any of three specified values.">Avance jusqu’après des instances consécutives de l’une des trois valeurs spécifiées.</summary>
      <param name="value0" vsli:raw="The first value to skip.">Première valeur à ignorer.</param>
      <param name="value1" vsli:raw="The second value to skip.">Deuxième valeur à ignorer.</param>
      <param name="value2" vsli:raw="The third value to skip.">Troisième valeur à ignorer.</param>
      <returns vsli:raw="The number of positions the reader has advanced.">Nombre de positions dont le lecteur a avancé.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(`0,`0,`0,`0)">
      <summary vsli:raw="Advances past consecutive instances of any of four specified values.">Avance jusqu’après des instances consécutives de l’une des quatre valeurs spécifiées.</summary>
      <param name="value0" vsli:raw="The first value to skip.">Première valeur à ignorer.</param>
      <param name="value1" vsli:raw="The second value to skip.">Deuxième valeur à ignorer.</param>
      <param name="value2" vsli:raw="The third value to skip.">Troisième valeur à ignorer.</param>
      <param name="value3" vsli:raw="The fourth value to skip.">Quatrième valeur à ignorer.</param>
      <returns vsli:raw="The number of positions the reader has advanced.">Nombre de positions dont le lecteur a avancé.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(System.ReadOnlySpan{`0})">
      <summary vsli:raw="Skips consecutive instances of any of the specified &lt;paramref name=&quot;values&quot; /&gt;.">Ignore les instances consécutives des <paramref name="values" /> spécifiés.</summary>
      <param name="values" vsli:raw="The values to be skipped.">Valeurs à ignorer.</param>
      <returns vsli:raw="The number of positions the reader has advanced.">Nombre de positions dont le lecteur a avancé.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Consumed">
      <summary vsli:raw="Gets the total number of &lt;typeparamref name=&quot;T&quot; /&gt; values processed by the reader.">Obtient le nombre total de valeurs <typeparamref name="T" /> traitées par le lecteur.</summary>
      <returns vsli:raw="The total number of values processed by the reader.">Nombre total de valeurs traitées par le lecteur.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.CurrentSpan">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Span`1&quot; /&gt; that contains the current segment in the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;.">Obtient un <see cref="T:System.Span`1" /> qui contient le segment actuel dans <see cref="P:System.Buffers.SequenceReader`1.Sequence" />.</summary>
      <returns vsli:raw="A span that contains the current segment in the sequence.">Étendue qui contient le segment actuel dans la séquence.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.CurrentSpanIndex">
      <summary vsli:raw="Gets the index in the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.CurrentSpan&quot; /&gt;.">Obtient l’index dans <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" />.</summary>
      <returns vsli:raw="The index in the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.CurrentSpan&quot; /&gt;.">Index dans le <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" />.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.End">
      <summary vsli:raw="Gets a value that indicates whether there is no more data in the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;.">Obtient une valeur qui indique s’il n’y a plus de données dans <see cref="P:System.Buffers.SequenceReader`1.Sequence" />.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; when there is no more data in the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />lorsqu’il n’y a plus de données <see cref="P:System.Buffers.SequenceReader`1.Sequence" />dans; sinon <see langword="false" />,.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.IsNext(`0,System.Boolean)">
      <summary vsli:raw="Checks whether a specified value is next in the sequence.">Vérifie si une valeur spécifiée suit dans la séquence.</summary>
      <param name="next" vsli:raw="The value to compare the next items to.">Valeur à laquelle comparer les éléments suivants.</param>
      <param name="advancePast" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the &lt;paramref name=&quot;next&quot; /&gt; values if they are found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> pour se déplacer après les valeurs <paramref name="next" /> si elles sont trouvées ; sinon, <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the values are next in sequence; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si les valeurs sont les prochaines dans la séquence ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.IsNext(System.ReadOnlySpan{`0},System.Boolean)">
      <summary vsli:raw="Checks whether the values specified in a read-only span are next in the sequence.">Vérifie si les valeurs spécifiées dans une plage en lecture seule suivent dans la séquence.</summary>
      <param name="next" vsli:raw="The span to compare the next items to.">Plage à laquelle comparer les éléments suivants.</param>
      <param name="advancePast" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the &lt;paramref name=&quot;next&quot; /&gt; values if they are found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> pour se déplacer après les valeurs <paramref name="next" /> si elles sont trouvées ; sinon, <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the values are next in sequence; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si les valeurs sont les prochaines dans la séquence ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Length">
      <summary vsli:raw="Gets the count of items in the reader's &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;.">Obtient le nombre d’éléments dans la <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> du lecteur.</summary>
      <returns vsli:raw="The count of items in the reader's &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;.">Nombre d’éléments dans le du <see cref="P:System.Buffers.SequenceReader`1.Sequence" />lecteur.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Position">
      <summary vsli:raw="Gets the current position in the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;.">Obtient la position actuelle dans <see cref="P:System.Buffers.SequenceReader`1.Sequence" />.</summary>
      <returns vsli:raw="The current position in the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;.">Position actuelle dans le <see cref="P:System.Buffers.SequenceReader`1.Sequence" />.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Remaining">
      <summary vsli:raw="Gets  the remaining items in the reader's &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;.">Obtient les éléments restants dans la <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> du lecteur.</summary>
      <returns vsli:raw="The remaining items in the reader's &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;">Les éléments restants dans le lecteur<see cref="P:System.Buffers.SequenceReader`1.Sequence" /></returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.Rewind(System.Int64)">
      <summary vsli:raw="Moves the reader back the specified number of items.">Déplace le lecteur vers l’arrière, du nombre d’éléments spécifié.</summary>
      <param name="count" vsli:raw="The number of items.">Nombre d'éléments.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;count&quot; /&gt; is negative or greater than &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Consumed&quot; /&gt;.">
        <paramref name="count" /> est négatif ou supérieur à <see cref="P:System.Buffers.SequenceReader`1.Consumed" />.</exception>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Sequence">
      <summary vsli:raw="Gets the underlying &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; for the reader.">Obtient la <see cref="T:System.Buffers.ReadOnlySequence`1" /> sous-jacente pour le lecteur.</summary>
      <returns vsli:raw="The underlying read-only sequence for the reader.">Séquence en lecture seule sous-jacente pour le lecteur.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryAdvanceTo(`0,System.Boolean)">
      <summary vsli:raw="Searches for a specified delimiter and optionally advances past it if it is found.">Recherche un délimiteur spécifié et avance (facultatif) jusqu’après celui-ci s’il est trouvé.</summary>
      <param name="delimiter" vsli:raw="The delimiter to search for.">Délimiteur à rechercher.</param>
      <param name="advancePastDelimiter" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the &lt;paramref name=&quot;delimiter&quot; /&gt; if it is found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> pour se déplacer après le <paramref name="delimiter" /> s’il est trouvé ; sinon, <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the given &lt;paramref name=&quot;delimiter&quot; /&gt; was found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si le <paramref name="delimiter" /> donné est trouvé ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryAdvanceToAny(System.ReadOnlySpan{`0},System.Boolean)">
      <summary vsli:raw="Searches for any of a number of specified delimiters and optionally advances past the first one to be found.">Recherche un des délimiteurs spécifiés et avance (facultatif) jusqu’après le premier de ces délimiteurs trouvé.</summary>
      <param name="delimiters" vsli:raw="The delimiters to search for.">Les délimiteurs à rechercher.</param>
      <param name="advancePastDelimiter" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the first instance of any of the given &lt;paramref name=&quot;delimiters&quot; /&gt;; &lt;see langword=&quot;false&quot; /&gt; to not move past the delimiter.">
        <see langword="true" /> pour se déplacer après la première instance d’un des <paramref name="delimiters" /> donnés ;  pour ne pas se déplacer après le délimiteur.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if any of the given &lt;paramref name=&quot;delimiters&quot; /&gt; was found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si un des <paramref name="delimiters" /> donnés a été trouvé ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryCopyTo(System.Span{`0})">
      <summary vsli:raw="Copies data from the current position to the given destination span if there is enough data to fill it.">Copie des données à partir de la position actuelle vers la plage de destination donnée s’il y a suffisamment de données pour la remplir.</summary>
      <param name="destination" vsli:raw="Destination span to copy to.">Plage de destination dans laquelle copier.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if there is enough data to completely fill the &lt;paramref name=&quot;destination&quot; /&gt; span; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> s’il y a suffisamment de données pour remplir complètement la plage <paramref name="destination" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryPeek(`0@)">
      <summary vsli:raw="Peeks at the next value without advancing the reader.">Donne un aperçu de la valeur suivante sans avancer le lecteur.</summary>
      <param name="value" vsli:raw="The next value, or the default value if at the end of the reader.">La valeur suivante, ou la valeur par défaut si la position correspond à la fin du lecteur.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the reader is not at its end and the peek operation succeeded; &lt;see langword=&quot;false&quot; /&gt; if at the end of the reader.">
        <see langword="true" /> si le lecteur n’est pas à la fin et que l’opération d’aperçu a réussi ; <see langword="false" /> si la position correspond à la fin du lecteur.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryRead(`0@)">
      <summary vsli:raw="Reads the next value and advance the reader.">Lit la valeur suivante et avance le lecteur.</summary>
      <param name="value" vsli:raw="The next value, or the default value if at the end of the reader.">La valeur suivante, ou la valeur par défaut si la position correspond à la fin du lecteur.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the reader is not at its end and the read operation succeeded; &lt;see langword=&quot;false&quot; /&gt; if at the end of the reader.">
        <see langword="true" /> si le lecteur n’est pas à la fin et que l’opération de lecture a réussi ; <see langword="false" /> si la position correspond à la fin du lecteur.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.Buffers.ReadOnlySequence{`0}@,`0,`0,System.Boolean)">
      <summary vsli:raw="Tries to read everything up to the given &lt;paramref name=&quot;delimiter&quot; /&gt;, ignoring delimiters that are preceded by &lt;paramref name=&quot;delimiterEscape&quot; /&gt;.">Tente de tout lire jusqu’au <paramref name="delimiter" />, en ignorant les délimiteurs précédés de <paramref name="delimiterEscape" />.</summary>
      <param name="sequence" vsli:raw="When the method returns, contains the data read, if any.">Quand la méthode retourne, contient les données lues, le cas échéant.</param>
      <param name="delimiter" vsli:raw="The delimiter to look for.">Délimiteur à rechercher.</param>
      <param name="delimiterEscape" vsli:raw="A value that indicates that an immediately following &lt;paramref name=&quot;delimiter&quot; /&gt; is to be skipped.">Valeur indiquant qu’un <paramref name="delimiter" /> qui suit immédiatement doit être ignoré.</param>
      <param name="advancePastDelimiter" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the &lt;paramref name=&quot;delimiter&quot; /&gt; if found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> pour se déplacer après le <paramref name="delimiter" /> s’il est trouvé ; sinon, <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;paramref name=&quot;delimiter&quot; /&gt; was found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si le <paramref name="delimiter" /> a été trouvé ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.Buffers.ReadOnlySequence{`0}@,`0,System.Boolean)">
      <summary vsli:raw="Tries to read everything up to the given &lt;paramref name=&quot;delimiter&quot; /&gt;.">Tente de tout lire jusqu’au <paramref name="delimiter" />.</summary>
      <param name="sequence" vsli:raw="When the method returns, contains the data read, if any.">Quand la méthode retourne, contient les données lues, le cas échéant.</param>
      <param name="delimiter" vsli:raw="The delimiter to look for.">Délimiteur à rechercher.</param>
      <param name="advancePastDelimiter" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the &lt;paramref name=&quot;delimiter&quot; /&gt; if found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> pour se déplacer après le <paramref name="delimiter" /> s’il est trouvé ; sinon, <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;paramref name=&quot;delimiter&quot; /&gt; was found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si le <paramref name="delimiter" /> a été trouvé ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.Buffers.ReadOnlySequence{`0}@,System.ReadOnlySpan{`0},System.Boolean)">
      <summary vsli:raw="Tries to read data until the entire delimiter specified as a read-only span matches.">Tente de lire les données jusqu’à ce que le délimiteur entier spécifié comme plage en lecture seule soit rencontré.</summary>
      <param name="sequence" vsli:raw="When the method returns, contains the data read, if any.">Quand la méthode retourne, contient les données lues, le cas échéant.</param>
      <param name="delimiter" vsli:raw="A read-only span that contains one or more delimiters.">Plage en lecture seule qui contient un ou plusieurs délimiteurs.</param>
      <param name="advancePastDelimiter" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the &lt;paramref name=&quot;delimiter&quot; /&gt; if found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> pour se déplacer après le <paramref name="delimiter" /> s’il est trouvé ; sinon, <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;paramref name=&quot;delimiter&quot; /&gt; was found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si le <paramref name="delimiter" /> a été trouvé ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.ReadOnlySpan{`0}@,`0,`0,System.Boolean)">
      <summary vsli:raw="Tries to read everything up to the given &lt;paramref name=&quot;delimiter&quot; /&gt;, ignoring delimiters that are preceded by &lt;paramref name=&quot;delimiterEscape&quot; /&gt;.">Tente de tout lire jusqu’au <paramref name="delimiter" />, en ignorant les délimiteurs précédés de <paramref name="delimiterEscape" />.</summary>
      <param name="span" vsli:raw="When the method returns, contains the data read, if any.">Quand la méthode retourne, contient les données lues, le cas échéant.</param>
      <param name="delimiter" vsli:raw="The delimiter to look for.">Délimiteur à rechercher.</param>
      <param name="delimiterEscape" vsli:raw="A value that indicates that an immediately following &lt;paramref name=&quot;delimiter&quot; /&gt; is to be skipped.">Valeur indiquant qu’un <paramref name="delimiter" /> qui suit immédiatement doit être ignoré.</param>
      <param name="advancePastDelimiter" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the &lt;paramref name=&quot;delimiter&quot; /&gt; if found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> pour se déplacer après le <paramref name="delimiter" /> s’il est trouvé ; sinon, <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;paramref name=&quot;delimiter&quot; /&gt; was found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si le <paramref name="delimiter" /> a été trouvé ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.ReadOnlySpan{`0}@,`0,System.Boolean)">
      <summary vsli:raw="Tries to read everything up to the given &lt;paramref name=&quot;delimiter&quot; /&gt;.">Tente de tout lire jusqu’au <paramref name="delimiter" />.</summary>
      <param name="span" vsli:raw="When the method returns, contains the data read, if any.">Quand la méthode retourne, contient les données lues, le cas échéant.</param>
      <param name="delimiter" vsli:raw="The delimiter to look for.">Délimiteur à rechercher.</param>
      <param name="advancePastDelimiter" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the &lt;paramref name=&quot;delimiter&quot; /&gt; if found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> pour se déplacer après le <paramref name="delimiter" /> s’il est trouvé ; sinon, <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;paramref name=&quot;delimiter&quot; /&gt; was found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si le <paramref name="delimiter" /> a été trouvé ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadToAny(System.Buffers.ReadOnlySequence{`0}@,System.ReadOnlySpan{`0},System.Boolean)">
      <summary vsli:raw="Tries to read everything up to any of the specified &lt;paramref name=&quot;delimiters&quot; /&gt;.">Tente de tout lire jusqu’à un des <paramref name="delimiters" /> spécifiés.</summary>
      <param name="sequence" vsli:raw="When the method returns, contains the data read, if any.">Quand la méthode retourne, contient les données lues, le cas échéant.</param>
      <param name="delimiters" vsli:raw="The delimiters to look for.">Délimiteurs à rechercher.</param>
      <param name="advancePastDelimiter" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the first found instance of any of the given &lt;paramref name=&quot;delimiters&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> pour se déplacer après la première instance trouvée d’un des <paramref name="delimiters" /> donnés ; sinon, <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if any of the &lt;paramref name=&quot;delimiters&quot; /&gt; were found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si un des <paramref name="delimiters" /> a été trouvé ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadToAny(System.ReadOnlySpan{`0}@,System.ReadOnlySpan{`0},System.Boolean)">
      <summary vsli:raw="Tries to read everything up to any of the specified &lt;paramref name=&quot;delimiters&quot; /&gt;.">Tente de tout lire jusqu’à un des <paramref name="delimiters" /> spécifiés.</summary>
      <param name="span" vsli:raw="When the method returns, contains the data read, if any.">Quand la méthode retourne, contient les données lues, le cas échéant.</param>
      <param name="delimiters" vsli:raw="The delimiters to look for.">Délimiteurs à rechercher.</param>
      <param name="advancePastDelimiter" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the first found instance of any of the given &lt;paramref name=&quot;delimiters&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> pour se déplacer après la première instance trouvée d’un des <paramref name="delimiters" /> donnés ; sinon, <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if any of the &lt;paramref name=&quot;delimiters&quot; /&gt; were found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si un des <paramref name="delimiters" /> a été trouvé ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.UnreadSpan">
      <summary vsli:raw="Gets the unread portion of the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.CurrentSpan&quot; /&gt;.">Obtient la partie non lue de <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" />.</summary>
      <returns vsli:raw="The unread portion of the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.CurrentSpan&quot; /&gt;.">Partie non lue de <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" />.</returns>
    </member>
    <member name="T:System.Buffers.SequenceReaderExtensions">
      <summary vsli:raw="Provides extended functionality for the &lt;see cref=&quot;T:System.Buffers.SequenceReader`1&quot; /&gt; class that allows reading of endian specific numeric values from binary data.">Fournit des fonctionnalités étendues pour la classe <see cref="T:System.Buffers.SequenceReader`1" /> qui permet de lire des valeurs numériques spécifiques à endian à partir de données binaires.</summary>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadBigEndian(System.Buffers.SequenceReader{System.Byte},System.Int16@)">
      <summary vsli:raw="Tries to read an &lt;see cref=&quot;T:System.Int16&quot; /&gt; as big endian.">Tente de lire un <see cref="T:System.Int16" /> avec primauté des octets de poids fort (big-endian).</summary>
      <param name="reader" vsli:raw="The byte sequence reader instance from which the value is to be read.">Instance de lecteur de séquence d’octets à partir de laquelle la valeur doit être lue.</param>
      <param name="value" vsli:raw="When the method returns, the value read out of the byte sequence reader, as big endian.">Lorsque la méthode est retournée, valeur lue dans le lecteur de séquence d’octets, avec primauté des octets de poids fort (big-endian).</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the read operation is successful; &lt;see langword=&quot;false&quot; /&gt; if there isn't enough data for an &lt;see cref=&quot;T:System.Int16&quot; /&gt;.">
        <see langword="true" /> si l’opération de lecture réussit ; <see langword="false" /> s’il n’y pas suffisamment de données pour un <see cref="T:System.Int16" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadBigEndian(System.Buffers.SequenceReader{System.Byte},System.Int32@)">
      <summary vsli:raw="Tries to read an &lt;see cref=&quot;T:System.Int32&quot; /&gt; as big endian.">Tente de lire un <see cref="T:System.Int32" /> avec primauté des octets de poids fort (big-endian).</summary>
      <param name="reader" vsli:raw="The byte sequence reader from which to read the value.">Lecteur de séquence d’octets à partir duquel la valeur doit être lue.</param>
      <param name="value" vsli:raw="When the method returns, the value read out of the byte sequence reader, as big endian.">Lorsque la méthode est retournée, valeur lue dans le lecteur de séquence d’octets, avec primauté des octets de poids fort (big-endian).</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the read operation is successful; &lt;see langword=&quot;false&quot; /&gt; if there isn't enough data for an &lt;see cref=&quot;T:System.Int32&quot; /&gt;.">
        <see langword="true" /> si l’opération de lecture réussit ; <see langword="false" /> s’il n’y pas suffisamment de données pour un <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadBigEndian(System.Buffers.SequenceReader{System.Byte},System.Int64@)">
      <summary vsli:raw="Tries to read an &lt;see cref=&quot;T:System.Int64&quot; /&gt; as big endian.">Tente de lire un <see cref="T:System.Int64" /> avec primauté des octets de poids fort (big-endian).</summary>
      <param name="reader" vsli:raw="The byte sequence reader instance from which the value is to be read.">Instance de lecteur de séquence d’octets à partir de laquelle la valeur doit être lue.</param>
      <param name="value" vsli:raw="When the method returns, the value read out of the byte sequence reader, as big endian.">Lorsque la méthode est retournée, valeur lue dans le lecteur de séquence d’octets, avec primauté des octets de poids fort (big-endian).</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the read operation is successful; &lt;see langword=&quot;false&quot; /&gt; if there isn't enough data for an &lt;see cref=&quot;T:System.Int64&quot; /&gt;.">
        <see langword="true" /> si l’opération de lecture réussit ; <see langword="false" /> s’il n’y pas suffisamment de données pour un <see cref="T:System.Int64" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadLittleEndian(System.Buffers.SequenceReader{System.Byte},System.Int16@)">
      <summary vsli:raw="Tries to read an &lt;see cref=&quot;T:System.Int16&quot; /&gt; as little endian.">Tente de lire un <see cref="T:System.Int16" /> en mode Little Endian.</summary>
      <param name="reader" vsli:raw="The byte sequence reader instance from which the value is to be read.">Instance de lecteur de séquence d’octets à partir de laquelle la valeur doit être lue.</param>
      <param name="value" vsli:raw="When the method returns, the value read out of the byte sequence reader, as little endian.">Lorsque la méthode est retournée, valeur lue dans le lecteur de séquence d’octets, en mode Little Endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the read operation is successful; &lt;see langword=&quot;false&quot; /&gt; if there isn't enough data for an &lt;see cref=&quot;T:System.Int16&quot; /&gt;.">
        <see langword="true" /> si l’opération de lecture réussit ; <see langword="false" /> s’il n’y pas suffisamment de données pour un <see cref="T:System.Int16" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadLittleEndian(System.Buffers.SequenceReader{System.Byte},System.Int32@)">
      <summary vsli:raw="Tries to read an &lt;see cref=&quot;T:System.Int32&quot; /&gt; as little endian.">Tente de lire un <see cref="T:System.Int32" /> en mode Little Endian.</summary>
      <param name="reader" vsli:raw="The byte sequence reader instance from which the value is to be read.">Instance de lecteur de séquence d’octets à partir de laquelle la valeur doit être lue.</param>
      <param name="value" vsli:raw="When the method returns, the value read out of the byte sequence reader, as little endian.">Lorsque la méthode est retournée, valeur lue dans le lecteur de séquence d’octets, en mode Little Endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the read operation is successful; &lt;see langword=&quot;false&quot; /&gt; if there isn't enough data for an &lt;see cref=&quot;T:System.Int32&quot; /&gt;.">
        <see langword="true" /> si l’opération de lecture réussit ; <see langword="false" /> s’il n’y pas suffisamment de données pour un <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadLittleEndian(System.Buffers.SequenceReader{System.Byte},System.Int64@)">
      <summary vsli:raw="Tries to read an &lt;see cref=&quot;T:System.Int64&quot; /&gt; as little endian.">Tente de lire un <see cref="T:System.Int64" /> en mode Little Endian.</summary>
      <param name="reader" vsli:raw="The byte sequence reader instance from which the value is to be read.">Instance de lecteur de séquence d’octets à partir de laquelle la valeur doit être lue.</param>
      <param name="value" vsli:raw="When the method returns, the value read out of the byte sequence reader, as little endian.">Lorsque la méthode est retournée, valeur lue dans le lecteur de séquence d’octets, en mode Little Endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the read operation is successful; &lt;see langword=&quot;false&quot; /&gt; if there isn't enough data for an &lt;see cref=&quot;T:System.Int64&quot; /&gt;.">
        <see langword="true" /> si l’opération de lecture réussit ; <see langword="false" /> s’il n’y pas suffisamment de données pour un <see cref="T:System.Int64" />.</returns>
    </member>
    <member name="T:System.Buffers.StandardFormat">
      <summary vsli:raw="Represents a standard format string without using an actual string.">Représente une chaîne de format standard sans utiliser une chaîne réelle.</summary>
    </member>
    <member name="M:System.Buffers.StandardFormat.#ctor(System.Char,System.Byte)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; structure.">Initialise une nouvelle instance de la structure <see cref="T:System.Buffers.StandardFormat" />.</summary>
      <param name="symbol" vsli:raw="A type-specific format specifier, such as 'G', 'D', or 'X'.">Un spécificateur de format de type spécifique, comme « G », « D » ou « X ».</param>
      <param name="precision" vsli:raw="An optional precision ranging from 0 to 99, or the special value &lt;see cref=&quot;F:System.Buffers.StandardFormat.NoPrecision&quot; /&gt; (the default).">Précision facultative comprise entre 0 et 99, ou la valeur spéciale <see cref="F:System.Buffers.StandardFormat.NoPrecision" /> (valeur par défaut).</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;symbol&quot; /&gt; is not &lt;see cref=&quot;F:System.Buffers.StandardFormat.NoPrecision&quot; /&gt;, and its value is greater than &lt;see cref=&quot;F:System.Buffers.StandardFormat.MaxPrecision&quot; /&gt;.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;symbol&quot; /&gt; cannot be converted to a &lt;see cref=&quot;T:System.Byte&quot; /&gt;.">
        <paramref name="symbol" /> n’est pas <see cref="F:System.Buffers.StandardFormat.NoPrecision" /> et sa valeur est supérieure à <see cref="F:System.Buffers.StandardFormat.MaxPrecision" />.

ou -

<paramref name="symbol" /> ne peut pas être converti en objet <see cref="T:System.Byte" />.</exception>
    </member>
    <member name="M:System.Buffers.StandardFormat.Equals(System.Buffers.StandardFormat)">
      <summary vsli:raw="Returns a value that indicates whether the specified &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; is equal to the current instance.">Retourne une valeur qui indique si le <see cref="T:System.Buffers.StandardFormat" /> spécifié est égal à l’instance actuelle.</summary>
      <param name="other" vsli:raw="The format to compare to the current instance.">Format à comparer à l’instance actuelle.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two instances are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si les deux instances sont égales ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.Equals(System.Object)">
      <summary vsli:raw="Returns a value that indicates whether the specified object is a &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; object that is equal to the current instance.">Retourne une valeur qui indique si l’objet spécifié est un objet <see cref="T:System.Buffers.StandardFormat" /> égal à l’instance actuelle.</summary>
      <param name="obj" vsli:raw="An object to compare to the current instance.">Objet à comparer à l’instance actuelle.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two instances are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si les deux instances sont égales ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.GetHashCode">
      <summary vsli:raw="Returns the hash code for this instance.">Retourne le code de hachage de cette instance.</summary>
      <returns vsli:raw="The hash code for this instance.">Code de hachage de cette instance.</returns>
    </member>
    <member name="P:System.Buffers.StandardFormat.HasPrecision">
      <summary vsli:raw="Gets a value that indicates whether a format has a defined precision.">Obtient une valeur qui indique si un format a une précision définie.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the format has a precision other than &lt;see cref=&quot;F:System.Buffers.StandardFormat.NoPrecision&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />Si le format a une précision autre que <see cref="F:System.Buffers.StandardFormat.NoPrecision" />; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Buffers.StandardFormat.IsDefault">
      <summary vsli:raw="Gets a value that indicates whether the current instance is a default format.">Obtient une valeur qui indique si l'instance actuelle est un format par défaut.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current instance is a default format; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />Si l’instance actuelle est un format par défaut; Sinon, <see langword="false" />.</returns>
    </member>
    <member name="F:System.Buffers.StandardFormat.MaxPrecision">
      <summary vsli:raw="Defines the maximum valid precision value.">Définit la valeur maximale de précision valide.</summary>
    </member>
    <member name="F:System.Buffers.StandardFormat.NoPrecision">
      <summary vsli:raw="Indicates that a format doesn't use a precision or that the precision is unspecified.">Indique qu’un format n’utilise pas de précision ou que la précision n’est pas spécifiée.</summary>
    </member>
    <member name="M:System.Buffers.StandardFormat.op_Equality(System.Buffers.StandardFormat,System.Buffers.StandardFormat)">
      <summary vsli:raw="Returns a value that indicates whether two &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; instances are equal.">Retourne une valeur qui indique si deux instances de <see cref="T:System.Buffers.StandardFormat" /> sont égales.</summary>
      <param name="left" vsli:raw="The first format to compare.">Premier format à comparer.</param>
      <param name="right" vsli:raw="The second format to compare.">Second format à comparer.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two instances are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si les deux instances sont égales ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.op_Implicit(System.Char)~System.Buffers.StandardFormat">
      <summary vsli:raw="Converts a character to a &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; instance using &lt;see cref=&quot;F:System.Buffers.StandardFormat.NoPrecision&quot; /&gt; precision.">Convertit un caractère en une instance <see cref="T:System.Buffers.StandardFormat" /> à l’aide de la précision <see cref="F:System.Buffers.StandardFormat.NoPrecision" />.</summary>
      <param name="symbol" vsli:raw="The character to convert to a &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; value.">Caractère à convertir en valeur <see cref="T:System.Buffers.StandardFormat" />.</param>
      <returns vsli:raw="A format with a &lt;see cref=&quot;P:System.Buffers.StandardFormat.Symbol&quot; /&gt; property equal to &lt;paramref name=&quot;symbol&quot; /&gt; and a &lt;see cref=&quot;P:System.Buffers.StandardFormat.Precision&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Buffers.StandardFormat.NoPrecision&quot; /&gt;.">Format avec une propriété <see cref="P:System.Buffers.StandardFormat.Symbol" /> égale à <paramref name="symbol" /> et une propriété <see cref="P:System.Buffers.StandardFormat.Precision" /> égale à <see cref="F:System.Buffers.StandardFormat.NoPrecision" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.op_Inequality(System.Buffers.StandardFormat,System.Buffers.StandardFormat)">
      <summary vsli:raw="Determines whether two &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; instances are unequal.">Détermine si deux instances de <see cref="T:System.Buffers.StandardFormat" /> sont inégales.</summary>
      <param name="left" vsli:raw="The first format to compare.">Premier format à comparer.</param>
      <param name="right" vsli:raw="The second format to compare.">Second format à comparer.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two formats are unequal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si les deux formats sont inégaux ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.Parse(System.ReadOnlySpan{System.Char})">
      <summary vsli:raw="Converts a &lt;see langword=&quot;ReadOnlySpan&amp;lt;System.Char&amp;gt;&quot; /&gt; into a &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; instance using &lt;see cref=&quot;F:System.Buffers.StandardFormat.NoPrecision&quot; /&gt; precision.">Convertit un <see langword="ReadOnlySpan&lt;System.Char&gt;" /> en une instance <see cref="T:System.Buffers.StandardFormat" /> à l’aide de la précision <see cref="F:System.Buffers.StandardFormat.NoPrecision" />.</summary>
      <param name="format" vsli:raw="A read-only span that contains the character to parse.">Étendue en lecture seule qui contient le caractère à analyser.</param>
      <returns vsli:raw="A value whose &lt;see cref=&quot;P:System.Buffers.StandardFormat.Symbol&quot; /&gt; property value is the character in &lt;paramref name=&quot;format&quot; /&gt; and whose &lt;see cref=&quot;P:System.Buffers.StandardFormat.Precision&quot; /&gt; property value is &lt;see cref=&quot;F:System.Buffers.StandardFormat.NoPrecision&quot; /&gt;.">Valeur dont la valeur de propriété <see cref="P:System.Buffers.StandardFormat.Symbol" /> est le caractère dans <paramref name="format" /> et dont la valeur de propriété <see cref="P:System.Buffers.StandardFormat.Precision" /> est <see cref="F:System.Buffers.StandardFormat.NoPrecision" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.Parse(System.String)">
      <summary vsli:raw="Converts a classic .NET standard format string to a &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; instance.">Convertit une chaîne de format standard .NET classique en une instance <see cref="T:System.Buffers.StandardFormat" />.</summary>
      <param name="format" vsli:raw="A classic .NET standard format string.">Chaîne de format standard .NET classique.</param>
      <returns vsli:raw="A format.">Un format.</returns>
      <exception cref="T:System.FormatException" vsli:raw="&lt;paramref name=&quot;format&quot; /&gt; is not a valid standard format string.">
        <paramref name="format" /> n’est pas une chaîne de format standard valide.</exception>
    </member>
    <member name="P:System.Buffers.StandardFormat.Precision">
      <summary vsli:raw="Gets the precision component of the format.">Obtient le composant de la précision du format.</summary>
      <returns vsli:raw="The precision component, which can be &lt;see cref=&quot;F:System.Buffers.StandardFormat.NoPrecision&quot; /&gt;, or can range from 0 to 9.">Le composant de précision, qui peut <see cref="F:System.Buffers.StandardFormat.NoPrecision" />être, ou peut être compris entre 0 et 9.</returns>
    </member>
    <member name="P:System.Buffers.StandardFormat.Symbol">
      <summary vsli:raw="Gets the character component of the format.">Obtient le composant de caractère du format.</summary>
      <returns vsli:raw="The character component of the format.">Composant de caractère du format.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.ToString">
      <summary vsli:raw="Returns the string representation of this format.">Retourne la représentation sous forme de chaîne de ce format.</summary>
      <returns vsli:raw="The string representation of this format.">Représentation sous forme de chaîne de ce format.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.TryParse(System.ReadOnlySpan{System.Char},System.Buffers.StandardFormat@)">
      <summary vsli:raw="Attempts to convert a &lt;see langword=&quot;ReadOnlySpan&amp;lt;Char&amp;gt;&quot; /&gt; to a &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; instance and returns a value that indicates whether the parsing operation succeeded.">Tente de convertir un <see langword="ReadOnlySpan&lt;Char&gt;" /> en une instance <see cref="T:System.Buffers.StandardFormat" /> et retourne une valeur qui indique si l’opération d’analyse a réussi.</summary>
      <param name="format" vsli:raw="A read-only span that contains the character to convert.">Étendue en lecture seule qui contient le caractère à convertir.</param>
      <param name="result" vsli:raw="When the method returns, contains the parsed &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; instance if the operation was successful.">Lorsque cette méthode retourne une valeur, contient l’instance <see cref="T:System.Buffers.StandardFormat" /> analysée si l’opération a réussi.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the parsing operation was successful; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si l'opération d'analyse a réussi ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="T:System.Buffers.Text.Base64">
      <summary>Conversions entre les données binaires et le texte codé UTF-8 qui est représenté en base 64.</summary>
    </member>
    <member name="M:System.Buffers.Text.Base64.DecodeFromUtf8(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@,System.Int32@,System.Boolean)">
      <summary>Décode l’étendue du texte codé en UTF-8 représenté en tant que base 64 dans les données binaires. Si l’entrée n’est pas un multiple de 4, il décodera autant que possible, au multiple de 4 le plus proche.</summary>
      <param name="utf8">L’étendue d’entrée qui contient du texte codé UTF-8 en base 64 qui doit être décodé.</param>
      <param name="bytes">L’étendue de sortie qui contient le résultat de l’opération, autrement dit, les données binaires décodées.</param>
      <param name="bytesConsumed">Le nombre d’octets d’entrée consommés pendant l’opération. Cela peut servir à découper l’entrée pour les appels suivants, si nécessaire.</param>
      <param name="bytesWritten">Le nombre d’octets écrits dans l’étendue de sortie. Cela peut servir à découper la sortie pour les appels suivants, si nécessaire.</param>
      <param name="isFinalBlock">
        <see langword="true" /> (valeur par défaut) si l’étendue d’entrée contient la totalité des données à décoder. <see langword="false" /> si l’étendue d’entrée contient des données partielles avec plus de données à suivre.</param>
      <returns>L'une des valeurs d’énumération qui indique l’état de l’opération de décodage.</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.DecodeFromUtf8InPlace(System.Span{System.Byte},System.Int32@)">
      <summary>Décode l’étendue du texte codé en UTF-8 en base 64 (sur place) dans les données binaires. La sortie binaire décodée est plus petite que les données de texte contenues dans l’entrée (l’opération dégonfle des données). Si l’entrée n’est pas un multiple de 4, la méthode ne décodera aucune donnée.</summary>
      <param name="buffer">L’étendue d’entrée qui contient les données de texte en base 64 qui doit être décodé.</param>
      <param name="bytesWritten">Le nombre d’octets écrits dans la mémoire tampon.</param>
      <returns>L'une des valeurs d’énumération qui indique l’état de l’opération de décodage.</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.EncodeToUtf8(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@,System.Int32@,System.Boolean)">
      <summary>Code l’étendue des données binaires en texte codé UTF-8 représenté en tant que base 64.</summary>
      <param name="bytes">L’étendue d’entrée qui contient les données binaires qui doivent être codées.</param>
      <param name="utf8">L’étendue de sortie qui contient le résultat de l’opération, autrement dit, le texte codé UTF-8 en base 64.</param>
      <param name="bytesConsumed">Le nombre d’octets d’entrée consommés pendant l’opération. Cela peut servir à découper l’entrée pour les appels suivants, si nécessaire.</param>
      <param name="bytesWritten">Le nombre d’octets écrits dans l’étendue de sortie. Cela peut servir à découper la sortie pour les appels suivants, si nécessaire.</param>
      <param name="isFinalBlock">
        <see langword="true" /> (valeur par défaut) si l’étendue d’entrée contient la totalité des données à coder. <see langword="false" /> si l’étendue d’entrée contient des données partielles avec plus de données à suivre.</param>
      <returns>L'une des valeurs d’énumération qui indique l’état de l’opération de codage.</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.EncodeToUtf8InPlace(System.Span{System.Byte},System.Int32,System.Int32@)">
      <summary>Code l’étendue des données binaires (sur place) en texte codé UTF-8 représenté en tant que base 64. La sortie du texte codé est plus grande que les données binaires contenues dans l’entrée (l’opération gonfle les données).</summary>
      <param name="buffer">L’étendue d’entrée qui contient les données binaires qui doivent être codées. Étant donné que la méthode effectue une conversion sur place, elle doit être suffisamment grande pour stocker le résultat de l’opération.</param>
      <param name="dataLength">Le nombre d’octets de données binaires contenues dans la mémoire tampon qui doit être codé. Cette valeur doit être inférieure à la longueur de la mémoire tampon.</param>
      <param name="bytesWritten">Le nombre d’octets écrits dans la mémoire tampon.</param>
      <returns>L'une des valeurs d’énumération qui indique l’état de l’opération de codage.</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.GetMaxDecodedFromUtf8Length(System.Int32)">
      <summary>Retourne la longueur maximale (en octets) du résultat, si vous deviez décoder le texte codé en base 64 dans une étendue d’octets avec la longueur spécifiée.</summary>
      <param name="length">Taille de l’étendue d’octets.</param>
      <returns>Longueur maximale (en octets) du résultat.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" /> est inférieur à 0.</exception>
    </member>
    <member name="M:System.Buffers.Text.Base64.GetMaxEncodedToUtf8Length(System.Int32)">
      <summary>Retourne la longueur maximale (en octets) du résultat, si vous deviez coder les données binaires dans une étendue d’octets avec la longueur spécifiée.</summary>
      <param name="length">Taille de l’étendue d’octets.</param>
      <returns>Longueur maximale (en octets) du résultat.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" /> est inférieur à 0 ou supérieur à 1610612733 (étant donné que le codage gonfle les données de 4/3).</exception>
    </member>
    <member name="T:System.Buffers.Text.Utf8Formatter">
      <summary vsli:raw="Provides static methods to format common data types as Utf8 strings.">Fournit des méthodes statiques pour mettre en forme des types de données courants sous forme de chaînes UTF-8.</summary>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Boolean,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.Boolean&quot; /&gt; as a UTF8 string.">Met en forme un <see cref="T:System.Boolean" /> en chaîne UTF-8.</summary>
      <param name="value" vsli:raw="The value to format.">Valeur à mettre en forme.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Mémoire tampon où écrire la valeur au format UTF-8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Quand la méthode retourne, contient la longueur en octets du texte mis en forme.</param>
      <param name="format" vsli:raw="The standard format to use.">Format standard à utiliser.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> si l’opération de mise en forme réussit ; <see langword="false" /> si <paramref name="buffer" /> est trop petit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Byte,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.Byte&quot; /&gt; as a UTF8 string.">Met en forme un <see cref="T:System.Byte" /> en chaîne UTF-8.</summary>
      <param name="value" vsli:raw="The value to format.">Valeur à mettre en forme.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Mémoire tampon où écrire la valeur au format UTF-8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Quand la méthode retourne, contient la longueur en octets du texte mis en forme.</param>
      <param name="format" vsli:raw="The standard format to use.">Format standard à utiliser.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> si l’opération de mise en forme réussit ; <see langword="false" /> si <paramref name="buffer" /> est trop petit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.DateTime,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.DateTime&quot; /&gt; as a UTF8 string.">Met en forme un <see cref="T:System.DateTime" /> en chaîne UTF-8.</summary>
      <param name="value" vsli:raw="The value to format.">Valeur à mettre en forme.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Mémoire tampon où écrire la valeur au format UTF-8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Quand la méthode retourne, contient la longueur en octets du texte mis en forme.</param>
      <param name="format" vsli:raw="The standard format to use.">Format standard à utiliser.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> si l’opération de mise en forme réussit ; <see langword="false" /> si <paramref name="buffer" /> est trop petit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.DateTimeOffset,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.DateTimeOffset&quot; /&gt; as a UTF8 string.">Met en forme un <see cref="T:System.DateTimeOffset" /> en chaîne UTF-8.</summary>
      <param name="value" vsli:raw="The value to format.">Valeur à mettre en forme.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Mémoire tampon où écrire la valeur au format UTF-8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Quand la méthode retourne, contient la longueur en octets du texte mis en forme.</param>
      <param name="format" vsli:raw="The standard format to use.">Format standard à utiliser.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> si l’opération de mise en forme réussit ; <see langword="false" /> si <paramref name="buffer" /> est trop petit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Decimal,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.Decimal&quot; /&gt; as a UTF8 string.">Met en forme un <see cref="T:System.Decimal" /> en chaîne UTF-8.</summary>
      <param name="value" vsli:raw="The value to format.">Valeur à mettre en forme.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Mémoire tampon où écrire la valeur au format UTF-8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Quand la méthode retourne, contient la longueur en octets du texte mis en forme.</param>
      <param name="format" vsli:raw="The standard format to use.">Format standard à utiliser.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> si l’opération de mise en forme réussit ; <see langword="false" /> si <paramref name="buffer" /> est trop petit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Double,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.Double&quot; /&gt; as a UTF8 string.">Met en forme un <see cref="T:System.Double" /> en chaîne UTF-8.</summary>
      <param name="value" vsli:raw="The value to format.">Valeur à mettre en forme.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Mémoire tampon où écrire la valeur au format UTF-8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Quand la méthode retourne, contient la longueur en octets du texte mis en forme.</param>
      <param name="format" vsli:raw="The standard format to use.">Format standard à utiliser.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> si l’opération de mise en forme réussit ; <see langword="false" /> si <paramref name="buffer" /> est trop petit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Guid,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.Guid&quot; /&gt; as a UTF8 string.">Met en forme un <see cref="T:System.Guid" /> en chaîne UTF-8.</summary>
      <param name="value" vsli:raw="The value to format.">Valeur à mettre en forme.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Mémoire tampon où écrire la valeur au format UTF-8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Quand la méthode retourne, contient la longueur en octets du texte mis en forme.</param>
      <param name="format" vsli:raw="The standard format to use.">Format standard à utiliser.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> si l’opération de mise en forme réussit ; <see langword="false" /> si <paramref name="buffer" /> est trop petit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Int16,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats an &lt;see cref=&quot;T:System.Int16&quot; /&gt; as a UTF8 string.">Met en forme un <see cref="T:System.Int16" /> en chaîne UTF-8.</summary>
      <param name="value" vsli:raw="The value to format.">Valeur à mettre en forme.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Mémoire tampon où écrire la valeur au format UTF-8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Quand la méthode retourne, contient la longueur en octets du texte mis en forme.</param>
      <param name="format" vsli:raw="The standard format to use.">Format standard à utiliser.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> si l’opération de mise en forme réussit ; <see langword="false" /> si <paramref name="buffer" /> est trop petit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Int32,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats an &lt;see cref=&quot;T:System.Int32&quot; /&gt; as a UTF8 string.">Met en forme un <see cref="T:System.Int32" /> en chaîne UTF-8.</summary>
      <param name="value" vsli:raw="The value to format.">Valeur à mettre en forme.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Mémoire tampon où écrire la valeur au format UTF-8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Quand la méthode retourne, contient la longueur en octets du texte mis en forme.</param>
      <param name="format" vsli:raw="The standard format to use.">Format standard à utiliser.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> si l’opération de mise en forme réussit ; <see langword="false" /> si <paramref name="buffer" /> est trop petit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Int64,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats an &lt;see cref=&quot;T:System.Int64&quot; /&gt; as a UTF8 string.">Met en forme un <see cref="T:System.Int64" /> en chaîne UTF-8.</summary>
      <param name="value" vsli:raw="The value to format.">Valeur à mettre en forme.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Mémoire tampon où écrire la valeur au format UTF-8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Quand la méthode retourne, contient la longueur en octets du texte mis en forme.</param>
      <param name="format" vsli:raw="The standard format to use.">Format standard à utiliser.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> si l’opération de mise en forme réussit ; <see langword="false" /> si <paramref name="buffer" /> est trop petit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.SByte,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats an &lt;see cref=&quot;T:System.SByte&quot; /&gt; as a UTF8 string.">Met en forme un <see cref="T:System.SByte" /> en chaîne UTF-8.</summary>
      <param name="value" vsli:raw="The value to format.">Valeur à mettre en forme.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Mémoire tampon où écrire la valeur au format UTF-8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Quand la méthode retourne, contient la longueur en octets du texte mis en forme.</param>
      <param name="format" vsli:raw="The standard format to use.">Format standard à utiliser.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> si l’opération de mise en forme réussit ; <see langword="false" /> si <paramref name="buffer" /> est trop petit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Single,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.Single&quot; /&gt; as a UTF8 string.">Met en forme un <see cref="T:System.Single" /> en chaîne UTF-8.</summary>
      <param name="value" vsli:raw="The value to format.">Valeur à mettre en forme.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Mémoire tampon où écrire la valeur au format UTF-8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Quand la méthode retourne, contient la longueur en octets du texte mis en forme.</param>
      <param name="format" vsli:raw="The standard format to use.">Format standard à utiliser.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> si l’opération de mise en forme réussit ; <see langword="false" /> si <paramref name="buffer" /> est trop petit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.TimeSpan,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; as a UTF8 string.">Met en forme un <see cref="T:System.TimeSpan" /> en chaîne UTF-8.</summary>
      <param name="value" vsli:raw="The value to format.">Valeur à mettre en forme.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Mémoire tampon où écrire la valeur au format UTF-8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Quand la méthode retourne, contient la longueur en octets du texte mis en forme.</param>
      <param name="format" vsli:raw="The standard format to use.">Format standard à utiliser.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> si l’opération de mise en forme réussit ; <see langword="false" /> si <paramref name="buffer" /> est trop petit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.UInt16,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; as a UTF8 string.">Met en forme un <see cref="T:System.UInt16" /> en chaîne UTF-8.</summary>
      <param name="value" vsli:raw="The value to format.">Valeur à mettre en forme.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Mémoire tampon où écrire la valeur au format UTF-8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Quand la méthode retourne, contient la longueur en octets du texte mis en forme.</param>
      <param name="format" vsli:raw="The standard format to use.">Format standard à utiliser.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> si l’opération de mise en forme réussit ; <see langword="false" /> si <paramref name="buffer" /> est trop petit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.UInt32,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; as a UTF8 string.">Met en forme un <see cref="T:System.UInt32" /> en chaîne UTF-8.</summary>
      <param name="value" vsli:raw="The value to format.">Valeur à mettre en forme.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Mémoire tampon où écrire la valeur au format UTF-8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Quand la méthode retourne, contient la longueur en octets du texte mis en forme.</param>
      <param name="format" vsli:raw="The standard format to use.">Format standard à utiliser.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> si l’opération de mise en forme réussit ; <see langword="false" /> si <paramref name="buffer" /> est trop petit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.UInt64,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; as a UTF8 string.">Met en forme un <see cref="T:System.UInt64" /> en chaîne UTF-8.</summary>
      <param name="value" vsli:raw="The value to format.">Valeur à mettre en forme.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Mémoire tampon où écrire la valeur au format UTF-8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Quand la méthode retourne, contient la longueur en octets du texte mis en forme.</param>
      <param name="format" vsli:raw="The standard format to use.">Format standard à utiliser.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> si l’opération de mise en forme réussit ; <see langword="false" /> si <paramref name="buffer" /> est trop petit.</returns>
    </member>
    <member name="T:System.Buffers.Text.Utf8Parser">
      <summary vsli:raw="Provides static methods to parse Utf8 strings to common data types.">Fournit des méthodes statiques pour analyser les types de données courants dans les chaînes UTF-8.</summary>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Boolean@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.Boolean&quot; /&gt; at the start of a Utf8 string.">Analyse un <see cref="T:System.Boolean" /> au début d’une chaîne UTF-8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Chaîne UTF-8 à analyser.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Quand la méthode retourne, contient la valeur analysée à partir de <paramref name="source" /> si l’opération d’analyse a réussi.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Si l’opération d’analyse a réussi, contient la longueur en octets de la sous-chaîne analysée quand la méthode retourne. Si la méthode échoue, <paramref name="bytesConsumed" /> est défini sur 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Format attendu de la chaîne UTF-8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> pour la réussite ; <see langword="false" /> si la syntaxe de la chaîne n’était pas valide, ou si un dépassement de capacité positif ou négatif s’est produit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Byte@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.Byte&quot; /&gt; at the start of a Utf8 string.">Analyse un <see cref="T:System.Byte" /> au début d’une chaîne UTF-8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Chaîne UTF-8 à analyser.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Quand la méthode retourne, contient la valeur analysée à partir de <paramref name="source" /> si l’opération d’analyse a réussi.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Si l’opération d’analyse a réussi, contient la longueur en octets de la sous-chaîne analysée quand la méthode retourne. Si la méthode échoue, <paramref name="bytesConsumed" /> est défini sur 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Format attendu de la chaîne UTF-8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> pour la réussite ; <see langword="false" /> si la syntaxe de la chaîne n’était pas valide, ou si un dépassement de capacité positif ou négatif s’est produit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.DateTime@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.DateTime&quot; /&gt; at the start of a Utf8 string.">Analyse un <see cref="T:System.DateTime" /> au début d’une chaîne UTF-8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Chaîne UTF-8 à analyser.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Quand la méthode retourne, contient la valeur analysée à partir de <paramref name="source" /> si l’opération d’analyse a réussi.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Si l’opération d’analyse a réussi, contient la longueur en octets de la sous-chaîne analysée quand la méthode retourne. Si la méthode échoue, <paramref name="bytesConsumed" /> est défini sur 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Format attendu de la chaîne UTF-8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> pour la réussite ; <see langword="false" /> si la syntaxe de la chaîne n’était pas valide, ou si un dépassement de capacité positif ou négatif s’est produit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.DateTimeOffset@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.DateTimeOffset&quot; /&gt; at the start of a Utf8 string.">Analyse un <see cref="T:System.DateTimeOffset" /> au début d’une chaîne UTF-8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Chaîne UTF-8 à analyser.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Quand la méthode retourne, contient la valeur analysée à partir de <paramref name="source" /> si l’opération d’analyse a réussi.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Si l’opération d’analyse a réussi, contient la longueur en octets de la sous-chaîne analysée quand la méthode retourne. Si la méthode échoue, <paramref name="bytesConsumed" /> est défini sur 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Format attendu de la chaîne UTF-8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> pour la réussite ; <see langword="false" /> si la syntaxe de la chaîne n’était pas valide, ou si un dépassement de capacité positif ou négatif s’est produit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Decimal@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.Decimal&quot; /&gt; at the start of a Utf8 string.">Analyse un <see cref="T:System.Decimal" /> au début d’une chaîne UTF-8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Chaîne UTF-8 à analyser.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Quand la méthode retourne, contient la valeur analysée à partir de <paramref name="source" /> si l’opération d’analyse a réussi.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Si l’opération d’analyse a réussi, contient la longueur en octets de la sous-chaîne analysée quand la méthode retourne. Si la méthode échoue, <paramref name="bytesConsumed" /> est défini sur 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Format attendu de la chaîne UTF-8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> pour la réussite ; <see langword="false" /> si la syntaxe de la chaîne n’était pas valide, ou si un dépassement de capacité positif ou négatif s’est produit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Double@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.Double&quot; /&gt; at the start of a Utf8 string.">Analyse un <see cref="T:System.Double" /> au début d’une chaîne UTF-8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Chaîne UTF-8 à analyser.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Quand la méthode retourne, contient la valeur analysée à partir de <paramref name="source" /> si l’opération d’analyse a réussi.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Si l’opération d’analyse a réussi, contient la longueur en octets de la sous-chaîne analysée quand la méthode retourne. Si la méthode échoue, <paramref name="bytesConsumed" /> est défini sur 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Format attendu de la chaîne UTF-8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> pour la réussite ; <see langword="false" /> si la syntaxe de la chaîne n’était pas valide, ou si un dépassement de capacité positif ou négatif s’est produit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Guid@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.Guid&quot; /&gt; at the start of a Utf8 string.">Analyse un <see cref="T:System.Guid" /> au début d’une chaîne UTF-8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Chaîne UTF-8 à analyser.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Quand la méthode retourne, contient la valeur analysée à partir de <paramref name="source" /> si l’opération d’analyse a réussi.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Si l’opération d’analyse a réussi, contient la longueur en octets de la sous-chaîne analysée quand la méthode retourne. Si la méthode échoue, <paramref name="bytesConsumed" /> est défini sur 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Format attendu de la chaîne UTF-8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> pour la réussite ; <see langword="false" /> si la syntaxe de la chaîne n’était pas valide, ou si un dépassement de capacité positif ou négatif s’est produit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Int16@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses an &lt;see cref=&quot;T:System.Int16&quot; /&gt; at the start of a Utf8 string.">Analyse un <see cref="T:System.Int16" /> au début d’une chaîne UTF-8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Chaîne UTF-8 à analyser.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Quand la méthode retourne, contient la valeur analysée à partir de <paramref name="source" /> si l’opération d’analyse a réussi.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Si l’opération d’analyse a réussi, contient la longueur en octets de la sous-chaîne analysée quand la méthode retourne. Si la méthode échoue, <paramref name="bytesConsumed" /> est défini sur 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Format attendu de la chaîne UTF-8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> pour la réussite ; <see langword="false" /> si la syntaxe de la chaîne n’était pas valide, ou si un dépassement de capacité positif ou négatif s’est produit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Int32@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses an &lt;see cref=&quot;T:System.Int32&quot; /&gt; at the start of a Utf8 string.">Analyse un <see cref="T:System.Int32" /> au début d’une chaîne UTF-8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Chaîne UTF-8 à analyser.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Quand la méthode retourne, contient la valeur analysée à partir de <paramref name="source" /> si l’opération d’analyse a réussi.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Si l’opération d’analyse a réussi, contient la longueur en octets de la sous-chaîne analysée quand la méthode retourne. Si la méthode échoue, <paramref name="bytesConsumed" /> est défini sur 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Format attendu de la chaîne UTF-8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> pour la réussite ; <see langword="false" /> si la syntaxe de la chaîne n’était pas valide, ou si un dépassement de capacité positif ou négatif s’est produit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Int64@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses an &lt;see cref=&quot;T:System.Int64&quot; /&gt; at the start of a Utf8 string.">Analyse un <see cref="T:System.Int64" /> au début d’une chaîne UTF-8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Chaîne UTF-8 à analyser.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Quand la méthode retourne, contient la valeur analysée à partir de <paramref name="source" /> si l’opération d’analyse a réussi.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Si l’opération d’analyse a réussi, contient la longueur en octets de la sous-chaîne analysée quand la méthode retourne. Si la méthode échoue, <paramref name="bytesConsumed" /> est défini sur 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Format attendu de la chaîne UTF-8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> pour la réussite ; <see langword="false" /> si la syntaxe de la chaîne n’était pas valide, ou si un dépassement de capacité positif ou négatif s’est produit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.SByte@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses an &lt;see cref=&quot;T:System.SByte&quot; /&gt; at the start of a Utf8 string.">Analyse un <see cref="T:System.SByte" /> au début d’une chaîne UTF-8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Chaîne UTF-8 à analyser.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Quand la méthode retourne, contient la valeur analysée à partir de <paramref name="source" /> si l’opération d’analyse a réussi.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Si l’opération d’analyse a réussi, contient la longueur en octets de la sous-chaîne analysée quand la méthode retourne. Si la méthode échoue, <paramref name="bytesConsumed" /> est défini sur 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Format attendu de la chaîne UTF-8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> pour la réussite ; <see langword="false" /> si la syntaxe de la chaîne n’était pas valide, ou si un dépassement de capacité positif ou négatif s’est produit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Single@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.Single&quot; /&gt; at the start of a Utf8 string.">Analyse un <see cref="T:System.Single" /> au début d’une chaîne UTF-8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Chaîne UTF-8 à analyser.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Quand la méthode retourne, contient la valeur analysée à partir de <paramref name="source" /> si l’opération d’analyse a réussi.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Si l’opération d’analyse a réussi, contient la longueur en octets de la sous-chaîne analysée quand la méthode retourne. Si la méthode échoue, <paramref name="bytesConsumed" /> est défini sur 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Format attendu de la chaîne UTF-8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> pour la réussite ; <see langword="false" /> si la syntaxe de la chaîne n’était pas valide, ou si un dépassement de capacité positif ou négatif s’est produit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.TimeSpan@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; at the start of a Utf8 string.">Analyse un <see cref="T:System.TimeSpan" /> au début d’une chaîne UTF-8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Chaîne UTF-8 à analyser.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Quand la méthode retourne, contient la valeur analysée à partir de <paramref name="source" /> si l’opération d’analyse a réussi.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Si l’opération d’analyse a réussi, contient la longueur en octets de la sous-chaîne analysée quand la méthode retourne. Si la méthode échoue, <paramref name="bytesConsumed" /> est défini sur 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Format attendu de la chaîne UTF-8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> pour la réussite ; <see langword="false" /> si la syntaxe de la chaîne n’était pas valide, ou si un dépassement de capacité positif ou négatif s’est produit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.UInt16@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; at the start of a Utf8 string.">Analyse un <see cref="T:System.UInt16" /> au début d’une chaîne UTF-8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Chaîne UTF-8 à analyser.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Quand la méthode retourne, contient la valeur analysée à partir de <paramref name="source" /> si l’opération d’analyse a réussi.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Si l’opération d’analyse a réussi, contient la longueur en octets de la sous-chaîne analysée quand la méthode retourne. Si la méthode échoue, <paramref name="bytesConsumed" /> est défini sur 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Format attendu de la chaîne UTF-8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> pour la réussite ; <see langword="false" /> si la syntaxe de la chaîne n’était pas valide, ou si un dépassement de capacité positif ou négatif s’est produit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.UInt32@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; at the start of a Utf8 string.">Analyse un <see cref="T:System.UInt32" /> au début d’une chaîne UTF-8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Chaîne UTF-8 à analyser.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Quand la méthode retourne, contient la valeur analysée à partir de <paramref name="source" /> si l’opération d’analyse a réussi.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Si l’opération d’analyse a réussi, contient la longueur en octets de la sous-chaîne analysée quand la méthode retourne. Si la méthode échoue, <paramref name="bytesConsumed" /> est défini sur 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Format attendu de la chaîne UTF-8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> pour la réussite ; <see langword="false" /> si la syntaxe de la chaîne n’était pas valide, ou si un dépassement de capacité positif ou négatif s’est produit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.UInt64@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; at the start of a Utf8 string.">Analyse un <see cref="T:System.UInt64" /> au début d’une chaîne UTF-8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Chaîne UTF-8 à analyser.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Quand la méthode retourne, contient la valeur analysée à partir de <paramref name="source" /> si l’opération d’analyse a réussi.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Si l’opération d’analyse a réussi, contient la longueur en octets de la sous-chaîne analysée quand la méthode retourne. Si la méthode échoue, <paramref name="bytesConsumed" /> est défini sur 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Format attendu de la chaîne UTF-8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> pour la réussite ; <see langword="false" /> si la syntaxe de la chaîne n’était pas valide, ou si un dépassement de capacité positif ou négatif s’est produit.</returns>
    </member>
    <member name="T:System.MemoryExtensions">
      <summary vsli:raw="Provides extension methods for the memory- and span-related types, such as &lt;see cref=&quot;T:System.Memory`1&quot; /&gt;, &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt;, &lt;see cref=&quot;T:System.Span`1&quot; /&gt;, and &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt;.">Fournit des méthodes d’extension pour les types liés à la mémoire et à l’étendue, comme <see cref="T:System.Memory`1" />, <see cref="T:System.ReadOnlyMemory`1" />, <see cref="T:System.Span`1" /> et <see cref="T:System.ReadOnlySpan`1" />.</summary>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String)">
      <summary vsli:raw="Creates a new &lt;see langword=&quot;ReadOnlyMemory&amp;lt;Char&amp;gt;&quot; /&gt; over the portion of the target string.">Crée un <see langword="ReadOnlyMemory&lt;Char&gt;" /> sur la partie de la chaîne cible.</summary>
      <param name="text" vsli:raw="The target string.">Chaîne cible.</param>
      <returns vsli:raw="The read-only character memory representation of the string, or &lt;see langword=&quot;default&quot; /&gt; if &lt;paramref name=&quot;text&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">Représentation sous forme de mémoire de caractères en lecture seule de la chaîne, ou <see langword="default" /> si <paramref name="text" /> est <see langword="null" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Index)">
      <summary vsli:raw="Creates a new &lt;see langword=&quot;ReadOnlyMemory&amp;lt;Char&amp;gt;&quot; /&gt; over a portion of the target string starting at a specified index.">Crée un <see langword="ReadOnlyMemory&lt;Char&gt;" /> sur une partie de la chaîne cible en commençant à un index spécifié.</summary>
      <param name="text" vsli:raw="The target string.">Chaîne cible.</param>
      <param name="startIndex" vsli:raw="The index at which to begin this slice.">Index auquel commence cette section.</param>
      <returns vsli:raw="The read-only character memory representation of the string.">Représentation sous forme de mémoire de caractères en lecture seule de la chaîne.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Int32)">
      <summary vsli:raw="Creates a new &lt;see langword=&quot;ReadOnlyMemory&amp;lt;Char&amp;gt;&quot; /&gt; over a portion of the target string starting at a specified character position.">Crée un <see langword="ReadOnlyMemory&lt;Char&gt;" /> sur une partie de la chaîne cible en commençant à une position de caractère spécifiée.</summary>
      <param name="text" vsli:raw="The target string.">Chaîne cible.</param>
      <param name="start" vsli:raw="The index at which to begin this slice.">Index auquel commence cette section.</param>
      <returns vsli:raw="The read-only character memory representation of the string, or &lt;see langword=&quot;default&quot; /&gt; if &lt;paramref name=&quot;text&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">Représentation sous forme de mémoire de caractères en lecture seule de la chaîne, ou <see langword="default" /> si <paramref name="text" /> est <see langword="null" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt; is not in the range of &lt;paramref name=&quot;text&quot; /&gt; (&lt;paramref name=&quot;start&quot; /&gt; is &amp;lt; 0 or &amp;gt; &lt;c&gt;text.Length&lt;/c&gt;).">
        <paramref name="start" /> n’est pas dans la plage de <paramref name="text" /> (<paramref name="start" /> est &lt; 0 ou &gt; <c>text.Length</c>).</exception>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Int32,System.Int32)">
      <summary vsli:raw="Creates a new &lt;see langword=&quot;ReadOnlyMemory&amp;lt;Char&amp;gt;&quot; /&gt; over a portion of the target string beginning at a specified position with a length.">Crée un <see langword="ReadOnlyMemory&lt;Char&gt;" /> sur une partie de la chaîne cible en commençant à une position spécifiée avec une longueur.</summary>
      <param name="text" vsli:raw="The target string.">Chaîne cible.</param>
      <param name="start" vsli:raw="The index at which to begin this slice.">Index auquel commence cette section.</param>
      <param name="length" vsli:raw="The desired length for the slice.">Longueur souhaitée de la section.</param>
      <returns vsli:raw="The read-only character memory representation of the string, or &lt;see langword=&quot;default&quot; /&gt; if &lt;paramref name=&quot;text&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">Représentation sous forme de mémoire de caractères en lecture seule de la chaîne, ou <see langword="default" /> si <paramref name="text" /> est <see langword="null" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt;, &lt;paramref name=&quot;length&quot; /&gt;, or &lt;paramref name=&quot;start&quot; /&gt; + &lt;paramref name=&quot;length&quot; /&gt; is not in the range of &lt;paramref name=&quot;text&quot; /&gt;.">
        <paramref name="start" />, <paramref name="length" /> ou <paramref name="start" /> + <paramref name="length" /> n’est pas dans la plage de <paramref name="text" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Range)">
      <summary vsli:raw="Creates a new &lt;see langword=&quot;ReadOnlyMemory&amp;lt;Char&amp;gt;&quot; /&gt; over a specified range of the target string.">Crée un <see langword="ReadOnlyMemory&lt;Char&gt;" /> sur une plage spécifiée de la chaîne cible.</summary>
      <param name="text" vsli:raw="The target string.">Chaîne cible.</param>
      <param name="range" vsli:raw="The range that indicates the start and length of the sliced string.">Plage qui indique le début et la longueur de la chaîne sectionnée.</param>
      <returns vsli:raw="The read-only character memory representation of the string.">Représentation sous forme de mémoire de caractères en lecture seule de la chaîne.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[])">
      <summary vsli:raw="Creates a new memory region over the target array.">Crée une région de mémoire sur le tableau cible.</summary>
      <param name="array" vsli:raw="The array to convert.">Tableau à convertir.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Type de tableau.</typeparam>
      <returns vsli:raw="The memory representation of the whole or part of the array.">Représentation sous forme de mémoire de tout ou partie du tableau.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Index)">
      <summary vsli:raw="Creates a new memory region over the portion of the target array starting at a specified index to the end of the array.">Crée une région de mémoire sur la partie du tableau cible en commençant à un index spécifié jusqu’à la fin du tableau.</summary>
      <param name="array" vsli:raw="The array to convert.">Tableau à convertir.</param>
      <param name="startIndex" vsli:raw="The first position of the array.">Première position du tableau.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Type de tableau.</typeparam>
      <returns vsli:raw="The memory representation of the whole or part of the array.">Représentation sous forme de mémoire de tout ou partie du tableau.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Int32)">
      <summary vsli:raw="Creates a new memory region over the portion of the target array starting at a specified position to the end of the array.">Crée une région de mémoire sur la partie du tableau cible en commençant à une position spécifiée jusqu’à la fin du tableau.</summary>
      <param name="array" vsli:raw="The target array.">Tableau cible.</param>
      <param name="start" vsli:raw="The index at which to begin the memory.">Index à partir duquel commencer la mémoire.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Type de tableau.</typeparam>
      <returns vsli:raw="The memory representation of the whole or part of the array.">Représentation sous forme de mémoire de tout ou partie du tableau.</returns>
      <exception cref="T:System.ArrayTypeMismatchException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt; is covariant, and the array's type is not exactly &lt;see langword=&quot;T[]&quot; /&gt;.">La valeur <paramref name="array" /> est covariante et le type du tableau n’est pas exactement <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt; index less than 0 or greater than &lt;see langword=&quot;array.Length&quot; /&gt;.">Index <paramref name="start" /> inférieur à 0 ou supérieur à <see langword="array.Length" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Int32,System.Int32)">
      <summary vsli:raw="Creates a new memory region over the portion of the target array beginning at a specified position with a specified length.">Crée une région de mémoire sur la partie du tableau cible en commençant à une position spécifiée avec une longueur spécifiée.</summary>
      <param name="array" vsli:raw="The target array.">Tableau cible.</param>
      <param name="start" vsli:raw="The index at which to begin the memory region.">Index où commencer la région de mémoire.</param>
      <param name="length" vsli:raw="The number of items in the memory region.">Nombre d’éléments dans la région de mémoire.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Type de tableau.</typeparam>
      <returns vsli:raw="The memory representation of the whole or part of the array.">Représentation sous forme de mémoire de tout ou partie du tableau.</returns>
      <exception cref="T:System.ArrayTypeMismatchException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt; is covariant, and the array's type is not exactly &lt;see langword=&quot;T[]&quot; /&gt;.">La valeur <paramref name="array" /> est covariante et le type du tableau n’est pas exactement <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt;, &lt;paramref name=&quot;length&quot; /&gt;, or &lt;paramref name=&quot;start&quot; /&gt; + &lt;paramref name=&quot;length&quot; /&gt; is not in the range of &lt;paramref name=&quot;array&quot; /&gt;.">
        <paramref name="start" />, <paramref name="length" /> ou <paramref name="start" /> + <paramref name="length" /> n’est pas dans la plage de <paramref name="array" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Range)">
      <summary vsli:raw="Creates a new memory region over the portion of the target array beginning at inclusive start index of the range and ending at the exclusive end index of the range.">Crée une région de mémoire sur la partie du tableau cible en commençant à l’index de début inclus de la plage et en se terminant à l’index de fin exclu de la plage.</summary>
      <param name="array" vsli:raw="The array to convert.">Tableau à convertir.</param>
      <param name="range" vsli:raw="The range to convert from the array.">Plage à convertir à partir du tableau.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Type de tableau.</typeparam>
      <returns vsli:raw="The memory representation of the whole or part of the array.">Représentation sous forme de mémoire de tout ou partie du tableau.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0})">
      <summary vsli:raw="Creates a new memory region over the portion of the target array segment.">Crée une région de mémoire sur la partie du segment de tableau cible.</summary>
      <param name="segment" vsli:raw="The segment to convert.">Segment à convertir.</param>
      <typeparam name="T" vsli:raw="The type of the segment.">Type du segment.</typeparam>
      <returns vsli:raw="The memory representation of the segment.">Représentation sous forme de mémoire du segment.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0},System.Int32)">
      <summary vsli:raw="Creates a new memory region over the portion of the target array segment starting at a specified position to the end of the segment.">Crée une région de mémoire sur la partie du segment de tableau cible en commençant à une position spécifiée jusqu’à la fin du segment.</summary>
      <param name="segment" vsli:raw="The target array segment.">Segment de tableau cible.</param>
      <param name="start" vsli:raw="The index at which to begin the memory.">Index à partir duquel commencer la mémoire.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Type de tableau.</typeparam>
      <returns vsli:raw="The memory representation of the whole or part of the array.">Représentation sous forme de mémoire de tout ou partie du tableau.</returns>
      <exception cref="T:System.ArrayTypeMismatchException" vsli:raw="&lt;paramref name=&quot;segment&quot; /&gt; is covariant, and the type of &lt;paramref name=&quot;segment&quot; /&gt; is not exactly &lt;see langword=&quot;T[]&quot; /&gt;.">La valeur <paramref name="segment" /> est covariante et le type de <paramref name="segment" /> n’est pas exactement <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt; is less than 0 or greater than &lt;see langword=&quot;segment.Count&quot; /&gt;.">
        <paramref name="start" /> est inférieur à 0 ou supérieur à <see langword="segment.Count" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0},System.Int32,System.Int32)">
      <summary vsli:raw="Creates a new memory region over the portion of the target array segment beginning at a specified position with a specified length.">Crée une région de mémoire sur la partie du segment de tableau cible en commençant à une position spécifiée avec une longueur spécifiée.</summary>
      <param name="segment" vsli:raw="The target array segment.">Segment de tableau cible.</param>
      <param name="start" vsli:raw="The index at which to begin the memory.">Index à partir duquel commencer la mémoire.</param>
      <param name="length" vsli:raw="The number of items in the memory.">Nombre d’éléments dans la mémoire.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Type de tableau.</typeparam>
      <returns vsli:raw="The memory representation of the whole or part of the array.">Représentation sous forme de mémoire de tout ou partie du tableau.</returns>
      <exception cref="T:System.ArrayTypeMismatchException" vsli:raw="&lt;paramref name=&quot;segment&quot; /&gt; is covariant, and the array's type is not exactly &lt;see langword=&quot;T[]&quot; /&gt;.">La valeur <paramref name="segment" /> est covariante et le type du tableau n’est pas exactement <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt;, &lt;paramref name=&quot;length&quot; /&gt;, or &lt;paramref name=&quot;start&quot; /&gt; + &lt;paramref name=&quot;length&quot; /&gt; is not in the range of &lt;paramref name=&quot;segment&quot; /&gt;.">
        <paramref name="start" />, <paramref name="length" /> ou <paramref name="start" /> + <paramref name="length" /> n’est pas dans la plage de <paramref name="segment" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan(System.String)">
      <summary vsli:raw="Creates a new read-only span over a string.">Crée une étendue en lecture seule sur une partie de la chaîne cible à une position spécifiée pour un nombre spécifié de caractères.</summary>
      <param name="text" vsli:raw="The target string.">Chaîne cible.</param>
      <returns vsli:raw="The read-only span representation of the string.">Représentation sous forme d’étendue en lecture seule de la chaîne.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan(System.String,System.Int32)">
      <summary vsli:raw="Creates a new read-only span over a portion of the target string from a specified position to the end of the string.">Crée une étendue en lecture seule sur une partie de la chaîne cible à une position spécifiée jusqu’à la fin de la chaîne.</summary>
      <param name="text" vsli:raw="The target string.">Chaîne cible.</param>
      <param name="start" vsli:raw="The index at which to begin this slice.">Index auquel commence cette section.</param>
      <returns vsli:raw="The read-only span representation of the string.">Représentation sous forme d’étendue en lecture seule de la chaîne.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="Thrown when &lt;paramref name=&quot;text&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="text" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt; is less than 0 or greater than &lt;see langword=&quot;text.Length&quot; /&gt;.">
        <paramref name="start" /> est inférieur à 0 ou supérieur à <see langword="text.Length" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan(System.String,System.Int32,System.Int32)">
      <summary vsli:raw="Creates a new read-only span over a portion of the target string from a specified position for a specified number of characters.">Crée une étendue en lecture seule sur une chaîne.</summary>
      <param name="text" vsli:raw="The target string.">Chaîne cible.</param>
      <param name="start" vsli:raw="The index at which to begin this slice.">Index auquel commence cette section.</param>
      <param name="length" vsli:raw="The desired length for the slice.">Longueur souhaitée de la section.</param>
      <returns vsli:raw="The read-only span representation of the string.">Représentation sous forme d’étendue en lecture seule de la chaîne.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt;, &lt;paramref name=&quot;length&quot; /&gt;, or &lt;paramref name=&quot;start&quot; /&gt; + &lt;paramref name=&quot;length&quot; /&gt; is not in the range of &lt;paramref name=&quot;text&quot; /&gt;.">
        <paramref name="start" />, <paramref name="length" /> ou <paramref name="start" /> + <paramref name="length" /> n’est pas dans la plage de <paramref name="text" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[])">
      <summary vsli:raw="Creates a new span over a target array.">Crée une étendue sur un tableau cible.</summary>
      <param name="array" vsli:raw="The array to convert.">Tableau à convertir.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Type de tableau.</typeparam>
      <returns vsli:raw="The span representation of the array.">Représentation sous forme d’étendue du tableau.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Index)">
      <summary vsli:raw="Creates a new span over the portion of the target array defined by an &lt;see cref=&quot;T:System.Index&quot; /&gt; value.">Crée une étendue sur la partie du tableau cible défini par une valeur <see cref="T:System.Index" />.</summary>
      <param name="array" vsli:raw="The array to convert.">Tableau à convertir.</param>
      <param name="startIndex" vsli:raw="The starting index.">Index de départ.</param>
      <typeparam name="T" vsli:raw="The array type.">Type de tableau.</typeparam>
      <returns vsli:raw="The span representation of the array.">Représentation sous forme d’étendue du tableau.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Int32)">
      <summary vsli:raw="Creates a new span over a portion of the target array starting at a specified position to the end of the array.">Crée une étendue sur une partie du tableau cible en commençant à une position spécifiée jusqu’à la fin du tableau.</summary>
      <param name="array" vsli:raw="The array to convert.">Tableau à convertir.</param>
      <param name="start" vsli:raw="The initial index from which the array will be converted.">Index initial à partir duquel le tableau sera converti.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Type de tableau.</typeparam>
      <returns vsli:raw="The span representation of the array.">Représentation sous forme d’étendue du tableau.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Int32,System.Int32)">
      <summary vsli:raw="Creates a new span over the portion of the target array beginning at a specified position for a specified length.">Crée une étendue sur la partie du tableau cible en commençant à une position spécifiée pour une longueur spécifiée.</summary>
      <param name="array" vsli:raw="The target array.">Tableau cible.</param>
      <param name="start" vsli:raw="The index at which to begin the span.">Index à partir duquel commencer l’étendue.</param>
      <param name="length" vsli:raw="The number of items in the span.">Nombre d’éléments dans l’étendue.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Type de tableau.</typeparam>
      <returns vsli:raw="The span representation of the array.">Représentation sous forme d’étendue du tableau.</returns>
      <exception cref="T:System.ArrayTypeMismatchException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt; is covariant, and the array's type is not exactly &lt;see langword=&quot;T[]&quot; /&gt;&quot;.">La valeur <paramref name="array" /> est covariante et le type du tableau n’est pas exactement <see langword="T[]" />".</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt;, &lt;paramref name=&quot;length&quot; /&gt;, or &lt;paramref name=&quot;start&quot; /&gt; + &lt;paramref name=&quot;length&quot; /&gt; is not in the range of &lt;paramref name=&quot;text&quot; /&gt;.">
        <paramref name="start" />, <paramref name="length" /> ou <paramref name="start" /> + <paramref name="length" /> n’est pas dans la plage de <paramref name="text" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Range)">
      <summary vsli:raw="Creates a new span over a portion of a target array defined by a &lt;see cref=&quot;T:System.Range&quot; /&gt; value.">Crée une étendue sur une partie d’un tableau cible défini par une valeur <see cref="T:System.Range" />.</summary>
      <param name="array" vsli:raw="The array to convert.">Tableau à convertir.</param>
      <param name="range" vsli:raw="The range of the array to convert.">Plage du tableau à convertir.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Type de tableau.</typeparam>
      <returns vsli:raw="The span representation of the array.">Représentation sous forme d’étendue du tableau.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0})">
      <summary vsli:raw="Creates a new span over a target array segment.">Crée une étendue sur un segment de tableau cible.</summary>
      <param name="segment" vsli:raw="The array segment to convert.">Segment de tableau à convertir.</param>
      <typeparam name="T" vsli:raw="The type of the array segment.">Type du segment de tableau.</typeparam>
      <returns vsli:raw="The span representation of the array segment.">Représentation sous forme d’étendue du segment de tableau.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Index)">
      <summary vsli:raw="Creates a new span over a portion of the target array segment beginning at a specified index and ending at the end of the segment.">Crée une étendue sur une partie du segment de tableau cible en commençant à un index spécifié et en se terminant à la fin du segment.</summary>
      <param name="segment" vsli:raw="The target array segment.">Segment de tableau cible.</param>
      <param name="startIndex" vsli:raw="The index at which to begin the Span.">Index à partir duquel commencer l’étendue.</param>
      <typeparam name="T" vsli:raw="The type of the array segment.">Type du segment de tableau.</typeparam>
      <returns vsli:raw="The span representation of the array segment.">Représentation sous forme d’étendue du segment de tableau.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Int32)">
      <summary vsli:raw="Creates a new span over a portion of a target array segment from a specified position to the end of the segment.">Crée une étendue sur une partie d’un segment de tableau cible à une position spécifiée jusqu’à la fin du segment.</summary>
      <param name="segment" vsli:raw="The target array segment.">Segment de tableau cible.</param>
      <param name="start" vsli:raw="The index at which to begin the san.">Index à partir duquel commencer l’étendue.</param>
      <typeparam name="T" vsli:raw="The type of the array segment.">Type du segment de tableau.</typeparam>
      <returns vsli:raw="The span representation of the array segment.">Représentation sous forme d’étendue du segment de tableau.</returns>
      <exception cref="T:System.ArrayTypeMismatchException" vsli:raw="&lt;paramref name=&quot;segment&quot; /&gt; is covariant, and the array's type is not exactly &lt;see langword=&quot;T[]&quot; /&gt;.">La valeur <paramref name="segment" /> est covariante et le type du tableau n’est pas exactement <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt; is less than 0 or greater than &lt;see langword=&quot;segment.Count&quot; /&gt;.">
        <paramref name="start" /> est inférieur à 0 ou supérieur à <see langword="segment.Count" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Int32,System.Int32)">
      <summary vsli:raw="Creates a new span over a portion of a target array segment from a specified position for a specified length.">Crée une étendue sur une partie d’un segment de tableau cible à une position spécifiée pour une longueur spécifiée.</summary>
      <param name="segment" vsli:raw="The target array segment.">Segment de tableau cible.</param>
      <param name="start" vsli:raw="The index at which to begin the span.">Index à partir duquel commencer l’étendue.</param>
      <param name="length" vsli:raw="The number of items in the span.">Nombre d’éléments dans l’étendue.</param>
      <typeparam name="T" vsli:raw="The type of the array segment.">Type du segment de tableau.</typeparam>
      <returns vsli:raw="The span representation of the array.">Représentation sous forme d’étendue du tableau.</returns>
      <exception cref="T:System.ArrayTypeMismatchException" vsli:raw="&lt;paramref name=&quot;segment&quot; /&gt; is covariant, and the array's type is not exactly &lt;see langword=&quot;T[]&quot; /&gt;.">La valeur <paramref name="segment" /> est covariante et le type du tableau n’est pas exactement <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt;, &lt;paramref name=&quot;length&quot; /&gt;, or &lt;paramref name=&quot;start&quot; /&gt; + &lt;paramref name=&quot;length&quot; /&gt; is not in the range of &lt;paramref name=&quot;segment&quot; /&gt;.">
        <paramref name="start" />, <paramref name="length" /> ou <paramref name="start" /> + <paramref name="length" /> n’est pas dans la plage de <paramref name="segment" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Range)">
      <summary vsli:raw="Creates a new span over a portion of a target array segment using the range start and end indexes.">Crée une étendue sur une partie d’un segment de tableau cible à l’aide des index de début et de fin de la plage.</summary>
      <param name="segment" vsli:raw="The target array segment.">Segment de tableau cible.</param>
      <param name="range" vsli:raw="The range which has start and end indexes to use for slicing the array.">Plage qui contient les index de début et de fin à utiliser pour découper le tableau.</param>
      <typeparam name="T" vsli:raw="The type of the array segment.">Type du segment de tableau.</typeparam>
      <returns vsli:raw="The span representation of the array segment.">Représentation sous forme d’étendue du segment de tableau.</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``1(System.ReadOnlySpan{``0},System.IComparable{``0})">
      <summary vsli:raw="Searches an entire sorted &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; for a value using the specified &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; generic interface.">Recherche une valeur dans une <see cref="T:System.ReadOnlySpan`1" /> entière triée en utilisant l’interface générique <see cref="T:System.IComparable`1" /> spécifiée.</summary>
      <param name="span" vsli:raw="The sorted &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; to search.">
        <see cref="T:System.ReadOnlySpan`1" /> triée dans laquelle rechercher.</param>
      <param name="comparable" vsli:raw="The &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; to use when comparing.">
        <see cref="T:System.IComparable`1" /> à utiliser pendant la comparaison.</param>
      <typeparam name="T" vsli:raw="The element type of the span.">Type d’élément de l’étendue.</typeparam>
      <returns vsli:raw="The zero-based index of &lt;paramref name=&quot;comparable&quot; /&gt; in the sorted &lt;paramref name=&quot;span&quot; /&gt;, if &lt;paramref name=&quot;comparable&quot; /&gt; is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than &lt;paramref name=&quot;comparable&quot; /&gt; or, if there is no larger element, the bitwise complement of &lt;see cref=&quot;P:System.ReadOnlySpan`1.Length&quot; /&gt;.">Index de base zéro de <paramref name="comparable" /> dans le <paramref name="span" /> trié, si <paramref name="comparable" /> existe ; sinon, un nombre négatif qui est le complément de bits de l'index de l'élément suivant supérieur à <paramref name="comparable" /> ou, s'il n'existe aucun élément supérieur, le complément de bits de <see cref="P:System.ReadOnlySpan`1.Length" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;comparable&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="comparable" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``1(System.Span{``0},System.IComparable{``0})">
      <summary vsli:raw="Searches an entire sorted &lt;see cref=&quot;T:System.Span`1&quot; /&gt; for a value using the specified &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; generic interface.">Recherche une valeur dans une <see cref="T:System.Span`1" /> entière triée en utilisant l’interface générique <see cref="T:System.IComparable`1" /> spécifiée.</summary>
      <param name="span" vsli:raw="The sorted &lt;see cref=&quot;T:System.Span`1&quot; /&gt; to search.">
        <see cref="T:System.Span`1" /> triée dans laquelle rechercher.</param>
      <param name="comparable" vsli:raw="The &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; to use when comparing.">
        <see cref="T:System.IComparable`1" /> à utiliser pendant la comparaison.</param>
      <typeparam name="T" vsli:raw="The element type of the span.">Type d’élément de l’étendue.</typeparam>
      <returns vsli:raw="The zero-based index of &lt;paramref name=&quot;comparable&quot; /&gt; in the sorted &lt;paramref name=&quot;span&quot; /&gt;, if &lt;paramref name=&quot;comparable&quot; /&gt; is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than &lt;paramref name=&quot;comparable&quot; /&gt; or, if there is no larger element, the bitwise complement of &lt;see cref=&quot;P:System.Span`1.Length&quot; /&gt;.">Index de base zéro de <paramref name="comparable" /> dans le <paramref name="span" /> trié, si <paramref name="comparable" /> existe ; sinon, un nombre négatif qui est le complément de bits de l'index de l'élément suivant supérieur à <paramref name="comparable" /> ou, s'il n'existe aucun élément supérieur, le complément de bits de <see cref="P:System.Span`1.Length" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;comparable&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="comparable" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``2(System.ReadOnlySpan{``0},``0,``1)">
      <summary vsli:raw="Searches an entire sorted &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; for a specified value using the specified &lt;typeparamref name=&quot;TComparer&quot; /&gt; generic type.">Recherche une valeur spécifiée dans une <see cref="T:System.ReadOnlySpan`1" /> entière triée en utilisant le type générique <typeparamref name="TComparer" /> spécifié.</summary>
      <param name="span" vsli:raw="The sorted &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; to search.">
        <see cref="T:System.ReadOnlySpan`1" /> triée dans laquelle rechercher.</param>
      <param name="value" vsli:raw="The object to locate. The value can be &lt;see langword=&quot;null&quot; /&gt; for reference types.">Objet à trouver. La valeur peut être <see langword="null" /> pour les types référence.</param>
      <param name="comparer" vsli:raw="The &lt;typeparamref name=&quot;TComparer&quot; /&gt; to use when comparing.">
        <typeparamref name="TComparer" /> à utiliser pendant la comparaison.</param>
      <typeparam name="T" vsli:raw="The element type of the span.">Type d’élément de l’étendue.</typeparam>
      <typeparam name="TComparer" vsli:raw="The specific type of &lt;see cref=&quot;T:System.Collections.Generic.IComparer`1&quot; /&gt;.">Type spécifique de <see cref="T:System.Collections.Generic.IComparer`1" />.</typeparam>
      <returns vsli:raw="The zero-based index of &lt;paramref name=&quot;value&quot; /&gt; in the sorted &lt;paramref name=&quot;span&quot; /&gt;, if &lt;paramref name=&quot;value&quot; /&gt; is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than &lt;paramref name=&quot;value&quot; /&gt; or, if there is no larger element, the bitwise complement of &lt;see cref=&quot;P:System.ReadOnlySpan`1.Length&quot; /&gt;.">Index de base zéro de <paramref name="value" /> dans le <paramref name="span" /> trié, si <paramref name="value" /> existe ; sinon, un nombre négatif qui est le complément de bits de l'index de l'élément suivant supérieur à <paramref name="value" /> ou, s'il n'existe aucun élément supérieur, le complément de bits de <see cref="P:System.ReadOnlySpan`1.Length" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;comparer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="comparer" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``2(System.ReadOnlySpan{``0},``1)">
      <summary vsli:raw="Searches an entire sorted &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; for a value using the specified &lt;typeparamref name=&quot;TComparable&quot; /&gt; generic type.">Recherche une valeur dans une <see cref="T:System.ReadOnlySpan`1" /> entière triée en utilisant le type générique <typeparamref name="TComparable" /> spécifié.</summary>
      <param name="span" vsli:raw="The sorted &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; to search.">
        <see cref="T:System.ReadOnlySpan`1" /> triée dans laquelle rechercher.</param>
      <param name="comparable" vsli:raw="The &lt;typeparamref name=&quot;TComparable&quot; /&gt; to use when comparing.">
        <typeparamref name="TComparable" /> à utiliser pendant la comparaison.</param>
      <typeparam name="T" vsli:raw="The element type of the span.">Type d’élément de l’étendue.</typeparam>
      <typeparam name="TComparable" vsli:raw="The specific type of &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt;.">Type spécifique de <see cref="T:System.IComparable`1" />.</typeparam>
      <returns vsli:raw="The zero-based index of &lt;paramref name=&quot;comparable&quot; /&gt; in the sorted &lt;paramref name=&quot;span&quot; /&gt;, if &lt;paramref name=&quot;comparable&quot; /&gt; is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than &lt;paramref name=&quot;comparable&quot; /&gt; or, if there is no larger element, the bitwise complement of &lt;see cref=&quot;P:System.ReadOnlySpan`1.Length&quot; /&gt;.">Index de base zéro de <paramref name="comparable" /> dans le <paramref name="span" /> trié, si <paramref name="comparable" /> existe ; sinon, un nombre négatif qui est le complément de bits de l'index de l'élément suivant supérieur à <paramref name="comparable" /> ou, s'il n'existe aucun élément supérieur, le complément de bits de <see cref="P:System.ReadOnlySpan`1.Length" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;comparable&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="comparable" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``2(System.Span{``0},``0,``1)">
      <summary vsli:raw="Searches an entire sorted &lt;see cref=&quot;T:System.Span`1&quot; /&gt; for a specified value using the specified &lt;typeparamref name=&quot;TComparer&quot; /&gt; generic type.">Recherche une valeur spécifiée dans une <see cref="T:System.Span`1" /> entière triée en utilisant le type générique <typeparamref name="TComparer" /> spécifié.</summary>
      <param name="span" vsli:raw="The sorted &lt;see cref=&quot;T:System.Span`1&quot; /&gt; to search.">
        <see cref="T:System.Span`1" /> triée dans laquelle rechercher.</param>
      <param name="value" vsli:raw="The object to locate. The value can be &lt;see langword=&quot;null&quot; /&gt; for reference types.">Objet à trouver. La valeur peut être <see langword="null" /> pour les types référence.</param>
      <param name="comparer" vsli:raw="The &lt;typeparamref name=&quot;TComparer&quot; /&gt; to use when comparing.">
        <typeparamref name="TComparer" /> à utiliser pendant la comparaison.</param>
      <typeparam name="T" vsli:raw="The element type of the span.">Type d’élément de l’étendue.</typeparam>
      <typeparam name="TComparer" vsli:raw="The specific type of &lt;see cref=&quot;T:System.Collections.Generic.IComparer`1&quot; /&gt;.">Type spécifique de <see cref="T:System.Collections.Generic.IComparer`1" />.</typeparam>
      <returns vsli:raw="The zero-based index of &lt;paramref name=&quot;value&quot; /&gt; in the sorted &lt;paramref name=&quot;span&quot; /&gt;, if &lt;paramref name=&quot;value&quot; /&gt; is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than &lt;paramref name=&quot;value&quot; /&gt; or, if there is no larger element, the bitwise complement of &lt;see cref=&quot;P:System.Span`1.Length&quot; /&gt;.">Index de base zéro de <paramref name="value" /> dans le <paramref name="span" /> trié, si <paramref name="value" /> existe ; sinon, un nombre négatif qui est le complément de bits de l'index de l'élément suivant supérieur à <paramref name="value" /> ou, s'il n'existe aucun élément supérieur, le complément de bits de <see cref="P:System.Span`1.Length" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;comparer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="comparer" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``2(System.Span{``0},``1)">
      <summary vsli:raw="Searches an entire sorted &lt;see cref=&quot;T:System.Span`1&quot; /&gt; for a value using the specified &lt;typeparamref name=&quot;TComparable&quot; /&gt; generic type.">Recherche une valeur dans une <see cref="T:System.Span`1" /> entière triée en utilisant le type générique <typeparamref name="TComparable" /> spécifié.</summary>
      <param name="span" vsli:raw="The sorted &lt;see cref=&quot;T:System.Span`1&quot; /&gt; to search.">
        <see cref="T:System.Span`1" /> triée dans laquelle rechercher.</param>
      <param name="comparable" vsli:raw="The &lt;typeparamref name=&quot;TComparable&quot; /&gt; to use when comparing.">
        <typeparamref name="TComparable" /> à utiliser pendant la comparaison.</param>
      <typeparam name="T" vsli:raw="The element type of the span.">Type d’élément de l’étendue.</typeparam>
      <typeparam name="TComparable" vsli:raw="The specific type of &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt;.">Type spécifique de <see cref="T:System.IComparable`1" />.</typeparam>
      <returns vsli:raw="The zero-based index of &lt;paramref name=&quot;comparable&quot; /&gt; in the sorted &lt;paramref name=&quot;span&quot; /&gt;, if &lt;paramref name=&quot;comparable&quot; /&gt; is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than &lt;paramref name=&quot;comparable&quot; /&gt; or, if there is no larger element, the bitwise complement of &lt;see cref=&quot;P:System.Span`1.Length&quot; /&gt;.">Index de base zéro de <paramref name="comparable" /> dans le <paramref name="span" /> trié, si <paramref name="comparable" /> existe ; sinon, un nombre négatif qui est le complément de bits de l'index de l'élément suivant supérieur à <paramref name="comparable" /> ou, s'il n'existe aucun élément supérieur, le complément de bits de <see cref="P:System.Span`1.Length" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;comparable&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="comparable" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.CompareTo(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary vsli:raw="Compares one character span with another using a specified string comparison, and returns an integer that indicates their relative position in the sort order.">Compare une étendue de caractères à une autre à l’aide d’une comparaison de chaînes spécifiée et retourne un entier qui indique leur position relative dans l’ordre de tri.</summary>
      <param name="span" vsli:raw="The source span.">Étendue source.</param>
      <param name="other" vsli:raw="The value to compare with the source span.">Valeur à comparer avec l’étendue source.</param>
      <param name="comparisonType" vsli:raw="An enumeration value that determines how &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;other&quot; /&gt; are compared.">Valeur d’énumération qui détermine comment <paramref name="span" /> et <paramref name="other" /> sont comparés.</param>
      <returns vsli:raw="A signed integer that indicates the relative order of &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;other&quot; /&gt;:&lt;br /&gt;   - If less than 0, &lt;paramref name=&quot;span&quot; /&gt; precedes than &lt;paramref name=&quot;other&quot; /&gt;.&lt;br /&gt;   - If 0, &lt;paramref name=&quot;span&quot; /&gt; equals &lt;paramref name=&quot;other&quot; /&gt;.&lt;br /&gt;   - If greater than 0, &lt;paramref name=&quot;span&quot; /&gt; follows &lt;paramref name=&quot;other&quot; /&gt;.">Entier signé qui indique l’ordre relatif de <paramref name="span" /> et <paramref name="other" /> :   - S’il est inférieur à 0, <paramref name="span" /> précède à <paramref name="other" />.   - S’il est égal à 0, <paramref name="span" /> est égal à <paramref name="other" />.   - S’il est supérieur à 0, <paramref name="span" /> suit <paramref name="other" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Contains(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary vsli:raw="Indicates whether a specified value occurs within a read-only character span.">Indique si une valeur spécifiée se produit dans une étendue de caractères en lecture seule.</summary>
      <param name="span" vsli:raw="The source span.">Étendue source.</param>
      <param name="value" vsli:raw="The value to seek within the source span.">Valeur à rechercher dans l’étendue source.</param>
      <param name="comparisonType" vsli:raw="An enumeration value that determines how the characters in &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;value&quot; /&gt; are compared.">Valeur d’énumération qui détermine comment les caractères dans <paramref name="span" /> et <paramref name="value" /> sont comparés.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;value&quot; /&gt; occurs within the span, &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" /> si <paramref name="value" /> se produit dans l’étendue ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Contains``1(System.ReadOnlySpan{``0},``0)">
      <summary vsli:raw="Indicates whether a specified value is found in a read-only span. Values are compared using IEquatable{T}.Equals(T).">Indique si une valeur spécifiée est trouvée dans une étendue en lecture seule. Les valeurs sont comparées en utilisant IEquatable{T}.Equals(T).</summary>
      <param name="span" vsli:raw="The span to search.">Étendue sur laquelle porte la recherche.</param>
      <param name="value" vsli:raw="The value to search for.">La valeur à rechercher.</param>
      <typeparam name="T" vsli:raw="The type of the span.">Type de l’étendue.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if found, &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" /> si trouvée ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Contains``1(System.Span{``0},``0)">
      <summary vsli:raw="Indicates whether a specified value is found in a span. Values are compared using IEquatable{T}.Equals(T).">Indique si une valeur spécifiée est trouvée dans une étendue. Les valeurs sont comparées en utilisant IEquatable{T}.Equals(T).</summary>
      <param name="span" vsli:raw="The span to search.">Étendue sur laquelle porte la recherche.</param>
      <param name="value" vsli:raw="The value to search for.">La valeur à rechercher.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the span.">Type des éléments de l’étendue.</typeparam>
      <returns vsli:raw="&lt;code data-dev-comment-type=&quot;langword&quot;&gt;true&lt;/code&gt; if found, &lt;code data-dev-comment-type=&quot;langword&quot;&gt;false&lt;/code&gt; otherwise.">
        <see langword="true" /> si trouvée ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.CopyTo``1(``0[],System.Memory{``0})">
      <summary vsli:raw="Copies the contents of the array into a memory region.">Copie le contenu du tableau dans une région de mémoire.</summary>
      <param name="source" vsli:raw="The array to copy items from.">Tableau à partir duquel copier les éléments.</param>
      <param name="destination" vsli:raw="The memory to copy items into.">Mémoire dans laquelle copier les éléments.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Type de tableau.</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="The destination is shorter than the source array.">La destination est plus petite que le tableau source.</exception>
    </member>
    <member name="M:System.MemoryExtensions.CopyTo``1(``0[],System.Span{``0})">
      <summary vsli:raw="Copies the contents of the array into the span.">Copie le contenu du tableau dans l’étendue.</summary>
      <param name="source" vsli:raw="The array to copy items from.">Tableau à partir duquel copier les éléments.</param>
      <param name="destination" vsli:raw="The span to copy items into.">Étendue dans laquelle copier les éléments.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Type de tableau.</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="The destination Span is shorter than the source array.">L’étendue de destination est plus petite que le tableau source.</exception>
    </member>
    <member name="M:System.MemoryExtensions.EndsWith(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary vsli:raw="Determines whether the end of the &lt;paramref name=&quot;span&quot; /&gt; matches the specified &lt;paramref name=&quot;value&quot; /&gt; when compared using the specified &lt;paramref name=&quot;comparisonType&quot; /&gt; option.">Détermine si la fin de <paramref name="span" /> correspond à la <paramref name="value" /> spécifiée quand elle est comparée à l’aide de l’option <paramref name="comparisonType" /> spécifiée.</summary>
      <param name="span" vsli:raw="The source span.">Étendue source.</param>
      <param name="value" vsli:raw="The sequence to compare to the end of the source span.">Séquence à comparer à la fin de l’étendue source.</param>
      <param name="comparisonType" vsli:raw="An enumeration value that determines how &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;value&quot; /&gt; are compared.">Valeur d’énumération qui détermine comment <paramref name="span" /> et <paramref name="value" /> sont comparés.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;value&quot; /&gt; matches the end of &lt;paramref name=&quot;span&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si <paramref name="value" /> correspond à la fin de <paramref name="span" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.EndsWith``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Determines whether the specified sequence appears at the end of a read-only span.">Détermine si la séquence spécifiée apparaît à la fin d’une étendue en lecture seule.</summary>
      <param name="span" vsli:raw="The source span.">Étendue source.</param>
      <param name="value" vsli:raw="The sequence to compare to the end of the source span.">Séquence à comparer à la fin de l’étendue source.</param>
      <typeparam name="T" vsli:raw="The type of the span.">Type de l’étendue.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;value&quot; /&gt; matches the end of &lt;paramref name=&quot;span&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si <paramref name="value" /> correspond à la fin de <paramref name="span" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.EndsWith``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Determines whether the specified sequence appears at the end of a span.">Détermine si la séquence spécifiée apparaît à la fin d’une étendue.</summary>
      <param name="span" vsli:raw="The source span.">Étendue source.</param>
      <param name="value" vsli:raw="The sequence to compare to the end of the source span.">Séquence à comparer à la fin de l’étendue source.</param>
      <typeparam name="T" vsli:raw="The type of the span.">Type de l’étendue.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;value&quot; /&gt; matches the end of &lt;paramref name=&quot;span&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si <paramref name="value" /> correspond à la fin de <paramref name="span" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.EnumerateRunes(System.ReadOnlySpan{System.Char})">
      <summary vsli:raw="Returns an enumeration of &lt;see cref=&quot;T:System.Text.Rune&quot; /&gt; from the provided read-only span.">Retourne une énumération de <see cref="T:System.Text.Rune" /> à partir de l’étendue en lecture seule fournie.</summary>
      <param name="span" vsli:raw="The source span.">Étendue source.</param>
      <returns vsli:raw="A rune enumerator.">Énumérateur Rune.</returns>
    </member>
    <member name="M:System.MemoryExtensions.EnumerateRunes(System.Span{System.Char})">
      <summary vsli:raw="Returns an enumeration of &lt;see cref=&quot;T:System.Text.Rune&quot; /&gt; from the provided span.">Retourne une énumération de <see cref="T:System.Text.Rune" /> à partir de l’étendue fournie.</summary>
      <param name="span" vsli:raw="The source span.">Étendue source.</param>
      <returns vsli:raw="A rune enumerator.">Énumérateur Rune.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Equals(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary vsli:raw="Determines whether this &lt;paramref name=&quot;span&quot; /&gt; and the specified &lt;paramref name=&quot;other&quot; /&gt; span have the same characters when compared using the specified &lt;paramref name=&quot;comparisonType&quot; /&gt; option.">Détermine si cette <paramref name="span" /> et l’étendue <paramref name="other" /> spécifiée ont les mêmes caractères lorsqu’elles sont comparées à l’aide de l’option <paramref name="comparisonType" /> spécifiée.</summary>
      <param name="span" vsli:raw="The source span.">Étendue source.</param>
      <param name="other" vsli:raw="The value to compare with the source span.">Valeur à comparer avec l’étendue source.</param>
      <param name="comparisonType" vsli:raw="An enumeration value that determines how &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;other&quot; /&gt; are compared.">Valeur d’énumération qui détermine comment <paramref name="span" /> et <paramref name="other" /> sont comparés.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if equal, &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" /> si elles sont égales ; sinon <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary vsli:raw="Reports the zero-based index of the first occurrence of the specified &lt;paramref name=&quot;value&quot; /&gt; in the current &lt;paramref name=&quot;span&quot; /&gt;.">Signale l’index de base zéro de la première occurrence de la <paramref name="value" /> spécifiée dans la <paramref name="span" /> actuelle.</summary>
      <param name="span" vsli:raw="The source span.">Étendue source.</param>
      <param name="value" vsli:raw="The value to seek within the source span.">Valeur à rechercher dans l’étendue source.</param>
      <param name="comparisonType" vsli:raw="An enumeration value that determines how &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;value&quot; /&gt; are compared.">Valeur d’énumération qui détermine comment <paramref name="span" /> et <paramref name="value" /> sont comparés.</param>
      <returns vsli:raw="The index of the occurrence of the value in the span.">Index de l’occurrence de la valeur dans l’étendue.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf``1(System.ReadOnlySpan{``0},``0)">
      <summary vsli:raw="Searches for the specified value and returns the index of its first occurrence. Values are compared using IEquatable{T}.Equals(T).">Recherche la valeur spécifiée et retourne l’index de sa première occurrence. Les valeurs sont comparées en utilisant IEquatable{T}.Equals(T).</summary>
      <param name="span" vsli:raw="The span to search.">Étendue sur laquelle porte la recherche.</param>
      <param name="value" vsli:raw="The value to search for.">La valeur à rechercher.</param>
      <typeparam name="T" vsli:raw="The type of the span and value.">Type de l’étendue et de la valeur.</typeparam>
      <returns vsli:raw="The index of the occurrence of the value in the span. If not found, returns -1.">Index de l’occurrence de la valeur dans l’étendue. Si non trouvé(e), retourne -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Searches for the specified sequence and returns the index of its first occurrence. Values are compared using IEquatable{T}.Equals(T).">Recherche la séquence spécifiée et retourne l’index de sa première occurrence. Les valeurs sont comparées en utilisant IEquatable{T}.Equals(T).</summary>
      <param name="span" vsli:raw="The span to search.">Étendue sur laquelle porte la recherche.</param>
      <param name="value" vsli:raw="The sequence to search for.">Séquence à rechercher.</param>
      <typeparam name="T" vsli:raw="The type of the span and value.">Type de l’étendue et de la valeur.</typeparam>
      <returns vsli:raw="The index of the occurrence of the value in the span. If not found, returns -1.">Index de l’occurrence de la valeur dans l’étendue. Si non trouvé(e), retourne -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf``1(System.Span{``0},``0)">
      <summary vsli:raw="Searches for the specified value and returns the index of its first occurrence. Values are compared using IEquatable{T}.Equals(T).">Recherche la valeur spécifiée et retourne l’index de sa première occurrence. Les valeurs sont comparées en utilisant IEquatable{T}.Equals(T).</summary>
      <param name="span" vsli:raw="The span to search.">Étendue sur laquelle porte la recherche.</param>
      <param name="value" vsli:raw="The value to search for.">La valeur à rechercher.</param>
      <typeparam name="T" vsli:raw="The type of the span and value.">Type de l’étendue et de la valeur.</typeparam>
      <returns vsli:raw="The index of the occurrence of the value in the span. If not found, returns -1.">Index de l’occurrence de la valeur dans l’étendue. Si non trouvé(e), retourne -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Searches for the specified sequence and returns the index of its first occurrence. Values are compared using IEquatable{T}.Equals(T).">Recherche la séquence spécifiée et retourne l’index de sa première occurrence. Les valeurs sont comparées en utilisant IEquatable{T}.Equals(T).</summary>
      <param name="span" vsli:raw="The span to search.">Étendue sur laquelle porte la recherche.</param>
      <param name="value" vsli:raw="The sequence to search for.">Séquence à rechercher.</param>
      <typeparam name="T" vsli:raw="The type of the span and value.">Type de l’étendue et de la valeur.</typeparam>
      <returns vsli:raw="The index of the occurrence of the value in the span. If not found, returns -1.">Index de l’occurrence de la valeur dans l’étendue. Si non trouvé(e), retourne -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},``0,``0)">
      <summary vsli:raw="Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator.">Recherche le premier index de l’une des valeurs spécifiées similaires à l’appel d’IndexOf plusieurs fois avec l’opérateur OR logique.</summary>
      <param name="span" vsli:raw="The span to search.">Étendue sur laquelle porte la recherche.</param>
      <param name="value0" vsli:raw="One of the values to search for.">Une des valeurs à rechercher.</param>
      <param name="value1" vsli:raw="One of the values to search for.">Une des valeurs à rechercher.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">Type de l’étendue et des valeurs.</typeparam>
      <returns vsli:raw="The first index of the occurrence of any of the values in the span. If not found, returns -1.">Premier index de l’occurrence de l’une des valeurs dans l’étendue. Si non trouvé(e), retourne -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},``0,``0,``0)">
      <summary vsli:raw="Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator.">Recherche le premier index de l’une des valeurs spécifiées similaires à l’appel d’IndexOf plusieurs fois avec l’opérateur OR logique.</summary>
      <param name="span" vsli:raw="The span to search.">Étendue sur laquelle porte la recherche.</param>
      <param name="value0" vsli:raw="One of the values to search for.">Une des valeurs à rechercher.</param>
      <param name="value1" vsli:raw="One of the values to search for.">Une des valeurs à rechercher.</param>
      <param name="value2" vsli:raw="One of the values to search for.">Une des valeurs à rechercher.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">Type de l’étendue et des valeurs.</typeparam>
      <returns vsli:raw="The first index of the occurrence of any of the values in the span. If not found, returns -1.">Premier index de l’occurrence de l’une des valeurs dans l’étendue. Si non trouvé(e), retourne -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator.">Recherche le premier index de l’une des valeurs spécifiées similaires à l’appel d’IndexOf plusieurs fois avec l’opérateur OR logique.</summary>
      <param name="span" vsli:raw="The span to search.">Étendue sur laquelle porte la recherche.</param>
      <param name="values" vsli:raw="The set of values to search for.">Ensemble des valeurs à rechercher.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">Type de l’étendue et des valeurs.</typeparam>
      <returns vsli:raw="The first index of the occurrence of any of the values in the span. If not found, returns -1.">Premier index de l’occurrence de l’une des valeurs dans l’étendue. Si non trouvé(e), retourne -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},``0,``0)">
      <summary vsli:raw="Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator.">Recherche le premier index de l’une des valeurs spécifiées similaires à l’appel d’IndexOf plusieurs fois avec l’opérateur OR logique.</summary>
      <param name="span" vsli:raw="The span to search.">Étendue sur laquelle porte la recherche.</param>
      <param name="value0" vsli:raw="One of the values to search for.">Une des valeurs à rechercher.</param>
      <param name="value1" vsli:raw="One of the values to search for.">Une des valeurs à rechercher.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">Type de l’étendue et des valeurs.</typeparam>
      <returns vsli:raw="The first index of the occurrence of any of the values in the span. If not found, returns -1.">Premier index de l’occurrence de l’une des valeurs dans l’étendue. Si non trouvé(e), retourne -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},``0,``0,``0)">
      <summary vsli:raw="Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator.">Recherche le premier index de l’une des valeurs spécifiées similaires à l’appel d’IndexOf plusieurs fois avec l’opérateur OR logique.</summary>
      <param name="span" vsli:raw="The span to search.">Étendue sur laquelle porte la recherche.</param>
      <param name="value0" vsli:raw="One of the values to search for.">Une des valeurs à rechercher.</param>
      <param name="value1" vsli:raw="One of the values to search for.">Une des valeurs à rechercher.</param>
      <param name="value2" vsli:raw="One of the values to search for.">Une des valeurs à rechercher.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">Type de l’étendue et des valeurs.</typeparam>
      <returns vsli:raw="The first index of the occurrence of any of the values in the span. If not found, returns -1.">Premier index de l’occurrence de l’une des valeurs dans l’étendue. Si non trouvé(e), retourne -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator.">Recherche le premier index de l’une des valeurs spécifiées similaires à l’appel d’IndexOf plusieurs fois avec l’opérateur OR logique.</summary>
      <param name="span" vsli:raw="The span to search.">Étendue sur laquelle porte la recherche.</param>
      <param name="values" vsli:raw="The set of values to search for.">Ensemble des valeurs à rechercher.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">Type de l’étendue et des valeurs.</typeparam>
      <returns vsli:raw="The first index of the occurrence of any of the values in the span. If not found, returns -1.">Premier index de l’occurrence de l’une des valeurs dans l’étendue. Si non trouvé(e), retourne -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IsWhiteSpace(System.ReadOnlySpan{System.Char})">
      <summary vsli:raw="Indicates whether the specified span contains only whitespace characters.">Indique si l’étendue spécifiée contient uniquement des espaces blancs.</summary>
      <param name="span" vsli:raw="The source span.">Étendue source.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span contains only whitespace characters, &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" /> si l’étendue contient uniquement des espaces blancs ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary vsli:raw="Reports the zero-based index of the last occurrence of the specified &lt;paramref name=&quot;value&quot; /&gt; in the current &lt;paramref name=&quot;span&quot; /&gt;.">Signale l’index de base zéro de la dernière occurrence de la <paramref name="value" /> spécifiée dans la <paramref name="span" /> actuelle.</summary>
      <param name="span" vsli:raw="The source span.">Étendue source.</param>
      <param name="value" vsli:raw="The value to seek within the source span.">Valeur à rechercher dans l’étendue source.</param>
      <param name="comparisonType" vsli:raw="An enumeration value that determines how &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;value&quot; /&gt; are compared.">Valeur d’énumération qui détermine comment <paramref name="span" /> et <paramref name="value" /> sont comparés.</param>
      <returns vsli:raw="The index of the last occurrence of the value in the span.">Index de la dernière occurrence de la valeur dans l’étendue.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf``1(System.ReadOnlySpan{``0},``0)">
      <summary vsli:raw="Searches for the specified value and returns the index of its last occurrence. Values are compared using IEquatable{T}.Equals(T).">Recherche la valeur spécifiée et retourne l’index de sa dernière occurrence. Les valeurs sont comparées en utilisant IEquatable{T}.Equals(T).</summary>
      <param name="span" vsli:raw="The span to search.">Étendue sur laquelle porte la recherche.</param>
      <param name="value" vsli:raw="The value to search for.">La valeur à rechercher.</param>
      <typeparam name="T" vsli:raw="The type of the span and value.">Type de l’étendue et de la valeur.</typeparam>
      <returns vsli:raw="The index of the last occurrence of the value in the span. If not found, returns -1.">Index de la dernière occurrence de la valeur dans l’étendue. Si non trouvé(e), retourne -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Searches for the specified sequence and returns the index of its last occurrence. Values are compared using IEquatable{T}.Equals(T).">Recherche la séquence spécifiée et retourne l’index de sa dernière occurrence. Les valeurs sont comparées en utilisant IEquatable{T}.Equals(T).</summary>
      <param name="span" vsli:raw="The span to search.">Étendue sur laquelle porte la recherche.</param>
      <param name="value" vsli:raw="The sequence to search for.">Séquence à rechercher.</param>
      <typeparam name="T" vsli:raw="The type of the span and value.">Type de l’étendue et de la valeur.</typeparam>
      <returns vsli:raw="The index of the last occurrence of the value in the span. If not found, returns -1.">Index de la dernière occurrence de la valeur dans l’étendue. Si non trouvé(e), retourne -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf``1(System.Span{``0},``0)">
      <summary vsli:raw="Searches for the specified value and returns the index of its last occurrence. Values are compared using IEquatable{T}.Equals(T).">Recherche la valeur spécifiée et retourne l’index de sa dernière occurrence. Les valeurs sont comparées en utilisant IEquatable{T}.Equals(T).</summary>
      <param name="span" vsli:raw="The span to search.">Étendue sur laquelle porte la recherche.</param>
      <param name="value" vsli:raw="The value to search for.">La valeur à rechercher.</param>
      <typeparam name="T" vsli:raw="The type of the span and value.">Type de l’étendue et de la valeur.</typeparam>
      <returns vsli:raw="The index of the last occurrence of the value in the span. If not found, returns -1.">Index de la dernière occurrence de la valeur dans l’étendue. Si non trouvé(e), retourne -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Searches for the specified sequence and returns the index of its last occurrence. Values are compared using IEquatable{T}.Equals(T).">Recherche la séquence spécifiée et retourne l’index de sa dernière occurrence. Les valeurs sont comparées en utilisant IEquatable{T}.Equals(T).</summary>
      <param name="span" vsli:raw="The span to search.">Étendue sur laquelle porte la recherche.</param>
      <param name="value" vsli:raw="The sequence to search for.">Séquence à rechercher.</param>
      <typeparam name="T" vsli:raw="The type of the span and value.">Type de l’étendue et de la valeur.</typeparam>
      <returns vsli:raw="The index of the last occurrence of the value in the span. If not found, returns -1.">Index de la dernière occurrence de la valeur dans l’étendue. Si non trouvé(e), retourne -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},``0,``0)">
      <summary vsli:raw="Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator.">Recherche le dernier index de l’une des valeurs spécifiées similaires à l’appel de LastIndexOf plusieurs fois avec l’opérateur OR logique.</summary>
      <param name="span" vsli:raw="The span to search.">Étendue sur laquelle porte la recherche.</param>
      <param name="value0" vsli:raw="One of the values to search for.">Une des valeurs à rechercher.</param>
      <param name="value1" vsli:raw="One of the values to search for.">Une des valeurs à rechercher.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">Type de l’étendue et des valeurs.</typeparam>
      <returns vsli:raw="The index of the last occurrence of any of the values in the span. If not found, returns -1.">Index de la dernière occurrence de l’une des valeurs dans l’étendue. Si non trouvé(e), retourne -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},``0,``0,``0)">
      <summary vsli:raw="Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator.">Recherche le dernier index de l’une des valeurs spécifiées similaires à l’appel de LastIndexOf plusieurs fois avec l’opérateur OR logique.</summary>
      <param name="span" vsli:raw="The span to search.">Étendue sur laquelle porte la recherche.</param>
      <param name="value0" vsli:raw="One of the values to search for.">Une des valeurs à rechercher.</param>
      <param name="value1" vsli:raw="One of the values to search for.">Une des valeurs à rechercher.</param>
      <param name="value2" vsli:raw="One of the values to search for.">Une des valeurs à rechercher.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">Type de l’étendue et des valeurs.</typeparam>
      <returns vsli:raw="The index of the last occurrence of any of the values in the span. If not found, returns -1.">Index de la dernière occurrence de l’une des valeurs dans l’étendue. Si non trouvé(e), retourne -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator.">Recherche le dernier index de l’une des valeurs spécifiées similaires à l’appel de LastIndexOf plusieurs fois avec l’opérateur OR logique.</summary>
      <param name="span" vsli:raw="The span to search.">Étendue sur laquelle porte la recherche.</param>
      <param name="values" vsli:raw="The set of values to search for.">Ensemble des valeurs à rechercher.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">Type de l’étendue et des valeurs.</typeparam>
      <returns vsli:raw="The index of the last occurrence of any of the values in the span. If not found, returns -1.">Index de la dernière occurrence de l’une des valeurs dans l’étendue. Si non trouvé(e), retourne -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},``0,``0)">
      <summary vsli:raw="Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator.">Recherche le dernier index de l’une des valeurs spécifiées similaires à l’appel de LastIndexOf plusieurs fois avec l’opérateur OR logique.</summary>
      <param name="span" vsli:raw="The span to search.">Étendue sur laquelle porte la recherche.</param>
      <param name="value0" vsli:raw="One of the values to search for.">Une des valeurs à rechercher.</param>
      <param name="value1" vsli:raw="One of the values to search for.">Une des valeurs à rechercher.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">Type de l’étendue et des valeurs.</typeparam>
      <returns vsli:raw="The index of the last occurrence of any of the values in the span. If not found, returns -1.">Index de la dernière occurrence de l’une des valeurs dans l’étendue. Si non trouvé(e), retourne -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},``0,``0,``0)">
      <summary vsli:raw="Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator.">Recherche le dernier index de l’une des valeurs spécifiées similaires à l’appel de LastIndexOf plusieurs fois avec l’opérateur OR logique.</summary>
      <param name="span" vsli:raw="The span to search.">Étendue sur laquelle porte la recherche.</param>
      <param name="value0" vsli:raw="One of the values to search for.">Une des valeurs à rechercher.</param>
      <param name="value1" vsli:raw="One of the values to search for.">Une des valeurs à rechercher.</param>
      <param name="value2" vsli:raw="One of the values to search for.">Une des valeurs à rechercher.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">Type de l’étendue et des valeurs.</typeparam>
      <returns vsli:raw="The index of the last occurrence of any of the values in the span. If not found, returns -1.">Index de la dernière occurrence de l’une des valeurs dans l’étendue. Si non trouvé(e), retourne -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator.">Recherche le dernier index de l’une des valeurs spécifiées similaires à l’appel de LastIndexOf plusieurs fois avec l’opérateur OR logique.</summary>
      <param name="span" vsli:raw="The span to search.">Étendue sur laquelle porte la recherche.</param>
      <param name="values" vsli:raw="The set of values to search for.">Ensemble des valeurs à rechercher.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">Type de l’étendue et des valeurs.</typeparam>
      <returns vsli:raw="The index of the last occurrence of any of the values in the span. If not found, returns -1.">Index de la dernière occurrence de l’une des valeurs dans l’étendue. Si non trouvé(e), retourne -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Overlaps``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Determines whether two read-only sequences overlap in memory.">Détermine si deux séquences en lecture seule se chevauchent dans la mémoire.</summary>
      <param name="span" vsli:raw="The first sequence.">Première séquence.</param>
      <param name="other" vsli:raw="The second sequence.">Deuxième séquence.</param>
      <typeparam name="T" vsli:raw="The type of elements in the read-only sequence.">Type de éléments dans la séquence en lecture seule.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two sequences overlap; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si les deux séquences se chevauchent ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Overlaps``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Int32@)">
      <summary vsli:raw="Determines whether two read-only sequences overlap in memory and outputs the element offset.">Détermine si deux séquences en lecture seule se chevauchent dans la mémoire et génère le décalage des éléments.</summary>
      <param name="span" vsli:raw="The first sequence.">Première séquence.</param>
      <param name="other" vsli:raw="The second sequence.">Deuxième séquence.</param>
      <param name="elementOffset" vsli:raw="When the method returns, contains the offset between &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;other&quot; /&gt;." />
      <typeparam name="T" vsli:raw="The type of elements in the span.">Type des éléments de l’étendue.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two sequences overlap; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si les deux séquences se chevauchent ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Overlaps``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Determines whether a span and a read-only span overlap in memory.">Détermine si une étendue et une étendue en lecture seule se chevauchent dans la mémoire.</summary>
      <param name="span" vsli:raw="The span to compare.">Étendue à comparer.</param>
      <param name="other" vsli:raw="The read-only span to compare.">Étendue en lecture seule à comparer.</param>
      <typeparam name="T" vsli:raw="The type of elements in the span.">Type des éléments de l’étendue.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two sequences overlap; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si les deux séquences se chevauchent ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Overlaps``1(System.Span{``0},System.ReadOnlySpan{``0},System.Int32@)">
      <summary vsli:raw="Determines whether a span and a read-only span overlap in memory and outputs the element offset.">Détermine si une étendue et une étendue en lecture seule se chevauchent dans la mémoire et génère le décalage des éléments.</summary>
      <param name="span" vsli:raw="The first sequence to compare.">Première séquence à comparer.</param>
      <param name="other" vsli:raw="The second sequence to compare.">Seconde séquence à comparer.</param>
      <param name="elementOffset" vsli:raw="When the method returns, contains the offset between &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;other&quot; /&gt;.">Quand la méthode retourne, contient le décalage entre <paramref name="span" /> et <paramref name="other" />.</param>
      <typeparam name="T" vsli:raw="The type of elements in the span.">Type des éléments de l’étendue.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two sequences overlap; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si les deux séquences se chevauchent ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Reverse``1(System.Span{``0})">
      <summary vsli:raw="Reverses the sequence of the elements in the entire span.">Inverse la séquence des éléments dans l’intégralité de l’étendue.</summary>
      <param name="span" vsli:raw="The span to reverse.">Étendue à inverser.</param>
      <typeparam name="T" vsli:raw="The type of elements in the span.">Type des éléments de l’étendue.</typeparam>
    </member>
    <member name="M:System.MemoryExtensions.SequenceCompareTo``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Determines the relative order of two read-only sequences by comparing their elements using IComparable{T}.CompareTo(T).">Détermine l’ordre relatif de deux séquences en lecture seule en comparant leurs éléments avec IComparable{T}.CompareTo(T).</summary>
      <param name="span" vsli:raw="The first sequence to compare.">Première séquence à comparer.</param>
      <param name="other" vsli:raw="The second sequence to compare.">Seconde séquence à comparer.</param>
      <typeparam name="T" vsli:raw="The type of elements in the sequence.">Type des éléments de la séquence.</typeparam>
      <returns vsli:raw="A signed integer that indicates the relative order of &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;other&quot; /&gt;:&lt;br /&gt;   - If less than 0, &lt;paramref name=&quot;span&quot; /&gt; precedes than &lt;paramref name=&quot;other&quot; /&gt;.&lt;br /&gt;   - If 0, &lt;paramref name=&quot;span&quot; /&gt; equals &lt;paramref name=&quot;other&quot; /&gt;.&lt;br /&gt;   - If greater than 0, &lt;paramref name=&quot;span&quot; /&gt; follows &lt;paramref name=&quot;other&quot; /&gt;.">Entier signé qui indique l’ordre relatif de <paramref name="span" /> et <paramref name="other" /> :   - S’il est inférieur à 0, <paramref name="span" /> précède à <paramref name="other" />.   - S’il est égal à 0, <paramref name="span" /> est égal à <paramref name="other" />.   - S’il est supérieur à 0, <paramref name="span" /> suit <paramref name="other" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.SequenceCompareTo``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Determines the relative order of a span and a read-only span by comparing the elements using IComparable{T}.CompareTo(T).">Détermine l’ordre relatif d’une étendue et d’une étendue en lecture seule en comparant les éléments avec IComparable{T}.CompareTo(T).</summary>
      <param name="span" vsli:raw="The span to compare.">Étendue à comparer.</param>
      <param name="other" vsli:raw="The read-only span to compare.">Étendue en lecture seule à comparer.</param>
      <typeparam name="T" vsli:raw="The type of elements in the span.">Type des éléments de l’étendue.</typeparam>
      <returns vsli:raw="A signed integer that indicates the relative order of &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;other&quot; /&gt;:&lt;br /&gt;   - If less than 0, &lt;paramref name=&quot;span&quot; /&gt; precedes than &lt;paramref name=&quot;other&quot; /&gt;.&lt;br /&gt;   - If 0, &lt;paramref name=&quot;span&quot; /&gt; equals &lt;paramref name=&quot;other&quot; /&gt;.&lt;br /&gt;   - If greater than 0, &lt;paramref name=&quot;span&quot; /&gt; follows &lt;paramref name=&quot;other&quot; /&gt;.">Entier signé qui indique l’ordre relatif de <paramref name="span" /> et <paramref name="other" /> :   - S’il est inférieur à 0, <paramref name="span" /> précède à <paramref name="other" />.   - S’il est égal à 0, <paramref name="span" /> est égal à <paramref name="other" />.   - S’il est supérieur à 0, <paramref name="span" /> suit <paramref name="other" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.SequenceEqual``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Determines whether two read-only sequences are equal by comparing the elements using IEquatable{T}.Equals(T).">Détermine si deux séquences en lecture seule sont égales en comparant les éléments avec IEquatable{T}.Equals(T).</summary>
      <param name="span" vsli:raw="The first sequence to compare.">Première séquence à comparer.</param>
      <param name="other" vsli:raw="The second sequence to compare.">Seconde séquence à comparer.</param>
      <typeparam name="T" vsli:raw="The type of elements in the sequence.">Type des éléments de la séquence.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two sequences are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si les deux séquences sont égales ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.SequenceEqual``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Determines whether a span and a read-only span are equal by comparing the elements using IEquatable{T}.Equals(T).">Détermine si une étendue et une étendue en lecture seule sont égales en comparant les éléments avec IEquatable{T}.Equals(T).</summary>
      <param name="span" vsli:raw="The span to compare.">Étendue à comparer.</param>
      <param name="other" vsli:raw="The read-only span to compare.">Étendue en lecture seule à comparer.</param>
      <typeparam name="T" vsli:raw="The type of elements in the sequence.">Type des éléments de la séquence.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two sequences are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si les deux séquences sont égales ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.StartsWith(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary vsli:raw="Determines whether a read-only character span begins with a specified value when compared using a specified &lt;see cref=&quot;T:System.StringComparison&quot; /&gt; value.">Détermine si une étendue de caractères en lecture seule commence par une valeur spécifiée lors d’une comparaison avec une valeur <see cref="T:System.StringComparison" /> spécifiée.</summary>
      <param name="span" vsli:raw="The source span.">Étendue source.</param>
      <param name="value" vsli:raw="The sequence to compare to the beginning of the source span.">Séquence à comparer au début de l’étendue source.</param>
      <param name="comparisonType" vsli:raw="An enumeration value that determines how &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;value&quot; /&gt; are compared.">Valeur d’énumération qui détermine comment <paramref name="span" /> et <paramref name="value" /> sont comparés.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;value&quot; /&gt; matches the beginning of &lt;paramref name=&quot;span&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si <paramref name="value" /> correspond au début de <paramref name="span" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.StartsWith``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Determines whether a specified sequence appears at the start of a read-only span.">Détermine si une séquence spécifiée apparaît au début d’une étendue en lecture seule.</summary>
      <param name="span" vsli:raw="The read-only character span to search.">Étendue de caractères en lecture seule dans laquelle rechercher.</param>
      <param name="value" vsli:raw="A sequence to search for at the start of &lt;paramref name=&quot;span&quot; /&gt;.">Séquence à rechercher au début de <paramref name="span" />.</param>
      <typeparam name="T" vsli:raw="The type of elements in the span.">Type des éléments de l’étendue.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;value&quot; /&gt; matches the beginning of &lt;paramref name=&quot;span&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si <paramref name="value" /> correspond au début de <paramref name="span" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.StartsWith``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Determines whether a specified sequence appears at the start of a span.">Détermine si une séquence spécifiée apparaît au début d’une étendue.</summary>
      <param name="span" vsli:raw="The span to search.">Étendue sur laquelle porte la recherche.</param>
      <param name="value" vsli:raw="A sequence to search for at the start of &lt;paramref name=&quot;span&quot; /&gt;.">Séquence à rechercher au début de <paramref name="span" />.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the span.">Type des éléments de l’étendue.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;value&quot; /&gt; matches the beginning of &lt;paramref name=&quot;span&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si <paramref name="value" /> correspond au début de <paramref name="span" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.ToLower(System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Globalization.CultureInfo)">
      <summary vsli:raw="Copies the characters from the source span into the destination, converting each character to lowercase, using the casing rules of the specified culture.">Copie les caractères de l’étendue source dans la destination en convertissant chaque caractère en minuscules, à l’aide des règles de casse de la culture spécifiée.</summary>
      <param name="source" vsli:raw="The source span.">Étendue source.</param>
      <param name="destination" vsli:raw="The destination span which contains the transformed characters.">Étendue de destination qui contient les caractères transformés.</param>
      <param name="culture" vsli:raw="An object that supplies culture-specific casing rules.">Objet qui fournit les règles de casse propres à la culture.</param>
      <returns vsli:raw="The number of characters written into the destination span. If the destination is too small, returns -1.">Nombre de caractères écrits dans l’étendue de destination. Si la destination est trop petite, retourne-1.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The source and destination buffers overlap.">Les mémoires tampon source et de destination se chevauchent.</exception>
    </member>
    <member name="M:System.MemoryExtensions.ToLowerInvariant(System.ReadOnlySpan{System.Char},System.Span{System.Char})">
      <summary vsli:raw="Copies the characters from the source span into the destination, converting each character to lowercase, using the casing rules of the invariant culture.">Copie les caractères de l’étendue source dans la destination en convertissant chaque caractère en minuscules, à l’aide des règles de casse de la culture invariante.</summary>
      <param name="source" vsli:raw="The source span.">Étendue source.</param>
      <param name="destination" vsli:raw="The destination span which contains the transformed characters.">Étendue de destination qui contient les caractères transformés.</param>
      <returns vsli:raw="The number of characters written into the destination span. If the destination is too small, returns -1.">Nombre de caractères écrits dans l’étendue de destination. Si la destination est trop petite, retourne-1.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The source and destination buffers overlap.">Les mémoires tampon source et de destination se chevauchent.</exception>
    </member>
    <member name="M:System.MemoryExtensions.ToUpper(System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Globalization.CultureInfo)">
      <summary vsli:raw="Copies the characters from the source span into the destination, converting each character to uppercase, using the casing rules of the specified culture.">Copie les caractères de l’étendue source dans la destination en convertissant chaque caractère en majuscules, à l’aide des règles de casse de la culture spécifiée.</summary>
      <param name="source" vsli:raw="The source span.">Étendue source.</param>
      <param name="destination" vsli:raw="The destination span which contains the transformed characters.">Étendue de destination qui contient les caractères transformés.</param>
      <param name="culture" vsli:raw="An object that supplies culture-specific casing rules.">Objet qui fournit les règles de casse propres à la culture.</param>
      <returns vsli:raw="The number of characters written into the destination span. If the destination is too small, returns -1.">Nombre de caractères écrits dans l’étendue de destination. Si la destination est trop petite, retourne-1.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The source and destination buffers overlap.">Les mémoires tampon source et de destination se chevauchent.</exception>
    </member>
    <member name="M:System.MemoryExtensions.ToUpperInvariant(System.ReadOnlySpan{System.Char},System.Span{System.Char})">
      <summary vsli:raw="Copies the characters from the source span into the destination, converting each character to uppercase using the casing rules of the invariant culture.">Copie les caractères de l’étendue source dans la destination en convertissant chaque caractère en majuscules, à l’aide des règles de casse de la culture invariante.</summary>
      <param name="source" vsli:raw="The source span.">Étendue source.</param>
      <param name="destination" vsli:raw="The destination span which contains the transformed characters.">Étendue de destination qui contient les caractères transformés.</param>
      <returns vsli:raw="The number of characters written into the destination span. If the destination is too small, returns -1.">Nombre de caractères écrits dans l’étendue de destination. Si la destination est trop petite, retourne-1.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The source and destination buffers overlap.">Les mémoires tampon source et de destination se chevauchent.</exception>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.Memory{System.Char})">
      <summary vsli:raw="Removes all leading and trailing whitespace characters from a character memory region.">Supprime tous les espaces blancs de début et de fin d’une région de mémoire de caractères.</summary>
      <param name="memory" vsli:raw="The source memory from which the characters are removed.">Mémoire source de laquelle les caractères sont supprimés.</param>
      <returns vsli:raw="The trimmed character memory region.">Région de mémoire de caractères tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.ReadOnlyMemory{System.Char})">
      <summary vsli:raw="Removes all leading and trailing whitespace characters from a read-only character memory region.">Supprime tous les espaces blancs de début et de fin d’une région de mémoire de caractères en lecture seule.</summary>
      <param name="memory" vsli:raw="The source memory from which the characters are removed.">Mémoire source de laquelle les caractères sont supprimés.</param>
      <returns vsli:raw="The trimmed character memory region.">Région de mémoire de caractères tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char})">
      <summary vsli:raw="Removes all leading and trailing whitespace characters from a read-only character span.">Supprime tous les espaces blancs de début et de fin d’une étendue de caractères en lecture seule.</summary>
      <param name="span" vsli:raw="The source span from which the characters are removed.">Étendue source de laquelle les caractères sont supprimés.</param>
      <returns vsli:raw="The trimmed read-only character span.">Étendue de caractères en lecture seule tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char},System.Char)">
      <summary vsli:raw="Removes all leading and trailing occurrences of a specified character from a read-only character span.">Supprime d’une étendue de caractères en lecture seule toutes les occurrences de début et de fin d’un caractère spécifié.</summary>
      <param name="span" vsli:raw="The source span from which the character is removed.">Étendue source de laquelle le caractère est supprimé.</param>
      <param name="trimChar" vsli:raw="The specified character to look for and remove.">Caractère spécifié à rechercher et à supprimer.</param>
      <returns vsli:raw="The trimmed read-only character span.">Étendue de caractères en lecture seule tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
      <summary vsli:raw="Removes all leading and trailing occurrences of a set of characters specified in a read-only span from a read-only character span.">Supprime d’une étendue de caractères en lecture seule toutes les occurrences de début et de fin d’un jeu de caractères spécifié dans une étendue en lecture seule.</summary>
      <param name="span" vsli:raw="The source span from which the characters are removed.">Étendue source de laquelle les caractères sont supprimés.</param>
      <param name="trimChars" vsli:raw="The span which contains the set of characters to remove.">Étendue qui contient le jeu de caractères à supprimer.</param>
      <returns vsli:raw="The trimmed read-only character span.">Étendue de caractères en lecture seule tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.Span{System.Char})">
      <summary vsli:raw="Removes all leading and trailing whitespace characters from a character span.">Supprime tous les espaces blancs de début et de fin d’une étendue de caractères.</summary>
      <param name="span" vsli:raw="The source span from which the characters are removed.">Étendue source de laquelle les caractères sont supprimés.</param>
      <returns vsli:raw="The trimmed character span.">Étendue de caractères tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.Memory{``0},``0)">
      <summary vsli:raw="Removes all leading and trailing occurrences of a specified element from a memory region.">Supprime d’une région de mémoire toutes les occurrences de début et de fin d’un élément spécifié.</summary>
      <param name="memory" vsli:raw="The source memory from which the element is removed.">Mémoire source de laquelle l’élément est supprimé.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">Élément spécifié à rechercher et à supprimer.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the memory region.">Type des éléments dans la région de la mémoire.</typeparam>
      <returns vsli:raw="The trimmed memory region.">Région de mémoire tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.Memory{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all leading and trailing occurrences of a set of elements specified in a read-only span from a memory region.">Supprime d’une région de mémoire toutes les occurrences de début et de fin d’un jeu d’éléments spécifié dans une étendue en lecture seule.</summary>
      <param name="memory" vsli:raw="The source memory from which the elements are removed.">Mémoire source de laquelle les éléments sont supprimés.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">Étendue qui contient le jeu d’éléments à supprimer.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the memory region.">Type des éléments dans la région de la mémoire.</typeparam>
      <returns vsli:raw="The trimmed memory region.">Région de mémoire tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlyMemory{``0},``0)">
      <summary vsli:raw="Removes all leading and trailing occurrences of a specified element from a read-only memory region.">Supprime d’une région de mémoire en lecture seule toutes les occurrences de début et de fin d’un élément spécifié.</summary>
      <param name="memory" vsli:raw="The source memory from which the element is removed.">Mémoire source de laquelle l’élément est supprimé.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">Élément spécifié à rechercher et à supprimer.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only memory region.">Type des éléments dans la zone de mémoire en lecture seule.</typeparam>
      <returns vsli:raw="The trimmed read-only memory region.">Région de mémoire en lecture seule tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all leading and trailing occurrences of a set of elements specified in a read-only span from a read-only memory region.">Supprime d’une région de mémoire en lecture seule toutes les occurrences de début et de fin d’un jeu d’éléments spécifié dans une étendue en lecture seule.</summary>
      <param name="memory" vsli:raw="The source memory from which the elements are removed.">Mémoire source de laquelle les éléments sont supprimés.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">Étendue qui contient le jeu d’éléments à supprimer.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only memory region.">Type des éléments dans la zone de mémoire en lecture seule.</typeparam>
      <returns vsli:raw="The trimmed read-only memory region.">Région de mémoire en lecture seule tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlySpan{``0},``0)">
      <summary vsli:raw="Removes all leading and trailing occurrences of a specified element from a read-only span.">Supprime toutes les occurrences de début et de fin d’un élément spécifié d’une étendue en lecture seule.</summary>
      <param name="span" vsli:raw="The source span from which the element is removed.">Étendue source de laquelle l’élément est supprimé.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">Élément spécifié à rechercher et à supprimer.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only span.">Type des éléments de l’étendue en lecture seule.</typeparam>
      <returns vsli:raw="The trimmed read-only span.">Étendue en lecture seule tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all leading and trailing occurrences of a set of elements specified in a read-only span from a read-only span.">Supprime d’une étendue en lecture seule toutes les occurrences de début et de fin d’un jeu d’éléments spécifié dans une étendue en lecture seule.</summary>
      <param name="span" vsli:raw="The source span from which the elements are removed.">Étendue source de laquelle les éléments sont supprimés.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">Étendue qui contient le jeu d’éléments à supprimer.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only span.">Type des éléments de l’étendue en lecture seule.</typeparam>
      <returns vsli:raw="The trimmed read-only span.">Étendue en lecture seule tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.Span{``0},``0)">
      <summary vsli:raw="Removes all leading and trailing occurrences of a specified element from a span.">Supprime d’une étendue toutes les occurrences de début et de fin d’un élément spécifié.</summary>
      <param name="span" vsli:raw="The source span from which the element is removed.">Étendue source de laquelle l’élément est supprimé.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">Élément spécifié à rechercher et à supprimer.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the span.">Type des éléments de l’étendue.</typeparam>
      <returns vsli:raw="The trimmed span.">Étendue tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all leading and trailing occurrences of a set of elements specified in a read-only span from a span.">Supprime d’une étendue toutes les occurrences de début et de fin d’un jeu d’éléments spécifié dans une étendue en lecture seule.</summary>
      <param name="span" vsli:raw="The source span from which the elements are removed.">Étendue source de laquelle les éléments sont supprimés.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">Étendue qui contient le jeu d’éléments à supprimer.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the span.">Type des éléments de l’étendue.</typeparam>
      <returns vsli:raw="The trimmed span.">Étendue tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.Memory{System.Char})">
      <summary vsli:raw="Removes all trailing whitespace characters from a character memory region.">Supprime tous les espaces blancs de fin d’une région de mémoire de caractères.</summary>
      <param name="memory" vsli:raw="The source memory from which the characters are removed.">Mémoire source de laquelle les caractères sont supprimés.</param>
      <returns vsli:raw="The trimmed character memory region.">Région de mémoire de caractères tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlyMemory{System.Char})">
      <summary vsli:raw="Removes all trailing whitespace characters from a read-only character memory region.">Supprime tous les espaces blancs de fin d’une région de mémoire de caractères en lecture seule.</summary>
      <param name="memory" vsli:raw="The source memory from which the characters are removed.">Mémoire source de laquelle les caractères sont supprimés.</param>
      <returns vsli:raw="The trimmed read-only character span.">Étendue de caractères en lecture seule tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char})">
      <summary vsli:raw="Removes all trailing whitespace characters from a read-only character span.">Supprime tous les espaces blancs de fin d’une étendue de caractères en lecture seule.</summary>
      <param name="span" vsli:raw="The source span from which the characters are removed.">Étendue source de laquelle les caractères sont supprimés.</param>
      <returns vsli:raw="The trimmed read-only character span.">Étendue de caractères en lecture seule tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char},System.Char)">
      <summary vsli:raw="Removes all trailing occurrences of a specified character from a read-only span.">Supprime toutes les occurrences de fin d’un caractère spécifié d’une étendue en lecture seule.</summary>
      <param name="span" vsli:raw="The source span from which the character is removed.">Étendue source de laquelle le caractère est supprimé.</param>
      <param name="trimChar" vsli:raw="The specified character to look for and remove.">Caractère spécifié à rechercher et à supprimer.</param>
      <returns vsli:raw="The trimmed read-only character span.">Étendue de caractères en lecture seule tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
      <summary vsli:raw="Removes all trailing occurrences of a set of characters specified in a read-only span from a read-only character span.">Supprime d’une étendue de caractères en lecture seule toutes les occurrences de fin d’un jeu de caractères spécifié dans une étendue en lecture seule.</summary>
      <param name="span" vsli:raw="The source span from which the characters are removed.">Étendue source de laquelle les caractères sont supprimés.</param>
      <param name="trimChars" vsli:raw="The span which contains the set of characters to remove.">Étendue qui contient le jeu de caractères à supprimer.</param>
      <returns vsli:raw="The trimmed read-only character span.">Étendue de caractères en lecture seule tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.Span{System.Char})">
      <summary vsli:raw="Removes all trailing whitespace characters from a character span.">Supprime tous les espaces blancs de fin d’une étendue de caractères.</summary>
      <param name="span" vsli:raw="The source span from which the characters are removed.">Étendue source de laquelle les caractères sont supprimés.</param>
      <returns vsli:raw="The trimmed character span.">Étendue de caractères tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.Memory{``0},``0)">
      <summary vsli:raw="Removes all trailing occurrences of a specified element from a character memory region.">Supprime d’une région de mémoire de caractères toutes les occurrences de fin d’un élément spécifié.</summary>
      <param name="memory" vsli:raw="The source memory from which the element is removed.">Mémoire source de laquelle l’élément est supprimé.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">Élément spécifié à rechercher et à supprimer.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the memory region.">Type des éléments dans la région de la mémoire.</typeparam>
      <returns vsli:raw="The trimmed memory region.">Région de mémoire tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.Memory{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all trailing occurrences of a set of elements specified in a read-only span from a memory region.">Supprime d’une région de mémoire toutes les occurrences de fin d’un jeu d’éléments spécifié dans une étendue en lecture seule.</summary>
      <param name="memory" vsli:raw="The source memory from which the elements are removed.">Mémoire source de laquelle les éléments sont supprimés.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">Étendue qui contient le jeu d’éléments à supprimer.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the memory region.">Type des éléments dans la région de la mémoire.</typeparam>
      <returns vsli:raw="The trimmed memory region.">Région de mémoire tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlyMemory{``0},``0)">
      <summary vsli:raw="Removes all trailing occurrences of a specified element from a read-only memory region.">Supprime d’une région de mémoire en lecture seule toutes les occurrences de fin d’un élément spécifié.</summary>
      <param name="memory" vsli:raw="The source memory from which the element is removed.">Mémoire source de laquelle l’élément est supprimé.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">Élément spécifié à rechercher et à supprimer.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only memory region.">Type des éléments dans la zone de mémoire en lecture seule.</typeparam>
      <returns vsli:raw="The trimmed read-only memory region.">Région de mémoire en lecture seule tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all trailing occurrences of a set of elements specified in a read-only span from a read-only memory region.">Supprime d’une région de mémoire en lecture seule toutes les occurrences de fin d’un jeu d’éléments spécifié dans une étendue en lecture seule.</summary>
      <param name="memory" vsli:raw="The source memory from which the elements are removed.">Mémoire source de laquelle les éléments sont supprimés.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">Étendue qui contient le jeu d’éléments à supprimer.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only memory region.">Type des éléments dans la zone de mémoire en lecture seule.</typeparam>
      <returns vsli:raw="The trimmed read-only memory region.">Région de mémoire en lecture seule tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlySpan{``0},``0)">
      <summary vsli:raw="Removes all trailing occurrences of a specified element from a read-only span.">Supprime d’une étendue en lecture seule toutes les occurrences de fin d’un élément spécifié.</summary>
      <param name="span" vsli:raw="The source span from which the element is removed.">Étendue source de laquelle l’élément est supprimé.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">Élément spécifié à rechercher et à supprimer.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only span.">Type des éléments de l’étendue en lecture seule.</typeparam>
      <returns vsli:raw="The trimmed read-only span.">Étendue en lecture seule tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all trailing occurrences of a set of elements specified in a read-only span from a read-only span.">Supprime d’une étendue en lecture seule toutes les occurrences de fin d’un jeu d’éléments spécifié dans une étendue en lecture seule.</summary>
      <param name="span" vsli:raw="The source span from which the elements are removed.">Étendue source de laquelle les éléments sont supprimés.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">Étendue qui contient le jeu d’éléments à supprimer.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only span.">Type des éléments de l’étendue en lecture seule.</typeparam>
      <returns vsli:raw="The trimmed read-only span.">Étendue en lecture seule tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.Span{``0},``0)">
      <summary vsli:raw="Removes all trailing occurrences of a specified element from a span.">Supprime d’une étendue toutes les occurrences de fin d’un élément spécifié.</summary>
      <param name="span" vsli:raw="The source span from which the element is removed.">Étendue source de laquelle l’élément est supprimé.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">Élément spécifié à rechercher et à supprimer.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the span.">Type des éléments de l’étendue.</typeparam>
      <returns vsli:raw="The trimmed span.">Étendue tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all trailing occurrences of a set of elements specified in a read-only span from a span.">Supprime d’une étendue toutes les occurrences de fin d’un jeu d’éléments spécifié dans une étendue en lecture seule.</summary>
      <param name="span" vsli:raw="The source span from which the elements are removed.">Étendue source de laquelle les éléments sont supprimés.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">Étendue qui contient le jeu d’éléments à supprimer.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the span.">Type des éléments de l’étendue.</typeparam>
      <returns vsli:raw="The trimmed span.">Étendue tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.Memory{System.Char})">
      <summary vsli:raw="Removes all leading whitespace characters from a memory region.">Supprime tous les espaces blancs de début d’une région de mémoire.</summary>
      <param name="memory" vsli:raw="The source memory from which the characters are removed.">Mémoire source de laquelle les caractères sont supprimés.</param>
      <returns vsli:raw="The trimmed character memory region.">Région de mémoire de caractères tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlyMemory{System.Char})">
      <summary vsli:raw="Removes all leading whitespace characters from a read-only memory region.">Supprime tous les espaces blancs de début d’une région de mémoire en lecture seule.</summary>
      <param name="memory" vsli:raw="The source memory from which the characters are removed.">Mémoire source de laquelle les caractères sont supprimés.</param>
      <returns vsli:raw="The trimmed read-only character memory region.">Région de mémoire de caractères en lecture seule tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char})">
      <summary vsli:raw="Removes all leading whitespace characters from a read-only span.">Supprime tous les espaces blancs de début d’une étendue en lecture seule.</summary>
      <param name="span" vsli:raw="The source span from which the characters are removed.">Étendue source de laquelle les caractères sont supprimés.</param>
      <returns vsli:raw="The trimmed read-only character span.">Étendue de caractères en lecture seule tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char},System.Char)">
      <summary vsli:raw="Removes all leading occurrences of a specified character from the span.">Supprime de l’étendue toutes les occurrences de début d’un caractère spécifié.</summary>
      <param name="span" vsli:raw="The source span from which the character is removed.">Étendue source de laquelle le caractère est supprimé.</param>
      <param name="trimChar" vsli:raw="The specified character to look for and remove.">Caractère spécifié à rechercher et à supprimer.</param>
      <returns vsli:raw="The trimmed read-only character span.">Étendue de caractères en lecture seule tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
      <summary vsli:raw="Removes all leading occurrences of a set of characters specified in a read-only span from the span.">Supprime de l’étendue toutes les occurrences de début d’un jeu de caractères spécifiés dans une étendue en lecture seule.</summary>
      <param name="span" vsli:raw="The source span from which the characters are removed.">Étendue source de laquelle les caractères sont supprimés.</param>
      <param name="trimChars" vsli:raw="The span which contains the set of characters to remove.">Étendue qui contient le jeu de caractères à supprimer.</param>
      <returns vsli:raw="The trimmed read-only character span.">Étendue de caractères en lecture seule tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.Span{System.Char})">
      <summary vsli:raw="Removes all leading whitespace characters from a span.">Supprime tous les espaces blancs de début d’une étendue.</summary>
      <param name="span" vsli:raw="The source span from which the characters are removed.">Étendue source de laquelle les caractères sont supprimés.</param>
      <returns vsli:raw="The trimmed character span.">Étendue de caractères tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.Memory{``0},``0)">
      <summary vsli:raw="Removes all leading occurrences of a specified element from a memory region.">Supprime d’une région de mémoire toutes les occurrences de début d’un élément spécifié.</summary>
      <param name="memory" vsli:raw="The source memory region from which the element is removed.">Région de mémoire source de laquelle l’élément est supprimé.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">Élément spécifié à rechercher et à supprimer.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the memory region.">Type des éléments dans la région de la mémoire.</typeparam>
      <returns vsli:raw="The trimmed memory region.">Région de mémoire tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.Memory{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all leading occurrences of a set of elements specified in a read-only span from a memory region.">Supprime d’une région de mémoire toutes les occurrences de début d’un jeu d’éléments spécifié dans une étendue en lecture seule.</summary>
      <param name="memory" vsli:raw="The source memory from which the elements are removed.">Mémoire source de laquelle les éléments sont supprimés.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">Étendue qui contient le jeu d’éléments à supprimer.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the memory region.">Type des éléments dans la région de la mémoire.</typeparam>
      <returns vsli:raw="The trimmed memory region.">Région de mémoire tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlyMemory{``0},``0)">
      <summary vsli:raw="Removes all leading occurrences of a specified element from a memory region.">Supprime d’une région de mémoire toutes les occurrences de début d’un élément spécifié.</summary>
      <param name="memory" vsli:raw="The source memory from which the element is removed.">Mémoire source de laquelle l’élément est supprimé.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">Élément spécifié à rechercher et à supprimer.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only memory region.">Type des éléments dans la zone de mémoire en lecture seule.</typeparam>
      <returns vsli:raw="The trimmed read-only memory region.">Région de mémoire en lecture seule tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all leading occurrences of a set of elements specified in a read-only span from a memory region.">Supprime d’une région de mémoire toutes les occurrences de début d’un jeu d’éléments spécifié dans une étendue en lecture seule.</summary>
      <param name="memory" vsli:raw="The source memory from which the elements are removed.">Mémoire source de laquelle les éléments sont supprimés.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">Étendue qui contient le jeu d’éléments à supprimer.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only memory region.">Type des éléments dans la zone de mémoire en lecture seule.</typeparam>
      <returns vsli:raw="The trimmed read-only memory region.">Région de mémoire en lecture seule tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlySpan{``0},``0)">
      <summary vsli:raw="Removes all leading occurrences of a specified element from the span.">Supprime de l’étendue toutes les occurrences de début d’un élément spécifié.</summary>
      <param name="span" vsli:raw="The source span from which the element is removed.">Étendue source de laquelle l’élément est supprimé.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">Élément spécifié à rechercher et à supprimer.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only span.">Type des éléments de l’étendue en lecture seule.</typeparam>
      <returns vsli:raw="The trimmed read-only span.">Étendue en lecture seule tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all leading occurrences of a set of elements specified in a read-only span from the span.">Supprime d’une étendue toutes les occurrences de début d’un jeu d’éléments spécifié dans une étendue en lecture seule.</summary>
      <param name="span" vsli:raw="The source span from which the elements are removed.">Étendue source de laquelle les éléments sont supprimés.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">Étendue qui contient le jeu d’éléments à supprimer.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only span.">Type des éléments de l’étendue en lecture seule.</typeparam>
      <returns vsli:raw="The trimmed read-only span.">Étendue en lecture seule tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.Span{``0},``0)">
      <summary vsli:raw="Removes all leading occurrences of a specified element from the span.">Supprime de l’étendue toutes les occurrences de début d’un élément spécifié.</summary>
      <param name="span" vsli:raw="The source span from which the element is removed.">Étendue source de laquelle l’élément est supprimé.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">Élément spécifié à rechercher et à supprimer.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the span.">Type des éléments de l’étendue.</typeparam>
      <returns vsli:raw="The trimmed span.">Étendue tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all leading occurrences of a set of elements specified in a read-only span from the span.">Supprime d’une étendue toutes les occurrences de début d’un jeu d’éléments spécifié dans une étendue en lecture seule.</summary>
      <param name="span" vsli:raw="The source span from which the elements are removed.">Étendue source de laquelle les éléments sont supprimés.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">Étendue qui contient le jeu d’éléments à supprimer.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the span.">Type des éléments de l’étendue.</typeparam>
      <returns vsli:raw="The trimmed span.">Étendue tronquée.</returns>
    </member>
    <member name="T:System.Runtime.InteropServices.MemoryMarshal">
      <summary vsli:raw="Provides methods to interoperate with &lt;see cref=&quot;T:System.Memory`1&quot; /&gt;, &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt;,  &lt;see cref=&quot;T:System.Span`1&quot; /&gt;, and  &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt;.">Fournit des méthodes pour interagir avec <see cref="T:System.Memory`1" />, <see cref="T:System.ReadOnlyMemory`1" />, <see cref="T:System.Span`1" /> et <see cref="T:System.ReadOnlySpan`1" />.</summary>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsBytes``1(System.ReadOnlySpan{``0})">
      <summary vsli:raw="Casts a &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; of one primitive type, &lt;paramref name=&quot;T&quot; /&gt;, to a &lt;see langword=&quot;ReadOnlySpan&amp;lt;Byte&amp;gt;&quot; /&gt;.">Convertit un élément <see cref="T:System.ReadOnlySpan`1" /> d’un type primitif, <paramref name="T" />, en un élément <see langword="ReadOnlySpan&lt;Byte&gt;" />.</summary>
      <param name="span" vsli:raw="The source slice to convert.">Section source à convertir.</param>
      <typeparam name="T" vsli:raw="The type of items in the read-only span.">Type des éléments de l’étendue en lecture seule.</typeparam>
      <returns vsli:raw="A read-only span of type &lt;see cref=&quot;T:System.Byte&quot; /&gt;.">Étendue en lecture seule de type <see cref="T:System.Byte" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;T&quot; /&gt; contains managed object references.">
        <paramref name="T" /> contient des références ou des pointeurs.</exception>
      <exception cref="T:System.OverflowException" vsli:raw="The &lt;see cref=&quot;P:System.ReadOnlySpan`1.Length&quot; /&gt; property of the new &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; would exceed &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;">La propriété <see cref="P:System.ReadOnlySpan`1.Length" /> du nouveau <see cref="T:System.ReadOnlySpan`1" /> dépasserait <see cref="F:System.Int32.MaxValue" /></exception>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsBytes``1(System.Span{``0})">
      <summary vsli:raw="Casts a &lt;see cref=&quot;T:System.Span`1&quot; /&gt; of one primitive type, &lt;paramref name=&quot;T&quot; /&gt;, to a &lt;see langword=&quot;Span&amp;lt;Byte&amp;gt;&quot; /&gt;.">Convertit un élément <see cref="T:System.Span`1" /> d’un type primitif, <paramref name="T" />, en un élément <see langword="Span&lt;Byte&gt;" />.</summary>
      <param name="span" vsli:raw="The source slice to convert.">Section source à convertir.</param>
      <typeparam name="T" vsli:raw="The type of items in the span.">Type des éléments de l’étendue.</typeparam>
      <returns vsli:raw="A span of type &lt;see cref=&quot;T:System.Byte&quot; /&gt;.">Une étendue de type <see cref="T:System.Byte" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;T&quot; /&gt; contains managed object references.">
        <paramref name="T" /> contient des références ou des pointeurs.</exception>
      <exception cref="T:System.OverflowException" vsli:raw="The &lt;see cref=&quot;P:System.ReadOnlySpan`1.Length&quot; /&gt; property of the new &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; would exceed &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;">La propriété <see cref="P:System.Span`1.Length" /> du nouveau <see cref="T:System.Span`1" /> dépasserait <see cref="F:System.Int32.MaxValue" /></exception>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsMemory``1(System.ReadOnlyMemory{``0})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Memory`1&quot; /&gt; instance from a &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt;.">Crée une instance <see cref="T:System.Memory`1" /> à partir d'un élément <see cref="T:System.ReadOnlyMemory`1" />.</summary>
      <param name="memory" vsli:raw="The read-only memory buffer.">Mémoire tampon en lecture seule.</param>
      <typeparam name="T" vsli:raw="The type of items in the read-only memory buffer.">Type des éléments dans la mémoire tampon en lecture seule.</typeparam>
      <returns vsli:raw="A memory block that represents the same memory as the &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt;.">Bloc de mémoire représentant la même mémoire que <see cref="T:System.ReadOnlyMemory`1" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsRef``1(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reinterprets a read-only span of bytes as a read-only reference to the structure of type &lt;paramref name=&quot;T&quot; /&gt;.">Réinterprète une étendue d’octets en lecture seule comme une référence en lecture seule à la structure de type <paramref name="T" />.</summary>
      <param name="span" vsli:raw="The read-only span to reinterpret.">L’étendue en lecture seule à réinterpréter.</param>
      <typeparam name="T" vsli:raw="The type of the returned reference.">Type de la référence retournée.</typeparam>
      <returns vsli:raw="The read-only reference to the structure of type &lt;paramref name=&quot;T&quot; /&gt;.">La référence en lecture seule à la structure de type <paramref name="T" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsRef``1(System.Span{System.Byte})">
      <summary vsli:raw="Reinterprets a span of bytes as a reference to the structure of type &lt;paramref name=&quot;T&quot; /&gt;.">Réinterprète une étendue d’octets comme une référence à la structure de type <paramref name="T" />.</summary>
      <param name="span" vsli:raw="The span to reinterpret.">L’étendue à réinterpréter.</param>
      <typeparam name="T" vsli:raw="The type of the returned reference.">Type de la référence retournée.</typeparam>
      <returns vsli:raw="The reference to the structure of type &lt;paramref name=&quot;T&quot; /&gt;.">La référence à la structure de type <paramref name="T" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.Cast``2(System.ReadOnlySpan{``0})">
      <summary vsli:raw="Casts a read-only span of one primitive type to a read-only span of another primitive type.">Convertit une étendue en lecture seule d’un type primitif en une étendue en lecture seule d’un autre type primitif.</summary>
      <param name="span" vsli:raw="The source slice to convert.">Section source à convertir.</param>
      <typeparam name="TFrom" vsli:raw="The type of the source span.">Type de l’étendue source.</typeparam>
      <typeparam name="TTo" vsli:raw="The type of the target span.">Type de l’étendue cible.</typeparam>
      <returns vsli:raw="The converted read-only span.">Étendue convertie en lecture seule.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;TFrom&quot; /&gt; or &lt;paramref name=&quot;TTo&quot; /&gt; contains managed object references.">
        <paramref name="TFrom" /> ou <paramref name="TTo" /> contient des références ou des pointeurs.</exception>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.Cast``2(System.Span{``0})">
      <summary vsli:raw="Casts a span of one primitive type to a span of another primitive type.">Convertit une étendue d’un type primitif en une étendue d’un autre type primitif.</summary>
      <param name="span" vsli:raw="The source slice to convert.">Section source à convertir.</param>
      <typeparam name="TFrom" vsli:raw="The type of the source span.">Type de l’étendue source.</typeparam>
      <typeparam name="TTo" vsli:raw="The type of the target span.">Type de l’étendue cible.</typeparam>
      <returns vsli:raw="The converted span.">Étendue convertie.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;TFrom&quot; /&gt; or &lt;paramref name=&quot;TTo&quot; /&gt; contains managed object references.">
        <paramref name="TFrom" /> ou <paramref name="TTo" /> contient des références ou des pointeurs.</exception>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.CreateFromPinnedArray``1(``0[],System.Int32,System.Int32)">
      <summary vsli:raw="Creates a new memory buffer over the portion of the pre-pinned target array beginning at the &lt;paramref name=&quot;start&quot; /&gt; index and consisting of &lt;paramref name=&quot;length&quot; /&gt; items.">Crée une nouvelle mémoire tampon sur la partie du tableau cible déjà épinglé commençant à l’index <paramref name="start" /> et comprenant des éléments <paramref name="length" />.</summary>
      <param name="array" vsli:raw="The pre-pinned source array.">Tableau source préalablement épinglé.</param>
      <param name="start" vsli:raw="The index of &lt;paramref name=&quot;array&quot; /&gt; at which to begin the memory block.">Index de <paramref name="array" /> où commencer le bloc de mémoire.</param>
      <param name="length" vsli:raw="The number of items to include in the memory block.">Nombre d’éléments à inclure dans le bloc de mémoire.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Type de tableau.</typeparam>
      <returns vsli:raw="A block of memory over the specified elements of &lt;paramref name=&quot;array&quot; /&gt;. If &lt;paramref name=&quot;array&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;, or if &lt;paramref name=&quot;start&quot; /&gt; and &lt;paramref name=&quot;length&quot; /&gt; are 0, the method returns a &lt;see cref=&quot;T:System.Memory`1&quot; /&gt; instance of &lt;see cref=&quot;P:System.Memory`1.Length&quot; /&gt; zero.">Bloc de mémoire sur les éléments spécifiés de <paramref name="array" />. Si <paramref name="array" /> est <see langword="null" />, ou si <paramref name="start" /> et <paramref name="length" /> sont 0, la méthode retourne une instance <see cref="T:System.Memory`1" /> de <see cref="P:System.Memory`1.Length" /> égale à zéro.</returns>
      <exception cref="T:System.ArrayTypeMismatchException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt; is covariant, and the type of &lt;paramref name=&quot;array&quot; /&gt; is not exactly &lt;paramref name=&quot;T[]&quot; /&gt;.">La valeur <paramref name="array" /> est covariante et le type de <paramref name="array" /> n’est pas exactement <paramref name="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The &lt;paramref name=&quot;start&quot; /&gt; or the end index is not in the range of 0 to &lt;see cref=&quot;P:System.Array.Length&quot; /&gt;.">La valeur <paramref name="start" /> ou l’index de fin n’est pas dans la plage de 0 à <see cref="P:System.Array.Length" />.</exception>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.CreateReadOnlySpan``1(``0@,System.Int32)">
      <summary vsli:raw="Creates a new read-only span over a portion of a regular managed object.">Crée une nouvelle étendue en lecture seule sur une partie d’un objet managé normal.</summary>
      <param name="reference" vsli:raw="A reference to data.">Référence à des données.</param>
      <param name="length" vsli:raw="The number of &lt;paramref name=&quot;T&quot; /&gt; elements that &lt;paramref name=&quot;reference&quot; /&gt; contains.">Nombre d'éléments <paramref name="T" /> que contient <paramref name="reference" />.</param>
      <typeparam name="T" vsli:raw="The type of the data items.">Type des éléments de données.</typeparam>
      <returns vsli:raw="A read-only span.">Étendue en lecture seule.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.CreateSpan``1(``0@,System.Int32)">
      <summary vsli:raw="Creates a new span over a portion of a regular managed object.">Crée une nouvelle étendue sur une partie d’un objet managé normal.</summary>
      <param name="reference" vsli:raw="A reference to data.">Référence à des données.</param>
      <param name="length" vsli:raw="The number of &lt;paramref name=&quot;T&quot; /&gt; elements that &lt;paramref name=&quot;reference&quot; /&gt; contains.">Nombre d'éléments <paramref name="T" /> que contient <paramref name="reference" />.</param>
      <typeparam name="T" vsli:raw="The type of the data items.">Type des éléments de données.</typeparam>
      <returns vsli:raw="A span.">Étendue.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.GetReference``1(System.ReadOnlySpan{``0})">
      <summary vsli:raw="Returns a reference to the element of the read-only span at index 0.">Retourne une référence à l’élément de l’étendue en lecture seule à l’index 0.</summary>
      <param name="span" vsli:raw="The read-only span from which the reference is retrieved.">Étendue en lecture seule à partir de laquelle la référence est extraite.</param>
      <typeparam name="T" vsli:raw="The type of items in the span.">Type des éléments de l’étendue.</typeparam>
      <returns vsli:raw="A reference to the element at index 0.">Référence à l'élément à l’index 0.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.GetReference``1(System.Span{``0})">
      <summary vsli:raw="Returns a reference to the element of the span at index 0.">Retourne une référence à l’élément de l’étendue à l’index 0.</summary>
      <param name="span" vsli:raw="The span from which the reference is retrieved.">Étendue en lecture seule à partir de laquelle la référence est récupérée.</param>
      <typeparam name="T" vsli:raw="The type of items in the span.">Type des éléments de l’étendue.</typeparam>
      <returns vsli:raw="A reference to the element at index 0.">Référence à l'élément à l’index 0.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.Read``1(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a structure of type &lt;typeparamref name=&quot;T&quot; /&gt; out of a read-only span of bytes.">Lit une structure de type <param name="T" /> en dehors d’une étendue d’octets en lecture seule.</summary>
      <param name="source" vsli:raw="A read-only span.">Étendue en lecture seule.</param>
      <typeparam name="T" vsli:raw="The type of the item to retrieve from the read-only span.">Type de l’élément à récupérer à partir de l’étendue en lecture seule.</typeparam>
      <returns vsli:raw="The structure retrieved from the read-only span.">Structure récupérée à partir de l’étendue en lecture seule.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;T&quot; /&gt; contains managed object references.">
        <paramref name="T" /> contient des références ou des pointeurs.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is smaller than &lt;paramref name=&quot;T&quot; /&gt;'s length in bytes.">
        <paramref name="source" /> est plus petit que <paramref name="T" />.</exception>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.ToEnumerable``1(System.ReadOnlyMemory{``0})">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; view of the given read-only memory buffer.">Crée une vue <see cref="T:System.Collections.Generic.IEnumerable`1" /> de la mémoire tampon en lecture seule donnée.</summary>
      <param name="memory" vsli:raw="A read-only memory buffer.">Mémoire tampon en lecture seule.</param>
      <typeparam name="T" vsli:raw="The type of the items in the read-only memory buffer.">Type des éléments dans la mémoire tampon en lecture seule.</typeparam>
      <returns vsli:raw="An enumerable view of &lt;paramref name=&quot;memory&quot; /&gt;.">Vue énumérable de <paramref name="memory" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetArray``1(System.ReadOnlyMemory{``0},System.ArraySegment{``0}@)">
      <summary vsli:raw="Tries to get an array segment from the underlying memory buffer. The return value indicates the success of the operation.">Tente d’obtenir un segment de tableau à partir de la mémoire tampon sous-jacente. La valeur de retour indique si l'opération a réussi.</summary>
      <param name="memory" vsli:raw="A read-only memory buffer.">Mémoire tampon en lecture seule.</param>
      <param name="segment" vsli:raw="When this method returns, contains the array segment retrieved from the underlying read-only memory buffer. If the method fails, the method returns a default array segment.">Lorsque cette méthode est retournée, contient le segment de tableau récupéré à partir de la mémoire tampon en lecture seule sous-jacente. Si la méthode échoue, la méthode retourne un segment de tableau par défaut.</param>
      <typeparam name="T" vsli:raw="The type of items in the read-only memory buffer.">Type des éléments dans la mémoire tampon en lecture seule.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the method call succeeds; &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" /> si l'appel de méthode a réussi ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetMemoryManager``2(System.ReadOnlyMemory{``0},``1@)">
      <summary vsli:raw="Tries to retrieve a &lt;see cref=&quot;T:System.Buffers.MemoryManager`1&quot; /&gt; from the underlying read-only memory buffer.">Tente de récupérer un élément <see cref="T:System.Buffers.MemoryManager`1" /> à partir de la mémoire tampon en lecture seule sous-jacente.</summary>
      <param name="memory" vsli:raw="The read-only memory buffer for which to get the memory manager.">Mémoire tampon en lecture seule pour laquelle obtenir le Gestionnaire de mémoire.</param>
      <param name="manager" vsli:raw="When the method returns, the manager of &lt;paramref name=&quot;memory&quot; /&gt;.">Quand la méthode est retournée, gestionnaire de <paramref name="memory" />.</param>
      <typeparam name="T" vsli:raw="The type of the items in the read-only memory buffer.">Type des éléments dans la mémoire tampon en lecture seule.</typeparam>
      <typeparam name="TManager" vsli:raw="The type of the &lt;see cref=&quot;T:System.Buffers.MemoryManager`1&quot; /&gt; to retrieve.">Type du <see cref="T:System.Buffers.MemoryManager`1" /> à récupérer.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the method retrieved the memory manager; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si la méthode a extrait le Gestionnaire de mémoire ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetMemoryManager``2(System.ReadOnlyMemory{``0},``1@,System.Int32@,System.Int32@)">
      <summary vsli:raw="Tries to retrieve a &lt;see cref=&quot;T:System.Buffers.MemoryManager`1&quot; /&gt;, start index, and length from the underlying read-only memory buffer.">Tente de récupérer un élément <see cref="T:System.Buffers.MemoryManager`1" />, un index de début et une longueur à partir de la mémoire tampon en lecture seule sous-jacente.</summary>
      <param name="memory" vsli:raw="The read-only memory buffer for which to get the memory manager.">Mémoire tampon en lecture seule pour laquelle obtenir le Gestionnaire de mémoire.</param>
      <param name="manager" vsli:raw="When the method returns, the manager of &lt;paramref name=&quot;memory&quot; /&gt;.">Quand la méthode est retournée, gestionnaire de <paramref name="memory" />.</param>
      <param name="start" vsli:raw="When the method returns, the offset from the start of the &lt;paramref name=&quot;manager&quot; /&gt; that the &lt;paramref name=&quot;memory&quot; /&gt; represents.">Quand la méthode est retournée, offset à partir du début du <paramref name="manager" /> représenté par <paramref name="memory" />.</param>
      <param name="length" vsli:raw="When the method returns, the length of the &lt;paramref name=&quot;manager&quot; /&gt; that the &lt;paramref name=&quot;memory&quot; /&gt; represents.">Quand la méthode est retournée, longueur du <paramref name="manager" /> représenté par <paramref name="memory" />.</param>
      <typeparam name="T" vsli:raw="The type of the items in the read-only memory buffer.">Type des éléments dans la mémoire tampon en lecture seule.</typeparam>
      <typeparam name="TManager" vsli:raw="The type of the &lt;see cref=&quot;T:System.Buffers.MemoryManager`1&quot; /&gt; to retrieve.">Type du <see cref="T:System.Buffers.MemoryManager`1" /> à récupérer.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the method succeeded; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si la méthode a réussi ; sinon <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetString(System.ReadOnlyMemory{System.Char},System.String@,System.Int32@,System.Int32@)">
      <summary vsli:raw="Tries to get the underlying string from a &lt;see langword=&quot;System.ReadOnlyMemory&amp;lt;Char&amp;gt;&quot; /&gt;.">Tente d’obtenir la chaîne sous-jacente à partir d’un élément <see langword="System.ReadOnlyMemory&lt;Char&gt;" />.</summary>
      <param name="memory" vsli:raw="Read-only memory containing a block of characters.">Mémoire en lecture seule contenant un bloc de caractères.</param>
      <param name="text" vsli:raw="When the method returns, the string contained in the memory buffer.">Lorsque la méthode est retournée, la chaîne contenue dans la mémoire tampon.</param>
      <param name="start" vsli:raw="The starting location in &lt;paramref name=&quot;text&quot; /&gt;.">Emplacement de départ dans <paramref name="text" />.</param>
      <param name="length" vsli:raw="The number of characters in &lt;paramref name=&quot;text&quot; /&gt;.">Nombre de caractères dans <paramref name="text" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the method successfully retrieves the underlying string; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si la méthode a réussi à récupérer la chaîne sous-jacente ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryRead``1(System.ReadOnlySpan{System.Byte},``0@)">
      <summary vsli:raw="Tries to read a structure of type &lt;paramref name=&quot;T&quot; /&gt; from a read-only span of bytes.">Tente de lire une structure de type <paramref name="T" /> à partir d’une étendue d’octets en lecture seule.</summary>
      <param name="source" vsli:raw="A read-only span of bytes.">Étendue d’octets en lecture seule.</param>
      <param name="value" vsli:raw="When the method returns, an instance of &lt;paramref name=&quot;T&quot; /&gt;.">Quand la méthode est retournée, instance de <paramref name="T" />.</param>
      <typeparam name="T" vsli:raw="The type of the structure to retrieve.">Type de la structure à récupérer.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the method succeeds in retrieving an instance of the structure; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si la méthode réussit lors de l’extraction d’une instance de la structure ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;T&quot; /&gt; contains managed object references.">
        <paramref name="T" /> contient des références ou des pointeurs.</exception>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryWrite``1(System.Span{System.Byte},``0@)">
      <summary vsli:raw="Tries to write a structure of type &lt;paramref name=&quot;T&quot; /&gt; into a span of bytes.">Tente d’écrire une structure de type <paramref name="T" /> dans une étendue d’octets.</summary>
      <param name="destination" vsli:raw="The span of bytes to contain the structure.">Étendue d’octets contenant la structure.</param>
      <param name="value" vsli:raw="The structure to be written to the span.">Structure à écrire dans l’étendue.</param>
      <typeparam name="T" vsli:raw="The type of the structure.">Type de la structure.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the write operation succeeded; otherwise, &lt;see langword=&quot;false&quot; /&gt;. The method returns &lt;see langword=&quot;false&quot; /&gt; if the span is too small to contain &lt;paramref name=&quot;T&quot; /&gt;.">
        <see langword="true" /> si l'opération d’écriture a abouti ; sinon <see langword="false" />. La méthode retourne <see langword="false" /> si l’étendue est trop petite pour contenir <paramref name="T" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;T&quot; /&gt; contains managed object references.">
        <paramref name="T" /> contient des références ou des pointeurs.</exception>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.Write``1(System.Span{System.Byte},``0@)">
      <summary vsli:raw="Writes a structure of type &lt;paramref name=&quot;T&quot; /&gt; into a span of bytes.">Écrit une structure de type <paramref name="T" /> dans une étendue d’octets.</summary>
      <param name="destination" vsli:raw="The span of bytes to contain the structure.">Étendue d’octets contenant la structure.</param>
      <param name="value" vsli:raw="The structure to be written to the span.">Structure à écrire dans l’étendue.</param>
      <typeparam name="T" vsli:raw="The type of the structure.">Type de la structure.</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;T&quot; /&gt; contains managed object references.">
        <paramref name="T" /> contient des références ou des pointeurs.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain &lt;paramref name=&quot;value&quot; /&gt;.">
        <paramref name="destination" /> est trop petite pour contenir <paramref name="value" />.</exception>
    </member>
    <member name="T:System.Runtime.InteropServices.SequenceMarshal">
      <summary vsli:raw="Provides a collection of methods for interoperating with &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Fournit une collection de méthodes pour l’interopérabilité avec <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
    </member>
    <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryGetArray``1(System.Buffers.ReadOnlySequence{``0},System.ArraySegment{``0}@)">
      <summary vsli:raw="Gets an array segment from the underlying read-only sequence.">Obtient un segment de tableau à partir de la séquence en lecture seule sous-jacente.</summary>
      <param name="sequence" vsli:raw="The read-only sequence from which the array segment will be retrieved.">Séquence en lecture seule à partir de laquelle le segment de tableau sera récupéré.</param>
      <param name="segment" vsli:raw="The returned array segment.">Segment de tableau retourné.</param>
      <typeparam name="T" vsli:raw="The type of the read-only sequence.">Type de la séquence en lecture seule.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if it's possible to retrieve the array segment; otherwise, &lt;see langword=&quot;false&quot; /&gt; and a default array segment is returned.">
        <see langword="true" /> s’il est possible de récupérer le segment de tableau ; sinon, <see langword="false" /> et un segment de tableau par défaut est retourné.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryGetReadOnlyMemory``1(System.Buffers.ReadOnlySequence{``0},System.ReadOnlyMemory{``0}@)">
      <summary vsli:raw="Attempts to retrieve a read-only memory from the specified read-only sequence.">Tente de récupérer une mémoire en lecture seule à partir de la séquence en lecture seule spécifiée.</summary>
      <param name="sequence" vsli:raw="The read-only sequence from which the memory will be retrieved.">Séquence en lecture seule à partir de laquelle la mémoire sera récupérée.</param>
      <param name="memory" vsli:raw="The returned read-only memory of type T.">Mémoire en lecture seule retournée de type T.</param>
      <typeparam name="T" vsli:raw="The type of the read-only sequence.">Type de la séquence en lecture seule.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the read-only memory can be retrieved; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si la mémoire en lecture seule peut être récupérée ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryGetReadOnlySequenceSegment``1(System.Buffers.ReadOnlySequence{``0},System.Buffers.ReadOnlySequenceSegment{``0}@,System.Int32@,System.Buffers.ReadOnlySequenceSegment{``0}@,System.Int32@)">
      <summary vsli:raw="Attempts to retrieve a read-only sequence segment from the specified read-only sequence.">Tente de récupérer un segment de séquence en lecture seule à partir de la séquence en lecture seule spécifiée.</summary>
      <param name="sequence" vsli:raw="The read-only sequence from which the read-only sequence segment will be retrieved.">Séquence en lecture seule à partir de laquelle le segment de séquence en lecture seule sera récupéré.</param>
      <param name="startSegment" vsli:raw="The beginning read-only sequence segment.">Segment de séquence en lecture seule de début.</param>
      <param name="startIndex" vsli:raw="The initial position.">Position initiale.</param>
      <param name="endSegment" vsli:raw="The ending read-only sequence segment.">Segment de séquence en lecture seule de fin.</param>
      <param name="endIndex" vsli:raw="The final position.">Position finale.</param>
      <typeparam name="T" vsli:raw="The type of the read-only sequence.">Type de la séquence en lecture seule.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the read-only sequence segment can be retrieved; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si le segment de séquence en lecture seule peut être récupéré ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryRead``1(System.Buffers.SequenceReader{System.Byte}@,``0@)">
      <summary vsli:raw="Attempts to read the specified type out of the buffer. It's dangerous to use this method with arbitrary structs - see remarks for more information.">Tente de lire le type spécifié à partir de la mémoire tampon. Il est dangereux d’utiliser cette méthode avec des structs arbitraires. Pour plus d’informations, consultez la section Notes.</summary>
      <param name="reader" vsli:raw="A reference to the sequence reader.">Référence au lecteur de séquence.</param>
      <param name="value" vsli:raw="The returned value if the read was successful. &lt;paramref name=&quot;value&quot; /&gt; will be &lt;see langword=&quot;default&quot; /&gt; if failed (due to lack of space).">Valeur retournée si la lecture a réussi. <paramref name="value" /> est <see langword="default" /> en cas d’échec (en raison d’un manque d’espace).</param>
      <typeparam name="T" vsli:raw="The type of the value.">Type de la valeur.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the read attempt was successful, &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" /> si la tentative de lecture a réussi ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="T:System.SequencePosition">
      <summary vsli:raw="Represents a position in a non-contiguous set of memory. Properties of this type should not be interpreted by anything but the type that created it.">Représente une position dans un jeu de mémoire non contigu. Les propriétés de ce type doivent uniquement être interprétées par le type qui les a créées.</summary>
    </member>
    <member name="M:System.SequencePosition.#ctor(System.Object,System.Int32)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; struct.">Initialise une nouvelle instance du struct <see cref="T:System.SequencePosition" />.</summary>
      <param name="object" vsli:raw="A non-contiguous set of memory.">Ensemble de mémoire non contigu.</param>
      <param name="integer" vsli:raw="The position in &lt;paramref name=&quot;object&quot; /&gt;.">Position dans <paramref name="object" />.</param>
    </member>
    <member name="M:System.SequencePosition.Equals(System.Object)">
      <summary vsli:raw="Returns a value that indicates whether the current instance is equal to another object.">Retourne une valeur qui indique si l’instance actuelle est égale à un autre objet.</summary>
      <param name="obj" vsli:raw="The object to compare with the current instance.">Objet à comparer à l'instance actuelle.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;obj&quot; /&gt; is of type &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; and is equal to the current instance; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si <paramref name="obj" /> est de type <see cref="T:System.SequencePosition" /> et s’il est égal à l’instance actuelle ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.SequencePosition.Equals(System.SequencePosition)">
      <summary vsli:raw="Indicates whether the current instance is equal to another &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt;.">Indique si l’instance actuelle est égale à un autre <see cref="T:System.SequencePosition" />.</summary>
      <param name="other" vsli:raw="The sequence position to compare with the current instance.">Position de séquence à comparer à l’instance actuelle.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two instances are equal; &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" /> si les deux instances sont égales ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.SequencePosition.GetHashCode">
      <summary vsli:raw="Returns the hash code for this instance.">Retourne le code de hachage de cette instance.</summary>
      <returns vsli:raw="The hash code for this instance.">Code de hachage de cette instance.</returns>
    </member>
    <member name="M:System.SequencePosition.GetInteger">
      <summary vsli:raw="Returns the integer part of this &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt;.">Retourne la partie entière de cette <see cref="T:System.SequencePosition" />.</summary>
      <returns vsli:raw="The integer part of this sequence position.">Partie entière de la position de séquence.</returns>
    </member>
    <member name="M:System.SequencePosition.GetObject">
      <summary vsli:raw="Returns the object part of this &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt;.">Retourne la partie objet de cette <see cref="T:System.SequencePosition" />.</summary>
      <returns vsli:raw="The object part of this sequence position.">Partie objet de la position de séquence.</returns>
    </member>
    <member name="T:System.Text.SpanRuneEnumerator">
      <summary vsli:raw="Provides an enumerator for the &lt;see cref=&quot;T:System.Text.Rune&quot; /&gt; values represented by a span containing UTF-16 text.">Fournit un énumérateur pour les valeurs <see cref="T:System.Text.Rune" /> représentées par une étendue contenant du texte UTF-16.</summary>
    </member>
    <member name="P:System.Text.SpanRuneEnumerator.Current">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Text.Rune&quot; /&gt; at the current position of the enumerator.">Obtient le <see cref="T:System.Text.Rune" /> à la position actuelle de l'énumérateur.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Text.Rune&quot; /&gt; at the current position of the enumerator.">
        <see cref="T:System.Text.Rune" /> à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="M:System.Text.SpanRuneEnumerator.GetEnumerator">
      <summary vsli:raw="Returns the current enumerator instance.">Retourne l’instance de l’énumérateur actuelle.</summary>
      <returns vsli:raw="The current enumerator instance.">Instance de l’énumérateur actuelle.</returns>
    </member>
    <member name="M:System.Text.SpanRuneEnumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next &lt;see cref=&quot;T:System.Text.Rune&quot; /&gt; of the span.">Avance l’énumérateur au <see cref="T:System.Text.Rune" /> suivant de l’étendue.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator successfully advanced to the next item; &lt;see langword=&quot;false&quot; /&gt; if the end of the span has been reached.">
        <see langword="true" /> si l’énumérateur a avancé jusqu’à l’élément suivant ; <see langword="false" /> si la fin de l’étendue a été atteinte.</returns>
    </member>
  </members>
</doc>