<?xml version="1.0" encoding="utf-8"?>
<doc xmlns:vsli="https://github.com/sk-0520/vs-localized-intellisense/tree/master/schema/2024">
  <assembly>
    <name>System.Collections.Concurrent</name>
  </assembly>
  <members>
    <member name="T:System.Collections.Concurrent.BlockingCollection`1">
      <summary vsli:raw="Provides blocking and bounding capabilities for thread-safe collections that implement &lt;see cref=&quot;T:System.Collections.Concurrent.IProducerConsumerCollection`1&quot; /&gt;.">Proporciona capacidades de bloqueo y establecimiento de límites en colecciones seguras para subprocesos que implementan <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" />.</summary>
      <typeparam name="T" vsli:raw="The type of elements in the collection.">Tipo de los elementos de la colección.</typeparam>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; class without an upper-bound.">Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> sin límite superior.</summary>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0})">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; class without an upper-bound and using the provided &lt;see cref=&quot;T:System.Collections.Concurrent.IProducerConsumerCollection`1&quot; /&gt; as its underlying data store.">Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> sin límite superior y usando el objeto <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /> proporcionado como almacén de datos subyacente.</summary>
      <param name="collection" vsli:raw="The collection to use as the underlying data store.">Colección que se va a usar como almacén de datos subyacente.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;collection&quot; /&gt; argument is null.">El argumento <paramref name="collection" /> es null.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0},System.Int32)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; class with the specified upper-bound and using the provided &lt;see cref=&quot;T:System.Collections.Concurrent.IProducerConsumerCollection`1&quot; /&gt; as its underlying data store.">Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> con el límite superior especificado y que usa el <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /> proporcionado como almacén de datos subyacente.</summary>
      <param name="collection" vsli:raw="The collection to use as the underlying data store.">Colección que se va a usar como almacén de datos subyacente.</param>
      <param name="boundedCapacity" vsli:raw="The bounded size of the collection.">Tamaño límite de la colección.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;collection&quot; /&gt; argument is null.">El argumento <paramref name="collection" /> es null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The &lt;paramref name=&quot;boundedCapacity&quot; /&gt; is not a positive value.">
        <paramref name="boundedCapacity" /> no es un valor positivo.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The supplied &lt;paramref name=&quot;collection&quot; /&gt; contains more values than is permitted by &lt;paramref name=&quot;boundedCapacity&quot; /&gt;.">El <paramref name="collection" /> proporcionado contiene más valores de los permitidos por <paramref name="boundedCapacity" />.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Int32)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; class with the specified upper-bound.">Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> con el límite superior especificado.</summary>
      <param name="boundedCapacity" vsli:raw="The bounded size of the collection.">Tamaño límite de la colección.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The &lt;paramref name=&quot;boundedCapacity&quot; /&gt; is not a positive value.">
        <paramref name="boundedCapacity" /> no es un valor positivo.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0)">
      <summary vsli:raw="Adds the item to the &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt;.">Agrega el elemento a <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
      <param name="item" vsli:raw="The item to be added to the collection. The value can be a null reference.">Elemento que se va a agregar a la colección. El valor puede ser una referencia nula.</param>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; has been disposed.">Se ha eliminado <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; has been marked as complete with regards to additions.&#xA;&#xA; -or-&#xA;&#xA; The underlying collection didn't accept the item.">
        <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> se ha marcado como completo en lo relativo a las adiciones.  
  
o bien 
La colección subyacente no aceptó el elemento.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0,System.Threading.CancellationToken)">
      <summary vsli:raw="Adds the item to the &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt;.">Agrega el elemento a <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
      <param name="item" vsli:raw="The item to be added to the collection. The value can be a null reference.">Elemento que se va a agregar a la colección. El valor puede ser una referencia nula.</param>
      <param name="cancellationToken" vsli:raw="A cancellation token to observe.">Token de cancelación que se va a observar.</param>
      <exception cref="T:System.OperationCanceledException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; is canceled.">Si se cancela <see cref="T:System.Threading.CancellationToken" />.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; has been disposed or the &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that owns &lt;paramref name=&quot;cancellationToken&quot; /&gt; has been disposed.">
        <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> ha sido eliminado o <see cref="T:System.Threading.CancellationTokenSource" /> que posee <paramref name="cancellationToken" /> ha sido eliminado.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; has been marked as complete with regards to additions.&#xA;&#xA; -or-&#xA;&#xA; The underlying collection didn't accept the item.">
        <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> se ha marcado como completo en lo relativo a las adiciones.  
  
o bien 
La colección subyacente no aceptó el elemento.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
      <summary vsli:raw="Adds the specified item to any one of the specified &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; instances.">Agrega el elemento especificado a cualquiera de las instancias especificadas de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
      <param name="collections" vsli:raw="The array of collections.">Matriz de colecciones.</param>
      <param name="item" vsli:raw="The item to be added to one of the collections.">Elemento que se va a agregar a una de las colecciones.</param>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="At least one of the &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; instances has been disposed.">Se ha eliminado al menos una de las instancias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;collections&quot; /&gt; argument is null.">El argumento <paramref name="collections" /> es null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The count of &lt;paramref name=&quot;collections&quot; /&gt; is greater than the maximum size of 62 for STA and 63 for MTA.">El recuento de <paramref name="collections" /> es mayor que el tamaño máximo de 62 para STA y 63 para MTA.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;collections&quot; /&gt; argument is a 0-length array or contains a null element, or at least one of collections has been marked as complete for adding.">El argumento <paramref name="collections" /> es una matriz de longitud 0 o contiene un elemento NULL, o al menos una de las colecciones se ha marcado como completa para agregar.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="At least one underlying collection didn't accept the item.">Al menos una colección subyacente no aceptó el elemento.</exception>
      <returns vsli:raw="The index of the collection in the &lt;paramref name=&quot;collections&quot; /&gt; array to which the item was added.">Índice de la colección de la matriz <paramref name="collections" /> donde se agregó el elemento.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Threading.CancellationToken)">
      <summary vsli:raw="Adds the specified item to any one of the specified &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; instances.">Agrega el elemento especificado a cualquiera de las instancias especificadas de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
      <param name="collections" vsli:raw="The array of collections.">Matriz de colecciones.</param>
      <param name="item" vsli:raw="The item to be added to one of the collections.">Elemento que se va a agregar a una de las colecciones.</param>
      <param name="cancellationToken" vsli:raw="A cancellation token to observe.">Token de cancelación que se va a observar.</param>
      <exception cref="T:System.OperationCanceledException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; is canceled.">Si se cancela <see cref="T:System.Threading.CancellationToken" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="At least one underlying collection didn't accept the item.">Al menos una colección subyacente no aceptó el elemento.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;collections&quot; /&gt; argument is null.">El argumento <paramref name="collections" /> es null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The count of &lt;paramref name=&quot;collections&quot; /&gt; is greater than the maximum size of 62 for STA and 63 for MTA.">El recuento de <paramref name="collections" /> es mayor que el tamaño máximo de 62 para STA y 63 para MTA.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;collections&quot; /&gt; argument is a 0-length array or contains a null element, or at least one of collections has been marked as complete for adding.">El argumento <paramref name="collections" /> es una matriz de longitud 0 o contiene un elemento NULL, o al menos una de las colecciones se ha marcado como completa para agregar.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="At least one of the &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; instances has been disposed, or the &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has been disposed.">Se ha eliminado al menos una de las instancias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> o se ha eliminado la <see cref="T:System.Threading.CancellationTokenSource" /> que creó <paramref name="cancellationToken" />.</exception>
      <returns vsli:raw="The index of the collection in the &lt;paramref name=&quot;collections&quot; /&gt; array to which the item was added.">Índice de la colección de la matriz <paramref name="collections" /> donde se agregó el elemento.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding">
      <summary vsli:raw="Marks the &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; instances as not accepting any more additions.">Marca las instancias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> para que no acepten nuevas adiciones.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; has been disposed.">Se ha eliminado <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.CopyTo(`0[],System.Int32)">
      <summary vsli:raw="Copies all of the items in the &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; instance to a compatible one-dimensional array, starting at the specified index of the target array.">Copia todos los elementos de la instancia de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> en una matriz unidimensional compatible, empezando por el índice especificado de la matriz de destino.</summary>
      <param name="array" vsli:raw="The one-dimensional array that is the destination of the elements copied from the &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; instance. The array must have zero-based indexing.">Matriz unidimensional que constituye el destino de los elementos copiados desde la instancia de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />. La matriz debe tener una indización de base cero.</param>
      <param name="index" vsli:raw="The zero-based index in &lt;paramref name=&quot;array&quot; /&gt; at which copying begins.">Índice de base cero en la <paramref name="array" /> donde comienza la copia.</param>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; has been disposed.">Se ha eliminado <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;array&quot; /&gt; argument is null.">El argumento <paramref name="array" /> es null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The &lt;paramref name=&quot;index&quot; /&gt; argument is less than zero.">El argumento <paramref name="index" /> es menor que cero.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;index&quot; /&gt; argument is equal to or greater than the length of the &lt;paramref name=&quot;array&quot; /&gt;.&#xA;&#xA; The destination array is too small to hold all of the BlockingCollection elements.&#xA;&#xA; The array rank doesn't match.&#xA;&#xA; The array type is incompatible with the type of the BlockingCollection elements.">El argumento <paramref name="index" /> es mayor o igual que la longitud de <paramref name="array" />.  
  
La matriz de destino es demasiado pequeña para contener todos los elementos BlockingCollection.  
  
El rango de la matriz no coincide.  
  
El tipo de la matriz es incompatible con el tipo de los elementos BlockingCollection.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; class.">Libera todos los recursos usados por la instancia actual de la clase <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.Dispose(System.Boolean)">
      <summary vsli:raw="Releases resources used by the &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; instance.">Libera todos los recursos usados por la instancia de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
      <param name="disposing" vsli:raw="Whether being disposed explicitly (true) or due to a finalizer (false).">Si se desecha de forma explícita (true) o a través de un finalizador (false).</param>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable">
      <summary vsli:raw="Provides a consuming &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; for items in the collection.">Proporciona una interfaz <see cref="T:System.Collections.Generic.IEnumerator`1" /> en uso para los elementos de la colección.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; has been disposed.">Se ha eliminado <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that removes and returns items from the collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que quita y devuelve elementos de la colección.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable(System.Threading.CancellationToken)">
      <summary vsli:raw="Provides a consuming &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; for items in the collection.">Proporciona una interfaz <see cref="T:System.Collections.Generic.IEnumerable`1" /> en uso para los elementos de la colección.</summary>
      <param name="cancellationToken" vsli:raw="A cancellation token to observe.">Token de cancelación que se va a observar.</param>
      <exception cref="T:System.OperationCanceledException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; is canceled.">Si se cancela <see cref="T:System.Threading.CancellationToken" />.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; has been disposed or the &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has been disposed">
        <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> ha sido eliminado o <see cref="T:System.Threading.CancellationTokenSource" /> que creó <paramref name="cancellationToken" /> ha sido eliminado.</exception>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that removes and returns items from the collection.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que quita y devuelve elementos de la colección.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
      <summary vsli:raw="Provides an &lt;see cref=&quot;T:System.Collections.Generic.IEnumerator`1&quot; /&gt; for items in the collection.">Proporciona una interfaz <see cref="T:System.Collections.Generic.IEnumerator`1" /> para los elementos de la colección.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; has been disposed.">Se ha eliminado <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerator`1&quot; /&gt; for the items in the collection.">
        <see cref="T:System.Collections.Generic.IEnumerator`1" /> para los elementos de la colección.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
      <summary vsli:raw="Copies all of the items in the &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; instance to a compatible one-dimensional array, starting at the specified index of the target array.">Copia todos los elementos de la instancia de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> en una matriz unidimensional compatible, empezando por el índice especificado de la matriz de destino.</summary>
      <param name="array" vsli:raw="The one-dimensional array that is the destination of the elements copied from the &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; instance. The array must have zero-based indexing.">Matriz unidimensional que constituye el destino de los elementos copiados desde la instancia de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />. La matriz debe tener una indización de base cero.</param>
      <param name="index" vsli:raw="The zero-based index in &lt;paramref name=&quot;array&quot; /&gt; at which copying begins.">Índice de base cero en la <paramref name="array" /> donde comienza la copia.</param>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; has been disposed.">Se ha eliminado <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;array&quot; /&gt; argument is null.">El argumento <paramref name="array" /> es null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The &lt;paramref name=&quot;index&quot; /&gt; argument is less than zero.">El argumento <paramref name="index" /> es menor que cero.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;index&quot; /&gt; argument is equal to or greater than the length of the &lt;paramref name=&quot;array&quot; /&gt;, the array is multidimensional, or the type parameter for the collection cannot be cast automatically to the type of the destination array.">El argumento <paramref name="index" /> es mayor o igual que la longitud de <paramref name="array" />, la matriz es multidimensional o el parámetro de tipo para la colección no se puede convertir automáticamente al tipo de la matriz de destino.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Provides an &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; for items in the collection.">Proporciona una interfaz <see cref="T:System.Collections.IEnumerator" /> para los elementos de la colección.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; has been disposed.">Se ha eliminado <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; for the items in the collection.">
        <see cref="T:System.Collections.IEnumerator" /> para los elementos de la colección.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.Take">
      <summary vsli:raw="Removes an item from the &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt;.">Quita un elemento de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; has been disposed.">Se ha eliminado <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The underlying collection was modified outside of this &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; instance, or the &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; is empty and has been marked as complete with regards to additions.">La colección subyacente se modificó fuera de esta estancia de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />, o la <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> está vacía y la colección se ha marcado como completa para agregar.</exception>
      <exception cref="T:System.OperationCanceledException">
        <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> está vacío y se ha marcado como completo con respecto a las adiciones.</exception>
      <returns vsli:raw="The item that was removed from the collection.">Elemento que se ha quitado de la colección.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.Take(System.Threading.CancellationToken)">
      <summary vsli:raw="Removes an item from the &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt;.">Quita un elemento de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
      <param name="cancellationToken" vsli:raw="A token that can be used to cancel the &quot;take&quot; operation.">Objeto que se puede usar para cancelar la operación en la que se toma un elemento.</param>
      <exception cref="T:System.OperationCanceledException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; is canceled.">
        <see cref="T:System.Threading.CancellationToken" /> se cancela.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; has been disposed.">
        <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> ha sido eliminado o <see cref="T:System.Threading.CancellationTokenSource" /> que creó el token se canceló.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The underlying collection was modified outside of this &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; instance, or the &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; is empty and has been marked as complete with regards to additions.">La colección subyacente se modificó fuera de esta instancia de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> o BlockingCollection se ha marcado como completa para las funciones de agregación o bien <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> está vacía.</exception>
      <returns vsli:raw="The item that was removed from the collection.">Elemento que se ha quitado de la colección.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
      <summary vsli:raw="Takes an item from any one of the specified &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; instances.">Toma un elemento de cualquiera de las instancias especificadas de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
      <param name="collections" vsli:raw="The array of collections.">Matriz de colecciones.</param>
      <param name="item" vsli:raw="The item that was removed from one of the collections.">Elemento que se ha quitado de una de las colecciones.</param>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="At least one of the &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; instances has been disposed.">Se ha eliminado al menos una de las instancias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;collections&quot; /&gt; argument is null.">El argumento <paramref name="collections" /> es null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The count of &lt;paramref name=&quot;collections&quot; /&gt; is greater than the maximum size of 62 for STA and 63 for MTA.">El recuento de <paramref name="collections" /> es mayor que el tamaño máximo de 62 para STA y 63 para MTA.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;collections&quot; /&gt; argument is a 0-length array or contains a null element or &lt;see cref=&quot;M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding&quot; /&gt; has been called on the collection.">El argumento <paramref name="collections" /> es una matriz de longitud 0 o contiene un elemento nulo o se ha llamado a <see cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding" /> en la colección.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="At least one of the underlying collections was modified outside of its &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; instance.">Al menos una de las colecciones subyacentes se modificó fuera de su instancia <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
      <returns vsli:raw="The index of the collection in the &lt;paramref name=&quot;collections&quot; /&gt; array from which the item was removed.">Índice de la colección de la matriz <paramref name="collections" /> de la que se quitó el elemento.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Threading.CancellationToken)">
      <summary vsli:raw="Takes an item from any one of the specified &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; instances while observing the specified cancellation token.">Toma un elemento de cualquiera de las instancias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> especificadas observando el token de cancelación indicado.</summary>
      <param name="collections" vsli:raw="The array of collections.">Matriz de colecciones.</param>
      <param name="item" vsli:raw="The item that was removed from one of the collections.">Elemento que se ha quitado de una de las colecciones.</param>
      <param name="cancellationToken" vsli:raw="A cancellation token to observe.">Token de cancelación que se va a observar.</param>
      <exception cref="T:System.OperationCanceledException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; is canceled.">Si se cancela <see cref="T:System.Threading.CancellationToken" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="At least one of the underlying collections was modified outside of its &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; instance.">Al menos una de las colecciones subyacentes se modificó fuera de su instancia <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;collections&quot; /&gt; argument is null.">El argumento <paramref name="collections" /> es null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The count of &lt;paramref name=&quot;collections&quot; /&gt; is greater than the maximum size of 62 for STA and 63 for MTA.">El recuento de <paramref name="collections" /> es mayor que el tamaño máximo de 62 para STA y 63 para MTA.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;collections&quot; /&gt; argument is a 0-length array or contains a null element, or &lt;see cref=&quot;M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding&quot; /&gt; has been called on the collection.">El argumento <paramref name="collections" /> es una matriz de longitud 0 o contiene un elemento nulo o se ha llamado a <see cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding" /> en la colección.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="At least one of the &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; instances has been disposed.">Se ha eliminado al menos una de las instancias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
      <returns vsli:raw="The index of the collection in the &lt;paramref name=&quot;collections&quot; /&gt; array from which the item was removed.">Índice de la colección de la matriz <paramref name="collections" /> de la que se quitó el elemento.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.ToArray">
      <summary vsli:raw="Copies the items from the &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; instance into a new array.">Copia los elementos de la instancia de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> en una nueva matriz.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; has been disposed.">Se ha eliminado <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
      <returns vsli:raw="An array containing copies of the elements of the collection.">Matriz que contiene copias de los elementos de la colección.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0)">
      <summary vsli:raw="Tries to add the specified item to the &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt;.">Intenta agregar el elemento especificado a <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
      <param name="item" vsli:raw="The item to be added to the collection.">Elemento que se va a agregar a la colección.</param>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; has been disposed.">Se ha eliminado <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; has been marked as complete with regards to additions.&#xA;&#xA; -or-&#xA;&#xA; The underlying collection didn't accept the item.">
        <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> se ha marcado como completo en lo relativo a las adiciones.  
  
o bien 
La colección subyacente no aceptó el elemento.</exception>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;item&quot; /&gt; could be added; otherwise, &lt;see langword=&quot;false&quot; /&gt;. If the item is a duplicate, and the underlying collection does not accept duplicate items, then an &lt;see cref=&quot;T:System.InvalidOperationException&quot; /&gt; is thrown.">
        <see langword="true" /> si se ha podido agregar <paramref name="item" />; de lo contrario, <see langword="false" />. Si el elemento es un duplicado, y la colección subyacente no acepta elementos duplicados, se producirá una excepción <see cref="T:System.InvalidOperationException" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32)">
      <summary vsli:raw="Tries to add the specified item to the &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; within the specified time period.">Intenta agregar el elemento especificado a <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> dentro del período de tiempo indicado.</summary>
      <param name="item" vsli:raw="The item to be added to the collection.">Elemento que se va a agregar a la colección.</param>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait for the collection to accept the item, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1) to wait indefinitely.">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</param>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; has been disposed.">Se ha eliminado <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" /> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; has been marked as complete with regards to additions.&#xA;&#xA; -or-&#xA;&#xA; The underlying collection didn't accept the item.">
        <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> se ha marcado como completo en lo relativo a las adiciones.  
  
o bien 
La colección subyacente no aceptó el elemento.</exception>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;paramref name=&quot;item&quot; /&gt; could be added to the collection within the specified time; otherwise, false. If the item is a duplicate, and the underlying collection does not accept duplicate items, then an &lt;see cref=&quot;T:System.InvalidOperationException&quot; /&gt; is thrown.">
        <see langword="true" /> si se ha podido agregar <paramref name="item" /> a la colección en el tiempo especificado; en caso contrario, es false. Si el elemento es un duplicado, y la colección subyacente no acepta elementos duplicados, se producirá una excepción <see cref="T:System.InvalidOperationException" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32,System.Threading.CancellationToken)">
      <summary vsli:raw="Tries to add the specified item to the &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; within the specified time period, while observing a cancellation token.">Intenta agregar el elemento especificado a <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> dentro del período de tiempo especificado, observando un token de cancelación.</summary>
      <param name="item" vsli:raw="The item to be added to the collection.">Elemento que se va a agregar a la colección.</param>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait for the collection to accept the item, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1) to wait indefinitely.">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</param>
      <param name="cancellationToken" vsli:raw="A cancellation token to observe.">Token de cancelación que se va a observar.</param>
      <exception cref="T:System.OperationCanceledException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; is canceled.">Si se cancela <see cref="T:System.Threading.CancellationToken" />.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; has been disposed or the underlying &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; has been disposed.">La <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> se ha eliminado o el <see cref="T:System.Threading.CancellationTokenSource" /> subyacente se ha eliminado.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" /> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; has been marked as complete with regards to additions.&#xA;&#xA; -or-&#xA;&#xA; The underlying collection didn't accept the item.">
        <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> se ha marcado como completo en lo relativo a las adiciones.  
  
o bien 
La colección subyacente no aceptó el elemento.</exception>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;paramref name=&quot;item&quot; /&gt; could be added to the collection within the specified time; otherwise, false. If the item is a duplicate, and the underlying collection does not accept duplicate items, then an &lt;see cref=&quot;T:System.InvalidOperationException&quot; /&gt; is thrown.">
        <see langword="true" /> si se ha podido agregar <paramref name="item" /> a la colección en el tiempo especificado; en caso contrario, es false. Si el elemento es un duplicado, y la colección subyacente no acepta elementos duplicados, se producirá una excepción <see cref="T:System.InvalidOperationException" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.TimeSpan)">
      <summary vsli:raw="Tries to add the specified item to the &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt;.">Intenta agregar el elemento especificado a <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
      <param name="item" vsli:raw="The item to be added to the collection.">Elemento que se va a agregar a la colección.</param>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely.">Estructura <see cref="T:System.TimeSpan" /> que representa el número de milisegundos de espera o estructura <see cref="T:System.TimeSpan" /> que representa -1 milisegundos para esperar indefinidamente.</param>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; has been disposed.">Se ha eliminado <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> es un número negativo distinto de -1 milisegundo, que representa un tiempo de espera infinito, o el tiempo de espera es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; has been marked as complete with regards to additions.&#xA;&#xA; -or-&#xA;&#xA; The underlying collection didn't accept the item.">
        <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> se ha marcado como completo en lo relativo a las adiciones.  
  
o bien 
La colección subyacente no aceptó el elemento.</exception>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;paramref name=&quot;item&quot; /&gt; could be added to the collection within the specified time span; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si se ha podido agregar <paramref name="item" /> a la colección en el intervalo de tiempo especificado; en caso contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
      <summary vsli:raw="Tries to add the specified item to any one of the specified &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; instances.">Intenta agregar el elemento especificado a cualquiera de las instancias especificadas de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
      <param name="collections" vsli:raw="The array of collections.">Matriz de colecciones.</param>
      <param name="item" vsli:raw="The item to be added to one of the collections.">Elemento que se va a agregar a una de las colecciones.</param>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="At least one of the &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; instances has been disposed.">Se ha eliminado al menos una de las instancias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;collections&quot; /&gt; argument is null.">El argumento <paramref name="collections" /> es null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The count of &lt;paramref name=&quot;collections&quot; /&gt; is greater than the maximum size of 62 for STA and 63 for MTA.">El recuento de <paramref name="collections" /> es mayor que el tamaño máximo de 62 para STA y 63 para MTA.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;collections&quot; /&gt; argument is a 0-length array or contains a null element, or at least one of collections has been marked as complete for adding.">El argumento <paramref name="collections" /> es una matriz de longitud 0 o contiene un elemento NULL, o al menos una de las colecciones se ha marcado como completa para agregar.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="At least one underlying collection didn't accept the item.">Al menos una colección subyacente no aceptó el elemento.</exception>
      <returns vsli:raw="The index of the collection in the &lt;paramref name=&quot;collections&quot; /&gt; array to which the item was added, or -1 if the item could not be added.">Índice de la colección en la matriz <paramref name="collections" /> a la que se agregó el elemento o -1 si no se pudo agregar el elemento.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32)">
      <summary vsli:raw="Tries to add the specified item to any one of the specified &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; instances.">Intenta agregar el elemento especificado a cualquiera de las instancias especificadas de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
      <param name="collections" vsli:raw="The array of collections.">Matriz de colecciones.</param>
      <param name="item" vsli:raw="The item to be added to one of the collections.">Elemento que se va a agregar a una de las colecciones.</param>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait for the collection to accept the item, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1) to wait indefinitely.">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</param>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="At least one of the &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; instances has been disposed.">Se ha eliminado al menos una de las instancias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;collections&quot; /&gt; argument is null.">El argumento <paramref name="collections" /> es null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.&#xA;&#xA; -or-&#xA;&#xA; The count of &lt;paramref name=&quot;collections&quot; /&gt; is greater than the maximum size of 62 for STA and 63 for MTA.">
        <paramref name="millisecondsTimeout" /> es un número negativo distinto de-1, que representa un tiempo de espera infinito. 
o bien 
El recuento de <paramref name="collections" /> es mayor que el tamaño máximo de 62 para STA y 63 para MTA.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;collections&quot; /&gt; argument is a 0-length array or contains a null element, or at least one of collections has been marked as complete for adding.">El argumento <paramref name="collections" /> es una matriz de longitud 0 o contiene un elemento NULL, o al menos una de las colecciones se ha marcado como completa para agregar.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="At least one underlying collection didn't accept the item.">Al menos una colección subyacente no aceptó el elemento.</exception>
      <returns vsli:raw="The index of the collection in the &lt;paramref name=&quot;collections&quot; /&gt; array to which the item was added, or -1 if the item could not be added.">Índice de la colección en la matriz <paramref name="collections" /> a la que se agregó el elemento o -1 si no se pudo agregar el elemento.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)">
      <summary vsli:raw="Tries to add the specified item to any one of the specified &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; instances.">Intenta agregar el elemento especificado a cualquiera de las instancias especificadas de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
      <param name="collections" vsli:raw="The array of collections.">Matriz de colecciones.</param>
      <param name="item" vsli:raw="The item to be added to one of the collections.">Elemento que se va a agregar a una de las colecciones.</param>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait for the collection to accept the item, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1) to wait indefinitely.">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</param>
      <param name="cancellationToken" vsli:raw="A cancellation token to observe.">Token de cancelación que se va a observar.</param>
      <exception cref="T:System.OperationCanceledException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; is canceled.">Si se cancela <see cref="T:System.Threading.CancellationToken" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="At least one underlying collection didn't accept the item.">Al menos una colección subyacente no aceptó el elemento.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;collections&quot; /&gt; argument is null.">El argumento <paramref name="collections" /> es null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.&#xA;&#xA; -or-&#xA;&#xA; The count of &lt;paramref name=&quot;collections&quot; /&gt; is greater than the maximum size of 62 for STA and 63 for MTA.">
        <paramref name="millisecondsTimeout" /> es un número negativo distinto de-1, que representa un tiempo de espera infinito. 
o bien 
El recuento de <paramref name="collections" /> es mayor que el tamaño máximo de 62 para STA y 63 para MTA.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;collections&quot; /&gt; argument is a 0-length array or contains a null element, or at least one of collections has been marked as complete for adding.">El argumento <paramref name="collections" /> es una matriz de longitud 0 o contiene un elemento NULL, o al menos una de las colecciones se ha marcado como completa para agregar.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="At least one of the &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; instances has been disposed.">Se ha eliminado al menos una de las instancias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
      <returns vsli:raw="The index of the collection in the &lt;paramref name=&quot;collections&quot; /&gt; array to which the item was added, or -1 if the item could not be added.">Índice de la colección en la matriz <paramref name="collections" /> a la que se agregó el elemento o -1 si no se pudo agregar el elemento.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.TimeSpan)">
      <summary vsli:raw="Tries to add the specified item to any one of the specified &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; instances while observing the specified cancellation token.">Intenta agregar el elemento especificado a cualquiera de las instancias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> indicadas observando el token de cancelación indicado.</summary>
      <param name="collections" vsli:raw="The array of collections.">Matriz de colecciones.</param>
      <param name="item" vsli:raw="The item to be added to one of the collections.">Elemento que se va a agregar a una de las colecciones.</param>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely.">Estructura <see cref="T:System.TimeSpan" /> que representa el número de milisegundos de espera o estructura <see cref="T:System.TimeSpan" /> que representa -1 milisegundos para esperar indefinidamente.</param>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="At least one of the &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; instances or the &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has been disposed.">Se ha eliminado al menos una de las instancias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> o de <see cref="T:System.Threading.CancellationTokenSource" /> que crearon <paramref name="cancellationToken" />.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;collections&quot; /&gt; argument is null.">El argumento <paramref name="collections" /> es null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.&#xA;&#xA;-or-&#xA;&#xA; The count of &lt;paramref name=&quot;collections&quot; /&gt; is greater than the maximum size of 62 for STA and 63 for MTA.">
        <paramref name="timeout" /> es un número negativo distinto de -1 milisegundo, que representa un tiempo de espera infinito, o el tiempo de espera es mayor que <see cref="F:System.Int32.MaxValue" />.  
  
o bien 
El recuento de <paramref name="collections" /> es mayor que el tamaño máximo de 62 para STA y 63 para MTA.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;collections&quot; /&gt; argument is a 0-length array or contains a null element, or at least one of collections has been marked as complete for adding.">El argumento <paramref name="collections" /> es una matriz de longitud 0 o contiene un elemento NULL, o al menos una de las colecciones se ha marcado como completa para agregar.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="At least one underlying collection didn't accept the item.">Al menos una colección subyacente no aceptó el elemento.</exception>
      <returns vsli:raw="The index of the collection in the &lt;paramref name=&quot;collections&quot; /&gt; array to which the item was added, or -1 if the item could not be added.">Índice de la colección en la matriz <paramref name="collections" /> a la que se agregó el elemento o -1 si no se pudo agregar el elemento.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@)">
      <summary vsli:raw="Tries to remove an item from the &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt;.">Intenta quitar un elemento de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
      <param name="item" vsli:raw="The item to be removed from the collection.">Elemento que va a quitarse de la colección.</param>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; has been disposed.">Se ha eliminado <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The underlying collection was modified outside of this &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; instance.">La colección subyacente se modificó fuera de esta instancia de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if an item could be removed; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si se pudo quitar un elemento; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32)">
      <summary vsli:raw="Tries to remove an item from the &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; in the specified time period.">Intenta quitar un elemento de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> dentro del período de tiempo especificado.</summary>
      <param name="item" vsli:raw="The item to be removed from the collection.">Elemento que va a quitarse de la colección.</param>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait for the item to be removed, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1) to wait indefinitely.">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</param>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; has been disposed.">Se ha eliminado <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" /> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The underlying collection was modified outside of this &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; instance.">La colección subyacente se modificó fuera de esta instancia de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if an item could be removed from the collection within the specified  time; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si se pudo quitar un elemento de la colección en el tiempo especificado; en caso contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)">
      <summary vsli:raw="Tries to remove an item from the &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; in the specified time period while observing a cancellation token.">Intenta quitar un elemento de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> dentro del período de tiempo especificado, observando un token de cancelación.</summary>
      <param name="item" vsli:raw="The item to be removed from the collection.">Elemento que va a quitarse de la colección.</param>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait for the item to be removed, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1) to wait indefinitely.">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</param>
      <param name="cancellationToken" vsli:raw="A cancellation token to observe.">Token de cancelación que se va a observar.</param>
      <exception cref="T:System.OperationCanceledException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; has been canceled.">El <see cref="T:System.Threading.CancellationToken" /> se ha cancelado.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; has been disposed or the underlying &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; has been disposed.">La <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> se ha eliminado o el <see cref="T:System.Threading.CancellationTokenSource" /> subyacente se ha eliminado.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" /> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The underlying collection was modified outside this &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; instance.">La colección subyacente se modificó fuera de esta instancia de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if an item could be removed from the collection within the specified  time; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si se pudo quitar un elemento de la colección en el tiempo especificado; en caso contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)">
      <summary vsli:raw="Tries to remove an item from the &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; in the specified time period.">Intenta quitar un elemento de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> dentro del período de tiempo especificado.</summary>
      <param name="item" vsli:raw="The item to be removed from the collection.">Elemento que va a quitarse de la colección.</param>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait for the item to be removed, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely.">Un objeto que representa el número de milisegundos de espera o un objeto que representa -1 milisegundos para esperar indefinidamente.</param>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; has been disposed.">Se ha eliminado <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out.&#xA;&#xA; -or-&#xA;&#xA; &lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> es un número negativo distinto de -1 milisegundos, que representa un tiempo de espera infinito. 
o bien 
 <paramref name="timeout" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The underlying collection was modified outside of this &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; instance.">La colección subyacente se modificó fuera de esta instancia de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if an item could be removed from the collection within the specified time; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si se pudo quitar un elemento de la colección en el tiempo especificado; en caso contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
      <summary vsli:raw="Tries to remove an item from any one of the specified &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; instances.">Intenta quitar un elemento de cualquiera de las instancias especificadas de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
      <param name="collections" vsli:raw="The array of collections.">Matriz de colecciones.</param>
      <param name="item" vsli:raw="The item that was removed from one of the collections.">Elemento que se ha quitado de una de las colecciones.</param>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="At least one of the &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; instances has been disposed.">Se ha eliminado al menos una de las instancias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;collections&quot; /&gt; argument is null.">El argumento <paramref name="collections" /> es null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The count of &lt;paramref name=&quot;collections&quot; /&gt; is greater than the maximum size of 62 for STA and 63 for MTA.">El recuento de <paramref name="collections" /> es mayor que el tamaño máximo de 62 para STA y 63 para MTA.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;collections&quot; /&gt; argument is a 0-length array or contains a null element.">El argumento <paramref name="collections" /> es una matriz de longitud 0 o contiene un elemento nulo.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="At least one of the underlying collections was modified outside of its &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; instance.">Al menos una de las colecciones subyacentes se modificó fuera de su instancia <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
      <returns vsli:raw="The index of the collection in the &lt;paramref name=&quot;collections&quot; /&gt; array from which the item was removed, or -1 if an item could not be removed.">Índice de la colección en la matriz <paramref name="collections" /> de la que se quitó el elemento o -1 si no se pudo quitar el elemento.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32)">
      <summary vsli:raw="Tries to remove an item from any one of the specified &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; instances.">Intenta quitar un elemento de cualquiera de las instancias especificadas de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
      <param name="collections" vsli:raw="The array of collections to remove an item from.">Matriz de colecciones.</param>
      <param name="item" vsli:raw="The item that was removed from one of the collections.">Elemento que se ha quitado de una de las colecciones.</param>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait for the item to be removed, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1) to wait indefinitely.">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</param>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="At least one of the &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; instances has been disposed.">Se ha eliminado al menos una de las instancias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;collections&quot; /&gt; argument is null.">El argumento <paramref name="collections" /> es null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.&#xA;&#xA; -or-&#xA;&#xA; The count of &lt;paramref name=&quot;collections&quot; /&gt; is greater than the maximum size of 62 for STA and 63 for MTA.">
        <paramref name="millisecondsTimeout" /> es un número negativo distinto de-1, que representa un tiempo de espera infinito. 
o bien 
El recuento de <paramref name="collections" /> es mayor que el tamaño máximo de 62 para STA y 63 para MTA.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;collections&quot; /&gt; argument is a 0-length array or contains a null element.">El argumento <paramref name="collections" /> es una matriz de longitud 0 o contiene un elemento nulo.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="At least one of the underlying collections was modified outside of its &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; instance.">Al menos una de las colecciones subyacentes se modificó fuera de su instancia <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
      <returns vsli:raw="The index of the collection in the &lt;paramref name=&quot;collections&quot; /&gt; array from which the item was removed, or -1 if an item could not be removed.">Índice de la colección en la matriz <paramref name="collections" /> de la que se quitó el elemento o -1 si no se pudo quitar el elemento.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)">
      <summary vsli:raw="Tries to remove an item from any one of the specified &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; instances.">Intenta quitar un elemento de cualquiera de las instancias especificadas de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
      <param name="collections" vsli:raw="The array of collections to remove an item from.">Matriz de colecciones.</param>
      <param name="item" vsli:raw="The item that was removed from one of the collections.">Elemento que se ha quitado de una de las colecciones.</param>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait for the item to be removed, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1) to wait indefinitely.">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</param>
      <param name="cancellationToken" vsli:raw="A cancellation token to observe.">Token de cancelación que se va a observar.</param>
      <exception cref="T:System.OperationCanceledException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; is canceled.">Si se cancela <see cref="T:System.Threading.CancellationToken" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="At least one of the underlying collections was modified outside of its &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; instance.">Al menos una de las colecciones subyacentes se modificó fuera de su instancia <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;collections&quot; /&gt; argument is null.">El argumento <paramref name="collections" /> es null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.&#xA;&#xA; -or-&#xA;&#xA; The count of &lt;paramref name=&quot;collections&quot; /&gt; is greater than the maximum size of 62 for STA and 63 for MTA.">
        <paramref name="millisecondsTimeout" /> es un número negativo distinto de-1, que representa un tiempo de espera infinito. 
o bien 
El recuento de <paramref name="collections" /> es mayor que el tamaño máximo de 62 para STA y 63 para MTA.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;collections&quot; /&gt; argument is a 0-length array or contains a null element.">El argumento <paramref name="collections" /> es una matriz de longitud 0 o contiene un elemento nulo.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="At least one of the &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; instances has been disposed.">Se ha eliminado al menos una de las instancias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
      <returns vsli:raw="The index of the collection in the &lt;paramref name=&quot;collections&quot; /&gt; array from which the item was removed, or -1 if an item could not be removed.">Índice de la colección en la matriz <paramref name="collections" /> de la que se quitó el elemento o -1 si no se pudo quitar el elemento.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.TimeSpan)">
      <summary vsli:raw="Tries to remove an item from any one of the specified &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; instances.">Intenta quitar un elemento de cualquiera de las instancias especificadas de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
      <param name="collections" vsli:raw="The array of collections.">Matriz de colecciones.</param>
      <param name="item" vsli:raw="The item that was removed from one of the collections.">Elemento que se ha quitado de una de las colecciones.</param>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely.">Estructura <see cref="T:System.TimeSpan" /> que representa el número de milisegundos de espera o estructura <see cref="T:System.TimeSpan" /> que representa -1 milisegundos para esperar indefinidamente.</param>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="At least one of the &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; instances has been disposed.">Se ha eliminado al menos una de las instancias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;collections&quot; /&gt; argument is null.">El argumento <paramref name="collections" /> es null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.&#xA;&#xA; -or-&#xA;&#xA; The count of &lt;paramref name=&quot;collections&quot; /&gt; is greater than the maximum size of 62 for STA and 63 for MTA.">
        <paramref name="timeout" /> es un número negativo distinto de -1 milisegundo, que representa un tiempo de espera infinito, o el tiempo de espera es mayor que <see cref="F:System.Int32.MaxValue" />.  
  
o bien 
El recuento de <paramref name="collections" /> es mayor que el tamaño máximo de 62 para STA y 63 para MTA.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;collections&quot; /&gt; argument is a 0-length array or contains a null element.">El argumento <paramref name="collections" /> es una matriz de longitud 0 o contiene un elemento nulo.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="At least one of the underlying collections was modified outside of its &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; instance.">Al menos una de las colecciones subyacentes se modificó fuera de su instancia <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
      <returns vsli:raw="The index of the collection in the &lt;paramref name=&quot;collections&quot; /&gt; array from which the item was removed, or -1 if an item could not be removed.">Índice de la colección en la matriz <paramref name="collections" /> de la que se quitó el elemento o -1 si no se pudo quitar el elemento.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.BlockingCollection`1.BoundedCapacity">
      <summary vsli:raw="Gets the bounded capacity of this &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; instance.">Obtiene la capacidad límite de esta instancia de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; has been disposed.">Se ha eliminado <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
      <returns vsli:raw="The bounded capacity of this collection, or -1 if no bound was supplied.">La capacidad límite de esta colección o int.MaxValue si no se proporciona ningún límite.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.BlockingCollection`1.Count">
      <summary vsli:raw="Gets the number of items contained in the &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt;.">Obtiene el número de elementos contenidos en <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; has been disposed.">Se ha eliminado <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
      <returns vsli:raw="The number of items contained in the &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt;.">Número de elementos contenidos en <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.BlockingCollection`1.IsAddingCompleted">
      <summary vsli:raw="Gets whether this &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; has been marked as complete for adding.">Obtiene si <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> se ha marcado como completa para las funciones de agregación.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; has been disposed.">Se ha eliminado <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
      <returns vsli:raw="Whether this collection has been marked as complete for adding.">Si esta colección se ha marcado como completa para las funciones de agregación.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.BlockingCollection`1.IsCompleted">
      <summary vsli:raw="Gets whether this &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; has been marked as complete for adding and is empty.">Obtiene si este <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> se ha marcado como completo para las funciones de agregación y está vacío.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; has been disposed.">Se ha eliminado <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
      <returns vsli:raw="Whether this collection has been marked as complete for adding and is empty.">Si esta colección se ha marcado como completa para las funciones de agregación y está vacía.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#IsSynchronized">
      <summary vsli:raw="Gets a value indicating whether access to the &lt;see cref=&quot;T:System.Collections.ICollection&quot; /&gt; is synchronized (thread safe).">Obtiene un valor que indica si el acceso a la interfaz <see cref="T:System.Collections.ICollection" /> está sincronizado (es seguro para subprocesos).</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; has been disposed.">Se ha eliminado <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
      <returns vsli:raw="Always returns &lt;see langword=&quot;false&quot; /&gt; to indicate the access is not synchronized.">Siempre devuelve <see langword="false" /> para indicar que el acceso no está sincronizado.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#SyncRoot">
      <summary vsli:raw="Gets an object that can be used to synchronize access to the &lt;see cref=&quot;T:System.Collections.ICollection&quot; /&gt;. This property is not supported.">Obtiene un objeto que se puede usar para sincronizar el acceso a <see cref="T:System.Collections.ICollection" />. Esta propiedad no es compatible.</summary>
      <exception cref="T:System.NotSupportedException" vsli:raw="The SyncRoot property is not supported.">La propiedad SyncRoot no es compatible.</exception>
      <returns vsli:raw="Returns &lt;see langword=&quot;null&quot; /&gt;.">Devuelve <see langword="null" />.</returns>
    </member>
    <member name="T:System.Collections.Concurrent.ConcurrentBag`1">
      <summary vsli:raw="Represents a thread-safe, unordered collection of objects.">Representa una colección segura para subprocesos desordenada de objetos.</summary>
      <typeparam name="T" vsli:raw="The type of the elements to be stored in the collection.">Tipo de los elementos que se van a almacenar en la colección.</typeparam>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentBag`1&quot; /&gt; class.">Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" />.</summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentBag`1&quot; /&gt; class that contains elements copied from the specified collection.">Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> que contiene los elementos copiados de la colección especificada.</summary>
      <param name="collection" vsli:raw="The collection whose elements are copied to the new &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentBag`1&quot; /&gt;.">Colección cuyos elementos se copian en el nuevo <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;collection&quot; /&gt; is a null reference (Nothing in Visual Basic).">
        <paramref name="collection" /> es una referencia nula (nada en Visual Basic).</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.Add(`0)">
      <summary vsli:raw="Adds an object to the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentBag`1&quot; /&gt;.">Agrega un objeto a <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" />.</summary>
      <param name="item" vsli:raw="The object to be added to the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentBag`1&quot; /&gt;. The value can be a null reference (Nothing in Visual Basic) for reference types.">Objeto que se va a agregar a <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" />. El valor puede ser una referencia nula (Nothing en Visual Basic) para los tipos de referencia.</param>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.Clear">
      <summary vsli:raw="Removes all values from the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentBag`1&quot; /&gt;.">Quita todos los valores de <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" />.</summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.CopyTo(`0[],System.Int32)">
      <summary vsli:raw="Copies the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentBag`1&quot; /&gt; elements to an existing one-dimensional &lt;see cref=&quot;T:System.Array&quot; /&gt;, starting at the specified array index.">Copia los elementos de <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> en una <see cref="T:System.Array" /> unidimensional existente, a partir del índice especificado de la matriz.</summary>
      <param name="array" vsli:raw="The one-dimensional &lt;see cref=&quot;T:System.Array&quot; /&gt; that is the destination of the elements copied from the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentBag`1&quot; /&gt;. The &lt;see cref=&quot;T:System.Array&quot; /&gt; must have zero-based indexing.">Matriz <see cref="T:System.Array" /> unidimensional que constituye el destino de los elementos copiados desde la colección <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" />. <see cref="T:System.Array" /> debe tener una indización de base cero.</param>
      <param name="index" vsli:raw="The zero-based index in &lt;paramref name=&quot;array&quot; /&gt; at which copying begins.">Índice de base cero en la <paramref name="array" /> donde comienza la copia.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt; is a null reference (Nothing in Visual Basic).">
        <paramref name="array" /> es una referencia nula (nada en Visual Basic).</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;index&quot; /&gt; is less than zero.">
        <paramref name="index" /> es menor que cero.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;index&quot; /&gt; is equal to or greater than the length of the &lt;paramref name=&quot;array&quot; /&gt; -or- the number of elements in the source &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentBag`1&quot; /&gt; is greater than the available space from &lt;paramref name=&quot;index&quot; /&gt; to the end of the destination &lt;paramref name=&quot;array&quot; /&gt;.">
        <paramref name="index" /> es igual o mayor que la longitud de la matriz <paramref name="array" /> -o bien- el número de elementos de la colección <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> de origen es mayor que el espacio disponible desde <paramref name="index" /> hasta el final del parámetro <paramref name="array" /> de destino.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentBag`1&quot; /&gt;.">Devuelve un enumerador que recorre en iteración la colección <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" />.</summary>
      <returns vsli:raw="An enumerator for the contents of the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentBag`1&quot; /&gt;.">Enumerador para los contenidos de <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.System#Collections#Concurrent#IProducerConsumerCollection{T}#TryAdd(`0)">
      <summary vsli:raw="Attempts to add an object to the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentBag`1&quot; /&gt;.">Intenta agregar un objeto a <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" />.</summary>
      <param name="item" vsli:raw="The object to be added to the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentBag`1&quot; /&gt;. The value can be a null reference (Nothing in Visual Basic) for reference types.">Objeto que se va a agregar a <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" />. El valor puede ser una referencia nula (Nothing en Visual Basic) para los tipos de referencia.</param>
      <returns vsli:raw="Always returns true.">Siempre devuelve true.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
      <summary vsli:raw="Copies the elements of the &lt;see cref=&quot;T:System.Collections.ICollection&quot; /&gt; to an &lt;see cref=&quot;T:System.Array&quot; /&gt;, starting at a particular &lt;see cref=&quot;T:System.Array&quot; /&gt; index.">Copia los elementos de <see cref="T:System.Collections.ICollection" /> en <see cref="T:System.Array" />, empezando por un índice determinado de <see cref="T:System.Array" />.</summary>
      <param name="array" vsli:raw="The one-dimensional &lt;see cref=&quot;T:System.Array&quot; /&gt; that is the destination of the elements copied from the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentBag`1&quot; /&gt;. The &lt;see cref=&quot;T:System.Array&quot; /&gt; must have zero-based indexing.">Matriz <see cref="T:System.Array" /> unidimensional que constituye el destino de los elementos copiados desde la colección <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" />. <see cref="T:System.Array" /> debe tener una indización de base cero.</param>
      <param name="index" vsli:raw="The zero-based index in &lt;paramref name=&quot;array&quot; /&gt; at which copying begins.">Índice de base cero en la <paramref name="array" /> donde comienza la copia.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt; is a null reference (Nothing in Visual Basic).">
        <paramref name="array" /> es una referencia nula (nada en Visual Basic).</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;index&quot; /&gt; is less than zero.">
        <paramref name="index" /> es menor que cero.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt; is multidimensional. -or- &lt;paramref name=&quot;array&quot; /&gt; does not have zero-based indexing. -or- &lt;paramref name=&quot;index&quot; /&gt; is equal to or greater than the length of the &lt;paramref name=&quot;array&quot; /&gt; -or- The number of elements in the source &lt;see cref=&quot;T:System.Collections.ICollection&quot; /&gt; is greater than the available space from &lt;paramref name=&quot;index&quot; /&gt; to the end of the destination &lt;paramref name=&quot;array&quot; /&gt;. -or- The type of the source &lt;see cref=&quot;T:System.Collections.ICollection&quot; /&gt; cannot be cast automatically to the type of the destination &lt;paramref name=&quot;array&quot; /&gt;.">
        <paramref name="array" /> es multidimensional. -o bien- <paramref name="array" /> no tiene índices de base cero. -o bien- <paramref name="index" /> es igual o mayor que la longitud de la matriz <paramref name="array" /> -o bien- el número de elementos de la colección <see cref="T:System.Collections.ICollection" /> de origen es mayor que el espacio disponible desde <paramref name="index" /> hasta el final del parámetro <paramref name="array" /> de destino. -o bien- el tipo de la colección <see cref="T:System.Collections.ICollection" /> de origen no puede convertirse automáticamente al tipo del parámetro <paramref name="array" /> de destino.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentBag`1&quot; /&gt;.">Devuelve un enumerador que recorre en iteración la colección <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" />.</summary>
      <returns vsli:raw="An enumerator for the contents of the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentBag`1&quot; /&gt;.">Enumerador para los contenidos de <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.ToArray">
      <summary vsli:raw="Copies the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentBag`1&quot; /&gt; elements to a new array.">Copia los elementos <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> en una matriz nueva.</summary>
      <returns vsli:raw="A new array containing a snapshot of elements copied from the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentBag`1&quot; /&gt;.">Nueva matriz que contiene una instantánea de los elementos copiados de <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.TryPeek(`0@)">
      <summary vsli:raw="Attempts to return an object from the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentBag`1&quot; /&gt; without removing it.">Intenta devolver un objeto de <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> sin quitarlo.</summary>
      <param name="result" vsli:raw="When this method returns, &lt;paramref name=&quot;result&quot; /&gt; contains an object from the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentBag`1&quot; /&gt; or the default value of &lt;typeparamref name=&quot;T&quot; /&gt; if the operation failed.">Cuando este método finaliza, <paramref name="result" /> contiene un objeto de <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> o el valor predeterminado de <typeparamref name="T" /> si se produjo un error en la operación.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if an object was returned successfully; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si se devolvió correctamente un objeto; en caso contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.TryTake(`0@)">
      <summary vsli:raw="Attempts to remove and return an object from the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentBag`1&quot; /&gt;.">Intenta quitar y devolver un objeto de <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" />.</summary>
      <param name="result" vsli:raw="When this method returns, &lt;paramref name=&quot;result&quot; /&gt; contains the object removed from the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentBag`1&quot; /&gt; or the default value of &lt;typeparamref name=&quot;T&quot; /&gt; if the bag is empty.">Cuando este método finaliza, <paramref name="result" /> contiene el objeto quitado de <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> o el valor predeterminado de <typeparamref name="T" /> si la bolsa está vacía.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if an object was removed successfully; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si un objeto se ha quitado correctamente; en caso contrario, es <see langword="false" />.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentBag`1.Count">
      <summary vsli:raw="Gets the number of elements contained in the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentBag`1&quot; /&gt;.">Obtiene el número de elementos incluidos en <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" />.</summary>
      <returns vsli:raw="The number of elements contained in the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentBag`1&quot; /&gt;.">Número de elementos contenidos en <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" />.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentBag`1.IsEmpty">
      <summary vsli:raw="Gets a value that indicates whether the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentBag`1&quot; /&gt; is empty.">Obtiene un valor que indica si <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> está vacía.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentBag`1&quot; /&gt; is empty; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> está vacío, en caso contrario, es <see langword="false" />.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentBag`1.System#Collections#ICollection#IsSynchronized">
      <summary vsli:raw="Gets a value indicating whether access to the &lt;see cref=&quot;T:System.Collections.ICollection&quot; /&gt; is synchronized with the SyncRoot.">Obtiene un valor que indica si el acceso a <see cref="T:System.Collections.ICollection" /> está sincronizado con SyncRoot.</summary>
      <returns vsli:raw="Always returns &lt;see langword=&quot;false&quot; /&gt; to indicate access is not synchronized.">Siempre devuelve <see langword="false" /> para indicar que el acceso no está sincronizado.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentBag`1.System#Collections#ICollection#SyncRoot">
      <summary vsli:raw="Gets an object that can be used to synchronize access to the &lt;see cref=&quot;T:System.Collections.ICollection&quot; /&gt;. This property is not supported.">Obtiene un objeto que se puede usar para sincronizar el acceso a <see cref="T:System.Collections.ICollection" />. Esta propiedad no es compatible.</summary>
      <exception cref="T:System.NotSupportedException" vsli:raw="The SyncRoot property is not supported.">La propiedad SyncRoot no es compatible.</exception>
      <returns vsli:raw="Returns &lt;see langword=&quot;null&quot; /&gt;.">Devuelve <see langword="null" />.</returns>
    </member>
    <member name="T:System.Collections.Concurrent.ConcurrentDictionary`2">
      <summary vsli:raw="Represents a thread-safe collection of key/value pairs that can be accessed by multiple threads concurrently.">Representa una colección segura para subprocesos de los pares clave-valor a los que pueden obtener acceso varios subprocesos a la vez.</summary>
      <typeparam name="TKey" vsli:raw="The type of the keys in the dictionary.">Tipo de las claves del diccionario.</typeparam>
      <typeparam name="TValue" vsli:raw="The type of the values in the dictionary.">Tipo de los valores del diccionario.</typeparam>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt; class that is empty, has the default concurrency level, has the default initial capacity, and uses the default comparer for the key type.">Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> que está vacía, tiene el nivel de simultaneidad predeterminado, tiene la capacidad inicial predeterminada y usa el comparador predeterminado para el tipo de clave.</summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt; class that contains elements copied from the specified &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt;, has the default concurrency level, has the default initial capacity, and uses the default comparer for the key type.">Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> que contiene elementos copiados de la interfaz <see cref="T:System.Collections.Generic.IEnumerable`1" /> especificada, tiene el nivel de simultaneidad predeterminado, tiene la capacidad inicial predeterminada y usa el comparador predeterminado para el tipo de clave.</summary>
      <param name="collection" vsli:raw="The &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; whose elements are copied to the new &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt;.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> cuyos elementos se copian en el nuevo <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;collection&quot; /&gt; or any of its keys is  &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="collection" /> o cualquiera de sus claves es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;collection&quot; /&gt; contains one or more duplicate keys.">
        <paramref name="collection" /> contiene una o varias claves duplicadas.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt; class that contains elements copied from the specified &lt;see cref=&quot;T:System.Collections.IEnumerable&quot; /&gt; has the default concurrency level, has the default initial capacity, and uses the specified  &lt;see cref=&quot;T:System.Collections.Generic.IEqualityComparer`1&quot; /&gt;.">Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> que contiene elementos copiados del <see cref="T:System.Collections.IEnumerable" /> especificado, tiene el nivel de simultaneidad predeterminado, tiene la capacidad inicial predeterminada y usa el <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> especificado.</summary>
      <param name="collection" vsli:raw="The &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; whose elements are copied to the new &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt;.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> cuyos elementos se copian en el nuevo <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</param>
      <param name="comparer" vsli:raw="The &lt;see cref=&quot;T:System.Collections.Generic.IEqualityComparer`1&quot; /&gt; implementation to use when comparing keys.">Implementación de <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> que se va a usar al comparar claves.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;collection&quot; /&gt; or &lt;paramref name=&quot;comparer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="collection" /> o <paramref name="comparer" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt; class that is empty, has the default concurrency level and capacity, and uses the specified &lt;see cref=&quot;T:System.Collections.Generic.IEqualityComparer`1&quot; /&gt;.">Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> que está vacía, tiene el nivel de simultaneidad y la capacidad predeterminados y utiliza el <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> especificado.</summary>
      <param name="comparer" vsli:raw="The equality comparison implementation to use when comparing keys.">Implementación de comparación de igualdad que se debe utilizar al comparar claves.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;comparer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="comparer" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Int32,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt; class that contains elements copied from the specified &lt;see cref=&quot;T:System.Collections.IEnumerable&quot; /&gt;, and uses the specified &lt;see cref=&quot;T:System.Collections.Generic.IEqualityComparer`1&quot; /&gt;.">Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> que contiene los elementos copiados del <see cref="T:System.Collections.IEnumerable" /> especificado y utiliza el <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> especificado.</summary>
      <param name="concurrencyLevel" vsli:raw="The estimated number of threads that will update the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt; concurrently, or in .NET 8+ only, -1 to indicate the default concurrency level.">Número previsto de subprocesos que actualizarán <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> simultáneamente.</param>
      <param name="collection" vsli:raw="The &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; whose elements are copied to the new &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt;.">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> cuyos elementos se copian en el nuevo <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</param>
      <param name="comparer" vsli:raw="The &lt;see cref=&quot;T:System.Collections.Generic.IEqualityComparer`1&quot; /&gt; implementation to use when comparing keys.">Implementación de <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> que se va a usar al comparar claves.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;collection&quot; /&gt; or &lt;paramref name=&quot;comparer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="collection" /> o <paramref name="comparer" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;concurrencyLevel&quot; /&gt; is less than 1.">
        <paramref name="concurrencyLevel" /> es menor que 1.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;collection&quot; /&gt; contains one or more duplicate keys.">
        <paramref name="collection" /> contiene una o varias claves duplicadas.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Int32,System.Int32)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt; class that is empty, has the specified concurrency level and capacity, and uses the default comparer for the key type.">Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> que está vacía, tiene el nivel de simultaneidad y la capacidad especificados, y usa el comparador predeterminado para el tipo de clave.</summary>
      <param name="concurrencyLevel" vsli:raw="The estimated number of threads that will update the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt; concurrently, or in .NET 8+ only, -1 to indicate the default concurrency level.">Número previsto de subprocesos que actualizarán <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> simultáneamente.</param>
      <param name="capacity" vsli:raw="The initial number of elements that the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt; can contain.">Número inicial de elementos que puede contener la colección <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;concurrencyLevel&quot; /&gt; is less than 1.&#xA;&#xA; -or-&#xA;&#xA; &lt;paramref name=&quot;capacity&quot; /&gt; is less than 0.">
        <paramref name="concurrencyLevel" /> es menor que 1.  
  
o bien 
 <paramref name="capacity" /> es menor que 0.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt; class that is empty, has the specified concurrency level, has the specified initial capacity, and uses the specified &lt;see cref=&quot;T:System.Collections.Generic.IEqualityComparer`1&quot; /&gt;.">Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> que está vacía, tiene el nivel de simultaneidad y la capacidad inicial especificados, y usa la interfaz <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> especificada.</summary>
      <param name="concurrencyLevel" vsli:raw="The estimated number of threads that will update the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt; concurrently, or in .NET 8+ only, -1 to indicate the default concurrency level.">Número previsto de subprocesos que actualizarán <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> simultáneamente.</param>
      <param name="capacity" vsli:raw="The initial number of elements that the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt; can contain.">Número inicial de elementos que puede contener la colección <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</param>
      <param name="comparer" vsli:raw="The &lt;see cref=&quot;T:System.Collections.Generic.IEqualityComparer`1&quot; /&gt; implementation to use when comparing keys.">Implementación de <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> que se va a usar al comparar claves.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;comparer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="comparer" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;concurrencyLevel&quot; /&gt; or &lt;paramref name=&quot;capacity&quot; /&gt; is less than 1.">
        <paramref name="concurrencyLevel" /> o <paramref name="capacity" /> es menor que 1.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.AddOrUpdate(`0,`1,System.Func{`0,`1,`1})">
      <summary vsli:raw="Adds a key/value pair to the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt; if the key does not already exist, or updates a key/value pair in the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt; by using the specified function if the key already exists.">Agrega un par clave-valor a <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> si la clave no existe o actualiza un par clave-valor de <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> utilizando la función especificada, si la clave ya existe.</summary>
      <param name="key" vsli:raw="The key to be added or whose value should be updated.">Clave que se va a agregar o cuyo valor se va a actualizar.</param>
      <param name="addValue" vsli:raw="The value to be added for an absent key.">Valor que se va a agregar para una clave ausente.</param>
      <param name="updateValueFactory" vsli:raw="The function used to generate a new value for an existing key based on the key's existing value.">Función que se usa para generar un nuevo valor para una clave existente basándose en el valor existente de la clave.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;key&quot; /&gt; or &lt;paramref name=&quot;updateValueFactory&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="key" /> o <paramref name="updateValueFactory" /> es <see langword="null" />.</exception>
      <exception cref="T:System.OverflowException" vsli:raw="The dictionary contains too many elements.">El diccionario contiene demasiados elementos.</exception>
      <returns vsli:raw="The new value for the key. This will be either be &lt;paramref name=&quot;addValue&quot; /&gt; (if the key was absent) or the result of &lt;paramref name=&quot;updateValueFactory&quot; /&gt; (if the key was present).">Nuevo valor de la clave. Este será <paramref name="addValue" /> (si la clave no se encontró) o el resultado de <paramref name="updateValueFactory" /> (si la clave se encontró).</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.AddOrUpdate(`0,System.Func{`0,`1},System.Func{`0,`1,`1})">
      <summary vsli:raw="Uses the specified functions to add a key/value pair to the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt; if the key does not already exist, or to update a key/value pair in the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt; if the key already exists.">Utiliza las funciones especificadas para agregar un par clave-valor a <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> si la clave no existe o para actualizar un par clave-valor de <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> si la clave ya existe.</summary>
      <param name="key" vsli:raw="The key to be added or whose value should be updated.">Clave que se va a agregar o cuyo valor se va a actualizar.</param>
      <param name="addValueFactory" vsli:raw="The function used to generate a value for an absent key.">Función que se usa para generar un valor para una clave ausente.</param>
      <param name="updateValueFactory" vsli:raw="The function used to generate a new value for an existing key based on the key's existing value.">Función que se usa para generar un nuevo valor para una clave existente basándose en el valor existente de la clave.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;key&quot; /&gt;, &lt;paramref name=&quot;addValueFactory&quot; /&gt;, or &lt;paramref name=&quot;updateValueFactory&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="key" />, <paramref name="addValueFactory" /> o <paramref name="updateValueFactory" /> es <see langword="null" />.</exception>
      <exception cref="T:System.OverflowException" vsli:raw="The dictionary contains too many elements.">El diccionario contiene demasiados elementos.</exception>
      <returns vsli:raw="The new value for the key. This will be either be the result of &lt;paramref name=&quot;addValueFactory&quot; /&gt; (if the key was absent) or the result of &lt;paramref name=&quot;updateValueFactory&quot; /&gt; (if the key was present).">Nuevo valor de la clave. Este será el resultado de <paramref name="addValueFactory" /> (si la clave no se encontró) o el de <paramref name="updateValueFactory" /> (si la clave se encontró).</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.AddOrUpdate``1(`0,System.Func{`0,``0,`1},System.Func{`0,`1,``0,`1},``0)">
      <summary vsli:raw="Uses the specified functions and argument to add a key/value pair to the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt; if the key does not already exist, or to update a key/value pair in the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt; if the key already exists.">Utiliza las funciones especificadas y un argumento para agregar un par clave-valor a <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> si la clave no existe o para actualizar un par clave-valor de <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> si la clave ya existe.</summary>
      <param name="key" vsli:raw="The key to be added or whose value should be updated.">Clave que se va a agregar o cuyo valor se va a actualizar.</param>
      <param name="addValueFactory" vsli:raw="The function used to generate a value for an absent key.">Función que se usa para generar un valor para una clave ausente.</param>
      <param name="updateValueFactory" vsli:raw="The function used to generate a new value for an existing key based on the key's existing value.">Función que se usa para generar un nuevo valor para una clave existente basándose en el valor existente de la clave.</param>
      <param name="factoryArgument" vsli:raw="An argument to pass into &lt;paramref name=&quot;addValueFactory&quot; /&gt; and &lt;paramref name=&quot;updateValueFactory&quot; /&gt;.">Argumento que se pasará a <paramref name="addValueFactory" /> y <paramref name="updateValueFactory" />.</param>
      <typeparam name="TArg" vsli:raw="The type of an argument to pass into &lt;paramref name=&quot;addValueFactory&quot; /&gt; and &lt;paramref name=&quot;updateValueFactory&quot; /&gt;.">Tipo de un argumento que se va a pasar a <paramref name="addValueFactory" /> y <paramref name="updateValueFactory" /> .</typeparam>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;key&quot; /&gt;, &lt;paramref name=&quot;addValueFactory&quot; /&gt;, or &lt;paramref name=&quot;updateValueFactory&quot; /&gt; is a null reference (Nothing in Visual Basic).">
        <paramref name="key" />, <paramref name="addValueFactory" /> o <paramref name="updateValueFactory" /> es una referencia nula (Nothing en Visual Basic).</exception>
      <exception cref="T:System.OverflowException" vsli:raw="The dictionary contains too many elements.">El diccionario contiene demasiados elementos.</exception>
      <returns vsli:raw="The new value for the key. This will be either be the result of &lt;paramref name=&quot;addValueFactory&quot; /&gt; (if the key was absent) or the result of &lt;paramref name=&quot;updateValueFactory&quot; /&gt; (if the key was present).">Nuevo valor de la clave. Este será el resultado de <paramref name="addValueFactory" /> (si la clave no se encontró) o el de <paramref name="updateValueFactory" /> (si la clave se encontró).</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.Clear">
      <summary vsli:raw="Removes all keys and values from the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt;.">Quita todas las claves y valores de <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.ContainsKey(`0)">
      <summary vsli:raw="Determines whether the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt; contains the specified key.">Determina si <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> contiene la clave especificada.</summary>
      <param name="key" vsli:raw="The key to locate in the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt;.">Clave que se buscará en <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;key&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="key" /> es <see langword="null" />.</exception>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt; contains an element with the specified key; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si la colección <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> contiene un elemento con la clave especificada; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt;.">Devuelve un enumerador que recorre en iteración la colección <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</summary>
      <returns vsli:raw="An enumerator for the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt;.">Enumerador para <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,`1)">
      <summary vsli:raw="Adds a key/value pair to the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt; if the key does not already exist. Returns the new value, or the existing value if the key exists.">Agrega un par clave-valor a <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> si la clave no existe. Devuelve el nuevo valor, o el valor existente si existe la clave.</summary>
      <param name="key" vsli:raw="The key of the element to add.">Clave del elemento que se va a agregar.</param>
      <param name="value" vsli:raw="The value to be added, if the key does not already exist.">Valor que se va a agregar si la clave aún no existe.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;key&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="key" /> es <see langword="null" />.</exception>
      <exception cref="T:System.OverflowException" vsli:raw="The dictionary contains too many elements.">El diccionario contiene demasiados elementos.</exception>
      <returns vsli:raw="The value for the key. This will be either the existing value for the key if the key is already in the dictionary, or the new value if the key was not in the dictionary.">Valor de la clave. Será el valor existente de la clave si esta ya existe en el diccionario o será un nuevo valor si la clave no está en el diccionario.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,System.Func{`0,`1})">
      <summary vsli:raw="Adds a key/value pair to the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt; by using the specified function if the key does not already exist. Returns the new value, or the existing value if the key exists.">Agrega un par clave-valor a <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> utilizando la función especificada, si la clave no existe todavía. Devuelve el nuevo valor, o el valor existente si existe la clave.</summary>
      <param name="key" vsli:raw="The key of the element to add.">Clave del elemento que se va a agregar.</param>
      <param name="valueFactory" vsli:raw="The function used to generate a value for the key.">Función que se usa para generar un valor para la clave.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;key&quot; /&gt; or &lt;paramref name=&quot;valueFactory&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="key" /> o <paramref name="valueFactory" /> es <see langword="null" />.</exception>
      <exception cref="T:System.OverflowException" vsli:raw="The dictionary contains too many elements.">El diccionario contiene demasiados elementos.</exception>
      <returns vsli:raw="The value for the key. This will be either the existing value for the key if the key is already in the dictionary, or the new value if the key was not in the dictionary.">Valor de la clave. Será el valor existente de la clave si esta ya existe en el diccionario o será un nuevo valor si la clave no está en el diccionario.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd``1(`0,System.Func{`0,``0,`1},``0)">
      <summary vsli:raw="Adds a key/value pair to the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt; by using the specified function and an argument if the key does not already exist, or returns the existing value if the key exists.">Agrega un par clave-valor a <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> mediante la función especificada y un argumento si la clave aún no existe, o devuelve el valor existente si la clave ya existe.</summary>
      <param name="key" vsli:raw="The key of the element to add.">Clave del elemento que se va a agregar.</param>
      <param name="valueFactory" vsli:raw="The function used to generate a value for the key.">Función que se usa para generar un valor para la clave.</param>
      <param name="factoryArgument" vsli:raw="An argument value to pass into &lt;paramref name=&quot;valueFactory&quot; /&gt;.">Valor de argumento que se pasará a <paramref name="valueFactory" />.</param>
      <typeparam name="TArg" vsli:raw="The type of an argument to pass into &lt;paramref name=&quot;valueFactory&quot; /&gt;.">Tipo de un argumento que se va a pasar a <paramref name="valueFactory" /> .</typeparam>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;key&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; reference (Nothing in Visual Basic).">
        <paramref name="key" /> es una referencia <see langword="null" /> (Nothing en Visual Basic).</exception>
      <exception cref="T:System.OverflowException" vsli:raw="The dictionary contains too many elements.">El diccionario contiene demasiados elementos.</exception>
      <returns vsli:raw="The value for the key. This will be either the existing value for the key if the key is already in the dictionary, or the new value if the key was not in the dictionary.">Valor de la clave. Será el valor existente de la clave si esta ya existe en el diccionario o será un nuevo valor si la clave no está en el diccionario.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#Add(System.Collections.Generic.KeyValuePair{`0,`1})">
      <summary vsli:raw="Adds an item to the collection.">Agrega un elemento a la colección.</summary>
      <param name="keyValuePair" vsli:raw="The &lt;see cref=&quot;T:System.Collections.Generic.KeyValuePair`2&quot; /&gt; to add to the dictionary.">Objeto <see cref="T:System.Collections.Generic.KeyValuePair`2" /> que se va a agregar al diccionario.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;see cref=&quot;P:System.Collections.Generic.KeyValuePair`2.Key&quot; /&gt; of &lt;paramref name=&quot;keyValuePair&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">La propiedad <see cref="P:System.Collections.Generic.KeyValuePair`2.Key" /> de <paramref name="keyValuePair" /> es <see langword="null" />.</exception>
      <exception cref="T:System.OverflowException" vsli:raw="The &lt;see cref=&quot;T:System.Collections.Generic.Dictionary`2&quot; /&gt; contains too many elements.">El elemento <see cref="T:System.Collections.Generic.Dictionary`2" /> contiene demasiados elementos.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="An element with the same key already exists in the &lt;see cref=&quot;T:System.Collections.Generic.Dictionary`2&quot; /&gt;.">Ya existe un elemento con la misma clave en <see cref="T:System.Collections.Generic.Dictionary`2" />.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
      <summary vsli:raw="Gets whether the &lt;see cref=&quot;T:System.Collections.Generic.ICollection`1&quot; /&gt; contains an element with the specified key.">Obtiene un valor que indica si <see cref="T:System.Collections.Generic.ICollection`1" /> contiene un elemento con la clave especificada.</summary>
      <param name="keyValuePair" vsli:raw="The key to locate in the &lt;see cref=&quot;T:System.Collections.Generic.ICollection`1&quot; /&gt;.">Clave que se buscará en <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Collections.Generic.ICollection`1&quot; /&gt; contains an element with the specified key; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si la colección <see cref="T:System.Collections.Generic.ICollection`1" /> contiene un elemento con la clave especificada; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
      <summary vsli:raw="Copies the elements of the &lt;see cref=&quot;T:System.Collections.ICollection&quot; /&gt; to an array, starting at the specified array index.">Copia los elementos de la interfaz <see cref="T:System.Collections.ICollection" /> en una matriz, comenzando en el índice especificado de la matriz.</summary>
      <param name="array" vsli:raw="The one-dimensional array that is the destination of the elements copied from the &lt;see cref=&quot;T:System.Collections.ICollection&quot; /&gt;. The array must have zero-based indexing.">Matriz unidimensional que constituye el destino de los elementos copiados desde <see cref="T:System.Collections.ICollection" />. La matriz debe tener una indización de base cero.</param>
      <param name="index" vsli:raw="The zero-based index in &lt;paramref name=&quot;array&quot; /&gt; at which copying begins.">Índice de base cero en la <paramref name="array" /> donde comienza la copia.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="array" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;index&quot; /&gt; is less than 0.">
        <paramref name="index" /> es menor que 0.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;index&quot; /&gt; is equal to or greater than the length of the &lt;paramref name=&quot;array&quot; /&gt;.&#xA;&#xA;-or-&#xA;&#xA;The number of elements in the source &lt;see cref=&quot;T:System.Collections.ICollection&quot; /&gt; is greater than the available space from &lt;paramref name=&quot;index&quot; /&gt; to the end of the destination &lt;paramref name=&quot;array&quot; /&gt;.">
        <paramref name="index" /> es igual o mayor que la longitud del parámetro <paramref name="array" />.

o bien

El número de elementos de la <see cref="T:System.Collections.ICollection" /> de origen es mayor que el espacio disponible desde <paramref name="index" /> hasta el final de la <paramref name="array" /> de destino.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
      <summary vsli:raw="Removes the specified key/value pair from the collection.">Quita el par clave-valor especificado de la colección.</summary>
      <param name="keyValuePair" vsli:raw="The &lt;see cref=&quot;T:System.Collections.Generic.KeyValuePair`2&quot; /&gt; to remove.">
        <see cref="T:System.Collections.Generic.KeyValuePair`2" /> que se va a quitar.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;see cref=&quot;P:System.Collections.Generic.KeyValuePair`2.Key&quot; /&gt; property of &lt;paramref name=&quot;keyValuePair&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">La propiedad <see cref="P:System.Collections.Generic.KeyValuePair`2.Key" /> de <paramref name="keyValuePair" /> es <see langword="null" />.</exception>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the element is successfully removed; otherwise, &lt;see langword=&quot;false&quot; /&gt;. This method also returns false if &lt;paramref name=&quot;key&quot; /&gt; was not found in the original &lt;see cref=&quot;T:System.Collections.Generic.ICollection`1&quot; /&gt;.">Es <see langword="true" /> si el elemento se quita correctamente; en caso contrario, es <see langword="false" />. Este método también devuelve false si no se encontró <paramref name="key" /> en la <see cref="T:System.Collections.Generic.ICollection`1" /> original.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#IDictionary{TKey@TValue}#Add(`0,`1)">
      <summary vsli:raw="Adds the specified key and value to the &lt;see cref=&quot;T:System.Collections.Generic.IDictionary`2&quot; /&gt;.">Agrega la clave y el valor especificados a <see cref="T:System.Collections.Generic.IDictionary`2" />.</summary>
      <param name="key" vsli:raw="The object to use as the key of the element to add.">Objeto que se va a utilizar como clave del elemento que se va a agregar.</param>
      <param name="value" vsli:raw="The object to use as the value of the element to add.">El objeto que se va a usar como valor del elemento que se va a agregar.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;key&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="key" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="An element with the same key already exists in the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt;.">Ya existe un elemento con la misma clave en <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</exception>
      <exception cref="T:System.OverflowException" vsli:raw="The dictionary contains too many elements.">El diccionario contiene demasiados elementos.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#IDictionary{TKey@TValue}#Remove(`0)">
      <summary vsli:raw="Removes the element with the specified key from the &lt;see cref=&quot;T:System.Collections.Generic.IDictionary`2&quot; /&gt;.">Quita el elemento con la clave especificada de <see cref="T:System.Collections.Generic.IDictionary`2" />.</summary>
      <param name="key" vsli:raw="The key of the element to remove.">Clave del elemento que se va a quitar.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;key&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="key" /> es <see langword="null" />.</exception>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the element is successfully removed; otherwise, &lt;see langword=&quot;false&quot; /&gt;. This method also returns &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;key&quot; /&gt; was not found in the original &lt;see cref=&quot;T:System.Collections.Generic.IDictionary`2&quot; /&gt;.">Es <see langword="true" /> si el elemento se quita correctamente; en caso contrario, es <see langword="false" />. Este método también devuelve <see langword="false" /> si no se encontró <paramref name="key" /> en el objeto <see cref="T:System.Collections.Generic.IDictionary`2" /> original.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
      <summary vsli:raw="Copies the elements of the &lt;see cref=&quot;T:System.Collections.ICollection&quot; /&gt; to an array, starting at the specified array index.">Copia los elementos de la interfaz <see cref="T:System.Collections.ICollection" /> en una matriz, comenzando en el índice especificado de la matriz.</summary>
      <param name="array" vsli:raw="The one-dimensional array that is the destination of the elements copied from the &lt;see cref=&quot;T:System.Collections.ICollection&quot; /&gt;. The array must have zero-based indexing.">Matriz unidimensional que constituye el destino de los elementos copiados desde <see cref="T:System.Collections.ICollection" />. La matriz debe tener una indización de base cero.</param>
      <param name="index" vsli:raw="The zero-based index in &lt;paramref name=&quot;array&quot; /&gt; at which copying begins.">Índice de base cero en la <paramref name="array" /> donde comienza la copia.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="array" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;index&quot; /&gt; is less than 0.">
        <paramref name="index" /> es menor que 0.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;index&quot; /&gt; is equal to or greater than the length of the &lt;paramref name=&quot;array&quot; /&gt;.&#xA;&#xA; -or-&#xA;&#xA; The number of elements in the source &lt;see cref=&quot;T:System.Collections.ICollection&quot; /&gt; is greater than the available space from &lt;paramref name=&quot;index&quot; /&gt; to the end of the destination &lt;paramref name=&quot;array&quot; /&gt;.">
        <paramref name="index" /> es igual o mayor que la longitud del parámetro <paramref name="array" />.  
  
o bien 
El número de elementos de la <see cref="T:System.Collections.ICollection" /> de origen es mayor que el espacio disponible desde <paramref name="index" /> hasta el final de la <paramref name="array" /> de destino.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Add(System.Object,System.Object)">
      <summary vsli:raw="Adds the specified key and value to the dictionary.">Agrega la clave y el valor especificados al diccionario.</summary>
      <param name="key" vsli:raw="The object to use as the key.">Objeto que se va a utilizar como clave.</param>
      <param name="value" vsli:raw="The object to use as the value.">Objeto que se va a utilizar como valor.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;key&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="key" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;key&quot; /&gt; is of a type that is not assignable to the key type  of the &lt;see cref=&quot;T:System.Collections.Generic.Dictionary`2&quot; /&gt;.&#xA;&#xA; -or-&#xA;&#xA; &lt;paramref name=&quot;value&quot; /&gt; is of a type that is not assignable to the type of values in the &lt;see cref=&quot;T:System.Collections.Generic.Dictionary`2&quot; /&gt;.&#xA;&#xA; -or-&#xA;&#xA; A value with the same key already exists in the &lt;see cref=&quot;T:System.Collections.Generic.Dictionary`2&quot; /&gt;.">
        <paramref name="key" /> es de un tipo que no se puede asignar al tipo de clave de <see cref="T:System.Collections.Generic.Dictionary`2" />.  
  
o bien 
 <paramref name="value" /> es de un tipo que no se puede asignar a <see cref="T:System.Collections.Generic.Dictionary`2" />, que es el tipo de los valores que hay en la colección.  
  
o bien 
Ya existe un valor con la misma clave en la colección <see cref="T:System.Collections.Generic.Dictionary`2" />.</exception>
      <exception cref="T:System.OverflowException" vsli:raw="The dictionary contains too many elements.">El diccionario contiene demasiados elementos.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Contains(System.Object)">
      <summary vsli:raw="Gets a value that indicates the &lt;see cref=&quot;T:System.Collections.Generic.IDictionary`2&quot; /&gt; contains an element with the specified key.">Obtiene un valor que indica si <see cref="T:System.Collections.Generic.IDictionary`2" /> contiene un elemento con la clave especificada.</summary>
      <param name="key" vsli:raw="The key to locate in the &lt;see cref=&quot;T:System.Collections.Generic.IDictionary`2&quot; /&gt;.">Clave que se buscará en <see cref="T:System.Collections.Generic.IDictionary`2" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;key&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="key" /> es <see langword="null" />.</exception>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Collections.Generic.IDictionary`2&quot; /&gt; contains an element with the specified key; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si la colección <see cref="T:System.Collections.Generic.IDictionary`2" /> contiene un elemento con la clave especificada; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#GetEnumerator">
      <summary vsli:raw="Provides a &lt;see cref=&quot;T:System.Collections.IDictionaryEnumerator&quot; /&gt; for the &lt;see cref=&quot;T:System.Collections.Generic.IDictionary`2&quot; /&gt;.">Proporciona un objeto <see cref="T:System.Collections.IDictionaryEnumerator" /> para el objeto <see cref="T:System.Collections.Generic.IDictionary`2" />.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Collections.IDictionaryEnumerator&quot; /&gt; for the &lt;see cref=&quot;T:System.Collections.Generic.IDictionary`2&quot; /&gt;.">Estructura <see cref="T:System.Collections.IDictionaryEnumerator" /> para la colección <see cref="T:System.Collections.Generic.IDictionary`2" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Remove(System.Object)">
      <summary vsli:raw="Removes the element with the specified key from the &lt;see cref=&quot;T:System.Collections.IDictionary&quot; /&gt;.">Quita el elemento con la clave especificada de <see cref="T:System.Collections.IDictionary" />.</summary>
      <param name="key" vsli:raw="The key of the element to remove.">Clave del elemento que se va a quitar.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;key&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="key" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt;.">Devuelve un enumerador que recorre en iteración la colección <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</summary>
      <returns vsli:raw="An enumerator for the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt;.">Enumerador para <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.ToArray">
      <summary vsli:raw="Copies the key and value pairs stored in the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt; to a new array.">Copia en una nueva matriz los pares valor-clave almacenados en <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</summary>
      <returns vsli:raw="A new array containing a snapshot of key and value pairs copied from the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt;.">Nueva matriz que contiene una instantánea de los pares clave-valor copiados de la colección <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryAdd(`0,`1)">
      <summary vsli:raw="Attempts to add the specified key and value to the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt;.">Intenta agregar la clave y el valor especificados a la colección <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</summary>
      <param name="key" vsli:raw="The key of the element to add.">Clave del elemento que se va a agregar.</param>
      <param name="value" vsli:raw="The value of the element to add. The value can be  &lt;see langword=&quot;null&quot; /&gt; for reference types.">Valor del elemento que se va a agregar. El valor puede ser <see langword="null" /> para los tipos de referencia.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;key&quot; /&gt; is  &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="key" /> es <see langword="null" />.</exception>
      <exception cref="T:System.OverflowException" vsli:raw="The dictionary contains too many elements.">El diccionario contiene demasiados elementos.</exception>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the key/value pair was added to the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt; successfully; &lt;see langword=&quot;false&quot; /&gt; if the key already exists.">Es <see langword="true" /> si el par clave-valor se agregó a <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> correctamente; es <see langword="false" /> si la clave ya existe.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryGetValue(`0,`1@)">
      <summary vsli:raw="Attempts to get the value associated with the specified key from the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt;.">Intenta obtener el valor asociado a la clave especificada de <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</summary>
      <param name="key" vsli:raw="The key of the value to get.">Clave del valor que se va a obtener.</param>
      <param name="value" vsli:raw="When this method returns, contains the object from the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt; that has the specified key, or the default value of the type if the operation failed.">Cuando este método devuelve un valor, contiene el objeto del elemento <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> con la clave especificada o el valor predeterminado del tipo si se produjo un error en la operación.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;key&quot; /&gt; is  &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="key" /> es <see langword="null" />.</exception>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the key was found in the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si se encontró la clave en <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryRemove(`0,`1@)">
      <summary vsli:raw="Attempts to remove and return the value that has the specified key from the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt;.">Intenta quitar y devolver el valor que tiene la clave especificada de <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</summary>
      <param name="key" vsli:raw="The key of the element to remove and return.">Clave del elemento que se va a quitar y devolver.</param>
      <param name="value" vsli:raw="When this method returns, contains the object removed from the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt;, or the default value of  the &lt;see langword=&quot;TValue&quot; /&gt; type if &lt;paramref name=&quot;key&quot; /&gt; does not exist.">Cuando este método devuelve un valor, contiene el objeto quitado de <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />, o el valor predeterminado del tipo <see langword="TValue" /> si <paramref name="key" /> no existe.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;key&quot; /&gt; is  &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="key" /> es <see langword="null" />.</exception>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the object was removed successfully; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si el objeto se ha quitado correctamente; en caso contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryRemove(System.Collections.Generic.KeyValuePair{`0,`1})">
      <summary vsli:raw="Removes a key and value from the dictionary.">Quita una clave y valor del diccionario.</summary>
      <param name="item" vsli:raw="The &lt;see cref=&quot;T:System.Collections.Generic.KeyValuePair`2&quot; /&gt; representing the key and value to remove.">Elemento <see cref="T:System.Collections.Generic.KeyValuePair`2" /> que representa la clave y el valor que se deben eliminar.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;see cref=&quot;P:System.Collections.Generic.KeyValuePair`2.Key&quot; /&gt; property of &lt;paramref name=&quot;item&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">La propiedad <see cref="P:System.Collections.Generic.KeyValuePair`2.Key" /> de <paramref name="item" /> es <see langword="null" />.</exception>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the key and value represented by &lt;paramref name=&quot;item&quot; /&gt; are successfully found and removed; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si la clave y el valor que representa <paramref name="item" /> se encuentran y quitan correctamente; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryUpdate(`0,`1,`1)">
      <summary vsli:raw="Updates the value associated with &lt;paramref name=&quot;key&quot; /&gt; to &lt;paramref name=&quot;newValue&quot; /&gt; if the existing value with &lt;paramref name=&quot;key&quot; /&gt; is equal to &lt;paramref name=&quot;comparisonValue&quot; /&gt;.">Actualiza el valor asociado a <paramref name="key" /> a <paramref name="newValue" /> si el valor existente con <paramref name="key" /> es igual a <paramref name="comparisonValue" />.</summary>
      <param name="key" vsli:raw="The key of the value that is compared with &lt;paramref name=&quot;comparisonValue&quot; /&gt; and possibly replaced.">Clave cuyo valor se compara con <paramref name="comparisonValue" /> y que posiblemente se reemplace.</param>
      <param name="newValue" vsli:raw="The value that replaces the value of the element that has the specified &lt;paramref name=&quot;key&quot; /&gt; if the comparison results in equality.">Valor que reemplaza el valor del elemento que ha especificado <paramref name="key" /> si al compararlos se determina que son iguales.</param>
      <param name="comparisonValue" vsli:raw="The value that is compared with the value of the element that has the specified &lt;paramref name=&quot;key&quot; /&gt;.">Valor que se compara con el valor del elemento que tiene el elemento <paramref name="key" /> especificado.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;key&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="key" /> es <see langword="null" />.</exception>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the value with &lt;paramref name=&quot;key&quot; /&gt; was equal to &lt;paramref name=&quot;comparisonValue&quot; /&gt; and was replaced with &lt;paramref name=&quot;newValue&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el valor con <paramref name="key" /> fue igual a <paramref name="comparisonValue" /> y se sustituyó por <paramref name="newValue" />; si no, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.Count">
      <summary vsli:raw="Gets the number of key/value pairs contained in the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt;.">Obtiene el número de pares clave-valor incluidos en <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</summary>
      <exception cref="T:System.OverflowException" vsli:raw="The dictionary contains too many elements.">El diccionario contiene demasiados elementos.</exception>
      <returns vsli:raw="The number of key/value pairs contained in the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt;.">Número de pares clave-valor incluidos en <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.IsEmpty">
      <summary vsli:raw="Gets a value that indicates whether the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt; is empty.">Obtiene un valor que indica si <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> está vacía.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt; is empty; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> está vacío, en caso contrario, es <see langword="false" />.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.Item(`0)">
      <summary vsli:raw="Gets or sets the value associated with the specified key.">Obtiene o establece el valor asociado a la clave especificada.</summary>
      <param name="key" vsli:raw="The key of the value to get or set.">Clave del valor que se va a obtener o establecer.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;key&quot; /&gt; is  &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="key" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Collections.Generic.KeyNotFoundException" vsli:raw="The property is retrieved and &lt;paramref name=&quot;key&quot; /&gt; does not exist in the collection.">La propiedad se recupera y <paramref name="key" /> no existe en la colección.</exception>
      <returns vsli:raw="The value of the key/value pair at the specified index.">El valor del par clave-valor situado en índice especificado.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.Keys">
      <summary vsli:raw="Gets a collection containing the keys in the &lt;see cref=&quot;T:System.Collections.Generic.Dictionary`2&quot; /&gt;.">Obtiene una colección que contiene las claves de <see cref="T:System.Collections.Generic.Dictionary`2" />.</summary>
      <returns vsli:raw="A collection of keys in the &lt;see cref=&quot;T:System.Collections.Generic.Dictionary`2&quot; /&gt;.">Colección de todas las claves de <see cref="T:System.Collections.Generic.Dictionary`2" />.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#IsReadOnly">
      <summary vsli:raw="Gets a value that indicates whether the &lt;see cref=&quot;T:System.Collections.ICollection&quot; /&gt; is read-only.">Obtiene un valor que indica si <see cref="T:System.Collections.ICollection" /> es de solo lectura.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Collections.ICollection&quot; /&gt; is read-only; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si la interfaz <see cref="T:System.Collections.ICollection" /> es de solo lectura; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#IReadOnlyDictionary{TKey@TValue}#Keys">
      <summary vsli:raw="Gets a collection containing the keys in the &lt;see cref=&quot;T:System.Collections.Generic.Dictionary`2&quot; /&gt;.">Obtiene una colección que contiene las claves de <see cref="T:System.Collections.Generic.Dictionary`2" />.</summary>
      <returns vsli:raw="A collection containing the keys in the &lt;see cref=&quot;T:System.Collections.Generic.Dictionary`2&quot; /&gt;.">Colección que contiene las claves de <see cref="T:System.Collections.Generic.Dictionary`2" />.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#IReadOnlyDictionary{TKey@TValue}#Values">
      <summary vsli:raw="Gets a collection that contains the values in the &lt;see cref=&quot;T:System.Collections.Generic.Dictionary`2&quot; /&gt;.">Obtiene una colección que contiene los valores de <see cref="T:System.Collections.Generic.Dictionary`2" />.</summary>
      <returns vsli:raw="A collection that contains the values in the &lt;see cref=&quot;T:System.Collections.Generic.Dictionary`2&quot; /&gt;.">Colección que contiene los valores de <see cref="T:System.Collections.Generic.Dictionary`2" />.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#ICollection#IsSynchronized">
      <summary vsli:raw="Gets a value that indicates whether access to the &lt;see cref=&quot;T:System.Collections.ICollection&quot; /&gt; is synchronized with the SyncRoot.">Obtiene un valor que indica si el acceso a <see cref="T:System.Collections.ICollection" /> está sincronizado con SyncRoot.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if access to the &lt;see cref=&quot;T:System.Collections.ICollection&quot; /&gt; is synchronized (thread safe); otherwise, &lt;see langword=&quot;false&quot; /&gt;. For &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt; this property always returns &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si el acceso a <see cref="T:System.Collections.ICollection" /> está sincronizado (es seguro para subprocesos); de lo contrario, es <see langword="false" />. Para <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> esta propiedad siempre devuelve <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#ICollection#SyncRoot">
      <summary vsli:raw="Gets an object that can be used to synchronize access to the &lt;see cref=&quot;T:System.Collections.ICollection&quot; /&gt;. This property is not supported.">Obtiene un objeto que se puede usar para sincronizar el acceso a <see cref="T:System.Collections.ICollection" />. Esta propiedad no es compatible.</summary>
      <exception cref="T:System.NotSupportedException" vsli:raw="This property is not supported.">Esta propiedad no es compatible.</exception>
      <returns vsli:raw="Always returns null.">Siempre devuelve null.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#IsFixedSize">
      <summary vsli:raw="Gets a value that indicates whether the &lt;see cref=&quot;T:System.Collections.Generic.IDictionary`2&quot; /&gt; has a fixed size.">Obtiene un valor que indica si el objeto <see cref="T:System.Collections.Generic.IDictionary`2" /> tiene un tamaño fijo.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Collections.Generic.IDictionary`2&quot; /&gt; has a fixed size; otherwise, &lt;see langword=&quot;false&quot; /&gt;. For &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt;, this property always returns &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si la <see cref="T:System.Collections.Generic.IDictionary`2" /> tiene un tamaño fijo; en caso contrario, <see langword="false" />. Para <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />, esta propiedad siempre devuelve <see langword="false" />.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#IsReadOnly">
      <summary vsli:raw="Gets a value that indicates whether the &lt;see cref=&quot;T:System.Collections.Generic.IDictionary`2&quot; /&gt; is read-only.">Obtiene un valor que indica si <see cref="T:System.Collections.Generic.IDictionary`2" /> es de solo lectura.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Collections.Generic.IDictionary`2&quot; /&gt; is read-only; otherwise, &lt;see langword=&quot;false&quot; /&gt;. For &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt;, this property always returns &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si la interfaz <see cref="T:System.Collections.Generic.IDictionary`2" /> es de solo lectura; de lo contrario, es <see langword="false" />. Para <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />, esta propiedad siempre devuelve <see langword="false" />.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Item(System.Object)">
      <summary vsli:raw="Gets or sets the value associated with the specified key.">Obtiene o establece el valor asociado a la clave especificada.</summary>
      <param name="key" vsli:raw="The key of the value to get or set.">Clave del valor que se va a obtener o establecer.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;key&quot; /&gt; is  &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="key" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="A value is being assigned, and &lt;paramref name=&quot;key&quot; /&gt; is of a type that is not assignable to the key type or the value type of the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt;.">Se está asignando un valor, y <paramref name="key" /> es de un tipo no asignable al tipo de clave o al tipo de valor de <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</exception>
      <returns vsli:raw="The value associated with the specified key, or  &lt;see langword=&quot;null&quot; /&gt; if &lt;paramref name=&quot;key&quot; /&gt; is not in the dictionary or &lt;paramref name=&quot;key&quot; /&gt; is of a type that is not assignable to the key type of the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentDictionary`2&quot; /&gt;.">Valor asociado a la clave especificada, o <see langword="null" /> si <paramref name="key" /> no está en el diccionario o si <paramref name="key" /> es de un tipo no asignable al tipo de clave <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Keys">
      <summary vsli:raw="Gets an &lt;see cref=&quot;T:System.Collections.ICollection&quot; /&gt; that contains the keys of the  &lt;see cref=&quot;T:System.Collections.Generic.IDictionary`2&quot; /&gt;.">Obtiene un elemento <see cref="T:System.Collections.ICollection" /> que contiene las claves de <see cref="T:System.Collections.Generic.IDictionary`2" />.</summary>
      <returns vsli:raw="An interface that contains the keys of the &lt;see cref=&quot;T:System.Collections.Generic.IDictionary`2&quot; /&gt;.">Interfaz que contiene las claves de <see cref="T:System.Collections.Generic.IDictionary`2" />.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Values">
      <summary vsli:raw="Gets an &lt;see cref=&quot;T:System.Collections.ICollection&quot; /&gt; that contains the values in the &lt;see cref=&quot;T:System.Collections.IDictionary&quot; /&gt;.">Obtiene un <see cref="T:System.Collections.ICollection" /> que contiene los valores de <see cref="T:System.Collections.IDictionary" />.</summary>
      <returns vsli:raw="An interface that contains the values in the &lt;see cref=&quot;T:System.Collections.IDictionary&quot; /&gt;.">Interfaz que contiene los valores de <see cref="T:System.Collections.IDictionary" />.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.Values">
      <summary vsli:raw="Gets a collection that contains the values in the &lt;see cref=&quot;T:System.Collections.Generic.Dictionary`2&quot; /&gt;.">Obtiene una colección que contiene los valores de <see cref="T:System.Collections.Generic.Dictionary`2" />.</summary>
      <returns vsli:raw="A collection that contains the values in the &lt;see cref=&quot;T:System.Collections.Generic.Dictionary`2&quot; /&gt;.">Colección que contiene los valores de <see cref="T:System.Collections.Generic.Dictionary`2" />.</returns>
    </member>
    <member name="T:System.Collections.Concurrent.ConcurrentQueue`1">
      <summary vsli:raw="Represents a thread-safe first in-first out (FIFO) collection.">Representa una colección de objetos FIFO (primero en entrar, primero en salir) que es segura para subprocesos.</summary>
      <typeparam name="T" vsli:raw="The type of the elements contained in the queue.">Tipo de elementos que contiene la cola.</typeparam>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentQueue`1&quot; /&gt; class.">Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" />.</summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentQueue`1&quot; /&gt; class that contains elements copied from the specified collection.">Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" /> que contiene los elementos copiados de la colección especificada.</summary>
      <param name="collection" vsli:raw="The collection whose elements are copied to the new &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentQueue`1&quot; /&gt;.">Colección cuyos elementos se copian en el nuevo <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;collection&quot; /&gt; argument is null.">El argumento <paramref name="collection" /> es null.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.Clear">
      <summary vsli:raw="Removes all objects from the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentQueue`1&quot; /&gt;.">Quita todos los objetos de la colección <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" />.</summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.CopyTo(`0[],System.Int32)">
      <summary vsli:raw="Copies the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentQueue`1&quot; /&gt; elements to an existing one-dimensional &lt;see cref=&quot;T:System.Array&quot; /&gt;, starting at the specified array index.">Copia los elementos de <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" /> en una <see cref="T:System.Array" /> unidimensional existente, a partir del índice especificado de la matriz.</summary>
      <param name="array" vsli:raw="The one-dimensional &lt;see cref=&quot;T:System.Array&quot; /&gt; that is the destination of the elements copied from the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentQueue`1&quot; /&gt;. The &lt;see cref=&quot;T:System.Array&quot; /&gt; must have zero-based indexing.">Matriz <see cref="T:System.Array" /> unidimensional que constituye el destino de los elementos copiados desde la colección <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" />. <see cref="T:System.Array" /> debe tener una indización de base cero.</param>
      <param name="index" vsli:raw="The zero-based index in &lt;paramref name=&quot;array&quot; /&gt; at which copying begins.">Índice de base cero en la <paramref name="array" /> donde comienza la copia.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt; is a null reference (Nothing in Visual Basic).">
        <paramref name="array" /> es una referencia nula (nada en Visual Basic).</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;index&quot; /&gt; is less than zero.">
        <paramref name="index" /> es menor que cero.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;index&quot; /&gt; is equal to or greater than the length of the &lt;paramref name=&quot;array&quot; /&gt; -or- The number of elements in the source &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentQueue`1&quot; /&gt; is greater than the available space from &lt;paramref name=&quot;index&quot; /&gt; to the end of the destination &lt;paramref name=&quot;array&quot; /&gt;.">
        <paramref name="index" /> es igual o mayor que la longitud de la matriz <paramref name="array" /> -o bien- el número de elementos de la colección <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" /> de origen es mayor que el espacio disponible desde <paramref name="index" /> hasta el final del parámetro <paramref name="array" /> de destino.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.Enqueue(`0)">
      <summary vsli:raw="Adds an object to the end of the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentQueue`1&quot; /&gt;.">Agrega un objeto al final de <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" />.</summary>
      <param name="item" vsli:raw="The object to add to the end of the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentQueue`1&quot; /&gt;. The value can be a null reference (Nothing in Visual Basic) for reference types.">Objeto que se va a agregar al final de <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" />. El valor puede ser una referencia nula (Nothing en Visual Basic) para los tipos de referencia.</param>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentQueue`1&quot; /&gt;.">Devuelve un enumerador que recorre en iteración la colección <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" />.</summary>
      <returns vsli:raw="An enumerator for the contents of the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentQueue`1&quot; /&gt;.">Enumerador para los contenidos de <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.System#Collections#Concurrent#IProducerConsumerCollection{T}#TryAdd(`0)">
      <summary vsli:raw="Attempts to add an object to the &lt;see cref=&quot;T:System.Collections.Concurrent.IProducerConsumerCollection`1&quot; /&gt;.">Intenta agregar un objeto a <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" />.</summary>
      <param name="item" vsli:raw="The object to add to the &lt;see cref=&quot;T:System.Collections.Concurrent.IProducerConsumerCollection`1&quot; /&gt;. The value can be a null reference (Nothing in Visual Basic) for reference types.">Objeto que se va a agregar a <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" />. El valor puede ser una referencia nula (Nothing en Visual Basic) para los tipos de referencia.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the object was added successfully; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el objeto se ha agregado correctamente; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.System#Collections#Concurrent#IProducerConsumerCollection{T}#TryTake(`0@)">
      <summary vsli:raw="Attempts to remove and return an object from the &lt;see cref=&quot;T:System.Collections.Concurrent.IProducerConsumerCollection`1&quot; /&gt;.">Intenta quitar y devolver un objeto de <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" />.</summary>
      <param name="item" vsli:raw="When this method returns, if the operation was successful, &lt;paramref name=&quot;item&quot; /&gt; contains the object removed. If no object was available to be removed, the value is unspecified.">Cuando este método devuelve un valor, si la operación se realizó correctamente, <paramref name="item" /> contiene el objeto que se ha quitado. Si no había ningún objeto para quitar, el valor estará sin especificar.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if an element was removed and returned successfully; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el elemento se ha quitado y devuelto correctamente; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
      <summary vsli:raw="Copies the elements of the &lt;see cref=&quot;T:System.Collections.ICollection&quot; /&gt; to an &lt;see cref=&quot;T:System.Array&quot; /&gt;, starting at a particular &lt;see cref=&quot;T:System.Array&quot; /&gt; index.">Copia los elementos de <see cref="T:System.Collections.ICollection" /> en <see cref="T:System.Array" />, empezando por un índice determinado de <see cref="T:System.Array" />.</summary>
      <param name="array" vsli:raw="The one-dimensional &lt;see cref=&quot;T:System.Array&quot; /&gt; that is the destination of the elements copied from the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentBag`1&quot; /&gt;. The &lt;see cref=&quot;T:System.Array&quot; /&gt; must have zero-based indexing.">Matriz <see cref="T:System.Array" /> unidimensional que constituye el destino de los elementos copiados desde la colección <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" />. <see cref="T:System.Array" /> debe tener una indización de base cero.</param>
      <param name="index" vsli:raw="The zero-based index in &lt;paramref name=&quot;array&quot; /&gt; at which copying begins.">Índice de base cero en la <paramref name="array" /> donde comienza la copia.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt; is a null reference (Nothing in Visual Basic).">
        <paramref name="array" /> es una referencia nula (nada en Visual Basic).</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;index&quot; /&gt; is less than zero.">
        <paramref name="index" /> es menor que cero.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt; is multidimensional. -or- &lt;paramref name=&quot;array&quot; /&gt; does not have zero-based indexing. -or- &lt;paramref name=&quot;index&quot; /&gt; is equal to or greater than the length of the &lt;paramref name=&quot;array&quot; /&gt; -or- The number of elements in the source &lt;see cref=&quot;T:System.Collections.ICollection&quot; /&gt; is greater than the available space from &lt;paramref name=&quot;index&quot; /&gt; to the end of the destination &lt;paramref name=&quot;array&quot; /&gt;. -or- The type of the source &lt;see cref=&quot;T:System.Collections.ICollection&quot; /&gt; cannot be cast automatically to the type of the destination &lt;paramref name=&quot;array&quot; /&gt;.">
        <paramref name="array" /> es multidimensional. -o bien- <paramref name="array" /> no tiene índices de base cero. -o bien- <paramref name="index" /> es igual o mayor que la longitud de la matriz <paramref name="array" /> -o bien- el número de elementos de la colección <see cref="T:System.Collections.ICollection" /> de origen es mayor que el espacio disponible desde <paramref name="index" /> hasta el final del parámetro <paramref name="array" /> de destino. -o bien- el tipo de la colección <see cref="T:System.Collections.ICollection" /> de origen no puede convertirse automáticamente al tipo del parámetro <paramref name="array" /> de destino.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Devuelve un enumerador que recorre en iteración una colección.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; that can be used to iterate through the collection.">
        <see cref="T:System.Collections.IEnumerator" /> que se puede utilizar para recorrer en iteración la colección.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.ToArray">
      <summary vsli:raw="Copies the elements stored in the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentQueue`1&quot; /&gt; to a new array.">Copia los elementos almacenados en <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" /> a una nueva matriz.</summary>
      <returns vsli:raw="A new array containing a snapshot of elements copied from the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentQueue`1&quot; /&gt;.">Nueva matriz que contiene una instantánea de los elementos copiados de <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.TryDequeue(`0@)">
      <summary vsli:raw="Tries to remove and return the object at the beginning of the concurrent queue.">Intenta quitar y devolver el objeto situado al principio de la cola simultánea.</summary>
      <param name="result" vsli:raw="When this method returns, if the operation was successful, &lt;paramref name=&quot;result&quot; /&gt; contains the object removed. If no object was available to be removed, the value is unspecified.">Cuando este método devuelve un valor, si la operación se realizó correctamente, <paramref name="result" /> contiene el objeto que se ha quitado. Si no había ningún objeto para quitar, el valor estará sin especificar.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if an element was removed and returned from the beginning of the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentQueue`1&quot; /&gt; successfully; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si se quitó y se devolvió correctamente el elemento situado al principio de <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" />; en caso contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.TryPeek(`0@)">
      <summary vsli:raw="Tries to return an object from the beginning of the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentQueue`1&quot; /&gt; without removing it.">Intenta devolver un objeto situado al principio de <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" /> sin quitarlo.</summary>
      <param name="result" vsli:raw="When this method returns, &lt;paramref name=&quot;result&quot; /&gt; contains an object from the beginning of the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentQueue`1&quot; /&gt; or an unspecified value if the operation failed.">Cuando este método vuelve, <paramref name="result" /> contiene un objeto situado al principio de <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" /> o un valor sin especificar si la operación no se realizó correctamente.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if an object was returned successfully; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si se devolvió correctamente un objeto; en caso contrario, es <see langword="false" />.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentQueue`1.Count">
      <summary vsli:raw="Gets the number of elements contained in the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentQueue`1&quot; /&gt;.">Obtiene el número de elementos incluidos en <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" />.</summary>
      <returns vsli:raw="The number of elements contained in the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentQueue`1&quot; /&gt;.">Número de elementos contenidos en <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" />.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentQueue`1.IsEmpty">
      <summary vsli:raw="Gets a value that indicates whether the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentQueue`1&quot; /&gt; is empty.">Obtiene un valor que indica si <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" /> está vacía.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentQueue`1&quot; /&gt; is empty; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" /> está vacío, en caso contrario, es <see langword="false" />.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentQueue`1.System#Collections#ICollection#IsSynchronized">
      <summary vsli:raw="Gets a value indicating whether access to the &lt;see cref=&quot;T:System.Collections.ICollection&quot; /&gt; is synchronized with the SyncRoot.">Obtiene un valor que indica si el acceso a <see cref="T:System.Collections.ICollection" /> está sincronizado con SyncRoot.</summary>
      <returns vsli:raw="Always returns &lt;see langword=&quot;false&quot; /&gt; to indicate access is not synchronized.">Siempre devuelve <see langword="false" /> para indicar que el acceso no está sincronizado.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentQueue`1.System#Collections#ICollection#SyncRoot">
      <summary vsli:raw="Gets an object that can be used to synchronize access to the &lt;see cref=&quot;T:System.Collections.ICollection&quot; /&gt;. This property is not supported.">Obtiene un objeto que se puede usar para sincronizar el acceso a <see cref="T:System.Collections.ICollection" />. Esta propiedad no es compatible.</summary>
      <exception cref="T:System.NotSupportedException" vsli:raw="The SyncRoot property is not supported.">La propiedad SyncRoot no es compatible.</exception>
      <returns vsli:raw="Returns &lt;see langword=&quot;null&quot; /&gt;.">Devuelve <see langword="null" />.</returns>
    </member>
    <member name="T:System.Collections.Concurrent.ConcurrentStack`1">
      <summary vsli:raw="Represents a thread-safe last in-first out (LIFO) collection.">Representa una colección de objetos LIFO (último en entrar, primero en salir) que es segura para subprocesos.</summary>
      <typeparam name="T" vsli:raw="The type of the elements contained in the stack.">Tipo de elementos incluidos en la pila.</typeparam>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentStack`1&quot; /&gt; class.">Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentStack`1&quot; /&gt; class that contains elements copied from the specified collection.">Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> que contiene los elementos copiados de la colección especificada.</summary>
      <param name="collection" vsli:raw="The collection whose elements are copied to the new &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentStack`1&quot; /&gt;.">Colección cuyos elementos se copian en el nuevo <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;collection&quot; /&gt; argument is null.">El argumento <paramref name="collection" /> es null.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.Clear">
      <summary vsli:raw="Removes all objects from the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentStack`1&quot; /&gt;.">Quita todos los objetos de la colección <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.CopyTo(`0[],System.Int32)">
      <summary vsli:raw="Copies the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentStack`1&quot; /&gt; elements to an existing one-dimensional &lt;see cref=&quot;T:System.Array&quot; /&gt;, starting at the specified array index.">Copia los elementos de <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> en una <see cref="T:System.Array" /> unidimensional existente, a partir del índice especificado de la matriz.</summary>
      <param name="array" vsli:raw="The one-dimensional &lt;see cref=&quot;T:System.Array&quot; /&gt; that is the destination of the elements copied from the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentStack`1&quot; /&gt;. The &lt;see cref=&quot;T:System.Array&quot; /&gt; must have zero-based indexing.">Matriz <see cref="T:System.Array" /> unidimensional que constituye el destino de los elementos copiados desde la colección <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />. <see cref="T:System.Array" /> debe tener una indización de base cero.</param>
      <param name="index" vsli:raw="The zero-based index in &lt;paramref name=&quot;array&quot; /&gt; at which copying begins.">Índice de base cero en la <paramref name="array" /> donde comienza la copia.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt; is a null reference (Nothing in Visual Basic).">
        <paramref name="array" /> es una referencia nula (nada en Visual Basic).</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;index&quot; /&gt; is less than zero.">
        <paramref name="index" /> es menor que cero.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;index&quot; /&gt; is equal to or greater than the length of the &lt;paramref name=&quot;array&quot; /&gt; -or- The number of elements in the source &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentStack`1&quot; /&gt; is greater than the available space from &lt;paramref name=&quot;index&quot; /&gt; to the end of the destination &lt;paramref name=&quot;array&quot; /&gt;.">
        <paramref name="index" /> es igual o mayor que la longitud de la matriz <paramref name="array" /> -o bien- el número de elementos de la colección <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> de origen es mayor que el espacio disponible desde <paramref name="index" /> hasta el final del parámetro <paramref name="array" /> de destino.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentStack`1&quot; /&gt;.">Devuelve un enumerador que recorre en iteración la colección <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</summary>
      <returns vsli:raw="An enumerator for the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentStack`1&quot; /&gt;.">Enumerador para <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.Push(`0)">
      <summary vsli:raw="Inserts an object at the top of the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentStack`1&quot; /&gt;.">Inserta un objeto al principio de <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</summary>
      <param name="item" vsli:raw="The object to push onto the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentStack`1&quot; /&gt;. The value can be a null reference (Nothing in Visual Basic) for reference types.">Objeto que se va a insertar en la colección <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />. El valor puede ser una referencia nula (Nothing en Visual Basic) para los tipos de referencia.</param>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.PushRange(`0[])">
      <summary vsli:raw="Inserts multiple objects at the top of the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentStack`1&quot; /&gt; atomically.">Inserta atómicamente varios objetos al principio de <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</summary>
      <param name="items" vsli:raw="The objects to push onto the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentStack`1&quot; /&gt;.">Objetos que se van a insertar en la colección <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;items&quot; /&gt; is a null reference (Nothing in Visual Basic).">
        <paramref name="items" /> es una referencia nula (nada en Visual Basic).</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.PushRange(`0[],System.Int32,System.Int32)">
      <summary vsli:raw="Inserts multiple objects at the top of the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentStack`1&quot; /&gt; atomically.">Inserta atómicamente varios objetos al principio de <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</summary>
      <param name="items" vsli:raw="The objects to push onto the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentStack`1&quot; /&gt;.">Objetos que se van a insertar en la colección <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</param>
      <param name="startIndex" vsli:raw="The zero-based offset in &lt;paramref name=&quot;items&quot; /&gt; at which to begin inserting elements onto the top of the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentStack`1&quot; /&gt;.">Desplazamiento de base cero en <paramref name="items" /> donde comienza la inserción de los elementos al principio de la colección <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</param>
      <param name="count" vsli:raw="The number of elements to be inserted onto the top of the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentStack`1&quot; /&gt;.">Número de elementos que se van a insertar al principio de la colección <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;items&quot; /&gt; is a null reference (Nothing in Visual Basic).">
        <paramref name="items" /> es una referencia nula (nada en Visual Basic).</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;startIndex&quot; /&gt; or &lt;paramref name=&quot;count&quot; /&gt; is negative. Or &lt;paramref name=&quot;startIndex&quot; /&gt; is greater than or equal to the length of &lt;paramref name=&quot;items&quot; /&gt;.">
        <paramref name="startIndex" /> o <paramref name="count" /> es negativo. O <paramref name="startIndex" /> es mayor o igual que la longitud de <paramref name="items" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;startIndex&quot; /&gt; + &lt;paramref name=&quot;count&quot; /&gt; is greater than the length of &lt;paramref name=&quot;items&quot; /&gt;.">
        <paramref name="startIndex" /> + <paramref name="count" /> es mayor que la longitud de <paramref name="items" />.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.System#Collections#Concurrent#IProducerConsumerCollection{T}#TryAdd(`0)">
      <summary vsli:raw="Attempts to add an object to the &lt;see cref=&quot;T:System.Collections.Concurrent.IProducerConsumerCollection`1&quot; /&gt;.">Intenta agregar un objeto a <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" />.</summary>
      <param name="item" vsli:raw="The object to add to the &lt;see cref=&quot;T:System.Collections.Concurrent.IProducerConsumerCollection`1&quot; /&gt;. The value can be a null reference (Nothing in Visual Basic) for reference types.">Objeto que se va a agregar a <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" />. El valor puede ser una referencia nula (Nothing en Visual Basic) para los tipos de referencia.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the object was added successfully; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el objeto se ha agregado correctamente; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.System#Collections#Concurrent#IProducerConsumerCollection{T}#TryTake(`0@)">
      <summary vsli:raw="Attempts to remove and return an object from the &lt;see cref=&quot;T:System.Collections.Concurrent.IProducerConsumerCollection`1&quot; /&gt;.">Intenta quitar y devolver un objeto de <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" />.</summary>
      <param name="item" vsli:raw="When this method returns, if the operation was successful, &lt;paramref name=&quot;item&quot; /&gt; contains the object removed. If no object was available to be removed, the value is unspecified.">Cuando este método devuelve un valor, si la operación se realizó correctamente, <paramref name="item" /> contiene el objeto que se ha quitado. Si no había ningún objeto para quitar, el valor estará sin especificar.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if an element was removed and returned successfully; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el elemento se ha quitado y devuelto correctamente; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
      <summary vsli:raw="Copies the elements of the &lt;see cref=&quot;T:System.Collections.ICollection&quot; /&gt; to an &lt;see cref=&quot;T:System.Array&quot; /&gt;, starting at a particular &lt;see cref=&quot;T:System.Array&quot; /&gt; index.">Copia los elementos de <see cref="T:System.Collections.ICollection" /> en <see cref="T:System.Array" />, empezando por un índice determinado de <see cref="T:System.Array" />.</summary>
      <param name="array" vsli:raw="The one-dimensional &lt;see cref=&quot;T:System.Array&quot; /&gt; that is the destination of the elements copied from the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentStack`1&quot; /&gt;. The &lt;see cref=&quot;T:System.Array&quot; /&gt; must have zero-based indexing.">Matriz <see cref="T:System.Array" /> unidimensional que constituye el destino de los elementos copiados desde la colección <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />. <see cref="T:System.Array" /> debe tener una indización de base cero.</param>
      <param name="index" vsli:raw="The zero-based index in &lt;paramref name=&quot;array&quot; /&gt; at which copying begins.">Índice de base cero en la <paramref name="array" /> donde comienza la copia.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt; is a null reference (Nothing in Visual Basic).">
        <paramref name="array" /> es una referencia nula (nada en Visual Basic).</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;index&quot; /&gt; is less than zero.">
        <paramref name="index" /> es menor que cero.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt; is multidimensional. -or- &lt;paramref name=&quot;array&quot; /&gt; does not have zero-based indexing. -or- &lt;paramref name=&quot;index&quot; /&gt; is equal to or greater than the length of the &lt;paramref name=&quot;array&quot; /&gt; -or- The number of elements in the source &lt;see cref=&quot;T:System.Collections.ICollection&quot; /&gt; is greater than the available space from &lt;paramref name=&quot;index&quot; /&gt; to the end of the destination &lt;paramref name=&quot;array&quot; /&gt;. -or- The type of the source &lt;see cref=&quot;T:System.Collections.ICollection&quot; /&gt; cannot be cast automatically to the type of the destination &lt;paramref name=&quot;array&quot; /&gt;.">
        <paramref name="array" /> es multidimensional. -o bien- <paramref name="array" /> no tiene índices de base cero. -o bien- <paramref name="index" /> es igual o mayor que la longitud de la matriz <paramref name="array" /> -o bien- el número de elementos de la colección <see cref="T:System.Collections.ICollection" /> de origen es mayor que el espacio disponible desde <paramref name="index" /> hasta el final del parámetro <paramref name="array" /> de destino. -o bien- el tipo de la colección <see cref="T:System.Collections.ICollection" /> de origen no puede convertirse automáticamente al tipo del parámetro <paramref name="array" /> de destino.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Devuelve un enumerador que recorre en iteración una colección.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; that can be used to iterate through the collection.">
        <see cref="T:System.Collections.IEnumerator" /> que se puede utilizar para recorrer en iteración la colección.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.ToArray">
      <summary vsli:raw="Copies the items stored in the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentStack`1&quot; /&gt; to a new array.">Copia en una nueva matriz los elementos almacenados en <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</summary>
      <returns vsli:raw="A new array containing a snapshot of elements copied from the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentStack`1&quot; /&gt;.">Nueva matriz que contiene una instantánea de los elementos copiados de <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.TryPeek(`0@)">
      <summary vsli:raw="Attempts to return an object from the top of the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentStack`1&quot; /&gt; without removing it.">Intenta devolver un objeto situado al principio de <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> sin quitarlo.</summary>
      <param name="result" vsli:raw="When this method returns, &lt;paramref name=&quot;result&quot; /&gt; contains an object from the top of the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentStack`1&quot; /&gt; or an unspecified value if the operation failed.">Cuando este método devuelve un valor, <paramref name="result" /> contiene un objeto situado al principio de <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> o un valor sin especificar si se produjo un error en la operación.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if and object was returned successfully; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si un objeto se ha devuelto correctamente; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.TryPop(`0@)">
      <summary vsli:raw="Attempts to pop and return the object at the top of the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentStack`1&quot; /&gt;.">Intenta extraer y devolver el objeto situado al principio de <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</summary>
      <param name="result" vsli:raw="When this method returns, if the operation was successful, &lt;paramref name=&quot;result&quot; /&gt; contains the object removed. If no object was available to be removed, the value is unspecified.">Cuando este método devuelve un valor, si la operación se realizó correctamente, <paramref name="result" /> contiene el objeto que se ha quitado. Si no había ningún objeto para quitar, el valor estará sin especificar.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if an element was removed and returned from the top of the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentStack`1&quot; /&gt; successfully; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si un elemento se ha quitado y devuelto correctamente desde el principio de <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.TryPopRange(`0[])">
      <summary vsli:raw="Attempts to pop and return multiple objects from the top of the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentStack`1&quot; /&gt; atomically.">Intenta extraer y devolver atómicamente varios objetos situados al principio de <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</summary>
      <param name="items" vsli:raw="The &lt;see cref=&quot;T:System.Array&quot; /&gt; to which objects popped from the top of the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentStack`1&quot; /&gt; will be added.">Objeto <see cref="T:System.Array" /> al que se van a agregar los objetos extraídos del principio de <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;items&quot; /&gt; is a null argument (Nothing in Visual Basic).">
        <paramref name="items" /> es un argumento NULL (Nothing en Visual Basic).</exception>
      <returns vsli:raw="The number of objects successfully popped from the top of the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentStack`1&quot; /&gt; and inserted in &lt;paramref name=&quot;items&quot; /&gt;.">Número de objetos que se han extraído correctamente del principio de <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> y se han insertado en <paramref name="items" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.TryPopRange(`0[],System.Int32,System.Int32)">
      <summary vsli:raw="Attempts to pop and return multiple objects from the top of the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentStack`1&quot; /&gt; atomically.">Intenta extraer y devolver atómicamente varios objetos situados al principio de <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</summary>
      <param name="items" vsli:raw="The &lt;see cref=&quot;T:System.Array&quot; /&gt; to which objects popped from the top of the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentStack`1&quot; /&gt; will be added.">Objeto <see cref="T:System.Array" /> al que se van a agregar los objetos extraídos del principio de <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</param>
      <param name="startIndex" vsli:raw="The zero-based offset in &lt;paramref name=&quot;items&quot; /&gt; at which to begin inserting elements from the top of the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentStack`1&quot; /&gt;.">Desplazamiento de base cero en <paramref name="items" /> donde comienza la inserción de los elementos del principio de la colección <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</param>
      <param name="count" vsli:raw="The number of elements to be popped from top of the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentStack`1&quot; /&gt; and inserted into &lt;paramref name=&quot;items&quot; /&gt;.">Número de elementos que se van a extraer del principio de la colección <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> y se van a insertar en <paramref name="items" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;items&quot; /&gt; is a null reference (Nothing in Visual Basic).">
        <paramref name="items" /> es una referencia nula (nada en Visual Basic).</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;startIndex&quot; /&gt; or &lt;paramref name=&quot;count&quot; /&gt; is negative. Or &lt;paramref name=&quot;startIndex&quot; /&gt; is greater than or equal to the length of &lt;paramref name=&quot;items&quot; /&gt;.">
        <paramref name="startIndex" /> o <paramref name="count" /> es negativo. O <paramref name="startIndex" /> es mayor o igual que la longitud de <paramref name="items" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;startIndex&quot; /&gt; + &lt;paramref name=&quot;count&quot; /&gt; is greater than the length of &lt;paramref name=&quot;items&quot; /&gt;.">
        <paramref name="startIndex" /> + <paramref name="count" /> es mayor que la longitud de <paramref name="items" />.</exception>
      <returns vsli:raw="The number of objects successfully popped from the top of the stack and inserted in &lt;paramref name=&quot;items&quot; /&gt;.">Número de objetos que se han extraído correctamente del principio de la pila y se han insertado en <paramref name="items" />.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentStack`1.Count">
      <summary vsli:raw="Gets the number of elements contained in the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentStack`1&quot; /&gt;.">Obtiene el número de elementos incluidos en <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</summary>
      <returns vsli:raw="The number of elements contained in the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentStack`1&quot; /&gt;.">Número de elementos contenidos en <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentStack`1.IsEmpty">
      <summary vsli:raw="Gets a value that indicates whether the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentStack`1&quot; /&gt; is empty.">Obtiene un valor que indica si <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> está vacía.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentStack`1&quot; /&gt; is empty; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> está vacío, en caso contrario, es <see langword="false" />.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentStack`1.System#Collections#ICollection#IsSynchronized">
      <summary vsli:raw="Gets a value indicating whether access to the &lt;see cref=&quot;T:System.Collections.ICollection&quot; /&gt; is synchronized with the SyncRoot.">Obtiene un valor que indica si el acceso a <see cref="T:System.Collections.ICollection" /> está sincronizado con SyncRoot.</summary>
      <returns vsli:raw="Always returns &lt;see langword=&quot;false&quot; /&gt; to indicate access is not synchronized.">Siempre devuelve <see langword="false" /> para indicar que el acceso no está sincronizado.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentStack`1.System#Collections#ICollection#SyncRoot">
      <summary vsli:raw="Gets an object that can be used to synchronize access to the &lt;see cref=&quot;T:System.Collections.ICollection&quot; /&gt;. This property is not supported.">Obtiene un objeto que se puede usar para sincronizar el acceso a <see cref="T:System.Collections.ICollection" />. Esta propiedad no es compatible.</summary>
      <exception cref="T:System.NotSupportedException" vsli:raw="The SyncRoot property is not supported">La propiedad SyncRoot no es compatible</exception>
      <returns vsli:raw="Returns &lt;see langword=&quot;null&quot; /&gt;.">Devuelve <see langword="null" />.</returns>
    </member>
    <member name="T:System.Collections.Concurrent.EnumerablePartitionerOptions">
      <summary vsli:raw="Specifies options to control the buffering behavior of a partitioner.">Especifica opciones para controlar el comportamiento de almacenamiento en búfer de un particionador.</summary>
    </member>
    <member name="F:System.Collections.Concurrent.EnumerablePartitionerOptions.NoBuffering">
      <summary vsli:raw="Create a partitioner that takes items from the source enumerable one at a time and does not use intermediate storage that can be accessed more efficiently by multiple threads. This option provides support for low latency (items will be processed as soon as they are available from the source) and provides partial support for dependencies between items (a thread cannot deadlock waiting for an item that the thread itself is responsible for processing).">Crea un particionador que toma elementos del enumerable de origen de uno en uno y no utiliza almacenamiento intermedio al que pueden obtener acceso más eficazmente varios subprocesos. Esta opción proporciona compatibilidad para latencia baja (los elementos se procesarán en cuanto están disponibles desde el origen) y compatibilidad parcial con dependencias entre elementos (un subproceso no puede producir un interbloqueo mientras espera un elemento que el propio subproceso es responsable de procesar).</summary>
    </member>
    <member name="F:System.Collections.Concurrent.EnumerablePartitionerOptions.None">
      <summary vsli:raw="Use the default behavior, which is to use buffering to achieve optimal performance.">Usar el comportamiento predeterminado, que consiste en usar el almacenamiento en búfer para lograr un rendimiento óptimo.</summary>
    </member>
    <member name="T:System.Collections.Concurrent.IProducerConsumerCollection`1">
      <summary vsli:raw="Defines methods to manipulate thread-safe collections intended for producer/consumer usage. This interface provides a unified representation for producer/consumer collections so that higher level abstractions such as &lt;see cref=&quot;T:System.Collections.Concurrent.BlockingCollection`1&quot; /&gt; can use the collection as the underlying storage mechanism.">Define los métodos para manipular las colecciones seguras para subprocesos que están pensadas para que las usen los productores y consumidores. Esta interfaz proporciona una representación unificada para colecciones de productor/consumidor, para que las abstracciones de nivel más alto como <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> puedan utilizar la colección como mecanismo de almacenamiento subyacente.</summary>
      <typeparam name="T" vsli:raw="Specifies the type of elements in the collection.">Especifica el tipo de elementos de la colección.</typeparam>
    </member>
    <member name="M:System.Collections.Concurrent.IProducerConsumerCollection`1.CopyTo(`0[],System.Int32)">
      <summary vsli:raw="Copies the elements of the &lt;see cref=&quot;T:System.Collections.Concurrent.IProducerConsumerCollection`1&quot; /&gt; to an &lt;see cref=&quot;T:System.Array&quot; /&gt;, starting at a specified index.">Copia los elementos de <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /> a un objeto <see cref="T:System.Array" />, a partir del índice especificado.</summary>
      <param name="array" vsli:raw="The one-dimensional &lt;see cref=&quot;T:System.Array&quot; /&gt; that is the destination of the elements copied from the &lt;see cref=&quot;T:System.Collections.Concurrent.IProducerConsumerCollection`1&quot; /&gt;.  &#xA;  &#xA; The array must have zero-based indexing.">Matriz <see cref="T:System.Array" /> unidimensional que constituye el destino de los elementos copiados desde la colección <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" />.  
  
La matriz debe tener una indización de base cero.</param>
      <param name="index" vsli:raw="The zero-based index in &lt;paramref name=&quot;array&quot; /&gt; at which copying begins.">Índice de base cero en la <paramref name="array" /> donde comienza la copia.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt; is a null reference (Nothing in Visual Basic).">
        <paramref name="array" /> es una referencia nula (nada en Visual Basic).</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;index&quot; /&gt; is less than zero.">
        <paramref name="index" /> es menor que cero.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;index&quot; /&gt; is equal to or greater than the length of the &lt;paramref name=&quot;array&quot; /&gt; -or- The number of elements in the collection is greater than the available space from &lt;paramref name=&quot;index&quot; /&gt; to the end of the destination &lt;paramref name=&quot;array&quot; /&gt;.">
        <paramref name="index" /> es igual o mayor que la longitud de <paramref name="array" /> -o bien- el número de elementos de la colección es mayor que el espacio disponible en <paramref name="index" /> hasta el final del parámetro de destino <paramref name="array" /></exception>
    </member>
    <member name="M:System.Collections.Concurrent.IProducerConsumerCollection`1.ToArray">
      <summary vsli:raw="Copies the elements contained in the &lt;see cref=&quot;T:System.Collections.Concurrent.IProducerConsumerCollection`1&quot; /&gt; to a new array.">Copia los elementos de <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /> a una nueva matriz.</summary>
      <returns vsli:raw="A new array containing the elements copied from the &lt;see cref=&quot;T:System.Collections.Concurrent.IProducerConsumerCollection`1&quot; /&gt;.">Nueva matriz que contiene los elementos copiados de <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.IProducerConsumerCollection`1.TryAdd(`0)">
      <summary vsli:raw="Attempts to add an object to the &lt;see cref=&quot;T:System.Collections.Concurrent.IProducerConsumerCollection`1&quot; /&gt;.">Intenta agregar un objeto a <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" />.</summary>
      <param name="item" vsli:raw="The object to add to the &lt;see cref=&quot;T:System.Collections.Concurrent.IProducerConsumerCollection`1&quot; /&gt;.">Objeto que se va a agregar a <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" />.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;item&quot; /&gt; was invalid for this collection.">
        <paramref name="item" /> no fue válido para esta colección.</exception>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the object was added successfully; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el objeto se ha agregado correctamente; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.IProducerConsumerCollection`1.TryTake(`0@)">
      <summary vsli:raw="Attempts to remove and return an object from the &lt;see cref=&quot;T:System.Collections.Concurrent.IProducerConsumerCollection`1&quot; /&gt;.">Intenta quitar y devolver un objeto de <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" />.</summary>
      <param name="item" vsli:raw="When this method returns, if the object was removed and returned successfully, &lt;paramref name=&quot;item&quot; /&gt; contains the removed object. If no object was available to be removed, the value is unspecified.">Cuando este método devuelve un valor, si el objeto se quitó y se devolvió correctamente, <paramref name="item" /> contiene dicho objeto. Si no había ningún objeto para quitar, el valor estará sin especificar.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if an object was removed and returned successfully; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el objeto se ha quitado y devuelto correctamente; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="T:System.Collections.Concurrent.OrderablePartitioner`1">
      <summary vsli:raw="Represents a particular manner of splitting an orderable data source into multiple partitions.">Representa una manera determinada de dividir un origen de datos ordenable en varias particiones.</summary>
      <typeparam name="TSource" vsli:raw="Type of the elements in the collection.">Tipo de los elementos de la colección.</typeparam>
    </member>
    <member name="M:System.Collections.Concurrent.OrderablePartitioner`1.#ctor(System.Boolean,System.Boolean,System.Boolean)">
      <summary vsli:raw="Called from constructors in derived classes to initialize the &lt;see cref=&quot;T:System.Collections.Concurrent.OrderablePartitioner`1&quot; /&gt; class with the specified constraints on the index keys.">Se llama desde los constructores de clases derivadas para inicializar la clase <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> con las restricciones especificadas en las claves de índice.</summary>
      <param name="keysOrderedInEachPartition" vsli:raw="Indicates whether the elements in each partition are yielded in the order of increasing keys.">Indica si los elementos de cada partición se proporcionan en el orden de claves crecientes.</param>
      <param name="keysOrderedAcrossPartitions" vsli:raw="Indicates whether elements in an earlier partition always come before elements in a later partition. If true, each element in partition 0 has a smaller order key than any element in partition 1, each element in partition 1 has a smaller order key than any element in partition 2, and so on.">Indica si los elementos de una partición anterior siempre están antes que los elementos de una partición posterior. Si es true, cada elemento de la partición 0 tiene una clave de ordenación menor que cualquier elemento de la partición 1, cada elemento de la partición 1 tiene una clave de ordenación menor que cualquier elemento de la partición 2 y así sucesivamente.</param>
      <param name="keysNormalized" vsli:raw="Indicates whether keys are normalized. If true, all order keys are distinct integers in the range [0 .. numberOfElements-1]. If false, order keys must still be distinct, but only their relative order is considered, not their absolute values.">Indica si las claves están normalizadas. Si es true, todas las claves de ordenación son enteros distintos en el intervalo [0 . numberOfElements-1]. Si es false, las claves de ordenación deben ser distintas, pero solo se considera su orden relativo, no sus valores absolutos.</param>
    </member>
    <member name="M:System.Collections.Concurrent.OrderablePartitioner`1.GetDynamicPartitions">
      <summary vsli:raw="Creates an object that can partition the underlying collection into a variable number of partitions.">Crea un objeto que puede dividir la colección subyacente en un número variable de particiones.</summary>
      <exception cref="T:System.NotSupportedException" vsli:raw="Dynamic partitioning is not supported by the base class. It must be implemented in derived classes.">Esta clase base no admite la creación de particiones dinámicas. Debe ser implementado en clases derivadas.</exception>
      <returns vsli:raw="An object that can create partitions over the underlying data source.">Objeto que puede crear particiones en el origen de datos subyacente.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.OrderablePartitioner`1.GetOrderableDynamicPartitions">
      <summary vsli:raw="Creates an object that can partition the underlying collection into a variable number of partitions.">Crea un objeto que puede dividir la colección subyacente en un número variable de particiones.</summary>
      <exception cref="T:System.NotSupportedException" vsli:raw="Dynamic partitioning is not supported by this partitioner.">Este particionador no admite la creación de particiones dinámica.</exception>
      <returns vsli:raw="An object that can create partitions over the underlying data source.">Objeto que puede crear particiones en el origen de datos subyacente.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.OrderablePartitioner`1.GetOrderablePartitions(System.Int32)">
      <summary vsli:raw="Partitions the underlying collection into the specified number of orderable partitions.">Divide la colección subyacente en el número especificado de particiones ordenables.</summary>
      <param name="partitionCount" vsli:raw="The number of partitions to create.">Número de particiones que se van a crear.</param>
      <returns vsli:raw="A list containing &lt;paramref name=&quot;partitionCount&quot; /&gt; enumerators.">Una lista que contiene enumeradores <paramref name="partitionCount" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.OrderablePartitioner`1.GetPartitions(System.Int32)">
      <summary vsli:raw="Partitions the underlying collection into the given number of ordered partitions.">Divide la colección subyacente en el número especificado de particiones ordenadas.</summary>
      <param name="partitionCount" vsli:raw="The number of partitions to create.">Número de particiones que se van a crear.</param>
      <returns vsli:raw="A list containing &lt;paramref name=&quot;partitionCount&quot; /&gt; enumerators.">Una lista que contiene enumeradores <paramref name="partitionCount" />.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized">
      <summary vsli:raw="Gets whether order keys are normalized.">Obtiene si las claves de ordenación están normalizadas o no.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the keys are normalized; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> Si las claves se normalizan; en caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysOrderedAcrossPartitions">
      <summary vsli:raw="Gets whether elements in an earlier partition always come before elements in a later partition.">Obtiene si los elementos de una partición anterior siempre están antes que los elementos de una partición posterior.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the elements in an earlier partition always come before elements in a later partition; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> Si los elementos de una partición anterior siempre están antes que los elementos de una partición posterior; en caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysOrderedInEachPartition">
      <summary vsli:raw="Gets whether elements in each partition are yielded in the order of increasing keys.">Obtiene si los elementos de cada partición se proporcionan en el orden de claves crecientes.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the elements in each partition are yielded in the order of increasing keys; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> Si los elementos de cada partición se proporcionan en el orden de claves crecientes; en caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="T:System.Collections.Concurrent.Partitioner">
      <summary vsli:raw="Provides common partitioning strategies for arrays, lists, and enumerables.">Proporciona estrategias comunes para la creación de particiones de matrices, listas y enumerables.</summary>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner.Create(System.Int32,System.Int32)">
      <summary vsli:raw="Creates a partitioner that chunks the user-specified range.">Crea un particionador que divide en fragmentos el intervalo especificado por el usuario.</summary>
      <param name="fromInclusive" vsli:raw="The lower, inclusive bound of the range.">Límite inferior inclusivo del intervalo.</param>
      <param name="toExclusive" vsli:raw="The upper, exclusive bound of the range.">Límite superior exclusivo del intervalo.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The &lt;paramref name=&quot;toExclusive&quot; /&gt; argument is less than or equal to the &lt;paramref name=&quot;fromInclusive&quot; /&gt; argument.">El argumento <paramref name="toExclusive" /> es menor o igual que el argumento <paramref name="fromInclusive" />.</exception>
      <returns vsli:raw="A partitioner.">Particionador.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner.Create(System.Int32,System.Int32,System.Int32)">
      <summary vsli:raw="Creates a partitioner that chunks the user-specified range.">Crea un particionador que divide en fragmentos el intervalo especificado por el usuario.</summary>
      <param name="fromInclusive" vsli:raw="The lower, inclusive bound of the range.">Límite inferior inclusivo del intervalo.</param>
      <param name="toExclusive" vsli:raw="The upper, exclusive bound of the range.">Límite superior exclusivo del intervalo.</param>
      <param name="rangeSize" vsli:raw="The size of each subrange.">Tamaño de cada subintervalo.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The &lt;paramref name=&quot;toExclusive&quot; /&gt; argument is less than or equal to the &lt;paramref name=&quot;fromInclusive&quot; /&gt; argument.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;paramref name=&quot;rangeSize&quot; /&gt; argument is less than or equal to 0.">El argumento <paramref name="toExclusive" /> es menor o igual que el argumento <paramref name="fromInclusive" />.  
  
o bien 
El argumento <paramref name="rangeSize" /> es menor o igual que 0.</exception>
      <returns vsli:raw="A partitioner.">Particionador.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner.Create(System.Int64,System.Int64)">
      <summary vsli:raw="Creates a partitioner that chunks the user-specified range.">Crea un particionador que divide en fragmentos el intervalo especificado por el usuario.</summary>
      <param name="fromInclusive" vsli:raw="The lower, inclusive bound of the range.">Límite inferior inclusivo del intervalo.</param>
      <param name="toExclusive" vsli:raw="The upper, exclusive bound of the range.">Límite superior exclusivo del intervalo.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The &lt;paramref name=&quot;toExclusive&quot; /&gt; argument is less than or equal to the &lt;paramref name=&quot;fromInclusive&quot; /&gt; argument.">El argumento <paramref name="toExclusive" /> es menor o igual que el argumento <paramref name="fromInclusive" />.</exception>
      <returns vsli:raw="A partitioner.">Particionador.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner.Create(System.Int64,System.Int64,System.Int64)">
      <summary vsli:raw="Creates a partitioner that chunks the user-specified range.">Crea un particionador que divide en fragmentos el intervalo especificado por el usuario.</summary>
      <param name="fromInclusive" vsli:raw="The lower, inclusive bound of the range.">Límite inferior inclusivo del intervalo.</param>
      <param name="toExclusive" vsli:raw="The upper, exclusive bound of the range.">Límite superior exclusivo del intervalo.</param>
      <param name="rangeSize" vsli:raw="The size of each subrange.">Tamaño de cada subintervalo.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The &lt;paramref name=&quot;toExclusive&quot; /&gt; argument is less than or equal to the &lt;paramref name=&quot;fromInclusive&quot; /&gt; argument.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;paramref name=&quot;rangeSize&quot; /&gt; argument is less than or equal to 0.">El argumento <paramref name="toExclusive" /> es menor o igual que el argumento <paramref name="fromInclusive" />.  
  
o bien 
El argumento <paramref name="rangeSize" /> es menor o igual que 0.</exception>
      <returns vsli:raw="A partitioner.">Particionador.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner.Create``1(``0[],System.Boolean)">
      <summary vsli:raw="Creates an orderable partitioner from a &lt;see cref=&quot;T:System.Array&quot; /&gt; instance.">Crea un particionador ordenable a partir de una instancia de <see cref="T:System.Array" />.</summary>
      <param name="array" vsli:raw="The array to be partitioned.">Matriz que se va a dividir en particiones.</param>
      <param name="loadBalance" vsli:raw="A Boolean value that indicates whether the created partitioner should dynamically load balance between partitions rather than statically partition.">Valor booleano que indica si el particionador creado debe equilibrar dinámicamente la carga entre las particiones en lugar de crear particiones estáticas.</param>
      <typeparam name="TSource" vsli:raw="Type of the elements in source array.">Tipo de elementos de la matriz de origen.</typeparam>
      <returns vsli:raw="An orderable partitioner based on the input array.">Particionador ordenable basado en la matriz de entrada.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner.Create``1(System.Collections.Generic.IEnumerable{``0})">
      <summary vsli:raw="Creates an orderable partitioner from a &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; instance.">Crea un particionador ordenable a partir de una instancia de <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
      <param name="source" vsli:raw="The enumerable to be partitioned.">Enumerable que se va a dividir en particiones.</param>
      <typeparam name="TSource" vsli:raw="Type of the elements in source enumerable.">Tipo de elementos del enumerable de origen.</typeparam>
      <returns vsli:raw="An orderable partitioner based on the input array.">Particionador ordenable basado en la matriz de entrada.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner.Create``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Concurrent.EnumerablePartitionerOptions)">
      <summary vsli:raw="Creates an orderable partitioner from a &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; instance.">Crea un particionador ordenable a partir de una instancia de <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
      <param name="source" vsli:raw="The enumerable to be partitioned.">Enumerable que se va a dividir en particiones.</param>
      <param name="partitionerOptions" vsli:raw="Options to control the buffering behavior of the partitioner.">Opciones para controlar el comportamiento de almacenamiento en búfer del particionador.</param>
      <typeparam name="TSource" vsli:raw="Type of the elements in source enumerable.">Tipo de elementos del enumerable de origen.</typeparam>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The &lt;paramref name=&quot;partitionerOptions&quot; /&gt; argument specifies an invalid value for &lt;see cref=&quot;T:System.Collections.Concurrent.EnumerablePartitionerOptions&quot; /&gt;.">El argumento <paramref name="partitionerOptions" /> especifica un valor no válido para <see cref="T:System.Collections.Concurrent.EnumerablePartitionerOptions" />.</exception>
      <returns vsli:raw="An orderable partitioner based on the input array.">Particionador ordenable basado en la matriz de entrada.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner.Create``1(System.Collections.Generic.IList{``0},System.Boolean)">
      <summary vsli:raw="Creates an orderable partitioner from an &lt;see cref=&quot;T:System.Collections.Generic.IList`1&quot; /&gt; instance.">Crea un particionador ordenable a partir de una instancia de <see cref="T:System.Collections.Generic.IList`1" />.</summary>
      <param name="list" vsli:raw="The list to be partitioned.">Lista que se va a dividir en particiones.</param>
      <param name="loadBalance" vsli:raw="A Boolean value that indicates whether the created partitioner should dynamically load balance between partitions rather than statically partition.">Valor booleano que indica si el particionador creado debe equilibrar dinámicamente la carga entre las particiones en lugar de crear particiones estáticas.</param>
      <typeparam name="TSource" vsli:raw="Type of the elements in source list.">Tipo de elementos de la lista de origen.</typeparam>
      <returns vsli:raw="An orderable partitioner based on the input list.">Particionador ordenable basado en la lista de entrada.</returns>
    </member>
    <member name="T:System.Collections.Concurrent.Partitioner`1">
      <summary vsli:raw="Represents a particular manner of splitting a data source into multiple partitions.">Representa una manera determinada de dividir un origen de datos en varias particiones.</summary>
      <typeparam name="TSource" vsli:raw="Type of the elements in the collection.">Tipo de los elementos de la colección.</typeparam>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner`1.#ctor">
      <summary vsli:raw="Creates a new partitioner instance.">Crea una nueva instancia del particionador.</summary>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner`1.GetDynamicPartitions">
      <summary vsli:raw="Creates an object that can partition the underlying collection into a variable number of partitions.">Crea un objeto que puede dividir la colección subyacente en un número variable de particiones.</summary>
      <exception cref="T:System.NotSupportedException" vsli:raw="Dynamic partitioning is not supported by the base class. You must implement it in a derived class.">Esta clase base no admite la creación de particiones dinámicas. Debe implementarlo en una clase derivada.</exception>
      <returns vsli:raw="An object that can create partitions over the underlying data source.">Objeto que puede crear particiones en el origen de datos subyacente.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)">
      <summary vsli:raw="Partitions the underlying collection into the given number of partitions.">Divide la colección subyacente en el número especificado de particiones.</summary>
      <param name="partitionCount" vsli:raw="The number of partitions to create.">Número de particiones que se van a crear.</param>
      <returns vsli:raw="A list containing &lt;paramref name=&quot;partitionCount&quot; /&gt; enumerators.">Una lista que contiene enumeradores <paramref name="partitionCount" />.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions">
      <summary vsli:raw="Gets whether additional partitions can be created dynamically.">Obtiene si se pueden crear particiones adicionales dinámicamente.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Collections.Concurrent.Partitioner`1&quot; /&gt; can create partitions dynamically as they are requested; &lt;see langword=&quot;false&quot; /&gt; if the &lt;see cref=&quot;T:System.Collections.Concurrent.Partitioner`1&quot; /&gt; can only allocate partitions statically.">
        <see langword="true" /> es si <see cref="T:System.Collections.Concurrent.Partitioner`1" /> puede crear particiones dinámicamente a medida que se solicitan; es <see langword="false" /> si <see cref="T:System.Collections.Concurrent.Partitioner`1" /> solo puede asignar particiones estáticamente.</returns>
    </member>
  </members>
</doc>