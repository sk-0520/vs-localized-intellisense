<?xml version="1.0" encoding="utf-8"?>
<doc xmlns:vsli="https://github.com/sk-0520/vs-localized-intellisense/tree/master/schema/2024">
  <assembly>
    <name>System.Memory</name>
  </assembly>
  <members>
    <member name="T:System.Buffers.ArrayBufferWriter`1">
      <summary vsli:raw="Represents a heap-based, array-backed output sink into which &lt;typeparamref name=&quot;T&quot; /&gt; data can be written.">Rappresenta un sink di output supportato da matrici e basato su heap in cui <typeparam name="T" /> è possibile scrivere dati.</summary>
      <typeparam name="T" vsli:raw="The type of the items in this &lt;see cref=&quot;T:System.Buffers.ArrayBufferWriter`1&quot; /&gt; instance.">Tipo degli elementi in questa <see cref="T:System.Buffers.ArrayBufferWriter`1" /> istanza.</typeparam>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.#ctor">
      <summary vsli:raw="Creates an instance of an &lt;see cref=&quot;T:System.Buffers.ArrayBufferWriter`1&quot; /&gt; to which data can be written, with the default initial capacity.">Crea un'istanza di <see cref="T:System.Buffers.ArrayBufferWriter`1" /> in cui è possibile scrivere dati, con la capacità iniziale predefinita.</summary>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.#ctor(System.Int32)">
      <summary vsli:raw="Creates an instance of an &lt;see cref=&quot;T:System.Buffers.ArrayBufferWriter`1&quot; /&gt; to which data can be written, with a specified initial capacity.">Crea un'istanza di <see cref="T:System.Buffers.ArrayBufferWriter`1" /> in cui è possibile scrivere dati, con una capacità iniziale specificata.</summary>
      <param name="initialCapacity" vsli:raw="The minimum capacity with which to initialize the underlying buffer.">La capacità minima con cui inizializzare il buffer sottostante.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;initialCapacity&quot; /&gt; is less than or equal to 0.">
        <paramref name="initialCapacity" /> è minore o uguale a 0.</exception>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.Advance(System.Int32)">
      <summary vsli:raw="Notifies the &lt;see cref=&quot;T:System.Buffers.IBufferWriter`1&quot; /&gt; that &lt;paramref name=&quot;count&quot; /&gt; items were written to the output &lt;see cref=&quot;T:System.Span`1&quot; /&gt;/&lt;see cref=&quot;T:System.Memory`1&quot; /&gt;.">Comunica a <see cref="T:System.Buffers.IBufferWriter`1" /> che sono stati scritti <paramref name="count" /> elementi nell'output <see cref="T:System.Span`1" />/<see cref="T:System.Memory`1" /></summary>
      <param name="count" vsli:raw="The number of items written.">Il numero di elementi scritti.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;count&quot; /&gt; is negative.">
        <paramref name="count" /> è negativo.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method call attempts to advance past the end of the underlying buffer.">La chiamata al metodo tenta di avanzare oltre la fine del buffer sottostante.</exception>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.Clear">
      <summary vsli:raw="Clears the data written to the underlying buffer.">Cancella i dati scritti nel buffer sottostante.</summary>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.GetMemory(System.Int32)">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Memory`1&quot; /&gt; to write to that is at least the length specified by &lt;paramref name=&quot;sizeHint&quot; /&gt;.">Restituisce un oggetto <see cref="T:System.Memory`1" /> nel quale scrivere la cui lunghezza è almeno quella specificata da <paramref name="sizeHint" />.</summary>
      <param name="sizeHint" vsli:raw="The minimum requested length of the &lt;see cref=&quot;T:System.Memory`1&quot; /&gt;.">La lunghezza minima richiesta di <see cref="T:System.Memory`1" />.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;sizeHint&quot; /&gt; is negative.">
        <paramref name="sizeHint" /> è negativo.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Memory`1&quot; /&gt; whose length is at least &lt;paramref name=&quot;sizeHint&quot; /&gt;.  If &lt;paramref name=&quot;sizeHint&quot; /&gt; is not provided or is equal to 0, some non-empty buffer is returned.">
        <see cref="T:System.Memory`1" /> la cui lunghezza è almeno <paramref name="sizeHint" />.  Se <paramref name="sizeHint" /> non viene specificato o è uguale a 0, viene restituito un buffer non vuoto.</returns>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.GetSpan(System.Int32)">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Span`1&quot; /&gt; to write to that is at least a specified length.">Restituisce un oggetto <see cref="T:System.Span`1" /> nel quale scrivere la cui lunghezza è almeno quella specificata.</summary>
      <param name="sizeHint" vsli:raw="The minimum requested length of the &lt;see cref=&quot;T:System.Span`1&quot; /&gt;.">La lunghezza minima richiesta di <see cref="T:System.Span`1" />.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;sizeHint&quot; /&gt; is negative.">
        <paramref name="sizeHint" /> è negativo.</exception>
      <returns vsli:raw="A span of at least &lt;paramref name=&quot;sizeHint&quot; /&gt; in length. If &lt;paramref name=&quot;sizeHint&quot; /&gt; is not provided or is equal to 0, some non-empty buffer is returned.">Un intervallo di almeno <paramref name="sizeHint" /> in lunghezza. Se <paramref name="sizeHint" /> non viene specificato o è uguale a 0, viene restituito un buffer non vuoto.</returns>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.Capacity">
      <summary vsli:raw="Gets the total amount of space within the underlying buffer.">Ottiene la quantità totale di spazio all'interno del buffer sottostante.</summary>
      <returns vsli:raw="The total capacity of the underlying buffer.">Capacità totale del buffer sottostante.</returns>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.FreeCapacity">
      <summary vsli:raw="Gets the amount of available space that can be written to without forcing the underlying buffer to grow.">Ottiene la quantità di spazio disponibile in cui è possibile scrivere senza determinare l'aumento del buffer sottostante.</summary>
      <returns vsli:raw="The space available for writing without forcing the underlying buffer to grow.">Spazio disponibile per la scrittura senza forzare l'aumento delle dimensioni del buffer sottostante.</returns>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.WrittenCount">
      <summary vsli:raw="Gets the amount of data written to the underlying buffer.">Ottiene la quantità di dati scritti nel buffer sottostante.</summary>
      <returns vsli:raw="The amount of data written to the underlying buffer.">Quantità di dati scritti nel buffer sottostante.</returns>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.WrittenMemory">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt; that contains the data written to the underlying buffer so far.">Ottiene un oggetto <see cref="T:System.ReadOnlyMemory`1" /> che contiene i dati scritti finora nel buffer sottostante.</summary>
      <returns vsli:raw="The data written to the underlying buffer.">Dati scritti nel buffer sottostante.</returns>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.WrittenSpan">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; that contains the data written to the underlying buffer so far.">Ottiene un oggetto <see cref="T:System.ReadOnlySpan`1" /> che contiene i dati scritti finora nel buffer sottostante.</summary>
      <returns vsli:raw="The data written to the underlying buffer.">Dati scritti nel buffer sottostante.</returns>
    </member>
    <member name="T:System.Buffers.Binary.BinaryPrimitives">
      <summary vsli:raw="Reads bytes as primitives with specific endianness.">Legge i byte come primitive con un ordine dei byte specifico.</summary>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadDoubleBigEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.Double&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Legge un <see cref="T:System.Double" /> dall'inizio di un intervallo di byte di sola lettura, come big endian.</summary>
      <param name="source" vsli:raw="The read-only span to read.">Intervallo di sola lettura da leggere.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.Double&quot; /&gt;.">
        <paramref name="source" /> è troppo piccolo per contenere un <see cref="T:System.Double" />.</exception>
      <returns vsli:raw="The big endian value.">Valore big endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadDoubleLittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.Double&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Legge un <see cref="T:System.Double" /> dall'inizio di un intervallo di byte di sola lettura, come little endian.</summary>
      <param name="source" vsli:raw="The read-only span to read.">Intervallo di sola lettura da leggere.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.Double&quot; /&gt;.">
        <paramref name="source" /> è troppo piccolo per contenere un <see cref="T:System.Double" />.</exception>
      <returns vsli:raw="The little endian value.">Valore little endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt16BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int16&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Legge un <see cref="T:System.Int16" /> dall'inizio di un intervallo di byte di sola lettura, come big endian.</summary>
      <param name="source" vsli:raw="The read-only span to read.">Intervallo di sola lettura da leggere.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int16&quot; /&gt;.">
        <paramref name="source" /> è troppo piccolo per contenere un <see cref="T:System.Int16" />.</exception>
      <returns vsli:raw="The big endian value.">Valore big endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt16LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int16&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Legge un <see cref="T:System.Int16" /> dall'inizio di un intervallo di byte di sola lettura, come little endian.</summary>
      <param name="source" vsli:raw="The read-only span to read.">Intervallo di sola lettura da leggere.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int16&quot; /&gt;.">
        <paramref name="source" /> è troppo piccolo per contenere un <see cref="T:System.Int16" />.</exception>
      <returns vsli:raw="The little endian value.">Valore little endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt32BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int32&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Legge un <see cref="T:System.Int32" /> dall'inizio di un intervallo di byte di sola lettura, come big endian.</summary>
      <param name="source" vsli:raw="The read-only span to read.">Intervallo di sola lettura da leggere.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int32&quot; /&gt;.">
        <paramref name="source" /> è troppo piccolo per contenere un <see cref="T:System.Int32" />.</exception>
      <returns vsli:raw="The big endian value.">Valore big endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt32LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int32&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Legge un <see cref="T:System.Int32" /> dall'inizio di un intervallo di byte di sola lettura, come little endian.</summary>
      <param name="source" vsli:raw="The read-only span to read.">Intervallo di sola lettura da leggere.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int32&quot; /&gt;.">
        <paramref name="source" /> è troppo piccolo per contenere un <see cref="T:System.Int32" />.</exception>
      <returns vsli:raw="The little endian value.">Valore little endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt64BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int64&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Legge un <see cref="T:System.Int64" /> dall'inizio di un intervallo di byte di sola lettura, come big endian.</summary>
      <param name="source" vsli:raw="The read-only span to read.">Intervallo di sola lettura da leggere.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int64&quot; /&gt;.">
        <paramref name="source" /> è troppo piccolo per contenere un <see cref="T:System.Int64" />.</exception>
      <returns vsli:raw="The big endian value.">Valore big endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt64LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int64&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Legge un <see cref="T:System.Int64" /> dall'inizio di un intervallo di byte di sola lettura, come little endian.</summary>
      <param name="source" vsli:raw="The read-only span to read.">Intervallo di sola lettura da leggere.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int64&quot; /&gt;.">
        <paramref name="source" /> è troppo piccolo per contenere un <see cref="T:System.Int64" />.</exception>
      <returns vsli:raw="The little endian value.">Valore little endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadSingleBigEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.Single&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Legge un <see cref="T:System.Single" /> dall'inizio di un intervallo di byte di sola lettura, come big endian.</summary>
      <param name="source" vsli:raw="The read-only span to read.">Intervallo di sola lettura da leggere.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.Single&quot; /&gt;.">
        <paramref name="source" /> è troppo piccolo per contenere un <see cref="T:System.Single" />.</exception>
      <returns vsli:raw="The big endian value.">Valore big endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadSingleLittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.Single&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Legge un <see cref="T:System.Single" /> dall'inizio di un intervallo di byte di sola lettura, come little endian.</summary>
      <param name="source" vsli:raw="The read-only span to read.">Intervallo di sola lettura da leggere.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.Single&quot; /&gt;.">
        <paramref name="source" /> è troppo piccolo per contenere un <see cref="T:System.Single" />.</exception>
      <returns vsli:raw="The little endian value.">Valore little endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt16BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Legge un <see cref="T:System.UInt16" /> dall'inizio di un intervallo di byte di sola lettura, come big endian.</summary>
      <param name="source" vsli:raw="The read-only span to read.">Intervallo di sola lettura da leggere.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt16&quot; /&gt;.">
        <paramref name="source" /> è troppo piccolo per contenere un <see cref="T:System.UInt16" />.</exception>
      <returns vsli:raw="The big endian value.">Valore big endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt16LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Legge un <see cref="T:System.UInt16" /> dall'inizio di un intervallo di byte di sola lettura, come little endian.</summary>
      <param name="source" vsli:raw="The read-only span to read.">Intervallo di sola lettura da leggere.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt16&quot; /&gt;.">
        <paramref name="source" /> è troppo piccolo per contenere un <see cref="T:System.UInt16" />.</exception>
      <returns vsli:raw="The little endian value.">Valore little endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt32BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Legge un <see cref="T:System.UInt32" /> dall'inizio di un intervallo di byte di sola lettura, come big endian.</summary>
      <param name="source" vsli:raw="The read-only span to read.">Intervallo di sola lettura da leggere.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt32&quot; /&gt;.">
        <paramref name="source" /> è troppo piccolo per contenere un <see cref="T:System.UInt32" />.</exception>
      <returns vsli:raw="The big endian value.">Valore big endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt32LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Legge un <see cref="T:System.UInt32" /> dall'inizio di un intervallo di byte di sola lettura, come little endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Intervallo di byte di sola lettura da leggere.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt32&quot; /&gt;.">
        <paramref name="source" /> è troppo piccolo per contenere un <see cref="T:System.UInt32" />.</exception>
      <returns vsli:raw="The little endian value.">Valore little endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt64BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Legge un <see cref="T:System.UInt64" /> dall'inizio di un intervallo di byte di sola lettura, come big endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Intervallo di byte di sola lettura da leggere.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt64&quot; /&gt;.">
        <paramref name="source" /> è troppo piccolo per contenere un <see cref="T:System.UInt64" />.</exception>
      <returns vsli:raw="The big endian value.">Valore big endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt64LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Legge un <see cref="T:System.UInt64" /> dall'inizio di un intervallo di byte di sola lettura, come little endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Intervallo di byte di sola lettura da leggere.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt64&quot; /&gt;.">
        <paramref name="source" /> è troppo piccolo per contenere un <see cref="T:System.UInt64" />.</exception>
      <returns vsli:raw="The little endian value.">Valore little endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Byte)">
      <summary vsli:raw="Reverses a primitive value by performing an endianness swap of the specified &lt;see cref=&quot;T:System.Byte&quot; /&gt; value, which effectively does nothing for a &lt;see cref=&quot;T:System.Byte&quot; /&gt;.">Inverte un valore primitivo eseguendo uno scambio dell'ordine dei byte del valore <see cref="T:System.Byte" /> specificato, operazione in realtà senza effetti per un <see cref="T:System.Byte" />.</summary>
      <param name="value" vsli:raw="The value to reverse.">Valore da invertire.</param>
      <returns vsli:raw="The passed-in value, unmodified.">Valore passato, non modificato.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int16)">
      <summary vsli:raw="Reverses a primitive value by performing an endianness swap of the specified &lt;see cref=&quot;T:System.Int16&quot; /&gt; value.">Inverte un valore primitivo eseguendo uno scambio dell'ordine dei byte del valore <see cref="T:System.Int16" /> specificato.</summary>
      <param name="value" vsli:raw="The value to reverse.">Valore da invertire.</param>
      <returns vsli:raw="The reversed value.">Valore invertito.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int32)">
      <summary vsli:raw="Reverses a primitive value by performing an endianness swap of the specified &lt;see cref=&quot;T:System.Int32&quot; /&gt; value.">Inverte un valore primitivo eseguendo uno scambio dell'ordine dei byte del valore <see cref="T:System.Int32" /> specificato.</summary>
      <param name="value" vsli:raw="The value to reverse.">Valore da invertire.</param>
      <returns vsli:raw="The reversed value.">Valore invertito.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int64)">
      <summary vsli:raw="Reverses a primitive value by performing an endianness swap of the specified &lt;see cref=&quot;T:System.Int64&quot; /&gt; value.">Inverte un valore primitivo eseguendo uno scambio dell'ordine dei byte del valore <see cref="T:System.Int64" /> specificato.</summary>
      <param name="value" vsli:raw="The value to reverse.">Valore da invertire.</param>
      <returns vsli:raw="The reversed value.">Valore invertito.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.SByte)">
      <summary vsli:raw="Reverses a primitive value by performing an endianness swap of the specified &lt;see cref=&quot;T:System.SByte&quot; /&gt; value, which effectively does nothing for an &lt;see cref=&quot;T:System.SByte&quot; /&gt;.">Inverte un valore primitivo eseguendo uno scambio dell'ordine dei byte del valore <see cref="T:System.SByte" /> specificato, operazione in realtà senza effetti per un <see cref="T:System.SByte" />.</summary>
      <param name="value" vsli:raw="The value to reverse.">Valore da invertire.</param>
      <returns vsli:raw="The passed-in value, unmodified.">Valore passato, non modificato.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt16)">
      <summary vsli:raw="Reverses a primitive value by performing an endianness swap of the specified &lt;see cref=&quot;T:System.UInt16&quot; /&gt; value.">Inverte un valore primitivo eseguendo uno scambio dell'ordine dei byte del valore <see cref="T:System.UInt16" /> specificato.</summary>
      <param name="value" vsli:raw="The value to reverse.">Valore da invertire.</param>
      <returns vsli:raw="The reversed value.">Valore invertito.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt32)">
      <summary vsli:raw="Reverses a primitive value by performing an endianness swap of the specified &lt;see cref=&quot;T:System.UInt32&quot; /&gt; value.">Inverte un valore primitivo eseguendo uno scambio dell'ordine dei byte del valore <see cref="T:System.UInt32" /> specificato.</summary>
      <param name="value" vsli:raw="The value to reverse.">Valore da invertire.</param>
      <returns vsli:raw="The reversed value.">Valore invertito.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt64)">
      <summary vsli:raw="Reverses a primitive value by performing an endianness swap of the specified &lt;see cref=&quot;T:System.UInt64&quot; /&gt; value.">Inverte un valore primitivo eseguendo uno scambio dell'ordine dei byte del valore <see cref="T:System.UInt64" /> specificato.</summary>
      <param name="value" vsli:raw="The value to reverse.">Valore da invertire.</param>
      <returns vsli:raw="The reversed value.">Valore invertito.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadDoubleBigEndian(System.ReadOnlySpan{System.Byte},System.Double@)">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.Double&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Legge un <see cref="T:System.Double" /> dall'inizio di un intervallo di byte di sola lettura, come big endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Intervallo di byte di sola lettura da leggere.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as big endian.">Al termine, questo metodo contiene il valore letto dall'intervallo di byte di sola lettura, come big endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.Double&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.Double" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadDoubleLittleEndian(System.ReadOnlySpan{System.Byte},System.Double@)">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.Double&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Legge un <see cref="T:System.Double" /> dall'inizio di un intervallo di byte di sola lettura, come little endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Intervallo di byte di sola lettura da leggere.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as little endian.">Al termine, questo metodo contiene il valore letto dall'intervallo di byte di sola lettura, come little endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.Double&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.Double" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt16BigEndian(System.ReadOnlySpan{System.Byte},System.Int16@)">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int16&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Legge un <see cref="T:System.Int16" /> dall'inizio di un intervallo di byte di sola lettura, come big endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Intervallo di byte di sola lettura da leggere.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as big endian.">Al termine di questo metodo, il valore letto dall'intervallo di byte di sola lettura, come big endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int16&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.Int16" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt16LittleEndian(System.ReadOnlySpan{System.Byte},System.Int16@)">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int16&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Legge un <see cref="T:System.Int16" /> dall'inizio di un intervallo di byte di sola lettura, come little endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Intervallo di byte di sola lettura da leggere.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as little endian.">Al termine di questo metodo, il valore letto dall'intervallo di byte di sola lettura, come little endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int16&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.Int16" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt32BigEndian(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int32&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Legge un <see cref="T:System.Int32" /> dall'inizio di un intervallo di byte di sola lettura, come big endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Intervallo di byte di sola lettura da leggere.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as big endian.">Al termine di questo metodo, il valore letto dall'intervallo di byte di sola lettura, come big endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int32&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.Int32" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt32LittleEndian(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int32&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Legge un <see cref="T:System.Int32" /> dall'inizio di un intervallo di byte di sola lettura, come little endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Intervallo di byte di sola lettura da leggere.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as little endian.">Al termine di questo metodo, il valore letto dall'intervallo di byte di sola lettura, come little endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int32&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.Int32" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt64BigEndian(System.ReadOnlySpan{System.Byte},System.Int64@)">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int64&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Legge un <see cref="T:System.Int64" /> dall'inizio di un intervallo di byte di sola lettura, come big endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Intervallo di byte di sola lettura da leggere.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as big endian.">Al termine di questo metodo, il valore letto dall'intervallo di byte di sola lettura, come big endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int64&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.Int64" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt64LittleEndian(System.ReadOnlySpan{System.Byte},System.Int64@)">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int64&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Legge un <see cref="T:System.Int64" /> dall'inizio di un intervallo di byte di sola lettura, come little endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Intervallo di byte di sola lettura da leggere.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as little endian.">Al termine di questo metodo, il valore letto dall'intervallo di byte di sola lettura, come little endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int64&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.Int64" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadSingleBigEndian(System.ReadOnlySpan{System.Byte},System.Single@)">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.Single&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Legge un <see cref="T:System.Single" /> dall'inizio di un intervallo di byte di sola lettura, come big endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Intervallo di byte di sola lettura da leggere.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as big endian.">Al termine, questo metodo contiene il valore letto dall'intervallo di byte di sola lettura, come big endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.Single&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.Single" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadSingleLittleEndian(System.ReadOnlySpan{System.Byte},System.Single@)">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.Single&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Legge un <see cref="T:System.Single" /> dall'inizio di un intervallo di byte di sola lettura, come little endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Intervallo di byte di sola lettura da leggere.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as little endian.">Al termine, questo metodo contiene il valore letto dall'intervallo di byte di sola lettura, come little endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.Single&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.Single" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt16BigEndian(System.ReadOnlySpan{System.Byte},System.UInt16@)">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Legge un <see cref="T:System.UInt16" /> dall'inizio di un intervallo di byte di sola lettura, come big endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Intervallo di byte di sola lettura da leggere.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as big endian.">Al termine di questo metodo, il valore letto dall'intervallo di byte di sola lettura, come big endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt16&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.UInt16" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt16LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt16@)">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Legge un <see cref="T:System.UInt16" /> dall'inizio di un intervallo di byte di sola lettura, come little endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Intervallo di byte di sola lettura da leggere.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as little endian.">Al termine di questo metodo, il valore letto dall'intervallo di byte di sola lettura, come little endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt16&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.UInt16" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt32BigEndian(System.ReadOnlySpan{System.Byte},System.UInt32@)">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Legge un <see cref="T:System.UInt32" /> dall'inizio di un intervallo di byte di sola lettura, come big endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Intervallo di byte di sola lettura da leggere.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as big endian.">Al termine di questo metodo, il valore letto dall'intervallo di byte di sola lettura, come big endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt32&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.UInt32" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt32LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt32@)">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Legge un <see cref="T:System.UInt32" /> dall'inizio di un intervallo di byte di sola lettura, come little endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Intervallo di byte di sola lettura da leggere.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as little endian.">Al termine di questo metodo, il valore letto dall'intervallo di byte di sola lettura, come little endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt32&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.UInt32" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt64BigEndian(System.ReadOnlySpan{System.Byte},System.UInt64@)">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Legge un <see cref="T:System.UInt64" /> dall'inizio di un intervallo di byte di sola lettura, come big endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Intervallo di byte di sola lettura da leggere.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as big endian.">Al termine di questo metodo, il valore letto dall'intervallo di byte di sola lettura, come big endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt64&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.UInt64" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt64LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt64@)">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Legge un <see cref="T:System.UInt64" /> dall'inizio di un intervallo di byte di sola lettura, come little endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Intervallo di byte di sola lettura da leggere.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as little endian.">Al termine di questo metodo, il valore letto dall'intervallo di byte di sola lettura, come little endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt64&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.UInt64" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteDoubleBigEndian(System.Span{System.Byte},System.Double)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.Double&quot; /&gt; into a span of bytes, as big endian.">Scrive un <see cref="T:System.Double" /> in un intervallo di byte, come big endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Intervallo di byte in cui deve essere scritto il valore, come big endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valore da scrivere nell'intervallo di byte.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.Double&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.Double" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteDoubleLittleEndian(System.Span{System.Byte},System.Double)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.Double&quot; /&gt; into a span of bytes, as little endian.">Scrive un <see cref="T:System.Double" /> in un intervallo di byte, come little endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Intervallo di byte in cui deve essere scritto il valore, come little endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valore da scrivere nell'intervallo di byte.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.Double&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.Double" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt16BigEndian(System.Span{System.Byte},System.Int16)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int16&quot; /&gt; into a span of bytes, as big endian.">Scrive un <see cref="T:System.Int16" /> in un intervallo di byte, come big endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Intervallo di byte in cui deve essere scritto il valore, come big endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valore da scrivere nell'intervallo di byte.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int16&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.Int16" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt16LittleEndian(System.Span{System.Byte},System.Int16)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int16&quot; /&gt; into a span of bytes, as little endian.">Scrive un <see cref="T:System.Int16" /> in un intervallo di byte, come little endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Intervallo di byte in cui deve essere scritto il valore, come little endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valore da scrivere nell'intervallo di byte.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int16&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.Int16" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt32BigEndian(System.Span{System.Byte},System.Int32)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int32&quot; /&gt; into a span of bytes, as big endian.">Scrive un <see cref="T:System.Int32" /> in un intervallo di byte, come big endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Intervallo di byte in cui deve essere scritto il valore, come big endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valore da scrivere nell'intervallo di byte.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int32&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.Int32" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt32LittleEndian(System.Span{System.Byte},System.Int32)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int32&quot; /&gt; into a span of bytes, as little endian.">Scrive un <see cref="T:System.Int32" /> in un intervallo di byte, come little endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Intervallo di byte in cui deve essere scritto il valore, come little endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valore da scrivere nell'intervallo di byte.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int32&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.Int32" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt64BigEndian(System.Span{System.Byte},System.Int64)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int64&quot; /&gt; into a span of bytes, as big endian.">Scrive un <see cref="T:System.Int64" /> in un intervallo di byte, come big endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Intervallo di byte in cui deve essere scritto il valore, come big endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valore da scrivere nell'intervallo di byte.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int64&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.Int64" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt64LittleEndian(System.Span{System.Byte},System.Int64)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int64&quot; /&gt; into a span of bytes, as little endian.">Scrive un <see cref="T:System.Int64" /> in un intervallo di byte, come little endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Intervallo di byte in cui deve essere scritto il valore, come little endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valore da scrivere nell'intervallo di byte.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int64&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.Int64" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteSingleBigEndian(System.Span{System.Byte},System.Single)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.Single&quot; /&gt; into a span of bytes, as big endian.">Scrive un <see cref="T:System.Single" /> in un intervallo di byte, come big endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Intervallo di byte in cui deve essere scritto il valore, come big endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valore da scrivere nell'intervallo di byte.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.Single&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.Single" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteSingleLittleEndian(System.Span{System.Byte},System.Single)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.Single&quot; /&gt; into a span of bytes, as little endian.">Scrive un <see cref="T:System.Single" /> in un intervallo di byte, come little endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Intervallo di byte in cui deve essere scritto il valore, come little endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valore da scrivere nell'intervallo di byte.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.Single&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.Single" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt16BigEndian(System.Span{System.Byte},System.UInt16)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; into a span of bytes, as big endian.">Scrive un <see cref="T:System.UInt16" /> in un intervallo di byte, come big endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Intervallo di byte in cui deve essere scritto il valore, come big endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valore da scrivere nell'intervallo di byte.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt16&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.UInt16" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt16LittleEndian(System.Span{System.Byte},System.UInt16)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; into a span of bytes, as little endian.">Scrive un <see cref="T:System.UInt16" /> in un intervallo di byte, come little endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Intervallo di byte in cui deve essere scritto il valore, come little endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valore da scrivere nell'intervallo di byte.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt16&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.UInt16" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt32BigEndian(System.Span{System.Byte},System.UInt32)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; into a span of bytes, as big endian.">Scrive un <see cref="T:System.UInt32" /> in un intervallo di byte, come big endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Intervallo di byte in cui deve essere scritto il valore, come big endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valore da scrivere nell'intervallo di byte.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt32&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.UInt32" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt32LittleEndian(System.Span{System.Byte},System.UInt32)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; into a span of bytes, as little endian.">Scrive un <see cref="T:System.UInt32" /> in un intervallo di byte, come little endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Intervallo di byte in cui deve essere scritto il valore, come little endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valore da scrivere nell'intervallo di byte.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt32&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.UInt32" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt64BigEndian(System.Span{System.Byte},System.UInt64)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; into a span of bytes, as big endian.">Scrive un <see cref="T:System.UInt64" /> in un intervallo di byte, come big endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Intervallo di byte in cui deve essere scritto il valore, come big endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valore da scrivere nell'intervallo di byte.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt64&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.UInt64" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt64LittleEndian(System.Span{System.Byte},System.UInt64)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; into a span of bytes, as little endian.">Scrive un <see cref="T:System.UInt64" /> in un intervallo di byte, come little endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Intervallo di byte in cui deve essere scritto il valore, come little endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valore da scrivere nell'intervallo di byte.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt64&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.UInt64" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteDoubleBigEndian(System.Span{System.Byte},System.Double)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.Double&quot; /&gt; into a span of bytes, as big endian.">Scrive un <see cref="T:System.Double" /> in un intervallo di byte, come big endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Intervallo di byte in cui deve essere scritto il valore, come big endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valore da scrivere nell'intervallo di byte.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.Double&quot; /&gt;.">
        <paramref name="destination" /> è troppo piccolo per contenere un <see cref="T:System.Double" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteDoubleLittleEndian(System.Span{System.Byte},System.Double)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.Double&quot; /&gt; into a span of bytes, as little endian.">Scrive un <see cref="T:System.Double" /> in un intervallo di byte, come little endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Intervallo di byte in cui deve essere scritto il valore, come little endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valore da scrivere nell'intervallo di byte.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.Double&quot; /&gt;.">
        <paramref name="destination" /> è troppo piccolo per contenere un <see cref="T:System.Double" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt16BigEndian(System.Span{System.Byte},System.Int16)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int16&quot; /&gt; into a span of bytes, as big endian.">Scrive un <see cref="T:System.Int16" /> in un intervallo di byte, come big endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Intervallo di byte in cui deve essere scritto il valore, come big endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valore da scrivere nell'intervallo di byte.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int16&quot; /&gt;.">
        <paramref name="destination" /> è troppo piccolo per contenere un <see cref="T:System.Int16" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt16LittleEndian(System.Span{System.Byte},System.Int16)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int16&quot; /&gt; into a span of bytes, as little endian.">Scrive un <see cref="T:System.Int16" /> in un intervallo di byte, come little endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Intervallo di byte in cui deve essere scritto il valore, come little endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valore da scrivere nell'intervallo di byte.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int16&quot; /&gt;.">
        <paramref name="destination" /> è troppo piccolo per contenere un <see cref="T:System.Int16" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt32BigEndian(System.Span{System.Byte},System.Int32)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int32&quot; /&gt; into a span of bytes, as big endian.">Scrive un <see cref="T:System.Int32" /> in un intervallo di byte, come big endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Intervallo di byte in cui deve essere scritto il valore, come big endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valore da scrivere nell'intervallo di byte.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int32&quot; /&gt;.">
        <paramref name="destination" /> è troppo piccolo per contenere un <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt32LittleEndian(System.Span{System.Byte},System.Int32)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int32&quot; /&gt; into a span of bytes, as little endian.">Scrive un <see cref="T:System.Int32" /> in un intervallo di byte, come little endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Intervallo di byte in cui deve essere scritto il valore, come little endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valore da scrivere nell'intervallo di byte.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int32&quot; /&gt;.">
        <paramref name="destination" /> è troppo piccolo per contenere un <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt64BigEndian(System.Span{System.Byte},System.Int64)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int64&quot; /&gt; into a span of bytes, as big endian.">Scrive un <see cref="T:System.Int64" /> in un intervallo di byte, come big endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Intervallo di byte in cui deve essere scritto il valore, come big endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valore da scrivere nell'intervallo di byte.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int64&quot; /&gt;.">
        <paramref name="destination" /> è troppo piccolo per contenere un <see cref="T:System.Int64" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt64LittleEndian(System.Span{System.Byte},System.Int64)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int64&quot; /&gt; into a span of bytes, as little endian.">Scrive un <see cref="T:System.Int64" /> in un intervallo di byte, come little endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Intervallo di byte in cui deve essere scritto il valore, come little endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valore da scrivere nell'intervallo di byte.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int64&quot; /&gt;.">
        <paramref name="destination" /> è troppo piccolo per contenere un <see cref="T:System.Int64" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteSingleBigEndian(System.Span{System.Byte},System.Single)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.Single&quot; /&gt; into a span of bytes, as big endian.">Scrive un <see cref="T:System.Single" /> in un intervallo di byte, come big endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Intervallo di byte in cui deve essere scritto il valore, come big endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valore da scrivere nell'intervallo di byte.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.Single&quot; /&gt;.">
        <paramref name="destination" /> è troppo piccolo per contenere un <see cref="T:System.Single" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteSingleLittleEndian(System.Span{System.Byte},System.Single)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.Single&quot; /&gt; into a span of bytes, as little endian.">Scrive un <see cref="T:System.Single" /> in un intervallo di byte, come little endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Intervallo di byte in cui deve essere scritto il valore, come little endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valore da scrivere nell'intervallo di byte.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.Single&quot; /&gt;.">
        <paramref name="destination" /> è troppo piccolo per contenere un <see cref="T:System.Single" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt16BigEndian(System.Span{System.Byte},System.UInt16)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; into a span of bytes, as big endian.">Scrive un <see cref="T:System.UInt16" /> in un intervallo di byte, come big endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Intervallo di byte in cui deve essere scritto il valore, come big endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valore da scrivere nell'intervallo di byte.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt16&quot; /&gt;.">
        <paramref name="destination" /> è troppo piccolo per contenere un <see cref="T:System.UInt16" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt16LittleEndian(System.Span{System.Byte},System.UInt16)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; into a span of bytes, as little endian.">Scrive un <see cref="T:System.UInt16" /> in un intervallo di byte, come little endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Intervallo di byte in cui deve essere scritto il valore, come little endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valore da scrivere nell'intervallo di byte.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt16&quot; /&gt;.">
        <paramref name="destination" /> è troppo piccolo per contenere un <see cref="T:System.UInt16" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt32BigEndian(System.Span{System.Byte},System.UInt32)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; into a span of bytes, as big endian.">Scrive un <see cref="T:System.UInt32" /> in un intervallo di byte, come big endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Intervallo di byte in cui deve essere scritto il valore, come big endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valore da scrivere nell'intervallo di byte.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt32&quot; /&gt;.">
        <paramref name="destination" /> è troppo piccolo per contenere un <see cref="T:System.UInt32" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt32LittleEndian(System.Span{System.Byte},System.UInt32)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; into a span of bytes, as little endian.">Scrive un <see cref="T:System.UInt32" /> in un intervallo di byte, come little endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Intervallo di byte in cui deve essere scritto il valore, come little endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valore da scrivere nell'intervallo di byte.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt32&quot; /&gt;.">
        <paramref name="destination" /> è troppo piccolo per contenere un <see cref="T:System.UInt32" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt64BigEndian(System.Span{System.Byte},System.UInt64)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; into a span of bytes, as big endian.">Scrive un <see cref="T:System.UInt64" /> in un intervallo di byte, come big endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Intervallo di byte in cui deve essere scritto il valore, come big endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valore da scrivere nell'intervallo di byte.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt64&quot; /&gt;.">
        <paramref name="destination" /> è troppo piccolo per contenere un <see cref="T:System.UInt64" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt64LittleEndian(System.Span{System.Byte},System.UInt64)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; into a span of bytes, as little endian.">Scrive un <see cref="T:System.UInt64" /> in un intervallo di byte, come little endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Intervallo di byte in cui deve essere scritto il valore, come little endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valore da scrivere nell'intervallo di byte.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt64&quot; /&gt;.">
        <paramref name="destination" /> è troppo piccolo per contenere un <see cref="T:System.UInt64" />.</exception>
    </member>
    <member name="T:System.Buffers.BuffersExtensions">
      <summary vsli:raw="Provides extension methods for &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Fornisce metodi di estensione per <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
    </member>
    <member name="M:System.Buffers.BuffersExtensions.CopyTo``1(System.Buffers.ReadOnlySequence{``0},System.Span{``0})">
      <summary vsli:raw="Copies the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; to the specified &lt;see cref=&quot;T:System.Span`1&quot; /&gt;.">Copia <see cref="T:System.Buffers.ReadOnlySequence`1" /> nel <see cref="T:System.Span`1" /> specificato.</summary>
      <param name="source" vsli:raw="The source &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Il <see cref="T:System.Buffers.ReadOnlySequence`1" /> di origine.</param>
      <param name="destination" vsli:raw="The destination &lt;see cref=&quot;T:System.Span`1&quot; /&gt;.">
        <see cref="T:System.Span`1" /> di destinazione.</param>
      <typeparam name="T" vsli:raw="The type of the items in the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Tipo degli elementi nell'oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" /> .</typeparam>
    </member>
    <member name="M:System.Buffers.BuffersExtensions.PositionOf``1(System.Buffers.ReadOnlySequence{``0},``0)">
      <summary vsli:raw="Returns the position of the first occurrence of &lt;paramref name=&quot;item&quot; /&gt; in the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Restituisce la posizione della prima occorrenza di <paramref name="item" /> in <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
      <param name="source" vsli:raw="The source &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Il <see cref="T:System.Buffers.ReadOnlySequence`1" /> di origine.</param>
      <param name="value" vsli:raw="The item to find in the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Elemento da trovare in <see cref="T:System.Buffers.ReadOnlySequence`1" />.</param>
      <typeparam name="T" vsli:raw="The type of the items in the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Tipo degli elementi nell'oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" /> .</typeparam>
      <returns vsli:raw="An object whose &lt;see cref=&quot;M:System.SequencePosition.GetInteger&quot; /&gt; method returns the position of the first occurrence of &lt;paramref name=&quot;item&quot; /&gt;, or an object whose &lt;see langword=&quot;Nullable&amp;lt;SequencePosition&amp;gt;.HasValue&quot; /&gt; property is &lt;see langword=&quot;false&quot; /&gt; .">Oggetto il cui metodo <see cref="M:System.SequencePosition.GetInteger" /> restituisce la posizione della prima occorrenza di <paramref name="item" />, o un oggetto la cui proprietà <see langword="Nullable&lt;SequencePosition&gt;.HasValue" /> è <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.BuffersExtensions.ToArray``1(System.Buffers.ReadOnlySequence{``0})">
      <summary vsli:raw="Converts the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; to an array.">Converte <see cref="T:System.Buffers.ReadOnlySequence`1" /> in una matrice.</summary>
      <param name="sequence" vsli:raw="The read-only sequence to convert to an array.">Sequenza di sola lettura da convertire in una matrice.</param>
      <typeparam name="T" vsli:raw="The type of the items in the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Tipo degli elementi nell'oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" /> .</typeparam>
      <returns vsli:raw="An array containing the data in the current read-only sequence.">Matrice che contiene i dati nella sequenza di sola lettura corrente.</returns>
    </member>
    <member name="M:System.Buffers.BuffersExtensions.Write``1(System.Buffers.IBufferWriter{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Writes the contents of &lt;paramref name=&quot;value&quot; /&gt; to &lt;paramref name=&quot;writer&quot; /&gt;.">Scrive il contenuto di <paramref name="value" /> in <paramref name="writer" />.</summary>
      <param name="writer" vsli:raw="The buffer writer to which to write &lt;paramref name=&quot;value&quot; /&gt;.">Writer del buffer in cui scrivere <paramref name="value" />.</param>
      <param name="value" vsli:raw="The read-only span to be written to &lt;paramref name=&quot;writer&quot; /&gt;.">Intervallo di sola lettura da scrivere in <paramref name="writer" />.</param>
      <typeparam name="T" vsli:raw="The type of the items in the &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt;.">Tipo degli elementi nell'oggetto <see cref="T:System.ReadOnlySpan`1" /> .</typeparam>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;writer&quot; /&gt; is shorter than &lt;paramref name=&quot;value&quot; /&gt;.">
        <paramref name="writer" /> è più breve di <paramref name="value" />.</exception>
    </member>
    <member name="T:System.Buffers.IBufferWriter`1">
      <summary vsli:raw="Represents an output sink into which &lt;typeparamref name=&quot;T&quot; /&gt; data can be written.">Rappresenta un sink di output in cui è possibile scrivere dati <typeparamref name="T" />.</summary>
      <typeparam name="T" vsli:raw="The type of the items in the &lt;see cref=&quot;T:System.Buffers.IBufferWriter`1&quot; /&gt;.">Tipo degli elementi nell'oggetto <see cref="T:System.Buffers.IBufferWriter`1" /> .</typeparam>
    </member>
    <member name="M:System.Buffers.IBufferWriter`1.Advance(System.Int32)">
      <summary vsli:raw="Notifies the &lt;see cref=&quot;T:System.Buffers.IBufferWriter`1&quot; /&gt; that &lt;paramref name=&quot;count&quot; /&gt; data items were written to the output &lt;see cref=&quot;T:System.Span`1&quot; /&gt; or &lt;see cref=&quot;T:System.Memory`1&quot; /&gt;.">Comunica a <see cref="T:System.Buffers.IBufferWriter`1" /> che gli elementi di dati <paramref name="count" /> sono stati scritti nell'elemento <see cref="T:System.Span`1" /> o <see cref="T:System.Memory`1" /> di output.</summary>
      <param name="count" vsli:raw="The number of data items written to the &lt;see cref=&quot;T:System.Span`1&quot; /&gt; or &lt;see cref=&quot;T:System.Memory`1&quot; /&gt;.">Numero di elementi di dati scritti in <see cref="T:System.Span`1" /> o <see cref="T:System.Memory`1" />.</param>
    </member>
    <member name="M:System.Buffers.IBufferWriter`1.GetMemory(System.Int32)">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Memory`1&quot; /&gt; to write to that is at least the requested size (specified by &lt;paramref name=&quot;sizeHint&quot; /&gt;).">Restituisce un elemento <see cref="T:System.Memory`1" /> in cui scrivere, con almeno le dimensioni richieste (specificate da <paramref name="sizeHint" />).</summary>
      <param name="sizeHint" vsli:raw="The minimum length of the returned &lt;see cref=&quot;T:System.Memory`1&quot; /&gt;. If 0, a non-empty buffer is returned.">Lunghezza minima dell'elemento <see cref="T:System.Memory`1" /> restituito. Se è 0, viene restituito un buffer non vuoto.</param>
      <exception cref="T:System.OutOfMemoryException" vsli:raw="The requested buffer size is not available.">Le dimensioni del buffer richieste non sono disponibili.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Memory`1&quot; /&gt; of at least the size &lt;paramref name=&quot;sizeHint&quot; /&gt;. If &lt;paramref name=&quot;sizeHint&quot; /&gt; is 0, returns a non-empty buffer.">Elemento <see cref="T:System.Memory`1" /> con dimensioni pari almeno a <paramref name="sizeHint" />. Se <paramref name="sizeHint" /> è 0, restituisce un buffer non vuoto.</returns>
    </member>
    <member name="M:System.Buffers.IBufferWriter`1.GetSpan(System.Int32)">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Span`1&quot; /&gt; to write to that is at least the requested size (specified by &lt;paramref name=&quot;sizeHint&quot; /&gt;).">Restituisce un elemento <see cref="T:System.Span`1" /> in cui scrivere, con almeno le dimensioni richieste (specificate da <paramref name="sizeHint" />).</summary>
      <param name="sizeHint" vsli:raw="The minimum length of the returned &lt;see cref=&quot;T:System.Span`1&quot; /&gt;. If 0, a non-empty buffer is returned.">Lunghezza minima dell'elemento <see cref="T:System.Span`1" /> restituito. Se è 0, viene restituito un buffer non vuoto.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Span`1&quot; /&gt; of at least the size &lt;paramref name=&quot;sizeHint&quot; /&gt;. If &lt;paramref name=&quot;sizeHint&quot; /&gt; is 0, returns a non-empty buffer.">Elemento <see cref="T:System.Span`1" /> con dimensioni pari almeno a <paramref name="sizeHint" />. Se <paramref name="sizeHint" /> è 0, restituisce un buffer non vuoto.</returns>
    </member>
    <member name="T:System.Buffers.MemoryPool`1">
      <summary vsli:raw="Represents a pool of memory blocks.">Rappresenta un pool di blocchi di memoria.</summary>
      <typeparam name="T" vsli:raw="The type of the items in the memory pool.">Tipo di elementi nel pool di memoria.</typeparam>
    </member>
    <member name="M:System.Buffers.MemoryPool`1.#ctor">
      <summary vsli:raw="Constructs a new instance of a memory pool.">Costruisce una nuova istanza di un pool di memoria.</summary>
    </member>
    <member name="M:System.Buffers.MemoryPool`1.Dispose">
      <summary vsli:raw="Frees all resources used by the memory pool.">Rilascia tutte le risorse usate dal pool di memoria.</summary>
    </member>
    <member name="M:System.Buffers.MemoryPool`1.Dispose(System.Boolean)">
      <summary vsli:raw="Frees the unmanaged resources used by the memory pool and optionally releases the managed resources.">Rilascia le risorse non gestite usate dal pool di memoria e, facoltativamente, le risorse gestite.</summary>
      <param name="disposing" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to release both managed and unmanaged resources; &lt;see langword=&quot;false&quot; /&gt; to release only unmanaged resources.">
        <see langword="true" /> per rilasciare sia le risorse gestite sia quelle non gestite; <see langword="false" /> per rilasciare solo le risorse non gestite.</param>
    </member>
    <member name="M:System.Buffers.MemoryPool`1.Rent(System.Int32)">
      <summary vsli:raw="Returns a memory block capable of holding at least &lt;paramref name=&quot;minBufferSize&quot; /&gt; elements of T.">Restituisce un blocco di memoria in grado di contenere almeno <paramref name="minBufferSize" /> elementi di T.</summary>
      <param name="minBufferSize" vsli:raw="The minimum number of elements of &lt;typeparamref name=&quot;T&quot; /&gt; that the memory pool can hold. A value of -1 returns a memory pool set to the default size for the pool.">Numero minimo di elementi di <typeparamref name="T" /> che può contenere il pool di memoria. Il valore -1 restituisce un pool di memoria impostato sulle dimensioni predefinite per il pool.</param>
      <returns vsli:raw="A memory block capable of holding at least &lt;paramref name=&quot;minBufferSize&quot; /&gt; elements of T.">Un blocco di memoria in grado di contenere almeno <paramref name="minBufferSize" /> elementi di T.</returns>
    </member>
    <member name="P:System.Buffers.MemoryPool`1.MaxBufferSize">
      <summary vsli:raw="Gets the maximum buffer size supported by this pool.">Ottiene la dimensione massima del buffer supportata da questo pool.</summary>
      <returns vsli:raw="The maximum buffer size supported by this pool.">Dimensione massima del buffer supportata da questo pool.</returns>
    </member>
    <member name="P:System.Buffers.MemoryPool`1.Shared">
      <summary vsli:raw="Gets a singleton instance of a memory pool based on arrays.">Ottiene un'istanza singleton di un pool di memoria basato su matrici.</summary>
      <returns vsli:raw="A singleton instance of a memory pool.">Istanza singleton di un pool di memoria.</returns>
    </member>
    <member name="T:System.Buffers.ReadOnlySequence`1">
      <summary vsli:raw="Represents a sequence that can read a sequential series of &lt;typeparamref name=&quot;T&quot; /&gt;.">Rappresenta una sequenza in grado di leggere una serie sequenziale di <typeparamref name="T" />.</summary>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only sequence.">Tipo degli elementi nella sequenza di sola lettura.</typeparam>
    </member>
    <member name="F:System.Buffers.ReadOnlySequence`1.Empty">
      <summary vsli:raw="Returns an empty &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Restituisce un oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" /> vuoto.</summary>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(`0[])">
      <summary vsli:raw="Creates an instance of &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; from the &lt;paramref name=&quot;array&quot; /&gt;.">Crea un'istanza di <see cref="T:System.Buffers.ReadOnlySequence`1" /> da <paramref name="array" />.</summary>
      <param name="array" vsli:raw="The array from which to create a read-only sequence.">Matrice da cui creare una sequenza di sola lettura.</param>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(`0[],System.Int32,System.Int32)">
      <summary vsli:raw="Creates an instance of a &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; from a section of an array.">Crea un'istanza di <see cref="T:System.Buffers.ReadOnlySequence`1" /> da una sezione di una matrice.</summary>
      <param name="array" vsli:raw="The array from which to create the read-only sequence.">Matrice da cui creare la sequenza di sola lettura.</param>
      <param name="start" vsli:raw="The zero-based index of the first element in the array to include in the read-only sequence.">Indice in base zero del primo elemento nella matrice da includere nella sequenza di sola lettura.</param>
      <param name="length" vsli:raw="The number of elements to include in the read-only sequence.">Numero di elementi da includere nella sequenza di sola lettura.</param>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(System.Buffers.ReadOnlySequenceSegment{`0},System.Int32,System.Buffers.ReadOnlySequenceSegment{`0},System.Int32)">
      <summary vsli:raw="Creates an instance of a &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; from a linked memory list represented by start and end segments and the corresponding indexes in them.">Crea un'istanza di <see cref="T:System.Buffers.ReadOnlySequence`1" /> da un elenco di memoria collegata rappresentato da segmenti iniziali e finali e dagli indici corrispondenti in essi contenuti.</summary>
      <param name="startSegment" vsli:raw="The initial node of the linked memory list.">Nodo iniziale dell'elenco di memoria collegata.</param>
      <param name="startIndex" vsli:raw="The position to the start of the sequence inside &lt;paramref name=&quot;startSegment&quot; /&gt;.">Posizione dell'inizio della sequenza all'interno di <paramref name="startSegment" />.</param>
      <param name="endSegment" vsli:raw="The final node of the linked memory list.">Nodo finale dell'elenco di memoria collegata.</param>
      <param name="endIndex" vsli:raw="The position to the end of the sequence inside &lt;paramref name=&quot;endSegment&quot; /&gt;.">Posizione della fine della sequenza all'interno di <paramref name="endSegment" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;startSegment&quot; /&gt; or &lt;paramref name=&quot;endSegment&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="startSegment" /> o <paramref name="endSegment" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The running index of &lt;paramref name=&quot;startSegment&quot; /&gt; is greater than the running index of &lt;paramref name=&quot;endSegment&quot; /&gt;, even though &lt;paramref name=&quot;startSegment&quot; /&gt; is different to &lt;paramref name=&quot;endSegment&quot; /&gt;.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;startSegment&quot; /&gt; is equal to &lt;paramref name=&quot;endSegment&quot; /&gt; but &lt;paramref name=&quot;endIndex&quot; /&gt; is smaller than &lt;paramref name=&quot;startIndex&quot; /&gt;.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;startIndex&quot; /&gt; is greater than the length of the underlying memory block of &lt;paramref name=&quot;startSegment&quot; /&gt;.">L'indice corrente di <paramref name="startSegment" /> è maggiore dell'indice corrente di <paramref name="endSegment" />, anche se <paramref name="startSegment" /> è diverso da <paramref name="endSegment" />.

-oppure-

<paramref name="startSegment" /> è uguale a <paramref name="endSegment" /> ma <paramref name="endIndex" /> è minore di <paramref name="startIndex" />.

-oppure-

<paramref name="startIndex" /> è maggiore della lunghezza del blocco di memoria sottostante di <paramref name="startSegment" />.</exception>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(System.ReadOnlyMemory{`0})">
      <summary vsli:raw="Creates an instance of &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; from a &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt;.">Crea un'istanza di <see cref="T:System.Buffers.ReadOnlySequence`1" /> da <see cref="T:System.ReadOnlyMemory`1" />.</summary>
      <param name="memory" vsli:raw="A read-only block of memory of elements of type &lt;typeparamref name=&quot;T&quot; /&gt;.">Blocco di memoria di sola lettura di elementi di tipo <typeparamref name="T" />.</param>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.GetEnumerator">
      <summary vsli:raw="Returns an enumerator over the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Restituisce un enumeratore per <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
      <returns vsli:raw="Returns an enumerator over the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Restituisce un enumeratore per <see cref="T:System.Buffers.ReadOnlySequence`1" />.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.GetOffset(System.SequencePosition)">
      <summary vsli:raw="Returns the offset of a &lt;paramref name=&quot;position&quot; /&gt; within this sequence from the start.">Restituisce l'offset di un oggetto <paramref name="position" /> all'interno di questa sequenza dall'inizio.</summary>
      <param name="position" vsli:raw="The &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; of which to get the offset.">
        <see cref="T:System.SequencePosition" /> di cui ottenere l'offset.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The position is out of range.">La posizione non è compresa nell'intervallo consentito.</exception>
      <returns vsli:raw="The offset from the start of the sequence.">Offset dall'inizio della sequenza.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.GetPosition(System.Int64)">
      <summary vsli:raw="Returns a new &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; at an &lt;paramref name=&quot;offset&quot; /&gt; from the start of the sequence.">Restituisce una nuova <see cref="T:System.SequencePosition" /> in corrispondenza di <paramref name="offset" /> dall'inizio della sequenza.</summary>
      <param name="offset" vsli:raw="The offset from the start of the sequence.">Offset dall'inizio della sequenza.</param>
      <returns vsli:raw="An object representing the sequence position that starts at the specified &lt;paramref name=&quot;offset&quot; /&gt; from the start of the sequence.">Oggetto che rappresenta la posizione della sequenza che inizia in corrispondenza dell'elemento <paramref name="offset" /> specificato dall'inizio della sequenza.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.GetPosition(System.Int64,System.SequencePosition)">
      <summary vsli:raw="Returns a new &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; starting at the specified offset from the &lt;paramref name=&quot;origin&quot; /&gt; position.">Restituisce una nuovo elemento <see cref="T:System.SequencePosition" /> a partire dall'offset specificato dalla posizione di <paramref name="origin" />.</summary>
      <param name="offset" vsli:raw="The offset from the specified &lt;paramref name=&quot;origin&quot; /&gt; sequence position.">Offset dalla posizione della sequenza <paramref name="origin" /> specificata.</param>
      <param name="origin" vsli:raw="A sequence position representing the point from which to initiate the offset.">Posizione della sequenza che rappresenta il punto da cui avviare l'offset.</param>
      <returns vsli:raw="An object representing the sequence position that starts at the &lt;paramref name=&quot;offset&quot; /&gt; position of the specified &lt;paramref name=&quot;origin&quot; /&gt; position object.">Oggetto che rappresenta la posizione della sequenza che inizia in corrispondenza della posizione di <paramref name="offset" /> dell'oggetto posizione <paramref name="origin" /> specificato.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int32,System.Int32)">
      <summary vsli:raw="Forms a slice out of the current &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;, beginning at &lt;paramref name=&quot;start&quot; /&gt;, with &lt;paramref name=&quot;length&quot; /&gt; items.">Crea una sezione dall'oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" /> corrente, a partire da <paramref name="start" />, con <paramref name="length" /> elementi.</summary>
      <param name="start" vsli:raw="The index at which to begin this slice.">Indice in corrispondenza del quale iniziare la sezione.</param>
      <param name="length" vsli:raw="The length of the slice.">Lunghezza della sezione.</param>
      <returns vsli:raw="A slice that consists of &lt;paramref name=&quot;length&quot; /&gt; elements from the current instance starting at index &lt;paramref name=&quot;start&quot; /&gt;.">Sezione costituita da <paramref name="length" /> elementi dall'istanza corrente a partire dall'indice <paramref name="start" />.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int32,System.SequencePosition)">
      <summary vsli:raw="Forms a slice out of the current &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;, beginning at &lt;paramref name=&quot;start&quot; /&gt; and ending at &lt;paramref name=&quot;end&quot; /&gt; (exclusive).">Crea una sezione dall'oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" /> corrente, a partire da <paramref name="start" /> e fino a <paramref name="end" /> (esclusivo).</summary>
      <param name="start" vsli:raw="The index at which to begin this slice.">Indice in corrispondenza del quale iniziare la sezione.</param>
      <param name="end" vsli:raw="The end (exclusive) &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; of the slice.">Fine (esclusiva) <see cref="T:System.SequencePosition" /> della sezione.</param>
      <returns vsli:raw="A slice that consists of items from the &lt;paramref name=&quot;start&quot; /&gt; index to, but not including, the &lt;paramref name=&quot;end&quot; /&gt; sequence position in the current read-only sequence.">Sezione costituita da elementi dall'indice <paramref name="start" /> fino alla posizione della sequenza <paramref name="end" />, non inclusa, nella sequenza di sola lettura corrente.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int64)">
      <summary vsli:raw="Forms a slice out of the current &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;, beginning at a specified index and continuing to the end of the read-only sequence.">Crea una sezione dall'oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" /> corrente, iniziando in corrispondenza dell'indice specificato e continuando fino alla fine della sequenza di sola lettura.</summary>
      <param name="start" vsli:raw="The start index at which to begin this slice.">Indice iniziale in corrispondenza del quale iniziare la sezione.</param>
      <returns vsli:raw="A slice starting at index &lt;paramref name=&quot;start&quot; /&gt; and continuing to the end of the current read-only sequence.">Una sezione che inizia dall'indice <paramref name="start" /> e continua fino alla fine della sequenza corrente di sola lettura.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int64,System.Int64)">
      <summary vsli:raw="Forms a slice out of the given &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;, beginning at &lt;paramref name=&quot;start&quot; /&gt;, with &lt;paramref name=&quot;length&quot; /&gt; items.">Crea una sezione dall'oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" /> specificato, a partire da <paramref name="start" />, con <paramref name="length" /> elementi.</summary>
      <param name="start" vsli:raw="The index at which to begin this slice.">Indice in corrispondenza del quale iniziare la sezione.</param>
      <param name="length" vsli:raw="The length of the slice.">Lunghezza della sezione.</param>
      <returns vsli:raw="A slice that consists of &lt;paramref name=&quot;length&quot; /&gt; elements from the current instance starting at index &lt;paramref name=&quot;start&quot; /&gt;.">Sezione costituita da <paramref name="length" /> elementi dall'istanza corrente a partire dall'indice <paramref name="start" />.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int64,System.SequencePosition)">
      <summary vsli:raw="Forms a slice out of the current &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;, beginning at &lt;paramref name=&quot;start&quot; /&gt; and ending at &lt;paramref name=&quot;end&quot; /&gt; (exclusive).">Crea una sezione dall'oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" /> corrente, a partire da <paramref name="start" /> e fino a <paramref name="end" /> (esclusivo).</summary>
      <param name="start" vsli:raw="The index at which to begin this slice.">Indice in corrispondenza del quale iniziare la sezione.</param>
      <param name="end" vsli:raw="The end (exclusive) of the slice.">Fine (esclusiva) della sezione.</param>
      <returns vsli:raw="A slice that consists of items from the &lt;paramref name=&quot;start&quot; /&gt; index to, but not including, the &lt;paramref name=&quot;end&quot; /&gt; sequence position in the current read-only sequence.">Sezione costituita da elementi dall'indice <paramref name="start" /> fino alla posizione della sequenza <paramref name="end" />, non inclusa, nella sequenza di sola lettura corrente.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition)">
      <summary vsli:raw="Forms a slice out of the current &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;, beginning at a specified sequence position and continuing to the end of the read-only sequence.">Crea una sezione dall'oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" /> corrente, iniziando in corrispondenza della posizione della sequenza specificata e continuando fino alla fine della sequenza di sola lettura.</summary>
      <param name="start" vsli:raw="The starting (inclusive) &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; at which to begin this slice.">Valore <see cref="T:System.SequencePosition" /> iniziale (inclusivo) in corrispondenza del quale iniziare questa sezione.</param>
      <returns vsli:raw="A slice starting at sequence position &lt;paramref name=&quot;start&quot; /&gt; and continuing to the end of the current read-only sequence.">Una sezione che inizia dalla posizione della sequenza <paramref name="start" /> e continua fino alla fine della sequenza corrente di sola lettura.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition,System.Int32)">
      <summary vsli:raw="Forms a slice out of the current &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;, beginning at &lt;paramref name=&quot;start&quot; /&gt;, with &lt;paramref name=&quot;length&quot; /&gt; items.">Crea una sezione dall'oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" /> corrente, a partire da <paramref name="start" />, con <paramref name="length" /> elementi.</summary>
      <param name="start" vsli:raw="The starting (inclusive) &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; at which to begin this slice.">Valore <see cref="T:System.SequencePosition" /> iniziale (inclusivo) in corrispondenza del quale iniziare questa sezione.</param>
      <param name="length" vsli:raw="The length of the slice.">Lunghezza della sezione.</param>
      <returns vsli:raw="A slice that consists of &lt;paramref name=&quot;length&quot; /&gt; elements from the current instance starting at sequence position &lt;paramref name=&quot;start&quot; /&gt;.">Sezione costituita da <paramref name="length" /> elementi dall'istanza corrente a partire dalla posizione della sequenza <paramref name="start" />.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition,System.Int64)">
      <summary vsli:raw="Forms a slice out of the current &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;, beginning at &lt;paramref name=&quot;start&quot; /&gt;, with &lt;paramref name=&quot;length&quot; /&gt; items.">Crea una sezione dall'oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" /> corrente, a partire da <paramref name="start" />, con <paramref name="length" /> elementi.</summary>
      <param name="start" vsli:raw="The starting (inclusive) &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; at which to begin this slice.">Valore <see cref="T:System.SequencePosition" /> iniziale (inclusivo) in corrispondenza del quale iniziare questa sezione.</param>
      <param name="length" vsli:raw="The length of the slice.">Lunghezza della sezione.</param>
      <returns vsli:raw="A slice that consists of &lt;paramref name=&quot;length&quot; /&gt; elements from the current instance starting at sequence position &lt;paramref name=&quot;start&quot; /&gt;.">Sezione costituita da <paramref name="length" /> elementi dall'istanza corrente a partire dalla posizione della sequenza <paramref name="start" />.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition,System.SequencePosition)">
      <summary vsli:raw="Forms a slice out of the current &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;, beginning at &lt;paramref name=&quot;start&quot; /&gt; and ending at &lt;paramref name=&quot;end&quot; /&gt; (exclusive).">Crea una sezione dall'oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" /> corrente, a partire da <paramref name="start" /> e fino a <paramref name="end" /> (esclusivo).</summary>
      <param name="start" vsli:raw="The starting (inclusive) &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; at which to begin this slice.">Valore <see cref="T:System.SequencePosition" /> iniziale (inclusivo) in corrispondenza del quale iniziare questa sezione.</param>
      <param name="end" vsli:raw="The ending (exclusive) &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; of the slice.">Valore finale (esclusivo) <see cref="T:System.SequencePosition" /> della sezione.</param>
      <returns vsli:raw="A slice that consists of items from the &lt;paramref name=&quot;start&quot; /&gt; sequence position to, but not including, the &lt;paramref name=&quot;end&quot; /&gt; sequence position in the current read-only sequence.">Sezione costituita da elementi dalla posizione della sequenza <paramref name="start" /> fino alla posizione della sequenza <paramref name="end" />, non inclusa, nella sequenza di sola lettura corrente.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.ToString">
      <summary vsli:raw="Returns a string that represents the current sequence.">Restituisce una stringa che rappresenta la sequenza corrente.</summary>
      <returns vsli:raw="A string that represents the current sequence.">Stringa che rappresenta la sequenza corrente.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.TryGet(System.SequencePosition@,System.ReadOnlyMemory{`0}@,System.Boolean)">
      <summary vsli:raw="Tries to retrieve the next segment after &lt;paramref name=&quot;position&quot; /&gt; and returns a value that indicates whether the operation succeeded.">Tenta di recuperare il segmento successivo dopo <paramref name="position" /> e restituisce un valore che indica se l'operazione è riuscita.</summary>
      <param name="position" vsli:raw="The current sequence position.">Posizione della sequenza corrente.</param>
      <param name="memory" vsli:raw="A read-only memory span that contains the next segment after &lt;paramref name=&quot;position&quot; /&gt;.">Intervallo di memoria di sola lettura che contiene il segmento successivo dopo <paramref name="position" />.</param>
      <param name="advance" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;position&quot; /&gt; should to the beginning of next segment; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se <paramref name="position" /> deve essere all'inizio del segmento successivo. In caso contrario, <see langword="false" />.</param>
      <returns vsli:raw="Returns &lt;see langword=&quot;true&quot; /&gt; if the method returned the next segment, or &lt;see langword=&quot;false&quot; /&gt; if the end of the read-only sequence was reached.">Restituisce <see langword="true" /> se il metodo ha restituito il segmento successivo o <see langword="false" /> se è stata raggiunta la fine della sequenza di sola lettura.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.End">
      <summary vsli:raw="Gets the position at the end of the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Ottiene la posizione alla fine di <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.First">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt; from the first segment.">Ottiene <see cref="T:System.ReadOnlyMemory`1" /> dal primo segmento.</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.FirstSpan">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; from the first segment.">Ottiene <see cref="T:System.ReadOnlySpan`1" /> dal primo segmento.</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.IsEmpty">
      <summary vsli:raw="Gets a value that indicates whether the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; is empty.">Ottiene un valore che indica se <see cref="T:System.Buffers.ReadOnlySequence`1" /> è vuoto.</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.IsSingleSegment">
      <summary vsli:raw="Gets a value that indicates whether the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; contains a single &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt; segment.">Ottiene un valore che indica se <see cref="T:System.Buffers.ReadOnlySequence`1" /> contiene un singolo segmento <see cref="T:System.ReadOnlyMemory`1" />.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the read-only sequence is empty; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> Se la sequenza di sola lettura è vuota; in caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.Length">
      <summary vsli:raw="Gets the length of the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Ottiene la lunghezza dell'oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
      <returns vsli:raw="The length of the read-only sequence.">Lunghezza della sequenza di sola lettura.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.Start">
      <summary vsli:raw="Gets the position to the start of the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Ottiene la posizione all'inizio di <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
    </member>
    <member name="T:System.Buffers.ReadOnlySequence`1.Enumerator">
      <summary vsli:raw="Represents an enumerator over a &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Rappresenta un enumeratore su <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
      <typeparam name="T" vsli:raw="" />
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Enumerator.#ctor(System.Buffers.ReadOnlySequence{`0}@)">
      <summary vsli:raw="Initializes the enumerator.">Inizializza l'enumeratore.</summary>
      <param name="sequence" vsli:raw="The &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; to enumerate.">Insieme <see cref="T:System.Buffers.ReadOnlySequence`1" /> da enumerare.</param>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Enumerator.MoveNext">
      <summary vsli:raw="Moves to the next &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt; in the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Passa al successivo oggetto <see cref="T:System.ReadOnlyMemory`1" /> nell'oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator successfully advanced to the next item; &lt;see langword=&quot;false&quot; /&gt; if the end of the sequence has been reached.">
        <see langword="true" /> se l'enumeratore è stato spostato correttamente all'elemento successivo; <see langword="false" /> se è stata raggiunta la fine della sequenza.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.Enumerator.Current">
      <summary vsli:raw="Gets the current &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt;.">Ottiene l'oggetto <see cref="T:System.ReadOnlyMemory`1" /> corrente.</summary>
      <returns vsli:raw="The current &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt;.">Oggetto <see cref="T:System.ReadOnlyMemory`1" /> corrente.</returns>
    </member>
    <member name="T:System.Buffers.ReadOnlySequenceSegment`1">
      <summary vsli:raw="Represents a linked list of &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt; nodes.">Rappresenta un elenco collegato di nodi <see cref="T:System.ReadOnlyMemory`1" />.</summary>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only sequence segment.">Tipo di elementi nel segmento di sequenza di sola lettura.</typeparam>
    </member>
    <member name="M:System.Buffers.ReadOnlySequenceSegment`1.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequenceSegment`1&quot; /&gt; class.">Inizializza una nuova istanza della classe <see cref="T:System.Buffers.ReadOnlySequenceSegment`1" />.</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequenceSegment`1.Memory">
      <summary vsli:raw="Gets or sets a &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt; value for the current node.">Ottiene o imposta un valore <see cref="T:System.ReadOnlyMemory`1" /> per il nodo corrente.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt; value for the current node.">
        <see cref="T:System.ReadOnlyMemory`1" />Valore per il nodo corrente.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequenceSegment`1.Next">
      <summary vsli:raw="Gets or sets the next node.">Ottiene o imposta il nodo successivo.</summary>
      <returns vsli:raw="The next node.">Nodo successivo.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequenceSegment`1.RunningIndex">
      <summary vsli:raw="Gets or sets the sum of node lengths before the current node.">Ottiene o imposta la somma delle lunghezze di nodo prima del nodo corrente.</summary>
      <returns vsli:raw="The sum of node lengths before the current node.">Somma delle lunghezze dei nodi prima del nodo corrente.</returns>
    </member>
    <member name="T:System.Buffers.SequenceReader`1">
      <summary vsli:raw="Provides methods for reading binary and text data out of a &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; with a focus on performance and minimal or zero heap allocations.">Fornisce metodi per la lettura di dati binari e di testo da un oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" /> con particolare attenzione alle prestazioni e allocazioni di heap minime o assenti.</summary>
      <typeparam name="T" vsli:raw="The type of the read-only sequence.">Tipo della sequenza di sola lettura.</typeparam>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.#ctor(System.Buffers.ReadOnlySequence{`0})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Buffers.SequenceReader`1&quot; /&gt; over a given &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Crea un oggetto <see cref="T:System.Buffers.SequenceReader`1" /> su un oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" /> specificato.</summary>
      <param name="sequence" vsli:raw="The read-only sequence over which to create the &lt;see cref=&quot;T:System.Buffers.SequenceReader`1&quot; /&gt;.">La sequenza di sola lettura sulla quale creare <see cref="T:System.Buffers.SequenceReader`1" />.</param>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.Advance(System.Int64)">
      <summary vsli:raw="Moves the reader ahead a specified number of items.">Sposta il lettore in avanti di un numero specificato di elementi.</summary>
      <param name="count" vsli:raw="The number of items to advance.">Il numero di elementi da far avanzare.</param>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePast(`0)">
      <summary vsli:raw="Advances past consecutive instances of the given &lt;paramref name=&quot;value&quot; /&gt;.">Avanza oltre le istanze consecutive dell'oggetto <paramref name="value" /> specificato.</summary>
      <param name="value" vsli:raw="The value past which the reader is to advance.">Il valore oltre il quale il lettore deve avanzare.</param>
      <returns vsli:raw="The number of positions the reader has advanced.">Il numero di posizioni di cui è avanzato il lettore.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(`0,`0)">
      <summary vsli:raw="Advances past consecutive instances of either of two specified values.">Avanza oltre le istanze consecutive di uno di due valori specificati.</summary>
      <param name="value0" vsli:raw="The first value to skip.">Il primo valore da ignorare.</param>
      <param name="value1" vsli:raw="The second value to skip.">Il secondo valore da ignorare.</param>
      <returns vsli:raw="The number of positions the reader has advanced.">Il numero di posizioni di cui è avanzato il lettore.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(`0,`0,`0)">
      <summary vsli:raw="Advances past consecutive instances of any of three specified values.">Avanza oltre le istanze consecutive di uno di tre valori specificati.</summary>
      <param name="value0" vsli:raw="The first value to skip.">Il primo valore da ignorare.</param>
      <param name="value1" vsli:raw="The second value to skip.">Il secondo valore da ignorare.</param>
      <param name="value2" vsli:raw="The third value to skip.">Il terzo valore da ignorare.</param>
      <returns vsli:raw="The number of positions the reader has advanced.">Il numero di posizioni di cui è avanzato il lettore.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(`0,`0,`0,`0)">
      <summary vsli:raw="Advances past consecutive instances of any of four specified values.">Avanza oltre le istanze consecutive di uno di quattro valori specificati.</summary>
      <param name="value0" vsli:raw="The first value to skip.">Il primo valore da ignorare.</param>
      <param name="value1" vsli:raw="The second value to skip.">Il secondo valore da ignorare.</param>
      <param name="value2" vsli:raw="The third value to skip.">Il terzo valore da ignorare.</param>
      <param name="value3" vsli:raw="The fourth value to skip.">Il quarto valore da ignorare.</param>
      <returns vsli:raw="The number of positions the reader has advanced.">Il numero di posizioni di cui è avanzato il lettore.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(System.ReadOnlySpan{`0})">
      <summary vsli:raw="Skips consecutive instances of any of the specified &lt;paramref name=&quot;values&quot; /&gt;.">Ignora le istanze consecutive di qualsiasi oggetto <paramref name="values" /> specificato.</summary>
      <param name="values" vsli:raw="The values to be skipped.">I valori da ignorare.</param>
      <returns vsli:raw="The number of positions the reader has advanced.">Il numero di posizioni di cui è avanzato il lettore.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvanceToEnd">
      <summary vsli:raw="Moves the reader to the end of the sequence.">Sposta il lettore alla fine della sequenza.</summary>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.IsNext(`0,System.Boolean)">
      <summary vsli:raw="Checks whether a specified value is next in the sequence.">Controlla se un valore specificato è successivo nella sequenza.</summary>
      <param name="next" vsli:raw="The value to compare the next items to.">Il valore con cui confrontare gli elementi successivi.</param>
      <param name="advancePast" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the &lt;paramref name=&quot;next&quot; /&gt; values if they are found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> per spostarsi oltre i valori <paramref name="next" /> se vengono trovati. In caso contrario, <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the values are next in sequence; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se i valori sono successivi nella sequenza. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.IsNext(System.ReadOnlySpan{`0},System.Boolean)">
      <summary vsli:raw="Checks whether the values specified in a read-only span are next in the sequence.">Controlla se i valori specificati in un intervallo di sola lettura sono successivi nella sequenza.</summary>
      <param name="next" vsli:raw="The span to compare the next items to.">L'intervallo con cui confrontare gli elementi successivi.</param>
      <param name="advancePast" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the &lt;paramref name=&quot;next&quot; /&gt; values if they are found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> per spostarsi oltre i valori <paramref name="next" /> se vengono trovati. In caso contrario, <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the values are next in sequence; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se i valori sono successivi nella sequenza. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.Rewind(System.Int64)">
      <summary vsli:raw="Moves the reader back the specified number of items.">Sposta il lettore indietro del numero specificato di elementi.</summary>
      <param name="count" vsli:raw="The number of items.">Numero di elementi.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;count&quot; /&gt; is negative or greater than &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Consumed&quot; /&gt;.">
        <paramref name="count" /> è negativo o maggiore di <see cref="P:System.Buffers.SequenceReader`1.Consumed" />.</exception>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryAdvanceTo(`0,System.Boolean)">
      <summary vsli:raw="Searches for a specified delimiter and optionally advances past it if it is found.">Cerca un delimitatore specificato e facoltativamente avanza oltre se viene trovato.</summary>
      <param name="delimiter" vsli:raw="The delimiter to search for.">Il delimitatore da cercare.</param>
      <param name="advancePastDelimiter" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the &lt;paramref name=&quot;delimiter&quot; /&gt; if it is found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> per superare l'oggetto <paramref name="delimiter" /> se viene trovato; in caso contrario, <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the given &lt;paramref name=&quot;delimiter&quot; /&gt; was found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'oggetto <paramref name="delimiter" /> specificato viene trovato; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryAdvanceToAny(System.ReadOnlySpan{`0},System.Boolean)">
      <summary vsli:raw="Searches for any of a number of specified delimiters and optionally advances past the first one to be found.">Cerca i delimitatori compresi in una serie di delimitatori specificati e facoltativamente avanza oltre il primo da trovare.</summary>
      <param name="delimiters" vsli:raw="The delimiters to search for.">I delimitatori da cercare.</param>
      <param name="advancePastDelimiter" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the first instance of any of the given &lt;paramref name=&quot;delimiters&quot; /&gt;; &lt;see langword=&quot;false&quot; /&gt; to not move past the delimiter.">
        <see langword="true" /> per spostarsi oltre la prima istanza di uno qualsiasi degli oggetti <paramref name="delimiters" /> specificati. <see langword="false" /> per non sposarsi oltre il delimitatore.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if any of the given &lt;paramref name=&quot;delimiters&quot; /&gt; was found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se viene trovato uno dei <paramref name="delimiters" /> specificati. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryCopyTo(System.Span{`0})">
      <summary vsli:raw="Copies data from the current position to the given destination span if there is enough data to fill it.">Copia i dati dalla posizione corrente nell'intervallo di destinazione specificato se sono disponibili dati sufficienti per riempirlo.</summary>
      <param name="destination" vsli:raw="Destination span to copy to.">Intervallo di destinazione in cui eseguire la copia.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if there is enough data to completely fill the &lt;paramref name=&quot;destination&quot; /&gt; span; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se sono disponibili dati sufficienti per riempire completamente l'intervallo <paramref name="destination" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryPeek(`0@)">
      <summary vsli:raw="Peeks at the next value without advancing the reader.">Visualizza il valore successivo senza far avanzare il lettore.</summary>
      <param name="value" vsli:raw="The next value, or the default value if at the end of the reader.">Il valore successivo o il valore predefinito se alla fine del lettore.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the reader is not at its end and the peek operation succeeded; &lt;see langword=&quot;false&quot; /&gt; if at the end of the reader.">
        <see langword="true" /> se il lettore non è alla fine e l'operazione di visualizzazione è riuscita; <see langword="false" /> se si è alla fine del lettore.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryPeek(System.Int64,`0@)">
      <summary vsli:raw="Peeks at the next value at the specified offset without advancing the reader.">Visualizza il valore successivo in corrispondenza dell'offset specificato senza far avanzare il lettore.</summary>
      <param name="offset" vsli:raw="The offset from current position.">Offset dalla posizione corrente.</param>
      <param name="value" vsli:raw="The next value, or the default value if at the end of the reader.">Il valore successivo o il valore predefinito se alla fine del lettore.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the reader is not at its end and the peek operation succeeded; &lt;see langword=&quot;false&quot; /&gt; if at the end of the reader.">
        <see langword="true" /> se il lettore non è alla fine e l'operazione di visualizzazione è riuscita; <see langword="false" /> se si è alla fine del lettore.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryRead(`0@)">
      <summary vsli:raw="Reads the next value and advance the reader.">Legge il valore successivo e fa avanzare il lettore.</summary>
      <param name="value" vsli:raw="The next value, or the default value if at the end of the reader.">Il valore successivo o il valore predefinito se alla fine del lettore.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the reader is not at its end and the read operation succeeded; &lt;see langword=&quot;false&quot; /&gt; if at the end of the reader.">
        <see langword="true" /> se il lettore non è alla fine e l'operazione di lettura è riuscita; <see langword="false" /> se si è alla fine del lettore.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.Buffers.ReadOnlySequence{`0}@,`0,`0,System.Boolean)">
      <summary vsli:raw="Tries to read everything up to the given &lt;paramref name=&quot;delimiter&quot; /&gt;, ignoring delimiters that are preceded by &lt;paramref name=&quot;delimiterEscape&quot; /&gt;.">Prova a leggere tutto fino all'oggetto <paramref name="delimiter" /> specificato, ignorando i delimitatori preceduti da <paramref name="delimiterEscape" />.</summary>
      <param name="sequence" vsli:raw="When the method returns, contains the data read, if any.">Quando il metodo viene restituito, contiene i dati letti, se presenti.</param>
      <param name="delimiter" vsli:raw="The delimiter to look for.">Il delimitatore da cercare.</param>
      <param name="delimiterEscape" vsli:raw="A value that indicates that an immediately following &lt;paramref name=&quot;delimiter&quot; /&gt; is to be skipped.">Un valore che indica che un oggetto <paramref name="delimiter" /> immediatamente seguente deve essere ignorato.</param>
      <param name="advancePastDelimiter" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the &lt;paramref name=&quot;delimiter&quot; /&gt; if found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> per spostarsi oltre il <paramref name="delimiter" /> se viene trovato. In caso contrario, <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;paramref name=&quot;delimiter&quot; /&gt; was found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'oggetto <paramref name="delimiter" /> viene trovato; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.Buffers.ReadOnlySequence{`0}@,`0,System.Boolean)">
      <summary vsli:raw="Tries to read everything up to the given &lt;paramref name=&quot;delimiter&quot; /&gt;.">Prova a leggere tutto fino all'oggetto <paramref name="delimiter" /> specificato.</summary>
      <param name="sequence" vsli:raw="When the method returns, contains the data read, if any.">Quando il metodo viene restituito, contiene i dati letti, se presenti.</param>
      <param name="delimiter" vsli:raw="The delimiter to look for.">Il delimitatore da cercare.</param>
      <param name="advancePastDelimiter" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the &lt;paramref name=&quot;delimiter&quot; /&gt; if found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> per spostarsi oltre il <paramref name="delimiter" /> se viene trovato. In caso contrario, <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;paramref name=&quot;delimiter&quot; /&gt; was found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'oggetto <paramref name="delimiter" /> viene trovato; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.Buffers.ReadOnlySequence{`0}@,System.ReadOnlySpan{`0},System.Boolean)">
      <summary vsli:raw="Tries to read data until the entire delimiter specified as a read-only span matches.">Prova a leggere i dati finché l'intero delimitatore specificato come intervallo di sola lettura corrisponde.</summary>
      <param name="sequence" vsli:raw="When the method returns, contains the data read, if any.">Quando il metodo viene restituito, contiene i dati letti, se presenti.</param>
      <param name="delimiter" vsli:raw="A read-only span that contains one or more delimiters.">Un intervallo di sola lettura contenente uno o più delimitatori.</param>
      <param name="advancePastDelimiter" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the &lt;paramref name=&quot;delimiter&quot; /&gt; if found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> per spostarsi oltre il <paramref name="delimiter" /> se viene trovato. In caso contrario, <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;paramref name=&quot;delimiter&quot; /&gt; was found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'oggetto <paramref name="delimiter" /> viene trovato; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.ReadOnlySpan{`0}@,`0,`0,System.Boolean)">
      <summary vsli:raw="Tries to read everything up to the given &lt;paramref name=&quot;delimiter&quot; /&gt;, ignoring delimiters that are preceded by &lt;paramref name=&quot;delimiterEscape&quot; /&gt;.">Prova a leggere tutto fino all'oggetto <paramref name="delimiter" /> specificato, ignorando i delimitatori preceduti da <paramref name="delimiterEscape" />.</summary>
      <param name="span" vsli:raw="When the method returns, contains the data read, if any.">Quando il metodo viene restituito, contiene i dati letti, se presenti.</param>
      <param name="delimiter" vsli:raw="The delimiter to look for.">Il delimitatore da cercare.</param>
      <param name="delimiterEscape" vsli:raw="A value that indicates that an immediately following &lt;paramref name=&quot;delimiter&quot; /&gt; is to be skipped.">Un valore che indica che un oggetto <paramref name="delimiter" /> immediatamente seguente deve essere ignorato.</param>
      <param name="advancePastDelimiter" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the &lt;paramref name=&quot;delimiter&quot; /&gt; if found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> per spostarsi oltre il <paramref name="delimiter" /> se viene trovato. In caso contrario, <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;paramref name=&quot;delimiter&quot; /&gt; was found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'oggetto <paramref name="delimiter" /> viene trovato; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.ReadOnlySpan{`0}@,`0,System.Boolean)">
      <summary vsli:raw="Tries to read everything up to the given &lt;paramref name=&quot;delimiter&quot; /&gt;.">Prova a leggere tutto fino all'oggetto <paramref name="delimiter" /> specificato.</summary>
      <param name="span" vsli:raw="When the method returns, contains the data read, if any.">Quando il metodo viene restituito, contiene i dati letti, se presenti.</param>
      <param name="delimiter" vsli:raw="The delimiter to look for.">Il delimitatore da cercare.</param>
      <param name="advancePastDelimiter" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the &lt;paramref name=&quot;delimiter&quot; /&gt; if found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> per spostarsi oltre il <paramref name="delimiter" /> se viene trovato. In caso contrario, <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;paramref name=&quot;delimiter&quot; /&gt; was found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'oggetto <paramref name="delimiter" /> viene trovato; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.ReadOnlySpan{`0}@,System.ReadOnlySpan{`0},System.Boolean)">
      <summary vsli:raw="Try to read everything up to the given &lt;paramref name=&quot;delimiter&quot; /&gt;.">Prova a leggere tutto fino all'oggetto <paramref name="delimiter" /> specificato.</summary>
      <param name="sequence" vsli:raw="The read data, if any.">Gli eventuali dati letti.</param>
      <param name="delimiter" vsli:raw="The delimiter to look for.">Il delimitatore da cercare.</param>
      <param name="advancePastDelimiter" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the &lt;paramref name=&quot;delimiter&quot; /&gt; if found.">
        <see langword="true" /> per superare l'oggetto <paramref name="delimiter" />, se trovato.</param>
      <param name="span" vsli:raw="The read data, if any.">Gli eventuali dati letti.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;paramref name=&quot;delimiter&quot; /&gt; was found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'oggetto <paramref name="delimiter" /> viene trovato; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadToAny(System.Buffers.ReadOnlySequence{`0}@,System.ReadOnlySpan{`0},System.Boolean)">
      <summary vsli:raw="Tries to read everything up to any of the specified &lt;paramref name=&quot;delimiters&quot; /&gt;.">Prova a leggere tutto fino a uno qualsiasi degli oggetti <paramref name="delimiters" /> specificati.</summary>
      <param name="sequence" vsli:raw="When the method returns, contains the data read, if any.">Quando il metodo viene restituito, contiene i dati letti, se presenti.</param>
      <param name="delimiters" vsli:raw="The delimiters to look for.">I delimitatori da cercare.</param>
      <param name="advancePastDelimiter" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the first found instance of any of the given &lt;paramref name=&quot;delimiters&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> per spostarsi oltre la prima istanza trovata di uno qualsiasi dei <paramref name="delimiters" /> specificati. In caso contrario <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if any of the &lt;paramref name=&quot;delimiters&quot; /&gt; were found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se uno qualsiasi degli oggetti <paramref name="delimiters" /> viene trovato; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadToAny(System.ReadOnlySpan{`0}@,System.ReadOnlySpan{`0},System.Boolean)">
      <summary vsli:raw="Tries to read everything up to any of the specified &lt;paramref name=&quot;delimiters&quot; /&gt;.">Prova a leggere tutto fino a uno qualsiasi degli oggetti <paramref name="delimiters" /> specificati.</summary>
      <param name="span" vsli:raw="When the method returns, contains the data read, if any.">Quando il metodo viene restituito, contiene i dati letti, se presenti.</param>
      <param name="delimiters" vsli:raw="The delimiters to look for.">I delimitatori da cercare.</param>
      <param name="advancePastDelimiter" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the first found instance of any of the given &lt;paramref name=&quot;delimiters&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> per spostarsi oltre la prima istanza trovata di uno qualsiasi dei <paramref name="delimiters" /> specificati. In caso contrario <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if any of the &lt;paramref name=&quot;delimiters&quot; /&gt; were found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se uno qualsiasi degli oggetti <paramref name="delimiters" /> viene trovato; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Consumed">
      <summary vsli:raw="Gets the total number of &lt;typeparamref name=&quot;T&quot; /&gt; values processed by the reader.">Ottiene il numero totale di valori <typeparamref name="T" /> elaborati dal lettore.</summary>
      <returns vsli:raw="The total number of values processed by the reader.">Numero totale di valori elaborati dal reader.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.CurrentSpan">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Span`1&quot; /&gt; that contains the current segment in the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;.">Ottiene un oggetto <see cref="T:System.Span`1" /> contenente il segmento corrente in <see cref="P:System.Buffers.SequenceReader`1.Sequence" />.</summary>
      <returns vsli:raw="A span that contains the current segment in the sequence.">Intervallo che contiene il segmento corrente nella sequenza.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.CurrentSpanIndex">
      <summary vsli:raw="Gets the index in the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.CurrentSpan&quot; /&gt;.">Ottiene l'indice in <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" />.</summary>
      <returns vsli:raw="The index in the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.CurrentSpan&quot; /&gt;.">Indice nell'oggetto <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" /> .</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.End">
      <summary vsli:raw="Gets a value that indicates whether there is no more data in the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;.">Ottiene un valore che indica se non sono presenti altri dati in <see cref="P:System.Buffers.SequenceReader`1.Sequence" />.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; when there is no more data in the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> Quando non sono presenti altri dati nell'oggetto <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> ; in caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Length">
      <summary vsli:raw="Gets the count of items in the reader's &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;.">Ottiene il numero di elementi presenti nell'oggetto <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> del lettore.</summary>
      <returns vsli:raw="The count of items in the reader's &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;.">Numero di elementi nell'oggetto del Reader <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> .</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Position">
      <summary vsli:raw="Gets the current position in the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;.">Ottiene la posizione corrente in <see cref="P:System.Buffers.SequenceReader`1.Sequence" />.</summary>
      <returns vsli:raw="The current position in the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;.">Posizione corrente nell'oggetto <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> .</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Remaining">
      <summary vsli:raw="Gets  the remaining items in the reader's &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;.">Ottiene gli elementi rimanenti nell'oggetto <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> del lettore.</summary>
      <returns vsli:raw="The remaining items in the reader's &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;">Gli elementi rimanenti nel lettore <see cref="P:System.Buffers.SequenceReader`1.Sequence" /></returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Sequence">
      <summary vsli:raw="Gets the underlying &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; for the reader.">Ottiene l'oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" /> sottostante per il lettore.</summary>
      <returns vsli:raw="The underlying read-only sequence for the reader.">Sequenza di sola lettura sottostante per il lettore.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.UnreadSequence">
      <summary vsli:raw="Gets the unread portion of the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;.">Ottiene la parte non letta di <see cref="P:System.Buffers.SequenceReader`1.Sequence" />.</summary>
      <returns vsli:raw="The unread portion of the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;.">Parte non letta dell'oggetto <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> .</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.UnreadSpan">
      <summary vsli:raw="Gets the unread portion of the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.CurrentSpan&quot; /&gt;.">Ottiene la parte non letta di <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" />.</summary>
      <returns vsli:raw="The unread portion of the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.CurrentSpan&quot; /&gt;.">Parte non letta dell'oggetto <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" /> .</returns>
    </member>
    <member name="T:System.Buffers.SequenceReaderExtensions">
      <summary vsli:raw="Provides extended functionality for the &lt;see cref=&quot;T:System.Buffers.SequenceReader`1&quot; /&gt; class that allows reading of endian specific numeric values from binary data.">Fornisce funzionalità estese per la classe <see cref="T:System.Buffers.SequenceReader`1" /> che consentono la lettura di valori numerici specifici endian da dati binari.</summary>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadBigEndian(System.Buffers.SequenceReader{System.Byte},System.Int16@)">
      <summary vsli:raw="Tries to read an &lt;see cref=&quot;T:System.Int16&quot; /&gt; as big endian.">Tenta di leggere un valore <see cref="T:System.Int16" /> come big endian.</summary>
      <param name="reader" vsli:raw="The byte sequence reader instance from which the value is to be read.">Istanza del lettore della sequenza di byte da cui deve essere letto il valore.</param>
      <param name="value" vsli:raw="When the method returns, the value read out of the byte sequence reader, as big endian.">Al termine del metodo, il valore letto dal lettore della sequenza di byte, come big endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the read operation is successful; &lt;see langword=&quot;false&quot; /&gt; if there isn't enough data for an &lt;see cref=&quot;T:System.Int16&quot; /&gt;.">
        <see langword="true" /> se l'operazione di lettura ha esito positivo; <see langword="false" /> se non ci sono dati sufficienti per <see cref="T:System.Int16" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadBigEndian(System.Buffers.SequenceReader{System.Byte},System.Int32@)">
      <summary vsli:raw="Tries to read an &lt;see cref=&quot;T:System.Int32&quot; /&gt; as big endian.">Tenta di leggere un valore <see cref="T:System.Int32" /> come big endian.</summary>
      <param name="reader" vsli:raw="The byte sequence reader from which to read the value.">Lettore della sequenza di byte da cui leggere il valore.</param>
      <param name="value" vsli:raw="When the method returns, the value read out of the byte sequence reader, as big endian.">Al termine del metodo, il valore letto dal lettore della sequenza di byte, come big endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the read operation is successful; &lt;see langword=&quot;false&quot; /&gt; if there isn't enough data for an &lt;see cref=&quot;T:System.Int32&quot; /&gt;.">
        <see langword="true" /> se l'operazione di lettura ha esito positivo; <see langword="false" /> se non ci sono dati sufficienti per <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadBigEndian(System.Buffers.SequenceReader{System.Byte},System.Int64@)">
      <summary vsli:raw="Tries to read an &lt;see cref=&quot;T:System.Int64&quot; /&gt; as big endian.">Tenta di leggere un valore <see cref="T:System.Int64" /> come big endian.</summary>
      <param name="reader" vsli:raw="The byte sequence reader instance from which the value is to be read.">Istanza del lettore della sequenza di byte da cui deve essere letto il valore.</param>
      <param name="value" vsli:raw="When the method returns, the value read out of the byte sequence reader, as big endian.">Al termine del metodo, il valore letto dal lettore della sequenza di byte, come big endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the read operation is successful; &lt;see langword=&quot;false&quot; /&gt; if there isn't enough data for an &lt;see cref=&quot;T:System.Int64&quot; /&gt;.">
        <see langword="true" /> se l'operazione di lettura ha esito positivo; <see langword="false" /> se non ci sono dati sufficienti per <see cref="T:System.Int64" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadLittleEndian(System.Buffers.SequenceReader{System.Byte},System.Int16@)">
      <summary vsli:raw="Tries to read an &lt;see cref=&quot;T:System.Int16&quot; /&gt; as little endian.">Tenta di leggere un valore <see cref="T:System.Int16" /> come little endian.</summary>
      <param name="reader" vsli:raw="The byte sequence reader instance from which the value is to be read.">Istanza del lettore della sequenza di byte da cui deve essere letto il valore.</param>
      <param name="value" vsli:raw="When the method returns, the value read out of the byte sequence reader, as little endian.">Al termine del metodo, il valore letto dal lettore della sequenza di byte, come little endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the read operation is successful; &lt;see langword=&quot;false&quot; /&gt; if there isn't enough data for an &lt;see cref=&quot;T:System.Int16&quot; /&gt;.">
        <see langword="true" /> se l'operazione di lettura ha esito positivo; <see langword="false" /> se non ci sono dati sufficienti per <see cref="T:System.Int16" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadLittleEndian(System.Buffers.SequenceReader{System.Byte},System.Int32@)">
      <summary vsli:raw="Tries to read an &lt;see cref=&quot;T:System.Int32&quot; /&gt; as little endian.">Tenta di leggere un valore <see cref="T:System.Int32" /> come little endian.</summary>
      <param name="reader" vsli:raw="The byte sequence reader instance from which the value is to be read.">Istanza del lettore della sequenza di byte da cui deve essere letto il valore.</param>
      <param name="value" vsli:raw="When the method returns, the value read out of the byte sequence reader, as little endian.">Al termine del metodo, il valore letto dal lettore della sequenza di byte, come little endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the read operation is successful; &lt;see langword=&quot;false&quot; /&gt; if there isn't enough data for an &lt;see cref=&quot;T:System.Int32&quot; /&gt;.">
        <see langword="true" /> se l'operazione di lettura ha esito positivo; <see langword="false" /> se non ci sono dati sufficienti per <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadLittleEndian(System.Buffers.SequenceReader{System.Byte},System.Int64@)">
      <summary vsli:raw="Tries to read an &lt;see cref=&quot;T:System.Int64&quot; /&gt; as little endian.">Tenta di leggere un valore <see cref="T:System.Int64" /> come little endian.</summary>
      <param name="reader" vsli:raw="The byte sequence reader instance from which the value is to be read.">Istanza del lettore della sequenza di byte da cui deve essere letto il valore.</param>
      <param name="value" vsli:raw="When the method returns, the value read out of the byte sequence reader, as little endian.">Al termine del metodo, il valore letto dal lettore della sequenza di byte, come little endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the read operation is successful; &lt;see langword=&quot;false&quot; /&gt; if there isn't enough data for an &lt;see cref=&quot;T:System.Int64&quot; /&gt;.">
        <see langword="true" /> se l'operazione di lettura ha esito positivo; <see langword="false" /> se non ci sono dati sufficienti per <see cref="T:System.Int64" />.</returns>
    </member>
    <member name="T:System.Buffers.StandardFormat">
      <summary vsli:raw="Represents a standard format string without using an actual string.">Rappresenta una stringa in formato standard senza usare una stringa effettiva.</summary>
    </member>
    <member name="F:System.Buffers.StandardFormat.MaxPrecision">
      <summary vsli:raw="Defines the maximum valid precision value.">Definisce il valore di precisione valido massimo.</summary>
    </member>
    <member name="F:System.Buffers.StandardFormat.NoPrecision">
      <summary vsli:raw="Indicates that a format doesn't use a precision or that the precision is unspecified.">Indica che un formato non usa una precisione o che la precisione non è specificata.</summary>
    </member>
    <member name="M:System.Buffers.StandardFormat.#ctor(System.Char,System.Byte)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; structure.">Inizializza una nuova istanza della struttura <see cref="T:System.Buffers.StandardFormat" />.</summary>
      <param name="symbol" vsli:raw="A type-specific format specifier, such as 'G', 'D', or 'X'.">Identificatore di formato specifico del tipo, ad esempio 'G', 'D' o 'X'.</param>
      <param name="precision" vsli:raw="An optional precision ranging from 0 to 99, or the special value &lt;see cref=&quot;F:System.Buffers.StandardFormat.NoPrecision&quot; /&gt; (the default).">Valore di precisione facoltativo compreso tra 0 e 99 oppure il valore speciale <see cref="F:System.Buffers.StandardFormat.NoPrecision" /> (predefinito).</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;symbol&quot; /&gt; is not &lt;see cref=&quot;F:System.Buffers.StandardFormat.NoPrecision&quot; /&gt;, and its value is greater than &lt;see cref=&quot;F:System.Buffers.StandardFormat.MaxPrecision&quot; /&gt;.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;symbol&quot; /&gt; cannot be converted to a &lt;see cref=&quot;T:System.Byte&quot; /&gt;.">
        <paramref name="symbol" /> non è <see cref="F:System.Buffers.StandardFormat.NoPrecision" /> e il relativo valore è maggiore di <see cref="F:System.Buffers.StandardFormat.MaxPrecision" />.

-oppure-

L'elemento <paramref name="symbol" /> non può essere convertito in <see cref="T:System.Byte" />.</exception>
    </member>
    <member name="M:System.Buffers.StandardFormat.Equals(System.Buffers.StandardFormat)">
      <summary vsli:raw="Returns a value that indicates whether the specified &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; is equal to the current instance.">Restituisce un valore che indica se l'oggetto <see cref="T:System.Buffers.StandardFormat" /> specificato è uguale all'istanza corrente.</summary>
      <param name="other" vsli:raw="The format to compare to the current instance.">Formato da confrontare con l'istanza corrente.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two instances are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se le due istanze sono uguali, in caso contrario <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.Equals(System.Object)">
      <summary vsli:raw="Returns a value that indicates whether the specified object is a &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; object that is equal to the current instance.">Restituisce un valore che indica se l'oggetto specificato è un oggetto <see cref="T:System.Buffers.StandardFormat" /> uguale all'istanza corrente.</summary>
      <param name="obj" vsli:raw="An object to compare to the current instance.">Oggetto da confrontare con l'istanza corrente.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two instances are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se le due istanze sono uguali, in caso contrario <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.GetHashCode">
      <summary vsli:raw="Returns the hash code for this instance.">Restituisce il codice hash per l'istanza.</summary>
      <returns vsli:raw="The hash code for this instance.">Codice hash per l'istanza.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.op_Equality(System.Buffers.StandardFormat,System.Buffers.StandardFormat)">
      <summary vsli:raw="Returns a value that indicates whether two &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; instances are equal.">Restituisce un valore che indica se due istanze di <see cref="T:System.Buffers.StandardFormat" /> sono uguali.</summary>
      <param name="left" vsli:raw="The first format to compare.">Primo formato da confrontare.</param>
      <param name="right" vsli:raw="The second format to compare.">Secondo formato da confrontare.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two instances are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se le due istanze sono uguali, in caso contrario <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.op_Implicit(System.Char)~System.Buffers.StandardFormat">
      <summary vsli:raw="Converts a character to a &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; instance using &lt;see cref=&quot;F:System.Buffers.StandardFormat.NoPrecision&quot; /&gt; precision.">Converte un carattere in un'istanza di <see cref="T:System.Buffers.StandardFormat" /> con la precisione <see cref="F:System.Buffers.StandardFormat.NoPrecision" />.</summary>
      <param name="symbol" vsli:raw="The character to convert to a &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; value.">Carattere da convertire in un valore <see cref="T:System.Buffers.StandardFormat" />.</param>
      <returns vsli:raw="A format with a &lt;see cref=&quot;P:System.Buffers.StandardFormat.Symbol&quot; /&gt; property equal to &lt;paramref name=&quot;symbol&quot; /&gt; and a &lt;see cref=&quot;P:System.Buffers.StandardFormat.Precision&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Buffers.StandardFormat.NoPrecision&quot; /&gt;.">Formato con una proprietà <see cref="P:System.Buffers.StandardFormat.Symbol" /> uguale a <paramref name="symbol" /> e una proprietà <see cref="P:System.Buffers.StandardFormat.Precision" /> uguale a <see cref="F:System.Buffers.StandardFormat.NoPrecision" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.op_Inequality(System.Buffers.StandardFormat,System.Buffers.StandardFormat)">
      <summary vsli:raw="Determines whether two &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; instances are unequal.">Determina se due istanze di <see cref="T:System.Buffers.StandardFormat" /> sono diverse.</summary>
      <param name="left" vsli:raw="The first format to compare.">Primo formato da confrontare.</param>
      <param name="right" vsli:raw="The second format to compare.">Secondo formato da confrontare.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two formats are unequal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se i due formati sono diversi. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.Parse(System.ReadOnlySpan{System.Char})">
      <summary vsli:raw="Converts a &lt;see langword=&quot;ReadOnlySpan&amp;lt;System.Char&amp;gt;&quot; /&gt; into a &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; instance using &lt;see cref=&quot;F:System.Buffers.StandardFormat.NoPrecision&quot; /&gt; precision.">Converte un <see langword="ReadOnlySpan&lt;System.Char&gt;" /> in un'istanza di <see cref="T:System.Buffers.StandardFormat" /> con la precisione <see cref="F:System.Buffers.StandardFormat.NoPrecision" />.</summary>
      <param name="format" vsli:raw="A read-only span that contains the character to parse.">Estensione di sola lettura che contiene il carattere da analizzare.</param>
      <returns vsli:raw="A value whose &lt;see cref=&quot;P:System.Buffers.StandardFormat.Symbol&quot; /&gt; property value is the character in &lt;paramref name=&quot;format&quot; /&gt; and whose &lt;see cref=&quot;P:System.Buffers.StandardFormat.Precision&quot; /&gt; property value is &lt;see cref=&quot;F:System.Buffers.StandardFormat.NoPrecision&quot; /&gt;.">Valore il cui valore della proprietà <see cref="P:System.Buffers.StandardFormat.Symbol" /> è il carattere in <paramref name="format" /> e il cui valore della proprietà <see cref="P:System.Buffers.StandardFormat.Precision" /> è <see cref="F:System.Buffers.StandardFormat.NoPrecision" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.Parse(System.String)">
      <summary vsli:raw="Converts a classic .NET standard format string to a &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; instance.">Converte una stringa di formato standard .NET classica in un'istanza di <see cref="T:System.Buffers.StandardFormat" />.</summary>
      <param name="format" vsli:raw="A classic .NET standard format string.">Stringa di formato standard .NET classica.</param>
      <exception cref="T:System.FormatException" vsli:raw="&lt;paramref name=&quot;format&quot; /&gt; is not a valid standard format string.">
        <paramref name="format" /> non è una stringa in formato standard valido.</exception>
      <returns vsli:raw="A format.">Formato.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.ToString">
      <summary vsli:raw="Returns the string representation of this format.">Restituisce la rappresentazione di stringa di questo formato.</summary>
      <returns vsli:raw="The string representation of this format.">Rappresentazione di stringa di questo formato.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.TryParse(System.ReadOnlySpan{System.Char},System.Buffers.StandardFormat@)">
      <summary vsli:raw="Attempts to convert a &lt;see langword=&quot;ReadOnlySpan&amp;lt;Char&amp;gt;&quot; /&gt; to a &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; instance and returns a value that indicates whether the parsing operation succeeded.">Tenta di convertire un <see langword="ReadOnlySpan&lt;Char&gt;" /> in un'istanza di <see cref="T:System.Buffers.StandardFormat" /> e restituisce un valore che indica se l'operazione di analisi ha avuto esito positivo.</summary>
      <param name="format" vsli:raw="A read-only span that contains the character to convert.">Estensione di sola lettura che contiene il carattere da convertire.</param>
      <param name="result" vsli:raw="When the method returns, contains the parsed &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; instance if the operation was successful.">Quando questo metodo termina, contiene l'istanza di <see cref="T:System.Buffers.StandardFormat" /> analizzata se l'operazione è stata completata correttamente.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the parsing operation was successful; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'operazione di analisi ha avuto esito positivo. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Buffers.StandardFormat.HasPrecision">
      <summary vsli:raw="Gets a value that indicates whether a format has a defined precision.">Ottiene un valore che indica se un formato ha una precisione definita.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the format has a precision other than &lt;see cref=&quot;F:System.Buffers.StandardFormat.NoPrecision&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> Se il formato ha una precisione diversa da <see cref="F:System.Buffers.StandardFormat.NoPrecision" /> ; in caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Buffers.StandardFormat.IsDefault">
      <summary vsli:raw="Gets a value that indicates whether the current instance is a default format.">Ottiene un valore che indica se l'istanza corrente è un formato predefinito.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current instance is a default format; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> Se l'istanza corrente è un formato predefinito. in caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Buffers.StandardFormat.Precision">
      <summary vsli:raw="Gets the precision component of the format.">Ottiene il componente di precisione del formato.</summary>
      <returns vsli:raw="The precision component, which can be &lt;see cref=&quot;F:System.Buffers.StandardFormat.NoPrecision&quot; /&gt;, or can range from 0 to 9.">Componente di precisione, che può essere <see cref="F:System.Buffers.StandardFormat.NoPrecision" /> o può variare da 0 a 9.</returns>
    </member>
    <member name="P:System.Buffers.StandardFormat.Symbol">
      <summary vsli:raw="Gets the character component of the format.">Ottiene il componente di carattere del formato.</summary>
      <returns vsli:raw="The character component of the format.">Componente carattere del formato.</returns>
    </member>
    <member name="T:System.Buffers.Text.Base64">
      <summary>Esegue la conversione tra dati binari e testo con codifica UTF-8 rappresentato in base 64.</summary>
    </member>
    <member name="M:System.Buffers.Text.Base64.DecodeFromUtf8(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@,System.Int32@,System.Boolean)">
      <summary>Decodifica in dati binari l'intervallo di testo con codifica UTF-8 rappresentato come base 64. Se l'input non è un multiplo di 4, decodificherà quanto è possibile fino al multiplo di 4 più vicino.</summary>
      <param name="utf8">Intervallo di input che contiene testo con codifica UTF-8 in base 64 che deve essere decodificato.</param>
      <param name="bytes">Intervallo di output che contiene il risultato dell'operazione, vale a dire i dati binari decodificati.</param>
      <param name="bytesConsumed">Numero di byte di input utilizzati durante l'operazione. Può essere usato per sezionare l'input per le chiamate successive, se necessario.</param>
      <param name="bytesWritten">Numero di byte scritti nell'intervallo di output. Può essere usato per sezionare l'output per le chiamate successive, se necessario.</param>
      <param name="isFinalBlock">
        <see langword="true" /> (impostazione predefinita) se l'intervallo di input contiene tutti i dati da decodificare. <see langword="false" /> se l'intervallo di input contiene dati parziali e seguono altri dati.</param>
      <returns>Uno dei valori di enumerazione indicante lo stato dell'operazione di decodifica.</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.DecodeFromUtf8InPlace(System.Span{System.Byte},System.Int32@)">
      <summary>Decodifica in dati binari l'intervallo di testo con codifica UTF-8 in base 64 (sul posto). L'output binario decodificato è più piccolo rispetto ai dati di testo contenuti nell'input (l'operazione comprime i dati). Se l'input non è un multiplo di 4, il metodo non decodificherà i dati.</summary>
      <param name="buffer">L'intervallo di input che contiene i dati di testo in base 64 che devono essere decodificati.</param>
      <param name="bytesWritten">Numero di byte scritti nel buffer.</param>
      <returns>Uno dei valori di enumerazione indicante lo stato dell'operazione di decodifica.</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.EncodeToUtf8(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@,System.Int32@,System.Boolean)">
      <summary>Codifica l'intervallo di dati binari in testo con codifica UTF-8 rappresentato come base 64.</summary>
      <param name="bytes">Intervallo di input che contiene i dati binari che devono essere codificati.</param>
      <param name="utf8">Intervallo di output che contiene il risultato dell'operazione, vale a dire il testo con codifica UTF-8 in base 64.</param>
      <param name="bytesConsumed">Numero di byte di input utilizzati durante l'operazione. Può essere usato per sezionare l'input per le chiamate successive, se necessario.</param>
      <param name="bytesWritten">Numero di byte scritti nell'intervallo di output. Può essere usato per sezionare l'output per le chiamate successive, se necessario.</param>
      <param name="isFinalBlock">
        <see langword="true" /> (impostazione predefinita) se l'intervallo di input contiene tutti i dati da codificare. <see langword="false" /> se l'intervallo di input contiene dati parziali e seguono altri dati.</param>
      <returns>Uno dei valori di enumerazione indicante lo stato dell'operazione di codifica.</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.EncodeToUtf8InPlace(System.Span{System.Byte},System.Int32,System.Int32@)">
      <summary>Codifica l'intervallo di dati binari (sul posto) in testo con codifica UTF-8 rappresentato come base 64. L'output di testo codificato è più grande rispetto ai dati binari contenuti nell'input (l'operazione incrementa i dati).</summary>
      <param name="buffer">Intervallo di input che contiene i dati binari che devono essere codificati. Poiché il metodo esegue una conversione sul posto, deve essere di dimensioni sufficienti per archiviare il risultato dell'operazione.</param>
      <param name="dataLength">Numero di byte di dati binari contenuti all'interno del buffer che deve essere codificato. Questo valore deve essere minore rispetto alla lunghezza del buffer.</param>
      <param name="bytesWritten">Numero di byte scritti nel buffer.</param>
      <returns>Uno dei valori di enumerazione indicante lo stato dell'operazione di codifica.</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.GetMaxDecodedFromUtf8Length(System.Int32)">
      <summary>Restituisce la lunghezza massima (in byte) del risultato, se fosse necessario decodificare il testo con codifica base 64 entro un intervallo di byte con la lunghezza specificata.</summary>
      <param name="length">Dimensioni dell'intervallo di byte.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" /> è minore di 0.</exception>
      <returns>Lunghezza massima (in byte) del risultato.</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.GetMaxEncodedToUtf8Length(System.Int32)">
      <summary>Restituisce la lunghezza massima (in byte) del risultato, se fosse necessario codificare dati binari entro un intervallo di byte con la lunghezza specificata.</summary>
      <param name="length">Dimensioni dell'intervallo di byte.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" /> è minore di 0 o maggiore di 1610612733 (perché la codifica incrementa i dati di 4/3).</exception>
      <returns>Lunghezza massima (in byte) del risultato.</returns>
    </member>
    <member name="T:System.Buffers.Text.Utf8Formatter">
      <summary vsli:raw="Provides static methods to format common data types as Utf8 strings.">Fornisce metodi statici per formattare i tipi di dati comuni come stringhe Utf8.</summary>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Boolean,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.Boolean&quot; /&gt; as a UTF8 string.">Formatta un elemento <see cref="T:System.Boolean" /> come stringa UTF8.</summary>
      <param name="value" vsli:raw="The value to format.">Valore da formattare.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Buffer in cui scrivere il valore in formato UTF8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Quando il metodo restituisce un risultato, contiene la lunghezza del testo formattato in byte.</param>
      <param name="format" vsli:raw="The standard format to use.">Il formato standard da usare.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> se l'operazione di formattazione ha esito positivo, <see langword="false" /> se <paramref name="buffer" /> è troppo piccolo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Byte,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.Byte&quot; /&gt; as a UTF8 string.">Formatta un elemento <see cref="T:System.Byte" /> come stringa UTF8.</summary>
      <param name="value" vsli:raw="The value to format.">Valore da formattare.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Buffer in cui scrivere il valore in formato UTF8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Quando il metodo restituisce un risultato, contiene la lunghezza del testo formattato in byte.</param>
      <param name="format" vsli:raw="The standard format to use.">Il formato standard da usare.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> se l'operazione di formattazione ha esito positivo, <see langword="false" /> se <paramref name="buffer" /> è troppo piccolo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.DateTime,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.DateTime&quot; /&gt; as a UTF8 string.">Formatta un elemento <see cref="T:System.DateTime" /> come stringa UTF8.</summary>
      <param name="value" vsli:raw="The value to format.">Valore da formattare.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Buffer in cui scrivere il valore in formato UTF8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Quando il metodo restituisce un risultato, contiene la lunghezza del testo formattato in byte.</param>
      <param name="format" vsli:raw="The standard format to use.">Il formato standard da usare.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> se l'operazione di formattazione ha esito positivo, <see langword="false" /> se <paramref name="buffer" /> è troppo piccolo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.DateTimeOffset,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.DateTimeOffset&quot; /&gt; as a UTF8 string.">Formatta un elemento <see cref="T:System.DateTimeOffset" /> come stringa UTF8.</summary>
      <param name="value" vsli:raw="The value to format.">Valore da formattare.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Buffer in cui scrivere il valore in formato UTF8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Quando il metodo restituisce un risultato, contiene la lunghezza del testo formattato in byte.</param>
      <param name="format" vsli:raw="The standard format to use.">Il formato standard da usare.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> se l'operazione di formattazione ha esito positivo, <see langword="false" /> se <paramref name="buffer" /> è troppo piccolo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Decimal,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.Decimal&quot; /&gt; as a UTF8 string.">Formatta un elemento <see cref="T:System.Decimal" /> come stringa UTF8.</summary>
      <param name="value" vsli:raw="The value to format.">Valore da formattare.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Buffer in cui scrivere il valore in formato UTF8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Quando il metodo restituisce un risultato, contiene la lunghezza del testo formattato in byte.</param>
      <param name="format" vsli:raw="The standard format to use.">Il formato standard da usare.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> se l'operazione di formattazione ha esito positivo, <see langword="false" /> se <paramref name="buffer" /> è troppo piccolo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Double,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.Double&quot; /&gt; as a UTF8 string.">Formatta un elemento <see cref="T:System.Double" /> come stringa UTF8.</summary>
      <param name="value" vsli:raw="The value to format.">Valore da formattare.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Buffer in cui scrivere il valore in formato UTF8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Quando il metodo restituisce un risultato, contiene la lunghezza del testo formattato in byte.</param>
      <param name="format" vsli:raw="The standard format to use.">Il formato standard da usare.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> se l'operazione di formattazione ha esito positivo, <see langword="false" /> se <paramref name="buffer" /> è troppo piccolo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Guid,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.Guid&quot; /&gt; as a UTF8 string.">Formatta un elemento <see cref="T:System.Guid" /> come stringa UTF8.</summary>
      <param name="value" vsli:raw="The value to format.">Valore da formattare.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Buffer in cui scrivere il valore in formato UTF8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Quando il metodo restituisce un risultato, contiene la lunghezza del testo formattato in byte.</param>
      <param name="format" vsli:raw="The standard format to use.">Il formato standard da usare.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> se l'operazione di formattazione ha esito positivo, <see langword="false" /> se <paramref name="buffer" /> è troppo piccolo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Int16,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats an &lt;see cref=&quot;T:System.Int16&quot; /&gt; as a UTF8 string.">Formatta un elemento <see cref="T:System.Int16" /> come stringa UTF8.</summary>
      <param name="value" vsli:raw="The value to format.">Valore da formattare.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Buffer in cui scrivere il valore in formato UTF8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Quando il metodo restituisce un risultato, contiene la lunghezza del testo formattato in byte.</param>
      <param name="format" vsli:raw="The standard format to use.">Il formato standard da usare.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> se l'operazione di formattazione ha esito positivo, <see langword="false" /> se <paramref name="buffer" /> è troppo piccolo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Int32,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats an &lt;see cref=&quot;T:System.Int32&quot; /&gt; as a UTF8 string.">Formatta un elemento <see cref="T:System.Int32" /> come stringa UTF8.</summary>
      <param name="value" vsli:raw="The value to format.">Valore da formattare.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Buffer in cui scrivere il valore in formato UTF8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Quando il metodo restituisce un risultato, contiene la lunghezza del testo formattato in byte.</param>
      <param name="format" vsli:raw="The standard format to use.">Il formato standard da usare.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> se l'operazione di formattazione ha esito positivo, <see langword="false" /> se <paramref name="buffer" /> è troppo piccolo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Int64,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats an &lt;see cref=&quot;T:System.Int64&quot; /&gt; as a UTF8 string.">Formatta un elemento <see cref="T:System.Int64" /> come stringa UTF8.</summary>
      <param name="value" vsli:raw="The value to format.">Valore da formattare.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Buffer in cui scrivere il valore in formato UTF8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Quando il metodo restituisce un risultato, contiene la lunghezza del testo formattato in byte.</param>
      <param name="format" vsli:raw="The standard format to use.">Il formato standard da usare.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> se l'operazione di formattazione ha esito positivo, <see langword="false" /> se <paramref name="buffer" /> è troppo piccolo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.SByte,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats an &lt;see cref=&quot;T:System.SByte&quot; /&gt; as a UTF8 string.">Formatta un elemento <see cref="T:System.SByte" /> come stringa UTF8.</summary>
      <param name="value" vsli:raw="The value to format.">Valore da formattare.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Buffer in cui scrivere il valore in formato UTF8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Quando il metodo restituisce un risultato, contiene la lunghezza del testo formattato in byte.</param>
      <param name="format" vsli:raw="The standard format to use.">Il formato standard da usare.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> se l'operazione di formattazione ha esito positivo, <see langword="false" /> se <paramref name="buffer" /> è troppo piccolo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Single,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.Single&quot; /&gt; as a UTF8 string.">Formatta un elemento <see cref="T:System.Single" /> come stringa UTF8.</summary>
      <param name="value" vsli:raw="The value to format.">Valore da formattare.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Buffer in cui scrivere il valore in formato UTF8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Quando il metodo restituisce un risultato, contiene la lunghezza del testo formattato in byte.</param>
      <param name="format" vsli:raw="The standard format to use.">Il formato standard da usare.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> se l'operazione di formattazione ha esito positivo, <see langword="false" /> se <paramref name="buffer" /> è troppo piccolo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.TimeSpan,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; as a UTF8 string.">Formatta un elemento <see cref="T:System.TimeSpan" /> come stringa UTF8.</summary>
      <param name="value" vsli:raw="The value to format.">Valore da formattare.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Buffer in cui scrivere il valore in formato UTF8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Quando il metodo restituisce un risultato, contiene la lunghezza del testo formattato in byte.</param>
      <param name="format" vsli:raw="The standard format to use.">Il formato standard da usare.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> se l'operazione di formattazione ha esito positivo, <see langword="false" /> se <paramref name="buffer" /> è troppo piccolo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.UInt16,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; as a UTF8 string.">Formatta un elemento <see cref="T:System.UInt16" /> come stringa UTF8.</summary>
      <param name="value" vsli:raw="The value to format.">Valore da formattare.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Buffer in cui scrivere il valore in formato UTF8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Quando il metodo restituisce un risultato, contiene la lunghezza del testo formattato in byte.</param>
      <param name="format" vsli:raw="The standard format to use.">Il formato standard da usare.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> se l'operazione di formattazione ha esito positivo, <see langword="false" /> se <paramref name="buffer" /> è troppo piccolo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.UInt32,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; as a UTF8 string.">Formatta un elemento <see cref="T:System.UInt32" /> come stringa UTF8.</summary>
      <param name="value" vsli:raw="The value to format.">Valore da formattare.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Buffer in cui scrivere il valore in formato UTF8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Quando il metodo restituisce un risultato, contiene la lunghezza del testo formattato in byte.</param>
      <param name="format" vsli:raw="The standard format to use.">Il formato standard da usare.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> se l'operazione di formattazione ha esito positivo, <see langword="false" /> se <paramref name="buffer" /> è troppo piccolo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.UInt64,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; as a UTF8 string.">Formatta un elemento <see cref="T:System.UInt64" /> come stringa UTF8.</summary>
      <param name="value" vsli:raw="The value to format.">Valore da formattare.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Buffer in cui scrivere il valore in formato UTF8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Quando il metodo restituisce un risultato, contiene la lunghezza del testo formattato in byte.</param>
      <param name="format" vsli:raw="The standard format to use.">Il formato standard da usare.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> se l'operazione di formattazione ha esito positivo, <see langword="false" /> se <paramref name="buffer" /> è troppo piccolo.</returns>
    </member>
    <member name="T:System.Buffers.Text.Utf8Parser">
      <summary vsli:raw="Provides static methods to parse Utf8 strings to common data types.">Offre metodi statici per analizzare le stringhe UTF8 in tipi di dati comuni.</summary>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Boolean@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.Boolean&quot; /&gt; at the start of a Utf8 string.">Analizza un elemento <see cref="T:System.Boolean" /> all'inizio di una stringa UTF8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Stringa UTF8 da analizzare.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Quando il metodo restituisce un risultato, contiene il valore analizzato da <paramref name="source" /> se l'operazione di analisi ha avuto esito positivo.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Se l'operazione di analisi ha esito positivo, contiene la lunghezza in byte della sottostringa analizzata quando il metodo restituisce un risultato. Se il metodo ha esito negativo, <paramref name="bytesConsumed" /> è impostato su 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Il formato previsto della stringa UTF8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> per l'esito positivo, <see langword="false" /> se la stringa non è sintatticamente valida oppure si è verificato un overflow o underflow.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Byte@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.Byte&quot; /&gt; at the start of a Utf8 string.">Analizza un elemento <see cref="T:System.Byte" /> all'inizio di una stringa UTF8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Stringa UTF8 da analizzare.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Quando il metodo restituisce un risultato, contiene il valore analizzato da <paramref name="source" /> se l'operazione di analisi ha avuto esito positivo.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Se l'operazione di analisi ha esito positivo, contiene la lunghezza in byte della sottostringa analizzata quando il metodo restituisce un risultato. Se il metodo ha esito negativo, <paramref name="bytesConsumed" /> è impostato su 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Il formato previsto della stringa UTF8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> per l'esito positivo, <see langword="false" /> se la stringa non è sintatticamente valida oppure si è verificato un overflow o underflow.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.DateTime@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.DateTime&quot; /&gt; at the start of a Utf8 string.">Analizza un elemento <see cref="T:System.DateTime" /> all'inizio di una stringa UTF8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Stringa UTF8 da analizzare.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Quando il metodo restituisce un risultato, contiene il valore analizzato da <paramref name="source" /> se l'operazione di analisi ha avuto esito positivo.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Se l'operazione di analisi ha esito positivo, contiene la lunghezza in byte della sottostringa analizzata quando il metodo restituisce un risultato. Se il metodo ha esito negativo, <paramref name="bytesConsumed" /> è impostato su 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Il formato previsto della stringa UTF8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> per l'esito positivo, <see langword="false" /> se la stringa non è sintatticamente valida oppure si è verificato un overflow o underflow.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.DateTimeOffset@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.DateTimeOffset&quot; /&gt; at the start of a Utf8 string.">Analizza un elemento <see cref="T:System.DateTimeOffset" /> all'inizio di una stringa UTF8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Stringa UTF8 da analizzare.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Quando il metodo restituisce un risultato, contiene il valore analizzato da <paramref name="source" /> se l'operazione di analisi ha avuto esito positivo.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Se l'operazione di analisi ha esito positivo, contiene la lunghezza in byte della sottostringa analizzata quando il metodo restituisce un risultato. Se il metodo ha esito negativo, <paramref name="bytesConsumed" /> è impostato su 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Il formato previsto della stringa UTF8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> per l'esito positivo, <see langword="false" /> se la stringa non è sintatticamente valida oppure si è verificato un overflow o underflow.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Decimal@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.Decimal&quot; /&gt; at the start of a Utf8 string.">Analizza un elemento <see cref="T:System.Decimal" /> all'inizio di una stringa UTF8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Stringa UTF8 da analizzare.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Quando il metodo restituisce un risultato, contiene il valore analizzato da <paramref name="source" /> se l'operazione di analisi ha avuto esito positivo.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Se l'operazione di analisi ha esito positivo, contiene la lunghezza in byte della sottostringa analizzata quando il metodo restituisce un risultato. Se il metodo ha esito negativo, <paramref name="bytesConsumed" /> è impostato su 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Il formato previsto della stringa UTF8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> per l'esito positivo, <see langword="false" /> se la stringa non è sintatticamente valida oppure si è verificato un overflow o underflow.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Double@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.Double&quot; /&gt; at the start of a Utf8 string.">Analizza un elemento <see cref="T:System.Double" /> all'inizio di una stringa UTF8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Stringa UTF8 da analizzare.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Quando il metodo restituisce un risultato, contiene il valore analizzato da <paramref name="source" /> se l'operazione di analisi ha avuto esito positivo.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Se l'operazione di analisi ha esito positivo, contiene la lunghezza in byte della sottostringa analizzata quando il metodo restituisce un risultato. Se il metodo ha esito negativo, <paramref name="bytesConsumed" /> è impostato su 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Il formato previsto della stringa UTF8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> per l'esito positivo, <see langword="false" /> se la stringa non è sintatticamente valida oppure si è verificato un overflow o underflow.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Guid@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.Guid&quot; /&gt; at the start of a Utf8 string.">Analizza un elemento <see cref="T:System.Guid" /> all'inizio di una stringa UTF8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Stringa UTF8 da analizzare.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Quando il metodo restituisce un risultato, contiene il valore analizzato da <paramref name="source" /> se l'operazione di analisi ha avuto esito positivo.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Se l'operazione di analisi ha esito positivo, contiene la lunghezza in byte della sottostringa analizzata quando il metodo restituisce un risultato. Se il metodo ha esito negativo, <paramref name="bytesConsumed" /> è impostato su 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Il formato previsto della stringa UTF8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> per l'esito positivo, <see langword="false" /> se la stringa non è sintatticamente valida oppure si è verificato un overflow o underflow.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Int16@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses an &lt;see cref=&quot;T:System.Int16&quot; /&gt; at the start of a Utf8 string.">Analizza un elemento <see cref="T:System.Int16" /> all'inizio di una stringa UTF8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Stringa UTF8 da analizzare.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Quando il metodo restituisce un risultato, contiene il valore analizzato da <paramref name="source" /> se l'operazione di analisi ha avuto esito positivo.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Se l'operazione di analisi ha esito positivo, contiene la lunghezza in byte della sottostringa analizzata quando il metodo restituisce un risultato. Se il metodo ha esito negativo, <paramref name="bytesConsumed" /> è impostato su 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Il formato previsto della stringa UTF8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> per l'esito positivo, <see langword="false" /> se la stringa non è sintatticamente valida oppure si è verificato un overflow o underflow.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Int32@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses an &lt;see cref=&quot;T:System.Int32&quot; /&gt; at the start of a Utf8 string.">Analizza un elemento <see cref="T:System.Int32" /> all'inizio di una stringa UTF8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Stringa UTF8 da analizzare.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Quando il metodo restituisce un risultato, contiene il valore analizzato da <paramref name="source" /> se l'operazione di analisi ha avuto esito positivo.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Se l'operazione di analisi ha esito positivo, contiene la lunghezza in byte della sottostringa analizzata quando il metodo restituisce un risultato. Se il metodo ha esito negativo, <paramref name="bytesConsumed" /> è impostato su 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Il formato previsto della stringa UTF8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> per l'esito positivo, <see langword="false" /> se la stringa non è sintatticamente valida oppure si è verificato un overflow o underflow.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Int64@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses an &lt;see cref=&quot;T:System.Int64&quot; /&gt; at the start of a Utf8 string.">Analizza un elemento <see cref="T:System.Int64" /> all'inizio di una stringa UTF8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Stringa UTF8 da analizzare.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Quando il metodo restituisce un risultato, contiene il valore analizzato da <paramref name="source" /> se l'operazione di analisi ha avuto esito positivo.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Se l'operazione di analisi ha esito positivo, contiene la lunghezza in byte della sottostringa analizzata quando il metodo restituisce un risultato. Se il metodo ha esito negativo, <paramref name="bytesConsumed" /> è impostato su 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Il formato previsto della stringa UTF8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> per l'esito positivo, <see langword="false" /> se la stringa non è sintatticamente valida oppure si è verificato un overflow o underflow.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.SByte@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses an &lt;see cref=&quot;T:System.SByte&quot; /&gt; at the start of a Utf8 string.">Analizza un elemento <see cref="T:System.SByte" /> all'inizio di una stringa UTF8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Stringa UTF8 da analizzare.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Quando il metodo restituisce un risultato, contiene il valore analizzato da <paramref name="source" /> se l'operazione di analisi ha avuto esito positivo.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Se l'operazione di analisi ha esito positivo, contiene la lunghezza in byte della sottostringa analizzata quando il metodo restituisce un risultato. Se il metodo ha esito negativo, <paramref name="bytesConsumed" /> è impostato su 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Il formato previsto della stringa UTF8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> per l'esito positivo, <see langword="false" /> se la stringa non è sintatticamente valida oppure si è verificato un overflow o underflow.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Single@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.Single&quot; /&gt; at the start of a Utf8 string.">Analizza un elemento <see cref="T:System.Single" /> all'inizio di una stringa UTF8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Stringa UTF8 da analizzare.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Quando il metodo restituisce un risultato, contiene il valore analizzato da <paramref name="source" /> se l'operazione di analisi ha avuto esito positivo.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Se l'operazione di analisi ha esito positivo, contiene la lunghezza in byte della sottostringa analizzata quando il metodo restituisce un risultato. Se il metodo ha esito negativo, <paramref name="bytesConsumed" /> è impostato su 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Il formato previsto della stringa UTF8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> per l'esito positivo, <see langword="false" /> se la stringa non è sintatticamente valida oppure si è verificato un overflow o underflow.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.TimeSpan@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; at the start of a Utf8 string.">Analizza un elemento <see cref="T:System.TimeSpan" /> all'inizio di una stringa UTF8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Stringa UTF8 da analizzare.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Quando il metodo restituisce un risultato, contiene il valore analizzato da <paramref name="source" /> se l'operazione di analisi ha avuto esito positivo.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Se l'operazione di analisi ha esito positivo, contiene la lunghezza in byte della sottostringa analizzata quando il metodo restituisce un risultato. Se il metodo ha esito negativo, <paramref name="bytesConsumed" /> è impostato su 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Il formato previsto della stringa UTF8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> per l'esito positivo, <see langword="false" /> se la stringa non è sintatticamente valida oppure si è verificato un overflow o underflow.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.UInt16@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; at the start of a Utf8 string.">Analizza un elemento <see cref="T:System.UInt16" /> all'inizio di una stringa UTF8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Stringa UTF8 da analizzare.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Quando il metodo restituisce un risultato, contiene il valore analizzato da <paramref name="source" /> se l'operazione di analisi ha avuto esito positivo.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Se l'operazione di analisi ha esito positivo, contiene la lunghezza in byte della sottostringa analizzata quando il metodo restituisce un risultato. Se il metodo ha esito negativo, <paramref name="bytesConsumed" /> è impostato su 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Il formato previsto della stringa UTF8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> per l'esito positivo, <see langword="false" /> se la stringa non è sintatticamente valida oppure si è verificato un overflow o underflow.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.UInt32@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; at the start of a Utf8 string.">Analizza un elemento <see cref="T:System.UInt32" /> all'inizio di una stringa UTF8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Stringa UTF8 da analizzare.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Quando il metodo restituisce un risultato, contiene il valore analizzato da <paramref name="source" /> se l'operazione di analisi ha avuto esito positivo.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Se l'operazione di analisi ha esito positivo, contiene la lunghezza in byte della sottostringa analizzata quando il metodo restituisce un risultato. Se il metodo ha esito negativo, <paramref name="bytesConsumed" /> è impostato su 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Il formato previsto della stringa UTF8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> per l'esito positivo, <see langword="false" /> se la stringa non è sintatticamente valida oppure si è verificato un overflow o underflow.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.UInt64@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; at the start of a Utf8 string.">Analizza un elemento <see cref="T:System.UInt64" /> all'inizio di una stringa UTF8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Stringa UTF8 da analizzare.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Quando il metodo restituisce un risultato, contiene il valore analizzato da <paramref name="source" /> se l'operazione di analisi ha avuto esito positivo.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Se l'operazione di analisi ha esito positivo, contiene la lunghezza in byte della sottostringa analizzata quando il metodo restituisce un risultato. Se il metodo ha esito negativo, <paramref name="bytesConsumed" /> è impostato su 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Il formato previsto della stringa UTF8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> per l'esito positivo, <see langword="false" /> se la stringa non è sintatticamente valida oppure si è verificato un overflow o underflow.</returns>
    </member>
    <member name="T:System.MemoryExtensions">
      <summary vsli:raw="Provides extension methods for the memory- and span-related types, such as &lt;see cref=&quot;T:System.Memory`1&quot; /&gt;, &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt;, &lt;see cref=&quot;T:System.Span`1&quot; /&gt;, and &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt;.">Specifica metodi di estensione per i tipi correlati alla memoria e all'intervallo, come ad esempio <see cref="T:System.Memory`1" />, <see cref="T:System.ReadOnlyMemory`1" />, <see cref="T:System.Span`1" /> e <see cref="T:System.ReadOnlySpan`1" />.</summary>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String)">
      <summary vsli:raw="Creates a new &lt;see langword=&quot;ReadOnlyMemory&amp;lt;Char&amp;gt;&quot; /&gt; over the portion of the target string.">Crea un nuovo oggetto <see langword="ReadOnlyMemory&lt;Char&gt;" /> sulla parte della stringa di destinazione.</summary>
      <param name="text" vsli:raw="The target string.">La stringa di destinazione.</param>
      <returns vsli:raw="The read-only character memory representation of the string, or &lt;see langword=&quot;default&quot; /&gt; if &lt;paramref name=&quot;text&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">Rappresentazione in memoria dei caratteri di sola lettura della stringa oppure <see langword="default" /> se <paramref name="text" /> è <see langword="null" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Index)">
      <summary vsli:raw="Creates a new &lt;see langword=&quot;ReadOnlyMemory&amp;lt;Char&amp;gt;&quot; /&gt; over a portion of the target string starting at a specified index.">Crea un nuovo oggetto <see langword="ReadOnlyMemory&lt;Char&gt;" /> sulla parte della stringa di destinazione a partire da un indice specificato.</summary>
      <param name="text" vsli:raw="The target string.">La stringa di destinazione.</param>
      <param name="startIndex" vsli:raw="The index at which to begin this slice.">Indice in corrispondenza del quale iniziare la sezione.</param>
      <returns vsli:raw="The read-only character memory representation of the string.">Rappresentazione in memoria dei caratteri di sola lettura della stringa.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Int32)">
      <summary vsli:raw="Creates a new &lt;see langword=&quot;ReadOnlyMemory&amp;lt;Char&amp;gt;&quot; /&gt; over a portion of the target string starting at a specified character position.">Crea un nuovo oggetto <see langword="ReadOnlyMemory&lt;Char&gt;" /> sulla parte della stringa di destinazione a partire da una posizione di carattere specificata.</summary>
      <param name="text" vsli:raw="The target string.">La stringa di destinazione.</param>
      <param name="start" vsli:raw="The index at which to begin this slice.">Indice in corrispondenza del quale iniziare la sezione.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt; is not in the range of &lt;paramref name=&quot;text&quot; /&gt; (&lt;paramref name=&quot;start&quot; /&gt; is &amp;lt; 0 or &amp;gt; &lt;c&gt;text.Length&lt;/c&gt;).">
        <paramref name="start" /> non è compreso nell'intervallo di <paramref name="text" /> (<paramref name="start" /> è &lt; 0 o &gt; <c>text.Length</c>).</exception>
      <returns vsli:raw="The read-only character memory representation of the string, or &lt;see langword=&quot;default&quot; /&gt; if &lt;paramref name=&quot;text&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">Rappresentazione in memoria dei caratteri di sola lettura della stringa oppure <see langword="default" /> se <paramref name="text" /> è <see langword="null" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Int32,System.Int32)">
      <summary vsli:raw="Creates a new &lt;see langword=&quot;ReadOnlyMemory&amp;lt;Char&amp;gt;&quot; /&gt; over a portion of the target string beginning at a specified position with a length.">Crea un nuovo oggetto <see langword="ReadOnlyMemory&lt;Char&gt;" /> su una parte della stringa di destinazione a partire da una posizione specificata con una lunghezza.</summary>
      <param name="text" vsli:raw="The target string.">La stringa di destinazione.</param>
      <param name="start" vsli:raw="The index at which to begin this slice.">Indice in corrispondenza del quale iniziare la sezione.</param>
      <param name="length" vsli:raw="The desired length for the slice.">Lunghezza desiderata della sezione.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt;, &lt;paramref name=&quot;length&quot; /&gt;, or &lt;paramref name=&quot;start&quot; /&gt; + &lt;paramref name=&quot;length&quot; /&gt; is not in the range of &lt;paramref name=&quot;text&quot; /&gt;.">
        <paramref name="start" />, <paramref name="length" /> o <paramref name="start" /> + <paramref name="length" /> non è compreso nell'intervallo di <paramref name="text" />.</exception>
      <returns vsli:raw="The read-only character memory representation of the string, or &lt;see langword=&quot;default&quot; /&gt; if &lt;paramref name=&quot;text&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">Rappresentazione in memoria dei caratteri di sola lettura della stringa oppure <see langword="default" /> se <paramref name="text" /> è <see langword="null" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Range)">
      <summary vsli:raw="Creates a new &lt;see langword=&quot;ReadOnlyMemory&amp;lt;Char&amp;gt;&quot; /&gt; over a specified range of the target string.">Crea un nuovo oggetto <see langword="ReadOnlyMemory&lt;Char&gt;" /> su un intervallo specificato della stringa di destinazione.</summary>
      <param name="text" vsli:raw="The target string.">La stringa di destinazione.</param>
      <param name="range" vsli:raw="The range that indicates the start and length of the sliced string.">Intervallo che indica l'inizio e la lunghezza della stringa sezionata.</param>
      <returns vsli:raw="The read-only character memory representation of the string.">Rappresentazione in memoria dei caratteri di sola lettura della stringa.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[])">
      <summary vsli:raw="Creates a new memory region over the target array.">Crea una nuova area di memoria sulla matrice di destinazione.</summary>
      <param name="array" vsli:raw="The array to convert.">Matrice da convertire.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Tipo della matrice</typeparam>
      <returns vsli:raw="The memory representation of the whole or part of the array.">Rappresentazione in memoria di una parte della matrice o della matrice intera.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Index)">
      <summary vsli:raw="Creates a new memory region over the portion of the target array starting at a specified index to the end of the array.">Crea una nuova area di memoria sulla parte della matrice di destinazione a partire da un indice specificato fino alla fine della matrice.</summary>
      <param name="array" vsli:raw="The array to convert.">Matrice da convertire.</param>
      <param name="startIndex" vsli:raw="The first position of the array.">Prima posizione della matrice.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Tipo della matrice</typeparam>
      <returns vsli:raw="The memory representation of the whole or part of the array.">Rappresentazione in memoria di una parte della matrice o della matrice intera.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Int32)">
      <summary vsli:raw="Creates a new memory region over the portion of the target array starting at a specified position to the end of the array.">Crea una nuova area di memoria sulla parte della matrice di destinazione a partire da una posizione specificata fino alla fine della matrice.</summary>
      <param name="array" vsli:raw="The target array.">Matrice di destinazione.</param>
      <param name="start" vsli:raw="The index at which to begin the memory.">Indice in corrispondenza del quale iniziare l'area di memoria.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Tipo della matrice</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt; is covariant, and the array's type is not exactly &lt;see langword=&quot;T[]&quot; /&gt;.">
        <paramref name="array" /> è covariante e il tipo di matrice non è esattamente <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt; index less than 0 or greater than &lt;see langword=&quot;array.Length&quot; /&gt;.">Indice <paramref name="start" /> minore di 0 o maggiore di <see langword="array.Length" />.</exception>
      <returns vsli:raw="The memory representation of the whole or part of the array.">Rappresentazione in memoria di una parte della matrice o della matrice intera.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Int32,System.Int32)">
      <summary vsli:raw="Creates a new memory region over the portion of the target array beginning at a specified position with a specified length.">Crea una nuova area di memoria sulla parte della matrice di destinazione a partire da una posizione specificata con una lunghezza specificata.</summary>
      <param name="array" vsli:raw="The target array.">Matrice di destinazione.</param>
      <param name="start" vsli:raw="The index at which to begin the memory region.">Indice in corrispondenza del quale iniziare l'area di memoria.</param>
      <param name="length" vsli:raw="The number of items in the memory region.">Numero di elementi nell'area di memoria.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Tipo della matrice</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt; is covariant, and the array's type is not exactly &lt;see langword=&quot;T[]&quot; /&gt;.">
        <paramref name="array" /> è covariante e il tipo di matrice non è esattamente <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt;, &lt;paramref name=&quot;length&quot; /&gt;, or &lt;paramref name=&quot;start&quot; /&gt; + &lt;paramref name=&quot;length&quot; /&gt; is not in the range of &lt;paramref name=&quot;array&quot; /&gt;.">
        <paramref name="start" />, <paramref name="length" /> o <paramref name="start" /> + <paramref name="length" /> non è compreso nell'intervallo di <paramref name="array" />.</exception>
      <returns vsli:raw="The memory representation of the whole or part of the array.">Rappresentazione in memoria di una parte della matrice o della matrice intera.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Range)">
      <summary vsli:raw="Creates a new memory region over the portion of the target array beginning at inclusive start index of the range and ending at the exclusive end index of the range.">Crea una nuova area di memoria sulla parte della matrice di destinazione a partire dall'indice di inizio inclusivo dell'intervallo fino all'indice finale esclusivo dell'intervallo.</summary>
      <param name="array" vsli:raw="The array to convert.">Matrice da convertire.</param>
      <param name="range" vsli:raw="The range to convert from the array.">Intervallo da convertire dalla matrice.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Tipo della matrice</typeparam>
      <returns vsli:raw="The memory representation of the whole or part of the array.">Rappresentazione in memoria di una parte della matrice o della matrice intera.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0})">
      <summary vsli:raw="Creates a new memory region over the portion of the target array segment.">Crea una nuova area di memoria sulla parte del segmento della matrice di destinazione.</summary>
      <param name="segment" vsli:raw="The segment to convert.">Segmento da convertire.</param>
      <typeparam name="T" vsli:raw="The type of the segment.">Tipo del segmento.</typeparam>
      <returns vsli:raw="The memory representation of the segment.">Rappresentazione in memoria del segmento.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0},System.Int32)">
      <summary vsli:raw="Creates a new memory region over the portion of the target array segment starting at a specified position to the end of the segment.">Crea una nuova area di memoria sulla parte del segmento della matrice di destinazione a partire da una posizione specificata fino alla fine del segmento.</summary>
      <param name="segment" vsli:raw="The target array segment.">Segmento della matrice di destinazione.</param>
      <param name="start" vsli:raw="The index at which to begin the memory.">Indice in corrispondenza del quale iniziare l'area di memoria.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Tipo della matrice</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException" vsli:raw="&lt;paramref name=&quot;segment&quot; /&gt; is covariant, and the type of &lt;paramref name=&quot;segment&quot; /&gt; is not exactly &lt;see langword=&quot;T[]&quot; /&gt;.">
        <paramref name="segment" /> è covariante e il tipo di <paramref name="segment" /> non è esattamente <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt; is less than 0 or greater than &lt;see langword=&quot;segment.Count&quot; /&gt;.">
        <paramref name="start" /> è minore di 0 o maggiore di <see langword="segment.Count" />.</exception>
      <returns vsli:raw="The memory representation of the whole or part of the array.">Rappresentazione in memoria di una parte della matrice o della matrice intera.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0},System.Int32,System.Int32)">
      <summary vsli:raw="Creates a new memory region over the portion of the target array segment beginning at a specified position with a specified length.">Crea una nuova area di memoria sulla parte del segmento della matrice di destinazione a partire da una posizione specificata fino alla lunghezza specificata.</summary>
      <param name="segment" vsli:raw="The target array segment.">Segmento della matrice di destinazione.</param>
      <param name="start" vsli:raw="The index at which to begin the memory.">Indice in corrispondenza del quale iniziare l'area di memoria.</param>
      <param name="length" vsli:raw="The number of items in the memory.">Numero di elementi nella memoria.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Tipo della matrice</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException" vsli:raw="&lt;paramref name=&quot;segment&quot; /&gt; is covariant, and the array's type is not exactly &lt;see langword=&quot;T[]&quot; /&gt;.">
        <paramref name="segment" /> è covariante e il tipo di matrice non è esattamente <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt;, &lt;paramref name=&quot;length&quot; /&gt;, or &lt;paramref name=&quot;start&quot; /&gt; + &lt;paramref name=&quot;length&quot; /&gt; is not in the range of &lt;paramref name=&quot;segment&quot; /&gt;.">
        <paramref name="start" />, <paramref name="length" /> o <paramref name="start" /> + <paramref name="length" /> non è compreso nell'intervallo di <paramref name="segment" />.</exception>
      <returns vsli:raw="The memory representation of the whole or part of the array.">Rappresentazione in memoria di una parte della matrice o della matrice intera.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan(System.String)">
      <summary vsli:raw="Creates a new read-only span over a string.">Crea un nuovo intervallo di sola lettura su una parte della stringa di destinazione da una posizione specificata per un numero di caratteri specificato.</summary>
      <param name="text" vsli:raw="The target string.">La stringa di destinazione.</param>
      <returns vsli:raw="The read-only span representation of the string.">Rappresentazione dell'intervallo di sola lettura della stringa.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan(System.String,System.Int32)">
      <summary vsli:raw="Creates a new read-only span over a portion of the target string from a specified position to the end of the string.">Crea un nuovo intervallo di sola lettura su una parte della stringa di destinazione da una posizione specificata fino alla fine della stringa.</summary>
      <param name="text" vsli:raw="The target string.">La stringa di destinazione.</param>
      <param name="start" vsli:raw="The index at which to begin this slice.">Indice in corrispondenza del quale iniziare la sezione.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="Thrown when &lt;paramref name=&quot;text&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="text" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt; is less than 0 or greater than &lt;see langword=&quot;text.Length&quot; /&gt;.">
        <paramref name="start" /> è minore di 0 o maggiore di <see langword="text.Length" />.</exception>
      <returns vsli:raw="The read-only span representation of the string.">Rappresentazione dell'intervallo di sola lettura della stringa.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan(System.String,System.Int32,System.Int32)">
      <summary vsli:raw="Creates a new read-only span over a portion of the target string from a specified position for a specified number of characters.">Crea un nuovo intervallo di sola lettura su una stringa.</summary>
      <param name="text" vsli:raw="The target string.">La stringa di destinazione.</param>
      <param name="start" vsli:raw="The index at which to begin this slice.">Indice in corrispondenza del quale iniziare la sezione.</param>
      <param name="length" vsli:raw="The desired length for the slice.">Lunghezza desiderata della sezione.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt;, &lt;paramref name=&quot;length&quot; /&gt;, or &lt;paramref name=&quot;start&quot; /&gt; + &lt;paramref name=&quot;length&quot; /&gt; is not in the range of &lt;paramref name=&quot;text&quot; /&gt;.">
        <paramref name="start" />, <paramref name="length" /> o <paramref name="start" /> + <paramref name="length" /> non è compreso nell'intervallo di <paramref name="text" />.</exception>
      <returns vsli:raw="The read-only span representation of the string.">Rappresentazione dell'intervallo di sola lettura della stringa.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[])">
      <summary vsli:raw="Creates a new span over a target array.">Crea un nuovo intervallo su una matrice di destinazione.</summary>
      <param name="array" vsli:raw="The array to convert.">Matrice da convertire.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Tipo della matrice</typeparam>
      <returns vsli:raw="The span representation of the array.">Rappresentazione dell'intervallo della matrice.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Index)">
      <summary vsli:raw="Creates a new span over the portion of the target array defined by an &lt;see cref=&quot;T:System.Index&quot; /&gt; value.">Crea un nuovo intervallo sulla parte della matrice di destinazione definita da un valore <see cref="T:System.Index" />.</summary>
      <param name="array" vsli:raw="The array to convert.">Matrice da convertire.</param>
      <param name="startIndex" vsli:raw="The starting index.">Indice iniziale.</param>
      <typeparam name="T" vsli:raw="The array type.">Tipo di matrice.</typeparam>
      <returns vsli:raw="The span representation of the array.">Rappresentazione dell'intervallo della matrice.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Int32)">
      <summary vsli:raw="Creates a new span over a portion of the target array starting at a specified position to the end of the array.">Crea un nuovo intervallo su una parte della matrice di destinazione a partire da una posizione specificata fino alla fine della matrice.</summary>
      <param name="array" vsli:raw="The array to convert.">Matrice da convertire.</param>
      <param name="start" vsli:raw="The initial index from which the array will be converted.">Indice iniziale da cui verrà convertita la matrice.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Tipo della matrice</typeparam>
      <returns vsli:raw="The span representation of the array.">Rappresentazione dell'intervallo della matrice.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Int32,System.Int32)">
      <summary vsli:raw="Creates a new span over the portion of the target array beginning at a specified position for a specified length.">Crea un nuovo intervallo su una parte della matrice di destinazione a partire da una posizione specificata per una lunghezza definita.</summary>
      <param name="array" vsli:raw="The target array.">Matrice di destinazione.</param>
      <param name="start" vsli:raw="The index at which to begin the span.">Indice in corrispondenza del quale iniziare l'intervallo.</param>
      <param name="length" vsli:raw="The number of items in the span.">Numero di elementi nell'intervallo.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Tipo della matrice</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt; is covariant, and the array's type is not exactly &lt;see langword=&quot;T[]&quot; /&gt;&quot;.">
        <paramref name="array" /> è covariante e il tipo di matrice non è esattamente <see langword="T[]" />".</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt;, &lt;paramref name=&quot;length&quot; /&gt;, or &lt;paramref name=&quot;start&quot; /&gt; + &lt;paramref name=&quot;length&quot; /&gt; is not in the range of &lt;paramref name=&quot;text&quot; /&gt;.">
        <paramref name="start" />, <paramref name="length" /> o <paramref name="start" /> + <paramref name="length" /> non è compreso nell'intervallo di <paramref name="text" />.</exception>
      <returns vsli:raw="The span representation of the array.">Rappresentazione dell'intervallo della matrice.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Range)">
      <summary vsli:raw="Creates a new span over a portion of a target array defined by a &lt;see cref=&quot;T:System.Range&quot; /&gt; value.">Crea un nuovo intervallo sulla parte della matrice di destinazione definita da un valore <see cref="T:System.Range" />.</summary>
      <param name="array" vsli:raw="The array to convert.">Matrice da convertire.</param>
      <param name="range" vsli:raw="The range of the array to convert.">Intervallo della matrice da convertire.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Tipo della matrice</typeparam>
      <returns vsli:raw="The span representation of the array.">Rappresentazione dell'intervallo della matrice.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0})">
      <summary vsli:raw="Creates a new span over a target array segment.">Crea un nuovo intervallo su un segmento della matrice di destinazione.</summary>
      <param name="segment" vsli:raw="The array segment to convert.">Segmento di matrice da convertire.</param>
      <typeparam name="T" vsli:raw="The type of the array segment.">Tipo del segmento di matrice.</typeparam>
      <returns vsli:raw="The span representation of the array segment.">Rappresentazione dell'intervallo del segmento della matrice.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Index)">
      <summary vsli:raw="Creates a new span over a portion of the target array segment beginning at a specified index and ending at the end of the segment.">Crea un nuovo intervallo su una parte del segmento della matrice di destinazione a partire da un indice specificato fino alla fine del segmento.</summary>
      <param name="segment" vsli:raw="The target array segment.">Segmento della matrice di destinazione.</param>
      <param name="startIndex" vsli:raw="The index at which to begin the Span.">Indice in corrispondenza del quale iniziare l'intervallo.</param>
      <typeparam name="T" vsli:raw="The type of the array segment.">Tipo del segmento di matrice.</typeparam>
      <returns vsli:raw="The span representation of the array segment.">Rappresentazione dell'intervallo del segmento della matrice.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Int32)">
      <summary vsli:raw="Creates a new span over a portion of a target array segment from a specified position to the end of the segment.">Crea un nuovo intervallo su una parte del segmento della stringa di destinazione da una posizione specificata alla fine del segmento.</summary>
      <param name="segment" vsli:raw="The target array segment.">Segmento della matrice di destinazione.</param>
      <param name="start" vsli:raw="The index at which to begin the san.">Indice in corrispondenza del quale iniziare l'intervallo.</param>
      <typeparam name="T" vsli:raw="The type of the array segment.">Tipo del segmento di matrice.</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException" vsli:raw="&lt;paramref name=&quot;segment&quot; /&gt; is covariant, and the array's type is not exactly &lt;see langword=&quot;T[]&quot; /&gt;.">
        <paramref name="segment" /> è covariante e il tipo di matrice non è esattamente <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt; is less than 0 or greater than &lt;see langword=&quot;segment.Count&quot; /&gt;.">
        <paramref name="start" /> è minore di 0 o maggiore di <see langword="segment.Count" />.</exception>
      <returns vsli:raw="The span representation of the array segment.">Rappresentazione dell'intervallo del segmento della matrice.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Int32,System.Int32)">
      <summary vsli:raw="Creates a new span over a portion of a target array segment from a specified position for a specified length.">Crea un nuovo intervallo su una parte del segmento della stringa di destinazione da una posizione specificata per una lunghezza definita.</summary>
      <param name="segment" vsli:raw="The target array segment.">Segmento della matrice di destinazione.</param>
      <param name="start" vsli:raw="The index at which to begin the span.">Indice in corrispondenza del quale iniziare l'intervallo.</param>
      <param name="length" vsli:raw="The number of items in the span.">Numero di elementi nell'intervallo.</param>
      <typeparam name="T" vsli:raw="The type of the array segment.">Tipo del segmento di matrice.</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException" vsli:raw="&lt;paramref name=&quot;segment&quot; /&gt; is covariant, and the array's type is not exactly &lt;see langword=&quot;T[]&quot; /&gt;.">
        <paramref name="segment" /> è covariante e il tipo di matrice non è esattamente <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt;, &lt;paramref name=&quot;length&quot; /&gt;, or &lt;paramref name=&quot;start&quot; /&gt; + &lt;paramref name=&quot;length&quot; /&gt; is not in the range of &lt;paramref name=&quot;segment&quot; /&gt;.">
        <paramref name="start" />, <paramref name="length" /> o <paramref name="start" /> + <paramref name="length" /> non è compreso nell'intervallo di <paramref name="segment" />.</exception>
      <returns vsli:raw="The span representation of the array.">Rappresentazione dell'intervallo della matrice.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Range)">
      <summary vsli:raw="Creates a new span over a portion of a target array segment using the range start and end indexes.">Crea un nuovo intervallo su una parte di un segmento della matrice di destinazione usando gli indici di inizio e di fine dell'intervallo.</summary>
      <param name="segment" vsli:raw="The target array segment.">Segmento della matrice di destinazione.</param>
      <param name="range" vsli:raw="The range which has start and end indexes to use for slicing the array.">Intervallo con indici iniziali e finali da usare per sezionare la matrice.</param>
      <typeparam name="T" vsli:raw="The type of the array segment.">Tipo del segmento di matrice.</typeparam>
      <returns vsli:raw="The span representation of the array segment.">Rappresentazione dell'intervallo del segmento della matrice.</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``1(System.ReadOnlySpan{``0},System.IComparable{``0})">
      <summary vsli:raw="Searches an entire sorted &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; for a value using the specified &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; generic interface.">Esegue la ricerca di un valore in un'intera matrice <see cref="T:System.ReadOnlySpan`1" /> ordinata usando l'interfaccia generica <see cref="T:System.IComparable`1" /> specificata.</summary>
      <param name="span" vsli:raw="The sorted &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; to search.">Matrice <see cref="T:System.ReadOnlySpan`1" /> ordinata in cui eseguire la ricerca.</param>
      <param name="comparable" vsli:raw="The &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; to use when comparing.">Oggetto <see cref="T:System.IComparable`1" /> da usare per i confronti.</param>
      <typeparam name="T" vsli:raw="The element type of the span.">Tipo di elemento dell'intervallo.</typeparam>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;comparable&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="comparable" /> è <see langword="null" />.</exception>
      <returns vsli:raw="The zero-based index of &lt;paramref name=&quot;comparable&quot; /&gt; in the sorted &lt;paramref name=&quot;span&quot; /&gt;, if &lt;paramref name=&quot;comparable&quot; /&gt; is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than &lt;paramref name=&quot;comparable&quot; /&gt; or, if there is no larger element, the bitwise complement of &lt;see cref=&quot;P:System.ReadOnlySpan`1.Length&quot; /&gt;.">Indice in base zero di <paramref name="comparable" /> nell'oggetto <paramref name="span" /> ordinato, se <paramref name="comparable" /> viene trovato; in caso contrario, un numero negativo che rappresenta il complemento bit per bit dell'indice dell'elemento successivo maggiore di <paramref name="comparable" /> o, se non è disponibile alcun elemento maggiore, il complemento bit per bit di <see cref="P:System.ReadOnlySpan`1.Length" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``1(System.Span{``0},System.IComparable{``0})">
      <summary vsli:raw="Searches an entire sorted &lt;see cref=&quot;T:System.Span`1&quot; /&gt; for a value using the specified &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; generic interface.">Esegue la ricerca di un valore in un'intera matrice <see cref="T:System.Span`1" /> ordinata usando l'interfaccia generica <see cref="T:System.IComparable`1" /> specificata.</summary>
      <param name="span" vsli:raw="The sorted &lt;see cref=&quot;T:System.Span`1&quot; /&gt; to search.">Matrice <see cref="T:System.Span`1" /> ordinata in cui eseguire la ricerca.</param>
      <param name="comparable" vsli:raw="The &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; to use when comparing.">Oggetto <see cref="T:System.IComparable`1" /> da usare per i confronti.</param>
      <typeparam name="T" vsli:raw="The element type of the span.">Tipo di elemento dell'intervallo.</typeparam>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;comparable&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="comparable" /> è <see langword="null" />.</exception>
      <returns vsli:raw="The zero-based index of &lt;paramref name=&quot;comparable&quot; /&gt; in the sorted &lt;paramref name=&quot;span&quot; /&gt;, if &lt;paramref name=&quot;comparable&quot; /&gt; is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than &lt;paramref name=&quot;comparable&quot; /&gt; or, if there is no larger element, the bitwise complement of &lt;see cref=&quot;P:System.Span`1.Length&quot; /&gt;.">Indice in base zero di <paramref name="comparable" /> nell'oggetto <paramref name="span" /> ordinato, se <paramref name="comparable" /> viene trovato; in caso contrario, un numero negativo che rappresenta il complemento bit per bit dell'indice dell'elemento successivo maggiore di <paramref name="comparable" /> o, se non è disponibile alcun elemento maggiore, il complemento bit per bit di <see cref="P:System.Span`1.Length" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``2(System.ReadOnlySpan{``0},``0,``1)">
      <summary vsli:raw="Searches an entire sorted &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; for a specified value using the specified &lt;typeparamref name=&quot;TComparer&quot; /&gt; generic type.">Esegue la ricerca di un valore specifico in un'intera matrice <see cref="T:System.ReadOnlySpan`1" /> ordinata usando il tipo generico <typeparamref name="TComparer" /> specificato.</summary>
      <param name="span" vsli:raw="The sorted &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; to search.">Matrice <see cref="T:System.ReadOnlySpan`1" /> ordinata in cui eseguire la ricerca.</param>
      <param name="value" vsli:raw="The object to locate. The value can be &lt;see langword=&quot;null&quot; /&gt; for reference types.">Oggetto da individuare. Il valore può essere <see langword="null" /> per i tipi di riferimento.</param>
      <param name="comparer" vsli:raw="The &lt;typeparamref name=&quot;TComparer&quot; /&gt; to use when comparing.">Oggetto <typeparamref name="TComparer" /> da usare per i confronti.</param>
      <typeparam name="T" vsli:raw="The element type of the span.">Tipo di elemento dell'intervallo.</typeparam>
      <typeparam name="TComparer" vsli:raw="The specific type of &lt;see cref=&quot;T:System.Collections.Generic.IComparer`1&quot; /&gt;.">Tipo specifico di <see cref="T:System.Collections.Generic.IComparer`1" /> .</typeparam>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;comparer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="comparer" /> è <see langword="null" />.</exception>
      <returns vsli:raw="The zero-based index of &lt;paramref name=&quot;value&quot; /&gt; in the sorted &lt;paramref name=&quot;span&quot; /&gt;, if &lt;paramref name=&quot;value&quot; /&gt; is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than &lt;paramref name=&quot;value&quot; /&gt; or, if there is no larger element, the bitwise complement of &lt;see cref=&quot;P:System.ReadOnlySpan`1.Length&quot; /&gt;.">Indice in base zero di <paramref name="value" /> nell'oggetto <paramref name="span" /> ordinato, se <paramref name="value" /> viene trovato; in caso contrario, un numero negativo che rappresenta il complemento bit per bit dell'indice dell'elemento successivo maggiore di <paramref name="value" /> o, se non è disponibile alcun elemento maggiore, il complemento bit per bit di <see cref="P:System.ReadOnlySpan`1.Length" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``2(System.ReadOnlySpan{``0},``1)">
      <summary vsli:raw="Searches an entire sorted &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; for a value using the specified &lt;typeparamref name=&quot;TComparable&quot; /&gt; generic type.">Esegue la ricerca di un valore in un'intera matrice <see cref="T:System.ReadOnlySpan`1" /> ordinata usando il tipo generico <typeparamref name="TComparable" /> specificato.</summary>
      <param name="span" vsli:raw="The sorted &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; to search.">Matrice <see cref="T:System.ReadOnlySpan`1" /> ordinata in cui eseguire la ricerca.</param>
      <param name="comparable" vsli:raw="The &lt;typeparamref name=&quot;TComparable&quot; /&gt; to use when comparing.">Oggetto <typeparamref name="TComparable" /> da usare per i confronti.</param>
      <typeparam name="T" vsli:raw="The element type of the span.">Tipo di elemento dell'intervallo.</typeparam>
      <typeparam name="TComparable" vsli:raw="The specific type of &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt;.">Tipo specifico di <see cref="T:System.IComparable`1" /> .</typeparam>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;comparable&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="comparable" /> è <see langword="null" />.</exception>
      <returns vsli:raw="The zero-based index of &lt;paramref name=&quot;comparable&quot; /&gt; in the sorted &lt;paramref name=&quot;span&quot; /&gt;, if &lt;paramref name=&quot;comparable&quot; /&gt; is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than &lt;paramref name=&quot;comparable&quot; /&gt; or, if there is no larger element, the bitwise complement of &lt;see cref=&quot;P:System.ReadOnlySpan`1.Length&quot; /&gt;.">Indice in base zero di <paramref name="comparable" /> nell'oggetto <paramref name="span" /> ordinato, se <paramref name="comparable" /> viene trovato; in caso contrario, un numero negativo che rappresenta il complemento bit per bit dell'indice dell'elemento successivo maggiore di <paramref name="comparable" /> o, se non è disponibile alcun elemento maggiore, il complemento bit per bit di <see cref="P:System.ReadOnlySpan`1.Length" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``2(System.Span{``0},``0,``1)">
      <summary vsli:raw="Searches an entire sorted &lt;see cref=&quot;T:System.Span`1&quot; /&gt; for a specified value using the specified &lt;typeparamref name=&quot;TComparer&quot; /&gt; generic type.">Esegue la ricerca di un valore specifico in un'intera matrice <see cref="T:System.Span`1" /> ordinata usando il tipo generico <typeparamref name="TComparer" /> specificato.</summary>
      <param name="span" vsli:raw="The sorted &lt;see cref=&quot;T:System.Span`1&quot; /&gt; to search.">Matrice <see cref="T:System.Span`1" /> ordinata in cui eseguire la ricerca.</param>
      <param name="value" vsli:raw="The object to locate. The value can be &lt;see langword=&quot;null&quot; /&gt; for reference types.">Oggetto da individuare. Il valore può essere <see langword="null" /> per i tipi di riferimento.</param>
      <param name="comparer" vsli:raw="The &lt;typeparamref name=&quot;TComparer&quot; /&gt; to use when comparing.">Oggetto <typeparamref name="TComparer" /> da usare per i confronti.</param>
      <typeparam name="T" vsli:raw="The element type of the span.">Tipo di elemento dell'intervallo.</typeparam>
      <typeparam name="TComparer" vsli:raw="The specific type of &lt;see cref=&quot;T:System.Collections.Generic.IComparer`1&quot; /&gt;.">Tipo specifico di <see cref="T:System.Collections.Generic.IComparer`1" /> .</typeparam>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;comparer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="comparer" /> è <see langword="null" />.</exception>
      <returns vsli:raw="The zero-based index of &lt;paramref name=&quot;value&quot; /&gt; in the sorted &lt;paramref name=&quot;span&quot; /&gt;, if &lt;paramref name=&quot;value&quot; /&gt; is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than &lt;paramref name=&quot;value&quot; /&gt; or, if there is no larger element, the bitwise complement of &lt;see cref=&quot;P:System.Span`1.Length&quot; /&gt;.">Indice in base zero di <paramref name="value" /> nell'oggetto <paramref name="span" /> ordinato, se <paramref name="value" /> viene trovato; in caso contrario, un numero negativo che rappresenta il complemento bit per bit dell'indice dell'elemento successivo maggiore di <paramref name="value" /> o, se non è disponibile alcun elemento maggiore, il complemento bit per bit di <see cref="P:System.Span`1.Length" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``2(System.Span{``0},``1)">
      <summary vsli:raw="Searches an entire sorted &lt;see cref=&quot;T:System.Span`1&quot; /&gt; for a value using the specified &lt;typeparamref name=&quot;TComparable&quot; /&gt; generic type.">Esegue la ricerca di un valore in un'intera matrice <see cref="T:System.Span`1" /> ordinata usando il tipo generico <typeparamref name="TComparable" /> specificato.</summary>
      <param name="span" vsli:raw="The sorted &lt;see cref=&quot;T:System.Span`1&quot; /&gt; to search.">Matrice <see cref="T:System.Span`1" /> ordinata in cui eseguire la ricerca.</param>
      <param name="comparable" vsli:raw="The &lt;typeparamref name=&quot;TComparable&quot; /&gt; to use when comparing.">Oggetto <typeparamref name="TComparable" /> da usare per i confronti.</param>
      <typeparam name="T" vsli:raw="The element type of the span.">Tipo di elemento dell'intervallo.</typeparam>
      <typeparam name="TComparable" vsli:raw="The specific type of &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt;.">Tipo specifico di <see cref="T:System.IComparable`1" /> .</typeparam>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;comparable&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="comparable" /> è <see langword="null" />.</exception>
      <returns vsli:raw="The zero-based index of &lt;paramref name=&quot;comparable&quot; /&gt; in the sorted &lt;paramref name=&quot;span&quot; /&gt;, if &lt;paramref name=&quot;comparable&quot; /&gt; is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than &lt;paramref name=&quot;comparable&quot; /&gt; or, if there is no larger element, the bitwise complement of &lt;see cref=&quot;P:System.Span`1.Length&quot; /&gt;.">Indice in base zero di <paramref name="comparable" /> nell'oggetto <paramref name="span" /> ordinato, se <paramref name="comparable" /> viene trovato; in caso contrario, un numero negativo che rappresenta il complemento bit per bit dell'indice dell'elemento successivo maggiore di <paramref name="comparable" /> o, se non è disponibile alcun elemento maggiore, il complemento bit per bit di <see cref="P:System.Span`1.Length" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.CompareTo(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary vsli:raw="Compares one character span with another using a specified string comparison, and returns an integer that indicates their relative position in the sort order.">Confronta un intervallo di caratteri con un altro usando un confronto di stringhe specificato e restituisce un intero che ne indica la posizione relativa nell'ordinamento.</summary>
      <param name="span" vsli:raw="The source span.">Intervallo di origine.</param>
      <param name="other" vsli:raw="The value to compare with the source span.">Valore da confrontare con l'intervallo di origine.</param>
      <param name="comparisonType" vsli:raw="An enumeration value that determines how &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;other&quot; /&gt; are compared.">Valore di enumerazione che determina la modalità di confronto tra <paramref name="span" /> e <paramref name="other" />.</param>
      <returns vsli:raw="A signed integer that indicates the relative order of &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;other&quot; /&gt;:&lt;br /&gt;   - If less than 0, &lt;paramref name=&quot;span&quot; /&gt; precedes than &lt;paramref name=&quot;other&quot; /&gt;.&lt;br /&gt;   - If 0, &lt;paramref name=&quot;span&quot; /&gt; equals &lt;paramref name=&quot;other&quot; /&gt;.&lt;br /&gt;   - If greater than 0, &lt;paramref name=&quot;span&quot; /&gt; follows &lt;paramref name=&quot;other&quot; /&gt;.">Intero con segno che indica l'ordine relativo di <paramref name="span" /> e <paramref name="other" />:   - Se minore di 0, <paramref name="span" /> precede <paramref name="other" />.   - Se 0, <paramref name="span" /> è uguale a <paramref name="other" />.   - Se maggiore di 0, <paramref name="span" /> segue <paramref name="other" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Contains(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary vsli:raw="Indicates whether a specified value occurs within a read-only character span.">Indica se un valore specificato è presente all'interno di un intervallo di caratteri di sola lettura.</summary>
      <param name="span" vsli:raw="The source span.">Intervallo di origine.</param>
      <param name="value" vsli:raw="The value to seek within the source span.">Valore da cercare all'interno dell'intervallo di origine.</param>
      <param name="comparisonType" vsli:raw="An enumeration value that determines how the characters in &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;value&quot; /&gt; are compared.">Valore di enumerazione che determina la modalità di confronto dei caratteri tra <paramref name="span" /> e <paramref name="value" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;value&quot; /&gt; occurs within the span, &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" /> se <paramref name="value" /> è presente all'interno dell'intervallo; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Contains``1(System.ReadOnlySpan{``0},``0)">
      <summary vsli:raw="Indicates whether a specified value is found in a read-only span. Values are compared using IEquatable{T}.Equals(T).">Indica se un valore specificato viene trovato in un intervallo di sola lettura. I valori vengono confrontati tramite IEquatable{T}.Equals(T).</summary>
      <param name="span" vsli:raw="The span to search.">Intervallo da ricercare.</param>
      <param name="value" vsli:raw="The value to search for.">Valore da cercare.</param>
      <typeparam name="T" vsli:raw="The type of the span.">Tipo dell'intervallo.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if found, &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" /> se il valore viene trovato; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Contains``1(System.Span{``0},``0)">
      <summary vsli:raw="Indicates whether a specified value is found in a span. Values are compared using IEquatable{T}.Equals(T).">Indica se un valore specificato viene trovato in un intervallo. I valori vengono confrontati tramite IEquatable{T}.Equals(T).</summary>
      <param name="span" vsli:raw="The span to search.">Intervallo da ricercare.</param>
      <param name="value" vsli:raw="The value to search for.">Valore da cercare.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the span.">Tipo degli elementi nell'intervallo.</typeparam>
      <returns vsli:raw="&lt;code data-dev-comment-type=&quot;langword&quot;&gt;true&lt;/code&gt; if found, &lt;code data-dev-comment-type=&quot;langword&quot;&gt;false&lt;/code&gt; otherwise.">
        <see langword="true" /> se il valore viene trovato; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.CopyTo``1(``0[],System.Memory{``0})">
      <summary vsli:raw="Copies the contents of the array into a memory region.">Copia il contenuto della matrice in un'area di memoria.</summary>
      <param name="source" vsli:raw="The array to copy items from.">Matrice da cui copiare elementi.</param>
      <param name="destination" vsli:raw="The memory to copy items into.">Memoria in cui copiare elementi.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Tipo della matrice</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="The destination is shorter than the source array.">La destinazione è più corta della matrice di origine.</exception>
    </member>
    <member name="M:System.MemoryExtensions.CopyTo``1(``0[],System.Span{``0})">
      <summary vsli:raw="Copies the contents of the array into the span.">Copia il contenuto della matrice nell'intervallo.</summary>
      <param name="source" vsli:raw="The array to copy items from.">Matrice da cui copiare elementi.</param>
      <param name="destination" vsli:raw="The span to copy items into.">Intervallo in cui copiare gli elementi.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Tipo della matrice</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="The destination Span is shorter than the source array.">L'intervallo di destinazione è più corto della matrice di origine.</exception>
    </member>
    <member name="M:System.MemoryExtensions.EndsWith(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary vsli:raw="Determines whether the end of the &lt;paramref name=&quot;span&quot; /&gt; matches the specified &lt;paramref name=&quot;value&quot; /&gt; when compared using the specified &lt;paramref name=&quot;comparisonType&quot; /&gt; option.">Determina se la fine di <paramref name="span" /> corrisponde al valore di <paramref name="value" /> specificato quando il confronto avviene usando l'opzione <paramref name="comparisonType" /> selezionata.</summary>
      <param name="span" vsli:raw="The source span.">Intervallo di origine.</param>
      <param name="value" vsli:raw="The sequence to compare to the end of the source span.">Sequenza da confrontare con la fine dell'intervallo di origine.</param>
      <param name="comparisonType" vsli:raw="An enumeration value that determines how &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;value&quot; /&gt; are compared.">Valore di enumerazione che determina la modalità di confronto tra <paramref name="span" /> e <paramref name="value" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;value&quot; /&gt; matches the end of &lt;paramref name=&quot;span&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se <paramref name="value" /> corrisponde alla fine di <paramref name="span" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.EndsWith``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Determines whether the specified sequence appears at the end of a read-only span.">Determina se la sequenza specificata viene visualizzata alla fine di un intervallo di sola lettura.</summary>
      <param name="span" vsli:raw="The source span.">Intervallo di origine.</param>
      <param name="value" vsli:raw="The sequence to compare to the end of the source span.">Sequenza da confrontare con la fine dell'intervallo di origine.</param>
      <typeparam name="T" vsli:raw="The type of the span.">Tipo dell'intervallo.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;value&quot; /&gt; matches the end of &lt;paramref name=&quot;span&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se <paramref name="value" /> corrisponde alla fine di <paramref name="span" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.EndsWith``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Determines whether the specified sequence appears at the end of a span.">Determina se la sequenza specificata viene visualizzata alla fine di un intervallo.</summary>
      <param name="span" vsli:raw="The source span.">Intervallo di origine.</param>
      <param name="value" vsli:raw="The sequence to compare to the end of the source span.">Sequenza da confrontare con la fine dell'intervallo di origine.</param>
      <typeparam name="T" vsli:raw="The type of the span.">Tipo dell'intervallo.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;value&quot; /&gt; matches the end of &lt;paramref name=&quot;span&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se <paramref name="value" /> corrisponde alla fine di <paramref name="span" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.EnumerateRunes(System.ReadOnlySpan{System.Char})">
      <summary vsli:raw="Returns an enumeration of &lt;see cref=&quot;T:System.Text.Rune&quot; /&gt; from the provided read-only span.">Restituisce un'enumerazione di <see cref="T:System.Text.Rune" /> dall'intervallo di sola lettura specificato.</summary>
      <param name="span" vsli:raw="The source span.">Intervallo di origine.</param>
      <returns vsli:raw="A rune enumerator.">Enumeratore di Rune.</returns>
    </member>
    <member name="M:System.MemoryExtensions.EnumerateRunes(System.Span{System.Char})">
      <summary vsli:raw="Returns an enumeration of &lt;see cref=&quot;T:System.Text.Rune&quot; /&gt; from the provided span.">Restituisce un'enumerazione di <see cref="T:System.Text.Rune" /> dall'intervallo specificato.</summary>
      <param name="span" vsli:raw="The source span.">Intervallo di origine.</param>
      <returns vsli:raw="A rune enumerator.">Enumeratore di Rune.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Equals(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary vsli:raw="Determines whether this &lt;paramref name=&quot;span&quot; /&gt; and the specified &lt;paramref name=&quot;other&quot; /&gt; span have the same characters when compared using the specified &lt;paramref name=&quot;comparisonType&quot; /&gt; option.">Determina se questo oggetto <paramref name="span" /> e l'intervallo <paramref name="other" /> specificato presentano gli stessi caratteri quando vengono confrontati usando l'opzione <paramref name="comparisonType" /> selezionata.</summary>
      <param name="span" vsli:raw="The source span.">Intervallo di origine.</param>
      <param name="other" vsli:raw="The value to compare with the source span.">Valore da confrontare con l'intervallo di origine.</param>
      <param name="comparisonType" vsli:raw="An enumeration value that determines how &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;other&quot; /&gt; are compared.">Valore di enumerazione che determina la modalità di confronto tra <paramref name="span" /> e <paramref name="other" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if equal, &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" /> se sono uguali; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary vsli:raw="Reports the zero-based index of the first occurrence of the specified &lt;paramref name=&quot;value&quot; /&gt; in the current &lt;paramref name=&quot;span&quot; /&gt;.">Restituisce l'indice in base zero della prima occorrenza dell'oggetto <paramref name="value" /> specificato nell'oggetto <paramref name="span" /> corrente.</summary>
      <param name="span" vsli:raw="The source span.">Intervallo di origine.</param>
      <param name="value" vsli:raw="The value to seek within the source span.">Valore da cercare all'interno dell'intervallo di origine.</param>
      <param name="comparisonType" vsli:raw="An enumeration value that determines how &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;value&quot; /&gt; are compared.">Valore di enumerazione che determina la modalità di confronto tra <paramref name="span" /> e <paramref name="value" />.</param>
      <returns vsli:raw="The index of the occurrence of the value in the span.">Indice dell'occorrenza del valore nell'intervallo.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf``1(System.ReadOnlySpan{``0},``0)">
      <summary vsli:raw="Searches for the specified value and returns the index of its first occurrence. Values are compared using IEquatable{T}.Equals(T).">Cerca il valore specificato e restituisce l'indice della prima occorrenza. I valori vengono confrontati tramite IEquatable{T}.Equals(T).</summary>
      <param name="span" vsli:raw="The span to search.">Intervallo da ricercare.</param>
      <param name="value" vsli:raw="The value to search for.">Valore da cercare.</param>
      <typeparam name="T" vsli:raw="The type of the span and value.">Tipo di span e value.</typeparam>
      <returns vsli:raw="The index of the occurrence of the value in the span. If not found, returns -1.">Indice dell'occorrenza del valore nell'intervallo. Se non viene trovato, restituisce -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Searches for the specified sequence and returns the index of its first occurrence. Values are compared using IEquatable{T}.Equals(T).">Cerca la sequenza specificata e restituisce l'indice della prima occorrenza. I valori vengono confrontati tramite IEquatable{T}.Equals(T).</summary>
      <param name="span" vsli:raw="The span to search.">Intervallo da ricercare.</param>
      <param name="value" vsli:raw="The sequence to search for.">Sequenza da cercare.</param>
      <typeparam name="T" vsli:raw="The type of the span and value.">Tipo di span e value.</typeparam>
      <returns vsli:raw="The index of the occurrence of the value in the span. If not found, returns -1.">Indice dell'occorrenza del valore nell'intervallo. Se non viene trovato, restituisce -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf``1(System.Span{``0},``0)">
      <summary vsli:raw="Searches for the specified value and returns the index of its first occurrence. Values are compared using IEquatable{T}.Equals(T).">Cerca il valore specificato e restituisce l'indice della prima occorrenza. I valori vengono confrontati tramite IEquatable{T}.Equals(T).</summary>
      <param name="span" vsli:raw="The span to search.">Intervallo da ricercare.</param>
      <param name="value" vsli:raw="The value to search for.">Valore da cercare.</param>
      <typeparam name="T" vsli:raw="The type of the span and value.">Tipo di span e value.</typeparam>
      <returns vsli:raw="The index of the occurrence of the value in the span. If not found, returns -1.">Indice dell'occorrenza del valore nell'intervallo. Se non viene trovato, restituisce -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Searches for the specified sequence and returns the index of its first occurrence. Values are compared using IEquatable{T}.Equals(T).">Cerca la sequenza specificata e restituisce l'indice della prima occorrenza. I valori vengono confrontati tramite IEquatable{T}.Equals(T).</summary>
      <param name="span" vsli:raw="The span to search.">Intervallo da ricercare.</param>
      <param name="value" vsli:raw="The sequence to search for.">Sequenza da cercare.</param>
      <typeparam name="T" vsli:raw="The type of the span and value.">Tipo di span e value.</typeparam>
      <returns vsli:raw="The index of the occurrence of the value in the span. If not found, returns -1.">Indice dell'occorrenza del valore nell'intervallo. Se non viene trovato, restituisce -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},``0,``0)">
      <summary vsli:raw="Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator.">Cerca il primo indice di uno dei valori specificati simile alla chiamata di IndexOf eseguita più volte con l'operatore logico OR.</summary>
      <param name="span" vsli:raw="The span to search.">Intervallo da ricercare.</param>
      <param name="value0" vsli:raw="One of the values to search for.">Uno dei valori da cercare.</param>
      <param name="value1" vsli:raw="One of the values to search for.">Uno dei valori da cercare.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">Tipo dell'intervallo e dei valori.</typeparam>
      <returns vsli:raw="The first index of the occurrence of any of the values in the span. If not found, returns -1.">Primo indice dell'occorrenza dei valori nell'intervallo. Se non viene trovato, restituisce -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},``0,``0,``0)">
      <summary vsli:raw="Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator.">Cerca il primo indice di uno dei valori specificati simile alla chiamata di IndexOf eseguita più volte con l'operatore logico OR.</summary>
      <param name="span" vsli:raw="The span to search.">Intervallo da ricercare.</param>
      <param name="value0" vsli:raw="One of the values to search for.">Uno dei valori da cercare.</param>
      <param name="value1" vsli:raw="One of the values to search for.">Uno dei valori da cercare.</param>
      <param name="value2" vsli:raw="One of the values to search for.">Uno dei valori da cercare.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">Tipo dell'intervallo e dei valori.</typeparam>
      <returns vsli:raw="The first index of the occurrence of any of the values in the span. If not found, returns -1.">Primo indice dell'occorrenza dei valori nell'intervallo. Se non viene trovato, restituisce -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator.">Cerca il primo indice di uno dei valori specificati simile alla chiamata di IndexOf eseguita più volte con l'operatore logico OR.</summary>
      <param name="span" vsli:raw="The span to search.">Intervallo da ricercare.</param>
      <param name="values" vsli:raw="The set of values to search for.">Set di valori da cercare.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">Tipo dell'intervallo e dei valori.</typeparam>
      <returns vsli:raw="The first index of the occurrence of any of the values in the span. If not found, returns -1.">Primo indice dell'occorrenza dei valori nell'intervallo. Se non viene trovato, restituisce -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},``0,``0)">
      <summary vsli:raw="Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator.">Cerca il primo indice di uno dei valori specificati simile alla chiamata di IndexOf eseguita più volte con l'operatore logico OR.</summary>
      <param name="span" vsli:raw="The span to search.">Intervallo da ricercare.</param>
      <param name="value0" vsli:raw="One of the values to search for.">Uno dei valori da cercare.</param>
      <param name="value1" vsli:raw="One of the values to search for.">Uno dei valori da cercare.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">Tipo dell'intervallo e dei valori.</typeparam>
      <returns vsli:raw="The first index of the occurrence of any of the values in the span. If not found, returns -1.">Primo indice dell'occorrenza dei valori nell'intervallo. Se non viene trovato, restituisce -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},``0,``0,``0)">
      <summary vsli:raw="Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator.">Cerca il primo indice di uno dei valori specificati simile alla chiamata di IndexOf eseguita più volte con l'operatore logico OR.</summary>
      <param name="span" vsli:raw="The span to search.">Intervallo da ricercare.</param>
      <param name="value0" vsli:raw="One of the values to search for.">Uno dei valori da cercare.</param>
      <param name="value1" vsli:raw="One of the values to search for.">Uno dei valori da cercare.</param>
      <param name="value2" vsli:raw="One of the values to search for.">Uno dei valori da cercare.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">Tipo dell'intervallo e dei valori.</typeparam>
      <returns vsli:raw="The first index of the occurrence of any of the values in the span. If not found, returns -1.">Primo indice dell'occorrenza dei valori nell'intervallo. Se non viene trovato, restituisce -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator.">Cerca il primo indice di uno dei valori specificati simile alla chiamata di IndexOf eseguita più volte con l'operatore logico OR.</summary>
      <param name="span" vsli:raw="The span to search.">Intervallo da ricercare.</param>
      <param name="values" vsli:raw="The set of values to search for.">Set di valori da cercare.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">Tipo dell'intervallo e dei valori.</typeparam>
      <returns vsli:raw="The first index of the occurrence of any of the values in the span. If not found, returns -1.">Primo indice dell'occorrenza dei valori nell'intervallo. Se non viene trovato, restituisce -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IsWhiteSpace(System.ReadOnlySpan{System.Char})">
      <summary vsli:raw="Indicates whether the specified span contains only whitespace characters.">Indica se l'intervallo specificato contiene solo spazi vuoti.</summary>
      <param name="span" vsli:raw="The source span.">Intervallo di origine.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span contains only whitespace characters, &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" /> se l'intervallo contiene solo spazi vuoti; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary vsli:raw="Reports the zero-based index of the last occurrence of the specified &lt;paramref name=&quot;value&quot; /&gt; in the current &lt;paramref name=&quot;span&quot; /&gt;.">Restituisce l'indice in base zero dell'ultima occorrenza dell'oggetto <paramref name="value" /> specificato nell'oggetto <paramref name="span" /> corrente.</summary>
      <param name="span" vsli:raw="The source span.">Intervallo di origine.</param>
      <param name="value" vsli:raw="The value to seek within the source span.">Valore da cercare all'interno dell'intervallo di origine.</param>
      <param name="comparisonType" vsli:raw="An enumeration value that determines how &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;value&quot; /&gt; are compared.">Valore di enumerazione che determina la modalità di confronto tra <paramref name="span" /> e <paramref name="value" />.</param>
      <returns vsli:raw="The index of the last occurrence of the value in the span.">Indice dell'ultima occorrenza del valore nell'intervallo.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf``1(System.ReadOnlySpan{``0},``0)">
      <summary vsli:raw="Searches for the specified value and returns the index of its last occurrence. Values are compared using IEquatable{T}.Equals(T).">Cerca il valore specificato e restituisce l'indice dell'ultima occorrenza. I valori vengono confrontati tramite IEquatable{T}.Equals(T).</summary>
      <param name="span" vsli:raw="The span to search.">Intervallo da ricercare.</param>
      <param name="value" vsli:raw="The value to search for.">Valore da cercare.</param>
      <typeparam name="T" vsli:raw="The type of the span and value.">Tipo di span e value.</typeparam>
      <returns vsli:raw="The index of the last occurrence of the value in the span. If not found, returns -1.">Indice dell'ultima occorrenza del valore nell'intervallo. Se non viene trovato, restituisce -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Searches for the specified sequence and returns the index of its last occurrence. Values are compared using IEquatable{T}.Equals(T).">Cerca la sequenza specificata e restituisce l'indice dell'ultima occorrenza. I valori vengono confrontati tramite IEquatable{T}.Equals(T).</summary>
      <param name="span" vsli:raw="The span to search.">Intervallo da ricercare.</param>
      <param name="value" vsli:raw="The sequence to search for.">Sequenza da cercare.</param>
      <typeparam name="T" vsli:raw="The type of the span and value.">Tipo di span e value.</typeparam>
      <returns vsli:raw="The index of the last occurrence of the value in the span. If not found, returns -1.">Indice dell'ultima occorrenza del valore nell'intervallo. Se non viene trovato, restituisce -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf``1(System.Span{``0},``0)">
      <summary vsli:raw="Searches for the specified value and returns the index of its last occurrence. Values are compared using IEquatable{T}.Equals(T).">Cerca il valore specificato e restituisce l'indice dell'ultima occorrenza. I valori vengono confrontati tramite IEquatable{T}.Equals(T).</summary>
      <param name="span" vsli:raw="The span to search.">Intervallo da ricercare.</param>
      <param name="value" vsli:raw="The value to search for.">Valore da cercare.</param>
      <typeparam name="T" vsli:raw="The type of the span and value.">Tipo di span e value.</typeparam>
      <returns vsli:raw="The index of the last occurrence of the value in the span. If not found, returns -1.">Indice dell'ultima occorrenza del valore nell'intervallo. Se non viene trovato, restituisce -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Searches for the specified sequence and returns the index of its last occurrence. Values are compared using IEquatable{T}.Equals(T).">Cerca la sequenza specificata e restituisce l'indice dell'ultima occorrenza. I valori vengono confrontati tramite IEquatable{T}.Equals(T).</summary>
      <param name="span" vsli:raw="The span to search.">Intervallo da ricercare.</param>
      <param name="value" vsli:raw="The sequence to search for.">Sequenza da cercare.</param>
      <typeparam name="T" vsli:raw="The type of the span and value.">Tipo di span e value.</typeparam>
      <returns vsli:raw="The index of the last occurrence of the value in the span. If not found, returns -1.">Indice dell'ultima occorrenza del valore nell'intervallo. Se non viene trovato, restituisce -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},``0,``0)">
      <summary vsli:raw="Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator.">Cerca l'ultimo indice di uno dei valori specificati simile alla chiamata di LastIndexOf eseguita più volte con l'operatore logico OR.</summary>
      <param name="span" vsli:raw="The span to search.">Intervallo da ricercare.</param>
      <param name="value0" vsli:raw="One of the values to search for.">Uno dei valori da cercare.</param>
      <param name="value1" vsli:raw="One of the values to search for.">Uno dei valori da cercare.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">Tipo dell'intervallo e dei valori.</typeparam>
      <returns vsli:raw="The index of the last occurrence of any of the values in the span. If not found, returns -1.">Indice dell'ultima occorrenza dei valori nell'intervallo. Se non viene trovato, restituisce -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},``0,``0,``0)">
      <summary vsli:raw="Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator.">Cerca l'ultimo indice di uno dei valori specificati simile alla chiamata di LastIndexOf eseguita più volte con l'operatore logico OR.</summary>
      <param name="span" vsli:raw="The span to search.">Intervallo da ricercare.</param>
      <param name="value0" vsli:raw="One of the values to search for.">Uno dei valori da cercare.</param>
      <param name="value1" vsli:raw="One of the values to search for.">Uno dei valori da cercare.</param>
      <param name="value2" vsli:raw="One of the values to search for.">Uno dei valori da cercare.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">Tipo dell'intervallo e dei valori.</typeparam>
      <returns vsli:raw="The index of the last occurrence of any of the values in the span. If not found, returns -1.">Indice dell'ultima occorrenza dei valori nell'intervallo. Se non viene trovato, restituisce -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator.">Cerca l'ultimo indice di uno dei valori specificati simile alla chiamata di LastIndexOf eseguita più volte con l'operatore logico OR.</summary>
      <param name="span" vsli:raw="The span to search.">Intervallo da ricercare.</param>
      <param name="values" vsli:raw="The set of values to search for.">Set di valori da cercare.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">Tipo dell'intervallo e dei valori.</typeparam>
      <returns vsli:raw="The index of the last occurrence of any of the values in the span. If not found, returns -1.">Indice dell'ultima occorrenza dei valori nell'intervallo. Se non viene trovato, restituisce -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},``0,``0)">
      <summary vsli:raw="Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator.">Cerca l'ultimo indice di uno dei valori specificati simile alla chiamata di LastIndexOf eseguita più volte con l'operatore logico OR.</summary>
      <param name="span" vsli:raw="The span to search.">Intervallo da ricercare.</param>
      <param name="value0" vsli:raw="One of the values to search for.">Uno dei valori da cercare.</param>
      <param name="value1" vsli:raw="One of the values to search for.">Uno dei valori da cercare.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">Tipo dell'intervallo e dei valori.</typeparam>
      <returns vsli:raw="The index of the last occurrence of any of the values in the span. If not found, returns -1.">Indice dell'ultima occorrenza dei valori nell'intervallo. Se non viene trovato, restituisce -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},``0,``0,``0)">
      <summary vsli:raw="Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator.">Cerca l'ultimo indice di uno dei valori specificati simile alla chiamata di LastIndexOf eseguita più volte con l'operatore logico OR.</summary>
      <param name="span" vsli:raw="The span to search.">Intervallo da ricercare.</param>
      <param name="value0" vsli:raw="One of the values to search for.">Uno dei valori da cercare.</param>
      <param name="value1" vsli:raw="One of the values to search for.">Uno dei valori da cercare.</param>
      <param name="value2" vsli:raw="One of the values to search for.">Uno dei valori da cercare.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">Tipo dell'intervallo e dei valori.</typeparam>
      <returns vsli:raw="The index of the last occurrence of any of the values in the span. If not found, returns -1.">Indice dell'ultima occorrenza dei valori nell'intervallo. Se non viene trovato, restituisce -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator.">Cerca l'ultimo indice di uno dei valori specificati simile alla chiamata di LastIndexOf eseguita più volte con l'operatore logico OR.</summary>
      <param name="span" vsli:raw="The span to search.">Intervallo da ricercare.</param>
      <param name="values" vsli:raw="The set of values to search for.">Set di valori da cercare.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">Tipo dell'intervallo e dei valori.</typeparam>
      <returns vsli:raw="The index of the last occurrence of any of the values in the span. If not found, returns -1.">Indice dell'ultima occorrenza dei valori nell'intervallo. Se non viene trovato, restituisce -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Overlaps``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Determines whether two read-only sequences overlap in memory.">Determina se due sequenze di sola lettura si sovrappongono in memoria.</summary>
      <param name="span" vsli:raw="The first sequence.">Prima sequenza.</param>
      <param name="other" vsli:raw="The second sequence.">Seconda sequenza.</param>
      <typeparam name="T" vsli:raw="The type of elements in the read-only sequence.">Tipo di elementi nella sequenza di sola lettura.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two sequences overlap; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se le due sequenze si sovrappongono; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Overlaps``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Int32@)">
      <summary vsli:raw="Determines whether two read-only sequences overlap in memory and outputs the element offset.">Determina se due sequenze di sola lettura si sovrappongono in memoria e genera l'offset dell'elemento.</summary>
      <param name="span" vsli:raw="The first sequence.">Prima sequenza.</param>
      <param name="other" vsli:raw="The second sequence.">Seconda sequenza.</param>
      <param name="elementOffset" vsli:raw="When the method returns, contains the offset between &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;other&quot; /&gt;.">Quando il metodo restituisce un risultato, contiene l'offset compreso tra <paramref name="span" /> e <paramref name="other" />.</param>
      <typeparam name="T" vsli:raw="The type of elements in the span.">Tipo di elementi nell'intervallo.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two sequences overlap; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se le due sequenze si sovrappongono; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Overlaps``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Determines whether a span and a read-only span overlap in memory.">Determina se un intervallo e un intervallo di sola lettura si sovrappongono in memoria.</summary>
      <param name="span" vsli:raw="The span to compare.">Intervallo da confrontare.</param>
      <param name="other" vsli:raw="The read-only span to compare.">Intervallo di sola lettura da confrontare.</param>
      <typeparam name="T" vsli:raw="The type of elements in the span.">Tipo di elementi nell'intervallo.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two sequences overlap; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se le due sequenze si sovrappongono; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Overlaps``1(System.Span{``0},System.ReadOnlySpan{``0},System.Int32@)">
      <summary vsli:raw="Determines whether a span and a read-only span overlap in memory and outputs the element offset.">Determina se un intervallo e un intervallo di sola lettura si sovrappongono in memoria e genera l'offset dell'elemento.</summary>
      <param name="span" vsli:raw="The first sequence to compare.">Prima sequenza da confrontare.</param>
      <param name="other" vsli:raw="The second sequence to compare.">Seconda sequenza da confrontare.</param>
      <param name="elementOffset" vsli:raw="When the method returns, contains the offset between &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;other&quot; /&gt;.">Quando il metodo restituisce un risultato, contiene l'offset compreso tra <paramref name="span" /> e <paramref name="other" />.</param>
      <typeparam name="T" vsli:raw="The type of elements in the span.">Tipo di elementi nell'intervallo.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two sequences overlap; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se le due sequenze si sovrappongono; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Reverse``1(System.Span{``0})">
      <summary vsli:raw="Reverses the sequence of the elements in the entire span.">Inverte la sequenza degli elementi nell'intero intervallo.</summary>
      <param name="span" vsli:raw="The span to reverse.">Intervallo da invertire.</param>
      <typeparam name="T" vsli:raw="The type of elements in the span.">Tipo di elementi nell'intervallo.</typeparam>
    </member>
    <member name="M:System.MemoryExtensions.SequenceCompareTo``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Determines the relative order of two read-only sequences by comparing their elements using IComparable{T}.CompareTo(T).">Determina l'ordine relativo di due sequenze di sola lettura confrontando i relativi elementi usando IComparable{T}.CompareTo(T).</summary>
      <param name="span" vsli:raw="The first sequence to compare.">Prima sequenza da confrontare.</param>
      <param name="other" vsli:raw="The second sequence to compare.">Seconda sequenza da confrontare.</param>
      <typeparam name="T" vsli:raw="The type of elements in the sequence.">Tipo di elementi della sequenza.</typeparam>
      <returns vsli:raw="A signed integer that indicates the relative order of &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;other&quot; /&gt;:&lt;br /&gt;   - If less than 0, &lt;paramref name=&quot;span&quot; /&gt; precedes than &lt;paramref name=&quot;other&quot; /&gt;.&lt;br /&gt;   - If 0, &lt;paramref name=&quot;span&quot; /&gt; equals &lt;paramref name=&quot;other&quot; /&gt;.&lt;br /&gt;   - If greater than 0, &lt;paramref name=&quot;span&quot; /&gt; follows &lt;paramref name=&quot;other&quot; /&gt;.">Intero con segno che indica l'ordine relativo di <paramref name="span" /> e <paramref name="other" />:   - Se minore di 0, <paramref name="span" /> precede <paramref name="other" />.   - Se 0, <paramref name="span" /> è uguale a <paramref name="other" />.   - Se maggiore di 0, <paramref name="span" /> segue <paramref name="other" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.SequenceCompareTo``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Determines the relative order of a span and a read-only span by comparing the elements using IComparable{T}.CompareTo(T).">Determina l'ordine relativo di un intervallo e di un intervallo di sola lettura confrontando i relativi elementi usando IComparable{T}.CompareTo(T).</summary>
      <param name="span" vsli:raw="The span to compare.">Intervallo da confrontare.</param>
      <param name="other" vsli:raw="The read-only span to compare.">Intervallo di sola lettura da confrontare.</param>
      <typeparam name="T" vsli:raw="The type of elements in the span.">Tipo di elementi nell'intervallo.</typeparam>
      <returns vsli:raw="A signed integer that indicates the relative order of &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;other&quot; /&gt;:&lt;br /&gt;   - If less than 0, &lt;paramref name=&quot;span&quot; /&gt; precedes than &lt;paramref name=&quot;other&quot; /&gt;.&lt;br /&gt;   - If 0, &lt;paramref name=&quot;span&quot; /&gt; equals &lt;paramref name=&quot;other&quot; /&gt;.&lt;br /&gt;   - If greater than 0, &lt;paramref name=&quot;span&quot; /&gt; follows &lt;paramref name=&quot;other&quot; /&gt;.">Intero con segno che indica l'ordine relativo di <paramref name="span" /> e <paramref name="other" />:   - Se minore di 0, <paramref name="span" /> precede <paramref name="other" />.   - Se 0, <paramref name="span" /> è uguale a <paramref name="other" />.   - Se maggiore di 0, <paramref name="span" /> segue <paramref name="other" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.SequenceEqual``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Determines whether two read-only sequences are equal by comparing the elements using IEquatable{T}.Equals(T).">Determina se due sequenze di sola lettura sono uguali confrontando gli elementi con IEquatable{T}.Equals(T).</summary>
      <param name="span" vsli:raw="The first sequence to compare.">Prima sequenza da confrontare.</param>
      <param name="other" vsli:raw="The second sequence to compare.">Seconda sequenza da confrontare.</param>
      <typeparam name="T" vsli:raw="The type of elements in the sequence.">Tipo di elementi della sequenza.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two sequences are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se le due sequenze sono uguali; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.SequenceEqual``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Determines whether a span and a read-only span are equal by comparing the elements using IEquatable{T}.Equals(T).">Determina se un intervallo e un intervallo di sola lettura sono uguali confrontando gli elementi con IEquatable{T}.Equals(T).</summary>
      <param name="span" vsli:raw="The span to compare.">Intervallo da confrontare.</param>
      <param name="other" vsli:raw="The read-only span to compare.">Intervallo di sola lettura da confrontare.</param>
      <typeparam name="T" vsli:raw="The type of elements in the sequence.">Tipo di elementi della sequenza.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two sequences are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se le due sequenze sono uguali; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Sort``1(System.Span{``0})">
      <summary vsli:raw="Sorts the elements in the entire &lt;see cref=&quot;T:System.Span`1&quot; /&gt; using the &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; implementation of each element of the &lt;see cref=&quot;T:System.Span`1&quot; /&gt;.">Ordina gli elementi dell'intera <see cref="T:System.Span`1" /> usando l'implementazione <see cref="T:System.IComparable`1" /> di ogni elemento dell'oggetto <see cref="T:System.Span`1" /></summary>
      <param name="span" vsli:raw="The span of memory to sort.">Intervallo di memoria da ordinare.</param>
      <typeparam name="T" vsli:raw="The type of the elements of the span.">Tipo degli elementi dell'intervallo.</typeparam>
      <exception cref="T:System.InvalidOperationException" vsli:raw="One or more elements in &lt;paramref name=&quot;span&quot; /&gt; do not implement the &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; interface.">Uno o più elementi in <paramref name="span" /> non implementano l'interfaccia <see cref="T:System.IComparable`1" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.Sort``1(System.Span{``0},System.Comparison{``0})">
      <summary vsli:raw="Sorts the elements in the entire &lt;see cref=&quot;T:System.Span`1&quot; /&gt; using the specified &lt;see cref=&quot;T:System.Comparison`1&quot; /&gt;.">Ordina gli elementi nell'intera classe <see cref="T:System.Span`1" /> usando l'oggetto <see cref="T:System.Comparison`1" /> specificato.</summary>
      <param name="span" vsli:raw="The span of memory to sort.">Intervallo di memoria da ordinare.</param>
      <param name="comparison" vsli:raw="The method to use when comparing elements.">Metodo da usare quando si confrontano gli elementi.</param>
      <typeparam name="T" vsli:raw="The type of the elements of the span.">Tipo degli elementi dell'intervallo.</typeparam>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;comparison&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="comparison" /> è <see langword="null" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.Sort``2(System.Span{``0},``1)">
      <summary vsli:raw="Sorts the elements in the entire &lt;see cref=&quot;T:System.Span`1&quot; /&gt; using the &lt;typeparamref name=&quot;TComparer&quot; /&gt;.">Ordina gli elementi nell'intera <see cref="T:System.Span`1" /> usando <typeparamref name="TComparer" />.</summary>
      <param name="span" vsli:raw="The span of memory to sort.">Intervallo di memoria da ordinare.</param>
      <param name="comparer" vsli:raw="The method to use when comparing elements, or &lt;see langword=&quot;null&quot; /&gt; to use each element's &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; interface implementation.">Metodo da usare quando si confrontano gli elementi oppure <see langword="null" /> per usare l'implementazione dell'interfaccia <see cref="T:System.IComparable`1" /> di ogni elemento.</param>
      <typeparam name="T" vsli:raw="The type of the elements of the span.">Tipo degli elementi dell'intervallo.</typeparam>
      <typeparam name="TComparer" vsli:raw="The type of the comparer to use to compare elements.">Tipo dell'operatore di confronto da utilizzare per confrontare gli elementi.</typeparam>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;comparer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;, and one or more elements in &lt;paramref name=&quot;span&quot; /&gt; do not implement the &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; interface.">
        <paramref name="comparer" /> è <see langword="null" /> e uno o più elementi in <paramref name="span" /> non implementano l'interfaccia <see cref="T:System.IComparable`1" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The implementation of &lt;paramref name=&quot;comparer&quot; /&gt; caused an error during the sort.">L'implementazione di <paramref name="comparer" /> ha causato un errore durante l'ordinamento.</exception>
    </member>
    <member name="M:System.MemoryExtensions.Sort``2(System.Span{``0},System.Span{``1})">
      <summary vsli:raw="Sorts a pair of spans (one containing the keys and the other containing the corresponding items) based on the keys in the first &lt;see cref=&quot;T:System.Span`1&quot; /&gt; using the &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; implementation of each key.">Ordina una coppia di intervalli (uno contenente le chiavi e l'altro contenente gli elementi corrispondenti) in base alle chiavi del primo oggetto <see cref="T:System.Span`1" /> usando l'implementazione di <see cref="T:System.IComparable`1" /> di ogni chiave.</summary>
      <param name="keys" vsli:raw="The span that contains the keys to sort.">Intervallo che contiene le chiavi da ordinare.</param>
      <param name="items" vsli:raw="The span that contains the items that correspond to the keys in &lt;paramref name=&quot;keys&quot; /&gt;.">Intervallo che contiene gli elementi corrispondenti alle chiavi in <paramref name="keys" />.</param>
      <typeparam name="TKey" vsli:raw="The type of the elements of the key span.">Tipo degli elementi dell'intervallo di chiavi.</typeparam>
      <typeparam name="TValue" vsli:raw="The type of the elements of the items span.">Tipo degli elementi dell'intervallo di elementi.</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="The length of &lt;paramref name=&quot;keys&quot; /&gt; isn't equal to the length of &lt;paramref name=&quot;items&quot; /&gt;.">La lunghezza di <paramref name="keys" /> non è uguale alla lunghezza di <paramref name="items" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="One or more elements in &lt;paramref name=&quot;keys&quot; /&gt; do not implement the &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; interface.">Uno o più elementi in <paramref name="keys" /> non implementano l'interfaccia <see cref="T:System.IComparable`1" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.Sort``2(System.Span{``0},System.Span{``1},System.Comparison{``0})">
      <summary vsli:raw="Sorts a pair of spans (one containing the keys and the other containing the corresponding items) based on the keys in the first &lt;see cref=&quot;T:System.Span`1&quot; /&gt; using the specified comparison.">Ordina una coppia di intervalli (uno contenente le chiavi e l'altro contenente gli elementi corrispondenti) in base alle chiavi del primo oggetto <see cref="T:System.Span`1" /> usando il confronto specificato.</summary>
      <param name="keys" vsli:raw="The span that contains the keys to sort.">Intervallo che contiene le chiavi da ordinare.</param>
      <param name="items" vsli:raw="The span that contains the items that correspond to the keys in &lt;paramref name=&quot;keys&quot; /&gt;.">Intervallo che contiene gli elementi corrispondenti alle chiavi in <paramref name="keys" />.</param>
      <param name="comparison" vsli:raw="The &lt;see cref=&quot;T:System.Comparison`1&quot; /&gt; to use when comparing elements.">Oggetto <see cref="T:System.Comparison`1" /> da usare quando si confrontano gli elementi.</param>
      <typeparam name="TKey" vsli:raw="The type of the elements of the key span.">Tipo degli elementi dell'intervallo di chiavi.</typeparam>
      <typeparam name="TValue" vsli:raw="The type of the elements of the items span.">Tipo degli elementi dell'intervallo di elementi.</typeparam>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;comparison&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="comparison" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The length of &lt;paramref name=&quot;keys&quot; /&gt; isn't equal to the length of &lt;paramref name=&quot;items&quot; /&gt;.">La lunghezza di <paramref name="keys" /> non è uguale alla lunghezza di <paramref name="items" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.Sort``3(System.Span{``0},System.Span{``1},``2)">
      <summary vsli:raw="Sorts a pair of spans (one containing the keys and the other containing the corresponding items) based on the keys in the first &lt;see cref=&quot;T:System.Span`1&quot; /&gt; using the specified comparer.">Ordina una coppia di intervalli (uno contenente le chiavi e l'altro contenente gli elementi corrispondenti) in base alle chiavi del primo oggetto <see cref="T:System.Span`1" /> usando l'operatore di confronto specificato.</summary>
      <param name="keys" vsli:raw="The span that contains the keys to sort.">Intervallo che contiene le chiavi da ordinare.</param>
      <param name="items" vsli:raw="The span that contains the items that correspond to the keys in &lt;paramref name=&quot;keys&quot; /&gt;.">Intervallo che contiene gli elementi corrispondenti alle chiavi in <paramref name="keys" />.</param>
      <param name="comparer" vsli:raw="The &lt;see cref=&quot;T:System.Collections.Generic.IComparer`1&quot; /&gt; implementation to use when comparing elements, or &lt;see langword=&quot;null&quot; /&gt; to use the &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; interface implementation of each element.">Implementazione di <see cref="T:System.Collections.Generic.IComparer`1" /> da usare per il confronto tra gli elementi oppure <see langword="null" /> per usare l'implementazione dell'interfaccia <see cref="T:System.IComparable`1" /> di ogni elemento.</param>
      <typeparam name="TKey" vsli:raw="The type of the elements of the key span.">Tipo degli elementi dell'intervallo di chiavi.</typeparam>
      <typeparam name="TValue" vsli:raw="The type of the elements of the items span.">Tipo degli elementi dell'intervallo di elementi.</typeparam>
      <typeparam name="TComparer" vsli:raw="The type of the comparer to use to compare elements.">Tipo dell'operatore di confronto da utilizzare per confrontare gli elementi.</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="The length of &lt;paramref name=&quot;keys&quot; /&gt; isn't equal to the length of &lt;paramref name=&quot;items&quot; /&gt;.">La lunghezza di <paramref name="keys" /> non è uguale alla lunghezza di <paramref name="items" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;comparer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;, and one or more elements in &lt;paramref name=&quot;keys&quot; /&gt; do not implement the &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; interface.">
        <paramref name="comparer" /> è <see langword="null" /> e uno o più elementi in <paramref name="keys" /> non implementano l'interfaccia <see cref="T:System.IComparable`1" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.StartsWith(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary vsli:raw="Determines whether a read-only character span begins with a specified value when compared using a specified &lt;see cref=&quot;T:System.StringComparison&quot; /&gt; value.">Determina se un intervallo di caratteri di sola lettura inizia con un valore specificato quando viene confrontato con un valore <see cref="T:System.StringComparison" /> specifico.</summary>
      <param name="span" vsli:raw="The source span.">Intervallo di origine.</param>
      <param name="value" vsli:raw="The sequence to compare to the beginning of the source span.">Sequenza da confrontare con l'inizio dell'intervallo di origine.</param>
      <param name="comparisonType" vsli:raw="An enumeration value that determines how &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;value&quot; /&gt; are compared.">Valore di enumerazione che determina la modalità di confronto tra <paramref name="span" /> e <paramref name="value" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;value&quot; /&gt; matches the beginning of &lt;paramref name=&quot;span&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se <paramref name="value" /> corrisponde all'inizio di <paramref name="span" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.StartsWith``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Determines whether a specified sequence appears at the start of a read-only span.">Determina se una sequenza specificata viene visualizzata all'inizio di un intervallo di sola lettura.</summary>
      <param name="span" vsli:raw="The read-only character span to search.">Intervallo di caratteri di sola lettura in cui eseguire la ricerca.</param>
      <param name="value" vsli:raw="A sequence to search for at the start of &lt;paramref name=&quot;span&quot; /&gt;.">Sequenza da cercare all'inizio di <paramref name="span" />.</param>
      <typeparam name="T" vsli:raw="The type of elements in the span.">Tipo di elementi nell'intervallo.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;value&quot; /&gt; matches the beginning of &lt;paramref name=&quot;span&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se <paramref name="value" /> corrisponde all'inizio di <paramref name="span" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.StartsWith``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Determines whether a specified sequence appears at the start of a span.">Determina se una sequenza specificata viene visualizzata all'inizio di un intervallo.</summary>
      <param name="span" vsli:raw="The span to search.">Intervallo da ricercare.</param>
      <param name="value" vsli:raw="A sequence to search for at the start of &lt;paramref name=&quot;span&quot; /&gt;.">Sequenza da cercare all'inizio di <paramref name="span" />.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the span.">Tipo degli elementi nell'intervallo.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;value&quot; /&gt; matches the beginning of &lt;paramref name=&quot;span&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se <paramref name="value" /> corrisponde all'inizio di <paramref name="span" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.ToLower(System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Globalization.CultureInfo)">
      <summary vsli:raw="Copies the characters from the source span into the destination, converting each character to lowercase, using the casing rules of the specified culture.">Copia i caratteri dall'intervallo di origine alla destinazione, convertendo ogni carattere in minuscolo, usando le regole di distinzione tra maiuscola e minuscola delle impostazioni cultura specificate.</summary>
      <param name="source" vsli:raw="The source span.">Intervallo di origine.</param>
      <param name="destination" vsli:raw="The destination span which contains the transformed characters.">Intervallo di destinazione che contiene i caratteri trasformati.</param>
      <param name="culture" vsli:raw="An object that supplies culture-specific casing rules.">Oggetto che fornisce le regole specifiche delle impostazioni cultura sull'uso di maiuscole e minuscole.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The source and destination buffers overlap.">I buffer di origine e di destinazione si sovrappongono.</exception>
      <returns vsli:raw="The number of characters written into the destination span. If the destination is too small, returns -1.">Numero di caratteri scritti nell'intervallo di destinazione. Se la destinazione è troppo piccola, restituisce -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.ToLowerInvariant(System.ReadOnlySpan{System.Char},System.Span{System.Char})">
      <summary vsli:raw="Copies the characters from the source span into the destination, converting each character to lowercase, using the casing rules of the invariant culture.">Copia i caratteri dall'intervallo di origine alla destinazione, convertendo ogni carattere in minuscolo, usando le regole di distinzione tra maiuscola e minuscola delle impostazioni cultura inglese non dipendenti da paese/area geografica.</summary>
      <param name="source" vsli:raw="The source span.">Intervallo di origine.</param>
      <param name="destination" vsli:raw="The destination span which contains the transformed characters.">Intervallo di destinazione che contiene i caratteri trasformati.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The source and destination buffers overlap.">I buffer di origine e di destinazione si sovrappongono.</exception>
      <returns vsli:raw="The number of characters written into the destination span. If the destination is too small, returns -1.">Numero di caratteri scritti nell'intervallo di destinazione. Se la destinazione è troppo piccola, restituisce -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.ToUpper(System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Globalization.CultureInfo)">
      <summary vsli:raw="Copies the characters from the source span into the destination, converting each character to uppercase, using the casing rules of the specified culture.">Copia i caratteri dall'intervallo di origine alla destinazione, convertendo ogni carattere in maiuscolo, usando le regole di distinzione tra maiuscola e minuscola delle impostazioni cultura specificate.</summary>
      <param name="source" vsli:raw="The source span.">Intervallo di origine.</param>
      <param name="destination" vsli:raw="The destination span which contains the transformed characters.">Intervallo di destinazione che contiene i caratteri trasformati.</param>
      <param name="culture" vsli:raw="An object that supplies culture-specific casing rules.">Oggetto che fornisce le regole specifiche delle impostazioni cultura sull'uso di maiuscole e minuscole.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The source and destination buffers overlap.">I buffer di origine e di destinazione si sovrappongono.</exception>
      <returns vsli:raw="The number of characters written into the destination span. If the destination is too small, returns -1.">Numero di caratteri scritti nell'intervallo di destinazione. Se la destinazione è troppo piccola, restituisce -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.ToUpperInvariant(System.ReadOnlySpan{System.Char},System.Span{System.Char})">
      <summary vsli:raw="Copies the characters from the source span into the destination, converting each character to uppercase using the casing rules of the invariant culture.">Copia i caratteri dall'intervallo di origine alla destinazione, convertendo ogni carattere in maiuscolo, usando le regole di distinzione tra maiuscola e minuscola delle impostazioni cultura inglese non dipendenti da paese/area geografica.</summary>
      <param name="source" vsli:raw="The source span.">Intervallo di origine.</param>
      <param name="destination" vsli:raw="The destination span which contains the transformed characters.">Intervallo di destinazione che contiene i caratteri trasformati.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The source and destination buffers overlap.">I buffer di origine e di destinazione si sovrappongono.</exception>
      <returns vsli:raw="The number of characters written into the destination span. If the destination is too small, returns -1.">Numero di caratteri scritti nell'intervallo di destinazione. Se la destinazione è troppo piccola, restituisce -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.Memory{System.Char})">
      <summary vsli:raw="Removes all leading and trailing whitespace characters from a character memory region.">Rimuove tutti gli spazi vuoti iniziali e finali da un'area di memoria dei caratteri.</summary>
      <param name="memory" vsli:raw="The source memory from which the characters are removed.">Memoria di origine da cui vengono rimossi i caratteri.</param>
      <returns vsli:raw="The trimmed character memory region.">Area di memoria da cui vengono ritagliati i caratteri.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.ReadOnlyMemory{System.Char})">
      <summary vsli:raw="Removes all leading and trailing whitespace characters from a read-only character memory region.">Rimuove tutti gli spazi vuoti iniziali e finali da un'area di memoria dei caratteri di sola lettura.</summary>
      <param name="memory" vsli:raw="The source memory from which the characters are removed.">Memoria di origine da cui vengono rimossi i caratteri.</param>
      <returns vsli:raw="The trimmed character memory region.">Area di memoria da cui vengono ritagliati i caratteri.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char})">
      <summary vsli:raw="Removes all leading and trailing whitespace characters from a read-only character span.">Rimuove tutti gli spazi vuoti iniziali e finali da un intervallo di caratteri di sola lettura.</summary>
      <param name="span" vsli:raw="The source span from which the characters are removed.">Intervallo di origine da cui vengono rimossi i caratteri.</param>
      <returns vsli:raw="The trimmed read-only character span.">Intervallo di caratteri di sola lettura ritagliato.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char},System.Char)">
      <summary vsli:raw="Removes all leading and trailing occurrences of a specified character from a read-only character span.">Rimuove tutte le occorrenze iniziali e finali da un carattere specificato da un intervallo di caratteri di sola lettura.</summary>
      <param name="span" vsli:raw="The source span from which the character is removed.">Intervallo di origine da cui viene rimosso il carattere.</param>
      <param name="trimChar" vsli:raw="The specified character to look for and remove.">Carattere specificato da cercare e rimuovere.</param>
      <returns vsli:raw="The trimmed read-only character span.">Intervallo di caratteri di sola lettura ritagliato.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
      <summary vsli:raw="Removes all leading and trailing occurrences of a set of characters specified in a read-only span from a read-only character span.">Rimuove tutte le occorrenze iniziali e finali di un set di caratteri specificato in un intervallo di sola lettura da un intervallo di caratteri di sola lettura.</summary>
      <param name="span" vsli:raw="The source span from which the characters are removed.">Intervallo di origine da cui vengono rimossi i caratteri.</param>
      <param name="trimChars" vsli:raw="The span which contains the set of characters to remove.">Intervallo contenente il set di caratteri da rimuovere.</param>
      <returns vsli:raw="The trimmed read-only character span.">Intervallo di caratteri di sola lettura ritagliato.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.Span{System.Char})">
      <summary vsli:raw="Removes all leading and trailing whitespace characters from a character span.">Rimuove tutti gli spazi vuoti iniziali e finali da un intervallo di caratteri.</summary>
      <param name="span" vsli:raw="The source span from which the characters are removed.">Intervallo di origine da cui vengono rimossi i caratteri.</param>
      <returns vsli:raw="The trimmed character span.">Intervallo di caratteri ritagliato.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.Memory{``0},``0)">
      <summary vsli:raw="Removes all leading and trailing occurrences of a specified element from a memory region.">Rimuove tutte le occorrenze iniziali e finali di un elemento specificato da un'area di memoria.</summary>
      <param name="memory" vsli:raw="The source memory from which the element is removed.">Memoria di origine da cui viene rimosso l'elemento.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">Elemento specificato da cercare e rimuovere.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the memory region.">Tipo degli elementi nell'area di memoria.</typeparam>
      <returns vsli:raw="The trimmed memory region.">Area di memoria ritagliata.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.Memory{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all leading and trailing occurrences of a set of elements specified in a read-only span from a memory region.">Rimuove tutte le occorrenze iniziali e finali di un set di elementi specificato in un intervallo di sola lettura da un'area di memoria.</summary>
      <param name="memory" vsli:raw="The source memory from which the elements are removed.">Memoria di origine da cui vengono rimossi gli elementi.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">Intervallo contenente il set di elementi da rimuovere.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the memory region.">Tipo degli elementi nell'area di memoria.</typeparam>
      <returns vsli:raw="The trimmed memory region.">Area di memoria ritagliata.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlyMemory{``0},``0)">
      <summary vsli:raw="Removes all leading and trailing occurrences of a specified element from a read-only memory region.">Rimuove tutte le occorrenze iniziali e finali di un elemento specificato da un'area di memoria di sola lettura.</summary>
      <param name="memory" vsli:raw="The source memory from which the element is removed.">Memoria di origine da cui viene rimosso l'elemento.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">Elemento specificato da cercare e rimuovere.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only memory region.">Tipo degli elementi nell'area di memoria di sola lettura.</typeparam>
      <returns vsli:raw="The trimmed read-only memory region.">Area di memoria di sola lettura ritagliata.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all leading and trailing occurrences of a set of elements specified in a read-only span from a read-only memory region.">Rimuove tutte le occorrenze iniziali e finali di un set di elementi specificato in un intervallo di sola lettura da un'area di memoria di sola lettura.</summary>
      <param name="memory" vsli:raw="The source memory from which the elements are removed.">Memoria di origine da cui vengono rimossi gli elementi.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">Intervallo contenente il set di elementi da rimuovere.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only memory region.">Tipo degli elementi nell'area di memoria di sola lettura.</typeparam>
      <returns vsli:raw="The trimmed read-only memory region.">Area di memoria di sola lettura ritagliata.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlySpan{``0},``0)">
      <summary vsli:raw="Removes all leading and trailing occurrences of a specified element from a read-only span.">Rimuove tutte le occorrenze iniziali e finali di un elemento specificato da un intervallo di sola lettura.</summary>
      <param name="span" vsli:raw="The source span from which the element is removed.">Intervallo di origine da cui viene rimosso l'elemento.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">Elemento specificato da cercare e rimuovere.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only span.">Tipo degli elementi nell'intervallo di sola lettura.</typeparam>
      <returns vsli:raw="The trimmed read-only span.">Intervallo di sola lettura ritagliato.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all leading and trailing occurrences of a set of elements specified in a read-only span from a read-only span.">Rimuove tutte le occorrenze iniziali e finali di un set di elementi specificato in un intervallo di sola lettura da un intervallo di sola lettura.</summary>
      <param name="span" vsli:raw="The source span from which the elements are removed.">Intervallo di origine da cui vengono rimossi gli elementi.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">Intervallo contenente il set di elementi da rimuovere.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only span.">Tipo degli elementi nell'intervallo di sola lettura.</typeparam>
      <returns vsli:raw="The trimmed read-only span.">Intervallo di sola lettura ritagliato.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.Span{``0},``0)">
      <summary vsli:raw="Removes all leading and trailing occurrences of a specified element from a span.">Rimuove tutte le occorrenze iniziali e finali di un elemento specificato da un intervallo.</summary>
      <param name="span" vsli:raw="The source span from which the element is removed.">Intervallo di origine da cui viene rimosso l'elemento.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">Elemento specificato da cercare e rimuovere.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the span.">Tipo degli elementi nell'intervallo.</typeparam>
      <returns vsli:raw="The trimmed span.">Intervallo ritagliato.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all leading and trailing occurrences of a set of elements specified in a read-only span from a span.">Rimuove tutte le occorrenze iniziali e finali di un set di elementi specificato in un intervallo di sola lettura da un intervallo.</summary>
      <param name="span" vsli:raw="The source span from which the elements are removed.">Intervallo di origine da cui vengono rimossi gli elementi.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">Intervallo contenente il set di elementi da rimuovere.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the span.">Tipo degli elementi nell'intervallo.</typeparam>
      <returns vsli:raw="The trimmed span.">Intervallo ritagliato.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.Memory{System.Char})">
      <summary vsli:raw="Removes all trailing whitespace characters from a character memory region.">Rimuove tutti gli spazi vuoti finali da un'area di memoria dei caratteri.</summary>
      <param name="memory" vsli:raw="The source memory from which the characters are removed.">Memoria di origine da cui vengono rimossi i caratteri.</param>
      <returns vsli:raw="The trimmed character memory region.">Area di memoria da cui vengono ritagliati i caratteri.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlyMemory{System.Char})">
      <summary vsli:raw="Removes all trailing whitespace characters from a read-only character memory region.">Rimuove tutti gli spazi vuoti finali da un'area di memoria dei caratteri di sola lettura.</summary>
      <param name="memory" vsli:raw="The source memory from which the characters are removed.">Memoria di origine da cui vengono rimossi i caratteri.</param>
      <returns vsli:raw="The trimmed read-only character span.">Intervallo di caratteri di sola lettura ritagliato.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char})">
      <summary vsli:raw="Removes all trailing whitespace characters from a read-only character span.">Rimuove tutti gli spazi vuoti finali da un intervallo di caratteri di sola lettura.</summary>
      <param name="span" vsli:raw="The source span from which the characters are removed.">Intervallo di origine da cui vengono rimossi i caratteri.</param>
      <returns vsli:raw="The trimmed read-only character span.">Intervallo di caratteri di sola lettura ritagliato.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char},System.Char)">
      <summary vsli:raw="Removes all trailing occurrences of a specified character from a read-only span.">Rimuove tutte le occorrenze finali da un carattere specificato da un intervallo di sola lettura.</summary>
      <param name="span" vsli:raw="The source span from which the character is removed.">Intervallo di origine da cui viene rimosso il carattere.</param>
      <param name="trimChar" vsli:raw="The specified character to look for and remove.">Carattere specificato da cercare e rimuovere.</param>
      <returns vsli:raw="The trimmed read-only character span.">Intervallo di caratteri di sola lettura ritagliato.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
      <summary vsli:raw="Removes all trailing occurrences of a set of characters specified in a read-only span from a read-only character span.">Rimuove tutte le occorrenze finali di un set di caratteri specificato in un intervallo di sola lettura da un intervallo di caratteri di sola lettura.</summary>
      <param name="span" vsli:raw="The source span from which the characters are removed.">Intervallo di origine da cui vengono rimossi i caratteri.</param>
      <param name="trimChars" vsli:raw="The span which contains the set of characters to remove.">Intervallo contenente il set di caratteri da rimuovere.</param>
      <returns vsli:raw="The trimmed read-only character span.">Intervallo di caratteri di sola lettura ritagliato.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.Span{System.Char})">
      <summary vsli:raw="Removes all trailing whitespace characters from a character span.">Rimuove tutti gli spazi vuoti finali da un intervallo di caratteri.</summary>
      <param name="span" vsli:raw="The source span from which the characters are removed.">Intervallo di origine da cui vengono rimossi i caratteri.</param>
      <returns vsli:raw="The trimmed character span.">Intervallo di caratteri ritagliato.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.Memory{``0},``0)">
      <summary vsli:raw="Removes all trailing occurrences of a specified element from a character memory region.">Rimuove tutte le occorrenze finali di un elemento specificato da un'area di memoria dei caratteri.</summary>
      <param name="memory" vsli:raw="The source memory from which the element is removed.">Memoria di origine da cui viene rimosso l'elemento.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">Elemento specificato da cercare e rimuovere.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the memory region.">Tipo degli elementi nell'area di memoria.</typeparam>
      <returns vsli:raw="The trimmed memory region.">Area di memoria ritagliata.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.Memory{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all trailing occurrences of a set of elements specified in a read-only span from a memory region.">Rimuove tutte le occorrenze finali di un set di elementi specificato in un intervallo di sola lettura da un'area di memoria.</summary>
      <param name="memory" vsli:raw="The source memory from which the elements are removed.">Memoria di origine da cui vengono rimossi gli elementi.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">Intervallo contenente il set di elementi da rimuovere.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the memory region.">Tipo degli elementi nell'area di memoria.</typeparam>
      <returns vsli:raw="The trimmed memory region.">Area di memoria ritagliata.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlyMemory{``0},``0)">
      <summary vsli:raw="Removes all trailing occurrences of a specified element from a read-only memory region.">Rimuove tutte le occorrenze finali di un elemento specificato da un'area di memoria di sola lettura.</summary>
      <param name="memory" vsli:raw="The source memory from which the element is removed.">Memoria di origine da cui viene rimosso l'elemento.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">Elemento specificato da cercare e rimuovere.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only memory region.">Tipo degli elementi nell'area di memoria di sola lettura.</typeparam>
      <returns vsli:raw="The trimmed read-only memory region.">Area di memoria di sola lettura ritagliata.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all trailing occurrences of a set of elements specified in a read-only span from a read-only memory region.">Rimuove tutte le occorrenze finali di un set di elementi specificato in un intervallo di sola lettura da un'area di memoria di sola lettura.</summary>
      <param name="memory" vsli:raw="The source memory from which the elements are removed.">Memoria di origine da cui vengono rimossi gli elementi.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">Intervallo contenente il set di elementi da rimuovere.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only memory region.">Tipo degli elementi nell'area di memoria di sola lettura.</typeparam>
      <returns vsli:raw="The trimmed read-only memory region.">Area di memoria di sola lettura ritagliata.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlySpan{``0},``0)">
      <summary vsli:raw="Removes all trailing occurrences of a specified element from a read-only span.">Rimuove tutte le occorrenze finali di un elemento specificato da un intervallo di sola lettura.</summary>
      <param name="span" vsli:raw="The source span from which the element is removed.">Intervallo di origine da cui viene rimosso l'elemento.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">Elemento specificato da cercare e rimuovere.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only span.">Tipo degli elementi nell'intervallo di sola lettura.</typeparam>
      <returns vsli:raw="The trimmed read-only span.">Intervallo di sola lettura ritagliato.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all trailing occurrences of a set of elements specified in a read-only span from a read-only span.">Rimuove tutte le occorrenze finali di un set di elementi specificato in un intervallo di sola lettura da un intervallo di sola lettura.</summary>
      <param name="span" vsli:raw="The source span from which the elements are removed.">Intervallo di origine da cui vengono rimossi gli elementi.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">Intervallo contenente il set di elementi da rimuovere.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only span.">Tipo degli elementi nell'intervallo di sola lettura.</typeparam>
      <returns vsli:raw="The trimmed read-only span.">Intervallo di sola lettura ritagliato.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.Span{``0},``0)">
      <summary vsli:raw="Removes all trailing occurrences of a specified element from a span.">Rimuove tutte le occorrenze finali di un elemento specificato da un intervallo.</summary>
      <param name="span" vsli:raw="The source span from which the element is removed.">Intervallo di origine da cui viene rimosso l'elemento.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">Elemento specificato da cercare e rimuovere.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the span.">Tipo degli elementi nell'intervallo.</typeparam>
      <returns vsli:raw="The trimmed span.">Intervallo ritagliato.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all trailing occurrences of a set of elements specified in a read-only span from a span.">Rimuove tutte le occorrenze finali di un set di elementi specificato in un intervallo di sola lettura da un intervallo.</summary>
      <param name="span" vsli:raw="The source span from which the elements are removed.">Intervallo di origine da cui vengono rimossi gli elementi.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">Intervallo contenente il set di elementi da rimuovere.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the span.">Tipo degli elementi nell'intervallo.</typeparam>
      <returns vsli:raw="The trimmed span.">Intervallo ritagliato.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.Memory{System.Char})">
      <summary vsli:raw="Removes all leading whitespace characters from a memory region.">Rimuove tutti gli spazi vuoti iniziali da un'area di memoria.</summary>
      <param name="memory" vsli:raw="The source memory from which the characters are removed.">Memoria di origine da cui vengono rimossi i caratteri.</param>
      <returns vsli:raw="The trimmed character memory region.">Area di memoria da cui vengono ritagliati i caratteri.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlyMemory{System.Char})">
      <summary vsli:raw="Removes all leading whitespace characters from a read-only memory region.">Rimuove tutti gli spazi vuoti iniziali da un'area di memoria di sola lettura.</summary>
      <param name="memory" vsli:raw="The source memory from which the characters are removed.">Memoria di origine da cui vengono rimossi i caratteri.</param>
      <returns vsli:raw="The trimmed read-only character memory region.">Area di memoria di sola lettura da cui vengono ritagliati i caratteri.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char})">
      <summary vsli:raw="Removes all leading whitespace characters from a read-only span.">Rimuove tutti gli spazi vuoti iniziali da un intervallo di sola lettura.</summary>
      <param name="span" vsli:raw="The source span from which the characters are removed.">Intervallo di origine da cui vengono rimossi i caratteri.</param>
      <returns vsli:raw="The trimmed read-only character span.">Intervallo di caratteri di sola lettura ritagliato.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char},System.Char)">
      <summary vsli:raw="Removes all leading occurrences of a specified character from the span.">Rimuove tutte le occorrenze iniziali di un carattere specificato dall'intervallo.</summary>
      <param name="span" vsli:raw="The source span from which the character is removed.">Intervallo di origine da cui viene rimosso il carattere.</param>
      <param name="trimChar" vsli:raw="The specified character to look for and remove.">Carattere specificato da cercare e rimuovere.</param>
      <returns vsli:raw="The trimmed read-only character span.">Intervallo di caratteri di sola lettura ritagliato.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
      <summary vsli:raw="Removes all leading occurrences of a set of characters specified in a read-only span from the span.">Rimuove tutte le occorrenze iniziali di un set di caratteri specificato in un intervallo di sola lettura dall'intervallo.</summary>
      <param name="span" vsli:raw="The source span from which the characters are removed.">Intervallo di origine da cui vengono rimossi i caratteri.</param>
      <param name="trimChars" vsli:raw="The span which contains the set of characters to remove.">Intervallo contenente il set di caratteri da rimuovere.</param>
      <returns vsli:raw="The trimmed read-only character span.">Intervallo di caratteri di sola lettura ritagliato.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.Span{System.Char})">
      <summary vsli:raw="Removes all leading whitespace characters from a span.">Rimuove tutti gli spazi vuoti iniziali da un intervallo.</summary>
      <param name="span" vsli:raw="The source span from which the characters are removed.">Intervallo di origine da cui vengono rimossi i caratteri.</param>
      <returns vsli:raw="The trimmed character span.">Intervallo di caratteri ritagliato.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.Memory{``0},``0)">
      <summary vsli:raw="Removes all leading occurrences of a specified element from a memory region.">Rimuove tutte le occorrenze iniziali di un elemento specificato da un'area di memoria.</summary>
      <param name="memory" vsli:raw="The source memory region from which the element is removed.">Area di memoria di origine da cui viene rimosso l'elemento.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">Elemento specificato da cercare e rimuovere.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the memory region.">Tipo degli elementi nell'area di memoria.</typeparam>
      <returns vsli:raw="The trimmed memory region.">Area di memoria ritagliata.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.Memory{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all leading occurrences of a set of elements specified in a read-only span from a memory region.">Rimuove tutte le occorrenze iniziali di un set di elementi specificato in un intervallo di sola lettura da un'area di memoria.</summary>
      <param name="memory" vsli:raw="The source memory from which the elements are removed.">Memoria di origine da cui vengono rimossi gli elementi.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">Intervallo contenente il set di elementi da rimuovere.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the memory region.">Tipo degli elementi nell'area di memoria.</typeparam>
      <returns vsli:raw="The trimmed memory region.">Area di memoria ritagliata.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlyMemory{``0},``0)">
      <summary vsli:raw="Removes all leading occurrences of a specified element from a memory region.">Rimuove tutte le occorrenze iniziali di un elemento specificato da un'area di memoria.</summary>
      <param name="memory" vsli:raw="The source memory from which the element is removed.">Memoria di origine da cui viene rimosso l'elemento.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">Elemento specificato da cercare e rimuovere.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only memory region.">Tipo degli elementi nell'area di memoria di sola lettura.</typeparam>
      <returns vsli:raw="The trimmed read-only memory region.">Area di memoria di sola lettura ritagliata.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all leading occurrences of a set of elements specified in a read-only span from a memory region.">Rimuove tutte le occorrenze iniziali di un set di elementi specificato in un intervallo di sola lettura da un'area di memoria.</summary>
      <param name="memory" vsli:raw="The source memory from which the elements are removed.">Memoria di origine da cui vengono rimossi gli elementi.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">Intervallo contenente il set di elementi da rimuovere.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only memory region.">Tipo degli elementi nell'area di memoria di sola lettura.</typeparam>
      <returns vsli:raw="The trimmed read-only memory region.">Area di memoria di sola lettura ritagliata.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlySpan{``0},``0)">
      <summary vsli:raw="Removes all leading occurrences of a specified element from the span.">Rimuove tutte le occorrenze iniziali di un elemento specificato da un intervallo.</summary>
      <param name="span" vsli:raw="The source span from which the element is removed.">Intervallo di origine da cui viene rimosso l'elemento.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">Elemento specificato da cercare e rimuovere.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only span.">Tipo degli elementi nell'intervallo di sola lettura.</typeparam>
      <returns vsli:raw="The trimmed read-only span.">Intervallo di sola lettura ritagliato.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all leading occurrences of a set of elements specified in a read-only span from the span.">Rimuove tutte le occorrenze iniziali di un set di elementi specificato in un intervallo di sola lettura da un intervallo.</summary>
      <param name="span" vsli:raw="The source span from which the elements are removed.">Intervallo di origine da cui vengono rimossi gli elementi.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">Intervallo contenente il set di elementi da rimuovere.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only span.">Tipo degli elementi nell'intervallo di sola lettura.</typeparam>
      <returns vsli:raw="The trimmed read-only span.">Intervallo di sola lettura ritagliato.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.Span{``0},``0)">
      <summary vsli:raw="Removes all leading occurrences of a specified element from the span.">Rimuove tutte le occorrenze iniziali di un elemento specificato da un intervallo.</summary>
      <param name="span" vsli:raw="The source span from which the element is removed.">Intervallo di origine da cui viene rimosso l'elemento.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">Elemento specificato da cercare e rimuovere.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the span.">Tipo degli elementi nell'intervallo.</typeparam>
      <returns vsli:raw="The trimmed span.">Intervallo ritagliato.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all leading occurrences of a set of elements specified in a read-only span from the span.">Rimuove tutte le occorrenze iniziali di un set di elementi specificato in un intervallo di sola lettura da un intervallo.</summary>
      <param name="span" vsli:raw="The source span from which the elements are removed.">Intervallo di origine da cui vengono rimossi gli elementi.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">Intervallo contenente il set di elementi da rimuovere.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the span.">Tipo degli elementi nell'intervallo.</typeparam>
      <returns vsli:raw="The trimmed span.">Intervallo ritagliato.</returns>
    </member>
    <member name="T:System.Runtime.InteropServices.MemoryMarshal">
      <summary vsli:raw="Provides methods to interoperate with &lt;see cref=&quot;T:System.Memory`1&quot; /&gt;, &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt;,  &lt;see cref=&quot;T:System.Span`1&quot; /&gt;, and  &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt;.">Fornisce metodi per l'interoperabilità con <see cref="T:System.Memory`1" />, <see cref="T:System.ReadOnlyMemory`1" />, <see cref="T:System.Span`1" /> e <see cref="T:System.ReadOnlySpan`1" />.</summary>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsBytes``1(System.ReadOnlySpan{``0})">
      <summary vsli:raw="Casts a &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; of one primitive type, &lt;paramref name=&quot;T&quot; /&gt;, to a &lt;see langword=&quot;ReadOnlySpan&amp;lt;Byte&amp;gt;&quot; /&gt;.">Esegue il cast di un oggetto <see cref="T:System.ReadOnlySpan`1" /> di un tipo primitivo, <paramref name="T" />, in un oggetto <see langword="ReadOnlySpan&lt;Byte&gt;" />.</summary>
      <param name="span" vsli:raw="The source slice to convert.">Sezione di origine da convertire.</param>
      <typeparam name="T" vsli:raw="The type of items in the read-only span.">Tipo di elementi nell'intervallo di sola lettura.</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;T&quot; /&gt; contains managed object references.">
        <paramref name="T" /> contiene riferimenti o puntatori.</exception>
      <exception cref="T:System.OverflowException" vsli:raw="The &lt;see cref=&quot;P:System.ReadOnlySpan`1.Length&quot; /&gt; property of the new &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; would exceed &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;">La proprietà <see cref="P:System.ReadOnlySpan`1.Length" /> del nuovo oggetto <see cref="T:System.ReadOnlySpan`1" /> supererebbe <see cref="F:System.Int32.MaxValue" /></exception>
      <returns vsli:raw="A read-only span of type &lt;see cref=&quot;T:System.Byte&quot; /&gt;.">Intervallo di sola lettura di tipo <see cref="T:System.Byte" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsBytes``1(System.Span{``0})">
      <summary vsli:raw="Casts a &lt;see cref=&quot;T:System.Span`1&quot; /&gt; of one primitive type, &lt;paramref name=&quot;T&quot; /&gt;, to a &lt;see langword=&quot;Span&amp;lt;Byte&amp;gt;&quot; /&gt;.">Esegue il cast di un oggetto <see cref="T:System.Span`1" /> di un tipo primitivo, <paramref name="T" />, in un oggetto <see langword="Span&lt;Byte&gt;" />.</summary>
      <param name="span" vsli:raw="The source slice to convert.">Sezione di origine da convertire.</param>
      <typeparam name="T" vsli:raw="The type of items in the span.">Tipo di elementi nell'intervallo.</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;T&quot; /&gt; contains managed object references.">
        <paramref name="T" /> contiene riferimenti o puntatori.</exception>
      <exception cref="T:System.OverflowException" vsli:raw="The &lt;see cref=&quot;P:System.ReadOnlySpan`1.Length&quot; /&gt; property of the new &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; would exceed &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;">La proprietà <see cref="P:System.Span`1.Length" /> del nuovo oggetto <see cref="T:System.Span`1" /> supererebbe <see cref="F:System.Int32.MaxValue" /></exception>
      <returns vsli:raw="A span of type &lt;see cref=&quot;T:System.Byte&quot; /&gt;.">Intervallo di tipo <see cref="T:System.Byte" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsMemory``1(System.ReadOnlyMemory{``0})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Memory`1&quot; /&gt; instance from a &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt;.">Crea un'istanza di <see cref="T:System.Memory`1" /> da un oggetto <see cref="T:System.ReadOnlyMemory`1" />.</summary>
      <param name="memory" vsli:raw="The read-only memory buffer.">Buffer di memoria di sola lettura.</param>
      <typeparam name="T" vsli:raw="The type of items in the read-only memory buffer.">Tipo di elementi nel buffer di memoria di sola lettura.</typeparam>
      <returns vsli:raw="A memory block that represents the same memory as the &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt;.">Blocco di memoria che rappresenta la stessa memoria di <see cref="T:System.ReadOnlyMemory`1" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsRef``1(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reinterprets a read-only span of bytes as a read-only reference to the structure of type &lt;paramref name=&quot;T&quot; /&gt;.">Reinterpreta un intervallo di sola lettura di byte come riferimento di sola lettura per la struttura di tipo <paramref name="T" />.</summary>
      <param name="span" vsli:raw="The read-only span to reinterpret.">Intervallo di sola lettura da reinterpretare.</param>
      <typeparam name="T" vsli:raw="The type of the returned reference.">Tipo del riferimento restituito.</typeparam>
      <returns vsli:raw="The read-only reference to the structure of type &lt;paramref name=&quot;T&quot; /&gt;.">Il riferimento di sola lettura per la struttura di tipo <paramref name="T" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsRef``1(System.Span{System.Byte})">
      <summary vsli:raw="Reinterprets a span of bytes as a reference to the structure of type &lt;paramref name=&quot;T&quot; /&gt;.">Reinterpreta un intervallo di byte come riferimento per la struttura di tipo <paramref name="T" />.</summary>
      <param name="span" vsli:raw="The span to reinterpret.">Intervallo da reinterpretare.</param>
      <typeparam name="T" vsli:raw="The type of the returned reference.">Tipo del riferimento restituito.</typeparam>
      <returns vsli:raw="The reference to the structure of type &lt;paramref name=&quot;T&quot; /&gt;.">Riferimento per la struttura di tipo <paramref name="T" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.Cast``2(System.ReadOnlySpan{``0})">
      <summary vsli:raw="Casts a read-only span of one primitive type to a read-only span of another primitive type.">Esegue il cast di un intervallo di sola lettura di un tipo primitivo in un intervallo di sola lettura di un altro tipo primitivo.</summary>
      <param name="span" vsli:raw="The source slice to convert.">Sezione di origine da convertire.</param>
      <typeparam name="TFrom" vsli:raw="The type of the source span.">Tipo dell'intervallo di origine.</typeparam>
      <typeparam name="TTo" vsli:raw="The type of the target span.">Tipo dell'intervallo di destinazione.</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;TFrom&quot; /&gt; or &lt;paramref name=&quot;TTo&quot; /&gt; contains managed object references.">
        <paramref name="TFrom" /> o <paramref name="TTo" /> contiene riferimenti o puntatori.</exception>
      <returns vsli:raw="The converted read-only span.">Intervallo di sola lettura convertito.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.Cast``2(System.Span{``0})">
      <summary vsli:raw="Casts a span of one primitive type to a span of another primitive type.">Esegue il cast di un intervallo di un tipo primitivo in un intervallo di un altro tipo primitivo.</summary>
      <param name="span" vsli:raw="The source slice to convert.">Sezione di origine da convertire.</param>
      <typeparam name="TFrom" vsli:raw="The type of the source span.">Tipo dell'intervallo di origine.</typeparam>
      <typeparam name="TTo" vsli:raw="The type of the target span.">Tipo dell'intervallo di destinazione.</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;TFrom&quot; /&gt; or &lt;paramref name=&quot;TTo&quot; /&gt; contains managed object references.">
        <paramref name="TFrom" /> o <paramref name="TTo" /> contiene riferimenti o puntatori.</exception>
      <returns vsli:raw="The converted span.">Intervallo convertito.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.CreateFromPinnedArray``1(``0[],System.Int32,System.Int32)">
      <summary vsli:raw="Creates a new memory buffer over the portion of the pre-pinned target array beginning at the &lt;paramref name=&quot;start&quot; /&gt; index and consisting of &lt;paramref name=&quot;length&quot; /&gt; items.">Crea un nuovo buffer di memoria sulla parte della matrice di destinazione già bloccata che inizia in corrispondenza dell'indice <paramref name="start" /> ed è costituita da elementi <paramref name="length" />.</summary>
      <param name="array" vsli:raw="The pre-pinned source array.">Matrice di origine già bloccata.</param>
      <param name="start" vsli:raw="The index of &lt;paramref name=&quot;array&quot; /&gt; at which to begin the memory block.">Indice di <paramref name="array" /> da cui iniziare il blocco di memoria.</param>
      <param name="length" vsli:raw="The number of items to include in the memory block.">Numero di elementi da includere nel blocco di memoria.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Tipo della matrice</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt; is covariant, and the type of &lt;paramref name=&quot;array&quot; /&gt; is not exactly &lt;paramref name=&quot;T[]&quot; /&gt;.">
        <paramref name="array" /> è covariante e il tipo di <paramref name="array" /> non è esattamente <paramref name="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The &lt;paramref name=&quot;start&quot; /&gt; or the end index is not in the range of 0 to &lt;see cref=&quot;P:System.Array.Length&quot; /&gt;.">
        <paramref name="start" /> o l'indice finale non è compreso nell'intervallo tra 0 e <see cref="P:System.Array.Length" />.</exception>
      <returns vsli:raw="A block of memory over the specified elements of &lt;paramref name=&quot;array&quot; /&gt;. If &lt;paramref name=&quot;array&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;, or if &lt;paramref name=&quot;start&quot; /&gt; and &lt;paramref name=&quot;length&quot; /&gt; are 0, the method returns a &lt;see cref=&quot;T:System.Memory`1&quot; /&gt; instance of &lt;see cref=&quot;P:System.Memory`1.Length&quot; /&gt; zero.">Blocco di memoria sugli elementi specificati di <paramref name="array" />. Se <paramref name="array" /> è <see langword="null" /> o se <paramref name="start" /> e <paramref name="length" /> sono 0, il metodo restituisce un'istanza <see cref="T:System.Memory`1" /> di zero <see cref="P:System.Memory`1.Length" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.CreateReadOnlySpan``1(``0@,System.Int32)">
      <summary vsli:raw="Creates a new read-only span over a portion of a regular managed object.">Crea un nuovo intervallo di sola lettura su una parte di un normale oggetto gestito.</summary>
      <param name="reference" vsli:raw="A reference to data.">Riferimento ai dati.</param>
      <param name="length" vsli:raw="The number of &lt;paramref name=&quot;T&quot; /&gt; elements that &lt;paramref name=&quot;reference&quot; /&gt; contains.">Numero di elementi <paramref name="T" /> contenuti in <paramref name="reference" />.</param>
      <typeparam name="T" vsli:raw="The type of the data items.">Tipo di elementi di dati.</typeparam>
      <returns vsli:raw="A read-only span.">Intervallo di sola lettura.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.CreateSpan``1(``0@,System.Int32)">
      <summary vsli:raw="Creates a new span over a portion of a regular managed object.">Crea un nuovo intervallo su una parte di un normale oggetto gestito.</summary>
      <param name="reference" vsli:raw="A reference to data.">Riferimento ai dati.</param>
      <param name="length" vsli:raw="The number of &lt;paramref name=&quot;T&quot; /&gt; elements that &lt;paramref name=&quot;reference&quot; /&gt; contains.">Numero di elementi <paramref name="T" /> contenuti in <paramref name="reference" />.</param>
      <typeparam name="T" vsli:raw="The type of the data items.">Tipo di elementi di dati.</typeparam>
      <returns vsli:raw="A span.">Intervallo.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.GetArrayDataReference``1(``0[])">
      <summary vsli:raw="Returns a reference to the 0th element of &lt;paramref name=&quot;array&quot; /&gt;. If the array is empty, returns a reference to where the 0th element would have been stored. Such a reference may be used for pinning but must never be dereferenced.">Restituisce un riferimento allo 0-esimo elemento di <paramref name="array" />. Se la matrice è vuota, restituisce un riferimento alla posizione in cui sarebbe stato archiviato lo 0-esimo elemento. Un riferimento di questo tipo può essere usato per il blocco, ma non deve mai essere dereferenziato.</summary>
      <param name="array" vsli:raw="The array to analyze.">Matrice da analizzare.</param>
      <typeparam name="T" vsli:raw="The type of the array elements.">Tipo degli elementi della matrice.</typeparam>
      <exception cref="T:System.NullReferenceException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="array" /> è <see langword="null" />.</exception>
      <returns vsli:raw="Reference to the 0th element in &lt;paramref name=&quot;array&quot; /&gt;.">Riferimento all'elemento 0th in <paramref name="array" /></returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.GetReference``1(System.ReadOnlySpan{``0})">
      <summary vsli:raw="Returns a reference to the element of the read-only span at index 0.">Restituisce un riferimento all'elemento dell'intervallo di sola lettura in corrispondenza dell'indice 0.</summary>
      <param name="span" vsli:raw="The read-only span from which the reference is retrieved.">Intervallo di sola lettura da cui viene recuperato il riferimento.</param>
      <typeparam name="T" vsli:raw="The type of items in the span.">Tipo di elementi nell'intervallo.</typeparam>
      <returns vsli:raw="A reference to the element at index 0.">Riferimento all'elemento in corrispondenza dell'indice 0.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.GetReference``1(System.Span{``0})">
      <summary vsli:raw="Returns a reference to the element of the span at index 0.">Restituisce un riferimento all'elemento dell'intervallo in corrispondenza dell'indice 0.</summary>
      <param name="span" vsli:raw="The span from which the reference is retrieved.">Intervallo da cui viene recuperato il riferimento.</param>
      <typeparam name="T" vsli:raw="The type of items in the span.">Tipo di elementi nell'intervallo.</typeparam>
      <returns vsli:raw="A reference to the element at index 0.">Riferimento all'elemento in corrispondenza dell'indice 0.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.Read``1(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a structure of type &lt;typeparamref name=&quot;T&quot; /&gt; out of a read-only span of bytes.">Legge una struttura di tipo <param name="T" /> da un intervallo di sola lettura di byte.</summary>
      <param name="source" vsli:raw="A read-only span.">Intervallo di sola lettura.</param>
      <typeparam name="T" vsli:raw="The type of the item to retrieve from the read-only span.">Tipo dell'elemento da recuperare dall'intervallo di sola lettura.</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;T&quot; /&gt; contains managed object references.">
        <paramref name="T" /> contiene riferimenti o puntatori.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is smaller than &lt;paramref name=&quot;T&quot; /&gt;'s length in bytes.">
        <paramref name="source" /> è minore di <paramref name="T" />.</exception>
      <returns vsli:raw="The structure retrieved from the read-only span.">Struttura recuperata dall'intervallo di sola lettura.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.ToEnumerable``1(System.ReadOnlyMemory{``0})">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; view of the given read-only memory buffer.">Crea una vista <see cref="T:System.Collections.Generic.IEnumerable`1" /> del buffer di memoria di sola lettura specificato.</summary>
      <param name="memory" vsli:raw="A read-only memory buffer.">Buffer di memoria di sola lettura.</param>
      <typeparam name="T" vsli:raw="The type of the items in the read-only memory buffer.">Tipo di elementi nel buffer di memoria di sola lettura.</typeparam>
      <returns vsli:raw="An enumerable view of &lt;paramref name=&quot;memory&quot; /&gt;.">Vista enumerabile di <paramref name="memory" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetArray``1(System.ReadOnlyMemory{``0},System.ArraySegment{``0}@)">
      <summary vsli:raw="Tries to get an array segment from the underlying memory buffer. The return value indicates the success of the operation.">Prova a ottenere un segmento di matrice dal buffer di memoria sottostante. Il valore restituito indica l'esito positivo dell'operazione.</summary>
      <param name="memory" vsli:raw="A read-only memory buffer.">Buffer di memoria di sola lettura.</param>
      <param name="segment" vsli:raw="When this method returns, contains the array segment retrieved from the underlying read-only memory buffer. If the method fails, the method returns a default array segment.">Quando termina, questo metodo contiene il segmento di matrice recuperato dal buffer di memoria di sola lettura sottostante. Se il metodo non riesce, restituisce un segmento di matrice predefinito.</param>
      <typeparam name="T" vsli:raw="The type of items in the read-only memory buffer.">Tipo di elementi nel buffer di memoria di sola lettura.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the method call succeeds; &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" /> se la chiamata al metodo riesce; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetMemoryManager``2(System.ReadOnlyMemory{``0},``1@)">
      <summary vsli:raw="Tries to retrieve a &lt;see cref=&quot;T:System.Buffers.MemoryManager`1&quot; /&gt; from the underlying read-only memory buffer.">Tenta di recuperare un <see cref="T:System.Buffers.MemoryManager`1" /> dal buffer di memoria di sola lettura sottostante.</summary>
      <param name="memory" vsli:raw="The read-only memory buffer for which to get the memory manager.">Buffer di memoria di sola lettura per cui ottenere il gestore di memoria.</param>
      <param name="manager" vsli:raw="When the method returns, the manager of &lt;paramref name=&quot;memory&quot; /&gt;.">Quando il metodo termina, il gestore di <paramref name="memory" />.</param>
      <typeparam name="T" vsli:raw="The type of the items in the read-only memory buffer.">Tipo di elementi nel buffer di memoria di sola lettura.</typeparam>
      <typeparam name="TManager" vsli:raw="The type of the &lt;see cref=&quot;T:System.Buffers.MemoryManager`1&quot; /&gt; to retrieve.">Tipo di <see cref="T:System.Buffers.MemoryManager`1" /> da recuperare.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the method retrieved the memory manager; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se il metodo ha recuperato il gestore di memoria; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetMemoryManager``2(System.ReadOnlyMemory{``0},``1@,System.Int32@,System.Int32@)">
      <summary vsli:raw="Tries to retrieve a &lt;see cref=&quot;T:System.Buffers.MemoryManager`1&quot; /&gt;, start index, and length from the underlying read-only memory buffer.">Tenta di recuperare un <see cref="T:System.Buffers.MemoryManager`1" />, l'indice iniziale e la lunghezza dal buffer di memoria di sola lettura sottostante.</summary>
      <param name="memory" vsli:raw="The read-only memory buffer for which to get the memory manager.">Buffer di memoria di sola lettura per cui ottenere il gestore di memoria.</param>
      <param name="manager" vsli:raw="When the method returns, the manager of &lt;paramref name=&quot;memory&quot; /&gt;.">Quando il metodo termina, il gestore di <paramref name="memory" />.</param>
      <param name="start" vsli:raw="When the method returns, the offset from the start of the &lt;paramref name=&quot;manager&quot; /&gt; that the &lt;paramref name=&quot;memory&quot; /&gt; represents.">Quando il metodo termina, offset dall'inizio di <paramref name="manager" /> rappresentato da <paramref name="memory" />.</param>
      <param name="length" vsli:raw="When the method returns, the length of the &lt;paramref name=&quot;manager&quot; /&gt; that the &lt;paramref name=&quot;memory&quot; /&gt; represents.">Quando il metodo termina, lunghezza di <paramref name="manager" /> rappresentato da <paramref name="memory" />.</param>
      <typeparam name="T" vsli:raw="The type of the items in the read-only memory buffer.">Tipo di elementi nel buffer di memoria di sola lettura.</typeparam>
      <typeparam name="TManager" vsli:raw="The type of the &lt;see cref=&quot;T:System.Buffers.MemoryManager`1&quot; /&gt; to retrieve.">Tipo di <see cref="T:System.Buffers.MemoryManager`1" /> da recuperare.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the method succeeded; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se il metodo è riuscito; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetString(System.ReadOnlyMemory{System.Char},System.String@,System.Int32@,System.Int32@)">
      <summary vsli:raw="Tries to get the underlying string from a &lt;see langword=&quot;System.ReadOnlyMemory&amp;lt;Char&amp;gt;&quot; /&gt;.">Prova a ottenere la stringa sottostante da un <see langword="System.ReadOnlyMemory&lt;Char&gt;" />.</summary>
      <param name="memory" vsli:raw="Read-only memory containing a block of characters.">Memoria di sola lettura che contiene un blocco di caratteri.</param>
      <param name="text" vsli:raw="When the method returns, the string contained in the memory buffer.">Quando il metodo termina, stringa contenuta nel buffer di memoria.</param>
      <param name="start" vsli:raw="The starting location in &lt;paramref name=&quot;text&quot; /&gt;.">Posizione iniziale in <paramref name="text" />.</param>
      <param name="length" vsli:raw="The number of characters in &lt;paramref name=&quot;text&quot; /&gt;.">Numero di caratteri in <paramref name="text" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the method successfully retrieves the underlying string; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se il metodo recupera correttamente la stringa sottostante; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryRead``1(System.ReadOnlySpan{System.Byte},``0@)">
      <summary vsli:raw="Tries to read a structure of type &lt;paramref name=&quot;T&quot; /&gt; from a read-only span of bytes.">Tenta di leggere una struttura di tipo <paramref name="T" /> da un intervallo di sola lettura di byte.</summary>
      <param name="source" vsli:raw="A read-only span of bytes.">Intervallo di sola lettura di byte.</param>
      <param name="value" vsli:raw="When the method returns, an instance of &lt;paramref name=&quot;T&quot; /&gt;.">Quando il metodo termina, istanza di <paramref name="T" />.</param>
      <typeparam name="T" vsli:raw="The type of the structure to retrieve.">Tipo di struttura da recuperare.</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;T&quot; /&gt; contains managed object references.">
        <paramref name="T" /> contiene riferimenti o puntatori.</exception>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the method succeeds in retrieving an instance of the structure; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se il metodo riesce a recuperare un'istanza della struttura; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryWrite``1(System.Span{System.Byte},``0@)">
      <summary vsli:raw="Tries to write a structure of type &lt;paramref name=&quot;T&quot; /&gt; into a span of bytes.">Tenta di scrivere una struttura di tipo <paramref name="T" /> in un intervallo di byte.</summary>
      <param name="destination" vsli:raw="The span of bytes to contain the structure.">Intervallo di byte per contenere la struttura.</param>
      <param name="value" vsli:raw="The structure to be written to the span.">Struttura da scrivere nell'intervallo.</param>
      <typeparam name="T" vsli:raw="The type of the structure.">Tipo della struttura.</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;T&quot; /&gt; contains managed object references.">
        <paramref name="T" /> contiene riferimenti o puntatori.</exception>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the write operation succeeded; otherwise, &lt;see langword=&quot;false&quot; /&gt;. The method returns &lt;see langword=&quot;false&quot; /&gt; if the span is too small to contain &lt;paramref name=&quot;T&quot; /&gt;.">
        <see langword="true" /> se l'operazione di scrittura ha esito positivo; in caso contrario, <see langword="false" />. Il metodo restituisce <see langword="false" /> se l'intervallo è troppo piccolo per contenere <paramref name="T" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.Write``1(System.Span{System.Byte},``0@)">
      <summary vsli:raw="Writes a structure of type &lt;paramref name=&quot;T&quot; /&gt; into a span of bytes.">Scrive una struttura di tipo <paramref name="T" /> in un intervallo di byte.</summary>
      <param name="destination" vsli:raw="The span of bytes to contain the structure.">Intervallo di byte per contenere la struttura.</param>
      <param name="value" vsli:raw="The structure to be written to the span.">Struttura da scrivere nell'intervallo.</param>
      <typeparam name="T" vsli:raw="The type of the structure.">Tipo della struttura.</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;T&quot; /&gt; contains managed object references.">
        <paramref name="T" /> contiene riferimenti o puntatori.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain &lt;paramref name=&quot;value&quot; /&gt;.">
        <paramref name="destination" /> è troppo piccolo per contenere <paramref name="value" />.</exception>
    </member>
    <member name="T:System.Runtime.InteropServices.SequenceMarshal">
      <summary vsli:raw="Provides a collection of methods for interoperating with &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Offre una raccolta di metodi per l'interoperabilità con <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
    </member>
    <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryGetArray``1(System.Buffers.ReadOnlySequence{``0},System.ArraySegment{``0}@)">
      <summary vsli:raw="Gets an array segment from the underlying read-only sequence.">Ottiene un segmento di matrice dalla sequenza di sola lettura sottostante.</summary>
      <param name="sequence" vsli:raw="The read-only sequence from which the array segment will be retrieved.">Sequenza di sola lettura da cui verrà recuperato il segmento di matrice.</param>
      <param name="segment" vsli:raw="The returned array segment.">Segmento di matrice restituito.</param>
      <typeparam name="T" vsli:raw="The type of the read-only sequence.">Tipo della sequenza di sola lettura.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if it's possible to retrieve the array segment; otherwise, &lt;see langword=&quot;false&quot; /&gt; and a default array segment is returned.">
        <see langword="true" /> se è possibile recuperare il segmento di matrice; in caso contrario, <see langword="false" /> e viene restituito un segmento di matrice predefinito.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryGetReadOnlyMemory``1(System.Buffers.ReadOnlySequence{``0},System.ReadOnlyMemory{``0}@)">
      <summary vsli:raw="Attempts to retrieve a read-only memory from the specified read-only sequence.">Tenta di recuperare una memoria di sola lettura dalla sequenza di sola lettura specificata.</summary>
      <param name="sequence" vsli:raw="The read-only sequence from which the memory will be retrieved.">Sequenza di sola lettura da cui verrà recuperata la memoria.</param>
      <param name="memory" vsli:raw="The returned read-only memory of type T.">Memoria di sola lettura di tipo T restituita.</param>
      <typeparam name="T" vsli:raw="The type of the read-only sequence.">Tipo della sequenza di sola lettura.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the read-only memory can be retrieved; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se è possibile recuperare la memoria di sola lettura; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryGetReadOnlySequenceSegment``1(System.Buffers.ReadOnlySequence{``0},System.Buffers.ReadOnlySequenceSegment{``0}@,System.Int32@,System.Buffers.ReadOnlySequenceSegment{``0}@,System.Int32@)">
      <summary vsli:raw="Attempts to retrieve a read-only sequence segment from the specified read-only sequence.">Tenta di recuperare un segmento di sequenza di sola lettura dalla sequenza di sola lettura specificata.</summary>
      <param name="sequence" vsli:raw="The read-only sequence from which the read-only sequence segment will be retrieved.">Sequenza di sola lettura da cui verrà recuperato il segmento di sequenza di sola lettura.</param>
      <param name="startSegment" vsli:raw="The beginning read-only sequence segment.">Segmento di sequenza di sola lettura iniziale.</param>
      <param name="startIndex" vsli:raw="The initial position.">Posizione iniziale.</param>
      <param name="endSegment" vsli:raw="The ending read-only sequence segment.">Segmento di sequenza di sola lettura finale.</param>
      <param name="endIndex" vsli:raw="The final position.">Posizione finale.</param>
      <typeparam name="T" vsli:raw="The type of the read-only sequence.">Tipo della sequenza di sola lettura.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the read-only sequence segment can be retrieved; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se è possibile recuperare il segmento di sequenza di sola lettura; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryRead``1(System.Buffers.SequenceReader{System.Byte}@,``0@)">
      <summary vsli:raw="Attempts to read the specified type out of the buffer. It's dangerous to use this method with arbitrary structs - see remarks for more information.">Tenta di leggere il tipo specificato dal buffer. L'uso di questo metodo con struct arbitrari è pericoloso. Per altre informazioni, vedere la sezione Osservazioni.</summary>
      <param name="reader" vsli:raw="A reference to the sequence reader.">Riferimento al lettore di sequenze.</param>
      <param name="value" vsli:raw="The returned value if the read was successful. &lt;paramref name=&quot;value&quot; /&gt; will be &lt;see langword=&quot;default&quot; /&gt; if failed (due to lack of space).">Valore restituito se la lettura è riuscita. <paramref name="value" /> sarà <see langword="default" /> se l'operazione non è riuscita (a causa di mancanza di spazio).</param>
      <typeparam name="T" vsli:raw="The type of the value.">Tipo del valore.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the read attempt was successful, &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" /> se il tentativo di lettura è riuscito, <see langword="false" /> in caso contrario.</returns>
    </member>
    <member name="T:System.SequencePosition">
      <summary vsli:raw="Represents a position in a non-contiguous set of memory. Properties of this type should not be interpreted by anything but the type that created it.">Rappresenta una posizione in un set di memoria non contiguo. Le proprietà di questo tipo devono essere interpretate solo dal tipo che le ha create.</summary>
    </member>
    <member name="M:System.SequencePosition.#ctor(System.Object,System.Int32)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; struct.">Inizializza una nuova istanza dell'elemento struct <see cref="T:System.SequencePosition" />.</summary>
      <param name="object" vsli:raw="A non-contiguous set of memory.">Set di memoria non contiguo.</param>
      <param name="integer" vsli:raw="The position in &lt;paramref name=&quot;object&quot; /&gt;.">Posizione in <paramref name="object" />.</param>
    </member>
    <member name="M:System.SequencePosition.Equals(System.Object)">
      <summary vsli:raw="Returns a value that indicates whether the current instance is equal to another object.">Restituisce un valore che indica se l'istanza corrente è uguale a un altro oggetto.</summary>
      <param name="obj" vsli:raw="The object to compare with the current instance.">Oggetto da confrontare con l'istanza corrente.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;obj&quot; /&gt; is of type &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; and is equal to the current instance; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se <paramref name="obj" /> è di tipo <see cref="T:System.SequencePosition" /> ed è uguale al valore dell'istanza corrente. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.SequencePosition.Equals(System.SequencePosition)">
      <summary vsli:raw="Indicates whether the current instance is equal to another &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt;.">Indica se l'istanza corrente è uguale a un altro oggetto <see cref="T:System.SequencePosition" />.</summary>
      <param name="other" vsli:raw="The sequence position to compare with the current instance.">Posizione della sequenza da confrontare con l'istanza corrente.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two instances are equal; &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" /> se le due istanze sono uguali. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.SequencePosition.GetHashCode">
      <summary vsli:raw="Returns the hash code for this instance.">Restituisce il codice hash per l'istanza.</summary>
      <returns vsli:raw="The hash code for this instance.">Codice hash per l'istanza.</returns>
    </member>
    <member name="M:System.SequencePosition.GetInteger">
      <summary vsli:raw="Returns the integer part of this &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt;.">Restituisce la parte intera di <see cref="T:System.SequencePosition" />.</summary>
      <returns vsli:raw="The integer part of this sequence position.">Parte intera della posizione della sequenza.</returns>
    </member>
    <member name="M:System.SequencePosition.GetObject">
      <summary vsli:raw="Returns the object part of this &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt;.">Restituisce la parte oggetto di <see cref="T:System.SequencePosition" />.</summary>
      <returns vsli:raw="The object part of this sequence position.">Parte dell'oggetto della posizione della sequenza.</returns>
    </member>
    <member name="T:System.Text.EncodingExtensions">
      <summary vsli:raw="Provides extension methods for the encoding types, such as &lt;see cref=&quot;T:System.Text.Encoding&quot; /&gt;, &lt;see cref=&quot;T:System.Text.Encoder&quot; /&gt;, and &lt;see cref=&quot;T:System.Text.Decoder&quot; /&gt;.">Fornisce metodi di estensione per i tipi di codifica, ad esempio <see cref="T:System.Text.Encoding" />, <see cref="T:System.Text.Encoder" /> e <see cref="T:System.Text.Decoder" />.</summary>
    </member>
    <member name="M:System.Text.EncodingExtensions.Convert(System.Text.Decoder,System.Buffers.ReadOnlySequence{System.Byte}@,System.Buffers.IBufferWriter{System.Char},System.Boolean,System.Int64@,System.Boolean@)">
      <summary vsli:raw="Converts a &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; to UTF-16 encoded characters and writes the result to &lt;paramref name=&quot;writer&quot; /&gt;.">Converte un oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" /> in caratteri con codifica UTF-16 e scrive il risultato in <paramref name="writer" />.</summary>
      <param name="decoder" vsli:raw="The decoder instance that can convert bytes to &lt;see langword=&quot;char&quot; /&gt; values.">Istanza del decodificatore in grado di convertire i byte in valori <see langword="char" />.</param>
      <param name="bytes" vsli:raw="A sequence of bytes to decode.">Sequenza di byte da decodificare.</param>
      <param name="writer" vsli:raw="The buffer to which the decoded characters will be written.">Buffer in cui verranno scritti i caratteri decodificati.</param>
      <param name="flush" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to indicate no further data is to be converted; otherwise &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> per indicare che non esistono altri dati da convertire; in caso contrario <see langword="false" />.</param>
      <param name="charsUsed" vsli:raw="When this method returns, contains the count of characters that were written to &lt;paramref name=&quot;writer&quot; /&gt;.">Quando termina, questo metodo contiene il numero di caratteri scritti in <paramref name="writer" />.</param>
      <param name="completed" vsli:raw="When this method returns, contains &lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;decoder&quot; /&gt; contains no partial internal state; otherwise, &lt;see langword=&quot;false&quot; /&gt;.&#xA; If &lt;paramref name=&quot;flush&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;, this will always be set to &lt;see langword=&quot;true&quot; /&gt; when the method returns.">Quando termina, questo metodo contiene <see langword="true" /> se <paramref name="decoder" /> non contiene uno stato interno parziale; in caso contrario, <see langword="false" />.
Se <paramref name="flush" /> è <see langword="true" />, verrà sempre impostato su <see langword="true" /> quando il metodo termina.</param>
      <exception cref="T:System.Text.DecoderFallbackException" vsli:raw="&lt;paramref name=&quot;bytes&quot; /&gt; contains data that cannot be decoded and &lt;paramref name=&quot;decoder&quot; /&gt; is configured to throw when such data is seen.">
        <paramref name="bytes" /> contiene dati che non possono essere decodificati e <paramref name="decoder" /> è configurato per generare un'eccezione quando viene rilevato questo tipo di dati.</exception>
    </member>
    <member name="M:System.Text.EncodingExtensions.Convert(System.Text.Decoder,System.ReadOnlySpan{System.Byte},System.Buffers.IBufferWriter{System.Char},System.Boolean,System.Int64@,System.Boolean@)">
      <summary vsli:raw="Converts a &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; to chars using &lt;paramref name=&quot;decoder&quot; /&gt; and writes the result to &lt;paramref name=&quot;writer&quot; /&gt;.">Converte un oggetto <see cref="T:System.ReadOnlySpan`1" /> in caratteri usando <paramref name="decoder" /> e scrive il risultato in <paramref name="writer" />.</summary>
      <param name="decoder" vsli:raw="The decoder instance that can convert bytes to &lt;see langword=&quot;char&quot; /&gt; values.">Istanza del decodificatore in grado di convertire i byte in valori <see langword="char" />.</param>
      <param name="bytes" vsli:raw="A sequence of bytes to decode.">Sequenza di byte da decodificare.</param>
      <param name="writer" vsli:raw="The buffer to which the decoded chars will be written.">Il buffer in cui verranno scritti i caratteri decodificati.</param>
      <param name="flush" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to indicate no further data is to be converted; otherwise &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> per indicare che non esistono altri dati da convertire; in caso contrario <see langword="false" />.</param>
      <param name="charsUsed" vsli:raw="When this method returns, contains the count of &lt;see langword=&quot;char&quot; /&gt;s which were written to &lt;paramref name=&quot;writer&quot; /&gt;.">Quando termina, questo metodo contiene il numero di oggetti <see langword="char" /> scritti in <paramref name="writer" />.</param>
      <param name="completed" vsli:raw="When this method returns, contains &lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;decoder&quot; /&gt; contains no partial internal state; otherwise, &lt;see langword=&quot;false&quot; /&gt;.&#xA; If &lt;paramref name=&quot;flush&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;, this will always be set to &lt;see langword=&quot;true&quot; /&gt; when the method returns.">Quando termina, questo metodo contiene <see langword="true" /> se <paramref name="decoder" /> non contiene uno stato interno parziale; in caso contrario, <see langword="false" />.
Se <paramref name="flush" /> è <see langword="true" />, verrà sempre impostato su <see langword="true" /> quando il metodo termina.</param>
      <exception cref="T:System.Text.DecoderFallbackException" vsli:raw="&lt;paramref name=&quot;bytes&quot; /&gt; contains data that cannot be encoded and &lt;paramref name=&quot;decoder&quot; /&gt; is configured to throw when such data is seen.">
        <paramref name="bytes" /> contiene dati che non possono essere codificati e <paramref name="decoder" /> è configurato per generare un'eccezione quando viene rilevato questo tipo di dati.</exception>
    </member>
    <member name="M:System.Text.EncodingExtensions.Convert(System.Text.Encoder,System.Buffers.ReadOnlySequence{System.Char}@,System.Buffers.IBufferWriter{System.Byte},System.Boolean,System.Int64@,System.Boolean@)">
      <summary vsli:raw="Converts a &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; to encoded bytes and writes the result to &lt;paramref name=&quot;writer&quot; /&gt;.">Converte un oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" /> in byte codificati e scrive il risultato in <paramref name="writer" />.</summary>
      <param name="encoder" vsli:raw="The encoder instance that can convert &lt;see langword=&quot;char&quot; /&gt; values to bytes.">Istanza del codificatore in grado di convertire valori <see langword="char" /> in byte.</param>
      <param name="chars" vsli:raw="A sequence of characters to encode.">Sequenza di caratteri da codificare.</param>
      <param name="writer" vsli:raw="The buffer to which the encoded bytes will be written.">Buffer in cui verranno scritti i byte codificati.</param>
      <param name="flush" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to indicate no further data is to be converted; otherwise &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> per indicare che non esistono altri dati da convertire; in caso contrario <see langword="false" />.</param>
      <param name="bytesUsed" vsli:raw="When this method returns, contains the count of &lt;see langword=&quot;byte&quot; /&gt;s which were written to &lt;paramref name=&quot;writer&quot; /&gt;.">Quando termina, questo metodo contiene il numero di oggetti <see langword="byte" /> scritti in <paramref name="writer" />.</param>
      <param name="completed" vsli:raw="When this method returns, contains &lt;see langword=&quot;true&quot; /&gt; if all input up until &lt;paramref name=&quot;bytesUsed&quot; /&gt; was converted; otherwise, &lt;see langword=&quot;false&quot; /&gt;. If &lt;paramref name=&quot;flush&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;, this will always be set to &lt;see langword=&quot;true&quot; /&gt; when the method returns.">Quando termina, questo metodo contiene <see langword="true" /> se l'input fino a <paramref name="bytesUsed" /> è stato interamente convertito; in caso contrario, <see langword="false" />. Se <paramref name="flush" /> è <see langword="true" />, verrà sempre impostato su <see langword="true" /> quando il metodo termina.</param>
      <exception cref="T:System.Text.EncoderFallbackException" vsli:raw="&lt;paramref name=&quot;chars&quot; /&gt; contains data that cannot be encoded and &lt;paramref name=&quot;encoder&quot; /&gt; is configured to throw when such data is seen.">
        <paramref name="chars" /> contiene dati che non possono essere codificati e <paramref name="encoder" /> è configurato per generare un'eccezione quando viene rilevato questo tipo di dati.</exception>
    </member>
    <member name="M:System.Text.EncodingExtensions.Convert(System.Text.Encoder,System.ReadOnlySpan{System.Char},System.Buffers.IBufferWriter{System.Byte},System.Boolean,System.Int64@,System.Boolean@)">
      <summary vsli:raw="Converts a &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; to bytes using &lt;paramref name=&quot;encoder&quot; /&gt; and writes the result to &lt;paramref name=&quot;writer&quot; /&gt;.">Converte un oggetto <see cref="T:System.ReadOnlySpan`1" /> in byte usando <paramref name="encoder" /> e scrive il risultato in <paramref name="writer" />.</summary>
      <param name="encoder" vsli:raw="The encoder instance that can convert &lt;see langword=&quot;char&quot; /&gt; values to bytes.">Istanza del codificatore in grado di convertire valori <see langword="char" /> in byte.</param>
      <param name="chars" vsli:raw="A sequence of characters to encode.">Sequenza di caratteri da codificare.</param>
      <param name="writer" vsli:raw="The buffer to which the encoded bytes will be written.">Buffer in cui verranno scritti i byte codificati.</param>
      <param name="flush" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to indicate no further data is to be converted; otherwise &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> per indicare che non esistono altri dati da convertire; in caso contrario <see langword="false" />.</param>
      <param name="bytesUsed" vsli:raw="When this method returns, contains the count of &lt;see langword=&quot;byte&quot; /&gt;s which were written to &lt;paramref name=&quot;writer&quot; /&gt;.">Quando termina, questo metodo contiene il numero di oggetti <see langword="byte" /> scritti in <paramref name="writer" />.</param>
      <param name="completed" vsli:raw="When this method returns, contains &lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;encoder&quot; /&gt; contains no partial internal state; otherwise, &lt;see langword=&quot;false&quot; /&gt;.&#xA; If &lt;paramref name=&quot;flush&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;, this will always be set to &lt;see langword=&quot;true&quot; /&gt; when the method returns.">Quando termina, questo metodo contiene <see langword="true" /> se <paramref name="encoder" /> non contiene uno stato interno parziale; in caso contrario, <see langword="false" />.
Se <paramref name="flush" /> è <see langword="true" />, verrà sempre impostato su <see langword="true" /> quando il metodo termina.</param>
      <exception cref="T:System.Text.EncoderFallbackException" vsli:raw="&lt;paramref name=&quot;chars&quot; /&gt; contains data that cannot be encoded and &lt;paramref name=&quot;encoder&quot; /&gt; is configured to throw when such data is seen.">
        <paramref name="chars" /> contiene dati che non possono essere codificati e <paramref name="encoder" /> è configurato per generare un'eccezione quando viene rilevato questo tipo di dati.</exception>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetBytes(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Char}@)">
      <summary vsli:raw="Encodes the specified &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; into a &lt;see cref=&quot;T:System.Byte&quot; /&gt; array using the specified &lt;see cref=&quot;T:System.Text.Encoding&quot; /&gt;.">Codifica l'oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" /> specificato in una matrice <see cref="T:System.Byte" /> usando l'oggetto <see cref="T:System.Text.Encoding" /> specificato.</summary>
      <param name="encoding" vsli:raw="The encoding that represents how the data in &lt;paramref name=&quot;chars&quot; /&gt; should be encoded.">Codifica che rappresenta il modo in cui devono essere codificati i dati in <paramref name="chars" />.</param>
      <param name="chars" vsli:raw="The sequence to encode to bytes.">Sequenza da codificare in byte.</param>
      <exception cref="T:System.Text.EncoderFallbackException" vsli:raw="&lt;paramref name=&quot;chars&quot; /&gt; contains data that cannot be encoded and &lt;paramref name=&quot;encoding&quot; /&gt; is configured to throw when such data is seen.">
        <paramref name="chars" /> contiene dati che non possono essere codificati e <paramref name="encoding" /> è configurato per generare un'eccezione quando viene rilevato questo tipo di dati.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Byte&quot; /&gt; array that represents the encoded contents of &lt;paramref name=&quot;chars&quot; /&gt;.">Matrice <see cref="T:System.Byte" /> che rappresenta il contenuto codificato di <paramref name="chars" />.</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetBytes(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Char}@,System.Buffers.IBufferWriter{System.Byte})">
      <summary vsli:raw="Decodes the specified &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; to &lt;see langword=&quot;byte&quot; /&gt;s using the specified &lt;see cref=&quot;T:System.Text.Encoding&quot; /&gt; and writes the result to &lt;paramref name=&quot;writer&quot; /&gt;.">Decodifica l'oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" /> specificato in <see langword="byte" /> usando l'oggetto <see cref="T:System.Text.Encoding" /> specificato e scrive il risultato in <paramref name="writer" />.</summary>
      <param name="encoding" vsli:raw="The encoding that represents how the data in &lt;paramref name=&quot;chars&quot; /&gt; should be encoded.">Codifica che rappresenta il modo in cui devono essere codificati i dati in <paramref name="chars" />.</param>
      <param name="chars" vsli:raw="The &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; whose contents should be encoded.">Oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" /> di cui deve essere codificato il contenuto.</param>
      <param name="writer" vsli:raw="The buffer to which the encoded bytes will be written.">Buffer in cui verranno scritti i byte codificati.</param>
      <exception cref="T:System.Text.EncoderFallbackException" vsli:raw="&lt;paramref name=&quot;chars&quot; /&gt; contains data that cannot be encoded and &lt;paramref name=&quot;encoding&quot; /&gt; is configured to throw when such data is seen.">
        <paramref name="chars" /> contiene dati che non possono essere codificati e <paramref name="encoding" /> è configurato per generare un'eccezione quando viene rilevato questo tipo di dati.</exception>
      <returns vsli:raw="The number of bytes written to &lt;paramref name=&quot;writer&quot; /&gt;.">Numero di byte scritti in <paramref name="writer" />.</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetBytes(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Char}@,System.Span{System.Byte})">
      <summary vsli:raw="Encodes the specified &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; to &lt;see langword=&quot;byte&quot; /&gt;s using the specified &lt;see cref=&quot;T:System.Text.Encoding&quot; /&gt; and outputs the result to &lt;paramref name=&quot;bytes&quot; /&gt;.">Codifica l'oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" /> specificato in <see langword="byte" /> usando l'oggetto <see cref="T:System.Text.Encoding" /> specificato e visualizza il risultato in <paramref name="bytes" />.</summary>
      <param name="encoding" vsli:raw="The encoding that represents how the data in &lt;paramref name=&quot;chars&quot; /&gt; should be encoded.">Codifica che rappresenta il modo in cui devono essere codificati i dati in <paramref name="chars" />.</param>
      <param name="chars" vsli:raw="The sequence to encode to bytes.">Sequenza da codificare in byte.</param>
      <param name="bytes" vsli:raw="The destination buffer to which the encoded bytes will be written.">Buffer di destinazione in cui verranno scritti i byte codificati.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;bytes&quot; /&gt; is not large enough to contain the encoded form of &lt;paramref name=&quot;chars&quot; /&gt;.">
        <paramref name="bytes" /> non è sufficientemente grande da contenere il formato codificato di <paramref name="chars" />.</exception>
      <exception cref="T:System.Text.EncoderFallbackException" vsli:raw="&lt;paramref name=&quot;chars&quot; /&gt; contains data that cannot be encoded and &lt;paramref name=&quot;encoding&quot; /&gt; is configured to throw when such data is seen.">
        <paramref name="chars" /> contiene dati che non possono essere codificati e <paramref name="encoding" /> è configurato per generare un'eccezione quando viene rilevato questo tipo di dati.</exception>
      <returns vsli:raw="The number of bytes written to &lt;paramref name=&quot;bytes&quot; /&gt;.">Numero di byte scritti in <paramref name="bytes" />.</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetBytes(System.Text.Encoding,System.ReadOnlySpan{System.Char},System.Buffers.IBufferWriter{System.Byte})">
      <summary vsli:raw="Encodes the specified &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; to &lt;see langword=&quot;byte&quot; /&gt;s using the specified &lt;see cref=&quot;T:System.Text.Encoding&quot; /&gt; and writes the result to &lt;paramref name=&quot;writer&quot; /&gt;.">Codifica l'oggetto <see cref="T:System.ReadOnlySpan`1" /> specificato in <see langword="byte" /> usando l'oggetto <see cref="T:System.Text.Encoding" /> specificato e scrive il risultato in <paramref name="writer" />.</summary>
      <param name="encoding" vsli:raw="The encoding that represents how the data in &lt;paramref name=&quot;chars&quot; /&gt; should be encoded.">Codifica che rappresenta il modo in cui devono essere codificati i dati in <paramref name="chars" />.</param>
      <param name="chars" vsli:raw="The sequence to encode to bytes.">Sequenza da codificare in byte.</param>
      <param name="writer" vsli:raw="The buffer to which the encoded bytes will be written.">Buffer in cui verranno scritti i byte codificati.</param>
      <exception cref="T:System.Text.EncoderFallbackException" vsli:raw="&lt;paramref name=&quot;chars&quot; /&gt; contains data that cannot be encoded and &lt;paramref name=&quot;encoding&quot; /&gt; is configured to throw when such data is seen.">
        <paramref name="chars" /> contiene dati che non possono essere codificati e <paramref name="encoding" /> è configurato per generare un'eccezione quando viene rilevato questo tipo di dati.</exception>
      <returns vsli:raw="The number of bytes written to &lt;paramref name=&quot;writer&quot; /&gt;.">Numero di byte scritti in <paramref name="writer" />.</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetChars(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Byte}@,System.Buffers.IBufferWriter{System.Char})">
      <summary vsli:raw="Decodes the specified &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; to &lt;see langword=&quot;char&quot; /&gt;s using the specified &lt;see cref=&quot;T:System.Text.Encoding&quot; /&gt; and writes the result to &lt;paramref name=&quot;writer&quot; /&gt;.">Decodifica l'oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" /> specificato in <see langword="char" /> usando l'oggetto <see cref="T:System.Text.Encoding" /> specificato e scrive il risultato in <paramref name="writer" />.</summary>
      <param name="encoding" vsli:raw="The encoding that represents how the data in &lt;paramref name=&quot;bytes&quot; /&gt; should be decoded.">Codifica che rappresenta il modo in cui devono essere decodificati i dati in <paramref name="bytes" />.</param>
      <param name="bytes" vsli:raw="The sequence whose bytes should be decoded.">Sequenza di cui devono essere decodificati i byte.</param>
      <param name="writer" vsli:raw="The buffer to which the decoded chars will be written.">Il buffer in cui verranno scritti i caratteri decodificati.</param>
      <exception cref="T:System.Text.DecoderFallbackException" vsli:raw="&lt;paramref name=&quot;bytes&quot; /&gt; contains data that cannot be decoded and &lt;paramref name=&quot;encoding&quot; /&gt; is configured to throw when such data is seen.">
        <paramref name="bytes" /> contiene dati che non possono essere decodificati e <paramref name="encoding" /> è configurato per generare un'eccezione quando viene rilevato questo tipo di dati.</exception>
      <returns vsli:raw="The number of chars written to &lt;paramref name=&quot;writer&quot; /&gt;.">Numero di caratteri scritti in <paramref name="writer" />.</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetChars(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Byte}@,System.Span{System.Char})">
      <summary vsli:raw="Decodes the specified &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; to &lt;see langword=&quot;char&quot; /&gt;s using the specified &lt;see cref=&quot;T:System.Text.Encoding&quot; /&gt; and outputs the result to &lt;paramref name=&quot;chars&quot; /&gt;.">Decodifica l'oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" /> specificato in <see langword="char" /> usando l'oggetto <see cref="T:System.Text.Encoding" /> specificato e visualizza il risultato in <paramref name="chars" />.</summary>
      <param name="encoding" vsli:raw="The encoding that represents how the data in &lt;paramref name=&quot;bytes&quot; /&gt; is encoded.">Codifica che rappresenta il modo in cui vengono codificati i dati in <paramref name="bytes" />.</param>
      <param name="bytes" vsli:raw="The sequence to decode to characters.">Sequenza da decodificare in caratteri.</param>
      <param name="chars" vsli:raw="The destination buffer to which the decoded characters will be written.">Buffer di destinazione in cui verranno scritti i caratteri decodificati.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;chars&quot; /&gt; is not large enough to contain the encoded form of &lt;paramref name=&quot;bytes&quot; /&gt;.">
        <paramref name="chars" /> non è sufficientemente grande da contenere il formato codificato di <paramref name="bytes" />.</exception>
      <exception cref="T:System.Text.DecoderFallbackException" vsli:raw="&lt;paramref name=&quot;bytes&quot; /&gt; contains data that cannot be decoded and &lt;paramref name=&quot;encoding&quot; /&gt; is configured to throw when such data is seen.">
        <paramref name="bytes" /> contiene dati che non possono essere decodificati e <paramref name="encoding" /> è configurato per generare un'eccezione quando viene rilevato questo tipo di dati.</exception>
      <returns vsli:raw="The number of chars written to &lt;paramref name=&quot;chars&quot; /&gt;.">Numero di caratteri scritti in <paramref name="chars" />.</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetChars(System.Text.Encoding,System.ReadOnlySpan{System.Byte},System.Buffers.IBufferWriter{System.Char})">
      <summary vsli:raw="Decodes the specified &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; to &lt;see langword=&quot;char&quot; /&gt;s using the specified &lt;see cref=&quot;T:System.Text.Encoding&quot; /&gt; and writes the result to &lt;paramref name=&quot;writer&quot; /&gt;.">Decodifica l'oggetto <see cref="T:System.ReadOnlySpan`1" /> specificato in <see langword="char" /> usando l'oggetto <see cref="T:System.Text.Encoding" /> specificato e scrive il risultato in <paramref name="writer" />.</summary>
      <param name="encoding" vsli:raw="The encoding that represents how the data in &lt;paramref name=&quot;bytes&quot; /&gt; should be decoded.">Codifica che rappresenta il modo in cui devono essere decodificati i dati in <paramref name="bytes" />.</param>
      <param name="bytes" vsli:raw="The span of bytes to decode.">Intervallo di byte da decodificare.</param>
      <param name="writer" vsli:raw="The buffer to which the decoded chars will be written.">Il buffer in cui verranno scritti i caratteri decodificati.</param>
      <exception cref="T:System.Text.DecoderFallbackException" vsli:raw="&lt;paramref name=&quot;bytes&quot; /&gt; contains data that cannot be decoded and &lt;paramref name=&quot;encoding&quot; /&gt; is configured to throw when such data is seen.">
        <paramref name="bytes" /> contiene dati che non possono essere decodificati e <paramref name="encoding" /> è configurato per generare un'eccezione quando viene rilevato questo tipo di dati.</exception>
      <returns vsli:raw="The number of chars written to &lt;paramref name=&quot;writer&quot; /&gt;.">Numero di caratteri scritti in <paramref name="writer" />.</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetString(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Byte}@)">
      <summary vsli:raw="Decodes the specified &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; into a &lt;see cref=&quot;T:System.String&quot; /&gt; using the specified &lt;see cref=&quot;T:System.Text.Encoding&quot; /&gt;.">Decodifica l'oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" /> specificato in una <see cref="T:System.String" /> usando l'oggetto <see cref="T:System.Text.Encoding" /> specificato.</summary>
      <param name="encoding" vsli:raw="The encoding that represents how the data in &lt;paramref name=&quot;bytes&quot; /&gt; is encoded.">Codifica che rappresenta il modo in cui vengono codificati i dati in <paramref name="bytes" />.</param>
      <param name="bytes" vsli:raw="The sequence to decode into characters.">Sequenza da decodificare in caratteri.</param>
      <exception cref="T:System.Text.DecoderFallbackException" vsli:raw="&lt;paramref name=&quot;bytes&quot; /&gt; contains data that cannot be decoded and &lt;paramref name=&quot;encoding&quot; /&gt; is configured to throw when such data is seen.">
        <paramref name="bytes" /> contiene dati che non possono essere decodificati e <paramref name="encoding" /> è configurato per generare un'eccezione quando viene rilevato questo tipo di dati.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.String&quot; /&gt; which represents the decoded contents of &lt;paramref name=&quot;bytes&quot; /&gt;.">Oggetto <see cref="T:System.String" /> che rappresenta il contenuto decodificato di <paramref name="bytes" />.</returns>
    </member>
    <member name="T:System.Text.SpanRuneEnumerator">
      <summary vsli:raw="Provides an enumerator for the &lt;see cref=&quot;T:System.Text.Rune&quot; /&gt; values represented by a span containing UTF-16 text.">Fornisce un enumeratore per i valori di <see cref="T:System.Text.Rune" /> rappresentati da un intervallo contenente testo UTF-16.</summary>
    </member>
    <member name="M:System.Text.SpanRuneEnumerator.GetEnumerator">
      <summary vsli:raw="Returns the current enumerator instance.">Restituisce l'istanza dell'enumeratore corrente.</summary>
      <returns vsli:raw="The current enumerator instance.">Istanza dell'enumeratore corrente.</returns>
    </member>
    <member name="M:System.Text.SpanRuneEnumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next &lt;see cref=&quot;T:System.Text.Rune&quot; /&gt; of the span.">Sposta l'enumeratore all'elemento <see cref="T:System.Text.Rune" /> successivo dell'intervallo.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator successfully advanced to the next item; &lt;see langword=&quot;false&quot; /&gt; if the end of the span has been reached.">
        <see langword="true" /> se l'enumeratore è stato spostato correttamente all'elemento successivo; <see langword="false" /> se è stata raggiunta la fine dell'intervallo.</returns>
    </member>
    <member name="P:System.Text.SpanRuneEnumerator.Current">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Text.Rune&quot; /&gt; at the current position of the enumerator.">Ottiene l'oggetto <see cref="T:System.Text.Rune" /> in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Text.Rune&quot; /&gt; at the current position of the enumerator.">Oggetto <see cref="T:System.Text.Rune" /> in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
  </members>
</doc>