<?xml version="1.0" encoding="utf-8"?>
<doc xmlns:vsli="https://github.com/sk-0520/vs-localized-intellisense/tree/master/schema/2024">
  <assembly>
    <name>System.Memory</name>
  </assembly>
  <members>
    <member name="T:System.Buffers.ArrayBufferWriter`1">
      <summary vsli:raw="Represents a heap-based, array-backed output sink into which &lt;typeparamref name=&quot;T&quot; /&gt; data can be written.">Stellt eine heapbasierte, arraygesicherte Ausgabesenke dar, in die <typeparam name="T" /> Daten geschrieben werden können.</summary>
      <typeparam name="T" vsli:raw="The type of the items in this &lt;see cref=&quot;T:System.Buffers.ArrayBufferWriter`1&quot; /&gt; instance.">Der Typ der Elemente in dieser <see cref="T:System.Buffers.ArrayBufferWriter`1" /> Instanz.</typeparam>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.#ctor">
      <summary vsli:raw="Creates an instance of an &lt;see cref=&quot;T:System.Buffers.ArrayBufferWriter`1&quot; /&gt; to which data can be written, with the default initial capacity.">Erstellt eine <see cref="T:System.Buffers.ArrayBufferWriter`1" />-Instanz, in die Daten geschrieben werden können, mit der standardmäßigen Anfangskapazität.</summary>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.#ctor(System.Int32)">
      <summary vsli:raw="Creates an instance of an &lt;see cref=&quot;T:System.Buffers.ArrayBufferWriter`1&quot; /&gt; to which data can be written, with a specified initial capacity.">Erstellt eine <see cref="T:System.Buffers.ArrayBufferWriter`1" />-Instanz, in die Daten geschrieben werden können, mit einer angegebenen Anfangskapazität.</summary>
      <param name="initialCapacity" vsli:raw="The minimum capacity with which to initialize the underlying buffer.">Die Mindestkapazität zum Initialisieren der zugrunde liegenden Puffer.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;initialCapacity&quot; /&gt; is less than or equal to 0.">
        <paramref name="initialCapacity" /> ist kleiner oder gleich 0.</exception>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.Advance(System.Int32)">
      <summary vsli:raw="Notifies the &lt;see cref=&quot;T:System.Buffers.IBufferWriter`1&quot; /&gt; that &lt;paramref name=&quot;count&quot; /&gt; items were written to the output &lt;see cref=&quot;T:System.Span`1&quot; /&gt;/&lt;see cref=&quot;T:System.Memory`1&quot; /&gt;.">Teilt <see cref="T:System.Buffers.IBufferWriter`1" /> mit, dass <paramref name="count" /> Elemente in die Ausgabe <see cref="T:System.Span`1" />/<see cref="T:System.Memory`1" /> geschrieben wurden.</summary>
      <param name="count" vsli:raw="The number of items written.">Die Anzahl der geschriebenen Elemente.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;count&quot; /&gt; is negative.">
        <paramref name="count" /> ist ein negativer Wert.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method call attempts to advance past the end of the underlying buffer.">Der Methodenaufruf versucht, hinter das Ende des zugrunde liegenden Puffer zu gelangen.</exception>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.Clear">
      <summary vsli:raw="Clears the data written to the underlying buffer.">Löscht die in den zugrunde liegenden Puffer geschriebenen Daten.</summary>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.GetMemory(System.Int32)">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Memory`1&quot; /&gt; to write to that is at least the length specified by &lt;paramref name=&quot;sizeHint&quot; /&gt;.">Gibt ein <see cref="T:System.Memory`1" />-Element zurück, in das geschrieben werden kann, das mindestens die durch <paramref name="sizeHint" /> angegebene Länge aufweist.</summary>
      <param name="sizeHint" vsli:raw="The minimum requested length of the &lt;see cref=&quot;T:System.Memory`1&quot; /&gt;.">Die mindestens angeforderte Länge von <see cref="T:System.Memory`1" />.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;sizeHint&quot; /&gt; is negative.">
        <paramref name="sizeHint" /> ist ein negativer Wert.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Memory`1&quot; /&gt; whose length is at least &lt;paramref name=&quot;sizeHint&quot; /&gt;.  If &lt;paramref name=&quot;sizeHint&quot; /&gt; is not provided or is equal to 0, some non-empty buffer is returned.">Ein <see cref="T:System.Memory`1" />-Element, dessen Länge mindestens <paramref name="sizeHint" /> beträgt.  Wenn <paramref name="sizeHint" /> nicht angegeben oder gleich null (0) ist, wird ein nicht leerer Puffer zurückgegeben.</returns>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.GetSpan(System.Int32)">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Span`1&quot; /&gt; to write to that is at least a specified length.">Gibt ein <see cref="T:System.Span`1" />-Element zurück, in das geschrieben werden kann, das mindestens die angegebene Länge aufweist.</summary>
      <param name="sizeHint" vsli:raw="The minimum requested length of the &lt;see cref=&quot;T:System.Span`1&quot; /&gt;.">Die mindestens angeforderte Länge von <see cref="T:System.Span`1" />.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;sizeHint&quot; /&gt; is negative.">
        <paramref name="sizeHint" /> ist ein negativer Wert.</exception>
      <returns vsli:raw="A span of at least &lt;paramref name=&quot;sizeHint&quot; /&gt; in length. If &lt;paramref name=&quot;sizeHint&quot; /&gt; is not provided or is equal to 0, some non-empty buffer is returned.">Eine Spanne mit einer Länge von mindestens <paramref name="sizeHint" />. Wenn <paramref name="sizeHint" /> nicht angegeben oder gleich null (0) ist, wird ein nicht leerer Puffer zurückgegeben.</returns>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.Capacity">
      <summary vsli:raw="Gets the total amount of space within the underlying buffer.">Ruft die Gesamtmenge des Speicherplatzes im zugrunde liegenden Puffer ab.</summary>
      <returns vsli:raw="The total capacity of the underlying buffer.">Die Gesamtkapazität des zugrunde liegenden Puffers.</returns>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.FreeCapacity">
      <summary vsli:raw="Gets the amount of available space that can be written to without forcing the underlying buffer to grow.">Ruft die Menge des verfügbaren Speicherplatzes ab, in den geschrieben werden kann, ohne dass der zugrunde liegende Puffer gezwungen wird, zu wachsen.</summary>
      <returns vsli:raw="The space available for writing without forcing the underlying buffer to grow.">Der zum Schreiben verfügbare Speicherplatz, ohne dass der zugrunde liegende Puffer vergrößert werden soll.</returns>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.WrittenCount">
      <summary vsli:raw="Gets the amount of data written to the underlying buffer.">Ruft die Menge der in den zugrunde liegenden Puffer geschriebenen Daten ab.</summary>
      <returns vsli:raw="The amount of data written to the underlying buffer.">Die Menge der Daten, die in den zugrunde liegenden Puffer geschrieben werden.</returns>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.WrittenMemory">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt; that contains the data written to the underlying buffer so far.">Ruft ein <see cref="T:System.ReadOnlyMemory`1" />-Element auf, das die bisher in den zugrunde liegenden Puffer geschriebenen Daten enthält.</summary>
      <returns vsli:raw="The data written to the underlying buffer.">Die Daten, die in den zugrunde liegenden Puffer geschrieben werden.</returns>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.WrittenSpan">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; that contains the data written to the underlying buffer so far.">Ruft ein <see cref="T:System.ReadOnlySpan`1" />-Element auf, das die bisher in den zugrunde liegenden Puffer geschriebenen Daten enthält.</summary>
      <returns vsli:raw="The data written to the underlying buffer.">Die Daten, die in den zugrunde liegenden Puffer geschrieben werden.</returns>
    </member>
    <member name="T:System.Buffers.Binary.BinaryPrimitives">
      <summary vsli:raw="Reads bytes as primitives with specific endianness.">Liest Bytes als primitive Werte mit einer bestimmten Bytereihenfolge</summary>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadDoubleBigEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.Double&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Liest eine <see cref="T:System.Double" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als big-endian-Wert</summary>
      <param name="source" vsli:raw="The read-only span to read.">Der zu lesende schreibgeschützte Bereich</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.Double&quot; /&gt;.">
        <paramref name="source" /> ist zu klein für eine <see cref="T:System.Double" />-Struktur.</exception>
      <returns vsli:raw="The big endian value.">Der big-endian-Wert</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadDoubleLittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.Double&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Liest eine <see cref="T:System.Double" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als Little-Endian-Wert</summary>
      <param name="source" vsli:raw="The read-only span to read.">Der zu lesende schreibgeschützte Bereich</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.Double&quot; /&gt;.">
        <paramref name="source" /> ist zu klein für eine <see cref="T:System.Double" />-Struktur.</exception>
      <returns vsli:raw="The little endian value.">Der Little-Endian-Wert</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt16BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int16&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Liest eine <see cref="T:System.Int16" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als big-endian-Wert</summary>
      <param name="source" vsli:raw="The read-only span to read.">Der zu lesende schreibgeschützte Bereich</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int16&quot; /&gt;.">
        <paramref name="source" /> ist zu klein für eine <see cref="T:System.Int16" />-Struktur.</exception>
      <returns vsli:raw="The big endian value.">Der big-endian-Wert</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt16LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int16&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Liest eine <see cref="T:System.Int16" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als Little-Endian-Wert</summary>
      <param name="source" vsli:raw="The read-only span to read.">Der zu lesende schreibgeschützte Bereich</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int16&quot; /&gt;.">
        <paramref name="source" /> ist zu klein für eine <see cref="T:System.Int16" />-Struktur.</exception>
      <returns vsli:raw="The little endian value.">Der Little-Endian-Wert</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt32BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int32&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Liest eine <see cref="T:System.Int32" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als big-endian-Wert</summary>
      <param name="source" vsli:raw="The read-only span to read.">Der zu lesende schreibgeschützte Bereich</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int32&quot; /&gt;.">
        <paramref name="source" /> ist zu klein für eine <see cref="T:System.Int32" />-Struktur.</exception>
      <returns vsli:raw="The big endian value.">Der big-endian-Wert</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt32LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int32&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Liest eine <see cref="T:System.Int32" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als Little-Endian-Wert</summary>
      <param name="source" vsli:raw="The read-only span to read.">Der zu lesende schreibgeschützte Bereich</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int32&quot; /&gt;.">
        <paramref name="source" /> ist zu klein für eine <see cref="T:System.Int32" />-Struktur.</exception>
      <returns vsli:raw="The little endian value.">Der Little-Endian-Wert</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt64BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int64&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Liest eine <see cref="T:System.Int64" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als big-endian-Wert</summary>
      <param name="source" vsli:raw="The read-only span to read.">Der zu lesende schreibgeschützte Bereich</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int64&quot; /&gt;.">
        <paramref name="source" /> ist zu klein für eine <see cref="T:System.Int64" />-Struktur.</exception>
      <returns vsli:raw="The big endian value.">Der big-endian-Wert</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt64LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int64&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Liest eine <see cref="T:System.Int64" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als Little-Endian-Wert</summary>
      <param name="source" vsli:raw="The read-only span to read.">Der zu lesende schreibgeschützte Bereich</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int64&quot; /&gt;.">
        <paramref name="source" /> ist zu klein für eine <see cref="T:System.Int64" />-Struktur.</exception>
      <returns vsli:raw="The little endian value.">Der Little-Endian-Wert</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadSingleBigEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.Single&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Liest eine <see cref="T:System.Single" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als big-endian-Wert</summary>
      <param name="source" vsli:raw="The read-only span to read.">Der zu lesende schreibgeschützte Bereich</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.Single&quot; /&gt;.">
        <paramref name="source" /> ist zu klein für eine <see cref="T:System.Single" />-Struktur.</exception>
      <returns vsli:raw="The big endian value.">Der big-endian-Wert</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadSingleLittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.Single&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Liest eine <see cref="T:System.Single" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als Little-Endian-Wert</summary>
      <param name="source" vsli:raw="The read-only span to read.">Der zu lesende schreibgeschützte Bereich</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.Single&quot; /&gt;.">
        <paramref name="source" /> ist zu klein für eine <see cref="T:System.Single" />-Struktur.</exception>
      <returns vsli:raw="The little endian value.">Der Little-Endian-Wert</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt16BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Liest eine <see cref="T:System.UInt16" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als big-endian-Wert</summary>
      <param name="source" vsli:raw="The read-only span to read.">Der zu lesende schreibgeschützte Bereich</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt16&quot; /&gt;.">
        <paramref name="source" /> ist zu klein für eine <see cref="T:System.UInt16" />-Struktur.</exception>
      <returns vsli:raw="The big endian value.">Der big-endian-Wert</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt16LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Liest eine <see cref="T:System.UInt16" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als Little-Endian-Wert</summary>
      <param name="source" vsli:raw="The read-only span to read.">Der zu lesende schreibgeschützte Bereich</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt16&quot; /&gt;.">
        <paramref name="source" /> ist zu klein für eine <see cref="T:System.UInt16" />-Struktur.</exception>
      <returns vsli:raw="The little endian value.">Der Little-Endian-Wert</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt32BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Liest eine <see cref="T:System.UInt32" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als big-endian-Wert</summary>
      <param name="source" vsli:raw="The read-only span to read.">Der zu lesende schreibgeschützte Bereich</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt32&quot; /&gt;.">
        <paramref name="source" /> ist zu klein für eine <see cref="T:System.UInt32" />-Struktur.</exception>
      <returns vsli:raw="The big endian value.">Der big-endian-Wert</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt32LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Liest eine <see cref="T:System.UInt32" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als Little-Endian-Wert</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Der schreibgeschützte Bereich der zu lesenden Bytes</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt32&quot; /&gt;.">
        <paramref name="source" /> ist zu klein für eine <see cref="T:System.UInt32" />-Struktur.</exception>
      <returns vsli:raw="The little endian value.">Der Little-Endian-Wert</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt64BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Liest eine <see cref="T:System.UInt64" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als big-endian-Wert</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Der schreibgeschützte Bereich der zu lesenden Bytes</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt64&quot; /&gt;.">
        <paramref name="source" /> ist zu klein für eine <see cref="T:System.UInt64" />-Struktur.</exception>
      <returns vsli:raw="The big endian value.">Der big-endian-Wert</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt64LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Liest eine <see cref="T:System.UInt64" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als Little-Endian-Wert</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Der schreibgeschützte Bereich der zu lesenden Bytes</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt64&quot; /&gt;.">
        <paramref name="source" /> ist zu klein für eine <see cref="T:System.UInt64" />-Struktur.</exception>
      <returns vsli:raw="The little endian value.">Der Little-Endian-Wert</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Byte)">
      <summary vsli:raw="Reverses a primitive value by performing an endianness swap of the specified &lt;see cref=&quot;T:System.Byte&quot; /&gt; value, which effectively does nothing for a &lt;see cref=&quot;T:System.Byte&quot; /&gt;.">Kehrt einen primitiven Wert um, indem die Bytereihenfolge des angegebenen <see cref="T:System.Byte" />-Werts geändert wird, der nicht für eine <see cref="T:System.Byte" />-Struktur benötigt wird</summary>
      <param name="value" vsli:raw="The value to reverse.">Der umzukehrende Wert</param>
      <returns vsli:raw="The passed-in value, unmodified.">Der übergebene Wert in unveränderter Form</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int16)">
      <summary vsli:raw="Reverses a primitive value by performing an endianness swap of the specified &lt;see cref=&quot;T:System.Int16&quot; /&gt; value.">Kehrt einen primitiven Wert um, indem die Bytereihenfolge des angegebenen <see cref="T:System.Int16" />-Werts geändert wird</summary>
      <param name="value" vsli:raw="The value to reverse.">Der umzukehrende Wert</param>
      <returns vsli:raw="The reversed value.">Der umgekehrte Wert</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int32)">
      <summary vsli:raw="Reverses a primitive value by performing an endianness swap of the specified &lt;see cref=&quot;T:System.Int32&quot; /&gt; value.">Kehrt einen primitiven Wert um, indem die Bytereihenfolge des angegebenen <see cref="T:System.Int32" />-Werts geändert wird</summary>
      <param name="value" vsli:raw="The value to reverse.">Der umzukehrende Wert</param>
      <returns vsli:raw="The reversed value.">Der umgekehrte Wert</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int64)">
      <summary vsli:raw="Reverses a primitive value by performing an endianness swap of the specified &lt;see cref=&quot;T:System.Int64&quot; /&gt; value.">Kehrt einen primitiven Wert um, indem die Bytereihenfolge des angegebenen <see cref="T:System.Int64" />-Werts geändert wird</summary>
      <param name="value" vsli:raw="The value to reverse.">Der umzukehrende Wert</param>
      <returns vsli:raw="The reversed value.">Der umgekehrte Wert</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.SByte)">
      <summary vsli:raw="Reverses a primitive value by performing an endianness swap of the specified &lt;see cref=&quot;T:System.SByte&quot; /&gt; value, which effectively does nothing for an &lt;see cref=&quot;T:System.SByte&quot; /&gt;.">Kehrt einen primitiven Wert um, indem die Bytereihenfolge des angegebenen <see cref="T:System.SByte" />-Werts geändert wird, der nicht für eine <see cref="T:System.SByte" />-Struktur benötigt wird</summary>
      <param name="value" vsli:raw="The value to reverse.">Der umzukehrende Wert</param>
      <returns vsli:raw="The passed-in value, unmodified.">Der übergebene Wert in unveränderter Form</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt16)">
      <summary vsli:raw="Reverses a primitive value by performing an endianness swap of the specified &lt;see cref=&quot;T:System.UInt16&quot; /&gt; value.">Kehrt einen primitiven Wert um, indem die Bytereihenfolge des angegebenen <see cref="T:System.UInt16" />-Werts geändert wird</summary>
      <param name="value" vsli:raw="The value to reverse.">Der umzukehrende Wert</param>
      <returns vsli:raw="The reversed value.">Der umgekehrte Wert</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt32)">
      <summary vsli:raw="Reverses a primitive value by performing an endianness swap of the specified &lt;see cref=&quot;T:System.UInt32&quot; /&gt; value.">Kehrt einen primitiven Wert um, indem die Bytereihenfolge des angegebenen <see cref="T:System.UInt32" />-Werts geändert wird</summary>
      <param name="value" vsli:raw="The value to reverse.">Der umzukehrende Wert</param>
      <returns vsli:raw="The reversed value.">Der umgekehrte Wert</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt64)">
      <summary vsli:raw="Reverses a primitive value by performing an endianness swap of the specified &lt;see cref=&quot;T:System.UInt64&quot; /&gt; value.">Kehrt einen primitiven Wert um, indem die Bytereihenfolge des angegebenen <see cref="T:System.UInt64" />-Werts geändert wird</summary>
      <param name="value" vsli:raw="The value to reverse.">Der umzukehrende Wert</param>
      <returns vsli:raw="The reversed value.">Der umgekehrte Wert</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadDoubleBigEndian(System.ReadOnlySpan{System.Byte},System.Double@)">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.Double&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Liest eine <see cref="T:System.Double" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als big-endian-Wert</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Der schreibgeschützte Bereich der zu lesenden Bytes</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as big endian.">Wenn diese Methode zurückgegeben wird, enthält sie den Wert, der aus dem schreibgeschützten Bytebereich als Big-Endian-Wert gelesen wird.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.Double&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Double" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadDoubleLittleEndian(System.ReadOnlySpan{System.Byte},System.Double@)">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.Double&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Liest eine <see cref="T:System.Double" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als Little-Endian-Wert</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Der schreibgeschützte Bereich der zu lesenden Bytes</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as little endian.">Wenn diese Methode zurückgegeben wird, enthält sie den Wert, der aus dem schreibgeschützten Bytebereich als Little-Endian-Wert gelesen wird.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.Double&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Double" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt16BigEndian(System.ReadOnlySpan{System.Byte},System.Int16@)">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int16&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Liest eine <see cref="T:System.Int16" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als big-endian-Wert</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Der schreibgeschützte Bereich der zu lesenden Bytes</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as big endian.">Wenn diese Methode zurückgegeben wird, wird der Wert aus dem schreibgeschützten Bytebereich als big-endian-Wert gelesen.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int16&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Int16" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt16LittleEndian(System.ReadOnlySpan{System.Byte},System.Int16@)">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int16&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Liest eine <see cref="T:System.Int16" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als Little-Endian-Wert</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Der schreibgeschützte Bereich der zu lesenden Bytes</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as little endian.">Wenn diese Methode zurückgegeben wird, wird der Wert aus dem schreibgeschützten Bytebereich als Little-Endian-Wert gelesen.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int16&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Int16" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt32BigEndian(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int32&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Liest eine <see cref="T:System.Int32" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als big-endian-Wert</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Der schreibgeschützte Bereich der zu lesenden Bytes</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as big endian.">Wenn diese Methode zurückgegeben wird, wird der Wert aus dem schreibgeschützten Bytebereich als big-endian-Wert gelesen.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int32&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Int32" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt32LittleEndian(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int32&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Liest eine <see cref="T:System.Int32" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als Little-Endian-Wert</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Der schreibgeschützte Bereich der zu lesenden Bytes</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as little endian.">Wenn diese Methode zurückgegeben wird, wird der Wert aus dem schreibgeschützten Bytebereich als Little-Endian-Wert gelesen.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int32&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Int32" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt64BigEndian(System.ReadOnlySpan{System.Byte},System.Int64@)">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int64&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Liest eine <see cref="T:System.Int64" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als big-endian-Wert</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Der schreibgeschützte Bereich der zu lesenden Bytes</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as big endian.">Wenn diese Methode zurückgegeben wird, wird der Wert aus dem schreibgeschützten Bytebereich als big-endian-Wert gelesen.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int64&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Int64" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt64LittleEndian(System.ReadOnlySpan{System.Byte},System.Int64@)">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int64&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Liest eine <see cref="T:System.Int64" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als Little-Endian-Wert</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Der schreibgeschützte Bereich der zu lesenden Bytes</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as little endian.">Wenn diese Methode zurückgegeben wird, wird der Wert aus dem schreibgeschützten Bytebereich als Little-Endian-Wert gelesen.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int64&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Int64" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadSingleBigEndian(System.ReadOnlySpan{System.Byte},System.Single@)">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.Single&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Liest eine <see cref="T:System.Single" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als big-endian-Wert</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Der schreibgeschützte Bereich der zu lesenden Bytes</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as big endian.">Wenn diese Methode zurückgegeben wird, enthält sie den Wert, der aus dem schreibgeschützten Bytebereich als Big-Endian-Wert gelesen wird.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.Single&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Single" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadSingleLittleEndian(System.ReadOnlySpan{System.Byte},System.Single@)">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.Single&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Liest eine <see cref="T:System.Single" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als Little-Endian-Wert</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Der schreibgeschützte Bereich der zu lesenden Bytes</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as little endian.">Wenn diese Methode zurückgegeben wird, enthält sie den Wert, der aus dem schreibgeschützten Bytebereich als Little-Endian-Wert gelesen wird.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.Single&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Single" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt16BigEndian(System.ReadOnlySpan{System.Byte},System.UInt16@)">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Liest eine <see cref="T:System.UInt16" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als big-endian-Wert</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Der schreibgeschützte Bereich der zu lesenden Bytes</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as big endian.">Wenn diese Methode zurückgegeben wird, wird der Wert aus dem schreibgeschützten Bytebereich als big-endian-Wert gelesen.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt16&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.UInt16" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt16LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt16@)">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Liest eine <see cref="T:System.UInt16" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als Little-Endian-Wert</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Der schreibgeschützte Bereich der zu lesenden Bytes</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as little endian.">Wenn diese Methode zurückgegeben wird, wird der Wert aus dem schreibgeschützten Bytebereich als Little-Endian-Wert gelesen.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt16&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.UInt16" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt32BigEndian(System.ReadOnlySpan{System.Byte},System.UInt32@)">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Liest eine <see cref="T:System.UInt32" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als big-endian-Wert</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Der schreibgeschützte Bereich der zu lesenden Bytes</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as big endian.">Wenn diese Methode zurückgegeben wird, wird der Wert aus dem schreibgeschützten Bytebereich als big-endian-Wert gelesen.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt32&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.UInt32" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt32LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt32@)">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Liest eine <see cref="T:System.UInt32" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als Little-Endian-Wert</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Der schreibgeschützte Bereich der zu lesenden Bytes</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as little endian.">Wenn diese Methode zurückgegeben wird, wird der Wert aus dem schreibgeschützten Bytebereich als Little-Endian-Wert gelesen.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt32&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.UInt32" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt64BigEndian(System.ReadOnlySpan{System.Byte},System.UInt64@)">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Liest eine <see cref="T:System.UInt64" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als big-endian-Wert</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Der schreibgeschützte Bereich der zu lesenden Bytes</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as big endian.">Wenn diese Methode zurückgegeben wird, wird der Wert aus dem schreibgeschützten Bytebereich als big-endian-Wert gelesen.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt64&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.UInt64" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt64LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt64@)">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Liest eine <see cref="T:System.UInt64" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als Little-Endian-Wert</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Der schreibgeschützte Bereich der zu lesenden Bytes</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as little endian.">Wenn diese Methode zurückgegeben wird, wird der Wert aus dem schreibgeschützten Bytebereich als Little-Endian-Wert gelesen.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt64&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.UInt64" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteDoubleBigEndian(System.Span{System.Byte},System.Double)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.Double&quot; /&gt; into a span of bytes, as big endian.">Schreibt eine <see cref="T:System.Double" />-Struktur als big-endian-Wert in einen Bytebereich</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Der Bytebereich, in den der Wert als big-endian-Wert geschrieben werden soll</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.Double&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Double" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteDoubleLittleEndian(System.Span{System.Byte},System.Double)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.Double&quot; /&gt; into a span of bytes, as little endian.">Schreibt eine <see cref="T:System.Double" />-Struktur als Little-Endian-Wert in einen Bytebereich</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Der Bytebereich, in den der Wert als Little-Endian-Wert geschrieben werden soll</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.Double&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Double" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt16BigEndian(System.Span{System.Byte},System.Int16)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int16&quot; /&gt; into a span of bytes, as big endian.">Schreibt eine <see cref="T:System.Int16" />-Struktur als big-endian-Wert in einen Bytebereich</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Der Bytebereich, in den der Wert als big-endian-Wert geschrieben werden soll</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int16&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Int16" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt16LittleEndian(System.Span{System.Byte},System.Int16)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int16&quot; /&gt; into a span of bytes, as little endian.">Schreibt eine <see cref="T:System.Int16" />-Struktur als Little-Endian-Wert in einen Bytebereich</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Der Bytebereich, in den der Wert als Little-Endian-Wert geschrieben werden soll</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int16&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Int16" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt32BigEndian(System.Span{System.Byte},System.Int32)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int32&quot; /&gt; into a span of bytes, as big endian.">Schreibt eine <see cref="T:System.Int32" />-Struktur als big-endian-Wert in einen Bytebereich</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Der Bytebereich, in den der Wert als big-endian-Wert geschrieben werden soll</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int32&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Int32" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt32LittleEndian(System.Span{System.Byte},System.Int32)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int32&quot; /&gt; into a span of bytes, as little endian.">Schreibt eine <see cref="T:System.Int32" />-Struktur als Little-Endian-Wert in einen Bytebereich</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Der Bytebereich, in den der Wert als Little-Endian-Wert geschrieben werden soll</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int32&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Int32" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt64BigEndian(System.Span{System.Byte},System.Int64)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int64&quot; /&gt; into a span of bytes, as big endian.">Schreibt eine <see cref="T:System.Int64" />-Struktur als big-endian-Wert in einen Bytebereich</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Der Bytebereich, in den der Wert als big-endian-Wert geschrieben werden soll</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int64&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Int64" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt64LittleEndian(System.Span{System.Byte},System.Int64)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int64&quot; /&gt; into a span of bytes, as little endian.">Schreibt eine <see cref="T:System.Int64" />-Struktur als Little-Endian-Wert in einen Bytebereich</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Der Bytebereich, in den der Wert als Little-Endian-Wert geschrieben werden soll</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int64&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Int64" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteSingleBigEndian(System.Span{System.Byte},System.Single)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.Single&quot; /&gt; into a span of bytes, as big endian.">Schreibt eine <see cref="T:System.Single" />-Struktur als big-endian-Wert in einen Bytebereich</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Der Bytebereich, in den der Wert als big-endian-Wert geschrieben werden soll</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.Single&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Single" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteSingleLittleEndian(System.Span{System.Byte},System.Single)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.Single&quot; /&gt; into a span of bytes, as little endian.">Schreibt eine <see cref="T:System.Single" />-Struktur als Little-Endian-Wert in einen Bytebereich</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Der Bytebereich, in den der Wert als Little-Endian-Wert geschrieben werden soll</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.Single&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Single" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt16BigEndian(System.Span{System.Byte},System.UInt16)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; into a span of bytes, as big endian.">Schreibt eine <see cref="T:System.UInt16" />-Struktur als big-endian-Wert in einen Bytebereich</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Der Bytebereich, in den der Wert als big-endian-Wert geschrieben werden soll</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt16&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.UInt16" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt16LittleEndian(System.Span{System.Byte},System.UInt16)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; into a span of bytes, as little endian.">Schreibt eine <see cref="T:System.UInt16" />-Struktur als Little-Endian-Wert in einen Bytebereich</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Der Bytebereich, in den der Wert als Little-Endian-Wert geschrieben werden soll</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt16&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.UInt16" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt32BigEndian(System.Span{System.Byte},System.UInt32)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; into a span of bytes, as big endian.">Schreibt eine <see cref="T:System.UInt32" />-Struktur als big-endian-Wert in einen Bytebereich</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Der Bytebereich, in den der Wert als big-endian-Wert geschrieben werden soll</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt32&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.UInt32" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt32LittleEndian(System.Span{System.Byte},System.UInt32)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; into a span of bytes, as little endian.">Schreibt eine <see cref="T:System.UInt32" />-Struktur als Little-Endian-Wert in einen Bytebereich</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Der Bytebereich, in den der Wert als Little-Endian-Wert geschrieben werden soll</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt32&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.UInt32" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt64BigEndian(System.Span{System.Byte},System.UInt64)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; into a span of bytes, as big endian.">Schreibt eine <see cref="T:System.UInt64" />-Struktur als big-endian-Wert in einen Bytebereich</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Der Bytebereich, in den der Wert als big-endian-Wert geschrieben werden soll</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt64&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.UInt64" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt64LittleEndian(System.Span{System.Byte},System.UInt64)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; into a span of bytes, as little endian.">Schreibt eine <see cref="T:System.UInt64" />-Struktur als Little-Endian-Wert in einen Bytebereich</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Der Bytebereich, in den der Wert als Little-Endian-Wert geschrieben werden soll</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt64&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.UInt64" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteDoubleBigEndian(System.Span{System.Byte},System.Double)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.Double&quot; /&gt; into a span of bytes, as big endian.">Schreibt eine <see cref="T:System.Double" />-Struktur als big-endian-Wert in einen Bytebereich</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Der Bytebereich, in den der Wert als big-endian-Wert geschrieben werden soll</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.Double&quot; /&gt;.">
        <paramref name="destination" /> ist zu klein für eine <see cref="T:System.Double" />-Struktur.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteDoubleLittleEndian(System.Span{System.Byte},System.Double)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.Double&quot; /&gt; into a span of bytes, as little endian.">Schreibt eine <see cref="T:System.Double" />-Struktur als Little-Endian-Wert in einen Bytebereich</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Der Bytebereich, in den der Wert als Little-Endian-Wert geschrieben werden soll</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.Double&quot; /&gt;.">
        <paramref name="destination" /> ist zu klein für eine <see cref="T:System.Double" />-Struktur.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt16BigEndian(System.Span{System.Byte},System.Int16)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int16&quot; /&gt; into a span of bytes, as big endian.">Schreibt eine <see cref="T:System.Int16" />-Struktur als big-endian-Wert in einen Bytebereich</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Der Bytebereich, in den der Wert als big-endian-Wert geschrieben werden soll</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int16&quot; /&gt;.">
        <paramref name="destination" /> ist zu klein für eine <see cref="T:System.Int16" />-Struktur.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt16LittleEndian(System.Span{System.Byte},System.Int16)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int16&quot; /&gt; into a span of bytes, as little endian.">Schreibt eine <see cref="T:System.Int16" />-Struktur als Little-Endian-Wert in einen Bytebereich</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Der Bytebereich, in den der Wert als Little-Endian-Wert geschrieben werden soll</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int16&quot; /&gt;.">
        <paramref name="destination" /> ist zu klein für eine <see cref="T:System.Int16" />-Struktur.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt32BigEndian(System.Span{System.Byte},System.Int32)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int32&quot; /&gt; into a span of bytes, as big endian.">Schreibt eine <see cref="T:System.Int32" />-Struktur als big-endian-Wert in einen Bytebereich</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Der Bytebereich, in den der Wert als big-endian-Wert geschrieben werden soll</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int32&quot; /&gt;.">
        <paramref name="destination" /> ist zu klein für eine <see cref="T:System.Int32" />-Struktur.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt32LittleEndian(System.Span{System.Byte},System.Int32)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int32&quot; /&gt; into a span of bytes, as little endian.">Schreibt eine <see cref="T:System.Int32" />-Struktur als Little-Endian-Wert in einen Bytebereich</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Der Bytebereich, in den der Wert als Little-Endian-Wert geschrieben werden soll</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int32&quot; /&gt;.">
        <paramref name="destination" /> ist zu klein für eine <see cref="T:System.Int32" />-Struktur.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt64BigEndian(System.Span{System.Byte},System.Int64)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int64&quot; /&gt; into a span of bytes, as big endian.">Schreibt eine <see cref="T:System.Int64" />-Struktur als big-endian-Wert in einen Bytebereich</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Der Bytebereich, in den der Wert als big-endian-Wert geschrieben werden soll</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int64&quot; /&gt;.">
        <paramref name="destination" /> ist zu klein für eine <see cref="T:System.Int64" />-Struktur.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt64LittleEndian(System.Span{System.Byte},System.Int64)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int64&quot; /&gt; into a span of bytes, as little endian.">Schreibt eine <see cref="T:System.Int64" />-Struktur als Little-Endian-Wert in einen Bytebereich</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Der Bytebereich, in den der Wert als Little-Endian-Wert geschrieben werden soll</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int64&quot; /&gt;.">
        <paramref name="destination" /> ist zu klein für eine <see cref="T:System.Int64" />-Struktur.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteSingleBigEndian(System.Span{System.Byte},System.Single)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.Single&quot; /&gt; into a span of bytes, as big endian.">Schreibt eine <see cref="T:System.Single" />-Struktur als big-endian-Wert in einen Bytebereich</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Der Bytebereich, in den der Wert als big-endian-Wert geschrieben werden soll</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.Single&quot; /&gt;.">
        <paramref name="destination" /> ist zu klein für eine <see cref="T:System.Single" />-Struktur.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteSingleLittleEndian(System.Span{System.Byte},System.Single)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.Single&quot; /&gt; into a span of bytes, as little endian.">Schreibt eine <see cref="T:System.Single" />-Struktur als Little-Endian-Wert in einen Bytebereich</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Der Bytebereich, in den der Wert als Little-Endian-Wert geschrieben werden soll</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.Single&quot; /&gt;.">
        <paramref name="destination" /> ist zu klein für eine <see cref="T:System.Single" />-Struktur.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt16BigEndian(System.Span{System.Byte},System.UInt16)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; into a span of bytes, as big endian.">Schreibt eine <see cref="T:System.UInt16" />-Struktur als big-endian-Wert in einen Bytebereich</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Der Bytebereich, in den der Wert als big-endian-Wert geschrieben werden soll</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt16&quot; /&gt;.">
        <paramref name="destination" /> ist zu klein für eine <see cref="T:System.UInt16" />-Struktur.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt16LittleEndian(System.Span{System.Byte},System.UInt16)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; into a span of bytes, as little endian.">Schreibt eine <see cref="T:System.UInt16" />-Struktur als Little-Endian-Wert in einen Bytebereich</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Der Bytebereich, in den der Wert als Little-Endian-Wert geschrieben werden soll</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt16&quot; /&gt;.">
        <paramref name="destination" /> ist zu klein für eine <see cref="T:System.UInt16" />-Struktur.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt32BigEndian(System.Span{System.Byte},System.UInt32)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; into a span of bytes, as big endian.">Schreibt eine <see cref="T:System.UInt32" />-Struktur als big-endian-Wert in einen Bytebereich</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Der Bytebereich, in den der Wert als big-endian-Wert geschrieben werden soll</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt32&quot; /&gt;.">
        <paramref name="destination" /> ist zu klein für eine <see cref="T:System.UInt32" />-Struktur.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt32LittleEndian(System.Span{System.Byte},System.UInt32)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; into a span of bytes, as little endian.">Schreibt eine <see cref="T:System.UInt32" />-Struktur als Little-Endian-Wert in einen Bytebereich</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Der Bytebereich, in den der Wert als Little-Endian-Wert geschrieben werden soll</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt32&quot; /&gt;.">
        <paramref name="destination" /> ist zu klein für eine <see cref="T:System.UInt32" />-Struktur.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt64BigEndian(System.Span{System.Byte},System.UInt64)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; into a span of bytes, as big endian.">Schreibt eine <see cref="T:System.UInt64" />-Struktur als big-endian-Wert in einen Bytebereich</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Der Bytebereich, in den der Wert als big-endian-Wert geschrieben werden soll</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt64&quot; /&gt;.">
        <paramref name="destination" /> ist zu klein für eine <see cref="T:System.UInt64" />-Struktur.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt64LittleEndian(System.Span{System.Byte},System.UInt64)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; into a span of bytes, as little endian.">Schreibt eine <see cref="T:System.UInt64" />-Struktur als Little-Endian-Wert in einen Bytebereich</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Der Bytebereich, in den der Wert als Little-Endian-Wert geschrieben werden soll</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt64&quot; /&gt;.">
        <paramref name="destination" /> ist zu klein für eine <see cref="T:System.UInt64" />-Struktur.</exception>
    </member>
    <member name="T:System.Buffers.BuffersExtensions">
      <summary vsli:raw="Provides extension methods for &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Stellt Erweiterungsmethoden für <see cref="T:System.Buffers.ReadOnlySequence`1" /> bereit.</summary>
    </member>
    <member name="M:System.Buffers.BuffersExtensions.CopyTo``1(System.Buffers.ReadOnlySequence{``0},System.Span{``0})">
      <summary vsli:raw="Copies the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; to the specified &lt;see cref=&quot;T:System.Span`1&quot; /&gt;.">Kopiert die <see cref="T:System.Buffers.ReadOnlySequence`1" /> in die angegebene <see cref="T:System.Span`1" />.</summary>
      <param name="source" vsli:raw="The source &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Der Quell-<see cref="T:System.Buffers.ReadOnlySequence`1" />.</param>
      <param name="destination" vsli:raw="The destination &lt;see cref=&quot;T:System.Span`1&quot; /&gt;.">Das Ziel-<see cref="T:System.Span`1" />.</param>
      <typeparam name="T" vsli:raw="The type of the items in the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Der Typ der Elemente in der <see cref="T:System.Buffers.ReadOnlySequence`1" /> .</typeparam>
    </member>
    <member name="M:System.Buffers.BuffersExtensions.PositionOf``1(System.Buffers.ReadOnlySequence{``0},``0)">
      <summary vsli:raw="Returns the position of the first occurrence of &lt;paramref name=&quot;item&quot; /&gt; in the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Gibt die Position des ersten Vorkommens von <paramref name="item" /> in der <see cref="T:System.Buffers.ReadOnlySequence`1" /> zurück.</summary>
      <param name="source" vsli:raw="The source &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Der Quell-<see cref="T:System.Buffers.ReadOnlySequence`1" />.</param>
      <param name="value" vsli:raw="The item to find in the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Das in <see cref="T:System.Buffers.ReadOnlySequence`1" /> zu suchende Element.</param>
      <typeparam name="T" vsli:raw="The type of the items in the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Der Typ der Elemente in der <see cref="T:System.Buffers.ReadOnlySequence`1" /> .</typeparam>
      <returns vsli:raw="An object whose &lt;see cref=&quot;M:System.SequencePosition.GetInteger&quot; /&gt; method returns the position of the first occurrence of &lt;paramref name=&quot;item&quot; /&gt;, or an object whose &lt;see langword=&quot;Nullable&amp;lt;SequencePosition&amp;gt;.HasValue&quot; /&gt; property is &lt;see langword=&quot;false&quot; /&gt; .">Ein Objekt, dessen <see cref="M:System.SequencePosition.GetInteger" />-Methode die Position des ersten Vorkommens von <paramref name="item" /> zurückgibt, oder ein Objekt, dessen <see langword="Nullable&lt;SequencePosition&gt;.HasValue" />-Eigenschaft <see langword="false" /> ist.</returns>
    </member>
    <member name="M:System.Buffers.BuffersExtensions.ToArray``1(System.Buffers.ReadOnlySequence{``0})">
      <summary vsli:raw="Converts the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; to an array.">Konvertiert die <see cref="T:System.Buffers.ReadOnlySequence`1" /> in ein Array.</summary>
      <param name="sequence" vsli:raw="The read-only sequence to convert to an array.">Die schreibgeschützte Sequenz, die in ein Array konvertiert werden soll.</param>
      <typeparam name="T" vsli:raw="The type of the items in the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Der Typ der Elemente in der <see cref="T:System.Buffers.ReadOnlySequence`1" /> .</typeparam>
      <returns vsli:raw="An array containing the data in the current read-only sequence.">Ein Array das die Daten der aktuellen schreibgeschützten Sequenz enthält.</returns>
    </member>
    <member name="M:System.Buffers.BuffersExtensions.Write``1(System.Buffers.IBufferWriter{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Writes the contents of &lt;paramref name=&quot;value&quot; /&gt; to &lt;paramref name=&quot;writer&quot; /&gt;.">Schreibt den Inhalt von <paramref name="value" /> in <paramref name="writer" />.</summary>
      <param name="writer" vsli:raw="The buffer writer to which to write &lt;paramref name=&quot;value&quot; /&gt;.">Der Pufferwriter, in den <paramref name="value" /> geschrieben werden soll.</param>
      <param name="value" vsli:raw="The read-only span to be written to &lt;paramref name=&quot;writer&quot; /&gt;.">Der schreibgeschützte Bereich, der in <paramref name="writer" /> geschrieben werden soll.</param>
      <typeparam name="T" vsli:raw="The type of the items in the &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt;.">Der Typ der Elemente in der <see cref="T:System.ReadOnlySpan`1" /> .</typeparam>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;writer&quot; /&gt; is shorter than &lt;paramref name=&quot;value&quot; /&gt;.">
        <paramref name="writer" /> ist kürzer als <paramref name="value" />.</exception>
    </member>
    <member name="T:System.Buffers.IBufferWriter`1">
      <summary vsli:raw="Represents an output sink into which &lt;typeparamref name=&quot;T&quot; /&gt; data can be written.">Stellt eine Ausgabesenke dar, in die <typeparamref name="T" />-Daten geschrieben werden können.</summary>
      <typeparam name="T" vsli:raw="The type of the items in the &lt;see cref=&quot;T:System.Buffers.IBufferWriter`1&quot; /&gt;.">Der Typ der Elemente in der <see cref="T:System.Buffers.IBufferWriter`1" /> .</typeparam>
    </member>
    <member name="M:System.Buffers.IBufferWriter`1.Advance(System.Int32)">
      <summary vsli:raw="Notifies the &lt;see cref=&quot;T:System.Buffers.IBufferWriter`1&quot; /&gt; that &lt;paramref name=&quot;count&quot; /&gt; data items were written to the output &lt;see cref=&quot;T:System.Span`1&quot; /&gt; or &lt;see cref=&quot;T:System.Memory`1&quot; /&gt;.">Teilt <see cref="T:System.Buffers.IBufferWriter`1" /> mit, dass <paramref name="count" /> Datenelemente in die Ausgabe <see cref="T:System.Span`1" /> oder <see cref="T:System.Memory`1" /> geschrieben wurden.</summary>
      <param name="count" vsli:raw="The number of data items written to the &lt;see cref=&quot;T:System.Span`1&quot; /&gt; or &lt;see cref=&quot;T:System.Memory`1&quot; /&gt;.">Die Anzahl der in <see cref="T:System.Span`1" /> oder <see cref="T:System.Memory`1" /> geschriebenen Datenelemente.</param>
    </member>
    <member name="M:System.Buffers.IBufferWriter`1.GetMemory(System.Int32)">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Memory`1&quot; /&gt; to write to that is at least the requested size (specified by &lt;paramref name=&quot;sizeHint&quot; /&gt;).">Gibt ein <see cref="T:System.Memory`1" />-Element zum Zurückschreiben zurück, das mindestens die angeforderte (von <paramref name="sizeHint" /> angegebene) Größe aufweist.</summary>
      <param name="sizeHint" vsli:raw="The minimum length of the returned &lt;see cref=&quot;T:System.Memory`1&quot; /&gt;. If 0, a non-empty buffer is returned.">Die Mindestlänge des zurückgegebenen <see cref="T:System.Memory`1" />-Elements. Wenn dieser Wert 0 lautet, wird ein nicht leerer Puffer zurückgegeben.</param>
      <exception cref="T:System.OutOfMemoryException" vsli:raw="The requested buffer size is not available.">Die angeforderte Puffergröße ist nicht verfügbar.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Memory`1&quot; /&gt; of at least the size &lt;paramref name=&quot;sizeHint&quot; /&gt;. If &lt;paramref name=&quot;sizeHint&quot; /&gt; is 0, returns a non-empty buffer.">Ein <see cref="T:System.Memory`1" />-Element, dessen Größe mindestens <paramref name="sizeHint" /> beträgt. Gibt einen nicht leeren Puffer zurück, wenn <paramref name="sizeHint" /> 0 ist.</returns>
    </member>
    <member name="M:System.Buffers.IBufferWriter`1.GetSpan(System.Int32)">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Span`1&quot; /&gt; to write to that is at least the requested size (specified by &lt;paramref name=&quot;sizeHint&quot; /&gt;).">Gibt ein <see cref="T:System.Span`1" />-Element zum Zurückschreiben zurück, das mindestens die angeforderte (von <paramref name="sizeHint" /> angegebene) Größe aufweist.</summary>
      <param name="sizeHint" vsli:raw="The minimum length of the returned &lt;see cref=&quot;T:System.Span`1&quot; /&gt;. If 0, a non-empty buffer is returned.">Die Mindestlänge des zurückgegebenen <see cref="T:System.Span`1" />-Elements. Wenn dieser Wert 0 lautet, wird ein nicht leerer Puffer zurückgegeben.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Span`1&quot; /&gt; of at least the size &lt;paramref name=&quot;sizeHint&quot; /&gt;. If &lt;paramref name=&quot;sizeHint&quot; /&gt; is 0, returns a non-empty buffer.">Ein <see cref="T:System.Span`1" />-Element, dessen Größe mindestens <paramref name="sizeHint" /> beträgt. Gibt einen nicht leeren Puffer zurück, wenn <paramref name="sizeHint" /> 0 ist.</returns>
    </member>
    <member name="T:System.Buffers.MemoryPool`1">
      <summary vsli:raw="Represents a pool of memory blocks.">Stellt einen Pool von Speicherblöcken dar.</summary>
      <typeparam name="T" vsli:raw="The type of the items in the memory pool.">Der Typ der Elemente im Speicherpool.</typeparam>
    </member>
    <member name="M:System.Buffers.MemoryPool`1.#ctor">
      <summary vsli:raw="Constructs a new instance of a memory pool.">Erstellt eine neue Instanz eines Speicherpools.</summary>
    </member>
    <member name="M:System.Buffers.MemoryPool`1.Dispose">
      <summary vsli:raw="Frees all resources used by the memory pool.">Gibt alle vom Speicherpool verwendeten Ressourcen frei.</summary>
    </member>
    <member name="M:System.Buffers.MemoryPool`1.Dispose(System.Boolean)">
      <summary vsli:raw="Frees the unmanaged resources used by the memory pool and optionally releases the managed resources.">Gibt die vom Speicherpool verwendeten nicht verwalteten Ressourcen und optional auch die verwalteten Ressourcen frei.</summary>
      <param name="disposing" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to release both managed and unmanaged resources; &lt;see langword=&quot;false&quot; /&gt; to release only unmanaged resources.">
        <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
    </member>
    <member name="M:System.Buffers.MemoryPool`1.Rent(System.Int32)">
      <summary vsli:raw="Returns a memory block capable of holding at least &lt;paramref name=&quot;minBufferSize&quot; /&gt; elements of T.">Gibt einen Speicherblock zurück, der mindestens <paramref name="minBufferSize" /> Elemente von T aufnehmen kann.</summary>
      <param name="minBufferSize" vsli:raw="The minimum number of elements of &lt;typeparamref name=&quot;T&quot; /&gt; that the memory pool can hold. A value of -1 returns a memory pool set to the default size for the pool.">Die minimale Anzahl von Elementen von <typeparamref name="T" />, die der Speicherpool enthalten kann. Der Wert -1 gibt einen Speicherpool zurück, der auf die Standardgröße für den Pool festgelegt ist.</param>
      <returns vsli:raw="A memory block capable of holding at least &lt;paramref name=&quot;minBufferSize&quot; /&gt; elements of T.">Ein Speicherblock, der mindestens <paramref name="minBufferSize" /> Elemente von T aufnehmen kann.</returns>
    </member>
    <member name="P:System.Buffers.MemoryPool`1.MaxBufferSize">
      <summary vsli:raw="Gets the maximum buffer size supported by this pool.">Ruft die maximale Puffergröße ab, die von diesem Pool unterstützt wird.</summary>
      <returns vsli:raw="The maximum buffer size supported by this pool.">Die maximale Puffergröße, die von diesem Pool unterstützt wird.</returns>
    </member>
    <member name="P:System.Buffers.MemoryPool`1.Shared">
      <summary vsli:raw="Gets a singleton instance of a memory pool based on arrays.">Ruft eine Singletoninstanz eines Speicherpools basierend auf Arrays ab.</summary>
      <returns vsli:raw="A singleton instance of a memory pool.">Eine Singleton Instanz eines Speicherpools.</returns>
    </member>
    <member name="T:System.Buffers.ReadOnlySequence`1">
      <summary vsli:raw="Represents a sequence that can read a sequential series of &lt;typeparamref name=&quot;T&quot; /&gt;.">Stellt eine Sequenz dar, die eine sequenzielle Reihe von <typeparamref name="T" /> lesen kann.</summary>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only sequence.">Der Typ der Elemente in der schreibgeschützten Sequenz.</typeparam>
    </member>
    <member name="F:System.Buffers.ReadOnlySequence`1.Empty">
      <summary vsli:raw="Returns an empty &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Gibt ein leeres <see cref="T:System.Buffers.ReadOnlySequence`1" /> zurück.</summary>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(`0[])">
      <summary vsli:raw="Creates an instance of &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; from the &lt;paramref name=&quot;array&quot; /&gt;.">Erstellt eine Instanz von <see cref="T:System.Buffers.ReadOnlySequence`1" /> aus <paramref name="array" />.</summary>
      <param name="array" vsli:raw="The array from which to create a read-only sequence.">Das Array, aus dem eine schreibgeschützte Sequenz erstellt werden soll.</param>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(`0[],System.Int32,System.Int32)">
      <summary vsli:raw="Creates an instance of a &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; from a section of an array.">Erstellt eine Instanz einer <see cref="T:System.Buffers.ReadOnlySequence`1" /> aus einem Abschnitt eines Arrays.</summary>
      <param name="array" vsli:raw="The array from which to create the read-only sequence.">Das Array, aus dem die schreibgeschützte Sequenz erstellt werden soll.</param>
      <param name="start" vsli:raw="The zero-based index of the first element in the array to include in the read-only sequence.">Der nullbasierte (0) Index des ersten Elements im Array, das in die schreibgeschützte Sequenz eingeschlossen werden soll.</param>
      <param name="length" vsli:raw="The number of elements to include in the read-only sequence.">Die Anzahl von Elementen, die in die schreibgeschützte Sequenz eingeschlossen werden sollen.</param>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(System.Buffers.ReadOnlySequenceSegment{`0},System.Int32,System.Buffers.ReadOnlySequenceSegment{`0},System.Int32)">
      <summary vsli:raw="Creates an instance of a &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; from a linked memory list represented by start and end segments and the corresponding indexes in them.">Erstellt eine Instanz einer <see cref="T:System.Buffers.ReadOnlySequence`1" /> aus einer verknüpften Speicherliste, die durch Start- und Endsegmente und die entsprechenden Indizes darin dargestellt wird.</summary>
      <param name="startSegment" vsli:raw="The initial node of the linked memory list.">Der anfängliche Knoten der verknüpften Speicherliste.</param>
      <param name="startIndex" vsli:raw="The position to the start of the sequence inside &lt;paramref name=&quot;startSegment&quot; /&gt;.">Die Position zum Anfang der Sequenz innerhalb von <paramref name="startSegment" />.</param>
      <param name="endSegment" vsli:raw="The final node of the linked memory list.">Der letzte Knoten der verknüpften Speicherliste.</param>
      <param name="endIndex" vsli:raw="The position to the end of the sequence inside &lt;paramref name=&quot;endSegment&quot; /&gt;.">Die Position zum Ende der Sequenz innerhalb von <paramref name="endSegment" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;startSegment&quot; /&gt; or &lt;paramref name=&quot;endSegment&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="startSegment" /> oder <paramref name="endSegment" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The running index of &lt;paramref name=&quot;startSegment&quot; /&gt; is greater than the running index of &lt;paramref name=&quot;endSegment&quot; /&gt;, even though &lt;paramref name=&quot;startSegment&quot; /&gt; is different to &lt;paramref name=&quot;endSegment&quot; /&gt;.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;startSegment&quot; /&gt; is equal to &lt;paramref name=&quot;endSegment&quot; /&gt; but &lt;paramref name=&quot;endIndex&quot; /&gt; is smaller than &lt;paramref name=&quot;startIndex&quot; /&gt;.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;startIndex&quot; /&gt; is greater than the length of the underlying memory block of &lt;paramref name=&quot;startSegment&quot; /&gt;.">Der ausgeführte Index von <paramref name="startSegment" /> ist größer als der ausgeführte Index von <paramref name="endSegment" />, auch wenn <paramref name="startSegment" /> sich von <paramref name="endSegment" /> unterscheidet.

- oder -

<paramref name="startSegment" /> ist gleich <paramref name="endSegment" />, aber <paramref name="endIndex" /> ist kleiner als <paramref name="startIndex" />.

- oder -

<paramref name="startIndex" /> ist länger als der zugrunde liegende Speicherblock von <paramref name="startSegment" />.</exception>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(System.ReadOnlyMemory{`0})">
      <summary vsli:raw="Creates an instance of &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; from a &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt;.">Erstellt eine Instanz von <see cref="T:System.Buffers.ReadOnlySequence`1" /> aus <see cref="T:System.ReadOnlyMemory`1" />.</summary>
      <param name="memory" vsli:raw="A read-only block of memory of elements of type &lt;typeparamref name=&quot;T&quot; /&gt;.">Ein schreibgeschützter Speicherblock mit Elementen des Typs <typeparamref name="T" />.</param>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.GetEnumerator">
      <summary vsli:raw="Returns an enumerator over the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Gibt einen Enumerator über die <see cref="T:System.Buffers.ReadOnlySequence`1" /> zurück.</summary>
      <returns vsli:raw="Returns an enumerator over the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Gibt einen Enumerator über die <see cref="T:System.Buffers.ReadOnlySequence`1" /> zurück.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.GetOffset(System.SequencePosition)">
      <summary vsli:raw="Returns the offset of a &lt;paramref name=&quot;position&quot; /&gt; within this sequence from the start.">Gibt den Offset einer <paramref name="position" /> innerhalb dieser Sequenz vom Anfang zurück.</summary>
      <param name="position" vsli:raw="The &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; of which to get the offset.">Die <see cref="T:System.SequencePosition" />, deren Offset abgerufen werden soll.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The position is out of range.">Die Position liegt außerhalb des gültigen Bereichs.</exception>
      <returns vsli:raw="The offset from the start of the sequence.">Der Offset vom Anfang der Sequenz.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.GetPosition(System.Int64)">
      <summary vsli:raw="Returns a new &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; at an &lt;paramref name=&quot;offset&quot; /&gt; from the start of the sequence.">Gibt eine neue <see cref="T:System.SequencePosition" /> an einem <paramref name="offset" /> ab dem Anfang der Sequenz zurück.</summary>
      <param name="offset" vsli:raw="The offset from the start of the sequence.">Der Offset vom Anfang der Sequenz.</param>
      <returns vsli:raw="An object representing the sequence position that starts at the specified &lt;paramref name=&quot;offset&quot; /&gt; from the start of the sequence.">Ein Objekt, das die Sequenzposition darstellt, die am angegebenen <paramref name="offset" /> vom Anfang der Sequenz beginnt.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.GetPosition(System.Int64,System.SequencePosition)">
      <summary vsli:raw="Returns a new &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; starting at the specified offset from the &lt;paramref name=&quot;origin&quot; /&gt; position.">Gibt eine neue <see cref="T:System.SequencePosition" /> ab dem angegebenen Offset von der Position <paramref name="origin" /> zurück.</summary>
      <param name="offset" vsli:raw="The offset from the specified &lt;paramref name=&quot;origin&quot; /&gt; sequence position.">Der Offset von der angegebenen Sequenzposition <paramref name="origin" />.</param>
      <param name="origin" vsli:raw="A sequence position representing the point from which to initiate the offset.">Eine Sequenzposition, die den Punkt darstellt, an dem der Offset initiiert werden soll.</param>
      <returns vsli:raw="An object representing the sequence position that starts at the &lt;paramref name=&quot;offset&quot; /&gt; position of the specified &lt;paramref name=&quot;origin&quot; /&gt; position object.">Ein Objekt, das die Sequenzposition darstellt, die an der Position <paramref name="offset" /> des angegebenen Positionsobjekts <paramref name="origin" /> beginnt.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int32,System.Int32)">
      <summary vsli:raw="Forms a slice out of the current &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;, beginning at &lt;paramref name=&quot;start&quot; /&gt;, with &lt;paramref name=&quot;length&quot; /&gt; items.">Bildet einen Slice aus der aktuellen <see cref="T:System.Buffers.ReadOnlySequence`1" />, beginnend bei <paramref name="start" />, mit <paramref name="length" /> Elementen.</summary>
      <param name="start" vsli:raw="The index at which to begin this slice.">Der Index, an dem dieser Slice beginnen soll.</param>
      <param name="length" vsli:raw="The length of the slice.">Die Länge des Slices.</param>
      <returns vsli:raw="A slice that consists of &lt;paramref name=&quot;length&quot; /&gt; elements from the current instance starting at index &lt;paramref name=&quot;start&quot; /&gt;.">Ein Slice, der aus <paramref name="length" /> Elementen der aktuellen Instanz besteht, beginnend bei Index <paramref name="start" />.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int32,System.SequencePosition)">
      <summary vsli:raw="Forms a slice out of the current &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;, beginning at &lt;paramref name=&quot;start&quot; /&gt; and ending at &lt;paramref name=&quot;end&quot; /&gt; (exclusive).">Bildet einen Slice aus der aktuellen <see cref="T:System.Buffers.ReadOnlySequence`1" />, beginnend bei <paramref name="start" /> und endend bei <paramref name="end" /> (exklusiv).</summary>
      <param name="start" vsli:raw="The index at which to begin this slice.">Der Index, an dem dieser Slice beginnen soll.</param>
      <param name="end" vsli:raw="The end (exclusive) &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; of the slice.">Das Ende (exklusiv) <see cref="T:System.SequencePosition" /> des Slices.</param>
      <returns vsli:raw="A slice that consists of items from the &lt;paramref name=&quot;start&quot; /&gt; index to, but not including, the &lt;paramref name=&quot;end&quot; /&gt; sequence position in the current read-only sequence.">Ein Slice, der aus Elementen aus dem <paramref name="start" />-Index besteht, aber nicht die Sequenzposition <paramref name="end" /> in der aktuellen schreibgeschützten Sequenz einschließt.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int64)">
      <summary vsli:raw="Forms a slice out of the current &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;, beginning at a specified index and continuing to the end of the read-only sequence.">Bildet einen Slice aus der aktuellen <see cref="T:System.Buffers.ReadOnlySequence`1" />, beginnend am angegebenen Index und bis zum Ende der schreibgeschützten Sequenz fortgesetzt.</summary>
      <param name="start" vsli:raw="The start index at which to begin this slice.">Der Startindex, an dem dieser Slice beginnen soll.</param>
      <returns vsli:raw="A slice starting at index &lt;paramref name=&quot;start&quot; /&gt; and continuing to the end of the current read-only sequence.">Ein Slice, der bei Index <paramref name="start" /> beginnt und bis zum Ende der schreibgeschützten Sequenz reicht.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int64,System.Int64)">
      <summary vsli:raw="Forms a slice out of the given &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;, beginning at &lt;paramref name=&quot;start&quot; /&gt;, with &lt;paramref name=&quot;length&quot; /&gt; items.">Bildet einen Slice aus der vorgegebenen <see cref="T:System.Buffers.ReadOnlySequence`1" />, beginnend bei <paramref name="start" />, mit <paramref name="length" /> Elementen.</summary>
      <param name="start" vsli:raw="The index at which to begin this slice.">Der Index, an dem dieser Slice beginnen soll.</param>
      <param name="length" vsli:raw="The length of the slice.">Die Länge des Slices.</param>
      <returns vsli:raw="A slice that consists of &lt;paramref name=&quot;length&quot; /&gt; elements from the current instance starting at index &lt;paramref name=&quot;start&quot; /&gt;.">Ein Slice, der aus <paramref name="length" /> Elementen der aktuellen Instanz besteht, beginnend bei Index <paramref name="start" />.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int64,System.SequencePosition)">
      <summary vsli:raw="Forms a slice out of the current &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;, beginning at &lt;paramref name=&quot;start&quot; /&gt; and ending at &lt;paramref name=&quot;end&quot; /&gt; (exclusive).">Bildet einen Slice aus der aktuellen <see cref="T:System.Buffers.ReadOnlySequence`1" />, beginnend bei <paramref name="start" /> und endend bei <paramref name="end" /> (exklusiv).</summary>
      <param name="start" vsli:raw="The index at which to begin this slice.">Der Index, an dem dieser Slice beginnen soll.</param>
      <param name="end" vsli:raw="The end (exclusive) of the slice.">Das Ende (exklusiv) des Slices.</param>
      <returns vsli:raw="A slice that consists of items from the &lt;paramref name=&quot;start&quot; /&gt; index to, but not including, the &lt;paramref name=&quot;end&quot; /&gt; sequence position in the current read-only sequence.">Ein Slice, der aus Elementen aus dem <paramref name="start" />-Index besteht, aber nicht die Sequenzposition <paramref name="end" /> in der aktuellen schreibgeschützten Sequenz einschließt.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition)">
      <summary vsli:raw="Forms a slice out of the current &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;, beginning at a specified sequence position and continuing to the end of the read-only sequence.">Bildet einen Slice aus der aktuellen <see cref="T:System.Buffers.ReadOnlySequence`1" />, beginnend an der angegebenen Sequenzposition und bis zum Ende der schreibgeschützten Sequenz reichend.</summary>
      <param name="start" vsli:raw="The starting (inclusive) &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; at which to begin this slice.">Die <see cref="T:System.SequencePosition" /> (inklusiv) des Beginns dieses Slices.</param>
      <returns vsli:raw="A slice starting at sequence position &lt;paramref name=&quot;start&quot; /&gt; and continuing to the end of the current read-only sequence.">Ein Slice, der bei Sequenzposition <paramref name="start" /> beginnt und bis zum Ende der schreibgeschützten Sequenz reicht.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition,System.Int32)">
      <summary vsli:raw="Forms a slice out of the current &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;, beginning at &lt;paramref name=&quot;start&quot; /&gt;, with &lt;paramref name=&quot;length&quot; /&gt; items.">Bildet einen Slice aus der aktuellen <see cref="T:System.Buffers.ReadOnlySequence`1" />, beginnend bei <paramref name="start" />, mit <paramref name="length" /> Elementen.</summary>
      <param name="start" vsli:raw="The starting (inclusive) &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; at which to begin this slice.">Die <see cref="T:System.SequencePosition" /> (inklusiv) des Beginns dieses Slices.</param>
      <param name="length" vsli:raw="The length of the slice.">Die Länge des Slices.</param>
      <returns vsli:raw="A slice that consists of &lt;paramref name=&quot;length&quot; /&gt; elements from the current instance starting at sequence position &lt;paramref name=&quot;start&quot; /&gt;.">Ein Slice, der aus <paramref name="length" /> Elementen der aktuellen Instanz besteht, beginnend bei Sequenzposition <paramref name="start" />.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition,System.Int64)">
      <summary vsli:raw="Forms a slice out of the current &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;, beginning at &lt;paramref name=&quot;start&quot; /&gt;, with &lt;paramref name=&quot;length&quot; /&gt; items.">Bildet einen Slice aus der aktuellen <see cref="T:System.Buffers.ReadOnlySequence`1" />, beginnend bei <paramref name="start" />, mit <paramref name="length" /> Elementen.</summary>
      <param name="start" vsli:raw="The starting (inclusive) &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; at which to begin this slice.">Die <see cref="T:System.SequencePosition" /> (inklusiv) des Beginns dieses Slices.</param>
      <param name="length" vsli:raw="The length of the slice.">Die Länge des Slices.</param>
      <returns vsli:raw="A slice that consists of &lt;paramref name=&quot;length&quot; /&gt; elements from the current instance starting at sequence position &lt;paramref name=&quot;start&quot; /&gt;.">Ein Slice, der aus <paramref name="length" /> Elementen der aktuellen Instanz besteht, beginnend bei Sequenzposition <paramref name="start" />.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition,System.SequencePosition)">
      <summary vsli:raw="Forms a slice out of the current &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;, beginning at &lt;paramref name=&quot;start&quot; /&gt; and ending at &lt;paramref name=&quot;end&quot; /&gt; (exclusive).">Bildet einen Slice aus der aktuellen <see cref="T:System.Buffers.ReadOnlySequence`1" />, beginnend bei <paramref name="start" /> und endend bei <paramref name="end" /> (exklusiv).</summary>
      <param name="start" vsli:raw="The starting (inclusive) &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; at which to begin this slice.">Die <see cref="T:System.SequencePosition" /> (inklusiv) des Beginns dieses Slices.</param>
      <param name="end" vsli:raw="The ending (exclusive) &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; of the slice.">Das Ende (exklusiv) <see cref="T:System.SequencePosition" /> des Slices.</param>
      <returns vsli:raw="A slice that consists of items from the &lt;paramref name=&quot;start&quot; /&gt; sequence position to, but not including, the &lt;paramref name=&quot;end&quot; /&gt; sequence position in the current read-only sequence.">Ein Slice, der aus Elementen von der <paramref name="start" />-Sequenzposition bis zur <paramref name="end" />-Sequenzposition, diese aber nicht einschließend, in der aktuellen schreibgeschützten Sequenz besteht.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.ToString">
      <summary vsli:raw="Returns a string that represents the current sequence.">Gibt eine Zeichenfolge zurück, die die aktuelle Sequenz darstellt.</summary>
      <returns vsli:raw="A string that represents the current sequence.">Eine Zeichenfolge, die die aktuelle Sequenz darstellt.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.TryGet(System.SequencePosition@,System.ReadOnlyMemory{`0}@,System.Boolean)">
      <summary vsli:raw="Tries to retrieve the next segment after &lt;paramref name=&quot;position&quot; /&gt; and returns a value that indicates whether the operation succeeded.">Damit wird versucht, das nächste Segment nach <paramref name="position" /> abzurufen, und es wird ein Wert zurückgegeben, der angibt, ob der Vorgang erfolgreich war.</summary>
      <param name="position" vsli:raw="The current sequence position.">Die aktuelle Sequenzposition.</param>
      <param name="memory" vsli:raw="A read-only memory span that contains the next segment after &lt;paramref name=&quot;position&quot; /&gt;.">Ein Bereich von schreibgeschütztem Speicher, der das nächste Segment nach <paramref name="position" /> enthält.</param>
      <param name="advance" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;position&quot; /&gt; should to the beginning of next segment; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn <paramref name="position" /> am Anfang des nächsten Segments liegen sollte; anderenfalls <see langword="false" />.</param>
      <returns vsli:raw="Returns &lt;see langword=&quot;true&quot; /&gt; if the method returned the next segment, or &lt;see langword=&quot;false&quot; /&gt; if the end of the read-only sequence was reached.">Gibt <see langword="true" /> zurück, wenn die Methode das nächste Segment zurückgegeben hat, oder <see langword="false" />, wenn das Ende der schreibgeschützten Sequenz erreicht wurde.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.End">
      <summary vsli:raw="Gets the position at the end of the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Ruft die Position am Ende der <see cref="T:System.Buffers.ReadOnlySequence`1" /> ab.</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.First">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt; from the first segment.">Ruft das <see cref="T:System.ReadOnlyMemory`1" /> aus dem ersten Segment ab.</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.FirstSpan">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; from the first segment.">Ruft das <see cref="T:System.ReadOnlySpan`1" /> aus dem ersten Segment ab.</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.IsEmpty">
      <summary vsli:raw="Gets a value that indicates whether the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; is empty.">Ruft einen Wert ab, der angibt, ob <see cref="T:System.Buffers.ReadOnlySequence`1" /> leer ist.</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.IsSingleSegment">
      <summary vsli:raw="Gets a value that indicates whether the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; contains a single &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt; segment.">Ruft einen Wert ab, der angibt, ob die <see cref="T:System.Buffers.ReadOnlySequence`1" /> ein einzelnes <see cref="T:System.ReadOnlyMemory`1" />-Segment enthält.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the read-only sequence is empty; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> , wenn die schreibgeschützte Sequenz leer ist. andernfalls <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.Length">
      <summary vsli:raw="Gets the length of the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Ruft die Länge der <see cref="T:System.Buffers.ReadOnlySequence`1" /> ab.</summary>
      <returns vsli:raw="The length of the read-only sequence.">Die Länge der schreibgeschützten Sequenz.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.Start">
      <summary vsli:raw="Gets the position to the start of the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Ruft die Position, an den Anfang der <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
    </member>
    <member name="T:System.Buffers.ReadOnlySequence`1.Enumerator">
      <summary vsli:raw="Represents an enumerator over a &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Stellt ein Enumeratorobjekt über einer <see cref="T:System.Buffers.ReadOnlySequence`1" /> dar.</summary>
      <typeparam name="T" vsli:raw="" />
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Enumerator.#ctor(System.Buffers.ReadOnlySequence{`0}@)">
      <summary vsli:raw="Initializes the enumerator.">Initialisiert den Enumerator.</summary>
      <param name="sequence" vsli:raw="The &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; to enumerate.">Die aufzulistende <see cref="T:System.Buffers.ReadOnlySequence`1" />.</param>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Enumerator.MoveNext">
      <summary vsli:raw="Moves to the next &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt; in the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Wechselt zum nächsten <see cref="T:System.ReadOnlyMemory`1" /> in <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator successfully advanced to the next item; &lt;see langword=&quot;false&quot; /&gt; if the end of the sequence has been reached.">
        <see langword="true" />, wenn der Enumerator erfolgreich auf das nächste Element festgelegt wurde; <see langword="false" />, wenn das Ende der Sequenz erreicht wurde.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.Enumerator.Current">
      <summary vsli:raw="Gets the current &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt;.">Ruft den aktuellen <see cref="T:System.ReadOnlyMemory`1" /> ab.</summary>
      <returns vsli:raw="The current &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt;.">Der aktuelle <see cref="T:System.ReadOnlyMemory`1" />.</returns>
    </member>
    <member name="T:System.Buffers.ReadOnlySequenceSegment`1">
      <summary vsli:raw="Represents a linked list of &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt; nodes.">Stellt eine verknüpfte Liste von <see cref="T:System.ReadOnlyMemory`1" />-Knoten dar.</summary>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only sequence segment.">Der Typ der Elemente im schreibgeschützten Sequenz Segment.</typeparam>
    </member>
    <member name="M:System.Buffers.ReadOnlySequenceSegment`1.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequenceSegment`1&quot; /&gt; class.">Initialisiert eine neue Instanz der <see cref="T:System.Buffers.ReadOnlySequenceSegment`1" />-Klasse.</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequenceSegment`1.Memory">
      <summary vsli:raw="Gets or sets a &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt; value for the current node.">Ruft einen <see cref="T:System.ReadOnlyMemory`1" />-Wert für den aktuellen Knoten ab oder legt ihn fest.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt; value for the current node.">Ein- <see cref="T:System.ReadOnlyMemory`1" /> Wert für den aktuellen Knoten.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequenceSegment`1.Next">
      <summary vsli:raw="Gets or sets the next node.">Ruft den nächsten Knoten ab oder legt ihn fest.</summary>
      <returns vsli:raw="The next node.">Der nächste Knoten.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequenceSegment`1.RunningIndex">
      <summary vsli:raw="Gets or sets the sum of node lengths before the current node.">Ruft die Summe der Knotenlängen vor dem aktuellen Knoten ab oder legt sie fest.</summary>
      <returns vsli:raw="The sum of node lengths before the current node.">Die Summe der Knoten Längen vor dem aktuellen Knoten.</returns>
    </member>
    <member name="T:System.Buffers.SequenceReader`1">
      <summary vsli:raw="Provides methods for reading binary and text data out of a &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; with a focus on performance and minimal or zero heap allocations.">Stellt Methoden zum Lesen von Binär-und Textdaten aus <see cref="T:System.Buffers.ReadOnlySequence`1" /> mit dem Fokus auf die Leistung und minimale oder keine Heapzuteilungen bereit</summary>
      <typeparam name="T" vsli:raw="The type of the read-only sequence.">Der Typ der schreibgeschützten Sequenz.</typeparam>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.#ctor(System.Buffers.ReadOnlySequence{`0})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Buffers.SequenceReader`1&quot; /&gt; over a given &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Erstellt einen <see cref="T:System.Buffers.SequenceReader`1" /> über eine angegebene <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
      <param name="sequence" vsli:raw="The read-only sequence over which to create the &lt;see cref=&quot;T:System.Buffers.SequenceReader`1&quot; /&gt;.">Die schreibgeschützte Sequenz, über die der <see cref="T:System.Buffers.SequenceReader`1" /> erstellt werden soll.</param>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.Advance(System.Int64)">
      <summary vsli:raw="Moves the reader ahead a specified number of items.">Verschiebt den Reader eine angegebene Anzahl von Elementen nach vorn.</summary>
      <param name="count" vsli:raw="The number of items to advance.">Die Anzahl der Elemente, um die vorgerückt wird.</param>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePast(`0)">
      <summary vsli:raw="Advances past consecutive instances of the given &lt;paramref name=&quot;value&quot; /&gt;.">Bewegt sich an aufeinander folgenden Instanzen des angegebenen <paramref name="value" /> vorbei.</summary>
      <param name="value" vsli:raw="The value past which the reader is to advance.">Der Wert um, den sich der Reader vorbeibewegt.</param>
      <returns vsli:raw="The number of positions the reader has advanced.">Die Anzahl der Positionen, um die der Reader vorgerückt ist.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(`0,`0)">
      <summary vsli:raw="Advances past consecutive instances of either of two specified values.">Bewegt sich an aufeinander folgenden Instanzen eines beliebigen von zwei angegebenen Werten vorbei.</summary>
      <param name="value0" vsli:raw="The first value to skip.">Der erste zu überspringende Wert.</param>
      <param name="value1" vsli:raw="The second value to skip.">Der zweite zu überspringende Wert.</param>
      <returns vsli:raw="The number of positions the reader has advanced.">Die Anzahl der Positionen, um die der Reader vorgerückt ist.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(`0,`0,`0)">
      <summary vsli:raw="Advances past consecutive instances of any of three specified values.">Bewegt sich an aufeinander folgenden Instanzen beliebiger von drei angegebenen Werten vorbei.</summary>
      <param name="value0" vsli:raw="The first value to skip.">Der erste zu überspringende Wert.</param>
      <param name="value1" vsli:raw="The second value to skip.">Der zweite zu überspringende Wert.</param>
      <param name="value2" vsli:raw="The third value to skip.">Der dritte zu überspringende Wert.</param>
      <returns vsli:raw="The number of positions the reader has advanced.">Die Anzahl der Positionen, um die der Reader vorgerückt ist.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(`0,`0,`0,`0)">
      <summary vsli:raw="Advances past consecutive instances of any of four specified values.">Bewegt sich an aufeinander folgenden Instanzen beliebiger von vier angegebenen Werten vorbei.</summary>
      <param name="value0" vsli:raw="The first value to skip.">Der erste zu überspringende Wert.</param>
      <param name="value1" vsli:raw="The second value to skip.">Der zweite zu überspringende Wert.</param>
      <param name="value2" vsli:raw="The third value to skip.">Der dritte zu überspringende Wert.</param>
      <param name="value3" vsli:raw="The fourth value to skip.">Der vierte zu überspringende Wert.</param>
      <returns vsli:raw="The number of positions the reader has advanced.">Die Anzahl der Positionen, um die der Reader vorgerückt ist.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(System.ReadOnlySpan{`0})">
      <summary vsli:raw="Skips consecutive instances of any of the specified &lt;paramref name=&quot;values&quot; /&gt;.">Überspringt aufeinander folgende Instanzen beliebiger der angegebenen <paramref name="values" />.</summary>
      <param name="values" vsli:raw="The values to be skipped.">Die zu überspringenden Werte.</param>
      <returns vsli:raw="The number of positions the reader has advanced.">Die Anzahl der Positionen, um die der Reader vorgerückt ist.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvanceToEnd">
      <summary vsli:raw="Moves the reader to the end of the sequence.">Verschiebt den Reader an das Ende der Sequenz.</summary>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.IsNext(`0,System.Boolean)">
      <summary vsli:raw="Checks whether a specified value is next in the sequence.">Überprüft, ob ein angegebener Wert der nächste in der Sequenz ist.</summary>
      <param name="next" vsli:raw="The value to compare the next items to.">Der Wert, mit dem die nächsten Elemente verglichen werden.</param>
      <param name="advancePast" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the &lt;paramref name=&quot;next&quot; /&gt; values if they are found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> zum Vorbeibewegen an den <paramref name="next" />-Werten, wenn sie gefunden werden; sonst <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the values are next in sequence; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn die Werte in der Sequenz als nächstes kommen; sonst <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.IsNext(System.ReadOnlySpan{`0},System.Boolean)">
      <summary vsli:raw="Checks whether the values specified in a read-only span are next in the sequence.">Überprüft, ob die in einer schreibgeschützten Spanne angegebenen Werte die nächsten in der Sequenz sind.</summary>
      <param name="next" vsli:raw="The span to compare the next items to.">Die Spanne, mit der die nächsten Elemente verglichen werden.</param>
      <param name="advancePast" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the &lt;paramref name=&quot;next&quot; /&gt; values if they are found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> zum Vorbeibewegen an den <paramref name="next" />-Werten, wenn sie gefunden werden; sonst <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the values are next in sequence; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn die Werte in der Sequenz als nächstes kommen; sonst <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.Rewind(System.Int64)">
      <summary vsli:raw="Moves the reader back the specified number of items.">Verschiebt den Reader eine angegebene Anzahl von Elementen zurück.</summary>
      <param name="count" vsli:raw="The number of items.">Eine -Anzahl von Elementen.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;count&quot; /&gt; is negative or greater than &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Consumed&quot; /&gt;.">
        <paramref name="count" /> ist negativ oder größer als <see cref="P:System.Buffers.SequenceReader`1.Consumed" />.</exception>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryAdvanceTo(`0,System.Boolean)">
      <summary vsli:raw="Searches for a specified delimiter and optionally advances past it if it is found.">Sucht nach einem angegebenen Trennzeichen und bewegt sich optional an ihm vorbei, wenn es gefunden wird.</summary>
      <param name="delimiter" vsli:raw="The delimiter to search for.">Das Trennzeichen, das gesucht werden soll.</param>
      <param name="advancePastDelimiter" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the &lt;paramref name=&quot;delimiter&quot; /&gt; if it is found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> zum Vorbeibewegen am <paramref name="delimiter" />, wenn er gefunden wird; andernfalls <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the given &lt;paramref name=&quot;delimiter&quot; /&gt; was found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der angegebene <paramref name="delimiter" /> gefunden wurde; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryAdvanceToAny(System.ReadOnlySpan{`0},System.Boolean)">
      <summary vsli:raw="Searches for any of a number of specified delimiters and optionally advances past the first one to be found.">Sucht nach beliebigen einer Anzahl angegebener Trennzeichen und bewegt sich optional an dem ersten gefundenen vorbei.</summary>
      <param name="delimiters" vsli:raw="The delimiters to search for.">Die Trennzeichen, die gesucht werden sollen.</param>
      <param name="advancePastDelimiter" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the first instance of any of the given &lt;paramref name=&quot;delimiters&quot; /&gt;; &lt;see langword=&quot;false&quot; /&gt; to not move past the delimiter.">
        <see langword="true" /> zum Vorbeibewegen an der ersten Instanz eines der angegebenen <paramref name="delimiters" />; <see langword="false" />, um sich nicht an dem Trennzeichen vorbei zu bewegen.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if any of the given &lt;paramref name=&quot;delimiters&quot; /&gt; was found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn ein beliebiges der angegebenen <paramref name="delimiters" /> gefunden wurde; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryCopyTo(System.Span{`0})">
      <summary vsli:raw="Copies data from the current position to the given destination span if there is enough data to fill it.">Kopiert Daten von der aktuellen Position zur angegebenen Zielspanne, wenn genügend Daten vorhanden sind, um sie zu füllen.</summary>
      <param name="destination" vsli:raw="Destination span to copy to.">Zielspanne, in die kopiert werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if there is enough data to completely fill the &lt;paramref name=&quot;destination&quot; /&gt; span; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn genügend Daten vorhanden sind, um die <paramref name="destination" />-Spanne vollständig zu füllen; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryPeek(`0@)">
      <summary vsli:raw="Peeks at the next value without advancing the reader.">Schaut auf den nächsten Wert, ohne den Reader vorzurücken.</summary>
      <param name="value" vsli:raw="The next value, or the default value if at the end of the reader.">Der nächste Wert, oder der Standardwert, wenn das Ende des Readers erreicht ist.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the reader is not at its end and the peek operation succeeded; &lt;see langword=&quot;false&quot; /&gt; if at the end of the reader.">
        <see langword="true" />, wenn sich der Reader nicht am Ende befindet und der Schauvorgang erfolgreich war; <see langword="false" />, wenn sich der Reader am Ende befindet.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryPeek(System.Int64,`0@)">
      <summary vsli:raw="Peeks at the next value at the specified offset without advancing the reader.">Sieht den nächsten Wert am angegebenen Offset ein, ohne den Reader vorzurücken.</summary>
      <param name="offset" vsli:raw="The offset from current position.">Der Offset von der aktuellen Position.</param>
      <param name="value" vsli:raw="The next value, or the default value if at the end of the reader.">Der nächste Wert, oder der Standardwert, wenn das Ende des Readers erreicht ist.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the reader is not at its end and the peek operation succeeded; &lt;see langword=&quot;false&quot; /&gt; if at the end of the reader.">
        <see langword="true" />, wenn sich der Reader nicht am Ende befindet und der Schauvorgang erfolgreich war; <see langword="false" />, wenn sich der Reader am Ende befindet.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryRead(`0@)">
      <summary vsli:raw="Reads the next value and advance the reader.">Liest den nächsten Wert und rückt den Reader vor.</summary>
      <param name="value" vsli:raw="The next value, or the default value if at the end of the reader.">Der nächste Wert, oder der Standardwert, wenn das Ende des Readers erreicht ist.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the reader is not at its end and the read operation succeeded; &lt;see langword=&quot;false&quot; /&gt; if at the end of the reader.">
        <see langword="true" />, wenn sich der Reader nicht am Ende befindet und der Lesevorgang erfolgreich war; <see langword="false" />, wenn sich der Reader am Ende befindet.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.Buffers.ReadOnlySequence{`0}@,`0,`0,System.Boolean)">
      <summary vsli:raw="Tries to read everything up to the given &lt;paramref name=&quot;delimiter&quot; /&gt;, ignoring delimiters that are preceded by &lt;paramref name=&quot;delimiterEscape&quot; /&gt;.">Versucht, alles bis zum angegebenen <paramref name="delimiter" /> zu lesen, wobei Trennzeichen ignoriert werden, denen <paramref name="delimiterEscape" /> vorangestellt ist.</summary>
      <param name="sequence" vsli:raw="When the method returns, contains the data read, if any.">Enthält die ggf. von der Methode gelesenen Daten.</param>
      <param name="delimiter" vsli:raw="The delimiter to look for.">Das Trennzeichen, das gesucht werden soll.</param>
      <param name="delimiterEscape" vsli:raw="A value that indicates that an immediately following &lt;paramref name=&quot;delimiter&quot; /&gt; is to be skipped.">Ein Wert, der angibt, dass ein unmittelbar nachfolgender <paramref name="delimiter" /> übersprungen werden soll.</param>
      <param name="advancePastDelimiter" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the &lt;paramref name=&quot;delimiter&quot; /&gt; if found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> zum Vorbeibewegen am <paramref name="delimiter" />, wenn er gefunden wird; andernfalls <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;paramref name=&quot;delimiter&quot; /&gt; was found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der <paramref name="delimiter" /> gefunden wurde; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.Buffers.ReadOnlySequence{`0}@,`0,System.Boolean)">
      <summary vsli:raw="Tries to read everything up to the given &lt;paramref name=&quot;delimiter&quot; /&gt;.">Versucht, alles bis zum angegebenen <paramref name="delimiter" /> zu lesen.</summary>
      <param name="sequence" vsli:raw="When the method returns, contains the data read, if any.">Enthält die ggf. von der Methode gelesenen Daten.</param>
      <param name="delimiter" vsli:raw="The delimiter to look for.">Das Trennzeichen, das gesucht werden soll.</param>
      <param name="advancePastDelimiter" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the &lt;paramref name=&quot;delimiter&quot; /&gt; if found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> zum Vorbeibewegen am <paramref name="delimiter" />, wenn er gefunden wird; andernfalls <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;paramref name=&quot;delimiter&quot; /&gt; was found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der <paramref name="delimiter" /> gefunden wurde; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.Buffers.ReadOnlySequence{`0}@,System.ReadOnlySpan{`0},System.Boolean)">
      <summary vsli:raw="Tries to read data until the entire delimiter specified as a read-only span matches.">Versucht, bis zur Übereinstimmung mit dem als schreibgeschützte Spanne angegebenen gesamten Trennzeichen Daten zu lesen.</summary>
      <param name="sequence" vsli:raw="When the method returns, contains the data read, if any.">Enthält die ggf. von der Methode gelesenen Daten.</param>
      <param name="delimiter" vsli:raw="A read-only span that contains one or more delimiters.">Eine schreibgeschützte Spanne, die mindestens ein Trennzeichen enthält.</param>
      <param name="advancePastDelimiter" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the &lt;paramref name=&quot;delimiter&quot; /&gt; if found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> zum Vorbeibewegen am <paramref name="delimiter" />, wenn er gefunden wird; andernfalls <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;paramref name=&quot;delimiter&quot; /&gt; was found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der <paramref name="delimiter" /> gefunden wurde; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.ReadOnlySpan{`0}@,`0,`0,System.Boolean)">
      <summary vsli:raw="Tries to read everything up to the given &lt;paramref name=&quot;delimiter&quot; /&gt;, ignoring delimiters that are preceded by &lt;paramref name=&quot;delimiterEscape&quot; /&gt;.">Versucht, alles bis zum angegebenen <paramref name="delimiter" /> zu lesen, wobei Trennzeichen ignoriert werden, denen <paramref name="delimiterEscape" /> vorangestellt ist.</summary>
      <param name="span" vsli:raw="When the method returns, contains the data read, if any.">Enthält die ggf. von der Methode gelesenen Daten.</param>
      <param name="delimiter" vsli:raw="The delimiter to look for.">Das Trennzeichen, das gesucht werden soll.</param>
      <param name="delimiterEscape" vsli:raw="A value that indicates that an immediately following &lt;paramref name=&quot;delimiter&quot; /&gt; is to be skipped.">Ein Wert, der angibt, dass ein unmittelbar nachfolgender <paramref name="delimiter" /> übersprungen werden soll.</param>
      <param name="advancePastDelimiter" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the &lt;paramref name=&quot;delimiter&quot; /&gt; if found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> zum Vorbeibewegen am <paramref name="delimiter" />, wenn er gefunden wird; andernfalls <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;paramref name=&quot;delimiter&quot; /&gt; was found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der <paramref name="delimiter" /> gefunden wurde; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.ReadOnlySpan{`0}@,`0,System.Boolean)">
      <summary vsli:raw="Tries to read everything up to the given &lt;paramref name=&quot;delimiter&quot; /&gt;.">Versucht, alles bis zum angegebenen <paramref name="delimiter" /> zu lesen.</summary>
      <param name="span" vsli:raw="When the method returns, contains the data read, if any.">Enthält die ggf. von der Methode gelesenen Daten.</param>
      <param name="delimiter" vsli:raw="The delimiter to look for.">Das Trennzeichen, das gesucht werden soll.</param>
      <param name="advancePastDelimiter" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the &lt;paramref name=&quot;delimiter&quot; /&gt; if found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> zum Vorbeibewegen am <paramref name="delimiter" />, wenn er gefunden wird; andernfalls <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;paramref name=&quot;delimiter&quot; /&gt; was found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der <paramref name="delimiter" /> gefunden wurde; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.ReadOnlySpan{`0}@,System.ReadOnlySpan{`0},System.Boolean)">
      <summary vsli:raw="Try to read everything up to the given &lt;paramref name=&quot;delimiter&quot; /&gt;.">Versucht, alles bis zum angegebenen <paramref name="delimiter" /> zu lesen.</summary>
      <param name="sequence" vsli:raw="The read data, if any.">Die gelesenen Daten, sofern vorhanden</param>
      <param name="delimiter" vsli:raw="The delimiter to look for.">Das Trennzeichen, das gesucht werden soll.</param>
      <param name="advancePastDelimiter" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the &lt;paramref name=&quot;delimiter&quot; /&gt; if found.">
        <see langword="true" /> zum Vorbeibewegen am <paramref name="delimiter" />, sofern gefunden.</param>
      <param name="span" vsli:raw="The read data, if any.">Die gelesenen Daten, sofern vorhanden</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;paramref name=&quot;delimiter&quot; /&gt; was found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der <paramref name="delimiter" /> gefunden wurde; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadToAny(System.Buffers.ReadOnlySequence{`0}@,System.ReadOnlySpan{`0},System.Boolean)">
      <summary vsli:raw="Tries to read everything up to any of the specified &lt;paramref name=&quot;delimiters&quot; /&gt;.">Versucht, alles bis zu einem der angegebenen <paramref name="delimiters" /> zu lesen.</summary>
      <param name="sequence" vsli:raw="When the method returns, contains the data read, if any.">Enthält die ggf. von der Methode gelesenen Daten.</param>
      <param name="delimiters" vsli:raw="The delimiters to look for.">Die Trennzeichen, die gesucht werden sollen.</param>
      <param name="advancePastDelimiter" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the first found instance of any of the given &lt;paramref name=&quot;delimiters&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> zum Vorbeibewegen an der ersten gefundenen Instanz eines beliebigen der angegebenen <paramref name="delimiters" />; andernfalls <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if any of the &lt;paramref name=&quot;delimiters&quot; /&gt; were found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, falls beliebige der <paramref name="delimiters" /> gefunden wurden; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadToAny(System.ReadOnlySpan{`0}@,System.ReadOnlySpan{`0},System.Boolean)">
      <summary vsli:raw="Tries to read everything up to any of the specified &lt;paramref name=&quot;delimiters&quot; /&gt;.">Versucht, alles bis zu einem der angegebenen <paramref name="delimiters" /> zu lesen.</summary>
      <param name="span" vsli:raw="When the method returns, contains the data read, if any.">Enthält die ggf. von der Methode gelesenen Daten.</param>
      <param name="delimiters" vsli:raw="The delimiters to look for.">Die Trennzeichen, die gesucht werden sollen.</param>
      <param name="advancePastDelimiter" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the first found instance of any of the given &lt;paramref name=&quot;delimiters&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> zum Vorbeibewegen an der ersten gefundenen Instanz eines beliebigen der angegebenen <paramref name="delimiters" />; andernfalls <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if any of the &lt;paramref name=&quot;delimiters&quot; /&gt; were found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, falls beliebige der <paramref name="delimiters" /> gefunden wurden; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Consumed">
      <summary vsli:raw="Gets the total number of &lt;typeparamref name=&quot;T&quot; /&gt; values processed by the reader.">Ruft die Gesamtzahl der vom Reader verarbeiteten <typeparamref name="T" />-Werte ab.</summary>
      <returns vsli:raw="The total number of values processed by the reader.">Die Gesamtanzahl der vom Reader verarbeiteten Werte.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.CurrentSpan">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Span`1&quot; /&gt; that contains the current segment in the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;.">Ruft eine <see cref="T:System.Span`1" /> ab, die das aktuelle Segment in der <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> enthält.</summary>
      <returns vsli:raw="A span that contains the current segment in the sequence.">Eine Spanne, die das aktuelle Segment in der Sequenz enthält.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.CurrentSpanIndex">
      <summary vsli:raw="Gets the index in the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.CurrentSpan&quot; /&gt;.">Ruft den Index in der <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" /> ab.</summary>
      <returns vsli:raw="The index in the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.CurrentSpan&quot; /&gt;.">Der Index in der <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" /> .</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.End">
      <summary vsli:raw="Gets a value that indicates whether there is no more data in the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;.">Ruft einen Wert ab, der angibt, ob keine Daten mehr in der <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> vorhanden sind.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; when there is no more data in the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> , wenn keine weiteren Daten in der vorhanden sind, <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> andernfalls <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Length">
      <summary vsli:raw="Gets the count of items in the reader's &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;.">Ruft die Anzahl der Elemente in der <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> des Readers ab.</summary>
      <returns vsli:raw="The count of items in the reader's &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;.">Die Anzahl der Elemente in der des Readers <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> .</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Position">
      <summary vsli:raw="Gets the current position in the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;.">Ruft die aktuelle Position in der <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> ab.</summary>
      <returns vsli:raw="The current position in the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;.">Die aktuelle Position in <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> .</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Remaining">
      <summary vsli:raw="Gets  the remaining items in the reader's &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;.">Ruft die verbleibenden Elemente in der <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> des Readers ab.</summary>
      <returns vsli:raw="The remaining items in the reader's &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;">Die restlichen Elemente im Reader <see cref="P:System.Buffers.SequenceReader`1.Sequence" /></returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Sequence">
      <summary vsli:raw="Gets the underlying &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; for the reader.">Ruft die zugrunde liegende <see cref="T:System.Buffers.ReadOnlySequence`1" /> für den Reader ab.</summary>
      <returns vsli:raw="The underlying read-only sequence for the reader.">Die zugrunde liegende schreibgeschützte Sequenz für den Reader.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.UnreadSequence">
      <summary vsli:raw="Gets the unread portion of the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;.">Ruft den ungelesenen Teil der <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> ab.</summary>
      <returns vsli:raw="The unread portion of the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;.">Der ungelesene Teil von <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> .</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.UnreadSpan">
      <summary vsli:raw="Gets the unread portion of the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.CurrentSpan&quot; /&gt;.">Ruft den ungelesenen Teil der <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" /> ab.</summary>
      <returns vsli:raw="The unread portion of the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.CurrentSpan&quot; /&gt;.">Der ungelesene Teil von <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" /> .</returns>
    </member>
    <member name="T:System.Buffers.SequenceReaderExtensions">
      <summary vsli:raw="Provides extended functionality for the &lt;see cref=&quot;T:System.Buffers.SequenceReader`1&quot; /&gt; class that allows reading of endian specific numeric values from binary data.">Stellt erweiterte Funktionen für die <see cref="T:System.Buffers.SequenceReader`1" />-Klasse bereit, die das Lesen von Endian-spezifischen numerischen Werten aus Binärdaten ermöglicht</summary>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadBigEndian(System.Buffers.SequenceReader{System.Byte},System.Int16@)">
      <summary vsli:raw="Tries to read an &lt;see cref=&quot;T:System.Int16&quot; /&gt; as big endian.">Versucht, <see cref="T:System.Int16" /> als big-endian zu lesen</summary>
      <param name="reader" vsli:raw="The byte sequence reader instance from which the value is to be read.">Die Instanz des Bytesequenzlesers, aus der der Wert gelesen werden soll</param>
      <param name="value" vsli:raw="When the method returns, the value read out of the byte sequence reader, as big endian.">Wenn die Methode zurückgegeben wird, wird der Wert aus dem Bytesequenzleser als big-endian ausgelesen.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the read operation is successful; &lt;see langword=&quot;false&quot; /&gt; if there isn't enough data for an &lt;see cref=&quot;T:System.Int16&quot; /&gt;.">
        <see langword="true" />, wenn der Lesevorgang erfolgreich ist; <see langword="false" />, wenn nicht genügend Daten für einen <see cref="T:System.Int16" />-Wert vorhanden sind.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadBigEndian(System.Buffers.SequenceReader{System.Byte},System.Int32@)">
      <summary vsli:raw="Tries to read an &lt;see cref=&quot;T:System.Int32&quot; /&gt; as big endian.">Versucht, <see cref="T:System.Int32" /> als big-endian zu lesen</summary>
      <param name="reader" vsli:raw="The byte sequence reader from which to read the value.">Der Bytesequenzleser, aus dem der Wert gelesen werden soll</param>
      <param name="value" vsli:raw="When the method returns, the value read out of the byte sequence reader, as big endian.">Wenn die Methode zurückgegeben wird, wird der Wert aus dem Bytesequenzleser als big-endian ausgelesen.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the read operation is successful; &lt;see langword=&quot;false&quot; /&gt; if there isn't enough data for an &lt;see cref=&quot;T:System.Int32&quot; /&gt;.">
        <see langword="true" />, wenn der Lesevorgang erfolgreich ist; <see langword="false" />, wenn nicht genügend Daten für einen <see cref="T:System.Int32" />-Wert vorhanden sind.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadBigEndian(System.Buffers.SequenceReader{System.Byte},System.Int64@)">
      <summary vsli:raw="Tries to read an &lt;see cref=&quot;T:System.Int64&quot; /&gt; as big endian.">Versucht, <see cref="T:System.Int64" /> als big-endian zu lesen</summary>
      <param name="reader" vsli:raw="The byte sequence reader instance from which the value is to be read.">Die Instanz des Bytesequenzlesers, aus der der Wert gelesen werden soll</param>
      <param name="value" vsli:raw="When the method returns, the value read out of the byte sequence reader, as big endian.">Wenn die Methode zurückgegeben wird, wird der Wert aus dem Bytesequenzleser als big-endian ausgelesen.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the read operation is successful; &lt;see langword=&quot;false&quot; /&gt; if there isn't enough data for an &lt;see cref=&quot;T:System.Int64&quot; /&gt;.">
        <see langword="true" />, wenn der Lesevorgang erfolgreich ist; <see langword="false" />, wenn nicht genügend Daten für einen <see cref="T:System.Int64" />-Wert vorhanden sind.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadLittleEndian(System.Buffers.SequenceReader{System.Byte},System.Int16@)">
      <summary vsli:raw="Tries to read an &lt;see cref=&quot;T:System.Int16&quot; /&gt; as little endian.">Versucht, <see cref="T:System.Int16" /> als Little-Endian zu lesen</summary>
      <param name="reader" vsli:raw="The byte sequence reader instance from which the value is to be read.">Die Instanz des Bytesequenzlesers, aus der der Wert gelesen werden soll</param>
      <param name="value" vsli:raw="When the method returns, the value read out of the byte sequence reader, as little endian.">Wenn die Methode zurückgegeben wird, wird der Wert aus dem Bytesequenzleser als Little-Endian ausgelesen.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the read operation is successful; &lt;see langword=&quot;false&quot; /&gt; if there isn't enough data for an &lt;see cref=&quot;T:System.Int16&quot; /&gt;.">
        <see langword="true" />, wenn der Lesevorgang erfolgreich ist; <see langword="false" />, wenn nicht genügend Daten für einen <see cref="T:System.Int16" />-Wert vorhanden sind.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadLittleEndian(System.Buffers.SequenceReader{System.Byte},System.Int32@)">
      <summary vsli:raw="Tries to read an &lt;see cref=&quot;T:System.Int32&quot; /&gt; as little endian.">Versucht, <see cref="T:System.Int32" /> als Little-Endian zu lesen</summary>
      <param name="reader" vsli:raw="The byte sequence reader instance from which the value is to be read.">Die Instanz des Bytesequenzlesers, aus der der Wert gelesen werden soll</param>
      <param name="value" vsli:raw="When the method returns, the value read out of the byte sequence reader, as little endian.">Wenn die Methode zurückgegeben wird, wird der Wert aus dem Bytesequenzleser als Little-Endian ausgelesen.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the read operation is successful; &lt;see langword=&quot;false&quot; /&gt; if there isn't enough data for an &lt;see cref=&quot;T:System.Int32&quot; /&gt;.">
        <see langword="true" />, wenn der Lesevorgang erfolgreich ist; <see langword="false" />, wenn nicht genügend Daten für einen <see cref="T:System.Int32" />-Wert vorhanden sind.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadLittleEndian(System.Buffers.SequenceReader{System.Byte},System.Int64@)">
      <summary vsli:raw="Tries to read an &lt;see cref=&quot;T:System.Int64&quot; /&gt; as little endian.">Versucht, <see cref="T:System.Int64" /> als Little-Endian zu lesen</summary>
      <param name="reader" vsli:raw="The byte sequence reader instance from which the value is to be read.">Die Instanz des Bytesequenzlesers, aus der der Wert gelesen werden soll</param>
      <param name="value" vsli:raw="When the method returns, the value read out of the byte sequence reader, as little endian.">Wenn die Methode zurückgegeben wird, wird der Wert aus dem Bytesequenzleser als Little-Endian ausgelesen.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the read operation is successful; &lt;see langword=&quot;false&quot; /&gt; if there isn't enough data for an &lt;see cref=&quot;T:System.Int64&quot; /&gt;.">
        <see langword="true" />, wenn der Lesevorgang erfolgreich ist; <see langword="false" />, wenn nicht genügend Daten für einen <see cref="T:System.Int64" />-Wert vorhanden sind.</returns>
    </member>
    <member name="T:System.Buffers.StandardFormat">
      <summary vsli:raw="Represents a standard format string without using an actual string.">Stellt eine Standardformatzeichenfolge ohne Verwendung einer tatsächlichen Zeichenfolge dar.</summary>
    </member>
    <member name="F:System.Buffers.StandardFormat.MaxPrecision">
      <summary vsli:raw="Defines the maximum valid precision value.">Definiert den maximal gültigen Genauigkeitswert.</summary>
    </member>
    <member name="F:System.Buffers.StandardFormat.NoPrecision">
      <summary vsli:raw="Indicates that a format doesn't use a precision or that the precision is unspecified.">Gibt an, dass ein Format keine Genauigkeit verwendet oder dass die Genauigkeit nicht angegeben wurde.</summary>
    </member>
    <member name="M:System.Buffers.StandardFormat.#ctor(System.Char,System.Byte)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; structure.">Initialisiert eine neue Instanz der <see cref="T:System.Buffers.StandardFormat" />-Struktur.</summary>
      <param name="symbol" vsli:raw="A type-specific format specifier, such as 'G', 'D', or 'X'.">Ein typspezifischer Formatbezeichner, z.B. „G“, „D“ oder „X“.</param>
      <param name="precision" vsli:raw="An optional precision ranging from 0 to 99, or the special value &lt;see cref=&quot;F:System.Buffers.StandardFormat.NoPrecision&quot; /&gt; (the default).">Eine optionale Genauigkeit zwischen 0 und 99 oder der spezielle Wert <see cref="F:System.Buffers.StandardFormat.NoPrecision" /> (Standard).</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;symbol&quot; /&gt; is not &lt;see cref=&quot;F:System.Buffers.StandardFormat.NoPrecision&quot; /&gt;, and its value is greater than &lt;see cref=&quot;F:System.Buffers.StandardFormat.MaxPrecision&quot; /&gt;.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;symbol&quot; /&gt; cannot be converted to a &lt;see cref=&quot;T:System.Byte&quot; /&gt;.">
        <paramref name="symbol" /> ist nicht <see cref="F:System.Buffers.StandardFormat.NoPrecision" />, und der zugehörige Wert ist größer als <see cref="F:System.Buffers.StandardFormat.MaxPrecision" />.

- oder -

<paramref name="symbol" /> kann nicht in ein <see cref="T:System.Byte" /> konvertiert werden.</exception>
    </member>
    <member name="M:System.Buffers.StandardFormat.Equals(System.Buffers.StandardFormat)">
      <summary vsli:raw="Returns a value that indicates whether the specified &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; is equal to the current instance.">Gibt einen Wert zurück, der angibt, ob das aktuelle <see cref="T:System.Buffers.StandardFormat" /> der aktuellen Instanz entspricht.</summary>
      <param name="other" vsli:raw="The format to compare to the current instance.">Das Format, das mit der aktuellen Instanz verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two instances are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn die beiden Instanzen gleich sind, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.Equals(System.Object)">
      <summary vsli:raw="Returns a value that indicates whether the specified object is a &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; object that is equal to the current instance.">Gibt einen Wert zurück, der angibt, ob das angegebene Objekt ein <see cref="T:System.Buffers.StandardFormat" />-Objekt ist, das der aktuellen Instanz entspricht.</summary>
      <param name="obj" vsli:raw="An object to compare to the current instance.">Ein Objekt, das mit der aktuellen Instanz verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two instances are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn die beiden Instanzen gleich sind, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.GetHashCode">
      <summary vsli:raw="Returns the hash code for this instance.">Gibt den Hashcode für diese Instanz zurück.</summary>
      <returns vsli:raw="The hash code for this instance.">Der Hashcode für diese Instanz.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.op_Equality(System.Buffers.StandardFormat,System.Buffers.StandardFormat)">
      <summary vsli:raw="Returns a value that indicates whether two &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; instances are equal.">Gibt einen Wert zurück, der angibt, ob zwei <see cref="T:System.Buffers.StandardFormat" />-Instanzen gleich sind.</summary>
      <param name="left" vsli:raw="The first format to compare.">Das erste Format für den Vergleich.</param>
      <param name="right" vsli:raw="The second format to compare.">Das zweite Format für den Vergleich.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two instances are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn die beiden Instanzen gleich sind, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.op_Implicit(System.Char)~System.Buffers.StandardFormat">
      <summary vsli:raw="Converts a character to a &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; instance using &lt;see cref=&quot;F:System.Buffers.StandardFormat.NoPrecision&quot; /&gt; precision.">Konvertiert ein Zeichen mit der Genauigkeit <see cref="F:System.Buffers.StandardFormat.NoPrecision" /> in eine <see cref="T:System.Buffers.StandardFormat" />-Instanz.</summary>
      <param name="symbol" vsli:raw="The character to convert to a &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; value.">Das in einen <see cref="T:System.Buffers.StandardFormat" />-Wert umzuwandelnde Zeichen.</param>
      <returns vsli:raw="A format with a &lt;see cref=&quot;P:System.Buffers.StandardFormat.Symbol&quot; /&gt; property equal to &lt;paramref name=&quot;symbol&quot; /&gt; and a &lt;see cref=&quot;P:System.Buffers.StandardFormat.Precision&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Buffers.StandardFormat.NoPrecision&quot; /&gt;.">Ein Format mit einer <see cref="P:System.Buffers.StandardFormat.Symbol" />-Eigenschaft gleich <paramref name="symbol" /> und einer <see cref="P:System.Buffers.StandardFormat.Precision" />-Eigenschaft gleich <see cref="F:System.Buffers.StandardFormat.NoPrecision" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.op_Inequality(System.Buffers.StandardFormat,System.Buffers.StandardFormat)">
      <summary vsli:raw="Determines whether two &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; instances are unequal.">Stellt fest, ob zwei <see cref="T:System.Buffers.StandardFormat" />-Instanzen ungleich sind.</summary>
      <param name="left" vsli:raw="The first format to compare.">Das erste Format für den Vergleich.</param>
      <param name="right" vsli:raw="The second format to compare.">Das zweite Format für den Vergleich.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two formats are unequal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn die beiden Formate nicht identisch sind, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.Parse(System.ReadOnlySpan{System.Char})">
      <summary vsli:raw="Converts a &lt;see langword=&quot;ReadOnlySpan&amp;lt;System.Char&amp;gt;&quot; /&gt; into a &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; instance using &lt;see cref=&quot;F:System.Buffers.StandardFormat.NoPrecision&quot; /&gt; precision.">Konvertiert <see langword="ReadOnlySpan&lt;System.Char&gt;" /> mit der Genauigkeit <see cref="F:System.Buffers.StandardFormat.NoPrecision" /> in eine <see cref="T:System.Buffers.StandardFormat" />-Instanz.</summary>
      <param name="format" vsli:raw="A read-only span that contains the character to parse.">Ein schreibgeschützter Bereich, der das zu analysierende Zeichen enthält.</param>
      <returns vsli:raw="A value whose &lt;see cref=&quot;P:System.Buffers.StandardFormat.Symbol&quot; /&gt; property value is the character in &lt;paramref name=&quot;format&quot; /&gt; and whose &lt;see cref=&quot;P:System.Buffers.StandardFormat.Precision&quot; /&gt; property value is &lt;see cref=&quot;F:System.Buffers.StandardFormat.NoPrecision&quot; /&gt;.">Ein Wert, dessen <see cref="P:System.Buffers.StandardFormat.Symbol" />-Eigenschaftswert das Zeichen in <paramref name="format" /> ist und dessen <see cref="P:System.Buffers.StandardFormat.Precision" />-Eigenschaftswert <see cref="F:System.Buffers.StandardFormat.NoPrecision" /> lautet.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.Parse(System.String)">
      <summary vsli:raw="Converts a classic .NET standard format string to a &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; instance.">Konvertiert eine klassische .NET-Standardformatzeichenfolge in eine <see cref="T:System.Buffers.StandardFormat" />-Instanz.</summary>
      <param name="format" vsli:raw="A classic .NET standard format string.">Eine klassische .NET-Standardformatzeichenfolge.</param>
      <exception cref="T:System.FormatException" vsli:raw="&lt;paramref name=&quot;format&quot; /&gt; is not a valid standard format string.">
        <paramref name="format" /> ist keine gültige Standard-Formatzeichenfolge.</exception>
      <returns vsli:raw="A format.">Ein Format.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.ToString">
      <summary vsli:raw="Returns the string representation of this format.">Gibt die Zeichenfolgendarstellung dieses Formats zurück.</summary>
      <returns vsli:raw="The string representation of this format.">Die Zeichenfolgendarstellung dieses Formats.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.TryParse(System.ReadOnlySpan{System.Char},System.Buffers.StandardFormat@)">
      <summary vsli:raw="Attempts to convert a &lt;see langword=&quot;ReadOnlySpan&amp;lt;Char&amp;gt;&quot; /&gt; to a &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; instance and returns a value that indicates whether the parsing operation succeeded.">Versucht, ein <see langword="ReadOnlySpan&lt;Char&gt;" /> in eine <see cref="T:System.Buffers.StandardFormat" />-Instanz zu konvertieren, und gibt einen Wert zurück, der angibt, ob der Analysevorgang erfolgreich war.</summary>
      <param name="format" vsli:raw="A read-only span that contains the character to convert.">Ein schreibgeschützter Bereich, der das zu konvertierende Zeichen enthält.</param>
      <param name="result" vsli:raw="When the method returns, contains the parsed &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; instance if the operation was successful.">Wenn diese Methode beendet wird, enthält sie die analysierte <see cref="T:System.Buffers.StandardFormat" />-Instanz, sofern der Vorgang erfolgreich war.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the parsing operation was successful; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der Analysevorgang erfolgreich war, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="P:System.Buffers.StandardFormat.HasPrecision">
      <summary vsli:raw="Gets a value that indicates whether a format has a defined precision.">Ruft einen Wert ab, der angibt, ob ein Format eine definierte Genauigkeit aufweist.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the format has a precision other than &lt;see cref=&quot;F:System.Buffers.StandardFormat.NoPrecision&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> , wenn das Format eine andere Genauigkeit als aufweist <see cref="F:System.Buffers.StandardFormat.NoPrecision" /> , andernfalls <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Buffers.StandardFormat.IsDefault">
      <summary vsli:raw="Gets a value that indicates whether the current instance is a default format.">Ruft einen Wert ab, der angibt, ob die aktuelle Instanz ein Standardformat ist.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current instance is a default format; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> , wenn die aktuelle Instanz ein Standardformat ist. andernfalls <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Buffers.StandardFormat.Precision">
      <summary vsli:raw="Gets the precision component of the format.">Ruft die Genauigkeitskomponente des Formats ab.</summary>
      <returns vsli:raw="The precision component, which can be &lt;see cref=&quot;F:System.Buffers.StandardFormat.NoPrecision&quot; /&gt;, or can range from 0 to 9.">Die Genauigkeits Komponente, die sein kann <see cref="F:System.Buffers.StandardFormat.NoPrecision" /> , oder zwischen 0 und 9 liegen kann.</returns>
    </member>
    <member name="P:System.Buffers.StandardFormat.Symbol">
      <summary vsli:raw="Gets the character component of the format.">Ruft die Zeichenkomponente des Formats ab.</summary>
      <returns vsli:raw="The character component of the format.">Die Zeichen Komponente des Formats.</returns>
    </member>
    <member name="T:System.Buffers.Text.Base64">
      <summary>Konvertiert zwischen binären Daten und UTF-8-codiertem Text, der als Base64 dargestellt wird.</summary>
    </member>
    <member name="M:System.Buffers.Text.Base64.DecodeFromUtf8(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@,System.Int32@,System.Boolean)">
      <summary>Decodiert den Bereich des UTF-8-codierten Texts in Base64-Darstellung in binäre Daten. Wenn die Eingabe kein Vielfaches von 4 ist, wird so viel wie möglich bis zum nächsten Vielfachen von 4 decodiert.</summary>
      <param name="utf8">Der Eingabebereich, der UTF-8-codierten Text in Base64-Darstellung enthält, der decodiert werden muss.</param>
      <param name="bytes">Der Ausgabebereich, der das Ergebnis des Vorgangs enthält, d.h. die decodierten binären Daten.</param>
      <param name="bytesConsumed">Die Anzahl der während des Vorgangs verwendeten eingegebenen Bytes. Dies kann verwendet werden, um die Eingabe ggf. für nachfolgende Aufrufe zu unterteilen.</param>
      <param name="bytesWritten">Die Anzahl der in den Ausgabebereich geschriebenen Bytes. Dies kann verwendet werden, um die Ausgabe ggf. für nachfolgende Aufrufe zu unterteilen.</param>
      <param name="isFinalBlock">
        <see langword="true" /> (Standard), wenn der Eingabebereich die gesamten zu decodierenden Daten enthält. <see langword="false" />, wenn der Eingabebereich Teildaten enthält, auf die weitere Daten folgen.</param>
      <returns>Einer der Enumerationswerte, der den Status der Decodierung anzeigt.</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.DecodeFromUtf8InPlace(System.Span{System.Byte},System.Int32@)">
      <summary>Decodiert den Bereich des UTF-8-codierten Texts in Base64-Darstellung (direkt) in binäre Daten. Die Ausgabe des decodierten binären Texts ist kleiner als die Textdaten, die in der Eingabe enthalten sind (der Vorgang verkleinert die Daten). Wenn die Eingabe kein Vielfaches von 4 ist, decodiert die Methode keine Daten.</summary>
      <param name="buffer">Der Eingabebereich, der Base64-Text enthält, der decodiert werden muss.</param>
      <param name="bytesWritten">Die Anzahl der in den Puffer geschriebenen Bytes.</param>
      <returns>Einer der Enumerationswerte, der den Status der Decodierung anzeigt.</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.EncodeToUtf8(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@,System.Int32@,System.Boolean)">
      <summary>Codiert den Bereich der binären Daten in UTF-8-codierten Text in Base64-Darstellung.</summary>
      <param name="bytes">Der Eingabebereich, der Binärdaten enthält, die codiert werden müssen.</param>
      <param name="utf8">Der Ausgabebereich, der das Ergebnis des Vorgangs enthält, d.h. den UTF-8-codierten Text in Base64-Darstellung.</param>
      <param name="bytesConsumed">Die Anzahl der während des Vorgangs verwendeten eingegebenen Bytes. Dies kann verwendet werden, um die Eingabe ggf. für nachfolgende Aufrufe zu unterteilen.</param>
      <param name="bytesWritten">Die Anzahl der in den Ausgabebereich geschriebenen Bytes. Dies kann verwendet werden, um die Ausgabe ggf. für nachfolgende Aufrufe zu unterteilen.</param>
      <param name="isFinalBlock">
        <see langword="true" /> (Standard), wenn der Eingabebereich die gesamten zu codierenden Daten enthält. <see langword="false" />, wenn der Eingabebereich Teildaten enthält, auf die weitere Daten folgen.</param>
      <returns>Einer der Enumerationswerte, der den Status der Codierung anzeigt.</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.EncodeToUtf8InPlace(System.Span{System.Byte},System.Int32,System.Int32@)">
      <summary>Codiert den Bereich der binären Daten (direkt) in UTF-8-codierten Text in Base64-Darstellung. Die Ausgabe des codierten Texts ist größer als die binären Daten, die in der Eingabe enthalten sind (der Vorgang vergrößert die Daten).</summary>
      <param name="buffer">Der Eingabebereich, der Binärdaten enthält, die codiert werden müssen. Da die Methode eine direkte Konvertierung ausführt, muss sie groß genug zum Speichern des Ergebnisses des Vorgangs sein.</param>
      <param name="dataLength">Die Anzahl der Bytes aus Binärdaten, die im Puffer enthalten sind, der codiert werden muss. Dieser Wert muss kleiner als die Pufferlänge sein.</param>
      <param name="bytesWritten">Die Anzahl der in den Puffer geschriebenen Bytes.</param>
      <returns>Einer der Enumerationswerte, der den Status der Codierung anzeigt.</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.GetMaxDecodedFromUtf8Length(System.Int32)">
      <summary>Gibt die maximale Länge (in Bytes) des Ergebnisses zurück, wenn Sie Base64-codierten Text innerhalb eines Bytebereichs mit der angegebenen Länge decodieren würden.</summary>
      <param name="length">Die Größe der Bytespanne</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" /> ist kleiner als 0.</exception>
      <returns>Die maximal zulässige Länge des Ergebnisses in Bytes.</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.GetMaxEncodedToUtf8Length(System.Int32)">
      <summary>Gibt die maximale Länge (in Bytes) des Ergebnisses zurück, wenn Sie binäre Daten innerhalb eines Bytebereichs mit der angegebenen Länge codieren würden.</summary>
      <param name="length">Die Größe der Bytespanne</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" /> ist kleiner als 0 oder größer als 1.610.612.733 (da Codieren die Daten mit dem Faktor 4/3 vergrößert).</exception>
      <returns>Die maximal zulässige Länge des Ergebnisses in Bytes.</returns>
    </member>
    <member name="T:System.Buffers.Text.Utf8Formatter">
      <summary vsli:raw="Provides static methods to format common data types as Utf8 strings.">Stellt statische Methoden bereit, um allgemeine Datentypen als UTF8-Zeichen folgen zu formatieren.</summary>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Boolean,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.Boolean&quot; /&gt; as a UTF8 string.">Formatiert einen <see cref="T:System.Boolean" />-Wert als UTF8-Zeichenfolge.</summary>
      <param name="value" vsli:raw="The value to format.">Der zu formatierende Wert.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Der Puffer, in den der UTF8-formatierte Wert geschrieben wird.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Enthält bei der Rückgabe der Methode die Länge des formatierten Texts in Bytes.</param>
      <param name="format" vsli:raw="The standard format to use.">Das zu verwendende Standardformat.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" />, wenn der Formatierungsvorgang erfolgreich ist; <see langword="false" />, wenn <paramref name="buffer" /> zu klein ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Byte,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.Byte&quot; /&gt; as a UTF8 string.">Formatiert einen <see cref="T:System.Byte" />-Wert als UTF8-Zeichenfolge.</summary>
      <param name="value" vsli:raw="The value to format.">Der zu formatierende Wert.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Der Puffer, in den der UTF8-formatierte Wert geschrieben wird.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Enthält bei der Rückgabe der Methode die Länge des formatierten Texts in Bytes.</param>
      <param name="format" vsli:raw="The standard format to use.">Das zu verwendende Standardformat.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" />, wenn der Formatierungsvorgang erfolgreich ist; <see langword="false" />, wenn <paramref name="buffer" /> zu klein ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.DateTime,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.DateTime&quot; /&gt; as a UTF8 string.">Formatiert einen <see cref="T:System.DateTime" />-Wert als UTF8-Zeichenfolge.</summary>
      <param name="value" vsli:raw="The value to format.">Der zu formatierende Wert.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Der Puffer, in den der UTF8-formatierte Wert geschrieben wird.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Enthält bei der Rückgabe der Methode die Länge des formatierten Texts in Bytes.</param>
      <param name="format" vsli:raw="The standard format to use.">Das zu verwendende Standardformat.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" />, wenn der Formatierungsvorgang erfolgreich ist; <see langword="false" />, wenn <paramref name="buffer" /> zu klein ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.DateTimeOffset,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.DateTimeOffset&quot; /&gt; as a UTF8 string.">Formatiert einen <see cref="T:System.DateTimeOffset" />-Wert als UTF8-Zeichenfolge.</summary>
      <param name="value" vsli:raw="The value to format.">Der zu formatierende Wert.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Der Puffer, in den der UTF8-formatierte Wert geschrieben wird.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Enthält bei der Rückgabe der Methode die Länge des formatierten Texts in Bytes.</param>
      <param name="format" vsli:raw="The standard format to use.">Das zu verwendende Standardformat.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" />, wenn der Formatierungsvorgang erfolgreich ist; <see langword="false" />, wenn <paramref name="buffer" /> zu klein ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Decimal,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.Decimal&quot; /&gt; as a UTF8 string.">Formatiert einen <see cref="T:System.Decimal" />-Wert als UTF8-Zeichenfolge.</summary>
      <param name="value" vsli:raw="The value to format.">Der zu formatierende Wert.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Der Puffer, in den der UTF8-formatierte Wert geschrieben wird.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Enthält bei der Rückgabe der Methode die Länge des formatierten Texts in Bytes.</param>
      <param name="format" vsli:raw="The standard format to use.">Das zu verwendende Standardformat.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" />, wenn der Formatierungsvorgang erfolgreich ist; <see langword="false" />, wenn <paramref name="buffer" /> zu klein ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Double,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.Double&quot; /&gt; as a UTF8 string.">Formatiert einen <see cref="T:System.Double" />-Wert als UTF8-Zeichenfolge.</summary>
      <param name="value" vsli:raw="The value to format.">Der zu formatierende Wert.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Der Puffer, in den der UTF8-formatierte Wert geschrieben wird.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Enthält bei der Rückgabe der Methode die Länge des formatierten Texts in Bytes.</param>
      <param name="format" vsli:raw="The standard format to use.">Das zu verwendende Standardformat.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" />, wenn der Formatierungsvorgang erfolgreich ist; <see langword="false" />, wenn <paramref name="buffer" /> zu klein ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Guid,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.Guid&quot; /&gt; as a UTF8 string.">Formatiert einen <see cref="T:System.Guid" />-Wert als UTF8-Zeichenfolge.</summary>
      <param name="value" vsli:raw="The value to format.">Der zu formatierende Wert.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Der Puffer, in den der UTF8-formatierte Wert geschrieben wird.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Enthält bei der Rückgabe der Methode die Länge des formatierten Texts in Bytes.</param>
      <param name="format" vsli:raw="The standard format to use.">Das zu verwendende Standardformat.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" />, wenn der Formatierungsvorgang erfolgreich ist; <see langword="false" />, wenn <paramref name="buffer" /> zu klein ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Int16,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats an &lt;see cref=&quot;T:System.Int16&quot; /&gt; as a UTF8 string.">Formatiert einen <see cref="T:System.Int16" />-Wert als UTF8-Zeichenfolge.</summary>
      <param name="value" vsli:raw="The value to format.">Der zu formatierende Wert.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Der Puffer, in den der UTF8-formatierte Wert geschrieben wird.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Enthält bei der Rückgabe der Methode die Länge des formatierten Texts in Bytes.</param>
      <param name="format" vsli:raw="The standard format to use.">Das zu verwendende Standardformat.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" />, wenn der Formatierungsvorgang erfolgreich ist; <see langword="false" />, wenn <paramref name="buffer" /> zu klein ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Int32,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats an &lt;see cref=&quot;T:System.Int32&quot; /&gt; as a UTF8 string.">Formatiert einen <see cref="T:System.Int32" />-Wert als UTF8-Zeichenfolge.</summary>
      <param name="value" vsli:raw="The value to format.">Der zu formatierende Wert.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Der Puffer, in den der UTF8-formatierte Wert geschrieben wird.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Enthält bei der Rückgabe der Methode die Länge des formatierten Texts in Bytes.</param>
      <param name="format" vsli:raw="The standard format to use.">Das zu verwendende Standardformat.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" />, wenn der Formatierungsvorgang erfolgreich ist; <see langword="false" />, wenn <paramref name="buffer" /> zu klein ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Int64,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats an &lt;see cref=&quot;T:System.Int64&quot; /&gt; as a UTF8 string.">Formatiert einen <see cref="T:System.Int64" />-Wert als UTF8-Zeichenfolge.</summary>
      <param name="value" vsli:raw="The value to format.">Der zu formatierende Wert.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Der Puffer, in den der UTF8-formatierte Wert geschrieben wird.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Enthält bei der Rückgabe der Methode die Länge des formatierten Texts in Bytes.</param>
      <param name="format" vsli:raw="The standard format to use.">Das zu verwendende Standardformat.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" />, wenn der Formatierungsvorgang erfolgreich ist; <see langword="false" />, wenn <paramref name="buffer" /> zu klein ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.SByte,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats an &lt;see cref=&quot;T:System.SByte&quot; /&gt; as a UTF8 string.">Formatiert einen <see cref="T:System.SByte" />-Wert als UTF8-Zeichenfolge.</summary>
      <param name="value" vsli:raw="The value to format.">Der zu formatierende Wert.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Der Puffer, in den der UTF8-formatierte Wert geschrieben wird.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Enthält bei der Rückgabe der Methode die Länge des formatierten Texts in Bytes.</param>
      <param name="format" vsli:raw="The standard format to use.">Das zu verwendende Standardformat.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" />, wenn der Formatierungsvorgang erfolgreich ist; <see langword="false" />, wenn <paramref name="buffer" /> zu klein ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Single,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.Single&quot; /&gt; as a UTF8 string.">Formatiert einen <see cref="T:System.Single" />-Wert als UTF8-Zeichenfolge.</summary>
      <param name="value" vsli:raw="The value to format.">Der zu formatierende Wert.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Der Puffer, in den der UTF8-formatierte Wert geschrieben wird.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Enthält bei der Rückgabe der Methode die Länge des formatierten Texts in Bytes.</param>
      <param name="format" vsli:raw="The standard format to use.">Das zu verwendende Standardformat.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" />, wenn der Formatierungsvorgang erfolgreich ist; <see langword="false" />, wenn <paramref name="buffer" /> zu klein ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.TimeSpan,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; as a UTF8 string.">Formatiert einen <see cref="T:System.TimeSpan" />-Wert als UTF8-Zeichenfolge.</summary>
      <param name="value" vsli:raw="The value to format.">Der zu formatierende Wert.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Der Puffer, in den der UTF8-formatierte Wert geschrieben wird.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Enthält bei der Rückgabe der Methode die Länge des formatierten Texts in Bytes.</param>
      <param name="format" vsli:raw="The standard format to use.">Das zu verwendende Standardformat.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" />, wenn der Formatierungsvorgang erfolgreich ist; <see langword="false" />, wenn <paramref name="buffer" /> zu klein ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.UInt16,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; as a UTF8 string.">Formatiert einen <see cref="T:System.UInt16" />-Wert als UTF8-Zeichenfolge.</summary>
      <param name="value" vsli:raw="The value to format.">Der zu formatierende Wert.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Der Puffer, in den der UTF8-formatierte Wert geschrieben wird.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Enthält bei der Rückgabe der Methode die Länge des formatierten Texts in Bytes.</param>
      <param name="format" vsli:raw="The standard format to use.">Das zu verwendende Standardformat.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" />, wenn der Formatierungsvorgang erfolgreich ist; <see langword="false" />, wenn <paramref name="buffer" /> zu klein ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.UInt32,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; as a UTF8 string.">Formatiert einen <see cref="T:System.UInt32" />-Wert als UTF8-Zeichenfolge.</summary>
      <param name="value" vsli:raw="The value to format.">Der zu formatierende Wert.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Der Puffer, in den der UTF8-formatierte Wert geschrieben wird.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Enthält bei der Rückgabe der Methode die Länge des formatierten Texts in Bytes.</param>
      <param name="format" vsli:raw="The standard format to use.">Das zu verwendende Standardformat.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" />, wenn der Formatierungsvorgang erfolgreich ist; <see langword="false" />, wenn <paramref name="buffer" /> zu klein ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.UInt64,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; as a UTF8 string.">Formatiert einen <see cref="T:System.UInt64" />-Wert als UTF8-Zeichenfolge.</summary>
      <param name="value" vsli:raw="The value to format.">Der zu formatierende Wert.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Der Puffer, in den der UTF8-formatierte Wert geschrieben wird.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Enthält bei der Rückgabe der Methode die Länge des formatierten Texts in Bytes.</param>
      <param name="format" vsli:raw="The standard format to use.">Das zu verwendende Standardformat.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" />, wenn der Formatierungsvorgang erfolgreich ist; <see langword="false" />, wenn <paramref name="buffer" /> zu klein ist.</returns>
    </member>
    <member name="T:System.Buffers.Text.Utf8Parser">
      <summary vsli:raw="Provides static methods to parse Utf8 strings to common data types.">Bietet statische Methoden zum Analysieren von UTF8-Zeichenfolgen in allgemeine Datentypen.</summary>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Boolean@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.Boolean&quot; /&gt; at the start of a Utf8 string.">Analysiert einen <see cref="T:System.Boolean" />-Wert am Anfang einer UTF8-Zeichenfolge.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Die zu analysierende UTF8-Zeichenfolge.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Enthält nach Rückgabe der Methode den aus <paramref name="source" /> analysierten Wert, wenn der Analysevorgang erfolgreich war.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Enthält bei Rückgabe der Methode die Länge der analysierten Teilzeichenfolge in Bytes, wenn der Analysevorgang erfolgreich war. Wenn bei der Methode ein Fehler auftritt, wird <paramref name="bytesConsumed" /> auf 0 gesetzt.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Das erwartete Format der UTF8-Zeichenfolge.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> für Erfolg; <see langword="false" />, wenn die Zeichenfolge syntaktisch ungültig war oder ein Über- bzw. Unterlauf aufgetreten ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Byte@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.Byte&quot; /&gt; at the start of a Utf8 string.">Analysiert einen <see cref="T:System.Byte" />-Wert am Anfang einer UTF8-Zeichenfolge.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Die zu analysierende UTF8-Zeichenfolge.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Enthält nach Rückgabe der Methode den aus <paramref name="source" /> analysierten Wert, wenn der Analysevorgang erfolgreich war.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Enthält bei Rückgabe der Methode die Länge der analysierten Teilzeichenfolge in Bytes, wenn der Analysevorgang erfolgreich war. Wenn bei der Methode ein Fehler auftritt, wird <paramref name="bytesConsumed" /> auf 0 gesetzt.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Das erwartete Format der UTF8-Zeichenfolge.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> für Erfolg; <see langword="false" />, wenn die Zeichenfolge syntaktisch ungültig war oder ein Über- bzw. Unterlauf aufgetreten ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.DateTime@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.DateTime&quot; /&gt; at the start of a Utf8 string.">Analysiert einen <see cref="T:System.DateTime" />-Wert am Anfang einer UTF8-Zeichenfolge.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Die zu analysierende UTF8-Zeichenfolge.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Enthält nach Rückgabe der Methode den aus <paramref name="source" /> analysierten Wert, wenn der Analysevorgang erfolgreich war.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Enthält bei Rückgabe der Methode die Länge der analysierten Teilzeichenfolge in Bytes, wenn der Analysevorgang erfolgreich war. Wenn bei der Methode ein Fehler auftritt, wird <paramref name="bytesConsumed" /> auf 0 gesetzt.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Das erwartete Format der UTF8-Zeichenfolge.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> für Erfolg; <see langword="false" />, wenn die Zeichenfolge syntaktisch ungültig war oder ein Über- bzw. Unterlauf aufgetreten ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.DateTimeOffset@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.DateTimeOffset&quot; /&gt; at the start of a Utf8 string.">Analysiert einen <see cref="T:System.DateTimeOffset" />-Wert am Anfang einer UTF8-Zeichenfolge.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Die zu analysierende UTF8-Zeichenfolge.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Enthält nach Rückgabe der Methode den aus <paramref name="source" /> analysierten Wert, wenn der Analysevorgang erfolgreich war.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Enthält bei Rückgabe der Methode die Länge der analysierten Teilzeichenfolge in Bytes, wenn der Analysevorgang erfolgreich war. Wenn bei der Methode ein Fehler auftritt, wird <paramref name="bytesConsumed" /> auf 0 gesetzt.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Das erwartete Format der UTF8-Zeichenfolge.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> für Erfolg; <see langword="false" />, wenn die Zeichenfolge syntaktisch ungültig war oder ein Über- bzw. Unterlauf aufgetreten ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Decimal@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.Decimal&quot; /&gt; at the start of a Utf8 string.">Analysiert einen <see cref="T:System.Decimal" />-Wert am Anfang einer UTF8-Zeichenfolge.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Die zu analysierende UTF8-Zeichenfolge.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Enthält nach Rückgabe der Methode den aus <paramref name="source" /> analysierten Wert, wenn der Analysevorgang erfolgreich war.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Enthält bei Rückgabe der Methode die Länge der analysierten Teilzeichenfolge in Bytes, wenn der Analysevorgang erfolgreich war. Wenn bei der Methode ein Fehler auftritt, wird <paramref name="bytesConsumed" /> auf 0 gesetzt.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Das erwartete Format der UTF8-Zeichenfolge.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> für Erfolg; <see langword="false" />, wenn die Zeichenfolge syntaktisch ungültig war oder ein Über- bzw. Unterlauf aufgetreten ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Double@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.Double&quot; /&gt; at the start of a Utf8 string.">Analysiert einen <see cref="T:System.Double" />-Wert am Anfang einer UTF8-Zeichenfolge.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Die zu analysierende UTF8-Zeichenfolge.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Enthält nach Rückgabe der Methode den aus <paramref name="source" /> analysierten Wert, wenn der Analysevorgang erfolgreich war.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Enthält bei Rückgabe der Methode die Länge der analysierten Teilzeichenfolge in Bytes, wenn der Analysevorgang erfolgreich war. Wenn bei der Methode ein Fehler auftritt, wird <paramref name="bytesConsumed" /> auf 0 gesetzt.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Das erwartete Format der UTF8-Zeichenfolge.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> für Erfolg; <see langword="false" />, wenn die Zeichenfolge syntaktisch ungültig war oder ein Über- bzw. Unterlauf aufgetreten ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Guid@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.Guid&quot; /&gt; at the start of a Utf8 string.">Analysiert einen <see cref="T:System.Guid" />-Wert am Anfang einer UTF8-Zeichenfolge.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Die zu analysierende UTF8-Zeichenfolge.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Enthält nach Rückgabe der Methode den aus <paramref name="source" /> analysierten Wert, wenn der Analysevorgang erfolgreich war.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Enthält bei Rückgabe der Methode die Länge der analysierten Teilzeichenfolge in Bytes, wenn der Analysevorgang erfolgreich war. Wenn bei der Methode ein Fehler auftritt, wird <paramref name="bytesConsumed" /> auf 0 gesetzt.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Das erwartete Format der UTF8-Zeichenfolge.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> für Erfolg; <see langword="false" />, wenn die Zeichenfolge syntaktisch ungültig war oder ein Über- bzw. Unterlauf aufgetreten ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Int16@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses an &lt;see cref=&quot;T:System.Int16&quot; /&gt; at the start of a Utf8 string.">Analysiert einen <see cref="T:System.Int16" />-Wert am Anfang einer UTF8-Zeichenfolge.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Die zu analysierende UTF8-Zeichenfolge.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Enthält nach Rückgabe der Methode den aus <paramref name="source" /> analysierten Wert, wenn der Analysevorgang erfolgreich war.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Enthält bei Rückgabe der Methode die Länge der analysierten Teilzeichenfolge in Bytes, wenn der Analysevorgang erfolgreich war. Wenn bei der Methode ein Fehler auftritt, wird <paramref name="bytesConsumed" /> auf 0 gesetzt.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Das erwartete Format der UTF8-Zeichenfolge.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> für Erfolg; <see langword="false" />, wenn die Zeichenfolge syntaktisch ungültig war oder ein Über- bzw. Unterlauf aufgetreten ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Int32@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses an &lt;see cref=&quot;T:System.Int32&quot; /&gt; at the start of a Utf8 string.">Analysiert einen <see cref="T:System.Int32" />-Wert am Anfang einer UTF8-Zeichenfolge.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Die zu analysierende UTF8-Zeichenfolge.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Enthält nach Rückgabe der Methode den aus <paramref name="source" /> analysierten Wert, wenn der Analysevorgang erfolgreich war.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Enthält bei Rückgabe der Methode die Länge der analysierten Teilzeichenfolge in Bytes, wenn der Analysevorgang erfolgreich war. Wenn bei der Methode ein Fehler auftritt, wird <paramref name="bytesConsumed" /> auf 0 gesetzt.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Das erwartete Format der UTF8-Zeichenfolge.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> für Erfolg; <see langword="false" />, wenn die Zeichenfolge syntaktisch ungültig war oder ein Über- bzw. Unterlauf aufgetreten ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Int64@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses an &lt;see cref=&quot;T:System.Int64&quot; /&gt; at the start of a Utf8 string.">Analysiert einen <see cref="T:System.Int64" />-Wert am Anfang einer UTF8-Zeichenfolge.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Die zu analysierende UTF8-Zeichenfolge.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Enthält nach Rückgabe der Methode den aus <paramref name="source" /> analysierten Wert, wenn der Analysevorgang erfolgreich war.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Enthält bei Rückgabe der Methode die Länge der analysierten Teilzeichenfolge in Bytes, wenn der Analysevorgang erfolgreich war. Wenn bei der Methode ein Fehler auftritt, wird <paramref name="bytesConsumed" /> auf 0 gesetzt.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Das erwartete Format der UTF8-Zeichenfolge.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> für Erfolg; <see langword="false" />, wenn die Zeichenfolge syntaktisch ungültig war oder ein Über- bzw. Unterlauf aufgetreten ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.SByte@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses an &lt;see cref=&quot;T:System.SByte&quot; /&gt; at the start of a Utf8 string.">Analysiert einen <see cref="T:System.SByte" />-Wert am Anfang einer UTF8-Zeichenfolge.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Die zu analysierende UTF8-Zeichenfolge.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Enthält nach Rückgabe der Methode den aus <paramref name="source" /> analysierten Wert, wenn der Analysevorgang erfolgreich war.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Enthält bei Rückgabe der Methode die Länge der analysierten Teilzeichenfolge in Bytes, wenn der Analysevorgang erfolgreich war. Wenn bei der Methode ein Fehler auftritt, wird <paramref name="bytesConsumed" /> auf 0 gesetzt.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Das erwartete Format der UTF8-Zeichenfolge.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> für Erfolg; <see langword="false" />, wenn die Zeichenfolge syntaktisch ungültig war oder ein Über- bzw. Unterlauf aufgetreten ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Single@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.Single&quot; /&gt; at the start of a Utf8 string.">Analysiert einen <see cref="T:System.Single" />-Wert am Anfang einer UTF8-Zeichenfolge.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Die zu analysierende UTF8-Zeichenfolge.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Enthält nach Rückgabe der Methode den aus <paramref name="source" /> analysierten Wert, wenn der Analysevorgang erfolgreich war.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Enthält bei Rückgabe der Methode die Länge der analysierten Teilzeichenfolge in Bytes, wenn der Analysevorgang erfolgreich war. Wenn bei der Methode ein Fehler auftritt, wird <paramref name="bytesConsumed" /> auf 0 gesetzt.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Das erwartete Format der UTF8-Zeichenfolge.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> für Erfolg; <see langword="false" />, wenn die Zeichenfolge syntaktisch ungültig war oder ein Über- bzw. Unterlauf aufgetreten ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.TimeSpan@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; at the start of a Utf8 string.">Analysiert einen <see cref="T:System.TimeSpan" />-Wert am Anfang einer UTF8-Zeichenfolge.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Die zu analysierende UTF8-Zeichenfolge.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Enthält nach Rückgabe der Methode den aus <paramref name="source" /> analysierten Wert, wenn der Analysevorgang erfolgreich war.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Enthält bei Rückgabe der Methode die Länge der analysierten Teilzeichenfolge in Bytes, wenn der Analysevorgang erfolgreich war. Wenn bei der Methode ein Fehler auftritt, wird <paramref name="bytesConsumed" /> auf 0 gesetzt.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Das erwartete Format der UTF8-Zeichenfolge.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> für Erfolg; <see langword="false" />, wenn die Zeichenfolge syntaktisch ungültig war oder ein Über- bzw. Unterlauf aufgetreten ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.UInt16@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; at the start of a Utf8 string.">Analysiert einen <see cref="T:System.UInt16" />-Wert am Anfang einer UTF8-Zeichenfolge.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Die zu analysierende UTF8-Zeichenfolge.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Enthält nach Rückgabe der Methode den aus <paramref name="source" /> analysierten Wert, wenn der Analysevorgang erfolgreich war.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Enthält bei Rückgabe der Methode die Länge der analysierten Teilzeichenfolge in Bytes, wenn der Analysevorgang erfolgreich war. Wenn bei der Methode ein Fehler auftritt, wird <paramref name="bytesConsumed" /> auf 0 gesetzt.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Das erwartete Format der UTF8-Zeichenfolge.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> für Erfolg; <see langword="false" />, wenn die Zeichenfolge syntaktisch ungültig war oder ein Über- bzw. Unterlauf aufgetreten ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.UInt32@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; at the start of a Utf8 string.">Analysiert einen <see cref="T:System.UInt32" />-Wert am Anfang einer UTF8-Zeichenfolge.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Die zu analysierende UTF8-Zeichenfolge.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Enthält nach Rückgabe der Methode den aus <paramref name="source" /> analysierten Wert, wenn der Analysevorgang erfolgreich war.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Enthält bei Rückgabe der Methode die Länge der analysierten Teilzeichenfolge in Bytes, wenn der Analysevorgang erfolgreich war. Wenn bei der Methode ein Fehler auftritt, wird <paramref name="bytesConsumed" /> auf 0 gesetzt.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Das erwartete Format der UTF8-Zeichenfolge.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> für Erfolg; <see langword="false" />, wenn die Zeichenfolge syntaktisch ungültig war oder ein Über- bzw. Unterlauf aufgetreten ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.UInt64@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; at the start of a Utf8 string.">Analysiert einen <see cref="T:System.UInt64" />-Wert am Anfang einer UTF8-Zeichenfolge.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Die zu analysierende UTF8-Zeichenfolge.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Enthält nach Rückgabe der Methode den aus <paramref name="source" /> analysierten Wert, wenn der Analysevorgang erfolgreich war.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Enthält bei Rückgabe der Methode die Länge der analysierten Teilzeichenfolge in Bytes, wenn der Analysevorgang erfolgreich war. Wenn bei der Methode ein Fehler auftritt, wird <paramref name="bytesConsumed" /> auf 0 gesetzt.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Das erwartete Format der UTF8-Zeichenfolge.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> für Erfolg; <see langword="false" />, wenn die Zeichenfolge syntaktisch ungültig war oder ein Über- bzw. Unterlauf aufgetreten ist.</returns>
    </member>
    <member name="T:System.MemoryExtensions">
      <summary vsli:raw="Provides extension methods for the memory- and span-related types, such as &lt;see cref=&quot;T:System.Memory`1&quot; /&gt;, &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt;, &lt;see cref=&quot;T:System.Span`1&quot; /&gt;, and &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt;.">Bietet Erweiterungsmethoden für die Memory- und Span-bezogenen Typen wie <see cref="T:System.Memory`1" />, <see cref="T:System.ReadOnlyMemory`1" />, <see cref="T:System.Span`1" /> und <see cref="T:System.ReadOnlySpan`1" />.</summary>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String)">
      <summary vsli:raw="Creates a new &lt;see langword=&quot;ReadOnlyMemory&amp;lt;Char&amp;gt;&quot; /&gt; over the portion of the target string.">Erstellt ein neues <see langword="ReadOnlyMemory&lt;Char&gt;" /> über den Abschnitt der Zielzeichenfolge.</summary>
      <param name="text" vsli:raw="The target string.">Die Zielzeichenfolge.</param>
      <returns vsli:raw="The read-only character memory representation of the string, or &lt;see langword=&quot;default&quot; /&gt; if &lt;paramref name=&quot;text&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">Die schreibgeschützte Zeichenspeicherdarstellung der Zeichenfolge oder <see langword="default" />, wenn <paramref name="text" /><see langword="null" /> ist.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Index)">
      <summary vsli:raw="Creates a new &lt;see langword=&quot;ReadOnlyMemory&amp;lt;Char&amp;gt;&quot; /&gt; over a portion of the target string starting at a specified index.">Erstellt ein neues <see langword="ReadOnlyMemory&lt;Char&gt;" /> über einen Abschnitt der Zielzeichenfolge, beginnend bei einem angegebenen Index.</summary>
      <param name="text" vsli:raw="The target string.">Die Zielzeichenfolge.</param>
      <param name="startIndex" vsli:raw="The index at which to begin this slice.">Der Index, an dem dieser Slice beginnen soll.</param>
      <returns vsli:raw="The read-only character memory representation of the string.">Die schreibgeschützte Zeichenspeicherdarstellung der Zeichenfolge.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Int32)">
      <summary vsli:raw="Creates a new &lt;see langword=&quot;ReadOnlyMemory&amp;lt;Char&amp;gt;&quot; /&gt; over a portion of the target string starting at a specified character position.">Erstellt ein neues <see langword="ReadOnlyMemory&lt;Char&gt;" /> über einen Abschnitt der Zielzeichenfolge, beginnend bei einer angegebenen Zeichenposition.</summary>
      <param name="text" vsli:raw="The target string.">Die Zielzeichenfolge.</param>
      <param name="start" vsli:raw="The index at which to begin this slice.">Der Index, an dem dieser Slice beginnen soll.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt; is not in the range of &lt;paramref name=&quot;text&quot; /&gt; (&lt;paramref name=&quot;start&quot; /&gt; is &amp;lt; 0 or &amp;gt; &lt;c&gt;text.Length&lt;/c&gt;).">
        <paramref name="start" /> liegt nicht im Bereich von <paramref name="text" />. (<paramref name="start" /> ist &lt; 0 oder &gt; <c>text.Length</c>).</exception>
      <returns vsli:raw="The read-only character memory representation of the string, or &lt;see langword=&quot;default&quot; /&gt; if &lt;paramref name=&quot;text&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">Die schreibgeschützte Zeichenspeicherdarstellung der Zeichenfolge oder <see langword="default" />, wenn <paramref name="text" /><see langword="null" /> ist.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Int32,System.Int32)">
      <summary vsli:raw="Creates a new &lt;see langword=&quot;ReadOnlyMemory&amp;lt;Char&amp;gt;&quot; /&gt; over a portion of the target string beginning at a specified position with a length.">Erstellt ein neues <see langword="ReadOnlyMemory&lt;Char&gt;" /> über einen Abschnitt der Zielzeichenfolge, beginnend bei einer angegebenen Position mit einer Länge.</summary>
      <param name="text" vsli:raw="The target string.">Die Zielzeichenfolge.</param>
      <param name="start" vsli:raw="The index at which to begin this slice.">Der Index, an dem dieser Slice beginnen soll.</param>
      <param name="length" vsli:raw="The desired length for the slice.">Die gewünschte Länge des Slices.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt;, &lt;paramref name=&quot;length&quot; /&gt;, or &lt;paramref name=&quot;start&quot; /&gt; + &lt;paramref name=&quot;length&quot; /&gt; is not in the range of &lt;paramref name=&quot;text&quot; /&gt;.">
        <paramref name="start" />, <paramref name="length" /> oder <paramref name="start" /> + <paramref name="length" /> liegt nicht im Bereich von <paramref name="text" />.</exception>
      <returns vsli:raw="The read-only character memory representation of the string, or &lt;see langword=&quot;default&quot; /&gt; if &lt;paramref name=&quot;text&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">Die schreibgeschützte Zeichenspeicherdarstellung der Zeichenfolge oder <see langword="default" />, wenn <paramref name="text" /><see langword="null" /> ist.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Range)">
      <summary vsli:raw="Creates a new &lt;see langword=&quot;ReadOnlyMemory&amp;lt;Char&amp;gt;&quot; /&gt; over a specified range of the target string.">Erstellt ein neues <see langword="ReadOnlyMemory&lt;Char&gt;" /> über einen angegebenen Bereich der Zielzeichenfolge.</summary>
      <param name="text" vsli:raw="The target string.">Die Zielzeichenfolge.</param>
      <param name="range" vsli:raw="The range that indicates the start and length of the sliced string.">Der Bereich, der den Anfang und die Länge der unterteilten Zeichenfolge angibt.</param>
      <returns vsli:raw="The read-only character memory representation of the string.">Die schreibgeschützte Zeichenspeicherdarstellung der Zeichenfolge.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[])">
      <summary vsli:raw="Creates a new memory region over the target array.">Erstellt einen neuen Speicherbereich über dem Zielarray.</summary>
      <param name="array" vsli:raw="The array to convert.">Das zu konvertierende Array.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Der Typ des Arrays.</typeparam>
      <returns vsli:raw="The memory representation of the whole or part of the array.">Die Speicherdarstellung des gesamten oder eines Teils des Arrays.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Index)">
      <summary vsli:raw="Creates a new memory region over the portion of the target array starting at a specified index to the end of the array.">Erstellt einen neuen Speicherbereich über dem Abschnitt des Zielarrays, beginnend bei einem angegebenen Index bis zum Ende des Arrays.</summary>
      <param name="array" vsli:raw="The array to convert.">Das zu konvertierende Array.</param>
      <param name="startIndex" vsli:raw="The first position of the array.">Die erste Position des Arrays.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Der Typ des Arrays.</typeparam>
      <returns vsli:raw="The memory representation of the whole or part of the array.">Die Speicherdarstellung des gesamten oder eines Teils des Arrays.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Int32)">
      <summary vsli:raw="Creates a new memory region over the portion of the target array starting at a specified position to the end of the array.">Erstellt einen neuen Speicherbereich über dem Abschnitt des Zielarrays, beginnend an einem angegebenen Position bis zum Ende des Arrays.</summary>
      <param name="array" vsli:raw="The target array.">Das Zielarray.</param>
      <param name="start" vsli:raw="The index at which to begin the memory.">Der Index, an dem der Speicher beginnen soll.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Der Typ des Arrays.</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt; is covariant, and the array's type is not exactly &lt;see langword=&quot;T[]&quot; /&gt;.">
        <paramref name="array" /> ist kovariant, und der Typ des Arrays ist nicht genau <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt; index less than 0 or greater than &lt;see langword=&quot;array.Length&quot; /&gt;.">
        <paramref name="start" />-Index kleiner als 0 oder größer als <see langword="array.Length" />.</exception>
      <returns vsli:raw="The memory representation of the whole or part of the array.">Die Speicherdarstellung des gesamten oder eines Teils des Arrays.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Int32,System.Int32)">
      <summary vsli:raw="Creates a new memory region over the portion of the target array beginning at a specified position with a specified length.">Erstellt einen neuen Speicherbereich über dem Abschnitt des Zielarrays, beginnend an einer angegebenen Position mit einer angegebenen Länge.</summary>
      <param name="array" vsli:raw="The target array.">Das Zielarray.</param>
      <param name="start" vsli:raw="The index at which to begin the memory region.">Der Index, an dem der Speicherbereich beginnen soll.</param>
      <param name="length" vsli:raw="The number of items in the memory region.">Die Anzahl der Elemente im Speicherbereich.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Der Typ des Arrays.</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt; is covariant, and the array's type is not exactly &lt;see langword=&quot;T[]&quot; /&gt;.">
        <paramref name="array" /> ist kovariant, und der Typ des Arrays ist nicht genau <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt;, &lt;paramref name=&quot;length&quot; /&gt;, or &lt;paramref name=&quot;start&quot; /&gt; + &lt;paramref name=&quot;length&quot; /&gt; is not in the range of &lt;paramref name=&quot;array&quot; /&gt;.">
        <paramref name="start" />, <paramref name="length" /> oder <paramref name="start" /> + <paramref name="length" /> liegt nicht im Bereich von <paramref name="array" />.</exception>
      <returns vsli:raw="The memory representation of the whole or part of the array.">Die Speicherdarstellung des gesamten oder eines Teils des Arrays.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Range)">
      <summary vsli:raw="Creates a new memory region over the portion of the target array beginning at inclusive start index of the range and ending at the exclusive end index of the range.">Erstellt einen neuen Speicherbereich über dem Abschnitt des Zielarrays, beginnend mit dem inklusiven Startindex des Bereichs und endend mit dem exklusiven Endindex des Bereichs.</summary>
      <param name="array" vsli:raw="The array to convert.">Das zu konvertierende Array.</param>
      <param name="range" vsli:raw="The range to convert from the array.">Der aus dem Array zu konvertierende Bereich.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Der Typ des Arrays.</typeparam>
      <returns vsli:raw="The memory representation of the whole or part of the array.">Die Speicherdarstellung des gesamten oder eines Teils des Arrays.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0})">
      <summary vsli:raw="Creates a new memory region over the portion of the target array segment.">Erstellt einen neuen Speicherbereich über dem Abschnitt des Zielarraysegments.</summary>
      <param name="segment" vsli:raw="The segment to convert.">Das zu konvertierende Segment.</param>
      <typeparam name="T" vsli:raw="The type of the segment.">Der Typ des Segments.</typeparam>
      <returns vsli:raw="The memory representation of the segment.">Die Speicherdarstellung des Segments.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0},System.Int32)">
      <summary vsli:raw="Creates a new memory region over the portion of the target array segment starting at a specified position to the end of the segment.">Erstellt einen neuen Speicherbereich über dem Abschnitt des Zielarraysegments, beginnend an einer angegebenen Position bis zum Ende des Segments.</summary>
      <param name="segment" vsli:raw="The target array segment.">Das Zielarraysegment.</param>
      <param name="start" vsli:raw="The index at which to begin the memory.">Der Index, an dem der Speicher beginnen soll.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Der Typ des Arrays.</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException" vsli:raw="&lt;paramref name=&quot;segment&quot; /&gt; is covariant, and the type of &lt;paramref name=&quot;segment&quot; /&gt; is not exactly &lt;see langword=&quot;T[]&quot; /&gt;.">
        <paramref name="segment" /> ist kovariant, und den Typ von <paramref name="segment" /> ist nicht genau <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt; is less than 0 or greater than &lt;see langword=&quot;segment.Count&quot; /&gt;.">
        <paramref name="start" /> ist kleiner als 0 oder größer als <see langword="segment.Count" />.</exception>
      <returns vsli:raw="The memory representation of the whole or part of the array.">Die Speicherdarstellung des gesamten oder eines Teils des Arrays.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0},System.Int32,System.Int32)">
      <summary vsli:raw="Creates a new memory region over the portion of the target array segment beginning at a specified position with a specified length.">Erstellt einen neuen Speicherbereich über dem Abschnitt des Zielarraysegments, beginnend an einer angegebenen Position mit einer angegebenen Länge.</summary>
      <param name="segment" vsli:raw="The target array segment.">Das Zielarraysegment.</param>
      <param name="start" vsli:raw="The index at which to begin the memory.">Der Index, an dem der Speicher beginnen soll.</param>
      <param name="length" vsli:raw="The number of items in the memory.">Die Anzahl der Elemente im Speicher.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Der Typ des Arrays.</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException" vsli:raw="&lt;paramref name=&quot;segment&quot; /&gt; is covariant, and the array's type is not exactly &lt;see langword=&quot;T[]&quot; /&gt;.">
        <paramref name="segment" /> ist kovariant, und der Typ des Arrays ist nicht genau <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt;, &lt;paramref name=&quot;length&quot; /&gt;, or &lt;paramref name=&quot;start&quot; /&gt; + &lt;paramref name=&quot;length&quot; /&gt; is not in the range of &lt;paramref name=&quot;segment&quot; /&gt;.">
        <paramref name="start" />, <paramref name="length" /> oder <paramref name="start" /> + <paramref name="length" /> liegt nicht im Bereich von <paramref name="segment" />.</exception>
      <returns vsli:raw="The memory representation of the whole or part of the array.">Die Speicherdarstellung des gesamten oder eines Teils des Arrays.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan(System.String)">
      <summary vsli:raw="Creates a new read-only span over a string.">Erstellt eine neue schreibgeschützte Spanne über einen Abschnitt der Zielzeichenfolge von einer angegebenen Position aus für eine angegebene Anzahl von Zeichen.</summary>
      <param name="text" vsli:raw="The target string.">Die Zielzeichenfolge.</param>
      <returns vsli:raw="The read-only span representation of the string.">Die schreibgeschützte Spannendarstellung der Zeichenfolge.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan(System.String,System.Int32)">
      <summary vsli:raw="Creates a new read-only span over a portion of the target string from a specified position to the end of the string.">Erstellt eine neue schreibgeschützte Spanne über einen Abschnitt der Zielzeichenfolge von einer angegebenen Position aus bis zum Ende der Zeichenfolge.</summary>
      <param name="text" vsli:raw="The target string.">Die Zielzeichenfolge.</param>
      <param name="start" vsli:raw="The index at which to begin this slice.">Der Index, an dem dieser Slice beginnen soll.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="Thrown when &lt;paramref name=&quot;text&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="text" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt; is less than 0 or greater than &lt;see langword=&quot;text.Length&quot; /&gt;.">
        <paramref name="start" /> ist kleiner als 0 oder größer als <see langword="text.Length" />.</exception>
      <returns vsli:raw="The read-only span representation of the string.">Die schreibgeschützte Spannendarstellung der Zeichenfolge.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan(System.String,System.Int32,System.Int32)">
      <summary vsli:raw="Creates a new read-only span over a portion of the target string from a specified position for a specified number of characters.">Erstellt eine neue schreibgeschützte Spanne über eine Zeichenfolge.</summary>
      <param name="text" vsli:raw="The target string.">Die Zielzeichenfolge.</param>
      <param name="start" vsli:raw="The index at which to begin this slice.">Der Index, an dem dieser Slice beginnen soll.</param>
      <param name="length" vsli:raw="The desired length for the slice.">Die gewünschte Länge des Slices.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt;, &lt;paramref name=&quot;length&quot; /&gt;, or &lt;paramref name=&quot;start&quot; /&gt; + &lt;paramref name=&quot;length&quot; /&gt; is not in the range of &lt;paramref name=&quot;text&quot; /&gt;.">
        <paramref name="start" />, <paramref name="length" /> oder <paramref name="start" /> + <paramref name="length" /> liegt nicht im Bereich von <paramref name="text" />.</exception>
      <returns vsli:raw="The read-only span representation of the string.">Die schreibgeschützte Spannendarstellung der Zeichenfolge.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[])">
      <summary vsli:raw="Creates a new span over a target array.">Erstellt eine neue Spanne über einem Zielarray.</summary>
      <param name="array" vsli:raw="The array to convert.">Das zu konvertierende Array.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Der Typ des Arrays.</typeparam>
      <returns vsli:raw="The span representation of the array.">Die Spannendarstellung des Arrays.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Index)">
      <summary vsli:raw="Creates a new span over the portion of the target array defined by an &lt;see cref=&quot;T:System.Index&quot; /&gt; value.">Erstellt eine neue Spanne über dem Abschnitt des Zielarrays, das durch einen <see cref="T:System.Index" />-Wert definiert ist.</summary>
      <param name="array" vsli:raw="The array to convert.">Das zu konvertierende Array.</param>
      <param name="startIndex" vsli:raw="The starting index.">Der Startindex.</param>
      <typeparam name="T" vsli:raw="The array type.">Der Arraytyp.</typeparam>
      <returns vsli:raw="The span representation of the array.">Die Spannendarstellung des Arrays.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Int32)">
      <summary vsli:raw="Creates a new span over a portion of the target array starting at a specified position to the end of the array.">Erstellt eine neue Spanne über einem Abschnitt des Zielarrays, beginnend an einer angegebenen Position bis zum Ende des Arrays.</summary>
      <param name="array" vsli:raw="The array to convert.">Das zu konvertierende Array.</param>
      <param name="start" vsli:raw="The initial index from which the array will be converted.">Der anfängliche Index, aus dem das Array konvertiert wird.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Der Typ des Arrays.</typeparam>
      <returns vsli:raw="The span representation of the array.">Die Spannendarstellung des Arrays.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Int32,System.Int32)">
      <summary vsli:raw="Creates a new span over the portion of the target array beginning at a specified position for a specified length.">Erstellt eine neue Spanne über dem Abschnitt des Zielarrays, beginnend an einer angegebenen Position für eine bestimmte Länge.</summary>
      <param name="array" vsli:raw="The target array.">Das Zielarray.</param>
      <param name="start" vsli:raw="The index at which to begin the span.">Der Index, an dem die Spanne beginnen soll.</param>
      <param name="length" vsli:raw="The number of items in the span.">Die Anzahl der Elemente in der Spanne.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Der Typ des Arrays.</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt; is covariant, and the array's type is not exactly &lt;see langword=&quot;T[]&quot; /&gt;&quot;.">
        <paramref name="array" /> ist kovariant, und der Typ des Arrays ist nicht genau <see langword="T[]" />".</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt;, &lt;paramref name=&quot;length&quot; /&gt;, or &lt;paramref name=&quot;start&quot; /&gt; + &lt;paramref name=&quot;length&quot; /&gt; is not in the range of &lt;paramref name=&quot;text&quot; /&gt;.">
        <paramref name="start" />, <paramref name="length" /> oder <paramref name="start" /> + <paramref name="length" /> liegt nicht im Bereich von <paramref name="text" />.</exception>
      <returns vsli:raw="The span representation of the array.">Die Spannendarstellung des Arrays.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Range)">
      <summary vsli:raw="Creates a new span over a portion of a target array defined by a &lt;see cref=&quot;T:System.Range&quot; /&gt; value.">Erstellt eine neue Spanne über einem Abschnitt eines Zielarrays, das durch einen <see cref="T:System.Range" />-Wert definiert ist.</summary>
      <param name="array" vsli:raw="The array to convert.">Das zu konvertierende Array.</param>
      <param name="range" vsli:raw="The range of the array to convert.">Der Bereich des zu konvertierenden Arrays.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Der Typ des Arrays.</typeparam>
      <returns vsli:raw="The span representation of the array.">Die Spannendarstellung des Arrays.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0})">
      <summary vsli:raw="Creates a new span over a target array segment.">Erstellt eine neue Spanne über einem Zielarraysegment.</summary>
      <param name="segment" vsli:raw="The array segment to convert.">Das zu konvertierende Arraysegment.</param>
      <typeparam name="T" vsli:raw="The type of the array segment.">Der Typ des Array Segments.</typeparam>
      <returns vsli:raw="The span representation of the array segment.">Die Spannendarstellung des Arraysegments.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Index)">
      <summary vsli:raw="Creates a new span over a portion of the target array segment beginning at a specified index and ending at the end of the segment.">Erstellt eine neue Spanne über einem Abschnitt des Zielarraysegments, beginnend mit einem angegebenen Index und endend mit dem Segmentende.</summary>
      <param name="segment" vsli:raw="The target array segment.">Das Zielarraysegment.</param>
      <param name="startIndex" vsli:raw="The index at which to begin the Span.">Der Index, an dem die Spanne beginnen soll.</param>
      <typeparam name="T" vsli:raw="The type of the array segment.">Der Typ des Array Segments.</typeparam>
      <returns vsli:raw="The span representation of the array segment.">Die Spannendarstellung des Arraysegments.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Int32)">
      <summary vsli:raw="Creates a new span over a portion of a target array segment from a specified position to the end of the segment.">Erstellt eine neue Spanne über einem Abschnitt eines Zielarraysegments von einer bestimmten Position aus bis zum Segmentende.</summary>
      <param name="segment" vsli:raw="The target array segment.">Das Zielarraysegment.</param>
      <param name="start" vsli:raw="The index at which to begin the san.">Der Index, an dem die Spanne beginnen soll.</param>
      <typeparam name="T" vsli:raw="The type of the array segment.">Der Typ des Array Segments.</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException" vsli:raw="&lt;paramref name=&quot;segment&quot; /&gt; is covariant, and the array's type is not exactly &lt;see langword=&quot;T[]&quot; /&gt;.">
        <paramref name="segment" /> ist kovariant, und der Typ des Arrays ist nicht genau <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt; is less than 0 or greater than &lt;see langword=&quot;segment.Count&quot; /&gt;.">
        <paramref name="start" /> ist kleiner als 0 oder größer als <see langword="segment.Count" />.</exception>
      <returns vsli:raw="The span representation of the array segment.">Die Spannendarstellung des Arraysegments.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Int32,System.Int32)">
      <summary vsli:raw="Creates a new span over a portion of a target array segment from a specified position for a specified length.">Erstellt eine neue Spanne über einem Abschnitt eines Zielarraysegments von einer bestimmten Position aus für eine angegebene Länge.</summary>
      <param name="segment" vsli:raw="The target array segment.">Das Zielarraysegment.</param>
      <param name="start" vsli:raw="The index at which to begin the span.">Der Index, an dem die Spanne beginnen soll.</param>
      <param name="length" vsli:raw="The number of items in the span.">Die Anzahl der Elemente in der Spanne.</param>
      <typeparam name="T" vsli:raw="The type of the array segment.">Der Typ des Array Segments.</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException" vsli:raw="&lt;paramref name=&quot;segment&quot; /&gt; is covariant, and the array's type is not exactly &lt;see langword=&quot;T[]&quot; /&gt;.">
        <paramref name="segment" /> ist kovariant, und der Typ des Arrays ist nicht genau <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt;, &lt;paramref name=&quot;length&quot; /&gt;, or &lt;paramref name=&quot;start&quot; /&gt; + &lt;paramref name=&quot;length&quot; /&gt; is not in the range of &lt;paramref name=&quot;segment&quot; /&gt;.">
        <paramref name="start" />, <paramref name="length" /> oder <paramref name="start" /> + <paramref name="length" /> liegt nicht im Bereich von <paramref name="segment" />.</exception>
      <returns vsli:raw="The span representation of the array.">Die Spannendarstellung des Arrays.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Range)">
      <summary vsli:raw="Creates a new span over a portion of a target array segment using the range start and end indexes.">Erstellt eine neue Spanne über einem Abschnitt eines Zielarraysegments unter Verwendung der Start- und Endindizes des Bereichs.</summary>
      <param name="segment" vsli:raw="The target array segment.">Das Zielarraysegment.</param>
      <param name="range" vsli:raw="The range which has start and end indexes to use for slicing the array.">Der Bereich, der Start- und Endindizes aufweist, die für das Unterteilen des Arrays verwendet werden können.</param>
      <typeparam name="T" vsli:raw="The type of the array segment.">Der Typ des Array Segments.</typeparam>
      <returns vsli:raw="The span representation of the array segment.">Die Spannendarstellung des Arraysegments.</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``1(System.ReadOnlySpan{``0},System.IComparable{``0})">
      <summary vsli:raw="Searches an entire sorted &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; for a value using the specified &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; generic interface.">Durchsucht ein ganzes sortiertes <see cref="T:System.ReadOnlySpan`1" /> mithilfe der angegebenen generischen <see cref="T:System.IComparable`1" />-Schnittstelle nach einem Wert.</summary>
      <param name="span" vsli:raw="The sorted &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; to search.">Das zu durchsuchende sortierte <see cref="T:System.ReadOnlySpan`1" />.</param>
      <param name="comparable" vsli:raw="The &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; to use when comparing.">
        <see cref="T:System.IComparable`1" />, das beim Vergleich verwendet werden soll.</param>
      <typeparam name="T" vsli:raw="The element type of the span.">Der Elementtyp der Spanne.</typeparam>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;comparable&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="comparable" /> ist <see langword="null" />.</exception>
      <returns vsli:raw="The zero-based index of &lt;paramref name=&quot;comparable&quot; /&gt; in the sorted &lt;paramref name=&quot;span&quot; /&gt;, if &lt;paramref name=&quot;comparable&quot; /&gt; is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than &lt;paramref name=&quot;comparable&quot; /&gt; or, if there is no larger element, the bitwise complement of &lt;see cref=&quot;P:System.ReadOnlySpan`1.Length&quot; /&gt;.">Der nullbasierte Index von <paramref name="comparable" /> in der sortierten <paramref name="span" />, sofern <paramref name="comparable" /> gefunden wird, andernfalls eine negative Zahl, die das bitweise Komplement des Indexes des nächsten Elements darstellt, das größer als <paramref name="comparable" /> ist, oder, wenn kein größeres Element vorhanden ist, das bitweise Komplement von <see cref="P:System.ReadOnlySpan`1.Length" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``1(System.Span{``0},System.IComparable{``0})">
      <summary vsli:raw="Searches an entire sorted &lt;see cref=&quot;T:System.Span`1&quot; /&gt; for a value using the specified &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; generic interface.">Durchsucht ein ganzes sortiertes <see cref="T:System.Span`1" /> mithilfe der angegebenen generischen <see cref="T:System.IComparable`1" />-Schnittstelle nach einem Wert.</summary>
      <param name="span" vsli:raw="The sorted &lt;see cref=&quot;T:System.Span`1&quot; /&gt; to search.">Das zu durchsuchende sortierte <see cref="T:System.Span`1" />.</param>
      <param name="comparable" vsli:raw="The &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; to use when comparing.">
        <see cref="T:System.IComparable`1" />, das beim Vergleich verwendet werden soll.</param>
      <typeparam name="T" vsli:raw="The element type of the span.">Der Elementtyp der Spanne.</typeparam>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;comparable&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="comparable" /> ist <see langword="null" />.</exception>
      <returns vsli:raw="The zero-based index of &lt;paramref name=&quot;comparable&quot; /&gt; in the sorted &lt;paramref name=&quot;span&quot; /&gt;, if &lt;paramref name=&quot;comparable&quot; /&gt; is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than &lt;paramref name=&quot;comparable&quot; /&gt; or, if there is no larger element, the bitwise complement of &lt;see cref=&quot;P:System.Span`1.Length&quot; /&gt;.">Der nullbasierte Index von <paramref name="comparable" /> in der sortierten <paramref name="span" />, sofern <paramref name="comparable" /> gefunden wird, andernfalls eine negative Zahl, die das bitweise Komplement des Indexes des nächsten Elements darstellt, das größer als <paramref name="comparable" /> ist, oder, wenn kein größeres Element vorhanden ist, das bitweise Komplement von <see cref="P:System.Span`1.Length" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``2(System.ReadOnlySpan{``0},``0,``1)">
      <summary vsli:raw="Searches an entire sorted &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; for a specified value using the specified &lt;typeparamref name=&quot;TComparer&quot; /&gt; generic type.">Durchsucht ein ganzes sortiertes <see cref="T:System.ReadOnlySpan`1" /> mithilfe des angegebenen generischen <typeparamref name="TComparer" />-Typs nach einem angegebenen Wert.</summary>
      <param name="span" vsli:raw="The sorted &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; to search.">Das zu durchsuchende sortierte <see cref="T:System.ReadOnlySpan`1" />.</param>
      <param name="value" vsli:raw="The object to locate. The value can be &lt;see langword=&quot;null&quot; /&gt; for reference types.">Das zu suchende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
      <param name="comparer" vsli:raw="The &lt;typeparamref name=&quot;TComparer&quot; /&gt; to use when comparing.">
        <typeparamref name="TComparer" />, das beim Vergleich verwendet werden soll.</param>
      <typeparam name="T" vsli:raw="The element type of the span.">Der Elementtyp der Spanne.</typeparam>
      <typeparam name="TComparer" vsli:raw="The specific type of &lt;see cref=&quot;T:System.Collections.Generic.IComparer`1&quot; /&gt;.">Der spezifische Typ von <see cref="T:System.Collections.Generic.IComparer`1" /> .</typeparam>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;comparer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="comparer" /> ist <see langword="null" />.</exception>
      <returns vsli:raw="The zero-based index of &lt;paramref name=&quot;value&quot; /&gt; in the sorted &lt;paramref name=&quot;span&quot; /&gt;, if &lt;paramref name=&quot;value&quot; /&gt; is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than &lt;paramref name=&quot;value&quot; /&gt; or, if there is no larger element, the bitwise complement of &lt;see cref=&quot;P:System.ReadOnlySpan`1.Length&quot; /&gt;.">Der nullbasierte Index von <paramref name="value" /> in der sortierten <paramref name="span" />, sofern <paramref name="value" /> gefunden wird, andernfalls eine negative Zahl, die das bitweise Komplement des Indexes des nächsten Elements darstellt, das größer als <paramref name="value" /> ist, oder, wenn kein größeres Element vorhanden ist, das bitweise Komplement von <see cref="P:System.ReadOnlySpan`1.Length" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``2(System.ReadOnlySpan{``0},``1)">
      <summary vsli:raw="Searches an entire sorted &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; for a value using the specified &lt;typeparamref name=&quot;TComparable&quot; /&gt; generic type.">Durchsucht ein ganzes sortiertes <see cref="T:System.ReadOnlySpan`1" /> mithilfe des angegebenen generischen <typeparamref name="TComparable" />-Typs nach einem Wert.</summary>
      <param name="span" vsli:raw="The sorted &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; to search.">Das zu durchsuchende sortierte <see cref="T:System.ReadOnlySpan`1" />.</param>
      <param name="comparable" vsli:raw="The &lt;typeparamref name=&quot;TComparable&quot; /&gt; to use when comparing.">
        <typeparamref name="TComparable" />, das beim Vergleich verwendet werden soll.</param>
      <typeparam name="T" vsli:raw="The element type of the span.">Der Elementtyp der Spanne.</typeparam>
      <typeparam name="TComparable" vsli:raw="The specific type of &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt;.">Der spezifische Typ von <see cref="T:System.IComparable`1" /> .</typeparam>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;comparable&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="comparable" /> ist <see langword="null" />.</exception>
      <returns vsli:raw="The zero-based index of &lt;paramref name=&quot;comparable&quot; /&gt; in the sorted &lt;paramref name=&quot;span&quot; /&gt;, if &lt;paramref name=&quot;comparable&quot; /&gt; is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than &lt;paramref name=&quot;comparable&quot; /&gt; or, if there is no larger element, the bitwise complement of &lt;see cref=&quot;P:System.ReadOnlySpan`1.Length&quot; /&gt;.">Der nullbasierte Index von <paramref name="comparable" /> in der sortierten <paramref name="span" />, sofern <paramref name="comparable" /> gefunden wird, andernfalls eine negative Zahl, die das bitweise Komplement des Indexes des nächsten Elements darstellt, das größer als <paramref name="comparable" /> ist, oder, wenn kein größeres Element vorhanden ist, das bitweise Komplement von <see cref="P:System.ReadOnlySpan`1.Length" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``2(System.Span{``0},``0,``1)">
      <summary vsli:raw="Searches an entire sorted &lt;see cref=&quot;T:System.Span`1&quot; /&gt; for a specified value using the specified &lt;typeparamref name=&quot;TComparer&quot; /&gt; generic type.">Durchsucht ein ganzes sortiertes <see cref="T:System.Span`1" /> mithilfe des angegebenen generischen <typeparamref name="TComparer" />-Typs nach einem angegebenen Wert.</summary>
      <param name="span" vsli:raw="The sorted &lt;see cref=&quot;T:System.Span`1&quot; /&gt; to search.">Das zu durchsuchende sortierte <see cref="T:System.Span`1" />.</param>
      <param name="value" vsli:raw="The object to locate. The value can be &lt;see langword=&quot;null&quot; /&gt; for reference types.">Das zu suchende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
      <param name="comparer" vsli:raw="The &lt;typeparamref name=&quot;TComparer&quot; /&gt; to use when comparing.">
        <typeparamref name="TComparer" />, das beim Vergleich verwendet werden soll.</param>
      <typeparam name="T" vsli:raw="The element type of the span.">Der Elementtyp der Spanne.</typeparam>
      <typeparam name="TComparer" vsli:raw="The specific type of &lt;see cref=&quot;T:System.Collections.Generic.IComparer`1&quot; /&gt;.">Der spezifische Typ von <see cref="T:System.Collections.Generic.IComparer`1" /> .</typeparam>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;comparer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="comparer" /> ist <see langword="null" />.</exception>
      <returns vsli:raw="The zero-based index of &lt;paramref name=&quot;value&quot; /&gt; in the sorted &lt;paramref name=&quot;span&quot; /&gt;, if &lt;paramref name=&quot;value&quot; /&gt; is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than &lt;paramref name=&quot;value&quot; /&gt; or, if there is no larger element, the bitwise complement of &lt;see cref=&quot;P:System.Span`1.Length&quot; /&gt;.">Der nullbasierte Index von <paramref name="value" /> in der sortierten <paramref name="span" />, sofern <paramref name="value" /> gefunden wird, andernfalls eine negative Zahl, die das bitweise Komplement des Indexes des nächsten Elements darstellt, das größer als <paramref name="value" /> ist, oder, wenn kein größeres Element vorhanden ist, das bitweise Komplement von <see cref="P:System.Span`1.Length" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``2(System.Span{``0},``1)">
      <summary vsli:raw="Searches an entire sorted &lt;see cref=&quot;T:System.Span`1&quot; /&gt; for a value using the specified &lt;typeparamref name=&quot;TComparable&quot; /&gt; generic type.">Durchsucht ein ganzes sortiertes <see cref="T:System.Span`1" /> mithilfe des angegebenen generischen <typeparamref name="TComparable" />-Typs nach einem Wert.</summary>
      <param name="span" vsli:raw="The sorted &lt;see cref=&quot;T:System.Span`1&quot; /&gt; to search.">Das zu durchsuchende sortierte <see cref="T:System.Span`1" />.</param>
      <param name="comparable" vsli:raw="The &lt;typeparamref name=&quot;TComparable&quot; /&gt; to use when comparing.">
        <typeparamref name="TComparable" />, das beim Vergleich verwendet werden soll.</param>
      <typeparam name="T" vsli:raw="The element type of the span.">Der Elementtyp der Spanne.</typeparam>
      <typeparam name="TComparable" vsli:raw="The specific type of &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt;.">Der spezifische Typ von <see cref="T:System.IComparable`1" /> .</typeparam>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;comparable&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="comparable" /> ist <see langword="null" />.</exception>
      <returns vsli:raw="The zero-based index of &lt;paramref name=&quot;comparable&quot; /&gt; in the sorted &lt;paramref name=&quot;span&quot; /&gt;, if &lt;paramref name=&quot;comparable&quot; /&gt; is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than &lt;paramref name=&quot;comparable&quot; /&gt; or, if there is no larger element, the bitwise complement of &lt;see cref=&quot;P:System.Span`1.Length&quot; /&gt;.">Der nullbasierte Index von <paramref name="comparable" /> in der sortierten <paramref name="span" />, sofern <paramref name="comparable" /> gefunden wird, andernfalls eine negative Zahl, die das bitweise Komplement des Indexes des nächsten Elements darstellt, das größer als <paramref name="comparable" /> ist, oder, wenn kein größeres Element vorhanden ist, das bitweise Komplement von <see cref="P:System.Span`1.Length" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.CompareTo(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary vsli:raw="Compares one character span with another using a specified string comparison, and returns an integer that indicates their relative position in the sort order.">Vergleicht eine Zeichenspanne mit einer anderen unter Verwendung eines angegebenen Zeichenfolgenvergleichs und gibt eine ganze Zahl zurück, die ihre relative Position in der Sortierreihenfolge angibt.</summary>
      <param name="span" vsli:raw="The source span.">Die Quellspanne.</param>
      <param name="other" vsli:raw="The value to compare with the source span.">Der Wert, der mit der Quellspanne verglichen werden soll.</param>
      <param name="comparisonType" vsli:raw="An enumeration value that determines how &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;other&quot; /&gt; are compared.">Ein Enumerationswert, der bestimmt, wie <paramref name="span" /> und <paramref name="other" /> verglichen werden.</param>
      <returns vsli:raw="A signed integer that indicates the relative order of &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;other&quot; /&gt;:&lt;br /&gt;   - If less than 0, &lt;paramref name=&quot;span&quot; /&gt; precedes than &lt;paramref name=&quot;other&quot; /&gt;.&lt;br /&gt;   - If 0, &lt;paramref name=&quot;span&quot; /&gt; equals &lt;paramref name=&quot;other&quot; /&gt;.&lt;br /&gt;   - If greater than 0, &lt;paramref name=&quot;span&quot; /&gt; follows &lt;paramref name=&quot;other&quot; /&gt;.">Eine ganze Zahl mit Vorzeichen, die die relative Reihenfolge von <paramref name="span" /> und <paramref name="other" /> angibt:   – Wenn kleiner als 0, <paramref name="span" /> vor <paramref name="other" />.   – Wenn diese 0 (null) sind, ist <paramref name="span" /> gleich <paramref name="other" />.   – Wenn größer als 0, folgt <paramref name="span" /> auf <paramref name="other" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Contains(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary vsli:raw="Indicates whether a specified value occurs within a read-only character span.">Gibt an, ob ein angegebener Wert innerhalb einer schreibgeschützten Zeichenspanne auftritt.</summary>
      <param name="span" vsli:raw="The source span.">Die Quellspanne.</param>
      <param name="value" vsli:raw="The value to seek within the source span.">Der innerhalb der Quellspanne zu suchende Wert.</param>
      <param name="comparisonType" vsli:raw="An enumeration value that determines how the characters in &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;value&quot; /&gt; are compared.">Ein Enumerationswert, der bestimmt, wie die Zeichen in <paramref name="span" /> und <paramref name="value" /> verglichen werden.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;value&quot; /&gt; occurs within the span, &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" />, wenn <paramref name="value" /> innerhalb der Spanne auftritt, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Contains``1(System.ReadOnlySpan{``0},``0)">
      <summary vsli:raw="Indicates whether a specified value is found in a read-only span. Values are compared using IEquatable{T}.Equals(T).">Gibt an, ob ein angegebener Wert in einer schreibgeschützten Spanne gefunden wird. Werte werden mit „IEquatable{T}.Equals(T)“ verglichen.</summary>
      <param name="span" vsli:raw="The span to search.">Die zu suchende Spanne.</param>
      <param name="value" vsli:raw="The value to search for.">Der zu suchende Wert.</param>
      <typeparam name="T" vsli:raw="The type of the span.">Der Typ der Spanne.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if found, &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" />, wenn er gefunden wurde, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Contains``1(System.Span{``0},``0)">
      <summary vsli:raw="Indicates whether a specified value is found in a span. Values are compared using IEquatable{T}.Equals(T).">Gibt an, ob ein angegebener Wert in einer Spanne gefunden wird. Werte werden mit „IEquatable{T}.Equals(T)“ verglichen.</summary>
      <param name="span" vsli:raw="The span to search.">Die zu suchende Spanne.</param>
      <param name="value" vsli:raw="The value to search for.">Der zu suchende Wert.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the span.">Der Typ der Elemente in der Spanne.</typeparam>
      <returns vsli:raw="&lt;code data-dev-comment-type=&quot;langword&quot;&gt;true&lt;/code&gt; if found, &lt;code data-dev-comment-type=&quot;langword&quot;&gt;false&lt;/code&gt; otherwise.">
        <see langword="true" />, wenn er gefunden wurde, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.CopyTo``1(``0[],System.Memory{``0})">
      <summary vsli:raw="Copies the contents of the array into a memory region.">Kopiert den Inhalt des Arrays in einen Speicherbereich.</summary>
      <param name="source" vsli:raw="The array to copy items from.">Das Array, aus dem Elemente kopiert werden sollen.</param>
      <param name="destination" vsli:raw="The memory to copy items into.">Das Array, in das die Elemente kopiert werden sollen.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Der Typ des Arrays.</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="The destination is shorter than the source array.">Das Ziel ist kürzer als das Quellarray.</exception>
    </member>
    <member name="M:System.MemoryExtensions.CopyTo``1(``0[],System.Span{``0})">
      <summary vsli:raw="Copies the contents of the array into the span.">Kopiert den Inhalt des Arrays in die Spanne.</summary>
      <param name="source" vsli:raw="The array to copy items from.">Das Array, aus dem Elemente kopiert werden sollen.</param>
      <param name="destination" vsli:raw="The span to copy items into.">Der Bereich, in den Elemente kopiert werden sollen.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Der Typ des Arrays.</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="The destination Span is shorter than the source array.">Die Zielspanne ist kürzer als das Quellarray.</exception>
    </member>
    <member name="M:System.MemoryExtensions.EndsWith(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary vsli:raw="Determines whether the end of the &lt;paramref name=&quot;span&quot; /&gt; matches the specified &lt;paramref name=&quot;value&quot; /&gt; when compared using the specified &lt;paramref name=&quot;comparisonType&quot; /&gt; option.">Bestimmt, ob das Ende von <paramref name="span" /> mit dem angegebenen <paramref name="value" /> übereinstimmt, wenn es mit der angegebenen <paramref name="comparisonType" />-Option verglichen wird.</summary>
      <param name="span" vsli:raw="The source span.">Die Quellspanne.</param>
      <param name="value" vsli:raw="The sequence to compare to the end of the source span.">Die Sequenz, die mit dem Ende der Quellspanne verglichen werden soll.</param>
      <param name="comparisonType" vsli:raw="An enumeration value that determines how &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;value&quot; /&gt; are compared.">Ein Enumerationswert, der bestimmt, wie <paramref name="span" /> und <paramref name="value" /> verglichen werden.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;value&quot; /&gt; matches the end of &lt;paramref name=&quot;span&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn <paramref name="value" /> mit dem Ende von <paramref name="span" /> übereinstimmt, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.EndsWith``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Determines whether the specified sequence appears at the end of a read-only span.">Bestimmt, ob die angegebene Sequenz am Ende einer schreibgeschützten Spanne angezeigt wird.</summary>
      <param name="span" vsli:raw="The source span.">Die Quellspanne.</param>
      <param name="value" vsli:raw="The sequence to compare to the end of the source span.">Die Sequenz, die mit dem Ende der Quellspanne verglichen werden soll.</param>
      <typeparam name="T" vsli:raw="The type of the span.">Der Typ der Spanne.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;value&quot; /&gt; matches the end of &lt;paramref name=&quot;span&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn <paramref name="value" /> mit dem Ende von <paramref name="span" /> übereinstimmt, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.EndsWith``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Determines whether the specified sequence appears at the end of a span.">Bestimmt, ob die angegebene Sequenz am Ende einer Spanne angezeigt wird.</summary>
      <param name="span" vsli:raw="The source span.">Die Quellspanne.</param>
      <param name="value" vsli:raw="The sequence to compare to the end of the source span.">Die Sequenz, die mit dem Ende der Quellspanne verglichen werden soll.</param>
      <typeparam name="T" vsli:raw="The type of the span.">Der Typ der Spanne.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;value&quot; /&gt; matches the end of &lt;paramref name=&quot;span&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn <paramref name="value" /> mit dem Ende von <paramref name="span" /> übereinstimmt, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.EnumerateRunes(System.ReadOnlySpan{System.Char})">
      <summary vsli:raw="Returns an enumeration of &lt;see cref=&quot;T:System.Text.Rune&quot; /&gt; from the provided read-only span.">Gibt eine Enumeration von <see cref="T:System.Text.Rune" /> aus der angegebenen schreibgeschützten Spanne zurück.</summary>
      <param name="span" vsli:raw="The source span.">Die Quellspanne.</param>
      <returns vsli:raw="A rune enumerator.">Ein rune-Enumerator.</returns>
    </member>
    <member name="M:System.MemoryExtensions.EnumerateRunes(System.Span{System.Char})">
      <summary vsli:raw="Returns an enumeration of &lt;see cref=&quot;T:System.Text.Rune&quot; /&gt; from the provided span.">Gibt eine Enumeration von <see cref="T:System.Text.Rune" /> aus der angegebenen Spanne zurück.</summary>
      <param name="span" vsli:raw="The source span.">Die Quellspanne.</param>
      <returns vsli:raw="A rune enumerator.">Ein rune-Enumerator.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Equals(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary vsli:raw="Determines whether this &lt;paramref name=&quot;span&quot; /&gt; and the specified &lt;paramref name=&quot;other&quot; /&gt; span have the same characters when compared using the specified &lt;paramref name=&quot;comparisonType&quot; /&gt; option.">Bestimmt, ob dieser <paramref name="span" /> und die angegebene <paramref name="other" />-Spanne dieselben Zeichen aufweisen, wenn sie mit der angegebenen <paramref name="comparisonType" />-Option verglichen werden.</summary>
      <param name="span" vsli:raw="The source span.">Die Quellspanne.</param>
      <param name="other" vsli:raw="The value to compare with the source span.">Der Wert, der mit der Quellspanne verglichen werden soll.</param>
      <param name="comparisonType" vsli:raw="An enumeration value that determines how &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;other&quot; /&gt; are compared.">Ein Enumerationswert, der bestimmt, wie <paramref name="span" /> und <paramref name="other" /> verglichen werden.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if equal, &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" />, sofern identisch, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary vsli:raw="Reports the zero-based index of the first occurrence of the specified &lt;paramref name=&quot;value&quot; /&gt; in the current &lt;paramref name=&quot;span&quot; /&gt;.">Gibt den NULL-basierten Index des ersten Vorkommens der angegebenen <paramref name="value" /> im aktuellen <paramref name="span" /> an.</summary>
      <param name="span" vsli:raw="The source span.">Die Quellspanne.</param>
      <param name="value" vsli:raw="The value to seek within the source span.">Der innerhalb der Quellspanne zu suchende Wert.</param>
      <param name="comparisonType" vsli:raw="An enumeration value that determines how &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;value&quot; /&gt; are compared.">Ein Enumerationswert, der bestimmt, wie <paramref name="span" /> und <paramref name="value" /> verglichen werden.</param>
      <returns vsli:raw="The index of the occurrence of the value in the span.">Der Index des Vorkommens des Werts in der Spanne.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf``1(System.ReadOnlySpan{``0},``0)">
      <summary vsli:raw="Searches for the specified value and returns the index of its first occurrence. Values are compared using IEquatable{T}.Equals(T).">Sucht nach dem angegebenen Wert und gibt den Index des ersten Vorkommens zurück. Werte werden mit „IEquatable{T}.Equals(T)“ verglichen.</summary>
      <param name="span" vsli:raw="The span to search.">Die zu suchende Spanne.</param>
      <param name="value" vsli:raw="The value to search for.">Der zu suchende Wert.</param>
      <typeparam name="T" vsli:raw="The type of the span and value.">Der Typ der Spanne und des Werts.</typeparam>
      <returns vsli:raw="The index of the occurrence of the value in the span. If not found, returns -1.">Der Index des Vorkommens des Werts in der Spanne. Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Searches for the specified sequence and returns the index of its first occurrence. Values are compared using IEquatable{T}.Equals(T).">Sucht nach der angegebenen Sequenz und gibt den Index des ersten Vorkommens zurück. Werte werden mit „IEquatable{T}.Equals(T)“ verglichen.</summary>
      <param name="span" vsli:raw="The span to search.">Die zu suchende Spanne.</param>
      <param name="value" vsli:raw="The sequence to search for.">Die zu suchende Sequenz.</param>
      <typeparam name="T" vsli:raw="The type of the span and value.">Der Typ der Spanne und des Werts.</typeparam>
      <returns vsli:raw="The index of the occurrence of the value in the span. If not found, returns -1.">Der Index des Vorkommens des Werts in der Spanne. Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf``1(System.Span{``0},``0)">
      <summary vsli:raw="Searches for the specified value and returns the index of its first occurrence. Values are compared using IEquatable{T}.Equals(T).">Sucht nach dem angegebenen Wert und gibt den Index des ersten Vorkommens zurück. Werte werden mit „IEquatable{T}.Equals(T)“ verglichen.</summary>
      <param name="span" vsli:raw="The span to search.">Die zu suchende Spanne.</param>
      <param name="value" vsli:raw="The value to search for.">Der zu suchende Wert.</param>
      <typeparam name="T" vsli:raw="The type of the span and value.">Der Typ der Spanne und des Werts.</typeparam>
      <returns vsli:raw="The index of the occurrence of the value in the span. If not found, returns -1.">Der Index des Vorkommens des Werts in der Spanne. Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Searches for the specified sequence and returns the index of its first occurrence. Values are compared using IEquatable{T}.Equals(T).">Sucht nach der angegebenen Sequenz und gibt den Index des ersten Vorkommens zurück. Werte werden mit „IEquatable{T}.Equals(T)“ verglichen.</summary>
      <param name="span" vsli:raw="The span to search.">Die zu suchende Spanne.</param>
      <param name="value" vsli:raw="The sequence to search for.">Die zu suchende Sequenz.</param>
      <typeparam name="T" vsli:raw="The type of the span and value.">Der Typ der Spanne und des Werts.</typeparam>
      <returns vsli:raw="The index of the occurrence of the value in the span. If not found, returns -1.">Der Index des Vorkommens des Werts in der Spanne. Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},``0,``0)">
      <summary vsli:raw="Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator.">Sucht nach dem ersten Index eines der angegebenen Werte, ähnlich dem mehrmaligen Aufruf von IndexOf mit dem logischen OR-Operator (ODER).</summary>
      <param name="span" vsli:raw="The span to search.">Die zu suchende Spanne.</param>
      <param name="value0" vsli:raw="One of the values to search for.">Einer der zu suchenden Werte.</param>
      <param name="value1" vsli:raw="One of the values to search for.">Einer der zu suchenden Werte.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">Der Typ der Spanne und der Werte.</typeparam>
      <returns vsli:raw="The first index of the occurrence of any of the values in the span. If not found, returns -1.">Der erste Index des Vorkommens eines der Werte in der Spanne. Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},``0,``0,``0)">
      <summary vsli:raw="Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator.">Sucht nach dem ersten Index eines der angegebenen Werte, ähnlich dem mehrmaligen Aufruf von IndexOf mit dem logischen OR-Operator (ODER).</summary>
      <param name="span" vsli:raw="The span to search.">Die zu suchende Spanne.</param>
      <param name="value0" vsli:raw="One of the values to search for.">Einer der zu suchenden Werte.</param>
      <param name="value1" vsli:raw="One of the values to search for.">Einer der zu suchenden Werte.</param>
      <param name="value2" vsli:raw="One of the values to search for.">Einer der zu suchenden Werte.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">Der Typ der Spanne und der Werte.</typeparam>
      <returns vsli:raw="The first index of the occurrence of any of the values in the span. If not found, returns -1.">Der erste Index des Vorkommens eines der Werte in der Spanne. Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator.">Sucht nach dem ersten Index eines der angegebenen Werte, ähnlich dem mehrmaligen Aufruf von IndexOf mit dem logischen OR-Operator (ODER).</summary>
      <param name="span" vsli:raw="The span to search.">Die zu suchende Spanne.</param>
      <param name="values" vsli:raw="The set of values to search for.">Der zu suchende Satz von Werten.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">Der Typ der Spanne und der Werte.</typeparam>
      <returns vsli:raw="The first index of the occurrence of any of the values in the span. If not found, returns -1.">Der erste Index des Vorkommens eines der Werte in der Spanne. Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},``0,``0)">
      <summary vsli:raw="Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator.">Sucht nach dem ersten Index eines der angegebenen Werte, ähnlich dem mehrmaligen Aufruf von IndexOf mit dem logischen OR-Operator (ODER).</summary>
      <param name="span" vsli:raw="The span to search.">Die zu suchende Spanne.</param>
      <param name="value0" vsli:raw="One of the values to search for.">Einer der zu suchenden Werte.</param>
      <param name="value1" vsli:raw="One of the values to search for.">Einer der zu suchenden Werte.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">Der Typ der Spanne und der Werte.</typeparam>
      <returns vsli:raw="The first index of the occurrence of any of the values in the span. If not found, returns -1.">Der erste Index des Vorkommens eines der Werte in der Spanne. Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},``0,``0,``0)">
      <summary vsli:raw="Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator.">Sucht nach dem ersten Index eines der angegebenen Werte, ähnlich dem mehrmaligen Aufruf von IndexOf mit dem logischen OR-Operator (ODER).</summary>
      <param name="span" vsli:raw="The span to search.">Die zu suchende Spanne.</param>
      <param name="value0" vsli:raw="One of the values to search for.">Einer der zu suchenden Werte.</param>
      <param name="value1" vsli:raw="One of the values to search for.">Einer der zu suchenden Werte.</param>
      <param name="value2" vsli:raw="One of the values to search for.">Einer der zu suchenden Werte.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">Der Typ der Spanne und der Werte.</typeparam>
      <returns vsli:raw="The first index of the occurrence of any of the values in the span. If not found, returns -1.">Der erste Index des Vorkommens eines der Werte in der Spanne. Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator.">Sucht nach dem ersten Index eines der angegebenen Werte, ähnlich dem mehrmaligen Aufruf von IndexOf mit dem logischen OR-Operator (ODER).</summary>
      <param name="span" vsli:raw="The span to search.">Die zu suchende Spanne.</param>
      <param name="values" vsli:raw="The set of values to search for.">Der zu suchende Satz von Werten.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">Der Typ der Spanne und der Werte.</typeparam>
      <returns vsli:raw="The first index of the occurrence of any of the values in the span. If not found, returns -1.">Der erste Index des Vorkommens eines der Werte in der Spanne. Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IsWhiteSpace(System.ReadOnlySpan{System.Char})">
      <summary vsli:raw="Indicates whether the specified span contains only whitespace characters.">Gibt an, ob die angegebene Spanne nur Leerzeichen enthält.</summary>
      <param name="span" vsli:raw="The source span.">Die Quellspanne.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span contains only whitespace characters, &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" />, wenn die Spanne nur Leerzeichen enthält, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary vsli:raw="Reports the zero-based index of the last occurrence of the specified &lt;paramref name=&quot;value&quot; /&gt; in the current &lt;paramref name=&quot;span&quot; /&gt;.">Gibt den NULL-basierten Index des letzten Vorkommens der angegebenen <paramref name="value" /> im aktuellen <paramref name="span" /> an.</summary>
      <param name="span" vsli:raw="The source span.">Die Quellspanne.</param>
      <param name="value" vsli:raw="The value to seek within the source span.">Der innerhalb der Quellspanne zu suchende Wert.</param>
      <param name="comparisonType" vsli:raw="An enumeration value that determines how &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;value&quot; /&gt; are compared.">Ein Enumerationswert, der bestimmt, wie <paramref name="span" /> und <paramref name="value" /> verglichen werden.</param>
      <returns vsli:raw="The index of the last occurrence of the value in the span.">Der Index des letzten Vorkommens des Werts in der Spanne.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf``1(System.ReadOnlySpan{``0},``0)">
      <summary vsli:raw="Searches for the specified value and returns the index of its last occurrence. Values are compared using IEquatable{T}.Equals(T).">Sucht nach dem angegebenen Wert und gibt den Index des letzten Vorkommens zurück. Werte werden mit „IEquatable{T}.Equals(T)“ verglichen.</summary>
      <param name="span" vsli:raw="The span to search.">Die zu suchende Spanne.</param>
      <param name="value" vsli:raw="The value to search for.">Der zu suchende Wert.</param>
      <typeparam name="T" vsli:raw="The type of the span and value.">Der Typ der Spanne und des Werts.</typeparam>
      <returns vsli:raw="The index of the last occurrence of the value in the span. If not found, returns -1.">Der Index des letzten Vorkommens des Werts in der Spanne. Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Searches for the specified sequence and returns the index of its last occurrence. Values are compared using IEquatable{T}.Equals(T).">Sucht nach der angegebenen Sequenz und gibt den Index des letzten Vorkommens zurück. Werte werden mit „IEquatable{T}.Equals(T)“ verglichen.</summary>
      <param name="span" vsli:raw="The span to search.">Die zu suchende Spanne.</param>
      <param name="value" vsli:raw="The sequence to search for.">Die zu suchende Sequenz.</param>
      <typeparam name="T" vsli:raw="The type of the span and value.">Der Typ der Spanne und des Werts.</typeparam>
      <returns vsli:raw="The index of the last occurrence of the value in the span. If not found, returns -1.">Der Index des letzten Vorkommens des Werts in der Spanne. Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf``1(System.Span{``0},``0)">
      <summary vsli:raw="Searches for the specified value and returns the index of its last occurrence. Values are compared using IEquatable{T}.Equals(T).">Sucht nach dem angegebenen Wert und gibt den Index des letzten Vorkommens zurück. Werte werden mit „IEquatable{T}.Equals(T)“ verglichen.</summary>
      <param name="span" vsli:raw="The span to search.">Die zu suchende Spanne.</param>
      <param name="value" vsli:raw="The value to search for.">Der zu suchende Wert.</param>
      <typeparam name="T" vsli:raw="The type of the span and value.">Der Typ der Spanne und des Werts.</typeparam>
      <returns vsli:raw="The index of the last occurrence of the value in the span. If not found, returns -1.">Der Index des letzten Vorkommens des Werts in der Spanne. Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Searches for the specified sequence and returns the index of its last occurrence. Values are compared using IEquatable{T}.Equals(T).">Sucht nach der angegebenen Sequenz und gibt den Index des letzten Vorkommens zurück. Werte werden mit „IEquatable{T}.Equals(T)“ verglichen.</summary>
      <param name="span" vsli:raw="The span to search.">Die zu suchende Spanne.</param>
      <param name="value" vsli:raw="The sequence to search for.">Die zu suchende Sequenz.</param>
      <typeparam name="T" vsli:raw="The type of the span and value.">Der Typ der Spanne und des Werts.</typeparam>
      <returns vsli:raw="The index of the last occurrence of the value in the span. If not found, returns -1.">Der Index des letzten Vorkommens des Werts in der Spanne. Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},``0,``0)">
      <summary vsli:raw="Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator.">Sucht nach dem letzten Index eines der angegebenen Werte, ähnlich dem mehrmaligen Aufruf von LastIndexOf mit dem logischen OR-Operator (ODER).</summary>
      <param name="span" vsli:raw="The span to search.">Die zu suchende Spanne.</param>
      <param name="value0" vsli:raw="One of the values to search for.">Einer der zu suchenden Werte.</param>
      <param name="value1" vsli:raw="One of the values to search for.">Einer der zu suchenden Werte.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">Der Typ der Spanne und der Werte.</typeparam>
      <returns vsli:raw="The index of the last occurrence of any of the values in the span. If not found, returns -1.">Der Index des letzten Vorkommens eines der Werte in der Spanne. Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},``0,``0,``0)">
      <summary vsli:raw="Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator.">Sucht nach dem letzten Index eines der angegebenen Werte, ähnlich dem mehrmaligen Aufruf von LastIndexOf mit dem logischen OR-Operator (ODER).</summary>
      <param name="span" vsli:raw="The span to search.">Die zu suchende Spanne.</param>
      <param name="value0" vsli:raw="One of the values to search for.">Einer der zu suchenden Werte.</param>
      <param name="value1" vsli:raw="One of the values to search for.">Einer der zu suchenden Werte.</param>
      <param name="value2" vsli:raw="One of the values to search for.">Einer der zu suchenden Werte.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">Der Typ der Spanne und der Werte.</typeparam>
      <returns vsli:raw="The index of the last occurrence of any of the values in the span. If not found, returns -1.">Der Index des letzten Vorkommens eines der Werte in der Spanne. Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator.">Sucht nach dem letzten Index eines der angegebenen Werte, ähnlich dem mehrmaligen Aufruf von LastIndexOf mit dem logischen OR-Operator (ODER).</summary>
      <param name="span" vsli:raw="The span to search.">Die zu suchende Spanne.</param>
      <param name="values" vsli:raw="The set of values to search for.">Der zu suchende Satz von Werten.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">Der Typ der Spanne und der Werte.</typeparam>
      <returns vsli:raw="The index of the last occurrence of any of the values in the span. If not found, returns -1.">Der Index des letzten Vorkommens eines der Werte in der Spanne. Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},``0,``0)">
      <summary vsli:raw="Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator.">Sucht nach dem letzten Index eines der angegebenen Werte, ähnlich dem mehrmaligen Aufruf von LastIndexOf mit dem logischen OR-Operator (ODER).</summary>
      <param name="span" vsli:raw="The span to search.">Die zu suchende Spanne.</param>
      <param name="value0" vsli:raw="One of the values to search for.">Einer der zu suchenden Werte.</param>
      <param name="value1" vsli:raw="One of the values to search for.">Einer der zu suchenden Werte.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">Der Typ der Spanne und der Werte.</typeparam>
      <returns vsli:raw="The index of the last occurrence of any of the values in the span. If not found, returns -1.">Der Index des letzten Vorkommens eines der Werte in der Spanne. Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},``0,``0,``0)">
      <summary vsli:raw="Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator.">Sucht nach dem letzten Index eines der angegebenen Werte, ähnlich dem mehrmaligen Aufruf von LastIndexOf mit dem logischen OR-Operator (ODER).</summary>
      <param name="span" vsli:raw="The span to search.">Die zu suchende Spanne.</param>
      <param name="value0" vsli:raw="One of the values to search for.">Einer der zu suchenden Werte.</param>
      <param name="value1" vsli:raw="One of the values to search for.">Einer der zu suchenden Werte.</param>
      <param name="value2" vsli:raw="One of the values to search for.">Einer der zu suchenden Werte.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">Der Typ der Spanne und der Werte.</typeparam>
      <returns vsli:raw="The index of the last occurrence of any of the values in the span. If not found, returns -1.">Der Index des letzten Vorkommens eines der Werte in der Spanne. Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator.">Sucht nach dem letzten Index eines der angegebenen Werte, ähnlich dem mehrmaligen Aufruf von LastIndexOf mit dem logischen OR-Operator (ODER).</summary>
      <param name="span" vsli:raw="The span to search.">Die zu suchende Spanne.</param>
      <param name="values" vsli:raw="The set of values to search for.">Der zu suchende Satz von Werten.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">Der Typ der Spanne und der Werte.</typeparam>
      <returns vsli:raw="The index of the last occurrence of any of the values in the span. If not found, returns -1.">Der Index des letzten Vorkommens eines der Werte in der Spanne. Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Overlaps``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Determines whether two read-only sequences overlap in memory.">Bestimmt, ob sich zwei schreibgeschützte Sequenzen im Speicher überlappen.</summary>
      <param name="span" vsli:raw="The first sequence.">Die erste Sequenz.</param>
      <param name="other" vsli:raw="The second sequence.">Die zweite Sequenz.</param>
      <typeparam name="T" vsli:raw="The type of elements in the read-only sequence.">Der Typ der Elemente in der schreibgeschützten Sequenz.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two sequences overlap; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn sich die beiden Sequenzen überlappen, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Overlaps``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Int32@)">
      <summary vsli:raw="Determines whether two read-only sequences overlap in memory and outputs the element offset.">Bestimmt, ob sich zwei schreibgeschützte Sequenzen im Speicher überlappen, und gibt den Elementoffset aus.</summary>
      <param name="span" vsli:raw="The first sequence.">Die erste Sequenz.</param>
      <param name="other" vsli:raw="The second sequence.">Die zweite Sequenz.</param>
      <param name="elementOffset" vsli:raw="When the method returns, contains the offset between &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;other&quot; /&gt;.">Wenn die Methode zurückkehrt, enthält sie den Offset zwischen <paramref name="span" /> und <paramref name="other" />.</param>
      <typeparam name="T" vsli:raw="The type of elements in the span.">Der Typ der Elemente in der Spanne.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two sequences overlap; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn sich die beiden Sequenzen überlappen, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Overlaps``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Determines whether a span and a read-only span overlap in memory.">Bestimmt, ob sich eine Spanne und eine schreibgeschützte Spanne im Speicher überlappen.</summary>
      <param name="span" vsli:raw="The span to compare.">Die zu vergleichende Spanne.</param>
      <param name="other" vsli:raw="The read-only span to compare.">Die zu vergleichende schreibgeschützte Spanne.</param>
      <typeparam name="T" vsli:raw="The type of elements in the span.">Der Typ der Elemente in der Spanne.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two sequences overlap; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn sich die beiden Sequenzen überlappen, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Overlaps``1(System.Span{``0},System.ReadOnlySpan{``0},System.Int32@)">
      <summary vsli:raw="Determines whether a span and a read-only span overlap in memory and outputs the element offset.">Bestimmt, ob sich eine Spanne und eine schreibgeschützte Spanne im Speicher überlappen, und gibt den Elementoffset aus.</summary>
      <param name="span" vsli:raw="The first sequence to compare.">Die erste zu vergleichende Sequenz.</param>
      <param name="other" vsli:raw="The second sequence to compare.">Die zweite zu vergleichende Sequenz.</param>
      <param name="elementOffset" vsli:raw="When the method returns, contains the offset between &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;other&quot; /&gt;.">Wenn die Methode zurückkehrt, enthält sie den Offset zwischen <paramref name="span" /> und <paramref name="other" />.</param>
      <typeparam name="T" vsli:raw="The type of elements in the span.">Der Typ der Elemente in der Spanne.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two sequences overlap; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn sich die beiden Sequenzen überlappen, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Reverse``1(System.Span{``0})">
      <summary vsli:raw="Reverses the sequence of the elements in the entire span.">Kehrt die Reihenfolge der Elemente in der gesamten Spanne um.</summary>
      <param name="span" vsli:raw="The span to reverse.">Die umzukehrende Spanne.</param>
      <typeparam name="T" vsli:raw="The type of elements in the span.">Der Typ der Elemente in der Spanne.</typeparam>
    </member>
    <member name="M:System.MemoryExtensions.SequenceCompareTo``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Determines the relative order of two read-only sequences by comparing their elements using IComparable{T}.CompareTo(T).">Bestimmt die relative Reihenfolge von zwei schreibgeschützten Sequenzen durch Vergleichen ihrer Elemente mit „IComparable{T}.CompareTo(T)“.</summary>
      <param name="span" vsli:raw="The first sequence to compare.">Die erste zu vergleichende Sequenz.</param>
      <param name="other" vsli:raw="The second sequence to compare.">Die zweite zu vergleichende Sequenz.</param>
      <typeparam name="T" vsli:raw="The type of elements in the sequence.">Der Typ der Elemente in der Sequenz.</typeparam>
      <returns vsli:raw="A signed integer that indicates the relative order of &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;other&quot; /&gt;:&lt;br /&gt;   - If less than 0, &lt;paramref name=&quot;span&quot; /&gt; precedes than &lt;paramref name=&quot;other&quot; /&gt;.&lt;br /&gt;   - If 0, &lt;paramref name=&quot;span&quot; /&gt; equals &lt;paramref name=&quot;other&quot; /&gt;.&lt;br /&gt;   - If greater than 0, &lt;paramref name=&quot;span&quot; /&gt; follows &lt;paramref name=&quot;other&quot; /&gt;.">Eine ganze Zahl mit Vorzeichen, die die relative Reihenfolge von <paramref name="span" /> und <paramref name="other" /> angibt:   – Wenn kleiner als 0, <paramref name="span" /> vor <paramref name="other" />.   – Wenn diese 0 (null) sind, ist <paramref name="span" /> gleich <paramref name="other" />.   – Wenn größer als 0, folgt <paramref name="span" /> auf <paramref name="other" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.SequenceCompareTo``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Determines the relative order of a span and a read-only span by comparing the elements using IComparable{T}.CompareTo(T).">Bestimmt die relative Reihenfolge von einer Spanne und einer schreibgeschützten Spanne durch Vergleichen der Elemente mit „IComparable{T}.CompareTo(T)“.</summary>
      <param name="span" vsli:raw="The span to compare.">Die zu vergleichende Spanne.</param>
      <param name="other" vsli:raw="The read-only span to compare.">Die zu vergleichende schreibgeschützte Spanne.</param>
      <typeparam name="T" vsli:raw="The type of elements in the span.">Der Typ der Elemente in der Spanne.</typeparam>
      <returns vsli:raw="A signed integer that indicates the relative order of &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;other&quot; /&gt;:&lt;br /&gt;   - If less than 0, &lt;paramref name=&quot;span&quot; /&gt; precedes than &lt;paramref name=&quot;other&quot; /&gt;.&lt;br /&gt;   - If 0, &lt;paramref name=&quot;span&quot; /&gt; equals &lt;paramref name=&quot;other&quot; /&gt;.&lt;br /&gt;   - If greater than 0, &lt;paramref name=&quot;span&quot; /&gt; follows &lt;paramref name=&quot;other&quot; /&gt;.">Eine ganze Zahl mit Vorzeichen, die die relative Reihenfolge von <paramref name="span" /> und <paramref name="other" /> angibt:   – Wenn kleiner als 0, <paramref name="span" /> vor <paramref name="other" />.   – Wenn diese 0 (null) sind, ist <paramref name="span" /> gleich <paramref name="other" />.   – Wenn größer als 0, folgt <paramref name="span" /> auf <paramref name="other" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.SequenceEqual``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Determines whether two read-only sequences are equal by comparing the elements using IEquatable{T}.Equals(T).">Bestimmt, ob zwei schreibgeschützte Sequenzen identisch sind, indem die Elemente mit „IEquatable{T}.Equals(T)“ verglichen werden.</summary>
      <param name="span" vsli:raw="The first sequence to compare.">Die erste zu vergleichende Sequenz.</param>
      <param name="other" vsli:raw="The second sequence to compare.">Die zweite zu vergleichende Sequenz.</param>
      <typeparam name="T" vsli:raw="The type of elements in the sequence.">Der Typ der Elemente in der Sequenz.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two sequences are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn die beiden Sequenzen identisch sind, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.SequenceEqual``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Determines whether a span and a read-only span are equal by comparing the elements using IEquatable{T}.Equals(T).">Bestimmt, ob eine Spanne und eine schreibgeschützte Spanne identisch sind, indem die Elemente mit „IEquatable{T}.Equals(T)“ verglichen werden.</summary>
      <param name="span" vsli:raw="The span to compare.">Die zu vergleichende Spanne.</param>
      <param name="other" vsli:raw="The read-only span to compare.">Die zu vergleichende schreibgeschützte Spanne.</param>
      <typeparam name="T" vsli:raw="The type of elements in the sequence.">Der Typ der Elemente in der Sequenz.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two sequences are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn die beiden Sequenzen identisch sind, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Sort``1(System.Span{``0})">
      <summary vsli:raw="Sorts the elements in the entire &lt;see cref=&quot;T:System.Span`1&quot; /&gt; using the &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; implementation of each element of the &lt;see cref=&quot;T:System.Span`1&quot; /&gt;.">Sortiert die Elemente innerhalb von <see cref="T:System.Span`1" /> mithilfe der <see cref="T:System.IComparable`1" />-Implementierung jedes Elements von <see cref="T:System.Span`1" />.</summary>
      <param name="span" vsli:raw="The span of memory to sort.">Der Umfang des zu sortierenden Speichers.</param>
      <typeparam name="T" vsli:raw="The type of the elements of the span.">Der Typ der Elemente der Spanne.</typeparam>
      <exception cref="T:System.InvalidOperationException" vsli:raw="One or more elements in &lt;paramref name=&quot;span&quot; /&gt; do not implement the &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; interface.">In einem oder mehreren Elementen in <paramref name="span" /> ist die <see cref="T:System.IComparable`1" />-Schnittstelle nicht implementiert.</exception>
    </member>
    <member name="M:System.MemoryExtensions.Sort``1(System.Span{``0},System.Comparison{``0})">
      <summary vsli:raw="Sorts the elements in the entire &lt;see cref=&quot;T:System.Span`1&quot; /&gt; using the specified &lt;see cref=&quot;T:System.Comparison`1&quot; /&gt;.">Sortiert die Elemente in der gesamten <see cref="T:System.Span`1" /> mithilfe des angegebenen <see cref="T:System.Comparison`1" />.</summary>
      <param name="span" vsli:raw="The span of memory to sort.">Der Umfang des zu sortierenden Speichers.</param>
      <param name="comparison" vsli:raw="The method to use when comparing elements.">Die Methode, die beim Vergleichen von Elementen verwendet werden soll.</param>
      <typeparam name="T" vsli:raw="The type of the elements of the span.">Der Typ der Elemente der Spanne.</typeparam>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;comparison&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="comparison" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.Sort``2(System.Span{``0},``1)">
      <summary vsli:raw="Sorts the elements in the entire &lt;see cref=&quot;T:System.Span`1&quot; /&gt; using the &lt;typeparamref name=&quot;TComparer&quot; /&gt;.">Sortiert die Elemente innerhalb von <see cref="T:System.Span`1" /> mithilfe von <typeparamref name="TComparer" />.</summary>
      <param name="span" vsli:raw="The span of memory to sort.">Der Umfang des zu sortierenden Speichers.</param>
      <param name="comparer" vsli:raw="The method to use when comparing elements, or &lt;see langword=&quot;null&quot; /&gt; to use each element's &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; interface implementation.">Die Methode, die beim Vergleichen von Elementen verwendet werden soll, oder <see langword="null" />, um die <see cref="T:System.IComparable`1" />-Schnittstellenimplementierung jedes Elements zu verwenden.</param>
      <typeparam name="T" vsli:raw="The type of the elements of the span.">Der Typ der Elemente der Spanne.</typeparam>
      <typeparam name="TComparer" vsli:raw="The type of the comparer to use to compare elements.">Der Typ des Vergleichs, der zum Vergleichen von Elementen verwendet werden soll.</typeparam>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;comparer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;, and one or more elements in &lt;paramref name=&quot;span&quot; /&gt; do not implement the &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; interface.">
        <paramref name="comparer" /> ist <see langword="null" />, und in einem oder mehreren Elementen in <paramref name="span" /> ist die <see cref="T:System.IComparable`1" />-Schnittstelle nicht implementiert.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The implementation of &lt;paramref name=&quot;comparer&quot; /&gt; caused an error during the sort.">Die Implementierung von <paramref name="comparer" /> hat einen Fehler während der Sortierung verursacht.</exception>
    </member>
    <member name="M:System.MemoryExtensions.Sort``2(System.Span{``0},System.Span{``1})">
      <summary vsli:raw="Sorts a pair of spans (one containing the keys and the other containing the corresponding items) based on the keys in the first &lt;see cref=&quot;T:System.Span`1&quot; /&gt; using the &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; implementation of each key.">Sortiert ein Paar von Spannen (eine enthält die Schlüssel und die andere die entsprechenden Elemente) auf Basis der Schlüssel in der ersten Schnittstelle <see cref="T:System.Span`1" /> und mithilfe der <see cref="T:System.IComparable`1" />-Implementierung der einzelnen Schlüssel.</summary>
      <param name="keys" vsli:raw="The span that contains the keys to sort.">Die Spanne, die die zu sortierenden Schlüssel enthält.</param>
      <param name="items" vsli:raw="The span that contains the items that correspond to the keys in &lt;paramref name=&quot;keys&quot; /&gt;.">Die Spanne, die die Elemente enthält, die den Schlüsseln in <paramref name="keys" /> entsprechen.</param>
      <typeparam name="TKey" vsli:raw="The type of the elements of the key span.">Der Typ der Elemente der Schlüssel Spanne.</typeparam>
      <typeparam name="TValue" vsli:raw="The type of the elements of the items span.">Der Typ der Elemente der Element Spanne.</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="The length of &lt;paramref name=&quot;keys&quot; /&gt; isn't equal to the length of &lt;paramref name=&quot;items&quot; /&gt;.">Die Länge von <paramref name="keys" /> entspricht nicht der Länge von <paramref name="items" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="One or more elements in &lt;paramref name=&quot;keys&quot; /&gt; do not implement the &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; interface.">In einem oder mehreren Elementen in <paramref name="keys" /> ist die <see cref="T:System.IComparable`1" />-Schnittstelle nicht implementiert.</exception>
    </member>
    <member name="M:System.MemoryExtensions.Sort``2(System.Span{``0},System.Span{``1},System.Comparison{``0})">
      <summary vsli:raw="Sorts a pair of spans (one containing the keys and the other containing the corresponding items) based on the keys in the first &lt;see cref=&quot;T:System.Span`1&quot; /&gt; using the specified comparison.">Sortiert ein Paar von Spannen (eine enthält die Schlüssel und die andere die entsprechenden Elemente) auf Basis der Schlüssel in der ersten Schnittstelle <see cref="T:System.Span`1" /> und mithilfe des angegebenen Vergleichs.</summary>
      <param name="keys" vsli:raw="The span that contains the keys to sort.">Die Spanne, die die zu sortierenden Schlüssel enthält.</param>
      <param name="items" vsli:raw="The span that contains the items that correspond to the keys in &lt;paramref name=&quot;keys&quot; /&gt;.">Die Spanne, die die Elemente enthält, die den Schlüsseln in <paramref name="keys" /> entsprechen.</param>
      <param name="comparison" vsli:raw="The &lt;see cref=&quot;T:System.Comparison`1&quot; /&gt; to use when comparing elements.">Die <see cref="T:System.Comparison`1" />, die beim Vergleich von Elementen verwendet werden soll.</param>
      <typeparam name="TKey" vsli:raw="The type of the elements of the key span.">Der Typ der Elemente der Schlüssel Spanne.</typeparam>
      <typeparam name="TValue" vsli:raw="The type of the elements of the items span.">Der Typ der Elemente der Element Spanne.</typeparam>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;comparison&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="comparison" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The length of &lt;paramref name=&quot;keys&quot; /&gt; isn't equal to the length of &lt;paramref name=&quot;items&quot; /&gt;.">Die Länge von <paramref name="keys" /> entspricht nicht der Länge von <paramref name="items" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.Sort``3(System.Span{``0},System.Span{``1},``2)">
      <summary vsli:raw="Sorts a pair of spans (one containing the keys and the other containing the corresponding items) based on the keys in the first &lt;see cref=&quot;T:System.Span`1&quot; /&gt; using the specified comparer.">Sortiert ein Paar von Spannen (eine enthält die Schlüssel und die andere die entsprechenden Elemente) auf Basis der Schlüssel in der ersten Schnittstelle <see cref="T:System.Span`1" /> und mithilfe der angegebenen Vergleichsfunktion.</summary>
      <param name="keys" vsli:raw="The span that contains the keys to sort.">Die Spanne, die die zu sortierenden Schlüssel enthält.</param>
      <param name="items" vsli:raw="The span that contains the items that correspond to the keys in &lt;paramref name=&quot;keys&quot; /&gt;.">Die Spanne, die die Elemente enthält, die den Schlüsseln in <paramref name="keys" /> entsprechen.</param>
      <param name="comparer" vsli:raw="The &lt;see cref=&quot;T:System.Collections.Generic.IComparer`1&quot; /&gt; implementation to use when comparing elements, or &lt;see langword=&quot;null&quot; /&gt; to use the &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; interface implementation of each element.">Die <see cref="T:System.Collections.Generic.IComparer`1" />-Implementierung, die beim Vergleichen von Elementen verwendet werden soll, oder <see langword="null" />, um die <see cref="T:System.IComparable`1" />-Schnittstellenimplementierung der einzelnen Elemente zu verwenden.</param>
      <typeparam name="TKey" vsli:raw="The type of the elements of the key span.">Der Typ der Elemente der Schlüssel Spanne.</typeparam>
      <typeparam name="TValue" vsli:raw="The type of the elements of the items span.">Der Typ der Elemente der Element Spanne.</typeparam>
      <typeparam name="TComparer" vsli:raw="The type of the comparer to use to compare elements.">Der Typ des Vergleichs, der zum Vergleichen von Elementen verwendet werden soll.</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="The length of &lt;paramref name=&quot;keys&quot; /&gt; isn't equal to the length of &lt;paramref name=&quot;items&quot; /&gt;.">Die Länge von <paramref name="keys" /> entspricht nicht der Länge von <paramref name="items" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;comparer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;, and one or more elements in &lt;paramref name=&quot;keys&quot; /&gt; do not implement the &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; interface.">
        <paramref name="comparer" /> ist <see langword="null" />, und in einem oder mehreren Elementen in <paramref name="keys" /> ist die <see cref="T:System.IComparable`1" />-Schnittstelle nicht implementiert.</exception>
    </member>
    <member name="M:System.MemoryExtensions.StartsWith(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary vsli:raw="Determines whether a read-only character span begins with a specified value when compared using a specified &lt;see cref=&quot;T:System.StringComparison&quot; /&gt; value.">Bestimmt, ob eine schreibgeschützte Zeichenspanne mit einem angegebenen Wert beginnt, wenn sie mit einem angegebenen <see cref="T:System.StringComparison" />-Wert verglichen wird.</summary>
      <param name="span" vsli:raw="The source span.">Die Quellspanne.</param>
      <param name="value" vsli:raw="The sequence to compare to the beginning of the source span.">Die Sequenz, die mit dem Anfang der Quellspanne verglichen werden soll.</param>
      <param name="comparisonType" vsli:raw="An enumeration value that determines how &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;value&quot; /&gt; are compared.">Ein Enumerationswert, der bestimmt, wie <paramref name="span" /> und <paramref name="value" /> verglichen werden.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;value&quot; /&gt; matches the beginning of &lt;paramref name=&quot;span&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn <paramref name="value" /> mit dem Anfang von <paramref name="span" /> übereinstimmt, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.StartsWith``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Determines whether a specified sequence appears at the start of a read-only span.">Bestimmt, ob eine angegebene Sequenz am Anfang einer schreibgeschützten Spanne angezeigt wird.</summary>
      <param name="span" vsli:raw="The read-only character span to search.">Die zu suchende schreibgeschützte Zeichenspanne.</param>
      <param name="value" vsli:raw="A sequence to search for at the start of &lt;paramref name=&quot;span&quot; /&gt;.">Eine am Anfang von <paramref name="span" /> zu suchende Sequenz.</param>
      <typeparam name="T" vsli:raw="The type of elements in the span.">Der Typ der Elemente in der Spanne.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;value&quot; /&gt; matches the beginning of &lt;paramref name=&quot;span&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn <paramref name="value" /> mit dem Anfang von <paramref name="span" /> übereinstimmt, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.StartsWith``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Determines whether a specified sequence appears at the start of a span.">Bestimmt, ob eine angegebene Sequenz am Anfang einer Spanne angezeigt wird.</summary>
      <param name="span" vsli:raw="The span to search.">Die zu suchende Spanne.</param>
      <param name="value" vsli:raw="A sequence to search for at the start of &lt;paramref name=&quot;span&quot; /&gt;.">Eine am Anfang von <paramref name="span" /> zu suchende Sequenz.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the span.">Der Typ der Elemente in der Spanne.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;value&quot; /&gt; matches the beginning of &lt;paramref name=&quot;span&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn <paramref name="value" /> mit dem Anfang von <paramref name="span" /> übereinstimmt, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.ToLower(System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Globalization.CultureInfo)">
      <summary vsli:raw="Copies the characters from the source span into the destination, converting each character to lowercase, using the casing rules of the specified culture.">Kopiert die Zeichen aus der Quellspanne in das Ziel und konvertiert jedes Zeichen in Kleinbuchstaben, wobei die Regeln für die Groß-/Kleinschreibung der angegebenen Kultur verwendet werden.</summary>
      <param name="source" vsli:raw="The source span.">Die Quellspanne.</param>
      <param name="destination" vsli:raw="The destination span which contains the transformed characters.">Die Zielspanne, die die transformierten Zeichen enthält.</param>
      <param name="culture" vsli:raw="An object that supplies culture-specific casing rules.">Ein Objekt, das kulturspezifische Regeln zur Groß- und Kleinschreibung bereitstellt.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The source and destination buffers overlap.">Die Quell- und Zielpuffer überlappen sich.</exception>
      <returns vsli:raw="The number of characters written into the destination span. If the destination is too small, returns -1.">Die Anzahl der Zeichen, die in die Zielspanne geschrieben werden. Wenn das Ziel zu klein ist, wird -1 zurückgegeben.</returns>
    </member>
    <member name="M:System.MemoryExtensions.ToLowerInvariant(System.ReadOnlySpan{System.Char},System.Span{System.Char})">
      <summary vsli:raw="Copies the characters from the source span into the destination, converting each character to lowercase, using the casing rules of the invariant culture.">Kopiert die Zeichen aus der Quellspanne in das Ziel und konvertiert jedes Zeichen in Kleinbuchstaben, wobei die Regeln für die Groß-/Kleinschreibung der invarianten Kultur verwendet werden.</summary>
      <param name="source" vsli:raw="The source span.">Die Quellspanne.</param>
      <param name="destination" vsli:raw="The destination span which contains the transformed characters.">Die Zielspanne, die die transformierten Zeichen enthält.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The source and destination buffers overlap.">Die Quell- und Zielpuffer überlappen sich.</exception>
      <returns vsli:raw="The number of characters written into the destination span. If the destination is too small, returns -1.">Die Anzahl der Zeichen, die in die Zielspanne geschrieben werden. Wenn das Ziel zu klein ist, wird -1 zurückgegeben.</returns>
    </member>
    <member name="M:System.MemoryExtensions.ToUpper(System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Globalization.CultureInfo)">
      <summary vsli:raw="Copies the characters from the source span into the destination, converting each character to uppercase, using the casing rules of the specified culture.">Kopiert die Zeichen aus der Quellspanne in das Ziel und konvertiert jedes Zeichen in Kleinbuchstaben, wobei die Regeln für die Groß-/Kleinschreibung der angegebenen Kultur verwendet werden.</summary>
      <param name="source" vsli:raw="The source span.">Die Quellspanne.</param>
      <param name="destination" vsli:raw="The destination span which contains the transformed characters.">Die Zielspanne, die die transformierten Zeichen enthält.</param>
      <param name="culture" vsli:raw="An object that supplies culture-specific casing rules.">Ein Objekt, das kulturspezifische Regeln zur Groß- und Kleinschreibung bereitstellt.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The source and destination buffers overlap.">Die Quell- und Zielpuffer überlappen sich.</exception>
      <returns vsli:raw="The number of characters written into the destination span. If the destination is too small, returns -1.">Die Anzahl der Zeichen, die in die Zielspanne geschrieben werden. Wenn das Ziel zu klein ist, wird -1 zurückgegeben.</returns>
    </member>
    <member name="M:System.MemoryExtensions.ToUpperInvariant(System.ReadOnlySpan{System.Char},System.Span{System.Char})">
      <summary vsli:raw="Copies the characters from the source span into the destination, converting each character to uppercase using the casing rules of the invariant culture.">Kopiert die Zeichen aus der Quellspanne in das Ziel und konvertiert jedes Zeichen in Großbuchstaben, wobei die Regeln für die Groß-/Kleinschreibung der angegebenen Kultur verwendet werden.</summary>
      <param name="source" vsli:raw="The source span.">Die Quellspanne.</param>
      <param name="destination" vsli:raw="The destination span which contains the transformed characters.">Die Zielspanne, die die transformierten Zeichen enthält.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The source and destination buffers overlap.">Die Quell- und Zielpuffer überlappen sich.</exception>
      <returns vsli:raw="The number of characters written into the destination span. If the destination is too small, returns -1.">Die Anzahl der Zeichen, die in die Zielspanne geschrieben werden. Wenn das Ziel zu klein ist, wird -1 zurückgegeben.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.Memory{System.Char})">
      <summary vsli:raw="Removes all leading and trailing whitespace characters from a character memory region.">Entfernt alle führenden und nachfolgenden Leerzeichen aus einem Zeichenspeicherbereich.</summary>
      <param name="memory" vsli:raw="The source memory from which the characters are removed.">Der Quellspeicher, aus dem die Zeichen entfernt werden.</param>
      <returns vsli:raw="The trimmed character memory region.">Der zugeschnittene Zeichenspeicherbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.ReadOnlyMemory{System.Char})">
      <summary vsli:raw="Removes all leading and trailing whitespace characters from a read-only character memory region.">Entfernt alle führenden und nachfolgenden Leerzeichen aus einem schreibgeschützten Zeichenspeicherbereich.</summary>
      <param name="memory" vsli:raw="The source memory from which the characters are removed.">Der Quellspeicher, aus dem die Zeichen entfernt werden.</param>
      <returns vsli:raw="The trimmed character memory region.">Der zugeschnittene Zeichenspeicherbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char})">
      <summary vsli:raw="Removes all leading and trailing whitespace characters from a read-only character span.">Entfernt alle führenden und nachfolgenden Leerzeichen aus einer schreibgeschützten Zeichenspanne.</summary>
      <param name="span" vsli:raw="The source span from which the characters are removed.">Die Quellspanne, aus der die Zeichen entfernt werden.</param>
      <returns vsli:raw="The trimmed read-only character span.">Der zugeschnittene, schreibgeschützte Zeichenbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char},System.Char)">
      <summary vsli:raw="Removes all leading and trailing occurrences of a specified character from a read-only character span.">Entfernt alle führenden und nachfolgenden Vorkommen eines bestimmten Zeichens aus einer schreibgeschützten Zeichenspanne.</summary>
      <param name="span" vsli:raw="The source span from which the character is removed.">Die Quellspanne, aus der das Zeichen entfernt wird.</param>
      <param name="trimChar" vsli:raw="The specified character to look for and remove.">Das angegebene Zeichen, das gesucht und entfernt werden soll.</param>
      <returns vsli:raw="The trimmed read-only character span.">Der zugeschnittene, schreibgeschützte Zeichenbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
      <summary vsli:raw="Removes all leading and trailing occurrences of a set of characters specified in a read-only span from a read-only character span.">Entfernt alle führenden und nachfolgenden Vorkommen einer Reihe von Zeichen, die in einer schreibgeschützten Spanne angegeben sind, aus einer schreibgeschützten Zeichenspanne.</summary>
      <param name="span" vsli:raw="The source span from which the characters are removed.">Die Quellspanne, aus der die Zeichen entfernt werden.</param>
      <param name="trimChars" vsli:raw="The span which contains the set of characters to remove.">Die Spanne, die den zu entfernenden Zeichensatz enthält.</param>
      <returns vsli:raw="The trimmed read-only character span.">Der zugeschnittene, schreibgeschützte Zeichenbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.Span{System.Char})">
      <summary vsli:raw="Removes all leading and trailing whitespace characters from a character span.">Entfernt alle führenden und nachfolgenden Leerzeichen aus einer Zeichenspanne.</summary>
      <param name="span" vsli:raw="The source span from which the characters are removed.">Die Quellspanne, aus der die Zeichen entfernt werden.</param>
      <returns vsli:raw="The trimmed character span.">Der zugeschnittene Zeichenbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.Memory{``0},``0)">
      <summary vsli:raw="Removes all leading and trailing occurrences of a specified element from a memory region.">Entfernt alle führenden und nachfolgenden Vorkommen eines angegebenen Elements aus einem Speicherbereich.</summary>
      <param name="memory" vsli:raw="The source memory from which the element is removed.">Der Quellspeicher, aus dem das Element entfernt wird.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">Das angegebene Element, das gesucht und entfernt werden soll.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the memory region.">Der Typ der Elemente im Speicherbereich.</typeparam>
      <returns vsli:raw="The trimmed memory region.">Der zugeschnittene Speicherbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.Memory{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all leading and trailing occurrences of a set of elements specified in a read-only span from a memory region.">Entfernt alle führenden und nachfolgenden Vorkommen einer Reihe von Elementen, die in einer schreibgeschützten Spanne angegeben sind, aus einem Speicherbereich.</summary>
      <param name="memory" vsli:raw="The source memory from which the elements are removed.">Der Quellspeicher, aus dem die Elemente entfernt werden.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">Die Spanne, die den Satz der zu entfernenden Elemente enthält.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the memory region.">Der Typ der Elemente im Speicherbereich.</typeparam>
      <returns vsli:raw="The trimmed memory region.">Der zugeschnittene Speicherbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlyMemory{``0},``0)">
      <summary vsli:raw="Removes all leading and trailing occurrences of a specified element from a read-only memory region.">Entfernt alle führenden und nachfolgenden Vorkommen eines angegebenen Elements aus einem schreibgeschützten Speicherbereich.</summary>
      <param name="memory" vsli:raw="The source memory from which the element is removed.">Der Quellspeicher, aus dem das Element entfernt wird.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">Das angegebene Element, das gesucht und entfernt werden soll.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only memory region.">Der Typ der Elemente im schreibgeschützten Speicherbereich.</typeparam>
      <returns vsli:raw="The trimmed read-only memory region.">Der zugeschnittene, schreibgeschützte Speicherbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all leading and trailing occurrences of a set of elements specified in a read-only span from a read-only memory region.">Entfernt alle führenden und nachfolgenden Vorkommen einer Reihe von Elementen, die in einer schreibgeschützten Spanne angegeben sind, aus einem schreibgeschützten Speicherbereich.</summary>
      <param name="memory" vsli:raw="The source memory from which the elements are removed.">Der Quellspeicher, aus dem die Elemente entfernt werden.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">Die Spanne, die den Satz der zu entfernenden Elemente enthält.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only memory region.">Der Typ der Elemente im schreibgeschützten Speicherbereich.</typeparam>
      <returns vsli:raw="The trimmed read-only memory region.">Der zugeschnittene, schreibgeschützte Speicherbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlySpan{``0},``0)">
      <summary vsli:raw="Removes all leading and trailing occurrences of a specified element from a read-only span.">Entfernt alle führenden und nachfolgenden Vorkommen eines angegebenen Elements aus einer schreibgeschützten Spanne.</summary>
      <param name="span" vsli:raw="The source span from which the element is removed.">Die Quellspanne, aus der das Element entfernt wird.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">Das angegebene Element, das gesucht und entfernt werden soll.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only span.">Der Typ der Elemente in der schreibgeschützten Spanne.</typeparam>
      <returns vsli:raw="The trimmed read-only span.">Der zugeschnittene, schreibgeschützte Bereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all leading and trailing occurrences of a set of elements specified in a read-only span from a read-only span.">Entfernt alle führenden und nachfolgenden Vorkommen einer Reihe von Elementen, die in einer schreibgeschützten Spanne angegeben sind, aus einer schreibgeschützten Spanne.</summary>
      <param name="span" vsli:raw="The source span from which the elements are removed.">Die Quellspanne, aus der die Elemente entfernt werden.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">Die Spanne, die den Satz der zu entfernenden Elemente enthält.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only span.">Der Typ der Elemente in der schreibgeschützten Spanne.</typeparam>
      <returns vsli:raw="The trimmed read-only span.">Der zugeschnittene, schreibgeschützte Bereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.Span{``0},``0)">
      <summary vsli:raw="Removes all leading and trailing occurrences of a specified element from a span.">Entfernt alle führenden und nachfolgenden Vorkommen eines angegebenen Elements aus einer Spanne.</summary>
      <param name="span" vsli:raw="The source span from which the element is removed.">Die Quellspanne, aus der das Element entfernt wird.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">Das angegebene Element, das gesucht und entfernt werden soll.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the span.">Der Typ der Elemente in der Spanne.</typeparam>
      <returns vsli:raw="The trimmed span.">Der zugeschnittene Bereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all leading and trailing occurrences of a set of elements specified in a read-only span from a span.">Entfernt alle führenden und nachfolgenden Vorkommen einer Reihe von Elementen, die in einer schreibgeschützten Spanne angegeben sind, aus einer Spanne.</summary>
      <param name="span" vsli:raw="The source span from which the elements are removed.">Die Quellspanne, aus der die Elemente entfernt werden.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">Die Spanne, die den Satz der zu entfernenden Elemente enthält.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the span.">Der Typ der Elemente in der Spanne.</typeparam>
      <returns vsli:raw="The trimmed span.">Der zugeschnittene Bereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.Memory{System.Char})">
      <summary vsli:raw="Removes all trailing whitespace characters from a character memory region.">Entfernt alle nachfolgenden Leerzeichen aus einem Zeichenspeicherbereich.</summary>
      <param name="memory" vsli:raw="The source memory from which the characters are removed.">Der Quellspeicher, aus dem die Zeichen entfernt werden.</param>
      <returns vsli:raw="The trimmed character memory region.">Der zugeschnittene Zeichenspeicherbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlyMemory{System.Char})">
      <summary vsli:raw="Removes all trailing whitespace characters from a read-only character memory region.">Entfernt alle nachfolgenden Leerzeichen aus einem schreibgeschützten Zeichenspeicherbereich.</summary>
      <param name="memory" vsli:raw="The source memory from which the characters are removed.">Der Quellspeicher, aus dem die Zeichen entfernt werden.</param>
      <returns vsli:raw="The trimmed read-only character span.">Der zugeschnittene, schreibgeschützte Zeichenbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char})">
      <summary vsli:raw="Removes all trailing whitespace characters from a read-only character span.">Entfernt alle nachfolgenden Leerzeichen aus einer schreibgeschützten Zeichenspanne.</summary>
      <param name="span" vsli:raw="The source span from which the characters are removed.">Die Quellspanne, aus der die Zeichen entfernt werden.</param>
      <returns vsli:raw="The trimmed read-only character span.">Der zugeschnittene, schreibgeschützte Zeichenbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char},System.Char)">
      <summary vsli:raw="Removes all trailing occurrences of a specified character from a read-only span.">Entfernt alle nachfolgenden Vorkommen eines bestimmten Zeichens aus einer schreibgeschützten Spanne.</summary>
      <param name="span" vsli:raw="The source span from which the character is removed.">Die Quellspanne, aus der das Zeichen entfernt wird.</param>
      <param name="trimChar" vsli:raw="The specified character to look for and remove.">Das angegebene Zeichen, das gesucht und entfernt werden soll.</param>
      <returns vsli:raw="The trimmed read-only character span.">Der zugeschnittene, schreibgeschützte Zeichenbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
      <summary vsli:raw="Removes all trailing occurrences of a set of characters specified in a read-only span from a read-only character span.">Entfernt alle nachfolgenden Vorkommen einer Reihe von Zeichen, die in einer schreibgeschützten Spanne angegeben sind, aus einer schreibgeschützten Zeichenspanne.</summary>
      <param name="span" vsli:raw="The source span from which the characters are removed.">Die Quellspanne, aus der die Zeichen entfernt werden.</param>
      <param name="trimChars" vsli:raw="The span which contains the set of characters to remove.">Die Spanne, die den zu entfernenden Zeichensatz enthält.</param>
      <returns vsli:raw="The trimmed read-only character span.">Der zugeschnittene, schreibgeschützte Zeichenbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.Span{System.Char})">
      <summary vsli:raw="Removes all trailing whitespace characters from a character span.">Entfernt alle nachfolgenden Leerzeichen aus einer Zeichenspanne.</summary>
      <param name="span" vsli:raw="The source span from which the characters are removed.">Die Quellspanne, aus der die Zeichen entfernt werden.</param>
      <returns vsli:raw="The trimmed character span.">Der zugeschnittene Zeichenbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.Memory{``0},``0)">
      <summary vsli:raw="Removes all trailing occurrences of a specified element from a character memory region.">Entfernt alle nachfolgenden Vorkommen eines angegebenen Elements aus einem Zeichenspeicherbereich.</summary>
      <param name="memory" vsli:raw="The source memory from which the element is removed.">Der Quellspeicher, aus dem das Element entfernt wird.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">Das angegebene Element, das gesucht und entfernt werden soll.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the memory region.">Der Typ der Elemente im Speicherbereich.</typeparam>
      <returns vsli:raw="The trimmed memory region.">Der zugeschnittene Speicherbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.Memory{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all trailing occurrences of a set of elements specified in a read-only span from a memory region.">Entfernt alle nachfolgenden Vorkommen einer Reihe von Elementen, die in einer schreibgeschützten Spanne angegeben sind, aus einem Speicherbereich.</summary>
      <param name="memory" vsli:raw="The source memory from which the elements are removed.">Der Quellspeicher, aus dem die Elemente entfernt werden.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">Die Spanne, die den Satz der zu entfernenden Elemente enthält.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the memory region.">Der Typ der Elemente im Speicherbereich.</typeparam>
      <returns vsli:raw="The trimmed memory region.">Der zugeschnittene Speicherbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlyMemory{``0},``0)">
      <summary vsli:raw="Removes all trailing occurrences of a specified element from a read-only memory region.">Entfernt alle nachfolgenden Vorkommen eines angegebenen Elements aus einem schreibgeschützten Speicherbereich.</summary>
      <param name="memory" vsli:raw="The source memory from which the element is removed.">Der Quellspeicher, aus dem das Element entfernt wird.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">Das angegebene Element, das gesucht und entfernt werden soll.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only memory region.">Der Typ der Elemente im schreibgeschützten Speicherbereich.</typeparam>
      <returns vsli:raw="The trimmed read-only memory region.">Der zugeschnittene, schreibgeschützte Speicherbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all trailing occurrences of a set of elements specified in a read-only span from a read-only memory region.">Entfernt alle nachfolgenden Vorkommen einer Reihe von Elementen, die in einer schreibgeschützten Spanne angegeben sind, aus einem schreibgeschützten Speicherbereich.</summary>
      <param name="memory" vsli:raw="The source memory from which the elements are removed.">Der Quellspeicher, aus dem die Elemente entfernt werden.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">Die Spanne, die den Satz der zu entfernenden Elemente enthält.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only memory region.">Der Typ der Elemente im schreibgeschützten Speicherbereich.</typeparam>
      <returns vsli:raw="The trimmed read-only memory region.">Der zugeschnittene, schreibgeschützte Speicherbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlySpan{``0},``0)">
      <summary vsli:raw="Removes all trailing occurrences of a specified element from a read-only span.">Entfernt alle nachfolgenden Vorkommen eines angegebenen Elements aus einer schreibgeschützten Spanne.</summary>
      <param name="span" vsli:raw="The source span from which the element is removed.">Die Quellspanne, aus der das Element entfernt wird.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">Das angegebene Element, das gesucht und entfernt werden soll.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only span.">Der Typ der Elemente in der schreibgeschützten Spanne.</typeparam>
      <returns vsli:raw="The trimmed read-only span.">Der zugeschnittene, schreibgeschützte Bereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all trailing occurrences of a set of elements specified in a read-only span from a read-only span.">Entfernt alle nachfolgenden Vorkommen einer Reihe von Elementen, die in einer schreibgeschützten Spanne angegeben sind, aus einer schreibgeschützten Spanne.</summary>
      <param name="span" vsli:raw="The source span from which the elements are removed.">Die Quellspanne, aus der die Elemente entfernt werden.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">Die Spanne, die den Satz der zu entfernenden Elemente enthält.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only span.">Der Typ der Elemente in der schreibgeschützten Spanne.</typeparam>
      <returns vsli:raw="The trimmed read-only span.">Der zugeschnittene, schreibgeschützte Bereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.Span{``0},``0)">
      <summary vsli:raw="Removes all trailing occurrences of a specified element from a span.">Entfernt alle nachfolgenden Vorkommen eines angegebenen Elements aus einer Spanne.</summary>
      <param name="span" vsli:raw="The source span from which the element is removed.">Die Quellspanne, aus der das Element entfernt wird.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">Das angegebene Element, das gesucht und entfernt werden soll.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the span.">Der Typ der Elemente in der Spanne.</typeparam>
      <returns vsli:raw="The trimmed span.">Der zugeschnittene Bereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all trailing occurrences of a set of elements specified in a read-only span from a span.">Entfernt alle nachfolgenden Vorkommen einer Reihe von Elementen, die in einer schreibgeschützten Spanne angegeben sind, aus einer Spanne.</summary>
      <param name="span" vsli:raw="The source span from which the elements are removed.">Die Quellspanne, aus der die Elemente entfernt werden.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">Die Spanne, die den Satz der zu entfernenden Elemente enthält.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the span.">Der Typ der Elemente in der Spanne.</typeparam>
      <returns vsli:raw="The trimmed span.">Der zugeschnittene Bereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.Memory{System.Char})">
      <summary vsli:raw="Removes all leading whitespace characters from a memory region.">Entfernt alle führenden Leerzeichen aus einem Speicherbereich.</summary>
      <param name="memory" vsli:raw="The source memory from which the characters are removed.">Der Quellspeicher, aus dem die Zeichen entfernt werden.</param>
      <returns vsli:raw="The trimmed character memory region.">Der zugeschnittene Zeichenspeicherbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlyMemory{System.Char})">
      <summary vsli:raw="Removes all leading whitespace characters from a read-only memory region.">Entfernt alle führenden Leerzeichen aus einem schreibgeschützten Speicherbereich.</summary>
      <param name="memory" vsli:raw="The source memory from which the characters are removed.">Der Quellspeicher, aus dem die Zeichen entfernt werden.</param>
      <returns vsli:raw="The trimmed read-only character memory region.">Der zugeschnittene, schreibgeschützte Zeichenspeicherbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char})">
      <summary vsli:raw="Removes all leading whitespace characters from a read-only span.">Entfernt alle führenden Leerzeichen aus einer schreibgeschützten Spanne.</summary>
      <param name="span" vsli:raw="The source span from which the characters are removed.">Die Quellspanne, aus der die Zeichen entfernt werden.</param>
      <returns vsli:raw="The trimmed read-only character span.">Der zugeschnittene, schreibgeschützte Zeichenbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char},System.Char)">
      <summary vsli:raw="Removes all leading occurrences of a specified character from the span.">Entfernt alle führenden Vorkommen eines bestimmten Zeichens aus der Spanne.</summary>
      <param name="span" vsli:raw="The source span from which the character is removed.">Die Quellspanne, aus der das Zeichen entfernt wird.</param>
      <param name="trimChar" vsli:raw="The specified character to look for and remove.">Das angegebene Zeichen, das gesucht und entfernt werden soll.</param>
      <returns vsli:raw="The trimmed read-only character span.">Der zugeschnittene, schreibgeschützte Zeichenbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
      <summary vsli:raw="Removes all leading occurrences of a set of characters specified in a read-only span from the span.">Entfernt alle führenden Vorkommen einer Reihe von Zeichen, die in einer schreibgeschützten Spanne angegeben sind, aus der Spanne.</summary>
      <param name="span" vsli:raw="The source span from which the characters are removed.">Die Quellspanne, aus der die Zeichen entfernt werden.</param>
      <param name="trimChars" vsli:raw="The span which contains the set of characters to remove.">Die Spanne, die den zu entfernenden Zeichensatz enthält.</param>
      <returns vsli:raw="The trimmed read-only character span.">Der zugeschnittene, schreibgeschützte Zeichenbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.Span{System.Char})">
      <summary vsli:raw="Removes all leading whitespace characters from a span.">Entfernt alle führenden Leerzeichen aus einer Spanne.</summary>
      <param name="span" vsli:raw="The source span from which the characters are removed.">Die Quellspanne, aus der die Zeichen entfernt werden.</param>
      <returns vsli:raw="The trimmed character span.">Der zugeschnittene Zeichenbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.Memory{``0},``0)">
      <summary vsli:raw="Removes all leading occurrences of a specified element from a memory region.">Entfernt alle führenden Vorkommen eines angegebenen Elements aus einem Speicherbereich.</summary>
      <param name="memory" vsli:raw="The source memory region from which the element is removed.">Der Quellspeicherbereich, aus dem das Element entfernt wird.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">Das angegebene Element, das gesucht und entfernt werden soll.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the memory region.">Der Typ der Elemente im Speicherbereich.</typeparam>
      <returns vsli:raw="The trimmed memory region.">Der zugeschnittene Speicherbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.Memory{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all leading occurrences of a set of elements specified in a read-only span from a memory region.">Entfernt alle führenden Vorkommen einer Reihe von Elementen, die in einer schreibgeschützten Spanne angegeben sind, aus einem Speicherbereich.</summary>
      <param name="memory" vsli:raw="The source memory from which the elements are removed.">Der Quellspeicher, aus dem die Elemente entfernt werden.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">Die Spanne, die den Satz der zu entfernenden Elemente enthält.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the memory region.">Der Typ der Elemente im Speicherbereich.</typeparam>
      <returns vsli:raw="The trimmed memory region.">Der zugeschnittene Speicherbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlyMemory{``0},``0)">
      <summary vsli:raw="Removes all leading occurrences of a specified element from a memory region.">Entfernt alle führenden Vorkommen eines angegebenen Elements aus einem Speicherbereich.</summary>
      <param name="memory" vsli:raw="The source memory from which the element is removed.">Der Quellspeicher, aus dem das Element entfernt wird.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">Das angegebene Element, das gesucht und entfernt werden soll.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only memory region.">Der Typ der Elemente im schreibgeschützten Speicherbereich.</typeparam>
      <returns vsli:raw="The trimmed read-only memory region.">Der zugeschnittene, schreibgeschützte Speicherbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all leading occurrences of a set of elements specified in a read-only span from a memory region.">Entfernt alle führenden Vorkommen einer Reihe von Elementen, die in einer schreibgeschützten Spanne angegeben sind, aus einem Speicherbereich.</summary>
      <param name="memory" vsli:raw="The source memory from which the elements are removed.">Der Quellspeicher, aus dem die Elemente entfernt werden.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">Die Spanne, die den Satz der zu entfernenden Elemente enthält.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only memory region.">Der Typ der Elemente im schreibgeschützten Speicherbereich.</typeparam>
      <returns vsli:raw="The trimmed read-only memory region.">Der zugeschnittene, schreibgeschützte Speicherbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlySpan{``0},``0)">
      <summary vsli:raw="Removes all leading occurrences of a specified element from the span.">Entfernt alle führenden Vorkommen eines bestimmten Elements aus der Spanne.</summary>
      <param name="span" vsli:raw="The source span from which the element is removed.">Die Quellspanne, aus der das Element entfernt wird.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">Das angegebene Element, das gesucht und entfernt werden soll.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only span.">Der Typ der Elemente in der schreibgeschützten Spanne.</typeparam>
      <returns vsli:raw="The trimmed read-only span.">Der zugeschnittene, schreibgeschützte Bereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all leading occurrences of a set of elements specified in a read-only span from the span.">Entfernt alle führenden Vorkommen einer Reihe von Elementen, die in einer schreibgeschützten Spanne angegeben sind, aus der Spanne.</summary>
      <param name="span" vsli:raw="The source span from which the elements are removed.">Die Quellspanne, aus der die Elemente entfernt werden.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">Die Spanne, die den Satz der zu entfernenden Elemente enthält.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only span.">Der Typ der Elemente in der schreibgeschützten Spanne.</typeparam>
      <returns vsli:raw="The trimmed read-only span.">Der zugeschnittene, schreibgeschützte Bereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.Span{``0},``0)">
      <summary vsli:raw="Removes all leading occurrences of a specified element from the span.">Entfernt alle führenden Vorkommen eines bestimmten Elements aus der Spanne.</summary>
      <param name="span" vsli:raw="The source span from which the element is removed.">Die Quellspanne, aus der das Element entfernt wird.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">Das angegebene Element, das gesucht und entfernt werden soll.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the span.">Der Typ der Elemente in der Spanne.</typeparam>
      <returns vsli:raw="The trimmed span.">Der zugeschnittene Bereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all leading occurrences of a set of elements specified in a read-only span from the span.">Entfernt alle führenden Vorkommen einer Reihe von Elementen, die in einer schreibgeschützten Spanne angegeben sind, aus der Spanne.</summary>
      <param name="span" vsli:raw="The source span from which the elements are removed.">Die Quellspanne, aus der die Elemente entfernt werden.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">Die Spanne, die den Satz der zu entfernenden Elemente enthält.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the span.">Der Typ der Elemente in der Spanne.</typeparam>
      <returns vsli:raw="The trimmed span.">Der zugeschnittene Bereich.</returns>
    </member>
    <member name="T:System.Runtime.InteropServices.MemoryMarshal">
      <summary vsli:raw="Provides methods to interoperate with &lt;see cref=&quot;T:System.Memory`1&quot; /&gt;, &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt;,  &lt;see cref=&quot;T:System.Span`1&quot; /&gt;, and  &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt;.">Stellt Methoden für die Interoperabilität mit <see cref="T:System.Memory`1" />, <see cref="T:System.ReadOnlyMemory`1" />, <see cref="T:System.Span`1" /> und <see cref="T:System.ReadOnlySpan`1" /> bereit.</summary>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsBytes``1(System.ReadOnlySpan{``0})">
      <summary vsli:raw="Casts a &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; of one primitive type, &lt;paramref name=&quot;T&quot; /&gt;, to a &lt;see langword=&quot;ReadOnlySpan&amp;lt;Byte&amp;gt;&quot; /&gt;.">Wandelt ein <see cref="T:System.ReadOnlySpan`1" /> eines primitiven Typs, <paramref name="T" />, in ein <see langword="ReadOnlySpan&lt;Byte&gt;" /> um.</summary>
      <param name="span" vsli:raw="The source slice to convert.">Der zu konvertierende Quellslice.</param>
      <typeparam name="T" vsli:raw="The type of items in the read-only span.">Der Typ der Elemente in der schreibgeschützten Spanne.</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;T&quot; /&gt; contains managed object references.">
        <paramref name="T" /> enthält Verweise oder Zeiger.</exception>
      <exception cref="T:System.OverflowException" vsli:raw="The &lt;see cref=&quot;P:System.ReadOnlySpan`1.Length&quot; /&gt; property of the new &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; would exceed &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;">Die <see cref="P:System.ReadOnlySpan`1.Length" />-Eigenschaft des neuen <see cref="T:System.ReadOnlySpan`1" /> würde <see cref="F:System.Int32.MaxValue" /> überschreiten.</exception>
      <returns vsli:raw="A read-only span of type &lt;see cref=&quot;T:System.Byte&quot; /&gt;.">Der schreibgeschützte Span des Typs <see cref="T:System.Byte" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsBytes``1(System.Span{``0})">
      <summary vsli:raw="Casts a &lt;see cref=&quot;T:System.Span`1&quot; /&gt; of one primitive type, &lt;paramref name=&quot;T&quot; /&gt;, to a &lt;see langword=&quot;Span&amp;lt;Byte&amp;gt;&quot; /&gt;.">Wandelt ein <see cref="T:System.Span`1" /> eines primitiven Typs, <paramref name="T" />, in ein <see langword="Span&lt;Byte&gt;" /> um.</summary>
      <param name="span" vsli:raw="The source slice to convert.">Der zu konvertierende Quellslice.</param>
      <typeparam name="T" vsli:raw="The type of items in the span.">Der Typ der Elemente in der Spanne.</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;T&quot; /&gt; contains managed object references.">
        <paramref name="T" /> enthält Verweise oder Zeiger.</exception>
      <exception cref="T:System.OverflowException" vsli:raw="The &lt;see cref=&quot;P:System.ReadOnlySpan`1.Length&quot; /&gt; property of the new &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; would exceed &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;">Die <see cref="P:System.Span`1.Length" />-Eigenschaft des neuen <see cref="T:System.Span`1" /> würde <see cref="F:System.Int32.MaxValue" /> überschreiten.</exception>
      <returns vsli:raw="A span of type &lt;see cref=&quot;T:System.Byte&quot; /&gt;.">Ein Span des Typs <see cref="T:System.Byte" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsMemory``1(System.ReadOnlyMemory{``0})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Memory`1&quot; /&gt; instance from a &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt;.">Erstellt eine <see cref="T:System.Memory`1" />-Instanz aus einem <see cref="T:System.ReadOnlyMemory`1" />.</summary>
      <param name="memory" vsli:raw="The read-only memory buffer.">Der schreibgeschützte Speicherpuffer.</param>
      <typeparam name="T" vsli:raw="The type of items in the read-only memory buffer.">Der Typ der Elemente im schreibgeschützten Speicherpuffer.</typeparam>
      <returns vsli:raw="A memory block that represents the same memory as the &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt;.">Ein Arbeitsspeicherblock, der den gleichen Speicher wie <see cref="T:System.ReadOnlyMemory`1" /> darstellt.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsRef``1(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reinterprets a read-only span of bytes as a read-only reference to the structure of type &lt;paramref name=&quot;T&quot; /&gt;.">Interpretiert einen schreibgeschützten Bereich von Bytes neu als schreibgeschützten Verweis auf die Struktur vom Typ <paramref name="T" />.</summary>
      <param name="span" vsli:raw="The read-only span to reinterpret.">Der neu zu interpretierende Bereich.</param>
      <typeparam name="T" vsli:raw="The type of the returned reference.">Der Typ des zurückgegebenen Verweises.</typeparam>
      <returns vsli:raw="The read-only reference to the structure of type &lt;paramref name=&quot;T&quot; /&gt;.">Der schreibgeschützte Verweis auf die Struktur vom Typ <paramref name="T" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsRef``1(System.Span{System.Byte})">
      <summary vsli:raw="Reinterprets a span of bytes as a reference to the structure of type &lt;paramref name=&quot;T&quot; /&gt;.">Interpretiert einen Bereich von Bytes neu als Verweis auf die Struktur vom Typ <paramref name="T" />.</summary>
      <param name="span" vsli:raw="The span to reinterpret.">Der neu zu interpretierende Bereich.</param>
      <typeparam name="T" vsli:raw="The type of the returned reference.">Der Typ des zurückgegebenen Verweises.</typeparam>
      <returns vsli:raw="The reference to the structure of type &lt;paramref name=&quot;T&quot; /&gt;.">Der Verweis auf die Struktur vom Typ <paramref name="T" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.Cast``2(System.ReadOnlySpan{``0})">
      <summary vsli:raw="Casts a read-only span of one primitive type to a read-only span of another primitive type.">Wandelt einen schreibgeschützten Span eines primitiven Typs in einen schreibgeschützten Span eines anderen primitiven Typs um.</summary>
      <param name="span" vsli:raw="The source slice to convert.">Der zu konvertierende Quellslice.</param>
      <typeparam name="TFrom" vsli:raw="The type of the source span.">Der Typ der Quell Spanne.</typeparam>
      <typeparam name="TTo" vsli:raw="The type of the target span.">Der Typ der Zielspanne.</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;TFrom&quot; /&gt; or &lt;paramref name=&quot;TTo&quot; /&gt; contains managed object references.">
        <paramref name="TFrom" /> oder <paramref name="TTo" /> enthält Verweise oder Zeiger.</exception>
      <returns vsli:raw="The converted read-only span.">Die konvertierte schreibgeschützte Span.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.Cast``2(System.Span{``0})">
      <summary vsli:raw="Casts a span of one primitive type to a span of another primitive type.">Wandelt einen Span eines primitiven Typs in einen Span eines anderen primitiven Typs um.</summary>
      <param name="span" vsli:raw="The source slice to convert.">Der zu konvertierende Quellslice.</param>
      <typeparam name="TFrom" vsli:raw="The type of the source span.">Der Typ der Quell Spanne.</typeparam>
      <typeparam name="TTo" vsli:raw="The type of the target span.">Der Typ der Zielspanne.</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;TFrom&quot; /&gt; or &lt;paramref name=&quot;TTo&quot; /&gt; contains managed object references.">
        <paramref name="TFrom" /> oder <paramref name="TTo" /> enthält Verweise oder Zeiger.</exception>
      <returns vsli:raw="The converted span.">Der konvertierte Span.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.CreateFromPinnedArray``1(``0[],System.Int32,System.Int32)">
      <summary vsli:raw="Creates a new memory buffer over the portion of the pre-pinned target array beginning at the &lt;paramref name=&quot;start&quot; /&gt; index and consisting of &lt;paramref name=&quot;length&quot; /&gt; items.">Erstellt einen neuen Speicherpuffer über dem Abschnitt des bereits angehefteten Zielarrays, der beim Index <paramref name="start" /> beginnt und aus <paramref name="length" />-Elementen besteht.</summary>
      <param name="array" vsli:raw="The pre-pinned source array.">Das bereits angeheftete Quellarray.</param>
      <param name="start" vsli:raw="The index of &lt;paramref name=&quot;array&quot; /&gt; at which to begin the memory block.">Der Index von <paramref name="array" />, bei dem der Speicherblock begonnen wird.</param>
      <param name="length" vsli:raw="The number of items to include in the memory block.">Die Anzahl der Elemente, die in den Speicherblock eingeschlossen werden sollen.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Der Typ des Arrays.</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt; is covariant, and the type of &lt;paramref name=&quot;array&quot; /&gt; is not exactly &lt;paramref name=&quot;T[]&quot; /&gt;.">
        <paramref name="array" /> ist kovariant, und den Typ von <paramref name="array" /> ist nicht genau <paramref name="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The &lt;paramref name=&quot;start&quot; /&gt; or the end index is not in the range of 0 to &lt;see cref=&quot;P:System.Array.Length&quot; /&gt;.">Der <paramref name="start" />- oder der Endindex liegt nicht im Bereich von 0 bis <see cref="P:System.Array.Length" />.</exception>
      <returns vsli:raw="A block of memory over the specified elements of &lt;paramref name=&quot;array&quot; /&gt;. If &lt;paramref name=&quot;array&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;, or if &lt;paramref name=&quot;start&quot; /&gt; and &lt;paramref name=&quot;length&quot; /&gt; are 0, the method returns a &lt;see cref=&quot;T:System.Memory`1&quot; /&gt; instance of &lt;see cref=&quot;P:System.Memory`1.Length&quot; /&gt; zero.">Ein Speicherblock über die angegebenen Elemente von <paramref name="array" />. Wenn <paramref name="array" /><see langword="null" /> ist, oder wenn <paramref name="start" /> und <paramref name="length" /> 0 sind, gibt die Methode eine <see cref="T:System.Memory`1" /> Instanz von <see cref="P:System.Memory`1.Length" /> Null wieder.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.CreateReadOnlySpan``1(``0@,System.Int32)">
      <summary vsli:raw="Creates a new read-only span over a portion of a regular managed object.">Erstellt ein neues schreibgeschützten Span über einen Teil eines regulären verwalteten Objekts.</summary>
      <param name="reference" vsli:raw="A reference to data.">Ein Verweis auf Daten.</param>
      <param name="length" vsli:raw="The number of &lt;paramref name=&quot;T&quot; /&gt; elements that &lt;paramref name=&quot;reference&quot; /&gt; contains.">Die Anzahl der <paramref name="T" />-Elemente, die in <paramref name="reference" /> enthalten sind.</param>
      <typeparam name="T" vsli:raw="The type of the data items.">Der Typ der Datenelemente.</typeparam>
      <returns vsli:raw="A read-only span.">Ein schreibgeschützter Span.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.CreateSpan``1(``0@,System.Int32)">
      <summary vsli:raw="Creates a new span over a portion of a regular managed object.">Erstellt einen neuen Span über einen Teil eines regulären verwalteten Objekts.</summary>
      <param name="reference" vsli:raw="A reference to data.">Ein Verweis auf Daten.</param>
      <param name="length" vsli:raw="The number of &lt;paramref name=&quot;T&quot; /&gt; elements that &lt;paramref name=&quot;reference&quot; /&gt; contains.">Die Anzahl der <paramref name="T" />-Elemente, die in <paramref name="reference" /> enthalten sind.</param>
      <typeparam name="T" vsli:raw="The type of the data items.">Der Typ der Datenelemente.</typeparam>
      <returns vsli:raw="A span.">Ein Span.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.GetArrayDataReference``1(``0[])">
      <summary vsli:raw="Returns a reference to the 0th element of &lt;paramref name=&quot;array&quot; /&gt;. If the array is empty, returns a reference to where the 0th element would have been stored. Such a reference may be used for pinning but must never be dereferenced.">Gibt einen Verweis auf das nullte Element von <paramref name="array" /> zurück. Wenn das Array leer ist, wird ein Verweis auf den Speicherort zurückgegeben, an dem das nullte Element gespeichert worden wäre. Ein solcher Verweis kann zum Fixieren verwendet werden, darf jedoch nie dereferenziert werden.</summary>
      <param name="array" vsli:raw="The array to analyze.">Das zu analysierende Array.</param>
      <typeparam name="T" vsli:raw="The type of the array elements.">Der Typ der Arrayelemente.</typeparam>
      <exception cref="T:System.NullReferenceException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="array" /> ist <see langword="null" />.</exception>
      <returns vsli:raw="Reference to the 0th element in &lt;paramref name=&quot;array&quot; /&gt;.">Verweis auf das nullte Element in <paramref name="array" /></returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.GetReference``1(System.ReadOnlySpan{``0})">
      <summary vsli:raw="Returns a reference to the element of the read-only span at index 0.">Gibt einen Verweis auf das Element des schreibgeschützten Span bei Index 0 zurück.</summary>
      <param name="span" vsli:raw="The read-only span from which the reference is retrieved.">Der schreibgeschützte Span, aus dem der Verweis abgerufen wird.</param>
      <typeparam name="T" vsli:raw="The type of items in the span.">Der Typ der Elemente in der Spanne.</typeparam>
      <returns vsli:raw="A reference to the element at index 0.">Ein Verweis auf das Element bei Index 0.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.GetReference``1(System.Span{``0})">
      <summary vsli:raw="Returns a reference to the element of the span at index 0.">Gibt einen Verweis auf das Element des Span bei Index 0 zurück.</summary>
      <param name="span" vsli:raw="The span from which the reference is retrieved.">Der Span, aus dem der Verweis abgerufen wird.</param>
      <typeparam name="T" vsli:raw="The type of items in the span.">Der Typ der Elemente in der Spanne.</typeparam>
      <returns vsli:raw="A reference to the element at index 0.">Ein Verweis auf das Element bei Index 0.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.Read``1(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a structure of type &lt;typeparamref name=&quot;T&quot; /&gt; out of a read-only span of bytes.">Liest eine Struktur des Typ <param name="T" /> aus dem schreibgeschützten Bytes-Span.</summary>
      <param name="source" vsli:raw="A read-only span.">Ein schreibgeschützter Span.</param>
      <typeparam name="T" vsli:raw="The type of the item to retrieve from the read-only span.">Der Typ des Elements, das aus der schreibgeschützten Spanne abgerufen werden soll.</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;T&quot; /&gt; contains managed object references.">
        <paramref name="T" /> enthält Verweise oder Zeiger.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is smaller than &lt;paramref name=&quot;T&quot; /&gt;'s length in bytes.">
        <paramref name="source" /> ist kleiner als <paramref name="T" />.</exception>
      <returns vsli:raw="The structure retrieved from the read-only span.">Die aus dem schreibgeschützten Span abgerufene Struktur.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.ToEnumerable``1(System.ReadOnlyMemory{``0})">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; view of the given read-only memory buffer.">Erstellt eine <see cref="T:System.Collections.Generic.IEnumerable`1" />-Ansicht des angegebenen schreibgeschützten Speicherpuffers.</summary>
      <param name="memory" vsli:raw="A read-only memory buffer.">Ein schreibgeschützter Speicherpuffer.</param>
      <typeparam name="T" vsli:raw="The type of the items in the read-only memory buffer.">Der Typ der Elemente im schreibgeschützten Speicherpuffer.</typeparam>
      <returns vsli:raw="An enumerable view of &lt;paramref name=&quot;memory&quot; /&gt;.">Eine aufzählbare Ansicht von <paramref name="memory" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetArray``1(System.ReadOnlyMemory{``0},System.ArraySegment{``0}@)">
      <summary vsli:raw="Tries to get an array segment from the underlying memory buffer. The return value indicates the success of the operation.">Versucht, ein Arraysegment aus dem zugrunde liegenden Speicherpuffer abzurufen. Der Rückgabewert gibt den Erfolg des Vorgangs an.</summary>
      <param name="memory" vsli:raw="A read-only memory buffer.">Ein schreibgeschützter Speicherpuffer.</param>
      <param name="segment" vsli:raw="When this method returns, contains the array segment retrieved from the underlying read-only memory buffer. If the method fails, the method returns a default array segment.">Wenn diese Methode ein Ergebnis zurückgibt, enthält sie das Arraysegment, das aus dem zugrunde liegenden schreibgeschützten Speicherpuffer abgerufen wurde. Wenn die Methode fehlschlägt, gibt die Methode ein Standardarraysegment zurück.</param>
      <typeparam name="T" vsli:raw="The type of items in the read-only memory buffer.">Der Typ der Elemente im schreibgeschützten Speicherpuffer.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the method call succeeds; &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" />, wenn der Aufruf der Methode erfolgreich ist; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetMemoryManager``2(System.ReadOnlyMemory{``0},``1@)">
      <summary vsli:raw="Tries to retrieve a &lt;see cref=&quot;T:System.Buffers.MemoryManager`1&quot; /&gt; from the underlying read-only memory buffer.">Versucht, den <see cref="T:System.Buffers.MemoryManager`1" /> aus dem zugrunde liegenden schreibgeschützten Speicherpuffer abzurufen.</summary>
      <param name="memory" vsli:raw="The read-only memory buffer for which to get the memory manager.">Der schreibgeschützten Speicherpuffer, für den der Speicher-Manager abgerufen werden soll.</param>
      <param name="manager" vsli:raw="When the method returns, the manager of &lt;paramref name=&quot;memory&quot; /&gt;.">Wenn die Methode ein Ergebnis zurückgibt, der Manager von <paramref name="memory" />.</param>
      <typeparam name="T" vsli:raw="The type of the items in the read-only memory buffer.">Der Typ der Elemente im schreibgeschützten Speicherpuffer.</typeparam>
      <typeparam name="TManager" vsli:raw="The type of the &lt;see cref=&quot;T:System.Buffers.MemoryManager`1&quot; /&gt; to retrieve.">Der Typ des abzurufenden <see cref="T:System.Buffers.MemoryManager`1" /> .</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the method retrieved the memory manager; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn die Methode den Speicher-Manager abruft, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetMemoryManager``2(System.ReadOnlyMemory{``0},``1@,System.Int32@,System.Int32@)">
      <summary vsli:raw="Tries to retrieve a &lt;see cref=&quot;T:System.Buffers.MemoryManager`1&quot; /&gt;, start index, and length from the underlying read-only memory buffer.">Versucht, den <see cref="T:System.Buffers.MemoryManager`1" />, den Startindex und die Länge aus dem zugrunde liegenden schreibgeschützten Speicherpuffer abzurufen.</summary>
      <param name="memory" vsli:raw="The read-only memory buffer for which to get the memory manager.">Der schreibgeschützten Speicherpuffer, für den der Speicher-Manager abgerufen werden soll.</param>
      <param name="manager" vsli:raw="When the method returns, the manager of &lt;paramref name=&quot;memory&quot; /&gt;.">Wenn die Methode ein Ergebnis zurückgibt, der Manager von <paramref name="memory" />.</param>
      <param name="start" vsli:raw="When the method returns, the offset from the start of the &lt;paramref name=&quot;manager&quot; /&gt; that the &lt;paramref name=&quot;memory&quot; /&gt; represents.">Wenn die Methode ein Ergebnis zurückgibt, der Offset ab dem Beginn des <paramref name="manager" />, den der <paramref name="memory" /> darstellt.</param>
      <param name="length" vsli:raw="When the method returns, the length of the &lt;paramref name=&quot;manager&quot; /&gt; that the &lt;paramref name=&quot;memory&quot; /&gt; represents.">Wenn die Methode ein Ergebnis zurückgibt, der Länge des <paramref name="manager" />, den der <paramref name="memory" /> darstellt.</param>
      <typeparam name="T" vsli:raw="The type of the items in the read-only memory buffer.">Der Typ der Elemente im schreibgeschützten Speicherpuffer.</typeparam>
      <typeparam name="TManager" vsli:raw="The type of the &lt;see cref=&quot;T:System.Buffers.MemoryManager`1&quot; /&gt; to retrieve.">Der Typ des abzurufenden <see cref="T:System.Buffers.MemoryManager`1" /> .</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the method succeeded; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn die Methode erfolgreich ausgeführt wurde, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetString(System.ReadOnlyMemory{System.Char},System.String@,System.Int32@,System.Int32@)">
      <summary vsli:raw="Tries to get the underlying string from a &lt;see langword=&quot;System.ReadOnlyMemory&amp;lt;Char&amp;gt;&quot; /&gt;.">Versucht, die zugrunde liegenden Zeichenfolge aus einem <see langword="System.ReadOnlyMemory&lt;Char&gt;" /> abzurufen.</summary>
      <param name="memory" vsli:raw="Read-only memory containing a block of characters.">Schreibgeschützter Speicher mit einem Block an Zeichen.</param>
      <param name="text" vsli:raw="When the method returns, the string contained in the memory buffer.">Wenn die Methode ein Ergebnis zurückgibt, die Zeichenfolge im Speicherpuffer.</param>
      <param name="start" vsli:raw="The starting location in &lt;paramref name=&quot;text&quot; /&gt;.">Die Anfangsposition in <paramref name="text" />.</param>
      <param name="length" vsli:raw="The number of characters in &lt;paramref name=&quot;text&quot; /&gt;.">Die Anzahl von Zeichen in <paramref name="text" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the method successfully retrieves the underlying string; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn die Methode die zugrunde liegende Zeichenfolge erfolgreich abruft, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryRead``1(System.ReadOnlySpan{System.Byte},``0@)">
      <summary vsli:raw="Tries to read a structure of type &lt;paramref name=&quot;T&quot; /&gt; from a read-only span of bytes.">Versucht, eine Struktur vom Typ <paramref name="T" /> aus einem schreibgeschützten Bereich von Bytes zu lesen.</summary>
      <param name="source" vsli:raw="A read-only span of bytes.">Ein schreibgeschützter Bytes-Span.</param>
      <param name="value" vsli:raw="When the method returns, an instance of &lt;paramref name=&quot;T&quot; /&gt;.">Wenn die Methode ein Ergebnis zurückgibt, eine Instanz von <paramref name="T" />.</param>
      <typeparam name="T" vsli:raw="The type of the structure to retrieve.">Der Typ der abzurufenden-Struktur.</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;T&quot; /&gt; contains managed object references.">
        <paramref name="T" /> enthält Verweise oder Zeiger.</exception>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the method succeeds in retrieving an instance of the structure; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn die Methode erfolgreich eine Instanz der Struktur abruft, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryWrite``1(System.Span{System.Byte},``0@)">
      <summary vsli:raw="Tries to write a structure of type &lt;paramref name=&quot;T&quot; /&gt; into a span of bytes.">Versucht, eine Struktur vom Typ <paramref name="T" /> in einen Bereich von Bytes zu schreiben.</summary>
      <param name="destination" vsli:raw="The span of bytes to contain the structure.">Der Bytes-Span, der die Struktur enthält.</param>
      <param name="value" vsli:raw="The structure to be written to the span.">Die Struktur, die in den Span geschrieben werden soll.</param>
      <typeparam name="T" vsli:raw="The type of the structure.">Der Typ der Struktur.</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;T&quot; /&gt; contains managed object references.">
        <paramref name="T" /> enthält Verweise oder Zeiger.</exception>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the write operation succeeded; otherwise, &lt;see langword=&quot;false&quot; /&gt;. The method returns &lt;see langword=&quot;false&quot; /&gt; if the span is too small to contain &lt;paramref name=&quot;T&quot; /&gt;.">
        <see langword="true" />, wenn der Schreibvorgang erfolgreich ausgeführt wurde, andernfalls <see langword="false" />. Die Methode gibt <see langword="false" /> zurück, wenn der Bereich zu klein ist für den <paramref name="T" /> ist.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.Write``1(System.Span{System.Byte},``0@)">
      <summary vsli:raw="Writes a structure of type &lt;paramref name=&quot;T&quot; /&gt; into a span of bytes.">Schreibt eine Struktur vom Typ <paramref name="T" /> in einen Bereich von Bytes.</summary>
      <param name="destination" vsli:raw="The span of bytes to contain the structure.">Der Bytes-Span, der die Struktur enthält.</param>
      <param name="value" vsli:raw="The structure to be written to the span.">Die Struktur, die in den Span geschrieben werden soll.</param>
      <typeparam name="T" vsli:raw="The type of the structure.">Der Typ der Struktur.</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;T&quot; /&gt; contains managed object references.">
        <paramref name="T" /> enthält Verweise oder Zeiger.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain &lt;paramref name=&quot;value&quot; /&gt;.">
        <paramref name="destination" /> ist zu klein für <paramref name="value" />.</exception>
    </member>
    <member name="T:System.Runtime.InteropServices.SequenceMarshal">
      <summary vsli:raw="Provides a collection of methods for interoperating with &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Stellt eine Sammlung von Methoden für die Interoperabilität mit <see cref="T:System.Buffers.ReadOnlySequence`1" /> zur Verfügung.</summary>
    </member>
    <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryGetArray``1(System.Buffers.ReadOnlySequence{``0},System.ArraySegment{``0}@)">
      <summary vsli:raw="Gets an array segment from the underlying read-only sequence.">Ruft ein Arraysegment aus der zugrunde liegenden schreibgeschützten Sequenz ab.</summary>
      <param name="sequence" vsli:raw="The read-only sequence from which the array segment will be retrieved.">Die schreibgeschützte Sequenz, aus der das Arraysegment abgerufen wird.</param>
      <param name="segment" vsli:raw="The returned array segment.">Das zurückgegebene Arraysegment.</param>
      <typeparam name="T" vsli:raw="The type of the read-only sequence.">Der Typ der schreibgeschützten Sequenz.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if it's possible to retrieve the array segment; otherwise, &lt;see langword=&quot;false&quot; /&gt; and a default array segment is returned.">
        <see langword="true" />, wenn es möglich ist, das Arraysegment abzurufen, andernfalls wird <see langword="false" /> und ein Standardarraysegment zurückgegeben.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryGetReadOnlyMemory``1(System.Buffers.ReadOnlySequence{``0},System.ReadOnlyMemory{``0}@)">
      <summary vsli:raw="Attempts to retrieve a read-only memory from the specified read-only sequence.">Versucht, einen schreibgeschützten Arbeitsspeicher aus der angegebenen schreibgeschützten Sequenz abzurufen.</summary>
      <param name="sequence" vsli:raw="The read-only sequence from which the memory will be retrieved.">Die schreibgeschützte Sequenz, aus der der Arbeitsspeicher abgerufen wird.</param>
      <param name="memory" vsli:raw="The returned read-only memory of type T.">Der zurückgegebene schreibgeschützte Arbeitsspeicher vom Typ T.</param>
      <typeparam name="T" vsli:raw="The type of the read-only sequence.">Der Typ der schreibgeschützten Sequenz.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the read-only memory can be retrieved; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn der schreibgeschützte Arbeitsspeicher abgerufen werden kann, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryGetReadOnlySequenceSegment``1(System.Buffers.ReadOnlySequence{``0},System.Buffers.ReadOnlySequenceSegment{``0}@,System.Int32@,System.Buffers.ReadOnlySequenceSegment{``0}@,System.Int32@)">
      <summary vsli:raw="Attempts to retrieve a read-only sequence segment from the specified read-only sequence.">Versucht, ein schreibgeschütztes Sequenzsegment aus der angegebenen schreibgeschützten Sequenz abzurufen.</summary>
      <param name="sequence" vsli:raw="The read-only sequence from which the read-only sequence segment will be retrieved.">Die schreibgeschützte Sequenz, aus der das schreibgeschützte Sequenzsegment abgerufen wird.</param>
      <param name="startSegment" vsli:raw="The beginning read-only sequence segment.">Das anfängliche schreibgeschützte Sequenzsegment.</param>
      <param name="startIndex" vsli:raw="The initial position.">Die anfängliche Position.</param>
      <param name="endSegment" vsli:raw="The ending read-only sequence segment.">Das abschließende schreibgeschützte Sequenzsegment.</param>
      <param name="endIndex" vsli:raw="The final position.">Die Endposition.</param>
      <typeparam name="T" vsli:raw="The type of the read-only sequence.">Der Typ der schreibgeschützten Sequenz.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the read-only sequence segment can be retrieved; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn das schreibgeschützte Sequenzsegment abgerufen werden kann, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryRead``1(System.Buffers.SequenceReader{System.Byte}@,``0@)">
      <summary vsli:raw="Attempts to read the specified type out of the buffer. It's dangerous to use this method with arbitrary structs - see remarks for more information.">Versucht, den angegebenen Typ aus dem Puffer zu lesen. Es ist gefährlich, diese Methode mit beliebigen Strukturen zu verwenden – weitere Informationen finden Sie unter den Hinweisen.</summary>
      <param name="reader" vsli:raw="A reference to the sequence reader.">Ein Verweis auf den Sequenzleser.</param>
      <param name="value" vsli:raw="The returned value if the read was successful. &lt;paramref name=&quot;value&quot; /&gt; will be &lt;see langword=&quot;default&quot; /&gt; if failed (due to lack of space).">Der zurückgegebene Wert, wenn der Lesevorgang erfolgreich war. Bei einem Fehler ist <paramref name="value" /><see langword="default" /> (aufgrund von unzureichendem Speicherplatz).</param>
      <typeparam name="T" vsli:raw="The type of the value.">Der Typ des Werts.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the read attempt was successful, &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" />, wenn der Leseversuch erfolgreich war, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="T:System.SequencePosition">
      <summary vsli:raw="Represents a position in a non-contiguous set of memory. Properties of this type should not be interpreted by anything but the type that created it.">Stellt eine Position in mehreren nicht zusammenhängenden Speichern dar. Eigenschaften dieses Typs sollten nur von dem Typ interpretiert werden, der sie erstellt hat.</summary>
    </member>
    <member name="M:System.SequencePosition.#ctor(System.Object,System.Int32)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; struct.">Initialisiert eine neue Instanz der <see cref="T:System.SequencePosition" />-Struktur.</summary>
      <param name="object" vsli:raw="A non-contiguous set of memory.">Mehrere nicht zusammenhängende Speicher.</param>
      <param name="integer" vsli:raw="The position in &lt;paramref name=&quot;object&quot; /&gt;.">Die Position in <paramref name="object" />.</param>
    </member>
    <member name="M:System.SequencePosition.Equals(System.Object)">
      <summary vsli:raw="Returns a value that indicates whether the current instance is equal to another object.">Gibt einen Wert zurück, der angibt, ob die aktuelle Instanz gleich einem anderen Objekt ist.</summary>
      <param name="obj" vsli:raw="The object to compare with the current instance.">Das Objekt, das mit der aktuellen Instanz verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;obj&quot; /&gt; is of type &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; and is equal to the current instance; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn <paramref name="obj" /> gleich dem Typ <see cref="T:System.SequencePosition" /> und der aktuellen Instanz ist; anderenfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.SequencePosition.Equals(System.SequencePosition)">
      <summary vsli:raw="Indicates whether the current instance is equal to another &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt;.">Gibt an, ob die aktuelle Instanz gleich einer anderen <see cref="T:System.SequencePosition" />-Struktur ist.</summary>
      <param name="other" vsli:raw="The sequence position to compare with the current instance.">Die Sequenzposition, die mit der aktuellen Instanz verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two instances are equal; &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" />, wenn die beiden Instanzen genau gleich sind; sonst <see langword="false" />.</returns>
    </member>
    <member name="M:System.SequencePosition.GetHashCode">
      <summary vsli:raw="Returns the hash code for this instance.">Gibt den Hashcode für diese Instanz zurück.</summary>
      <returns vsli:raw="The hash code for this instance.">Der Hashcode für diese Instanz.</returns>
    </member>
    <member name="M:System.SequencePosition.GetInteger">
      <summary vsli:raw="Returns the integer part of this &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt;.">Gibt den ganzzahligen Teil dieser <see cref="T:System.SequencePosition" /> zurück.</summary>
      <returns vsli:raw="The integer part of this sequence position.">Der ganzzahlige Teil dieser Sequenzposition.</returns>
    </member>
    <member name="M:System.SequencePosition.GetObject">
      <summary vsli:raw="Returns the object part of this &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt;.">Gibt den Objektteil dieser <see cref="T:System.SequencePosition" /> zurück.</summary>
      <returns vsli:raw="The object part of this sequence position.">Der Objektteil dieser Sequenzposition.</returns>
    </member>
    <member name="T:System.Text.EncodingExtensions">
      <summary vsli:raw="Provides extension methods for the encoding types, such as &lt;see cref=&quot;T:System.Text.Encoding&quot; /&gt;, &lt;see cref=&quot;T:System.Text.Encoder&quot; /&gt;, and &lt;see cref=&quot;T:System.Text.Decoder&quot; /&gt;.">Diese Klasse stellt Erweiterungsmethoden für die Codierungstypen bereit, z. B. <see cref="T:System.Text.Encoding" />, <see cref="T:System.Text.Encoder" />und <see cref="T:System.Text.Decoder" />.</summary>
    </member>
    <member name="M:System.Text.EncodingExtensions.Convert(System.Text.Decoder,System.Buffers.ReadOnlySequence{System.Byte}@,System.Buffers.IBufferWriter{System.Char},System.Boolean,System.Int64@,System.Boolean@)">
      <summary vsli:raw="Converts a &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; to UTF-16 encoded characters and writes the result to &lt;paramref name=&quot;writer&quot; /&gt;.">Konvertiert eine <see cref="T:System.Buffers.ReadOnlySequence`1" /> in UTF-16-codierte Zeichen und schreibt das Ergebnis in <paramref name="writer" />.</summary>
      <param name="decoder" vsli:raw="The decoder instance that can convert bytes to &lt;see langword=&quot;char&quot; /&gt; values.">Die Decoderinstanz, die Bytes in <see langword="char" />-Werte konvertieren kann.</param>
      <param name="bytes" vsli:raw="A sequence of bytes to decode.">Die zu decodierende Bytesequenz.</param>
      <param name="writer" vsli:raw="The buffer to which the decoded characters will be written.">Der Puffer, in den die decodierten Zeichen geschrieben werden.</param>
      <param name="flush" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to indicate no further data is to be converted; otherwise &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, um anzugeben, dass keine weiteren Daten konvertiert werden; andernfalls <see langword="false" />.</param>
      <param name="charsUsed" vsli:raw="When this method returns, contains the count of characters that were written to &lt;paramref name=&quot;writer&quot; /&gt;.">Enthält nach Ausführung dieser Methode die Anzahl der in <paramref name="writer" /> geschriebenen Zeichen.</param>
      <param name="completed" vsli:raw="When this method returns, contains &lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;decoder&quot; /&gt; contains no partial internal state; otherwise, &lt;see langword=&quot;false&quot; /&gt;.&#xA; If &lt;paramref name=&quot;flush&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;, this will always be set to &lt;see langword=&quot;true&quot; /&gt; when the method returns.">Enthält nach Ausführung dieser Methode <see langword="true" />, wenn <paramref name="decoder" /> keinen partiellen internen Zustand enthält; andernfalls <see langword="false" />.
Wenn <paramref name="flush" /><see langword="true" /> ist, wird dieser stets auf <see langword="true" /> festgelegt, nachdem die Methode ausgeführt wurde.</param>
      <exception cref="T:System.Text.DecoderFallbackException" vsli:raw="&lt;paramref name=&quot;bytes&quot; /&gt; contains data that cannot be decoded and &lt;paramref name=&quot;decoder&quot; /&gt; is configured to throw when such data is seen.">
        <paramref name="bytes" /> enthält Daten, die nicht decodiert werden können, und <paramref name="decoder" /> ist für das Auslösen konfiguriert, wenn solche Daten erkannt werden.</exception>
    </member>
    <member name="M:System.Text.EncodingExtensions.Convert(System.Text.Decoder,System.ReadOnlySpan{System.Byte},System.Buffers.IBufferWriter{System.Char},System.Boolean,System.Int64@,System.Boolean@)">
      <summary vsli:raw="Converts a &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; to chars using &lt;paramref name=&quot;decoder&quot; /&gt; and writes the result to &lt;paramref name=&quot;writer&quot; /&gt;.">Konvertiert eine <see cref="T:System.ReadOnlySpan`1" /> mithilfe von <paramref name="decoder" /> in Zeichen und schreibt das Ergebnis in <paramref name="writer" />.</summary>
      <param name="decoder" vsli:raw="The decoder instance that can convert bytes to &lt;see langword=&quot;char&quot; /&gt; values.">Die Decoderinstanz, die Bytes in <see langword="char" />-Werte konvertieren kann.</param>
      <param name="bytes" vsli:raw="A sequence of bytes to decode.">Die zu decodierende Bytesequenz.</param>
      <param name="writer" vsli:raw="The buffer to which the decoded chars will be written.">Der Puffer, in den die decodierten Zeichen geschrieben werden.</param>
      <param name="flush" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to indicate no further data is to be converted; otherwise &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, um anzugeben, dass keine weiteren Daten konvertiert werden; andernfalls <see langword="false" />.</param>
      <param name="charsUsed" vsli:raw="When this method returns, contains the count of &lt;see langword=&quot;char&quot; /&gt;s which were written to &lt;paramref name=&quot;writer&quot; /&gt;.">Enthält nach Ausführung dieser Methode die Anzahl der <see langword="char" />-Instanzen, die in <paramref name="writer" /> geschrieben wurden.</param>
      <param name="completed" vsli:raw="When this method returns, contains &lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;decoder&quot; /&gt; contains no partial internal state; otherwise, &lt;see langword=&quot;false&quot; /&gt;.&#xA; If &lt;paramref name=&quot;flush&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;, this will always be set to &lt;see langword=&quot;true&quot; /&gt; when the method returns.">Enthält nach Ausführung dieser Methode <see langword="true" />, wenn <paramref name="decoder" /> keinen partiellen internen Zustand enthält; andernfalls <see langword="false" />.
Wenn <paramref name="flush" /><see langword="true" /> ist, wird dieser stets auf <see langword="true" /> festgelegt, nachdem die Methode ausgeführt wurde.</param>
      <exception cref="T:System.Text.DecoderFallbackException" vsli:raw="&lt;paramref name=&quot;bytes&quot; /&gt; contains data that cannot be encoded and &lt;paramref name=&quot;decoder&quot; /&gt; is configured to throw when such data is seen.">
        <paramref name="bytes" /> enthält Daten, die nicht codiert werden können, und <paramref name="decoder" /> ist für das Auslösen konfiguriert, wenn solche Daten erkannt werden.</exception>
    </member>
    <member name="M:System.Text.EncodingExtensions.Convert(System.Text.Encoder,System.Buffers.ReadOnlySequence{System.Char}@,System.Buffers.IBufferWriter{System.Byte},System.Boolean,System.Int64@,System.Boolean@)">
      <summary vsli:raw="Converts a &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; to encoded bytes and writes the result to &lt;paramref name=&quot;writer&quot; /&gt;.">Konvertiert eine <see cref="T:System.Buffers.ReadOnlySequence`1" /> in codierte Bytes und schreibt das Ergebnis in <paramref name="writer" />.</summary>
      <param name="encoder" vsli:raw="The encoder instance that can convert &lt;see langword=&quot;char&quot; /&gt; values to bytes.">Die Encoderinstanz, die <see langword="char" />-Werte in Bytes konvertieren kann.</param>
      <param name="chars" vsli:raw="A sequence of characters to encode.">Eine Sequenz von Zeichen, die codiert werden sollen.</param>
      <param name="writer" vsli:raw="The buffer to which the encoded bytes will be written.">Der Puffer, in den die codierten Bytes geschrieben werden.</param>
      <param name="flush" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to indicate no further data is to be converted; otherwise &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, um anzugeben, dass keine weiteren Daten konvertiert werden; andernfalls <see langword="false" />.</param>
      <param name="bytesUsed" vsli:raw="When this method returns, contains the count of &lt;see langword=&quot;byte&quot; /&gt;s which were written to &lt;paramref name=&quot;writer&quot; /&gt;.">Enthält nach Ausführung dieser Methode die Anzahl der <see langword="byte" />-Instanzen, die in <paramref name="writer" /> geschrieben wurden.</param>
      <param name="completed" vsli:raw="When this method returns, contains &lt;see langword=&quot;true&quot; /&gt; if all input up until &lt;paramref name=&quot;bytesUsed&quot; /&gt; was converted; otherwise, &lt;see langword=&quot;false&quot; /&gt;. If &lt;paramref name=&quot;flush&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;, this will always be set to &lt;see langword=&quot;true&quot; /&gt; when the method returns.">Enthält nach Ausführung dieser Methode <see langword="true" />, wenn alle Eingaben bis <paramref name="bytesUsed" /> konvertiert wurden; andernfalls <see langword="false" />. Wenn <paramref name="flush" /><see langword="true" /> ist, wird dieser stets auf <see langword="true" /> festgelegt, nachdem die Methode ausgeführt wurde.</param>
      <exception cref="T:System.Text.EncoderFallbackException" vsli:raw="&lt;paramref name=&quot;chars&quot; /&gt; contains data that cannot be encoded and &lt;paramref name=&quot;encoder&quot; /&gt; is configured to throw when such data is seen.">
        <paramref name="chars" /> enthält Daten, die nicht codiert werden können, und <paramref name="encoder" /> ist für das Auslösen konfiguriert, wenn solche Daten erkannt werden.</exception>
    </member>
    <member name="M:System.Text.EncodingExtensions.Convert(System.Text.Encoder,System.ReadOnlySpan{System.Char},System.Buffers.IBufferWriter{System.Byte},System.Boolean,System.Int64@,System.Boolean@)">
      <summary vsli:raw="Converts a &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; to bytes using &lt;paramref name=&quot;encoder&quot; /&gt; and writes the result to &lt;paramref name=&quot;writer&quot; /&gt;.">Konvertiert eine <see cref="T:System.ReadOnlySpan`1" /> mithilfe von <paramref name="encoder" /> in Bytes und schreibt das Ergebnis in <paramref name="writer" />.</summary>
      <param name="encoder" vsli:raw="The encoder instance that can convert &lt;see langword=&quot;char&quot; /&gt; values to bytes.">Die Encoderinstanz, die <see langword="char" />-Werte in Bytes konvertieren kann.</param>
      <param name="chars" vsli:raw="A sequence of characters to encode.">Eine Sequenz von Zeichen, die codiert werden sollen.</param>
      <param name="writer" vsli:raw="The buffer to which the encoded bytes will be written.">Der Puffer, in den die codierten Bytes geschrieben werden.</param>
      <param name="flush" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to indicate no further data is to be converted; otherwise &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, um anzugeben, dass keine weiteren Daten konvertiert werden; andernfalls <see langword="false" />.</param>
      <param name="bytesUsed" vsli:raw="When this method returns, contains the count of &lt;see langword=&quot;byte&quot; /&gt;s which were written to &lt;paramref name=&quot;writer&quot; /&gt;.">Enthält nach Ausführung dieser Methode die Anzahl der <see langword="byte" />-Instanzen, die in <paramref name="writer" /> geschrieben wurden.</param>
      <param name="completed" vsli:raw="When this method returns, contains &lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;encoder&quot; /&gt; contains no partial internal state; otherwise, &lt;see langword=&quot;false&quot; /&gt;.&#xA; If &lt;paramref name=&quot;flush&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;, this will always be set to &lt;see langword=&quot;true&quot; /&gt; when the method returns.">Enthält nach Ausführung dieser Methode <see langword="true" />, wenn <paramref name="encoder" /> keinen partiellen internen Zustand enthält; andernfalls <see langword="false" />.
Wenn <paramref name="flush" /><see langword="true" /> ist, wird dieser stets auf <see langword="true" /> festgelegt, nachdem die Methode ausgeführt wurde.</param>
      <exception cref="T:System.Text.EncoderFallbackException" vsli:raw="&lt;paramref name=&quot;chars&quot; /&gt; contains data that cannot be encoded and &lt;paramref name=&quot;encoder&quot; /&gt; is configured to throw when such data is seen.">
        <paramref name="chars" /> enthält Daten, die nicht codiert werden können, und <paramref name="encoder" /> ist für das Auslösen konfiguriert, wenn solche Daten erkannt werden.</exception>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetBytes(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Char}@)">
      <summary vsli:raw="Encodes the specified &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; into a &lt;see cref=&quot;T:System.Byte&quot; /&gt; array using the specified &lt;see cref=&quot;T:System.Text.Encoding&quot; /&gt;.">Codiert die angegebene <see cref="T:System.Buffers.ReadOnlySequence`1" /> unter Verwendung der angegebenen <see cref="T:System.Text.Encoding" /> in ein <see cref="T:System.Byte" />-Array.</summary>
      <param name="encoding" vsli:raw="The encoding that represents how the data in &lt;paramref name=&quot;chars&quot; /&gt; should be encoded.">Die Codierung, die angibt, wie die Daten in <paramref name="chars" /> codiert werden sollen.</param>
      <param name="chars" vsli:raw="The sequence to encode to bytes.">Die Sequenz, die in Bytes codiert werden soll.</param>
      <exception cref="T:System.Text.EncoderFallbackException" vsli:raw="&lt;paramref name=&quot;chars&quot; /&gt; contains data that cannot be encoded and &lt;paramref name=&quot;encoding&quot; /&gt; is configured to throw when such data is seen.">
        <paramref name="chars" /> enthält Daten, die nicht codiert werden können, und <paramref name="encoding" /> ist für das Auslösen konfiguriert, wenn solche Daten erkannt werden.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Byte&quot; /&gt; array that represents the encoded contents of &lt;paramref name=&quot;chars&quot; /&gt;.">Ein <see cref="T:System.Byte" />-Array, das den codierten Inhalt von <paramref name="chars" /> darstellt.</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetBytes(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Char}@,System.Buffers.IBufferWriter{System.Byte})">
      <summary vsli:raw="Decodes the specified &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; to &lt;see langword=&quot;byte&quot; /&gt;s using the specified &lt;see cref=&quot;T:System.Text.Encoding&quot; /&gt; and writes the result to &lt;paramref name=&quot;writer&quot; /&gt;.">Decodiert die angegebene <see cref="T:System.Buffers.ReadOnlySequence`1" /> in <see langword="byte" />s unter Verwendung der angegebenen <see cref="T:System.Text.Encoding" /> und schreibt das Ergebnis in <paramref name="writer" />.</summary>
      <param name="encoding" vsli:raw="The encoding that represents how the data in &lt;paramref name=&quot;chars&quot; /&gt; should be encoded.">Die Codierung, die angibt, wie die Daten in <paramref name="chars" /> codiert werden sollen.</param>
      <param name="chars" vsli:raw="The &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; whose contents should be encoded.">Die <see cref="T:System.Buffers.ReadOnlySequence`1" />, deren Inhalt codiert werden soll.</param>
      <param name="writer" vsli:raw="The buffer to which the encoded bytes will be written.">Der Puffer, in den die codierten Bytes geschrieben werden.</param>
      <exception cref="T:System.Text.EncoderFallbackException" vsli:raw="&lt;paramref name=&quot;chars&quot; /&gt; contains data that cannot be encoded and &lt;paramref name=&quot;encoding&quot; /&gt; is configured to throw when such data is seen.">
        <paramref name="chars" /> enthält Daten, die nicht codiert werden können, und <paramref name="encoding" /> ist für das Auslösen konfiguriert, wenn solche Daten erkannt werden.</exception>
      <returns vsli:raw="The number of bytes written to &lt;paramref name=&quot;writer&quot; /&gt;.">Die Anzahl der Bytes, die in <paramref name="writer" /> geschrieben wurden.</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetBytes(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Char}@,System.Span{System.Byte})">
      <summary vsli:raw="Encodes the specified &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; to &lt;see langword=&quot;byte&quot; /&gt;s using the specified &lt;see cref=&quot;T:System.Text.Encoding&quot; /&gt; and outputs the result to &lt;paramref name=&quot;bytes&quot; /&gt;.">Codiert die angegebene <see cref="T:System.Buffers.ReadOnlySequence`1" /> in <see langword="byte" />s unter Verwendung der angegebenen <see cref="T:System.Text.Encoding" /> und gibt das Ergebnis in <paramref name="bytes" /> aus.</summary>
      <param name="encoding" vsli:raw="The encoding that represents how the data in &lt;paramref name=&quot;chars&quot; /&gt; should be encoded.">Die Codierung, die angibt, wie die Daten in <paramref name="chars" /> codiert werden sollen.</param>
      <param name="chars" vsli:raw="The sequence to encode to bytes.">Die Sequenz, die in Bytes codiert werden soll.</param>
      <param name="bytes" vsli:raw="The destination buffer to which the encoded bytes will be written.">Der Zielpuffer, in den die codierten Bytes geschrieben werden.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;bytes&quot; /&gt; is not large enough to contain the encoded form of &lt;paramref name=&quot;chars&quot; /&gt;.">
        <paramref name="bytes" /> ist nicht groß genug, um die codierte Form von <paramref name="chars" /> aufzunehmen.</exception>
      <exception cref="T:System.Text.EncoderFallbackException" vsli:raw="&lt;paramref name=&quot;chars&quot; /&gt; contains data that cannot be encoded and &lt;paramref name=&quot;encoding&quot; /&gt; is configured to throw when such data is seen.">
        <paramref name="chars" /> enthält Daten, die nicht codiert werden können, und <paramref name="encoding" /> ist für das Auslösen konfiguriert, wenn solche Daten erkannt werden.</exception>
      <returns vsli:raw="The number of bytes written to &lt;paramref name=&quot;bytes&quot; /&gt;.">Die Anzahl der Bytes, die in <paramref name="bytes" /> geschrieben wurden.</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetBytes(System.Text.Encoding,System.ReadOnlySpan{System.Char},System.Buffers.IBufferWriter{System.Byte})">
      <summary vsli:raw="Encodes the specified &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; to &lt;see langword=&quot;byte&quot; /&gt;s using the specified &lt;see cref=&quot;T:System.Text.Encoding&quot; /&gt; and writes the result to &lt;paramref name=&quot;writer&quot; /&gt;.">Codiert die angegebene <see cref="T:System.ReadOnlySpan`1" /> in <see langword="byte" />s unter Verwendung der angegebenen <see cref="T:System.Text.Encoding" /> und schreibt das Ergebnis in <paramref name="writer" />.</summary>
      <param name="encoding" vsli:raw="The encoding that represents how the data in &lt;paramref name=&quot;chars&quot; /&gt; should be encoded.">Die Codierung, die angibt, wie die Daten in <paramref name="chars" /> codiert werden sollen.</param>
      <param name="chars" vsli:raw="The sequence to encode to bytes.">Die Sequenz, die in Bytes codiert werden soll.</param>
      <param name="writer" vsli:raw="The buffer to which the encoded bytes will be written.">Der Puffer, in den die codierten Bytes geschrieben werden.</param>
      <exception cref="T:System.Text.EncoderFallbackException" vsli:raw="&lt;paramref name=&quot;chars&quot; /&gt; contains data that cannot be encoded and &lt;paramref name=&quot;encoding&quot; /&gt; is configured to throw when such data is seen.">
        <paramref name="chars" /> enthält Daten, die nicht codiert werden können, und <paramref name="encoding" /> ist für das Auslösen konfiguriert, wenn solche Daten erkannt werden.</exception>
      <returns vsli:raw="The number of bytes written to &lt;paramref name=&quot;writer&quot; /&gt;.">Die Anzahl der Bytes, die in <paramref name="writer" /> geschrieben wurden.</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetChars(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Byte}@,System.Buffers.IBufferWriter{System.Char})">
      <summary vsli:raw="Decodes the specified &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; to &lt;see langword=&quot;char&quot; /&gt;s using the specified &lt;see cref=&quot;T:System.Text.Encoding&quot; /&gt; and writes the result to &lt;paramref name=&quot;writer&quot; /&gt;.">Decodiert die angegebene <see cref="T:System.Buffers.ReadOnlySequence`1" /> in <see langword="char" />s unter Verwendung der angegebenen <see cref="T:System.Text.Encoding" /> und schreibt das Ergebnis in <paramref name="writer" />.</summary>
      <param name="encoding" vsli:raw="The encoding that represents how the data in &lt;paramref name=&quot;bytes&quot; /&gt; should be decoded.">Die Codierung, die angibt, wie die Daten in <paramref name="bytes" /> decodiert werden sollen.</param>
      <param name="bytes" vsli:raw="The sequence whose bytes should be decoded.">Die Sequenz, deren Bytes decodiert werden sollen.</param>
      <param name="writer" vsli:raw="The buffer to which the decoded chars will be written.">Der Puffer, in den die decodierten Zeichen geschrieben werden.</param>
      <exception cref="T:System.Text.DecoderFallbackException" vsli:raw="&lt;paramref name=&quot;bytes&quot; /&gt; contains data that cannot be decoded and &lt;paramref name=&quot;encoding&quot; /&gt; is configured to throw when such data is seen.">
        <paramref name="bytes" /> enthält Daten, die nicht decodiert werden können, und <paramref name="encoding" /> ist für das Auslösen konfiguriert, wenn solche Daten erkannt werden.</exception>
      <returns vsli:raw="The number of chars written to &lt;paramref name=&quot;writer&quot; /&gt;.">Die Anzahl der in <paramref name="writer" /> geschriebenen Zeichen.</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetChars(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Byte}@,System.Span{System.Char})">
      <summary vsli:raw="Decodes the specified &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; to &lt;see langword=&quot;char&quot; /&gt;s using the specified &lt;see cref=&quot;T:System.Text.Encoding&quot; /&gt; and outputs the result to &lt;paramref name=&quot;chars&quot; /&gt;.">Decodiert die angegebene <see cref="T:System.Buffers.ReadOnlySequence`1" /> in <see langword="char" />s unter Verwendung der angegebenen <see cref="T:System.Text.Encoding" /> und gibt das Ergebnis in <paramref name="chars" /> aus.</summary>
      <param name="encoding" vsli:raw="The encoding that represents how the data in &lt;paramref name=&quot;bytes&quot; /&gt; is encoded.">Die Codierung, die angibt, wie die Daten in <paramref name="bytes" /> codiert werden.</param>
      <param name="bytes" vsli:raw="The sequence to decode to characters.">Die Sequenz, die in Zeichen decodiert werden soll.</param>
      <param name="chars" vsli:raw="The destination buffer to which the decoded characters will be written.">Der Zielpuffer, in den die decodierten Zeichen geschrieben werden.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;chars&quot; /&gt; is not large enough to contain the encoded form of &lt;paramref name=&quot;bytes&quot; /&gt;.">
        <paramref name="chars" /> ist nicht groß genug, um die codierte Form von <paramref name="bytes" /> aufzunehmen.</exception>
      <exception cref="T:System.Text.DecoderFallbackException" vsli:raw="&lt;paramref name=&quot;bytes&quot; /&gt; contains data that cannot be decoded and &lt;paramref name=&quot;encoding&quot; /&gt; is configured to throw when such data is seen.">
        <paramref name="bytes" /> enthält Daten, die nicht decodiert werden können, und <paramref name="encoding" /> ist für das Auslösen konfiguriert, wenn solche Daten erkannt werden.</exception>
      <returns vsli:raw="The number of chars written to &lt;paramref name=&quot;chars&quot; /&gt;.">Die Anzahl der in <paramref name="chars" /> geschriebenen Zeichen.</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetChars(System.Text.Encoding,System.ReadOnlySpan{System.Byte},System.Buffers.IBufferWriter{System.Char})">
      <summary vsli:raw="Decodes the specified &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; to &lt;see langword=&quot;char&quot; /&gt;s using the specified &lt;see cref=&quot;T:System.Text.Encoding&quot; /&gt; and writes the result to &lt;paramref name=&quot;writer&quot; /&gt;.">Decodiert die angegebene <see cref="T:System.ReadOnlySpan`1" /> in <see langword="char" />s unter Verwendung der angegebenen <see cref="T:System.Text.Encoding" /> und schreibt das Ergebnis in <paramref name="writer" />.</summary>
      <param name="encoding" vsli:raw="The encoding that represents how the data in &lt;paramref name=&quot;bytes&quot; /&gt; should be decoded.">Die Codierung, die angibt, wie die Daten in <paramref name="bytes" /> decodiert werden sollen.</param>
      <param name="bytes" vsli:raw="The span of bytes to decode.">Der Bereich der zu decodierenden Bytes.</param>
      <param name="writer" vsli:raw="The buffer to which the decoded chars will be written.">Der Puffer, in den die decodierten Zeichen geschrieben werden.</param>
      <exception cref="T:System.Text.DecoderFallbackException" vsli:raw="&lt;paramref name=&quot;bytes&quot; /&gt; contains data that cannot be decoded and &lt;paramref name=&quot;encoding&quot; /&gt; is configured to throw when such data is seen.">
        <paramref name="bytes" /> enthält Daten, die nicht decodiert werden können, und <paramref name="encoding" /> ist für das Auslösen konfiguriert, wenn solche Daten erkannt werden.</exception>
      <returns vsli:raw="The number of chars written to &lt;paramref name=&quot;writer&quot; /&gt;.">Die Anzahl der in <paramref name="writer" /> geschriebenen Zeichen.</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetString(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Byte}@)">
      <summary vsli:raw="Decodes the specified &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; into a &lt;see cref=&quot;T:System.String&quot; /&gt; using the specified &lt;see cref=&quot;T:System.Text.Encoding&quot; /&gt;.">Decodiert die angegebene <see cref="T:System.Buffers.ReadOnlySequence`1" /> unter Verwendung der angegebenen <see cref="T:System.Text.Encoding" /> in einen <see cref="T:System.String" />.</summary>
      <param name="encoding" vsli:raw="The encoding that represents how the data in &lt;paramref name=&quot;bytes&quot; /&gt; is encoded.">Die Codierung, die angibt, wie die Daten in <paramref name="bytes" /> codiert werden.</param>
      <param name="bytes" vsli:raw="The sequence to decode into characters.">Die Sequenz, die in Zeichen decodiert werden soll.</param>
      <exception cref="T:System.Text.DecoderFallbackException" vsli:raw="&lt;paramref name=&quot;bytes&quot; /&gt; contains data that cannot be decoded and &lt;paramref name=&quot;encoding&quot; /&gt; is configured to throw when such data is seen.">
        <paramref name="bytes" /> enthält Daten, die nicht decodiert werden können, und <paramref name="encoding" /> ist für das Auslösen konfiguriert, wenn solche Daten erkannt werden.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.String&quot; /&gt; which represents the decoded contents of &lt;paramref name=&quot;bytes&quot; /&gt;.">Ein <see cref="T:System.String" />, der den decodierten Inhalt von <paramref name="bytes" /> darstellt.</returns>
    </member>
    <member name="T:System.Text.SpanRuneEnumerator">
      <summary vsli:raw="Provides an enumerator for the &lt;see cref=&quot;T:System.Text.Rune&quot; /&gt; values represented by a span containing UTF-16 text.">Stellt einen Enumerator für die <see cref="T:System.Text.Rune" />-Werte bereit, die durch einen Bereich dargestellt werden, der UTF-16-Text enthält</summary>
    </member>
    <member name="M:System.Text.SpanRuneEnumerator.GetEnumerator">
      <summary vsli:raw="Returns the current enumerator instance.">Gibt die aktuelle Enumeratorinstanz zurück</summary>
      <returns vsli:raw="The current enumerator instance.">Die aktuelle Enumeratorinstanz</returns>
    </member>
    <member name="M:System.Text.SpanRuneEnumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next &lt;see cref=&quot;T:System.Text.Rune&quot; /&gt; of the span.">Legt den Enumerator auf das nächste <see cref="T:System.Text.Rune" />-Element des Bereichs fest</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator successfully advanced to the next item; &lt;see langword=&quot;false&quot; /&gt; if the end of the span has been reached.">
        <see langword="true" />, wenn der Enumerator erfolgreich auf das nächste Element festgelegt wurde; <see langword="false" />, wenn das Ende des Bereichs erreicht wurde</returns>
    </member>
    <member name="P:System.Text.SpanRuneEnumerator.Current">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Text.Rune&quot; /&gt; at the current position of the enumerator.">Ruft <see cref="T:System.Text.Rune" /> an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Text.Rune&quot; /&gt; at the current position of the enumerator.">Das-Element <see cref="T:System.Text.Rune" /> an der aktuellen Position des Enumerators.</returns>
    </member>
  </members>
</doc>