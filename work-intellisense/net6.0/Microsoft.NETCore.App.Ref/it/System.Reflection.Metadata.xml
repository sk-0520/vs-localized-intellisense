<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Reflection.Metadata</name>
  </assembly>
  <members>
    <member name="T:System.Reflection.AssemblyFlags" />
    <member name="F:System.Reflection.AssemblyFlags.ContentTypeMask">
      <summary>Bit mascherati del tipo di contenuto che corrispondono ai valori di <see cref="T:System.Reflection.AssemblyContentType" />.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.DisableJitCompileOptimizer">
      <summary>L'ottimizzazione del compilatore JIT (Just-In-Time) è disabilitata per l'assembly.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.EnableJitCompileTracking">
      <summary>Il rilevamento del compilatore JIT (Just-In-Time) è abilitato per l'assembly.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.PublicKey">
      <summary>Il riferimento all'assembly include la chiave pubblica completa (senza hash). Non applicabile alla definizione dell'assembly.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.Retargetable">
      <summary>Non è previsto che l'implementazione dell'assembly a cui viene fatto riferimento usata in fase di esecuzione corrisponda alla versione visualizzata in fase di compilazione.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.WindowsRuntime">
      <summary>L'assembly contiene codice Windows Runtime.</summary>
    </member>
    <member name="T:System.Reflection.AssemblyHashAlgorithm">
      <summary>Specifica gli algoritmi hash usati per l'hash dei file di assembly e per generare il nome sicuro.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.MD5">
      <summary>Recupera l'algoritmo del digest del messaggio MD5.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.None">
      <summary>Maschera che indica che non esiste alcun algoritmo hash.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha1">
      <summary>Recupera una revisione dell'algoritmo SHA (Secure Hash Algorithm) che corregga eventuali difetti non pubblicati in SHA.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha256">
      <summary>Recupera una versione di SHA (Secure Hash Algorithm) con una dimensione hash di 256 bit.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha384">
      <summary>Recupera una versione di SHA (Secure Hash Algorithm) con una dimensione hash di 384 bit.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha512">
      <summary>Recupera una versione di SHA (Secure Hash Algorithm) con una dimensione hash di 512 bit.</summary>
    </member>
    <member name="T:System.Reflection.DeclarativeSecurityAction">
      <summary>Specifica le azioni relative alla sicurezza che possono essere eseguite con la sicurezza dichiarativa.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.Assert">
      <summary>Il codice chiamante consente di accedere alla risorsa identificata dall'oggetto autorizzazioni corrente, anche se ai primi chiamanti dello stack non è stata concessa l'autorizzazione per l'accesso alla risorsa.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.Demand">
      <summary>Verificare che a tutti i chiamanti nella catena di chiamate sia stata concessa l'autorizzazione specificata.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.Deny">
      <summary>Senza ulteriori controlli, rifiutare la richiesta di autorizzazione specificata.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.InheritanceDemand">
      <summary>La classe derivata che eredita la classe o che esegue l'override di un metodo deve avere l'autorizzazione specificata.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.LinkDemand">
      <summary>Controllare che al chiamante diretto sia stata concessa l'autorizzazione specificata.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.None">
      <summary>Nessuna azione di sicurezza dichiarativa.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.PermitOnly">
      <summary>Senza ulteriori controlli, rifiutare la richiesta di tutte le autorizzazioni diverse da quelle specificate.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.RequestMinimum">
      <summary>Richiedere le autorizzazioni minime necessarie per l'esecuzione del codice. Questa azione può essere usata solo nell'ambito dell'assembly.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.RequestOptional">
      <summary>Richiedere autorizzazioni aggiuntive facoltative (non necessarie per l'esecuzione). Con questa richiesta viene implicitamente rifiutata ogni altra autorizzazione che non sia stata esplicitamente richiesta. Questa azione può essere usata solo nell'ambito dell'assembly.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.RequestRefuse">
      <summary>Richiedere di impedire che al codice chiamante vengano concesse autorizzazioni utilizzabili in modo improprio. Questa azione può essere usata solo nell'ambito dell'assembly.</summary>
    </member>
    <member name="T:System.Reflection.ManifestResourceAttributes" />
    <member name="F:System.Reflection.ManifestResourceAttributes.Private">
      <summary>La risorsa non viene esportata dall'assembly.</summary>
    </member>
    <member name="F:System.Reflection.ManifestResourceAttributes.Public">
      <summary>La risorsa viene esportata dall'assembly.</summary>
    </member>
    <member name="F:System.Reflection.ManifestResourceAttributes.VisibilityMask">
      <summary>Maschera solo gli attributi correlati alla visibilità.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ArrayShape">
      <summary>Rappresenta la forma di un tipo matrice.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ArrayShape.#ctor(System.Int32,System.Collections.Immutable.ImmutableArray{System.Int32},System.Collections.Immutable.ImmutableArray{System.Int32})">
      <summary>Inizializza una nuova istanza della struttura <see cref="T:System.Reflection.Metadata.ArrayShape" />.</summary>
      <param name="rank">Numero di dimensioni nella matrice.</param>
      <param name="sizes">Valore di ogni dimensione.</param>
      <param name="lowerBounds">Limite inferiore di ogni dimensione.</param>
    </member>
    <member name="P:System.Reflection.Metadata.ArrayShape.LowerBounds">
      <summary>Ottiene il limite inferiore di ogni dimensione. La lunghezza può essere inferiore alla classificazione, nel qual caso i limiti inferiori delle dimensioni finali non sono specificati.</summary>
      <returns>Matrice di limiti inferiori.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ArrayShape.Rank">
      <summary>Ottiene il numero di dimensioni nella matrice.</summary>
      <returns>Numero di dimensioni.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ArrayShape.Sizes">
      <summary>Ottiene i valori di tutte le dimensioni.</summary>
      <returns>Matrice di dimensioni.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyDefinition" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinition.GetAssemblyName" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinition.GetDeclarativeSecurityAttributes" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Culture" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Flags" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.HashAlgorithm" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Name" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.PublicKey" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Version" />
    <member name="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.Equals(System.Reflection.Metadata.AssemblyDefinitionHandle)">
      <summary>Indica se l'oggetto corrente è uguale a un altro oggetto dello stesso tipo.</summary>
      <param name="other">Oggetto da confrontare con l'oggetto corrente.</param>
      <returns>
        <see langword="true" /> se l'oggetto corrente è uguale al parametro <paramref name="other" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Equality(System.Reflection.Metadata.AssemblyDefinitionHandle,System.Reflection.Metadata.AssemblyDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.AssemblyDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.AssemblyDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Implicit(System.Reflection.Metadata.AssemblyDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Implicit(System.Reflection.Metadata.AssemblyDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Inequality(System.Reflection.Metadata.AssemblyDefinitionHandle,System.Reflection.Metadata.AssemblyDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.AssemblyFile" />
    <member name="M:System.Reflection.Metadata.AssemblyFile.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.AssemblyFile.ContainsMetadata">
      <summary>Ottiene un valore che indica se nel file sono presenti metadati.</summary>
      <returns>
        <see langword="true" /> Se il file contiene metadati <see langword="false" /> . in caso contrario,.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFile.HashValue">
      <summary>Ottiene il valore hash del contenuto del file calcolato usando <see cref="P:System.Reflection.Metadata.AssemblyDefinition.HashAlgorithm" />.</summary>
      <returns>
        <see cref="T:System.Reflection.Metadata.BlobHandle" />Istanza di che rappresenta il valore hash del contenuto del file.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFile.Name">
      <summary>Ottiene il nome del file, inclusa l'estensione.</summary>
      <returns>
        <see cref="T:System.Reflection.Metadata.StringHandle" />Istanza di che rappresenta il nome file con l'estensione.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyFileHandle" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.Equals(System.Reflection.Metadata.AssemblyFileHandle)">
      <summary>Indica se l'oggetto corrente è uguale a un altro oggetto dello stesso tipo.</summary>
      <param name="other">Oggetto da confrontare con l'oggetto corrente.</param>
      <returns>
        <see langword="true" /> se l'oggetto corrente è uguale al parametro <paramref name="other" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Equality(System.Reflection.Metadata.AssemblyFileHandle,System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.AssemblyFileHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.AssemblyFileHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Implicit(System.Reflection.Metadata.AssemblyFileHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Implicit(System.Reflection.Metadata.AssemblyFileHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Inequality(System.Reflection.Metadata.AssemblyFileHandle,System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFileHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.AssemblyFileHandleCollection">
      <summary>Rappresenta una raccolta di oggetti <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#AssemblyFileHandle}#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di scorrere la raccolta.</summary>
      <returns>Enumeratore che può essere usato per scorrere la raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di eseguire l'iterazione di una raccolta.</summary>
      <returns>Oggetto <see cref="T:System.Collections.IEnumerator" /> che può essere usato per eseguire l'iterazione della raccolta.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFileHandleCollection.Count">
      <summary>Ottiene il numero di elementi nella raccolta.</summary>
      <returns>Numero di elementi contenuti nella raccolta.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.MoveNext">
      <summary>Sposta l'enumeratore all'elemento successivo della raccolta.</summary>
      <returns>
        <see langword="true" /> se l'enumeratore è stato spostato correttamente in avanti in corrispondenza dell'elemento successivo, <see langword="false" /> se l'enumeratore ha superato la fine della raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Imposta l'enumeratore sulla propria posizione iniziale, ovvero prima del primo elemento nella raccolta.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Esegue attività definite dall'applicazione, come rilasciare o reimpostare risorse non gestite.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyReference" />
    <member name="M:System.Reflection.Metadata.AssemblyReference.GetAssemblyName" />
    <member name="M:System.Reflection.Metadata.AssemblyReference.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Culture" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Flags" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.HashValue" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Name" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.PublicKeyOrToken" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Version" />
    <member name="T:System.Reflection.Metadata.AssemblyReferenceHandle" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.Equals(System.Reflection.Metadata.AssemblyReferenceHandle)">
      <summary>Indica se l'oggetto corrente è uguale a un altro oggetto dello stesso tipo.</summary>
      <param name="other">Oggetto da confrontare con l'oggetto corrente.</param>
      <returns>
        <see langword="true" /> se l'oggetto corrente è uguale al parametro <paramref name="other" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Equality(System.Reflection.Metadata.AssemblyReferenceHandle,System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.AssemblyReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.AssemblyReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Implicit(System.Reflection.Metadata.AssemblyReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Implicit(System.Reflection.Metadata.AssemblyReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Inequality(System.Reflection.Metadata.AssemblyReferenceHandle,System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.AssemblyReferenceHandleCollection">
      <summary>Raccolta di riferimenti ad assembly.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#AssemblyReferenceHandle}#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di scorrere la raccolta.</summary>
      <returns>Enumeratore che può essere usato per scorrere la raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di eseguire l'iterazione di una raccolta.</summary>
      <returns>Oggetto <see cref="T:System.Collections.IEnumerator" /> che può essere usato per eseguire l'iterazione della raccolta.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Count">
      <summary>Ottiene il numero di elementi nella raccolta.</summary>
      <returns>Numero di elementi contenuti nella raccolta.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.MoveNext">
      <summary>Sposta l'enumeratore all'elemento successivo della raccolta.</summary>
      <returns>
        <see langword="true" /> se l'enumeratore è stato spostato correttamente in avanti in corrispondenza dell'elemento successivo, <see langword="false" /> se l'enumeratore ha superato la fine della raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Imposta l'enumeratore sulla propria posizione iniziale, ovvero prima del primo elemento nella raccolta.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Esegue attività definite dall'applicazione, come rilasciare o reimpostare risorse non gestite.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Blob" />
    <member name="M:System.Reflection.Metadata.Blob.GetBytes" />
    <member name="P:System.Reflection.Metadata.Blob.IsDefault" />
    <member name="P:System.Reflection.Metadata.Blob.Length" />
    <member name="T:System.Reflection.Metadata.BlobBuilder" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.#ctor(System.Int32)">
      <param name="capacity" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Align(System.Int32)">
      <param name="alignment" />
      <exception cref="T:System.InvalidOperationException">Non è possibile scrivere nel generatore perché è stato collegato con un altro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.AllocateChunk(System.Int32)">
      <param name="minimalSize" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Clear" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.ContentEquals(System.Reflection.Metadata.BlobBuilder)">
      <summary>Confronta il contenuto corrente di questo writer con un altro.</summary>
      <param name="other">Istanza di <see cref="T:System.Reflection.Metadata.BlobBuilder" /> da confrontare con questa.</param>
      <exception cref="T:System.InvalidOperationException">Il contenuto non è disponibile perché il generatore è stato collegato con un altro.</exception>
      <returns>
        <see langword="true" /> se è uguale; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Free" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.FreeChunk" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.GetBlobs">
      <summary>Restituisce una sequenza di tutti i BLOB che rappresentano il contenuto del generatore.</summary>
      <exception cref="T:System.InvalidOperationException">Il contenuto non è disponibile perché il generatore è stato collegato con un altro.</exception>
      <returns>Sequenza di BLOB.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.LinkPrefix(System.Reflection.Metadata.BlobBuilder)">
      <param name="prefix" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="prefix" /> è <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Non è possibile scrivere nel generatore perché è stato collegato con un altro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.LinkSuffix(System.Reflection.Metadata.BlobBuilder)">
      <param name="suffix" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="suffix" /> è <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Non è possibile scrivere nel generatore perché è stato collegato con un altro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.PadTo(System.Int32)">
      <param name="position" />
      <exception cref="T:System.InvalidOperationException">Non è possibile scrivere nel generatore perché è stato collegato con un altro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ReserveBytes(System.Int32)">
      <summary>Riserva un blocco contiguo di byte.</summary>
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> è negativo.</exception>
      <exception cref="T:System.InvalidOperationException">Non è possibile scrivere nel generatore perché è stato collegato con un altro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToArray">
      <exception cref="T:System.InvalidOperationException">Il contenuto non è disponibile perché il generatore è stato collegato con un altro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToArray(System.Int32,System.Int32)">
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">L'intervallo specificato da <paramref name="start" /> e <paramref name="byteCount" /> non rientra nei limiti del contenuto del buffer.</exception>
      <exception cref="T:System.InvalidOperationException">Il contenuto non è disponibile perché il generatore è stato collegato con un altro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToImmutableArray">
      <exception cref="T:System.InvalidOperationException">Il contenuto non è disponibile perché il generatore è stato collegato con un altro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToImmutableArray(System.Int32,System.Int32)">
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">L'intervallo specificato da <paramref name="start" /> e <paramref name="byteCount" /> non rientra nei limiti del contenuto del buffer.</exception>
      <exception cref="T:System.InvalidOperationException">Il contenuto non è disponibile perché il generatore è stato collegato con un altro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.TryWriteBytes(System.IO.Stream,System.Int32)">
      <summary>Prova a scrivere una sequenza di byte nel generatore. Un valore restituito indica il numero di byte scritti correttamente.</summary>
      <param name="source" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> è negativo.</exception>
      <exception cref="T:System.InvalidOperationException">Non è possibile scrivere nel generatore perché è stato collegato con un altro.</exception>
      <returns>Numero di byte scritti correttamente da <paramref name="source" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBoolean(System.Boolean)">
      <summary>Scrive un valore <see cref="T:System.Boolean" /> nel generatore.</summary>
      <param name="value">Valore da scrivere.</param>
      <exception cref="T:System.InvalidOperationException">Non è possibile scrivere nel generatore perché è stato collegato con un altro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteByte(System.Byte)">
      <summary>Scrive un valore <see cref="T:System.Byte" /> nel generatore.</summary>
      <param name="value">Valore da scrivere.</param>
      <exception cref="T:System.InvalidOperationException">Non è possibile scrivere nel generatore perché è stato collegato con un altro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte*,System.Int32)">
      <summary>Scrive un numero specificato di byte da un buffer al generatore.</summary>
      <param name="buffer" />
      <param name="byteCount">Numero di byte da scrivere.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> è negativo.</exception>
      <exception cref="T:System.InvalidOperationException">Non è possibile scrivere nel generatore perché è stato collegato con un altro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte,System.Int32)">
      <summary>Scrive un numero specificato di occorrenze di un valore di byte nel generatore.</summary>
      <param name="value" />
      <param name="byteCount">Numero di occorrenze di <paramref name="value" /> da scrivere.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> è negativo.</exception>
      <exception cref="T:System.InvalidOperationException">Non è possibile scrivere nel generatore perché è stato collegato con un altro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte[])">
      <summary>Scrive il contenuto di una matrice di byte nel generatore.</summary>
      <param name="buffer">Matrice di byte da scrivere.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> è <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Non è possibile scrivere nel generatore perché è stato collegato con un altro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte[],System.Int32,System.Int32)">
      <summary>Scrive un numero specificato di byte nel generatore a partire dall'indice specificato in una matrice di byte.</summary>
      <param name="buffer" />
      <param name="start" />
      <param name="byteCount">Numero di byte da scrivere.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">L'intervallo specificato da <paramref name="start" /> e <paramref name="byteCount" /> non rientra nei limiti di <paramref name="buffer" />.</exception>
      <exception cref="T:System.InvalidOperationException">Non è possibile scrivere nel generatore perché è stato collegato con un altro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>Scrive il contenuto di una matrice di byte non modificabile nel generatore.</summary>
      <param name="buffer">Matrice da inserire.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> è <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Non è possibile scrivere nel generatore perché è stato collegato con un altro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte},System.Int32,System.Int32)">
      <summary>Scrive un numero specificato di byte nel generatore a partire dall'indice specificato di una matrice non modificabile.</summary>
      <param name="buffer" />
      <param name="start" />
      <param name="byteCount">Numero di byte da scrivere.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">L'intervallo specificato da <paramref name="start" /> e <paramref name="byteCount" /> non rientra nei limiti del <paramref name="buffer" />.</exception>
      <exception cref="T:System.InvalidOperationException">Non è possibile scrivere nel generatore perché è stato collegato con un altro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteCompressedInteger(System.Int32)">
      <summary>Implementa la codifica di Unsigned Integer compressi come definito da ECMA-335-II capitolo 23,2: BLOB e firme.</summary>
      <param name="value">Valore da scrivere.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="value" /> non può essere rappresentato come Unsigned Integer compresso.</exception>
      <exception cref="T:System.InvalidOperationException">Non è possibile scrivere nel generatore perché è stato collegato con un altro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteCompressedSignedInteger(System.Int32)">
      <summary>Implementa la codifica di interi con segno compresso come definito da ECMA-335-II capitolo 23,2: BLOB e firme.</summary>
      <param name="value">Valore da scrivere.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="value" /> non può essere rappresentato come Signed Integer compresso.</exception>
      <exception cref="T:System.InvalidOperationException">Non è possibile scrivere nel generatore perché è stato collegato con un altro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteConstant(System.Object)">
      <summary>Scrive un valore costante (vedere la sezione 22.9 della partizione II di ECMA-335) nella posizione corrente.</summary>
      <param name="value">Valore costante da scrivere.</param>
      <exception cref="T:System.ArgumentException">Il tipo di <paramref name="value" /> non è costante.</exception>
      <exception cref="T:System.InvalidOperationException">Non è possibile scrivere nel generatore perché è stato collegato con un altro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteContentTo(System.IO.Stream)">
      <param name="destination" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="destination" /> è <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Il contenuto non è disponibile perché il generatore è stato collegato con un altro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteContentTo(System.Reflection.Metadata.BlobBuilder)">
      <param name="destination" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="destination" /> è <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Il contenuto non è disponibile perché il generatore è stato collegato con un altro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteContentTo(System.Reflection.Metadata.BlobWriter@)">
      <param name="destination" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="destination" /> è l'impostazione predefinita (<see cref="T:System.Reflection.Metadata.BlobWriter" />).</exception>
      <exception cref="T:System.InvalidOperationException">Il contenuto non è disponibile perché il generatore è stato collegato con un altro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteDateTime(System.DateTime)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Non è possibile scrivere nel generatore perché è stato collegato con un altro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteDecimal(System.Decimal)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Non è possibile scrivere nel generatore perché è stato collegato con un altro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteDouble(System.Double)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Non è possibile scrivere nel generatore perché è stato collegato con un altro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteGuid(System.Guid)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Non è possibile scrivere nel generatore perché è stato collegato con un altro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt16(System.Int16)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Non è possibile scrivere nel generatore perché è stato collegato con un altro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt16BE(System.Int16)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Non è possibile scrivere nel generatore perché è stato collegato con un altro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt32(System.Int32)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Non è possibile scrivere nel generatore perché è stato collegato con un altro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt32BE(System.Int32)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Non è possibile scrivere nel generatore perché è stato collegato con un altro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt64(System.Int64)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Non è possibile scrivere nel generatore perché è stato collegato con un altro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteReference(System.Int32,System.Boolean)">
      <summary>Scrive un riferimento a un heap (offset dell'heap) o a una tabella (numero di righe).</summary>
      <param name="reference">Offset di heap o numero di righe di tabella.</param>
      <param name="isSmall">
        <see langword="true" /> per codificare il riferimento come Integer a 16 bit, <see langword="false" /> per codificarlo come Integer a 32 bit.</param>
      <exception cref="T:System.InvalidOperationException">Non è possibile scrivere nel generatore perché è stato collegato con un altro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteSByte(System.SByte)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Non è possibile scrivere nel generatore perché è stato collegato con un altro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteSerializedString(System.String)">
      <summary>Scrive una stringa in formato SerString (vedere la sezione relativa agli attributi personalizzati in ECMA-335-II 23.3).</summary>
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Non è possibile scrivere nel generatore perché è stato collegato con un altro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteSingle(System.Single)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Non è possibile scrivere nel generatore perché è stato collegato con un altro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt16(System.UInt16)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Non è possibile scrivere nel generatore perché è stato collegato con un altro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt16BE(System.UInt16)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Non è possibile scrivere nel generatore perché è stato collegato con un altro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt32(System.UInt32)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Non è possibile scrivere nel generatore perché è stato collegato con un altro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt32BE(System.UInt32)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Non è possibile scrivere nel generatore perché è stato collegato con un altro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt64(System.UInt64)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Non è possibile scrivere nel generatore perché è stato collegato con un altro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUserString(System.String)">
      <summary>Scrive una stringa in formato heap User String (#US). Vedere la sezione relativa agli heap #US e #Blob in ECMA-335-II 24.2.4.</summary>
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Non è possibile scrivere nel generatore perché è stato collegato con un altro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUTF16(System.Char[])">
      <summary>Scrive una matrice di caratteri con codifica UTF16 (little endian) nella posizione corrente.</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> è <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Non è possibile scrivere nel generatore perché è stato collegato con un altro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUTF16(System.String)">
      <summary>Scrive una stringa con codifica UTF16 (little endian) nella posizione corrente.</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> è <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Non è possibile scrivere nel generatore perché è stato collegato con un altro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUTF8(System.String,System.Boolean)">
      <summary>Scrive una stringa con codifica UTF8 nella posizione corrente.</summary>
      <param name="value">Valore costante.</param>
      <param name="allowUnpairedSurrogates">
        <see langword="true" /> per codificare i surrogati non abbinati specificati. <see langword="false" /> per sostituirli con un carattere U+FFFD.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> è <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Non è possibile scrivere nel generatore perché è stato collegato con un altro.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.BlobBuilder.ChunkCapacity" />
    <member name="P:System.Reflection.Metadata.BlobBuilder.Count" />
    <member name="P:System.Reflection.Metadata.BlobBuilder.FreeBytes" />
    <member name="T:System.Reflection.Metadata.BlobBuilder.Blobs" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.MoveNext">
      <summary>Sposta l'enumeratore all'elemento successivo della raccolta.</summary>
      <returns>
        <see langword="true" /> se l'enumeratore è stato spostato correttamente in avanti in corrispondenza dell'elemento successivo, <see langword="false" /> se l'enumeratore ha superato la fine della raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.Reset">
      <summary>Imposta l'enumeratore sulla propria posizione iniziale, ovvero prima del primo elemento nella raccolta.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#Blob}#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di scorrere la raccolta.</summary>
      <returns>Enumeratore che può essere usato per scorrere la raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.System#Collections#IEnumerable#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di eseguire l'iterazione di una raccolta.</summary>
      <returns>Oggetto <see cref="T:System.Collections.IEnumerator" /> che può essere usato per eseguire l'iterazione della raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.System#IDisposable#Dispose">
      <summary>Esegue attività definite dall'applicazione, come rilasciare o reimpostare risorse non gestite.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.BlobBuilder.Blobs.Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.BlobBuilder.Blobs.System#Collections#IEnumerator#Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.BlobContentId" />
    <member name="M:System.Reflection.Metadata.BlobContentId.#ctor(System.Byte[])">
      <param name="id" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.#ctor(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="id" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.#ctor(System.Guid,System.UInt32)">
      <param name="guid" />
      <param name="stamp" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.Equals(System.Reflection.Metadata.BlobContentId)">
      <summary>Indica se l'oggetto corrente è uguale a un altro oggetto dello stesso tipo.</summary>
      <param name="other">Oggetto da confrontare con l'oggetto corrente.</param>
      <returns>
        <see langword="true" /> se l'oggetto corrente è uguale al parametro <paramref name="other" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.FromHash(System.Byte[])">
      <param name="hashCode" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.FromHash(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="hashCode" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.GetHashCode" />
    <member name="M:System.Reflection.Metadata.BlobContentId.GetTimeBasedProvider" />
    <member name="M:System.Reflection.Metadata.BlobContentId.op_Equality(System.Reflection.Metadata.BlobContentId,System.Reflection.Metadata.BlobContentId)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.op_Inequality(System.Reflection.Metadata.BlobContentId,System.Reflection.Metadata.BlobContentId)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.BlobContentId.Guid" />
    <member name="P:System.Reflection.Metadata.BlobContentId.IsDefault" />
    <member name="P:System.Reflection.Metadata.BlobContentId.Stamp" />
    <member name="T:System.Reflection.Metadata.BlobHandle" />
    <member name="M:System.Reflection.Metadata.BlobHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.Equals(System.Reflection.Metadata.BlobHandle)">
      <summary>Indica se l'oggetto corrente è uguale a un altro oggetto dello stesso tipo.</summary>
      <param name="other">Oggetto da confrontare con l'oggetto corrente.</param>
      <returns>
        <see langword="true" /> se l'oggetto corrente è uguale al parametro <paramref name="other" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Equality(System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.BlobHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.BlobHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Implicit(System.Reflection.Metadata.BlobHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Inequality(System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.BlobHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.BlobHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.BlobReader" />
    <member name="M:System.Reflection.Metadata.BlobReader.#ctor(System.Byte*,System.Int32)">
      <summary>Crea un lettore del blocco di memoria specificato.</summary>
      <param name="buffer">Puntatore all'inizio del blocco di memoria.</param>
      <param name="length">Lunghezza in byte del blocco di memoria.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> è <see langword="null" /> e <paramref name="length" /> è maggiore di zero.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" /> è negativo.</exception>
      <exception cref="T:System.PlatformNotSupportedException">La piattaforma corrente non è little endian.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.Align(System.Byte)">
      <summary>Riposiziona il lettore in avanti di tanti byte quanti sono necessari per soddisfare l'allineamento specificato.</summary>
      <param name="alignment" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.IndexOf(System.Byte)">
      <summary>Cerca un byte specificato nel BLOB che segue la posizione corrente.</summary>
      <param name="value">Valore di byte da trovare.</param>
      <returns>Indice relativo alla posizione corrente oppure -1 se il byte non viene trovato nel BLOB che segue la posizione corrente.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBlobHandle">
      <summary>Legge un handle heap del BLOB codificato come Integer compresso.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBoolean" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadByte" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBytes(System.Int32)">
      <summary>Legge i byte a partire dalla posizione corrente.</summary>
      <param name="byteCount">Numero di byte da leggere.</param>
      <exception cref="T:System.BadImageFormatException">Byte <paramref name="byteCount" /> non disponibili.</exception>
      <returns>Matrice di byte.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBytes(System.Int32,System.Byte[],System.Int32)">
      <summary>Legge i byte a partire dalla posizione corrente e li scrive nel buffer specificato a partire dall'offset specificato.</summary>
      <param name="byteCount">Numero di byte da leggere.</param>
      <param name="buffer">Buffer di destinazione in cui verranno scritti i byte letti.</param>
      <param name="bufferOffset">Offset nel buffer di destinazione in cui verranno scritti i byte letti.</param>
      <exception cref="T:System.BadImageFormatException">Byte <paramref name="byteCount" /> non disponibili.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadChar" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadCompressedInteger">
      <summary>Legge un valore Unsigned Integer compresso. Vedere la sezione relativa alle specifiche dei metadati sezione II. 23,2: BLOB e firme.</summary>
      <exception cref="T:System.BadImageFormatException">I dati nella posizione corrente non erano un Integer compresso valido.</exception>
      <returns>Valore dell'Integer compresso che è stato letto.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadCompressedSignedInteger">
      <summary>Legge un valore Signed Integer compresso. Vedere la sezione relativa alle specifiche dei metadati sezione II. 23,2: BLOB e firme.</summary>
      <exception cref="T:System.BadImageFormatException">I dati nella posizione corrente non erano un Integer compresso valido.</exception>
      <returns>Valore dell'Integer compresso che è stato letto.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadConstant(System.Reflection.Metadata.ConstantTypeCode)">
      <summary>Legge un valore costante (vedere la sezione 22.9 della partizione II di ECMA-335) dalla posizione corrente.</summary>
      <param name="typeCode" />
      <exception cref="T:System.BadImageFormatException">Errore durante la lettura dal BLOB.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="typeCode" /> non è un oggetto <see cref="T:System.Reflection.Metadata.ConstantTypeCode" /> valido.</exception>
      <returns>Valore boxed costante. Per evitare di allocare l'oggetto, usare direttamente i metodi Read*.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadDateTime" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadDecimal">
      <summary>Legge un numero <see cref="T:System.Decimal" />.</summary>
      <exception cref="T:System.BadImageFormatException">I dati nella posizione corrente non erano un numero <see cref="T:System.Decimal" /> valido.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadDouble" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadGuid" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadInt16" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadInt32" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadInt64" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSByte" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSerializationTypeCode">
      <summary>Legge un codice di tipo codificato in un valore di attributo personalizzato serializzato.</summary>
      <returns>
        <see cref="F:System.Reflection.Metadata.SerializationTypeCode.Invalid" /> se la codifica non è valida.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSerializedString">
      <summary>Legge una stringa codificata come Integer compresso contenente la lunghezza seguita dal contenuto in UTF8. Le stringhe Null vengono codificate come byte 0xFF singolo.</summary>
      <exception cref="T:System.BadImageFormatException">La codifica non è valida.</exception>
      <returns>Valore di stringa oppure <see langword="null" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSignatureHeader" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSignatureTypeCode">
      <summary>Legge un codice di tipo codificato in una firma.</summary>
      <returns>Codice del tipo nel valore dell'attributo personalizzato serializzato se la codifica è valida oppure <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Invalid" /> se la codifica non è valida.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSingle" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadTypeHandle">
      <summary>Legge un handle di tipo codificato in una firma come TypeDefOrRefOrSpecEncoded (ECMA-335 II.23.2.8).</summary>
      <returns>L'handle quando la codifica è valida. In caso contrario, un handle in cui la proprietà <see cref="P:System.Reflection.Metadata.EntityHandle.IsNil" /> è <see langword="true" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUInt16" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUInt32" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUInt64" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUTF16(System.Int32)">
      <summary>Legge una stringa con codifica UTF16 (little endian) a partire dalla posizione corrente.</summary>
      <param name="byteCount">Numero di byte da leggere.</param>
      <exception cref="T:System.BadImageFormatException">Byte <paramref name="byteCount" /> non disponibili.</exception>
      <returns>Stringa.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUTF8(System.Int32)">
      <summary>Legge una stringa con codifica UTF8 a partire dalla posizione corrente.</summary>
      <param name="byteCount">Numero di byte da leggere.</param>
      <exception cref="T:System.BadImageFormatException">Byte <paramref name="byteCount" /> non disponibili.</exception>
      <returns>Stringa.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.Reset">
      <summary>Riposiziona il lettore all'inizio del blocco di memoria sottostante.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.TryReadCompressedInteger(System.Int32@)">
      <summary>Legge un valore Unsigned Integer compresso. Vedere la sezione relativa alle specifiche dei metadati sezione II. 23,2: BLOB e firme.</summary>
      <param name="value">Valore dell'Integer compresso che è stato letto.</param>
      <returns>
        <see langword="true" /> se il valore è stato letto correttamente. <see langword="false" /> se i dati nella posizione corrente non erano un Integer compresso valido.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.TryReadCompressedSignedInteger(System.Int32@)">
      <summary>Legge un valore Signed Integer compresso. Vedere la sezione relativa alle specifiche dei metadati sezione II. 23,2: BLOB e firme.</summary>
      <param name="value">Valore dell'Integer compresso che è stato letto.</param>
      <returns>
        <see langword="true" /> se il valore è stato letto correttamente. <see langword="false" /> se i dati nella posizione corrente non erano un Integer compresso valido.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.CurrentPointer">
      <summary>Ottiene un puntatore al byte in corrispondenza della posizione corrente del lettore.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.Length">
      <summary>Ottiene la lunghezza totale del blocco di memoria sottostante.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.Offset">
      <summary>Ottiene o imposta l'offset dall'inizio del BLOB alla posizione corrente.</summary>
      <exception cref="T:System.BadImageFormatException">L'offset viene impostato al di fuori dei limiti del lettore sottostante.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.RemainingBytes">
      <summary>Ottiene il numero di byte rimanenti dalla posizione corrente alla fine del blocco di memoria sottostante.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.StartPointer">
      <summary>Ottiene un puntatore al byte all'inizio del blocco di memoria sottostante.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.BlobWriter" />
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Byte[])">
      <param name="buffer" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Byte[],System.Int32,System.Int32)">
      <param name="buffer" />
      <param name="start" />
      <param name="count" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Int32)">
      <param name="size" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Reflection.Metadata.Blob)">
      <param name="blob" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.Align(System.Int32)">
      <param name="alignment" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.Clear" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ContentEquals(System.Reflection.Metadata.BlobWriter)">
      <summary>Confronta il contenuto corrente di questo writer con un altro.</summary>
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.PadTo(System.Int32)">
      <param name="offset" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.ToArray" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ToArray(System.Int32,System.Int32)">
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">L'intervallo specificato da <paramref name="start" /> e <paramref name="byteCount" /> non rientra nei limiti del contenuto del buffer.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.ToImmutableArray" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ToImmutableArray(System.Int32,System.Int32)">
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">L'intervallo specificato da <paramref name="start" /> e <paramref name="byteCount" /> non rientra nei limiti del contenuto del buffer.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBoolean(System.Boolean)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteByte(System.Byte)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte*,System.Int32)">
      <param name="buffer" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> è negativo.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte,System.Int32)">
      <param name="value" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> è negativo.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte[])">
      <param name="buffer" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> è <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte[],System.Int32,System.Int32)">
      <param name="buffer" />
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">L'intervallo specificato da <paramref name="start" /> e <paramref name="byteCount" /> non rientra nei limiti del <paramref name="buffer" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="buffer" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> è <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte},System.Int32,System.Int32)">
      <param name="buffer" />
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">L'intervallo specificato da <paramref name="start" /> e <paramref name="byteCount" /> non rientra nei limiti del <paramref name="buffer" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.IO.Stream,System.Int32)">
      <param name="source" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> è negativo.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Reflection.Metadata.BlobBuilder)">
      <param name="source" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> è <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteCompressedInteger(System.Int32)">
      <summary>Implementa la codifica di Unsigned Integer compressi come definito da ECMA-335-II capitolo 23,2: BLOB e firme.</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="value" /> non può essere rappresentato come Unsigned Integer compresso.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteCompressedSignedInteger(System.Int32)">
      <summary>Implementa la codifica di interi con segno compresso come definito da ECMA-335-II capitolo 23,2: BLOB e firme.</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="value" /> non può essere rappresentato come Signed Integer compresso.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteConstant(System.Object)">
      <summary>Scrive un valore costante (vedere la sezione 22.9 della partizione II di ECMA-335) nella posizione corrente.</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentException">Il tipo di <paramref name="value" /> non è costante.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteDateTime(System.DateTime)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteDecimal(System.Decimal)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteDouble(System.Double)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteGuid(System.Guid)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt16(System.Int16)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt16BE(System.Int16)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt32(System.Int32)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt32BE(System.Int32)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt64(System.Int64)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteReference(System.Int32,System.Boolean)">
      <summary>Scrive un riferimento a un heap (offset dell'heap) o a una tabella (numero di righe).</summary>
      <param name="reference">Offset di heap o numero di righe di tabella.</param>
      <param name="isSmall">
        <see langword="true" /> per codificare il riferimento come Integer a 16 bit, <see langword="false" /> per codificarlo come Integer a 32 bit.</param>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteSByte(System.SByte)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteSerializedString(System.String)">
      <summary>Scrive una stringa in formato SerString (vedere la sezione relativa agli attributi personalizzati in ECMA-335-II 23.3).</summary>
      <param name="str" />
      <exception cref="T:System.InvalidOperationException">Non è possibile scrivere nel generatore perché è stato collegato con un altro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteSingle(System.Single)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt16(System.UInt16)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt16BE(System.UInt16)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt32(System.UInt32)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt32BE(System.UInt32)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt64(System.UInt64)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUserString(System.String)">
      <summary>Scrive una stringa in formato heap User String (#US). Vedere la sezione relativa agli heap #US e #Blob in ECMA-335-II 24.2.4.</summary>
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Non è possibile scrivere nel generatore perché è stato collegato con un altro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUTF16(System.Char[])">
      <summary>Scrive una stringa con codifica UTF16 (little endian) nella posizione corrente.</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> è <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUTF16(System.String)">
      <summary>Scrive una stringa con codifica UTF16 (little endian) nella posizione corrente.</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> è <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUTF8(System.String,System.Boolean)">
      <summary>Scrive una stringa con codifica UTF8 nella posizione corrente.</summary>
      <param name="value" />
      <param name="allowUnpairedSurrogates" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> è <see langword="null" />.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.BlobWriter.Blob" />
    <member name="P:System.Reflection.Metadata.BlobWriter.Length" />
    <member name="P:System.Reflection.Metadata.BlobWriter.Offset" />
    <member name="P:System.Reflection.Metadata.BlobWriter.RemainingBytes" />
    <member name="T:System.Reflection.Metadata.Constant" />
    <member name="P:System.Reflection.Metadata.Constant.Parent">
      <summary>Ottiene l'handle padre (<see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />o <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />).</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Constant.TypeCode">
      <summary>Ottiene un codice di tipo che identifica il tipo del valore costante.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Constant.Value">
      <summary>Ottiene il valore della costante.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ConstantHandle" />
    <member name="M:System.Reflection.Metadata.ConstantHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.Equals(System.Reflection.Metadata.ConstantHandle)">
      <summary>Indica se l'oggetto corrente è uguale a un altro oggetto dello stesso tipo.</summary>
      <param name="other">Oggetto da confrontare con l'oggetto corrente.</param>
      <returns>
        <see langword="true" /> se l'oggetto corrente è uguale al parametro <paramref name="other" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Equality(System.Reflection.Metadata.ConstantHandle,System.Reflection.Metadata.ConstantHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ConstantHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ConstantHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Implicit(System.Reflection.Metadata.ConstantHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Implicit(System.Reflection.Metadata.ConstantHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Inequality(System.Reflection.Metadata.ConstantHandle,System.Reflection.Metadata.ConstantHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.ConstantHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ConstantTypeCode">
      <summary>Specifica valori che rappresentano tipi di costanti di metadati.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Boolean">
      <summary>Tipo Boolean.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Byte">
      <summary>Intero senza segno a 1 byte.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Char">
      <summary>Tipo carattere.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Double">
      <summary>Tipo a virgola mobile a 8 byte.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Int16">
      <summary>Tipo intero con segno a 2 byte.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Int32">
      <summary>Tipo intero con segno a 4 byte.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Int64">
      <summary>Tipo intero con segno a 8 byte.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Invalid">
      <summary>Tipo non valido.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.NullReference">
      <summary>Riferimento null.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.SByte">
      <summary>Tipo intero con segno a 1 byte.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Single">
      <summary>Tipo a virgola mobile a 4 byte.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.String">
      <summary>Tipo <see cref="T:System.String" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.UInt16">
      <summary>Tipo intero senza segno a 2 byte.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.UInt32">
      <summary>Tipo intero senza segno a 4 byte.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.UInt64">
      <summary>Tipo intero senza segno a 8 byte.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttribute" />
    <member name="M:System.Reflection.Metadata.CustomAttribute.DecodeValue``1(System.Reflection.Metadata.ICustomAttributeTypeProvider{``0})">
      <summary>Decodifica gli argomenti codificati nel BLOB del valore.</summary>
      <param name="provider" />
      <typeparam name="TType" />
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttribute.Constructor">
      <summary>Ottiene il costruttore (<see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> o <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />) del tipo di attributo personalizzato.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttribute.Parent">
      <summary>Ottiene l'handle dell'entità di metadati a cui è applicato l'attributo.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttribute.Value">
      <summary>Ottiene il valore dell'attributo.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeHandle" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.Equals(System.Reflection.Metadata.CustomAttributeHandle)">
      <summary>Indica se l'oggetto corrente è uguale a un altro oggetto dello stesso tipo.</summary>
      <param name="other">Oggetto da confrontare con l'oggetto corrente.</param>
      <returns>
        <see langword="true" /> se l'oggetto corrente è uguale al parametro <paramref name="other" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Equality(System.Reflection.Metadata.CustomAttributeHandle,System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.CustomAttributeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.CustomAttributeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Implicit(System.Reflection.Metadata.CustomAttributeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Implicit(System.Reflection.Metadata.CustomAttributeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Inequality(System.Reflection.Metadata.CustomAttributeHandle,System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.CustomAttributeHandleCollection" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#CustomAttributeHandle}#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di scorrere la raccolta.</summary>
      <returns>Enumeratore che può essere usato per scorrere la raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di eseguire l'iterazione di una raccolta.</summary>
      <returns>Oggetto <see cref="T:System.Collections.IEnumerator" /> che può essere usato per eseguire l'iterazione della raccolta.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeHandleCollection.Count">
      <summary>Ottiene il numero di elementi nella raccolta.</summary>
      <returns>Numero di elementi contenuti nella raccolta.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.MoveNext">
      <summary>Sposta l'enumeratore all'elemento successivo della raccolta.</summary>
      <returns>
        <see langword="true" /> se l'enumeratore è stato spostato correttamente in avanti in corrispondenza dell'elemento successivo, <see langword="false" /> se l'enumeratore ha superato la fine della raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Imposta l'enumeratore sulla propria posizione iniziale, ovvero prima del primo elemento nella raccolta.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Esegue attività definite dall'applicazione, come rilasciare o reimpostare risorse non gestite.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeNamedArgument`1">
      <summary>Rappresenta un argomento con nome decodificato da una firma di attributo personalizzato.</summary>
      <typeparam name="TType">Tipo utilizzato per rappresentare i tipi di valori decodificati dalla firma dell'attributo personalizzato.</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeNamedArgument`1.#ctor(System.String,System.Reflection.Metadata.CustomAttributeNamedArgumentKind,`0,System.Object)">
      <summary>Inizializza una nuova istanza della struttura <see cref="T:System.Reflection.Metadata.CustomAttributeNamedArgument`1" /> con il nome, la tipologia, il tipo e il valore specificati.</summary>
      <param name="name">Il nome dell’argomento.</param>
      <param name="kind">Tipologia dell'argomento.</param>
      <param name="type">Il tipo di argomento.</param>
      <param name="value">Valore dell'argomento.</param>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Kind">
      <summary>Ottiene la tipologia dell'argomento.</summary>
      <returns>Tipo di argomento.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Name">
      <summary>Ottiene il nome dell'argomento.</summary>
      <returns>Nome dell'argomento.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Type">
      <summary>Ottiene il tipo dell'argomento.</summary>
      <returns>Tipo dell'argomento.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Value">
      <summary>Ottiene il valore dell'argomento.</summary>
      <returns>Oggetto contenente il valore dell'argomento.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeNamedArgumentKind">
      <summary>Specifica costanti che definiscono le tipologie degli argomenti in una firma dell'attributo personalizzato.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.CustomAttributeNamedArgumentKind.Field">
      <summary>Argomento campo.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.CustomAttributeNamedArgumentKind.Property">
      <summary>Argomento proprietà.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeTypedArgument`1">
      <summary>Rappresenta un argomento tipizzato per un attributo di metadati personalizzato.</summary>
      <typeparam name="TType">Il tipo di argomento.</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeTypedArgument`1.#ctor(`0,System.Object)">
      <summary>Inizializza una nuova istanza della struttura <see cref="T:System.Reflection.Metadata.CustomAttributeTypedArgument`1" /> con il tipo e il valore dell'argomento specificato.</summary>
      <param name="type">Il tipo di argomento.</param>
      <param name="value">Valore dell'argomento.</param>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeTypedArgument`1.Type">
      <summary>Ottiene il tipo dell'argomento.</summary>
      <returns>Tipo dell'argomento.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeTypedArgument`1.Value">
      <summary>Ottiene il valore dell'argomento.</summary>
      <returns>Valore dell'argomento.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeValue`1">
      <summary>Rappresenta un attributo personalizzato del tipo specificato da <paramref name="TType" />.</summary>
      <typeparam name="TType">Tipo di attributo.</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeValue`1.#ctor(System.Collections.Immutable.ImmutableArray{System.Reflection.Metadata.CustomAttributeTypedArgument{`0}},System.Collections.Immutable.ImmutableArray{System.Reflection.Metadata.CustomAttributeNamedArgument{`0}})">
      <summary>Inizializza una nuova istanza della struttura <see cref="T:System.Reflection.Metadata.CustomAttributeValue`1" /> usando gli argomenti fissi e gli argomenti denominati specificati.</summary>
      <param name="fixedArguments">Argomenti fissi.</param>
      <param name="namedArguments">Argomenti denominati.</param>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeValue`1.FixedArguments">
      <summary>Ottiene gli argomenti fissi per l'attributo personalizzato.</summary>
      <returns>Matrice non modificabile di argomenti.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeValue`1.NamedArguments">
      <summary>Ottiene gli argomenti denominati per il valore dell'attributo personalizzato.</summary>
      <returns>Matrice non modificabile di argomenti.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomDebugInformation" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformation.Kind" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformation.Parent" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformation.Value" />
    <member name="T:System.Reflection.Metadata.CustomDebugInformationHandle" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.Equals(System.Reflection.Metadata.CustomDebugInformationHandle)">
      <summary>Indica se l'oggetto corrente è uguale a un altro oggetto dello stesso tipo.</summary>
      <param name="other">Oggetto da confrontare con l'oggetto corrente.</param>
      <returns>
        <see langword="true" /> se l'oggetto corrente è uguale al parametro <paramref name="other" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Equality(System.Reflection.Metadata.CustomDebugInformationHandle,System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.CustomDebugInformationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.CustomDebugInformationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Implicit(System.Reflection.Metadata.CustomDebugInformationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Implicit(System.Reflection.Metadata.CustomDebugInformationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Inequality(System.Reflection.Metadata.CustomDebugInformationHandle,System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.CustomDebugInformationHandleCollection" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#CustomDebugInformationHandle}#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di scorrere la raccolta.</summary>
      <returns>Enumeratore che può essere usato per scorrere la raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di eseguire l'iterazione di una raccolta.</summary>
      <returns>Oggetto <see cref="T:System.Collections.IEnumerator" /> che può essere usato per eseguire l'iterazione della raccolta.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Count">
      <summary>Ottiene il numero di elementi nella raccolta.</summary>
      <returns>Numero di elementi contenuti nella raccolta.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.MoveNext">
      <summary>Sposta l'enumeratore all'elemento successivo della raccolta.</summary>
      <returns>
        <see langword="true" /> se l'enumeratore è stato spostato correttamente in avanti in corrispondenza dell'elemento successivo, <see langword="false" /> se l'enumeratore ha superato la fine della raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Imposta l'enumeratore sulla propria posizione iniziale, ovvero prima del primo elemento nella raccolta.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Esegue attività definite dall'applicazione, come rilasciare o reimpostare risorse non gestite.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.DebugMetadataHeader" />
    <member name="P:System.Reflection.Metadata.DebugMetadataHeader.EntryPoint" />
    <member name="P:System.Reflection.Metadata.DebugMetadataHeader.Id" />
    <member name="P:System.Reflection.Metadata.DebugMetadataHeader.IdStartOffset">
      <summary>Ottiene l'offset, in byte, dall'inizio del BLOB di metadati all'inizio del BLOB <see cref="P:System.Reflection.Metadata.DebugMetadataHeader.Id" />.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttribute" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttribute.Action" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttribute.Parent" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttribute.PermissionSet" />
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.Equals(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <summary>Indica se l'oggetto corrente è uguale a un altro oggetto dello stesso tipo.</summary>
      <param name="other">Oggetto da confrontare con l'oggetto corrente.</param>
      <returns>
        <see langword="true" /> se l'oggetto corrente è uguale al parametro <paramref name="other" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Equality(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle,System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.DeclarativeSecurityAttributeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.DeclarativeSecurityAttributeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Implicit(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Implicit(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Inequality(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle,System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#DeclarativeSecurityAttributeHandle}#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di scorrere la raccolta.</summary>
      <returns>Enumeratore che può essere usato per scorrere la raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di eseguire l'iterazione di una raccolta.</summary>
      <returns>Oggetto <see cref="T:System.Collections.IEnumerator" /> che può essere usato per eseguire l'iterazione della raccolta.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Count">
      <summary>Ottiene il numero di elementi nella raccolta.</summary>
      <returns>Numero di elementi contenuti nella raccolta.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.MoveNext">
      <summary>Sposta l'enumeratore all'elemento successivo della raccolta.</summary>
      <returns>
        <see langword="true" /> se l'enumeratore è stato spostato correttamente in avanti in corrispondenza dell'elemento successivo, <see langword="false" /> se l'enumeratore ha superato la fine della raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Imposta l'enumeratore sulla propria posizione iniziale, ovvero prima del primo elemento nella raccolta.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Esegue attività definite dall'applicazione, come rilasciare o reimpostare risorse non gestite.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Document">
      <summary>Documento di origine nei metadati di debug.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.Hash">
      <summary>Ottiene l'hash del contenuto del documento.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.HashAlgorithm">
      <summary>Ottiene l'algoritmo hash usato per calcolare la proprietà <see cref="P:System.Reflection.Metadata.Document.Hash" /> (SHA1, SHA256 e così via).</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.Language">
      <summary>Ottiene il linguaggio del codice sorgente (C#, VB, F# e così via).</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.Name">
      <summary>Ottiene il BLOB del nome del documento.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.DocumentHandle" />
    <member name="M:System.Reflection.Metadata.DocumentHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.Equals(System.Reflection.Metadata.DocumentHandle)">
      <summary>Indica se l'oggetto corrente è uguale a un altro oggetto dello stesso tipo.</summary>
      <param name="other">Oggetto da confrontare con l'oggetto corrente.</param>
      <returns>
        <see langword="true" /> se l'oggetto corrente è uguale al parametro <paramref name="other" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Equality(System.Reflection.Metadata.DocumentHandle,System.Reflection.Metadata.DocumentHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.DocumentHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.DocumentHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Implicit(System.Reflection.Metadata.DocumentHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Implicit(System.Reflection.Metadata.DocumentHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Inequality(System.Reflection.Metadata.DocumentHandle,System.Reflection.Metadata.DocumentHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.DocumentHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.DocumentHandleCollection" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#DocumentHandle}#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di scorrere la raccolta.</summary>
      <returns>Enumeratore che può essere usato per scorrere la raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di eseguire l'iterazione di una raccolta.</summary>
      <returns>Oggetto <see cref="T:System.Collections.IEnumerator" /> che può essere usato per eseguire l'iterazione della raccolta.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.DocumentHandleCollection.Count">
      <summary>Ottiene il numero di elementi nella raccolta.</summary>
      <returns>Numero di elementi contenuti nella raccolta.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.DocumentHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.MoveNext">
      <summary>Sposta l'enumeratore all'elemento successivo della raccolta.</summary>
      <returns>
        <see langword="true" /> se l'enumeratore è stato spostato correttamente in avanti in corrispondenza dell'elemento successivo, <see langword="false" /> se l'enumeratore ha superato la fine della raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Imposta l'enumeratore sulla propria posizione iniziale, ovvero prima del primo elemento nella raccolta.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Esegue attività definite dall'applicazione, come rilasciare o reimpostare risorse non gestite.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.DocumentNameBlobHandle">
      <summary>
        <see cref="T:System.Reflection.Metadata.BlobHandle" /> che rappresenta un BLOB nell'heap #Blob in un PDB portatile strutturato come nome di documento.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.Equals(System.Reflection.Metadata.DocumentNameBlobHandle)">
      <summary>Indica se l'oggetto corrente è uguale a un altro oggetto dello stesso tipo.</summary>
      <param name="other">Oggetto da confrontare con l'oggetto corrente.</param>
      <returns>
        <see langword="true" /> se l'oggetto corrente è uguale al parametro <paramref name="other" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Equality(System.Reflection.Metadata.DocumentNameBlobHandle,System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Explicit(System.Reflection.Metadata.BlobHandle)~System.Reflection.Metadata.DocumentNameBlobHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Implicit(System.Reflection.Metadata.DocumentNameBlobHandle)~System.Reflection.Metadata.BlobHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Inequality(System.Reflection.Metadata.DocumentNameBlobHandle,System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.DocumentNameBlobHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder.Shape(System.Int32,System.Collections.Immutable.ImmutableArray{System.Int32},System.Collections.Immutable.ImmutableArray{System.Int32})">
      <summary>Codifica la forma della matrice.</summary>
      <param name="rank">Il numero di dimensioni nella matrice (deve essere maggiore o uguale a 1).</param>
      <param name="sizes">Dimensioni delle dimensioni. La matrice può essere più breve di <paramref name="rank" /> ma non più lunga.</param>
      <param name="lowerBounds">Limiti inferiori della dimensione o il valore predefinito (<see cref="T:System.Collections.Immutable.ImmutableArray`1" />) per impostare tutti i limiti inferiori di <paramref name="rank" /> su 0.
La matrice può essere più breve di <paramref name="rank" /> ma non più lunga.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="rank" /> non è compreso nell'intervallo [1, 0xffff], è minore di <see langword="sizes.Length" /> o è minore di <see langword="lowerBounds.Length" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="sizes" /> è <see langword="null" />.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.BlobEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.CustomAttributeSignature(System.Action{System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder},System.Action{System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder})">
      <summary>Codifica il BLOB della firma dell'attributo personalizzato.</summary>
      <param name="fixedArguments">Chiamato per primo, per codificare gli argomenti fissi.</param>
      <param name="namedArguments">Chiamato per secondo, per codificare gli argomenti denominati.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="fixedArguments" /> o <paramref name="namedArguments" /> è <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.CustomAttributeSignature(System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder@,System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder@)">
      <summary>Codifica il BLOB della firma dell'attributo personalizzato.
Restituisce una coppia di codificatori che devono essere usati nell'ordine in cui sono visualizzati nell'elenco dei parametri.</summary>
      <param name="fixedArguments">Usare per primo, per codificare gli argomenti fissi.</param>
      <param name="namedArguments">Usare per secondo, per codificare gli argomenti denominati.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.FieldSignature">
      <summary>Codifica il BLOB della firma del campo.</summary>
      <returns>Codificatore del tipo di campo.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.LocalVariableSignature(System.Int32)">
      <summary>Codifica la firma della variabile locale.</summary>
      <param name="variableCount">Numero di variabili locali.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="variableCount" /> non è compreso nell'intervallo [0, 0x1fffffff].</exception>
      <returns>Codificatore di una sequenza di variabili locali.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.MethodSignature(System.Reflection.Metadata.SignatureCallingConvention,System.Int32,System.Boolean)">
      <summary>Codifica il BLOB della firma del metodo.</summary>
      <param name="convention">Convenzione di chiamata.</param>
      <param name="genericParameterCount">Numero di parametri generici.</param>
      <param name="isInstanceMethod">
        <see langword="true" /> per codificare la firma di un metodo di istanza, <see langword="false" /> per codificare la firma di un metodo statico.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="genericParameterCount" /> non è compreso nell'intervallo [0, 0xffff].</exception>
      <returns>Codificatore del resto della firma, inclusi il valore restituito e i parametri.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.MethodSpecificationSignature(System.Int32)">
      <summary>Codice il BLOB della firma di specifica del metodo.</summary>
      <param name="genericArgumentCount">Numero di argomenti generici.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="genericArgumentCount" /> non è compreso nell'intervallo [0, 0xffff].</exception>
      <returns>Codificatore di argomenti generici.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.PermissionSetArguments(System.Int32)">
      <summary>Codifica gli argomenti del set di autorizzazioni.</summary>
      <param name="argumentCount">Numero di argomenti nel set.</param>
      <returns>Codificatore degli argomenti del set.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.PermissionSetBlob(System.Int32)">
      <summary>Codifica un BLOB del set di autorizzazioni.</summary>
      <param name="attributeCount">Numero di attributi nel set.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="attributeCount" /> non è compreso nell'intervallo [0, 0x1fffffff].</exception>
      <returns>Codificatore del set di autorizzazioni.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.PropertySignature(System.Boolean)">
      <summary>Codifica il BLOB della firma della proprietà.</summary>
      <param name="isInstanceProperty">
        <see langword="true" /> per codificare la firma di una proprietà dell'istanza, <see langword="false" /> per codificare la firma di una proprietà statica.</param>
      <returns>Codificatore del resto della firma, inclusi il valore restituito e i parametri, che hanno la stessa struttura della firma del metodo.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.TypeSpecificationSignature">
      <summary>Codifica la firma di specifica del tipo.</summary>
      <returns>Codificatore di tipo del tipo strutturato rappresentato dalla specifica del tipo (non deve codificare un tipo primitivo).</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.BlobEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.CodedIndex" />
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.CustomAttributeType(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcola un indice codificato CustomAttributeType per l'handle specificato.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> o <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" /></param>
      <exception cref="T:System.ArgumentException">Il tipo di handle non è previsto.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasConstant(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcola un indice codificato HasConstant per l'handle specificato.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />o <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" /></param>
      <exception cref="T:System.ArgumentException">Il tipo di handle non è previsto.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasCustomAttribute(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcola un indice codificato HasCustomAttribute per l'handle specificato.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />, <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />, <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />, <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" /> o <see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />.</param>
      <exception cref="T:System.ArgumentException">Il tipo di handle non è previsto.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasCustomDebugInformation(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcola un indice codificato HasCustomDebugInformation per l'handle specificato.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />, <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />, <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />, <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" />, <see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.DocumentHandle" />, <see cref="T:System.Reflection.Metadata.LocalScopeHandle" />, <see cref="T:System.Reflection.Metadata.LocalVariableHandle" />, <see cref="T:System.Reflection.Metadata.LocalConstantHandle" /> o <see cref="T:System.Reflection.Metadata.ImportScopeHandle" />.</param>
      <exception cref="T:System.ArgumentException">Il tipo di handle non è previsto.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasDeclSecurity(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcola un indice codificato HasDeclSecurity per l'handle specificato.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />o <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" /></param>
      <exception cref="T:System.ArgumentException">Il tipo di handle non è previsto.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasFieldMarshal(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcola un indice codificato HasFieldMarshal per l'handle specificato.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.ParameterHandle" /> o <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" /></param>
      <exception cref="T:System.ArgumentException">Il tipo di handle non è previsto.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasSemantics(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcola un indice codificato HasSemantics per l'handle specificato.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" /> o <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" /></param>
      <exception cref="T:System.ArgumentException">Il tipo di handle non è previsto.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.Implementation(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcola un indice codificato di implementazione per l'handle specificato.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" /> o <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" /></param>
      <exception cref="T:System.ArgumentException">Il tipo di handle non è previsto.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.MemberForwarded(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcola un indice codificato MemberForwarded per l'handle specificato.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.FieldDefinition" />, <see cref="T:System.Reflection.Metadata.MethodDefinition" /></param>
      <exception cref="T:System.ArgumentException">Il tipo di handle non è previsto.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.MemberRefParent(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcola un indice codificato MemberRefParent per l'handle specificato.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />, o <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <exception cref="T:System.ArgumentException">Il tipo di handle non è previsto.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.MethodDefOrRef(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcola un indice codificato MethodDefOrRef per l'handle specificato.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> o <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" /></param>
      <exception cref="T:System.ArgumentException">Il tipo di handle non è previsto.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.ResolutionScope(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcola un indice codificato ResolutionScope per l'handle specificato.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" /> o <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /></param>
      <exception cref="T:System.ArgumentException">Il tipo di handle non è previsto.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.TypeDefOrRef(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcola un indice codificato TypeDefOrRef per l'handle specificato.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> o <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /></param>
      <exception cref="T:System.ArgumentException">Il tipo di handle non è previsto.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.TypeDefOrRefOrSpec(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcola un indice codificato TypeDefOrRefOrSpec per l'handle specificato.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> o <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /></param>
      <exception cref="T:System.ArgumentException">Il tipo di handle non è previsto.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.TypeOrMethodDef(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcola un indice codificato TypeOrMethodDef per l'handle specificato.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> o <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /></param>
      <exception cref="T:System.ArgumentException">Il tipo di handle non è previsto.</exception>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.ControlFlowBuilder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.#ctor" />
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddCatchRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>Aggiunge l'area catch.</summary>
      <param name="tryStart">Etichetta che contrassegna la prima istruzione del blocco try.</param>
      <param name="tryEnd">Etichetta che contrassegna l'istruzione immediatamente successiva al blocco try.</param>
      <param name="handlerStart">Etichetta che contrassegna la prima istruzione del gestore.</param>
      <param name="handlerEnd">Etichetta che contrassegna l'istruzione immediatamente successiva al gestore.</param>
      <param name="catchType">Tipo di eccezione da intercettare: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> o <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <exception cref="T:System.ArgumentException">Un'etichetta non è stata definita da un codificatore di istruzioni a cui è associato il generatore.

-oppure-

<paramref name="catchType" /> non è un handle di tipo valido.</exception>
      <exception cref="T:System.ArgumentNullException">Un'etichetta ha un valore predefinito.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddFaultRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary>Aggiunge l'area fault.</summary>
      <param name="tryStart">Etichetta che contrassegna la prima istruzione del blocco try.</param>
      <param name="tryEnd">Etichetta che contrassegna l'istruzione immediatamente successiva al blocco try.</param>
      <param name="handlerStart">Etichetta che contrassegna la prima istruzione del gestore.</param>
      <param name="handlerEnd">Etichetta che contrassegna l'istruzione immediatamente successiva al gestore.</param>
      <exception cref="T:System.ArgumentException">Un'etichetta non è stata definita da un codificatore di istruzioni a cui è associato il generatore.</exception>
      <exception cref="T:System.ArgumentNullException">Un'etichetta ha un valore predefinito.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddFilterRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary>Aggiunge l'area catch.</summary>
      <param name="tryStart">Etichetta che contrassegna la prima istruzione del blocco try.</param>
      <param name="tryEnd">Etichetta che contrassegna l'istruzione immediatamente successiva al blocco try.</param>
      <param name="handlerStart">Etichetta che contrassegna la prima istruzione del gestore.</param>
      <param name="handlerEnd">Etichetta che contrassegna l'istruzione immediatamente successiva al gestore.</param>
      <param name="filterStart">Etichetta che contrassegna la prima istruzione del blocco del filtro.</param>
      <exception cref="T:System.ArgumentException">Un'etichetta non è stata definita da un codificatore di istruzioni a cui è associato il generatore.</exception>
      <exception cref="T:System.ArgumentNullException">Un'etichetta ha un valore predefinito.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddFinallyRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary>Aggiunge l'area finally.</summary>
      <param name="tryStart">Etichetta che contrassegna la prima istruzione del blocco try.</param>
      <param name="tryEnd">Etichetta che contrassegna l'istruzione immediatamente successiva al blocco try.</param>
      <param name="handlerStart">Etichetta che contrassegna la prima istruzione del gestore.</param>
      <param name="handlerEnd">Etichetta che contrassegna l'istruzione immediatamente successiva al gestore.</param>
      <exception cref="T:System.ArgumentException">Un'etichetta non è stata definita da un codificatore di istruzioni a cui è associato il generatore.</exception>
      <exception cref="T:System.ArgumentNullException">Un'etichetta ha un valore predefinito.</exception>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.ElementType" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.ObjectArray" />
    <member name="P:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Boolean" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Byte" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Char" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Double" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Enum(System.String)">
      <param name="enumTypeName" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Int16" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Int32" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Int64" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.PrimitiveType(System.Reflection.Metadata.PrimitiveSerializationTypeCode)">
      <param name="type" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.SByte" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Single" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.String" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.SystemType" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.UInt16" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.UInt32" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.UInt64" />
    <member name="P:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder.Count(System.Int32)">
      <param name="count" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder.AddModifier(System.Reflection.Metadata.EntityHandle,System.Boolean)">
      <summary>Codifica un modificatore personalizzato.</summary>
      <param name="type">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> o <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <param name="isOptional">Modificatore facoltativo.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="type" /> è <see langword="null" /> di tipo o di un tipo imprevisto.</exception>
      <returns>Codificatore dei modificatori successivi.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry" />
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.#ctor(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.Ecma335.EditAndContinueOperation)">
      <param name="handle" />
      <param name="operation" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Equals(System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry)">
      <summary>Indica se l'oggetto corrente è uguale a un altro oggetto dello stesso tipo.</summary>
      <param name="other">Oggetto da confrontare con l'oggetto corrente.</param>
      <returns>
        <see langword="true" /> se l'oggetto corrente è uguale al parametro <paramref name="other" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.GetHashCode" />
    <member name="P:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Handle" />
    <member name="P:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Operation" />
    <member name="T:System.Reflection.Metadata.Ecma335.EditAndContinueOperation" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddEvent" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddField" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddMethod" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddParameter" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddProperty" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.Default" />
    <member name="T:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.Add(System.Reflection.Metadata.ExceptionRegionKind,System.Int32,System.Int32,System.Int32,System.Int32,System.Reflection.Metadata.EntityHandle,System.Int32)">
      <summary>Aggiunge una clausola di eccezione.</summary>
      <param name="kind">Tipo di clausola.</param>
      <param name="tryOffset">Offset iniziale del blocco try.</param>
      <param name="tryLength">Lunghezza del blocco try.</param>
      <param name="handlerOffset">Offset iniziale del gestore.</param>
      <param name="handlerLength">Lunghezza del gestore.</param>
      <param name="catchType">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> o <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /> oppure nil se <paramref name="kind" /> non è <see cref="F:System.Reflection.Metadata.ExceptionRegionKind.Catch" /></param>
      <param name="filterOffset">Offset del blocco di filtro oppure 0 se <paramref name="kind" /> non è <see cref="F:System.Reflection.Metadata.ExceptionRegionKind.Filter" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="catchType" /> non è valido.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Il valore di <paramref name="kind" />non è valido.
          
-oppure-

<paramref name="tryOffset" />, <paramref name="tryLength" />, <paramref name="handlerOffset" /> o <paramref name="handlerLength" /> non è compreso nell'intervallo.</exception>
      <exception cref="T:System.InvalidOperationException">Il corpo del metodo non è stato dichiarato con aree di eccezioni.</exception>
      <returns>Codificatore per la clausola successiva.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddCatch(System.Int32,System.Int32,System.Int32,System.Int32,System.Reflection.Metadata.EntityHandle)">
      <summary>Aggiunge una clausola fault.</summary>
      <param name="tryOffset">Offset iniziale del blocco try.</param>
      <param name="tryLength">Lunghezza del blocco try.</param>
      <param name="handlerOffset">Offset iniziale del gestore.</param>
      <param name="handlerLength">Lunghezza del gestore.</param>
      <param name="catchType">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> o <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="catchType" /> non è valido.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="tryOffset" />, <paramref name="tryLength" />, <paramref name="handlerOffset" /> o <paramref name="handlerLength" /> non è compreso nell'intervallo.</exception>
      <exception cref="T:System.InvalidOperationException">Il corpo del metodo non è stato dichiarato con aree di eccezioni.</exception>
      <returns>Codificatore per la clausola successiva.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddFault(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>Aggiunge una clausola fault.</summary>
      <param name="tryOffset">Offset iniziale del blocco try.</param>
      <param name="tryLength">Lunghezza del blocco try.</param>
      <param name="handlerOffset">Offset iniziale del gestore.</param>
      <param name="handlerLength">Lunghezza del gestore.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="tryOffset" />, <paramref name="tryLength" />, <paramref name="handlerOffset" /> o <paramref name="handlerLength" /> non è compreso nell'intervallo.</exception>
      <exception cref="T:System.InvalidOperationException">Il corpo del metodo non è stato dichiarato con aree di eccezioni.</exception>
      <returns>Codificatore per la clausola successiva.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddFilter(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>Aggiunge una clausola fault.</summary>
      <param name="tryOffset">Offset iniziale del blocco try.</param>
      <param name="tryLength">Lunghezza del blocco try.</param>
      <param name="handlerOffset">Offset iniziale del gestore.</param>
      <param name="handlerLength">Lunghezza del gestore.</param>
      <param name="filterOffset">Offset del blocco di filtro.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="tryOffset" />, <paramref name="tryLength" />, <paramref name="handlerOffset" /> o <paramref name="handlerLength" /> non è compreso nell'intervallo.</exception>
      <exception cref="T:System.InvalidOperationException">Il corpo del metodo non è stato dichiarato con aree di eccezioni.</exception>
      <returns>Codificatore per la clausola successiva.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddFinally(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>Aggiunge una clausola finally.</summary>
      <param name="tryOffset">Offset iniziale del blocco try.</param>
      <param name="tryLength">Lunghezza del blocco try.</param>
      <param name="handlerOffset">Offset iniziale del gestore.</param>
      <param name="handlerLength">Lunghezza del gestore.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="tryOffset" />, <paramref name="tryLength" />, <paramref name="handlerOffset" /> o <paramref name="handlerLength" /> non è compreso nell'intervallo.</exception>
      <exception cref="T:System.InvalidOperationException">Il corpo del metodo non è stato dichiarato con aree di eccezioni.</exception>
      <returns>Codificatore per la clausola successiva.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.IsSmallExceptionRegion(System.Int32,System.Int32)">
      <summary>Restituisce <see langword="true" /> se l'area rientra nel formato ridotto.</summary>
      <param name="startOffset">Offset iniziale dell'area.</param>
      <param name="length">Lunghezza dell'area.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.IsSmallRegionCount(System.Int32)">
      <summary>Restituisce <see langword="true" /> se il numero di aree di eccezione rientra nel formato ridotto.</summary>
      <param name="exceptionRegionCount">Numero delle aree di eccezione.</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.Builder">
      <summary>Generatore sottostante.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.HasSmallFormat">
      <summary>
        <see langword="true" /> se il codificatore usa un formato ridotto.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.ExportedTypeExtensions">
      <summary>Fornisce un metodo di estensione per accedere alla colonna TypeDefinitionId della tabella ExportedType.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExportedTypeExtensions.GetTypeDefinitionId(System.Reflection.Metadata.ExportedType)">
      <summary>Ottiene un hint in corrispondenza del numero di riga probabile del tipo di destinazione nella tabella TypeDef del relativo modulo.
Se gli spazi dei nomi e i nomi non corrispondono, la risoluzione esegue il fallback a una ricerca completa della tabella TypeDef di destinazione. Ignorato e deve essere zero se <see cref="P:System.Reflection.Metadata.ExportedType.IsForwarder" /> è <see langword="true" />.</summary>
      <param name="exportedType" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder.AddArgument" />
    <member name="P:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes" />
    <member name="F:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes.HasExplicitThis" />
    <member name="F:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes.HasThis" />
    <member name="F:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes.None" />
    <member name="T:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder.AddArgument" />
    <member name="P:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.HeapIndex" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.Blob" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.Guid" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.String" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.UserString" />
    <member name="T:System.Reflection.Metadata.Ecma335.InstructionEncoder">
      <summary>Codifica le istruzioni.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.#ctor(System.Reflection.Metadata.BlobBuilder,System.Reflection.Metadata.Ecma335.ControlFlowBuilder)">
      <summary>Consente di creare un codificatore supportato da generatori di codice e di flusso di controllo.</summary>
      <param name="codeBuilder">Generatore in cui scrivere le istruzioni codificate.</param>
      <param name="controlFlowBuilder">Etichette di rilevamento, rami e gestori di eccezioni del generatore.
Deve essere specificato per poter usare alcuni dei metodi factory del flusso di controllo di <see cref="T:System.Reflection.Metadata.Ecma335.InstructionEncoder" />, ad esempio <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Branch(System.Reflection.Metadata.ILOpCode,System.Reflection.Metadata.Ecma335.LabelHandle)" />, <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.DefineLabel" />, <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.MarkLabel(System.Reflection.Metadata.Ecma335.LabelHandle)" /> e così via.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Branch(System.Reflection.Metadata.ILOpCode,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary>Codifica un'istruzione branch.</summary>
      <param name="code">Istruzione branch da codificare.</param>
      <param name="label">Etichetta della posizione di destinazione nel flusso di istruzioni.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="code" /> non è un'istruzione branch.

-oppure- 
<paramref name="label" /> non è stato definito dal codificatore.</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="label" /> ha un valore predefinito.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.EntityHandle)">
      <summary>Codifica l'istruzione <c>call</c> e il relativo operando.</summary>
      <param name="methodHandle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.MemberReferenceHandle)">
      <summary>Codifica l'istruzione <c>call</c> e il relativo operando.</summary>
      <param name="methodHandle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary>Codifica l'istruzione <c>call</c> e il relativo operando.</summary>
      <param name="methodHandle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.MethodSpecificationHandle)">
      <summary>Codifica l'istruzione <c>call</c> e il relativo operando.</summary>
      <param name="methodHandle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.CallIndirect(System.Reflection.Metadata.StandaloneSignatureHandle)">
      <summary>Codifica l'istruzione <c>calli</c> e il relativo operando.</summary>
      <param name="signature" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.DefineLabel">
      <summary>Definisce un'etichetta che può essere usata in un secondo momento per contrassegnare e fare riferimento a una posizione nel flusso di istruzioni.</summary>
      <exception cref="T:System.InvalidOperationException">
        <see cref="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder" /> è <see langword="null" />.</exception>
      <returns>Handle dell'etichetta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadArgument(System.Int32)">
      <summary>Codifica l'istruzione di caricamento degli argomenti.</summary>
      <param name="argumentIndex">Indice dell'argomento.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="argumentIndex" /> è negativo.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadArgumentAddress(System.Int32)">
      <summary>Codifica l'istruzione di caricamento dell'indirizzo dell'argomento.</summary>
      <param name="argumentIndex">Indice dell'argomento.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="argumentIndex" /> è negativo.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantI4(System.Int32)">
      <summary>Codifica l'istruzione di caricamento della costante <see cref="T:System.Int32" />.</summary>
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantI8(System.Int64)">
      <summary>Codifica l'istruzione di caricamento della costante <see cref="T:System.Int64" />.</summary>
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantR4(System.Single)">
      <summary>Codifica l'istruzione di caricamento della costante <see cref="T:System.Single" />.</summary>
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantR8(System.Double)">
      <summary>Codifica l'istruzione di caricamento della costante <see cref="T:System.Double" />.</summary>
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadLocal(System.Int32)">
      <summary>Codifica l'istruzione di caricamento della variabile locale.</summary>
      <param name="slotIndex">Indice dello slot della variabile locale.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="slotIndex" /> è negativo.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadLocalAddress(System.Int32)">
      <summary>Codifica l'istruzione di caricamento dell'indirizzo della variabile locale.</summary>
      <param name="slotIndex">Indice dello slot della variabile locale.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="slotIndex" /> è negativo.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)">
      <summary>Codifica l'istruzione <c>ldstr</c> e il relativo operando.</summary>
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.MarkLabel(System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary>Associa l'etichetta specificata all'offset IL corrente.</summary>
      <param name="label">Etichetta da contrassegnare.</param>
      <exception cref="T:System.InvalidOperationException">
        <see cref="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="label" /> non è stato definito dal codificatore.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="label" /> ha un valore predefinito.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.OpCode(System.Reflection.Metadata.ILOpCode)">
      <summary>Codifica il codice operativo specificato.</summary>
      <param name="code" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.StoreArgument(System.Int32)">
      <summary>Codifica l'istruzione di archiviazione dell'argomento.</summary>
      <param name="argumentIndex">Indice dell'argomento.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="argumentIndex" /> è negativo.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.StoreLocal(System.Int32)">
      <summary>Codifica l'istruzione di archiviazione della variabile locale.</summary>
      <param name="slotIndex">Indice dello slot della variabile locale.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="slotIndex" /> è negativo.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Token(System.Int32)">
      <summary>Codifica un token.</summary>
      <param name="token" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Token(System.Reflection.Metadata.EntityHandle)">
      <summary>Codifica un token.</summary>
      <param name="handle" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.CodeBuilder">
      <summary>Generatore sottostante in cui vengono scritte le istruzioni codificate.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder">
      <summary>Etichette di rilevamento, rami e gestori di eccezioni del generatore.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.Offset">
      <summary>Offset della successiva istruzione codificata.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.LabelHandle" />
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.Equals(System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary>Indica se l'oggetto corrente è uguale a un altro oggetto dello stesso tipo.</summary>
      <param name="other">Oggetto da confrontare con l'oggetto corrente.</param>
      <returns>
        <see langword="true" /> se l'oggetto corrente è uguale al parametro <paramref name="other" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.op_Equality(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.op_Inequality(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.LabelHandle.Id">
      <summary>ID in base 1 che identifica l'etichetta all'interno del contesto di un elemento <see cref="T:System.Reflection.Metadata.Ecma335.ControlFlowBuilder" />.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.LabelHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.Ecma335.LiteralEncoder">
      <summary>Specifica metodi per la codifica dei valori letterali.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder">Crea una nuova istanza della classe <see cref="T:System.Reflection.Metadata.Ecma335.LiteralEncoder" /> con il generatore di BLOB specificato.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.Scalar">
      <summary>Restituisce il codificatore usato per codificare il valore letterale.</summary>
      <returns>Codificatore del valore letterale.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedScalar(System.Action{System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.ScalarEncoder})">
      <summary>Codifica il tipo e il valore di un valore letterale usando i delegati specificati.</summary>
      <param name="type">Delegato usato per codificare il tipo del valore letterale. Chiamato per primo da questo metodo.</param>
      <param name="scalar">Delegato usato per codificare il valore del valore letterale. Chiamato per secondo da questo metodo.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> o <paramref name="scalar" /> è <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedScalar(System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder@,System.Reflection.Metadata.Ecma335.ScalarEncoder@)">
      <summary>Restituisce una coppia di codificatori che devono essere usati per codificare il tipo e il valore di un valore letterale nell'ordine in cui compaiono nell'elenco dei parametri.</summary>
      <param name="type">Al termine del metodo, un codificatore di tipi di elemento attributo personalizzato usato per codificare il tipo del valore letterale.</param>
      <param name="scalar">Al termine del metodo, un valore scalare codificato usato per codificare il valore del valore letterale.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedVector(System.Action{System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.VectorEncoder})">
      <summary>Codifica il tipo e gli elementi di un valore letterale del vettore usando i delegati specificati.</summary>
      <param name="arrayType">Delegato usato per codificare il tipo del vettore. Chiamato per primo da questo metodo.</param>
      <param name="vector">Delegato usato per codificare gli elementi del vettore. Chiamato per secondo da questo metodo.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="arrayType" /> o <paramref name="vector" /> è <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedVector(System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder@,System.Reflection.Metadata.Ecma335.VectorEncoder@)">
      <summary>Restituisce una coppia di codificatori che devono essere usati per codificare il tipo e gli elementi di un valore letterale di vettore nell'ordine in cui compaiono nell'elenco dei parametri.</summary>
      <param name="arrayType">Al termine del metodo, un codificatore di tipi di matrice attributo personalizzato usato per codificare il tipo del valore.</param>
      <param name="vector">Al termine del metodo, un codificatore di vettore usato per codificare gli elementi del vettore.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.Vector">
      <summary>Ottiene un codificatore di vettore usato per codificare gli elementi di un vettore.</summary>
      <returns>Codificatore di vettore usato per codificare gli elementi di un vettore.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.LiteralEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.LiteralsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralsEncoder.AddLiteral" />
    <member name="P:System.Reflection.Metadata.Ecma335.LiteralsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder.AddVariable" />
    <member name="P:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.CustomModifiers" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.Type(System.Boolean,System.Boolean)">
      <param name="isByRef" />
      <param name="isPinned" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.TypedReference" />
    <member name="P:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataAggregator" />
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataAggregator.#ctor(System.Collections.Generic.IReadOnlyList{System.Int32},System.Collections.Generic.IReadOnlyList{System.Int32},System.Collections.Generic.IReadOnlyList{System.Reflection.Metadata.MetadataReader})">
      <param name="baseTableRowCounts" />
      <param name="baseHeapSizes" />
      <param name="deltaReaders" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataAggregator.#ctor(System.Reflection.Metadata.MetadataReader,System.Collections.Generic.IReadOnlyList{System.Reflection.Metadata.MetadataReader})">
      <param name="baseReader" />
      <param name="deltaReaders" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataAggregator.GetGenerationHandle(System.Reflection.Metadata.Handle,System.Int32@)">
      <summary>Calcola l'handle dell'entità all'interno della generazione dei metadati in cui è definito, dato un handle di un'entità nei metadati di un'aggregazione.</summary>
      <param name="handle">Handle di un'entità nei metadati di un'aggregazione.</param>
      <param name="generation">Generazione in cui è definita l'entità.</param>
      <returns>Handle dell'entità all'interno del parametro <paramref name="generation" /> dei metadati.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataBuilder">
      <summary>La classe MetadataBuilder legge e scrive i metadati per un assembly in modo estremamente efficiente. È progettata per essere usata dai compilatori e da altri strumenti per la generazione di assembly.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>Crea un generatore per tabelle e heap dei metadati.</summary>
      <param name="userStringHeapStartOffset">Offset iniziale dell'heap delle stringhe utente. Le dimensioni cumulative degli heap delle stringhe utente di tutte le generazioni EnC precedenti devono essere 0, a meno che i metadati non siano metadati delta EnC.</param>
      <param name="stringHeapStartOffset">Offset iniziale dell'heap delle stringhe. Le dimensioni cumulative degli heap delle stringhe di tutte le generazioni EnC precedenti devono essere 0, a meno che i metadati non siano metadati delta EnC.</param>
      <param name="blobHeapStartOffset">Offset iniziale dell'heap dei BLOB. Le dimensioni cumulative degli heap dei BLOB di tutte le generazioni EnC precedenti devono essere 0, a meno che i metadati non siano metadati delta EnC.</param>
      <param name="guidHeapStartOffset">Offset iniziale dell'heap dei GUID. Le dimensioni cumulative degli heap dei GUID di tutte le generazioni EnC precedenti devono essere 0, a meno che i metadati non siano metadati delta EnC.</param>
      <exception cref="T:System.Reflection.Metadata.ImageFormatLimitationException">Offset troppo grande.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Offset negativo.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="guidHeapStartOffset" /> non è un multiplo delle dimensioni del GUID.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddAssembly(System.Reflection.Metadata.StringHandle,System.Version,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Reflection.AssemblyFlags,System.Reflection.AssemblyHashAlgorithm)">
      <param name="name" />
      <param name="version" />
      <param name="culture" />
      <param name="publicKey" />
      <param name="flags" />
      <param name="hashAlgorithm" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddAssemblyFile(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Boolean)">
      <param name="name" />
      <param name="hashValue" />
      <param name="containsMetadata" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddAssemblyReference(System.Reflection.Metadata.StringHandle,System.Version,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Reflection.AssemblyFlags,System.Reflection.Metadata.BlobHandle)">
      <param name="name" />
      <param name="version" />
      <param name="culture" />
      <param name="publicKeyOrToken" />
      <param name="flags" />
      <param name="hashValue" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddConstant(System.Reflection.Metadata.EntityHandle,System.Object)">
      <summary>Aggiunge un valore predefinito per un parametro, un campo o una proprietà.</summary>
      <param name="parent">Handle dell'entità padre, che può essere uno dei seguenti: <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" /> o <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />.</param>
      <param name="value">Valore della costante.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" /> non ha il tipo di handle previsto.</exception>
      <returns>Handle per la costante aggiunta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddCustomAttribute(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Aggiunge un attributo personalizzato.</summary>
      <param name="parent">Entità a cui collegare l'attributo personalizzato: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />, <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />, <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />, <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" /> o <see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />.</param>
      <param name="constructor">Costruttore di attributo personalizzato: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> o <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />.</param>
      <param name="value">BLOB del valore dell'attributo personalizzato.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" /> non ha il tipo di handle previsto.</exception>
      <returns>Handle per l'attributo personalizzato aggiunto.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddCustomDebugInformation(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Aggiunge informazioni di debug personalizzate.</summary>
      <param name="parent">Entità a cui collegare le informazioni di debug: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />, <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />, <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />, <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" />, <see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.DocumentHandle" />, <see cref="T:System.Reflection.Metadata.LocalScopeHandle" />, <see cref="T:System.Reflection.Metadata.LocalVariableHandle" />, <see cref="T:System.Reflection.Metadata.LocalConstantHandle" /> o <see cref="T:System.Reflection.Metadata.ImportScopeHandle" />.</param>
      <param name="kind">Tipo di informazioni. Determina la struttura del BLOB <paramref name="value" />.</param>
      <param name="value">BLOB di informazioni di debug personalizzate.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" /> non ha il tipo di handle previsto.</exception>
      <returns>Handle per le informazioni di debug personalizzate aggiunte.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddDeclarativeSecurityAttribute(System.Reflection.Metadata.EntityHandle,System.Reflection.DeclarativeSecurityAction,System.Reflection.Metadata.BlobHandle)">
      <summary>Aggiunge un attributo di sicurezza dichiarativa a un tipo, un metodo o un assembly.</summary>
      <param name="parent">Handle dell'entità padre, che può essere uno dei seguenti: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> o <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />.</param>
      <param name="action">Azione di sicurezza dichiarativa.</param>
      <param name="permissionSet">BLOB del set di autorizzazioni.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" /> non ha il tipo di handle previsto.</exception>
      <returns>Handle per l'attributo di sicurezza dichiarativa aggiunto.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddDocument(System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.GuidHandle)">
      <summary>Aggiunge informazioni di debug del documento.</summary>
      <param name="name">BLOB del nome del documento.</param>
      <param name="hashAlgorithm">GUID dell'algoritmo hash usato per calcolare il valore di <paramref name="hash" />.</param>
      <param name="hash">Hash del contenuto del documento.</param>
      <param name="language">GUID del linguaggio.</param>
      <returns>Handle per il documento aggiunto.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEncLogEntry(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.Ecma335.EditAndContinueOperation)">
      <param name="entity" />
      <param name="code" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEncMapEntry(System.Reflection.Metadata.EntityHandle)">
      <param name="entity" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEvent(System.Reflection.EventAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>Aggiunge una definizione di evento.</summary>
      <param name="attributes">Attributi dell'evento.</param>
      <param name="name">Il nome dell'evento.</param>
      <param name="type">Tipo di evento: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> o <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="type" /> non ha il tipo di handle previsto.</exception>
      <returns>Handle per la definizione di evento aggiunta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEventMap(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="declaringType" />
      <param name="eventList" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddExportedType(System.Reflection.TypeAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle,System.Int32)">
      <summary>Aggiunge un tipo esportato.</summary>
      <param name="attributes">Attributi del tipo.</param>
      <param name="namespace">Spazio dei nomi del tipo.</param>
      <param name="name">Nome del tipo.</param>
      <param name="implementation">Handle dell'entità di implementazione, che può essere uno dei seguenti: <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" /> o <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />.</param>
      <param name="typeDefinitionId">ID della definizione del tipo.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="implementation" /> non ha il tipo di handle previsto.</exception>
      <returns>Handle per il tipo esportato aggiunto.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddFieldDefinition(System.Reflection.FieldAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Aggiunge una definizione di campo.</summary>
      <param name="attributes">Attributi del campo.</param>
      <param name="name">Nome del campo.</param>
      <param name="signature">Firma di campo. Usare <see cref="M:System.Reflection.Metadata.Ecma335.BlobEncoder.FieldSignature" /> per costruire il BLOB.</param>
      <returns>Handle per la definizione di campo aggiunta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddFieldLayout(System.Reflection.Metadata.FieldDefinitionHandle,System.Int32)">
      <summary>Definisce un layout di campo di una definizione di campo.</summary>
      <param name="field">Handle della definizione di campo.</param>
      <param name="offset">Offset di byte del campo all'interno dell'istanza del tipo dichiarante.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddFieldRelativeVirtualAddress(System.Reflection.Metadata.FieldDefinitionHandle,System.Int32)">
      <summary>Aggiunge un mapping da un campo al relativo valore iniziale archiviato nell'immagine PE.</summary>
      <param name="field">Handle della definizione di campo.</param>
      <param name="offset">Offset all'interno del blocco nell'immagine PE che archivia i valori iniziali dei campi mappati (in genere nella sezione .text).</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="offset" /> è negativo.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddGenericParameter(System.Reflection.Metadata.EntityHandle,System.Reflection.GenericParameterAttributes,System.Reflection.Metadata.StringHandle,System.Int32)">
      <summary>Aggiunge una definizione di parametro generico.</summary>
      <param name="parent">Handle dell'entità padre, che può essere <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> o <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />.</param>
      <param name="attributes">Attributi del parametro generico.</param>
      <param name="name">Nome del parametro.</param>
      <param name="index">Indice del parametro in base zero.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" /> non ha il tipo di handle previsto.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> è maggiore di <see cref="F:System.UInt16.MaxValue" />.</exception>
      <returns>Handle per il parametro generico aggiunto.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddGenericParameterConstraint(System.Reflection.Metadata.GenericParameterHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>Aggiunge un vincolo di tipo a un parametro generico.</summary>
      <param name="genericParameter">Parametro generico da vincolare.</param>
      <param name="constraint">Vincolo di tipo, che può essere uno dei seguenti: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> o <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="genericParameter" /> non ha il tipo di handle previsto.</exception>
      <returns>Handle per il vincolo di parametro generico aggiunto.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddImportScope(System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Aggiunge le informazioni di debug dell'ambito locale.</summary>
      <param name="parentScope">Handle dell'ambito padre.</param>
      <param name="imports">Handle dell'ambito di importazione.</param>
      <returns>Handle per l'ambito di importazione aggiunto.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddInterfaceImplementation(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>Aggiunge una implementazione dell'interfaccia a un tipo.</summary>
      <param name="type">Tipo che implementa l'interfaccia.</param>
      <param name="implementedInterface">Interfaccia implementata, che può essere una delle seguenti: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> o <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="implementedInterface" /> non ha il tipo di handle previsto.</exception>
      <returns>Handle per l'implementazione dell'interfaccia aggiunta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddLocalConstant(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Aggiunge le informazioni di debug della costane locale.</summary>
      <param name="name">Nome della variabile.</param>
      <param name="signature">BLOB LocalConstantSig.</param>
      <returns>Handle per la costante locale aggiunta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddLocalScope(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.LocalVariableHandle,System.Reflection.Metadata.LocalConstantHandle,System.Int32,System.Int32)">
      <summary>Aggiunge le informazioni di debug dell'ambito locale.</summary>
      <param name="method">Metodo contenitore.</param>
      <param name="importScope">Handle dell'ambito di importazione associato.</param>
      <param name="variableList">Se l'ambito dichiara variabili, impostarlo sull'handle della prima. In caso contrario, impostarlo sull'handle della prima variabile dichiarata dalla definizione di ambito successiva. Se nessun ambito definisce alcuna variabile, <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.LocalVariableHandle(1)" />.</param>
      <param name="constantList">Se l'ambito dichiara costanti, impostarlo sull'handle della prima. In caso contrario, impostarlo sull'handle della prima costante dichiarata dalla definizione di ambito successiva. Se nessun ambito definisce alcuna costante, <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.LocalConstantHandle(1)" />.</param>
      <param name="startOffset">Offset della prima istruzione a cui si applica l'ambito.</param>
      <param name="length">Lunghezza in byte dell'ambito.</param>
      <returns>Handle per l'ambito locale aggiunto.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddLocalVariable(System.Reflection.Metadata.LocalVariableAttributes,System.Int32,System.Reflection.Metadata.StringHandle)">
      <summary>Aggiunge informazioni di debug della variabile locale.</summary>
      <param name="attributes">Attributi della variabile locale.</param>
      <param name="index">Indice in base zero della variabile locale nella firma locale.</param>
      <param name="name">Nome della variabile.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> è maggiore di <see cref="F:System.UInt16.MaxValue" />.</exception>
      <returns>Handle per la variabile locale aggiunta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddManifestResource(System.Reflection.ManifestResourceAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle,System.UInt32)">
      <summary>Aggiunge una risorsa del manifesto.</summary>
      <param name="attributes">Attributi della risorsa del manifesto.</param>
      <param name="name">Nome della risorsa del manifesto.</param>
      <param name="implementation">Handle dell'entità di implementazione, che può essere uno dei seguenti: <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" /> o <see langword="null" />.</param>
      <param name="offset">Specifica l'offset in byte all'interno del file di riferimento da cui inizia questo record di risorsa.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="implementation" /> non ha il tipo di handle previsto.</exception>
      <returns>Handle per la risorsa del manifesto aggiunta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMarshallingDescriptor(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Aggiunge informazioni di marshalling a un campo o a un parametro.</summary>
      <param name="parent">Handle dell'entità padre, che può essere uno dei seguenti: <see cref="T:System.Reflection.Metadata.ParameterHandle" /> o <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />.</param>
      <param name="descriptor">BLOB del descrittore.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" /> non ha il tipo di handle previsto.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMemberReference(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Aggiunge una riga della tabella MemberRef.</summary>
      <param name="parent">L'entità contenitore, che può essere una delle seguenti: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> o <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <param name="name">Nome del membro.</param>
      <param name="signature">Firma del membro.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" /> non ha il tipo di handle previsto.</exception>
      <returns>Handle per il riferimento al membro aggiunto.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodDebugInformation(System.Reflection.Metadata.DocumentHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Aggiunge informazioni di debug del metodo.</summary>
      <param name="document">Handle di un singolo documento che contiene tutti i punti di sequenza del metodo o <see langword="null" /> se il metodo non ha punti di sequenza o si estende su più documenti.</param>
      <param name="sequencePoints">BLOB dei punti di sequenza oppure <see langword="null" /> se il metodo non ha punti di sequenza.</param>
      <returns>Handle per le informazioni di debug del metodo aggiunto.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodDefinition(System.Reflection.MethodAttributes,System.Reflection.MethodImplAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Int32,System.Reflection.Metadata.ParameterHandle)">
      <summary>Aggiunge una definizione del metodo.</summary>
      <param name="attributes">Attributi del metodo.</param>
      <param name="implAttributes">Attributi di implementazione del metodo.</param>
      <param name="name">Nome del metodo.</param>
      <param name="signature">Firma del metodo.</param>
      <param name="bodyOffset">Offset all'interno del blocco nell'immagine PE che archivia i corpi dei metodi (flusso IL) oppure -1 se il metodo non ha un corpo.</param>
      <param name="parameterList">Se il metodo dichiara parametri nella tabella Params, impostarlo sull'handle del primo. In caso contrario, impostarlo sull'handle del primo parametro dichiarato dalla definizione del metodo successiva. Se nel modulo non è dichiarato alcun parametro, <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.ParameterHandle(1)" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="bodyOffset" /> è minore di -1.</exception>
      <returns>Handle per la definizione del metodo aggiunta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodImplementation(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>Definisce un'implementazione per una dichiarazione di metodo all'interno di un tipo.</summary>
      <param name="type">Definizione del tipo</param>
      <param name="methodBody">Handle dell'entità del corpo del metodo, che può essere uno dei seguenti: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> o <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />.</param>
      <param name="methodDeclaration">Handle dell'entità di dichiarazione del metodo, che può essere uno dei seguenti: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> o <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="methodBody" /> o <paramref name="methodDeclaration" /> non ha il tipo di handle previsto.</exception>
      <returns>Handle per l'implementazione del metodo aggiunta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodImport(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.MethodImportAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.ModuleReferenceHandle)">
      <summary>Aggiunge informazioni di importazione a una definizione di metodo.</summary>
      <param name="method">Handle della definizione del metodo.</param>
      <param name="attributes">Attributi di importazione del metodo.</param>
      <param name="name">Nome del metodo non gestito.</param>
      <param name="module">Il modulo che contiene il metodo non gestito.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodSemantics(System.Reflection.Metadata.EntityHandle,System.Reflection.MethodSemanticsAttributes,System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary>Associa un metodo (getter, setter, adder e così via) a una proprietà o un evento.</summary>
      <param name="association">Handle dell'entità di associazione, che può essere uno dei seguenti: <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" /> o <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />.</param>
      <param name="semantics">Attributi della semantica del metodo.</param>
      <param name="methodDefinition">Definizione del metodo.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="association" /> non ha il tipo di handle previsto.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodSpecification(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Aggiunge una specifica del metodo (creazione di un'istanza).</summary>
      <param name="method">Handle di entità del metodo generico, che può essere uno dei seguenti: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> o <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />.</param>
      <param name="instantiation">BLOB di creazione di istanze che codifica gli argomenti generici del metodo.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non ha il tipo di handle previsto.</exception>
      <returns>Handle per la specifica del metodo aggiunta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddModule(System.Int32,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle)">
      <param name="generation" />
      <param name="moduleName" />
      <param name="mvid" />
      <param name="encId" />
      <param name="encBaseId" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddModuleReference(System.Reflection.Metadata.StringHandle)">
      <param name="moduleName" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddNestedType(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.TypeDefinitionHandle)">
      <summary>Definisce una relazione di annidamento con le definizioni di tipo specificate.</summary>
      <param name="type">Handle di definizione del tipo annidato.</param>
      <param name="enclosingType">Handle della definizione del tipo di inclusione.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddParameter(System.Reflection.ParameterAttributes,System.Reflection.Metadata.StringHandle,System.Int32)">
      <summary>Aggiunge una definizione del parametro.</summary>
      <param name="attributes">Attributi del parametro.</param>
      <param name="name">facoltativo. Nome del parametro.</param>
      <param name="sequenceNumber">Numero di sequenza del parametro. Il valore 0 fa riferimento al tipo restituito del metodo proprietario, I relativi parametri sono quindi numerati da 1 in poi.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="sequenceNumber" /> è maggiore di <see cref="F:System.UInt16.MaxValue" />.</exception>
      <returns>Handle per il parametro aggiunto.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddProperty(System.Reflection.PropertyAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Aggiunge una definizione di proprietà.</summary>
      <param name="attributes">Attributi della proprietà.</param>
      <param name="name">Nome della proprietà.</param>
      <param name="signature">Firma della proprietà.</param>
      <returns>Handle per la definizione della proprietà aggiunta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddPropertyMap(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="declaringType" />
      <param name="propertyList" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddStandaloneSignature(System.Reflection.Metadata.BlobHandle)">
      <param name="signature" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddStateMachineMethod(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary>Aggiunge informazioni di debug del metodo della macchina a stati.</summary>
      <param name="moveNextMethod">Handle del metodo <see langword="MoveNext" /> della macchina a stati (metodo generato dal compilatore).</param>
      <param name="kickoffMethod">Handle del metodo di avvio (metodo iteratore/asincrono definito dall'utente).</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeDefinition(System.Reflection.TypeAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.FieldDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary>Aggiunge una definizione di tipo.</summary>
      <param name="attributes">Attributi del tipo.</param>
      <param name="namespace">Spazio dei nomi del tipo.</param>
      <param name="name">Nome del tipo.</param>
      <param name="baseType">Handle di entità del tipo di base, che può essere uno dei seguenti: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /> o <see langword="null" />.</param>
      <param name="fieldList">Se il tipo dichiara campi, impostarlo sull'handle del primo. In caso contrario, impostarlo sull'handle del primo campo dichiarato dalla definizione di tipo successiva. Se nessun tipo definisce alcun campo nel modulo, <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.FieldDefinitionHandle(1)" />.</param>
      <param name="methodList">Se il tipo dichiara metodi, l'handle del primo. In caso contrario, l'handle del primo metodo dichiarato dalla definizione di tipo successiva. Se nessun tipo definisce alcun metodo nel modulo, <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDefinitionHandle(1)" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="baseType" /> non ha il tipo di handle previsto.</exception>
      <returns>Handle per la definizione di tipo aggiunta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeLayout(System.Reflection.Metadata.TypeDefinitionHandle,System.UInt16,System.UInt32)">
      <summary>Definisce un layout di tipo di una definizione di tipo.</summary>
      <param name="type">Definizione del tipo</param>
      <param name="packingSize">Specifica che i campi devono essere posizionati all'interno dell'istanza del tipo in corrispondenza di indirizzi di byte che sono un multiplo di <paramref name="packingSize" /> o in corrispondenza dell'allineamento naturale per quel tipo di campo, a seconda del valore minore. Il valore deve essere uno dei seguenti: 0, 1, 2, 4, 8, 16, 32, 64 o 128. Il valore zero indica che la dimensione di compressione usata deve corrispondere a quella predefinita per la piattaforma corrente.</param>
      <param name="size">Indica una dimensione minima dell'istanza del tipo ed è progettato per consentire il riempimento. La quantità di memoria allocata è il massimo delle dimensioni calcolate dal layout e <paramref name="size" />. Si noti che se questa direttiva si applica a un tipo valore, le dimensioni saranno inferiori a 1 MB.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeReference(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle)">
      <summary>Aggiunge un riferimento al tipo.</summary>
      <param name="resolutionScope">Entità che dichiara il tipo di destinazione, che può essere uno dei seguenti: <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> o <see langword="null" />.</param>
      <param name="namespace">Spazio dei nomi del riferimento al tipo.</param>
      <param name="name">Nome del riferimento al tipo.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="resolutionScope" /> non ha il tipo di handle previsto.</exception>
      <returns>Handle per il riferimento al tipo aggiunto.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeSpecification(System.Reflection.Metadata.BlobHandle)">
      <param name="signature" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlob(System.Byte[])">
      <summary>Aggiunge il BLOB specificato all'heap dei BLOB, se non è già presente.</summary>
      <param name="value">Matrice contenente il BLOB.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> è <see langword="null" />.</exception>
      <returns>Handle per il BLOB aggiunto o esistente.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlob(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>Aggiunge il BLOB specificato da una matrice di byte all'heap dei BLOB, se non è già presente.</summary>
      <param name="value">Matrice contenente il BLOB.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> è <see langword="null" />.</exception>
      <returns>Handle per il BLOB aggiunto o esistente.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlob(System.Reflection.Metadata.BlobBuilder)">
      <summary>Aggiunge il BLOB specificato da una matrice di byte non modificabile all'heap dei BLOB, se non è già presente.</summary>
      <param name="value">Istanza del generatore di BLOB contenente il BLOB.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> è <see langword="null" />.</exception>
      <returns>Handle per il BLOB aggiunto o esistente.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlobUTF16(System.String)">
      <summary>Codifica una stringa usando la codifica UTF16 in un BLOB e lo aggiunge all'heap dei BLOB, se non è già presente.</summary>
      <param name="value">Stringa da aggiungere.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> è <see langword="null" />.</exception>
      <returns>Handle per il BLOB aggiunto o esistente.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlobUTF8(System.String,System.Boolean)">
      <summary>Codifica una stringa usando la codifica UTF8 in un BLOB e la aggiunge all'heap dei BLOB, se non è già presente.</summary>
      <param name="value">Il valore da aggiungere.</param>
      <param name="allowUnpairedSurrogates">
        <see langword="true" /> per codificare i surrogati non abbinati specificati. <see langword="false" /> per sostituirli con il carattere U+FFFD.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> è <see langword="null" />.</exception>
      <returns>Handle per il BLOB aggiunto o esistente.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddConstantBlob(System.Object)">
      <summary>Codifica un valore costante in un BLOB e lo aggiunge all'heap dei BLOB, se non è già presente. Usa UTF16 per codificare le costanti stringa.</summary>
      <param name="value">Valore costante da aggiungere.</param>
      <returns>Handle per il BLOB aggiunto o esistente.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddDocumentName(System.String)">
      <summary>Codifica un nome di documento di debug e lo aggiunge all'heap dei BLOB, se non è già presente.</summary>
      <param name="value">Nome del documento da aggiungere.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> è <see langword="null" />.</exception>
      <returns>Handle per il BLOB del nome del documento aggiunto o esistente.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddGuid(System.Guid)">
      <summary>Aggiunge il GUID specificato all'heap dei GUID, se non è già presente.</summary>
      <param name="guid">GUID da aggiungere.</param>
      <returns>Handle per il GUID aggiunto o esistente.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddString(System.String)">
      <summary>Aggiunge la stringa specificata all'heap delle stringhe, se non è già presente.</summary>
      <param name="value">Stringa da aggiungere.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> è <see langword="null" />.</exception>
      <returns>Handle per la stringa aggiunta o esistente.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddUserString(System.String)">
      <summary>Aggiunge la stringa specificata all'heap delle stringhe utente, se non è già presente.</summary>
      <param name="value">Stringa da aggiungere.</param>
      <exception cref="T:System.Reflection.Metadata.ImageFormatLimitationException">Lo spazio rimanente nell'heap è troppo piccolo per la stringa.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> è <see langword="null" />.</exception>
      <returns>Handle per la stringa aggiunta o esistente. Questo valore può essere usato in <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetRowCount(System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary>Restituisce il numero corrente di elementi nella tabella specificata.</summary>
      <param name="table">Indice della tabella.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="table" /> non è un indice di tabella valido.</exception>
      <returns>Numero di elementi nella tabella.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetRowCounts">
      <summary>Restituisce il numero corrente di elementi in ogni tabella.</summary>
      <returns>Matrice di dimensioni <see cref="F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount" />, con ogni elemento riempito con il numero di righe corrente della tabella corrispondente.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.ReserveGuid">
      <summary>Riserva spazio per un GUID nell'heap dei GUID.</summary>
      <exception cref="T:System.Reflection.Metadata.ImageFormatLimitationException">Lo spazio rimanente nell'heap è troppo piccolo per la stringa.</exception>
      <returns>Handle per il GUID riservato e un <see cref="T:System.Reflection.Metadata.Blob" /> che rappresenta il BLOB GUID archiviato nell'heap.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.ReserveUserString(System.Int32)">
      <summary>Riserva spazio nell'heap delle stringhe utente per una stringa con la lunghezza specificata.</summary>
      <param name="length">Numero di caratteri da riservare.</param>
      <exception cref="T:System.Reflection.Metadata.ImageFormatLimitationException">Lo spazio rimanente nell'heap è troppo piccolo per la stringa.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" /> è negativo.</exception>
      <returns>Handle per la stringa utente riservata e un <see cref="T:System.Reflection.Metadata.Blob" /> che rappresenta l'intero BLOB di stringhe utente (inclusi la lunghezza e il carattere terminale). L'handle può essere usato in <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)" />.
Usare <see cref="M:System.Reflection.Metadata.BlobWriter.WriteUserString(System.String)" /> per compilare il contenuto del BLOB.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.SetCapacity(System.Reflection.Metadata.Ecma335.HeapIndex,System.Int32)">
      <summary>Imposta la capacità dell'heap specificato.</summary>
      <param name="heap">Indice dell'heap.</param>
      <param name="byteCount">Numero di byte.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="heap" /> non è un indice di heap valido.

-oppure-

<paramref name="byteCount" /> è negativo.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.SetCapacity(System.Reflection.Metadata.Ecma335.TableIndex,System.Int32)">
      <summary>Imposta la capacità della tabella specificata.</summary>
      <param name="table">Indice della tabella.</param>
      <param name="rowCount">Numero di righe nella tabella.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="table" /> non è un indice di tabella valido.

-oppure-

<paramref name="rowCount" /> è negativo.</exception>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions">
      <summary>Specifica metodi di estensione per l'uso di determinati elementi non elaborati delle tabelle e degli heap dei metadati ECMA-335.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetEditAndContinueLogEntries(System.Reflection.Metadata.MetadataReader)">
      <summary>Enumera le voci del log EnC.</summary>
      <param name="reader" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> è <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetEditAndContinueMapEntries(System.Reflection.Metadata.MetadataReader)">
      <summary>Enumera le voci della mappa EnC.</summary>
      <param name="reader" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> è <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetHeapMetadataOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.HeapIndex)">
      <summary>Restituisce l'offset dall'inizio dei metadati all'heap specificato.</summary>
      <param name="reader" />
      <param name="heapIndex" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="heapIndex" /> non è un indice di heap valido.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetHeapSize(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.HeapIndex)">
      <summary>Restituisce le dimensioni dell'heap specificato.</summary>
      <param name="reader" />
      <param name="heapIndex" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="heapIndex" /> non è un indice di heap valido.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.BlobHandle)">
      <summary>Restituisce l'handle per il <see cref="T:System.Reflection.Metadata.Blob" /> che segue quello specificato nell'heap <see cref="T:System.Reflection.Metadata.Blob" /> o un handle Null se è l'ultimo.</summary>
      <param name="reader" />
      <param name="handle" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> è <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.StringHandle)">
      <summary>Restituisce un handle per la stringa che segue quella specificata nell'heap delle stringhe oppure un handle Null se è l'ultima.</summary>
      <param name="reader" />
      <param name="handle" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> è <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.UserStringHandle)">
      <summary>Restituisce un handle per il valore UserString che segue quello specificato nell'heap UserString oppure un handle Null se è l'ultimo.</summary>
      <param name="reader" />
      <param name="handle" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> è <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableMetadataOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary>Restituisce l'offset dall'inizio dei metadati alla tabella specificata.</summary>
      <param name="reader" />
      <param name="tableIndex" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="tableIndex" /> non è un indice di tabella valido.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableRowCount(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary>Restituisce il numero di righe nella tabella specificata.</summary>
      <param name="reader" />
      <param name="tableIndex" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="tableIndex" /> non è un indice di tabella valido.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableRowSize(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary>Restituisce le dimensioni di una riga nella tabella specificata.</summary>
      <param name="reader" />
      <param name="tableIndex" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="tableIndex" /> non è un indice di tabella valido.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTypesWithEvents(System.Reflection.Metadata.MetadataReader)">
      <summary>Enumera i tipi che definiscono uno o più eventi.</summary>
      <param name="reader" />
      <returns>La sequenza risultante corrisponde esattamente alle voci nella tabella EventMap, ad esempio l'ennesimo <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> restituito viene archiviato nell'ennesima riga di EventMap.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTypesWithProperties(System.Reflection.Metadata.MetadataReader)">
      <summary>Enumera i tipi che definiscono una o più proprietà.</summary>
      <param name="reader" />
      <returns>La sequenza risultante corrisponde esattamente alle voci nella tabella della mappa delle proprietà, ovvero l'ennesimo <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> restituito viene archiviato nell'ennesima riga della mappa delle proprietà.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)">
      <summary>Dato un handle di tipo e un tipo non elaborato trovato in un BLOB di firma, determina se il tipo di destinazione è un tipo valore o un tipo riferimento.</summary>
      <param name="reader" />
      <param name="typeHandle" />
      <param name="rawTypeKind" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataRootBuilder">
      <summary>Generatore di una radice dei metadati da incorporare in un'immagine eseguibile di tipo PE.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.#ctor(System.Reflection.Metadata.Ecma335.MetadataBuilder,System.String,System.Boolean)">
      <summary>Crea un generatore di una radice dei metadati.</summary>
      <param name="tablesAndHeaps">Generatore popolato con entità di metadati archiviate in tabelle e valori archiviati in heap. Le entità e i valori verranno enumerati durante la serializzazione della radice dei metadati.</param>
      <param name="metadataVersion">Stringa di versione scritta nell'intestazione dei metadati. Il valore predefinito è "v4.0.30319".</param>
      <param name="suppressValidation">
        <see langword="true" /> per disattivare la convalida di base delle tabelle dei metadati durante la serializzazione. In caso contrario, <paramref name="false" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="tablesAndHeaps" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="metadataVersion" /> è troppo lungo (il numero di byte con la codifica UTF8 deve essere minore di 255).</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.Serialize(System.Reflection.Metadata.BlobBuilder,System.Int32,System.Int32)">
      <summary>Serializza il contenuto della radice dei metadati nel <see cref="T:System.Reflection.Metadata.BlobBuilder" /> specificato.</summary>
      <param name="builder">Generatore in cui scrivere.</param>
      <param name="methodBodyStreamRva">Indirizzo virtuale relativo dell'inizio del flusso del corpo del metodo. Usato per calcolare il valore finale dei campi RVA della tabella MethodDef.</param>
      <param name="mappedFieldDataStreamRva">Indirizzo virtuale relativo dell'inizio del flusso di dati di inizializzazione dei campi. Usato per calcolare il valore finale dei campi RVA della tabella FieldRVA.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="builder" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="methodBodyStreamRva" /> o <paramref name="mappedFieldDataStreamRva" /> è negativo.</exception>
      <exception cref="T:System.InvalidOperationException">Una tabella di metadati non è ordinata come richiesto dalla specifica e <see cref="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.SuppressValidation" /> è <see langword="false" />.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.MetadataVersion">
      <summary>Versione dei metadati.</summary>
      <returns>Stringa che rappresenta la versione dei metadati.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.Sizes">
      <summary>Restituisce le dimensioni di varie strutture di metadati.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.SuppressValidation">
      <summary>Determina se la convalida di base delle tabelle di metadati deve essere disattivata. La convalida verifica che le voci nelle tabelle siano state aggiunte nell'ordine richiesto dalla specifica ECMA. Non applica tutti i requisiti della specifica alle tabelle di metadati.</summary>
      <returns>
        <see langword="true" /> per disattivare la convalida di base delle tabelle di metadati; in caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataSizes">
      <summary>Specifica informazioni sulle dimensioni di varie strutture di metadati.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataSizes.GetAlignedHeapSize(System.Reflection.Metadata.Ecma335.HeapIndex)">
      <summary>Restituisce le dimensioni allineate dell'heap specificato.</summary>
      <param name="index" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataSizes.ExternalRowCounts">
      <summary>Conteggio delle righe della tabella esterna.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataSizes.HeapSizes">
      <summary>Dimensioni dell'heap esatte (non allineate).</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataSizes.RowCounts">
      <summary>Conteggi di righe della tabella.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataTokens" />
    <member name="F:System.Reflection.Metadata.Ecma335.MetadataTokens.HeapCount">
      <summary>Numero massimo di tabelle che possono essere presenti nei metadati Ecma335.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount">
      <summary>Numero massimo di tabelle che possono essere presenti nei metadati Ecma335.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.AssemblyFileHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.AssemblyReferenceHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.BlobHandle(System.Int32)">
      <param name="offset" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ConstantHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.CustomAttributeHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.CustomDebugInformationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.DeclarativeSecurityAttributeHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.DocumentHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.DocumentNameBlobHandle(System.Int32)">
      <param name="offset" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.EntityHandle(System.Int32)">
      <summary>Crea un handle di entità da un valore di token.</summary>
      <param name="token" />
      <exception cref="T:System.ArgumentException">
        <paramref name="token" /> non è un token di entità dei metadati valido.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.EntityHandle(System.Reflection.Metadata.Ecma335.TableIndex,System.Int32)">
      <summary>Crea un <see cref="T:System.Reflection.Metadata.EntityHandle" /> da un valore di token.</summary>
      <param name="tableIndex" />
      <param name="rowNumber" />
      <exception cref="T:System.ArgumentException">
        <paramref name="tableIndex" /> non è un indice di tabella valido.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.EventDefinitionHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ExportedTypeHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.FieldDefinitionHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GenericParameterConstraintHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GenericParameterHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.BlobHandle)">
      <summary>Ottiene l'offset dei dati dell'heap dei metadati che corrispondono all'<paramref name="handle" /> specificato.</summary>
      <param name="handle" />
      <returns>Offset in base zero oppure -1 se <paramref name="handle" /> può essere interpretato solo nel contesto di un <see cref="T:System.Reflection.Metadata.MetadataReader" /> o <see cref="T:System.Reflection.Metadata.Ecma335.MetadataBuilder" /> specifico.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.GuidHandle)">
      <summary>Ottiene l'offset dei dati dell'heap dei metadati che corrispondono all'<paramref name="handle" /> specificato.</summary>
      <param name="handle" />
      <returns>Indice in base 1 nell'heap #Guid. A differenza di altri heap, che sono essenzialmente matrici di byte, l'heap #Guid è una matrice di GUID a 16 byte.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.Handle)">
      <summary>Ottiene l'offset dei dati dell'heap dei metadati che corrispondono all'<paramref name="handle" /> specificato.</summary>
      <param name="handle" />
      <returns>Offset nell'heap corrispondente oppure -1 se <paramref name="handle" /> può essere interpretato solo nel contesto di un <see cref="T:System.Reflection.Metadata.MetadataReader" /> o <see cref="T:System.Reflection.Metadata.Ecma335.MetadataBuilder" /> specifico.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Handle)">
      <summary>Ottiene l'offset dei dati dell'heap dei metadati che corrispondono all'<paramref name="handle" /> specificato nel contesto di <paramref name="reader" />.</summary>
      <param name="reader" />
      <param name="handle" />
      <exception cref="T:System.NotSupportedException">L'operazione non è supportata per l'oggetto <paramref name="handle" /> specificato.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="handle" /> non è valido.</exception>
      <returns>Offset in base zero oppure -1 se <paramref name="handle" /> non è un handle dell'heap dei metadati.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.StringHandle)">
      <summary>Ottiene l'offset dei dati dell'heap dei metadati che corrispondono all'<paramref name="handle" /> specificato.</summary>
      <param name="handle" />
      <returns>Offset in base zero oppure -1 se <paramref name="handle" /> può essere interpretato nel contesto di un <see cref="T:System.Reflection.Metadata.MetadataReader" /> o <see cref="T:System.Reflection.Metadata.Ecma335.MetadataBuilder" /> specifico.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.UserStringHandle)">
      <summary>Ottiene l'offset dei dati dell'heap dei metadati che corrispondono all'<paramref name="handle" /> specificato.</summary>
      <param name="handle" />
      <returns>Offset in base zero.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.EntityHandle)">
      <summary>Ottiene il numero di riga di una voce della tabella di metadati che corrisponde all'<paramref name="handle" /> specificato.</summary>
      <param name="handle" />
      <returns>Numero di riga in base uno oppure -1 se <paramref name="handle" /> può essere interpretato solo nel contesto di un <see cref="T:System.Reflection.Metadata.MetadataReader" /> specifico.
Vedere <see cref="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)">
      <summary>Ottiene il numero di riga di una voce della tabella di metadati che corrisponde all'<paramref name="handle" /> specificato nel contesto di <paramref name="reader" />.</summary>
      <param name="reader" />
      <param name="handle" />
      <exception cref="T:System.ArgumentException">
        <paramref name="handle" /> non è un handle di tabella dei metadati valido.</exception>
      <returns>Numero di riga in base uno.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.EntityHandle)">
      <summary>Ottiene il token di metadati dell'<paramref name="handle" /> specificato.</summary>
      <param name="handle" />
      <returns>Token di metadati oppure 0 se <paramref name="handle" /> può essere interpretato solo nel contesto di un <see cref="T:System.Reflection.Metadata.MetadataReader" /> specifico.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.Handle)">
      <summary>Ottiene il token di metadati dell'<paramref name="handle" /> specificato.</summary>
      <param name="handle" />
      <exception cref="T:System.ArgumentException">L'handle rappresenta un'entità di metadati che non include un token.
Un token può essere recuperato solo per un handle di tabella di metadati o un handle di heap di tipo <see cref="F:System.Reflection.Metadata.HandleKind.UserString" />.</exception>
      <returns>Token di metadati oppure 0 se <paramref name="handle" /> può essere interpretato solo nel contesto di un <see cref="T:System.Reflection.Metadata.MetadataReader" /> specifico.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)">
      <summary>Ottiene il token di metadati dell'<paramref name="handle" /> specificato nel contesto di <paramref name="reader" />.</summary>
      <param name="reader" />
      <param name="handle" />
      <exception cref="T:System.NotSupportedException">L'operazione non è supportata per l'oggetto <paramref name="handle" /> specificato.</exception>
      <returns>Token di metadati.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Handle)">
      <summary>Ottiene il token di metadati dell'<paramref name="handle" /> specificato nel contesto di <paramref name="reader" />.</summary>
      <param name="reader" />
      <param name="handle" />
      <exception cref="T:System.ArgumentException">L'handle rappresenta un'entità di metadati che non include un token.
Un token può essere recuperato solo per un handle di tabella di metadati o un handle di heap di tipo <see cref="F:System.Reflection.Metadata.HandleKind.UserString" />.</exception>
      <exception cref="T:System.NotSupportedException">L'operazione non è supportata per l'oggetto <paramref name="handle" /> specificato.</exception>
      <returns>Token di metadati.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GuidHandle(System.Int32)">
      <param name="offset" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.Handle(System.Int32)">
      <summary>Crea un handle da un valore di token.</summary>
      <param name="token" />
      <exception cref="T:System.ArgumentException">
        <paramref name="token" /> non è un token di metadati valido.
Deve codificare un'entità di tabella di metadati o un offset nell'heap <see cref="F:System.Reflection.Metadata.HandleKind.UserString" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.Handle(System.Reflection.Metadata.Ecma335.TableIndex,System.Int32)">
      <summary>Crea un <see cref="T:System.Reflection.Metadata.EntityHandle" /> da un valore di token.</summary>
      <param name="tableIndex" />
      <param name="rowNumber" />
      <exception cref="T:System.ArgumentException">
        <paramref name="tableIndex" /> non è un indice di tabella valido.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ImportScopeHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.InterfaceImplementationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.LocalConstantHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.LocalScopeHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.LocalVariableHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ManifestResourceHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MemberReferenceHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDebugInformationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDefinitionHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodImplementationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodSpecificationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ModuleReferenceHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ParameterHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.PropertyDefinitionHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.StandaloneSignatureHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.StringHandle(System.Int32)">
      <param name="offset" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TryGetHeapIndex(System.Reflection.Metadata.HandleKind,System.Reflection.Metadata.Ecma335.HeapIndex@)">
      <summary>Ottiene l'<see cref="T:System.Reflection.Metadata.Ecma335.HeapIndex" /> dell'heap corrispondente all'<see cref="T:System.Reflection.Metadata.HandleKind" /> specificato.</summary>
      <param name="type">Tipo di handle.</param>
      <param name="index">Indice dell'heap.</param>
      <returns>
        <see langword="true" /> se il tipo di handle corrisponde a un heap Ecma335. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TryGetTableIndex(System.Reflection.Metadata.HandleKind,System.Reflection.Metadata.Ecma335.TableIndex@)">
      <summary>Ottiene il <see cref="T:System.Reflection.Metadata.Ecma335.TableIndex" /> della tabella corrispondente all'<see cref="T:System.Reflection.Metadata.HandleKind" /> specificato.</summary>
      <param name="type">Tipo di handle.</param>
      <param name="index">Indice della tabella.</param>
      <returns>
        <see langword="true" /> se il tipo di handle corrisponde a una tabella Ecma335 o PDB portatile. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TypeDefinitionHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TypeReferenceHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TypeSpecificationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.UserStringHandle(System.Int32)">
      <param name="offset" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MethodBodyAttributes">
      <summary>Definisce gli attributi del corpo del metodo.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MethodBodyAttributes.InitLocals">
      <summary>Inizializza le variabili locali che il metodo imposta su zero e alloca in modo dinamico la memoria locale.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MethodBodyAttributes.None">
      <summary>Non esegue l'inizializzazione della memoria locale.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder">
      <summary>Offre un codificatore per il flusso dei corpi dei metodi.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Int32,System.Int32,System.Int32,System.Boolean,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes)">
      <summary>Codifica il corpo di un metodo e lo aggiunge al flusso dei corpi dei metodi, usando la dimensione del codice, la dimensione massima dello stack, il numero di aree di eccezione, l'handle di firma delle variabili locali e gli attributi del corpo del metodo specificati e consentendo di indicare se le aree di eccezione devono essere codificate in formato ridotto o meno.</summary>
      <param name="codeSize">Numero di byte da riservare per le istruzioni.</param>
      <param name="maxStack">Dimensione massima dello stack.</param>
      <param name="exceptionRegionCount">Numero delle aree di eccezione.</param>
      <param name="hasSmallExceptionRegions">
        <see langword="true" /> se le aree di eccezione devono essere codificate in formato ridotto; in caso contrario, <see langword="false" />.</param>
      <param name="localVariablesSignature">Handle della firma della variabile locale.</param>
      <param name="attributes">Attributi del corpo del metodo.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="codeSize" />, <paramref name="exceptionRegionCount" /> o <paramref name="maxStack" /> non è compreso nell'intervallo consentito.</exception>
      <returns>Offset del corpo codificato nel flusso dei corpi dei metodi.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Int32,System.Int32,System.Int32,System.Boolean,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes,System.Boolean)">
      <summary>Codifica il corpo di un metodo e lo aggiunge al flusso dei corpi dei metodi, usando la dimensione del codice, la dimensione massima dello stack, il numero di aree di eccezione, l'handle di firma delle variabili locali e gli attributi del corpo del metodo specificati, consentendo di indicare se le aree di eccezione devono essere codificate in formato ridotto o meno e se il metodo deve eseguire le allocazioni dal pool della memoria locale dinamica o meno.</summary>
      <param name="codeSize">Numero di byte da riservare per le istruzioni.</param>
      <param name="maxStack">Dimensione massima dello stack.</param>
      <param name="exceptionRegionCount">Numero delle aree di eccezione.</param>
      <param name="hasSmallExceptionRegions">
        <see langword="true" /> se le aree di eccezione devono essere codificate in formato ridotto; in caso contrario, <see langword="false" />.</param>
      <param name="localVariablesSignature">Handle della firma della variabile locale.</param>
      <param name="attributes">Attributi del corpo del metodo.</param>
      <param name="hasDynamicStackAllocation">
        <see langword="true" /> se il metodo esegue le allocazioni dal pool della memoria locale dinamica (istruzione <see langword="localloc" />); in caso contrario, <see langword="false" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="codeSize" />, <paramref name="exceptionRegionCount" /> o <paramref name="maxStack" /> non è compreso nell'intervallo consentito.</exception>
      <returns>Offset del corpo codificato nel flusso dei corpi dei metodi.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Reflection.Metadata.Ecma335.InstructionEncoder,System.Int32,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes)">
      <summary>Codifica il corpo di un metodo e lo aggiunge al flusso dei corpi dei metodi.</summary>
      <param name="instructionEncoder">Codificatore di istruzioni.</param>
      <param name="maxStack">Dimensione massima dello stack.</param>
      <param name="localVariablesSignature">Handle della firma della variabile locale.</param>
      <param name="attributes">Attributi del corpo del metodo.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="instructionEncoder" /> ha un valore predefinito.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="maxStack" /> non è compreso nell'intervallo [0, <see cref="F:System.UInt16.MaxValue" />].</exception>
      <exception cref="T:System.InvalidOperationException">Un'etichetta scelta come destinazione in base a un ramo nel flusso di istruzioni non è stata contrassegnata oppure la distanza tra un'istruzione del ramo e l'etichetta di destinazione non corrisponde alle dimensioni dell'operando dell'istruzione.</exception>
      <returns>Offset del corpo codificato nel flusso dei corpi dei metodi.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Reflection.Metadata.Ecma335.InstructionEncoder,System.Int32,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes,System.Boolean)">
      <summary>Codifica il corpo di un metodo e lo aggiunge al flusso dei corpi dei metodi, usando il codificatore di istruzioni, la dimensione massima dello stack, l'handle di firma delle variabili locali e gli attributi del corpo del metodo specificati e consentendo di indicare se il metodo deve eseguire allocazioni dal pool della memoria locale dinamica o meno.</summary>
      <param name="instructionEncoder">Codificatore di istruzioni.</param>
      <param name="maxStack">Dimensione massima dello stack.</param>
      <param name="localVariablesSignature">Handle della firma della variabile locale.</param>
      <param name="attributes">Attributi del corpo del metodo.</param>
      <param name="hasDynamicStackAllocation">
        <see langword="true" /> se il metodo esegue le allocazioni dal pool della memoria locale dinamica (IL contiene l'istruzione <see langword="localloc" />); in caso contrario, <see langword="false" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="instructionEncoder" /> ha un valore predefinito.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="maxStack" /> non è compreso nell'intervallo [0, <see cref="F:System.UInt16.MaxValue" />].</exception>
      <exception cref="T:System.InvalidOperationException">Un'etichetta scelta come destinazione in base a un ramo nel flusso di istruzioni non è stata contrassegnata oppure la distanza tra un'istruzione del ramo e l'etichetta di destinazione non corrisponde alle dimensioni dell'operando dell'istruzione.</exception>
      <returns>Offset del corpo codificato nel flusso dei corpi dei metodi.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody">
      <summary>Descrive il corpo di un metodo. Questa classe è destinata a essere usata insieme alla classe <see cref="T:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder" />.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody.ExceptionRegions">
      <summary>Ottiene un oggetto codificatore che può essere usato per codificare le aree di eccezione nel corpo del metodo.</summary>
      <returns>Istanza del codificatore di area di eccezione.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody.Instructions">
      <summary>Ottiene un BLOB riservato per le istruzioni.</summary>
      <returns>Un BLOB riservato per le istruzioni.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody.Offset">
      <summary>Ottiene l'offset del corpo del metodo codificato nel flusso del corpo del metodo.</summary>
      <returns>Offset del corpo del metodo codificato nel flusso del corpo del metodo.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder">
      <summary>Fornisce un codificatore per le firme dei metodi.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.#ctor(System.Reflection.Metadata.BlobBuilder,System.Boolean)">
      <param name="builder" />
      <param name="hasVarArgs" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.Parameters(System.Int32,System.Action{System.Reflection.Metadata.Ecma335.ReturnTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.ParametersEncoder})">
      <summary>Codifica il tipo restituito e i parametri specificati.</summary>
      <param name="parameterCount">Numero di parametri.</param>
      <param name="returnType">Metodo chiamato per primo per codificare il tipo restituito.</param>
      <param name="parameters">Metodo chiamato per secondo per codificare i parametri.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="returnType" /> o <paramref name="parameters" /> è <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.Parameters(System.Int32,System.Reflection.Metadata.Ecma335.ReturnTypeEncoder@,System.Reflection.Metadata.Ecma335.ParametersEncoder@)">
      <summary>Codifica il tipo restituito e i parametri specificati, che devono essere usati nell'ordine in cui sono visualizzati nell'elenco dei parametri.</summary>
      <param name="parameterCount">Numero di parametri.</param>
      <param name="returnType">Metodo chiamato per primo per codificare i tipi restituiti.</param>
      <param name="parameters">Metodo chiamato per secondo per codificare i parametri.</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.Builder" />
    <member name="P:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.HasVarArgs" />
    <member name="T:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <summary>Inizializza una nuova istanza della struttura <see cref="T:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder" />.</summary>
      <param name="builder">Generatore per la codifica dell'argomento denominato.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.AddArgument(System.Boolean,System.Action{System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.NameEncoder},System.Action{System.Reflection.Metadata.Ecma335.LiteralEncoder})">
      <summary>Codifica un argomento denominato (un campo o una proprietà).</summary>
      <param name="isField">
        <see langword="true" /> per codificare un campo, <see langword="false" /> per codificare una proprietà.</param>
      <param name="type">Metodo da chiamare per primo per codificare il tipo dell'argomento.</param>
      <param name="name">Metodo da chiamare per secondo per codificare il nome del campo o della proprietà.</param>
      <param name="literal">Metodo da chiamare per terzo per codificare il valore letterale dell'argomento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" />, <paramref name="name" /> o <paramref name="literal" /> è <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.AddArgument(System.Boolean,System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder@,System.Reflection.Metadata.Ecma335.NameEncoder@,System.Reflection.Metadata.Ecma335.LiteralEncoder@)">
      <summary>Codifica un argomento denominato (un campo o una proprietà) e restituisce tre codificatori che devono essere usati nell'ordine in cui sono visualizzati nell'elenco dei parametri.</summary>
      <param name="isField">
        <see langword="true" /> per codificare un campo, <see langword="false" /> per codificare una proprietà.</param>
      <param name="type">Metodo da chiamare per primo per codificare il tipo dell'argomento.</param>
      <param name="name">Metodo da chiamare per secondo per codificare il nome del campo o della proprietà.</param>
      <param name="literal">Metodo da chiamare per terzo per codificare il valore letterale dell'argomento.</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.Object" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.ScalarType" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.SZArray" />
    <member name="P:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.NameEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NameEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.NameEncoder.Name(System.String)">
      <param name="name" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.NameEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.ParametersEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParametersEncoder.#ctor(System.Reflection.Metadata.BlobBuilder,System.Boolean)">
      <param name="builder" />
      <param name="hasVarArgs" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ParametersEncoder.AddParameter" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParametersEncoder.StartVarArgs" />
    <member name="P:System.Reflection.Metadata.Ecma335.ParametersEncoder.Builder" />
    <member name="P:System.Reflection.Metadata.Ecma335.ParametersEncoder.HasVarArgs" />
    <member name="T:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.CustomModifiers" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.Type(System.Boolean)">
      <param name="isByRef" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.TypedReference" />
    <member name="P:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.PermissionSetEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.AddPermission(System.String,System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="typeName" />
      <param name="encodedArguments" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.AddPermission(System.String,System.Reflection.Metadata.BlobBuilder)">
      <param name="typeName" />
      <param name="encodedArguments" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.PortablePdbBuilder">
      <summary>Rappresenta il generatore di un'immagine PDB portatile.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.#ctor(System.Reflection.Metadata.Ecma335.MetadataBuilder,System.Collections.Immutable.ImmutableArray{System.Int32},System.Reflection.Metadata.MethodDefinitionHandle,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Reflection.Metadata.BlobContentId})">
      <summary>Crea un generatore di un'immagine PDB portatile.</summary>
      <param name="tablesAndHeaps">Un generatore popolato con entità di metadati di debug archiviate in tabelle e valori archiviati in heap. Le entità e i valori vengono enumerati durante la serializzazione dell'immagine PDB portatile.</param>
      <param name="typeSystemRowCounts">Conteggio delle righe di tutte le tabelle contenute nei metadati di sistema dei tipi associati. Ogni slot della matrice corrisponde a una tabella (<see cref="T:System.Reflection.Metadata.Ecma335.TableIndex" />). La lunghezza della matrice deve essere uguale a <see cref="F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount" />.</param>
      <param name="entryPoint">Handle di definizione di un metodo del punto di ingresso.</param>
      <param name="idProvider">Funzione che calcola l'ID del contenuto rappresentato come sequenza di BLOB. Se non specificata, funzione predefinita che ignora il contenuto e restituisce un ID contenuto basato sull'ora corrente usata (<see cref="M:System.Reflection.Metadata.BlobContentId.GetTimeBasedProvider" />). È necessario specificare una funzione deterministica per produrre un'immagine PDB portatile deterministica.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="tablesAndHeaps" /> o <paramref name="typeSystemRowCounts" /> è <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.Serialize(System.Reflection.Metadata.BlobBuilder)">
      <summary>Serializza il contenuto PDB portatile in <see cref="T:System.Reflection.Metadata.BlobBuilder" /> specificato.</summary>
      <param name="builder">Generatore in cui scrivere.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="builder" /> è <see langword="null" />.</exception>
      <returns>ID del contenuto serializzato.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.FormatVersion" />
    <member name="P:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.IdProvider" />
    <member name="P:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.MetadataVersion" />
    <member name="T:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.CustomModifiers" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.Type(System.Boolean)">
      <param name="isByRef" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.TypedReference" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.Void" />
    <member name="P:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.ScalarEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.Constant(System.Object)">
      <summary>Codifica il valore letterale di una costante.</summary>
      <param name="value">Costante di tipo <see cref="T:System.Boolean" />, <see cref="T:System.Byte" />, <see cref="T:System.SByte" />, <see cref="T:System.Int16" />, <see cref="T:System.UInt16" />, <see cref="T:System.Int32" />, <see cref="T:System.UInt32" />, <see cref="T:System.Int64" />, <see cref="T:System.UInt64" />, <see cref="T:System.Single" />, <see cref="T:System.Double" />, <see cref="T:System.Char" /> (codificata come carattere Unicode a due byte), <see cref="T:System.String" /> (codificata come SerString) o <see cref="T:System.Enum" /> (codificata come valore Integer sottostante).</param>
      <exception cref="T:System.ArgumentException">Tipo di costante non previsto.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.NullArray">
      <summary>Codifica un valore letterale <see langword="null" /> di tipo <see cref="T:System.Array" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.SystemType(System.String)">
      <summary>Codifica un valore letterale di tipo <see cref="T:System.Type" /> (che può essere probabilmente <see langword="null" />).</summary>
      <param name="serializedTypeName">Nome del tipo o <see langword="null" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="serializedTypeName" /> è vuoto.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ScalarEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.SignatureDecoder`2">
      <summary>Decodifica i BLOB di firma.</summary>
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.#ctor(System.Reflection.Metadata.ISignatureTypeProvider{`0,`1},System.Reflection.Metadata.MetadataReader,`1)">
      <summary>Crea un nuovo oggetto <see cref="T:System.Reflection.Metadata.Ecma335.SignatureDecoder`2" />.</summary>
      <param name="provider">Il provider usato per ottenere i simboli di tipo come firma è decodificato.</param>
      <param name="metadataReader">Lettore di metadati da cui è stata ottenuta la firma. Può essere <see langword="null" /> se il provider specificato lo consente.</param>
      <param name="genericContext">Contesto aggiuntivo necessario per la risoluzione dei parametri generici.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeFieldSignature(System.Reflection.Metadata.BlobReader@)">
      <summary>Decodifica il BLOB di firma di un campo e fa avanzare il lettore oltre la firma.</summary>
      <param name="blobReader">Lettore BLOB posizionato in corrispondenza di una firma di campo.</param>
      <returns>Tipo di campo decodificato.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeLocalSignature(System.Reflection.Metadata.BlobReader@)">
      <summary>Decodifica il BLOB di firma di una variabile locale e fa avanzare il lettore oltre la firma.</summary>
      <param name="blobReader">Lettore BLOB posizionato in corrispondenza di una firma di variabile locale.</param>
      <exception cref="T:System.BadImageFormatException">La firma della variabile locale non è valida.</exception>
      <returns>Tipi di variabile locale.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeMethodSignature(System.Reflection.Metadata.BlobReader@)">
      <summary>Decodifica il BLOB di firma di un metodo (definizione, riferimento o autonomo) o una proprietà.</summary>
      <param name="blobReader">Lettore BLOB posizionato in corrispondenza di una firma di metodo.</param>
      <exception cref="T:System.BadImageFormatException">La firma del metodo non è valida.</exception>
      <returns>Firma del metodo decodificata.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeMethodSpecificationSignature(System.Reflection.Metadata.BlobReader@)">
      <summary>Decodifica il BLOB di firma di specifica di un metodo e fa avanzare il lettore oltre la firma.</summary>
      <param name="blobReader">Un lettore BLOB posizionato in corrispondenza di una firma di specifica di metodo valida.</param>
      <returns>Tipi usati per creare un'istanza di un metodo generico tramite la specifica del metodo.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeType(System.Reflection.Metadata.BlobReader@,System.Boolean)">
      <summary>Decodifica un tipo incorporato in una firma e fa avanzare il lettore oltre il tipo.</summary>
      <param name="blobReader">Lettore BLOB posizionato in corrispondenza di <see cref="T:System.Reflection.Metadata.SignatureTypeCode" /> iniziale.</param>
      <param name="allowTypeSpecifications">
        <see langword="true" /> per consentire <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /> successivo a (CLASS | VALUETYPE) nella firma; <see langword="false" /> in caso contrario.</param>
      <exception cref="T:System.BadImageFormatException">Il lettore non è posizionato in corrispondenza di un tipo di firma valido.</exception>
      <returns>Tipo decodificato.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Array(System.Action{System.Reflection.Metadata.Ecma335.SignatureTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.ArrayShapeEncoder})">
      <summary>Codifica un tipo di matrice.</summary>
      <param name="elementType">Chiamato per primo, per codificare il tipo dell'elemento.</param>
      <param name="arrayShape">Chiamato per secondo, per codificare la forma della matrice.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="elementType" /> o <paramref name="arrayShape" /> è <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Array(System.Reflection.Metadata.Ecma335.SignatureTypeEncoder@,System.Reflection.Metadata.Ecma335.ArrayShapeEncoder@)">
      <summary>Codifica un tipo di matrice. Restituisce una coppia di codificatori che devono essere usati nell'ordine in cui sono visualizzati nell'elenco dei parametri.</summary>
      <param name="elementType">Usare per primo, per codificare il tipo dell'elemento.</param>
      <param name="arrayShape">Usare per secondo, per codificare la forma della matrice.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Boolean" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Byte" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Char" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.CustomModifiers">
      <summary>Avvia una firma di un tipo con modificatori personalizzati.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Double" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.FunctionPointer(System.Reflection.Metadata.SignatureCallingConvention,System.Reflection.Metadata.Ecma335.FunctionPointerAttributes,System.Int32)">
      <summary>Avvia una firma del puntatore a funzione.</summary>
      <param name="convention">Convenzione di chiamata.</param>
      <param name="attributes">Attributi del puntatore a funzione.</param>
      <param name="genericParameterCount">Conteggio parametri generici.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="attributes" /> non è valido.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="genericParameterCount" /> non è compreso nell'intervallo [0, 0xffff].</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.GenericInstantiation(System.Reflection.Metadata.EntityHandle,System.Int32,System.Boolean)">
      <summary>Avvia una firma di creazione di un'istanza generica.</summary>
      <param name="genericType">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> o <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />.</param>
      <param name="genericArgumentCount">Conteggio argomenti generici.</param>
      <param name="isValueType">
        <see langword="true" /> per contrassegnare il tipo come tipo di valore, <see langword="false" /> per contrassegnarlo come tipo di riferimento nella firma.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="genericType" /> non ha il tipo di handle previsto.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="genericArgumentCount" /> non è compreso nell'intervallo [1, 0xffff].</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.GenericMethodTypeParameter(System.Int32)">
      <summary>Codifica un riferimento al parametro di tipo di un metodo generico che lo contiene.</summary>
      <param name="parameterIndex">Indice di parametro.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="parameterIndex" /> non è compreso nell'intervallo [0, 0xffff].</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.GenericTypeParameter(System.Int32)">
      <summary>Codifica un riferimento al parametro di tipo di un tipo generico che lo contiene.</summary>
      <param name="parameterIndex">Indice di parametro.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="parameterIndex" /> non è compreso nell'intervallo [0, 0xffff].</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Int16" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Int32" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Int64" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.IntPtr" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Object" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Pointer">
      <summary>Avvia la firma del puntatore.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.PrimitiveType(System.Reflection.Metadata.PrimitiveTypeCode)">
      <summary>Scrive codice di tipo primitivo.</summary>
      <param name="type">Qualsiasi codice di tipo primitivo ad eccezione di <see cref="F:System.Reflection.Metadata.PrimitiveTypeCode.TypedReference" /> e <see cref="F:System.Reflection.Metadata.PrimitiveTypeCode.Void" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="type" /> non è valido in questo contesto.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.SByte" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Single" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.String" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.SZArray">
      <summary>Avvia la firma della matrice SZ (vettore).</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Type(System.Reflection.Metadata.EntityHandle,System.Boolean)">
      <summary>Codifica un riferimento a un tipo.</summary>
      <param name="type">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> o <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />.</param>
      <param name="isValueType">
        <see langword="true" /> per contrassegnare il tipo come tipo di valore, <see langword="false" /> per contrassegnarlo come tipo di riferimento nella firma.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="type" /> non ha il tipo di handle previsto.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UInt16" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UInt32" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UInt64" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UIntPtr" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.VoidPointer">
      <summary>Codifica un puntatore void (<c>void*</c>).</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.TableIndex" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Assembly" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyOS" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyProcessor" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyRefOS" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyRefProcessor" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ClassLayout" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Constant" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.CustomAttribute" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.CustomDebugInformation" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.DeclSecurity" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Document" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EncLog" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EncMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Event" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EventMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EventPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ExportedType" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Field" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldLayout" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldMarshal" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldRva" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.File" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.GenericParam" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.GenericParamConstraint" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ImplMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ImportScope" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.InterfaceImpl" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.LocalConstant" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.LocalScope" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.LocalVariable" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ManifestResource" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MemberRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodDebugInformation" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodDef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodImpl" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodSemantics" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodSpec" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Module" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ModuleRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.NestedClass" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Param" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ParamPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Property" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.PropertyMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.PropertyPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.StandAloneSig" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.StateMachineMethod" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.TypeDef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.TypeRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.TypeSpec" />
    <member name="T:System.Reflection.Metadata.Ecma335.VectorEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.VectorEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.VectorEncoder.Count(System.Int32)">
      <param name="count" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.VectorEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.EntityHandle">
      <summary>Rappresenta un'entità di metadati, ad esempio un riferimento a un tipo, una definizione di tipo, una specifica di tipo, una definizione di metodo o un attributo personalizzato.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.EntityHandle.AssemblyDefinition" />
    <member name="F:System.Reflection.Metadata.EntityHandle.ModuleDefinition" />
    <member name="M:System.Reflection.Metadata.EntityHandle.Equals(System.Object)">
      <summary>Restituisce un valore che indica se l'istanza corrente e l'oggetto specificato sono uguali.</summary>
      <param name="obj">Oggetto da confrontare con l'istanza corrente.</param>
      <returns>
        <see langword="true" /> se <paramref name="obj" /> è un <see cref="T:System.Reflection.Metadata.EntityHandle" /> ed è uguale all'istanza corrente. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.Equals(System.Reflection.Metadata.EntityHandle)">
      <summary>Restituisce un valore che indica se l'istanza corrente e l'oggetto <see cref="T:System.Reflection.Metadata.EntityHandle" /> specificato sono uguali.</summary>
      <param name="other">Valore da confrontare con l'istanza corrente.</param>
      <returns>
        <see langword="true" /> se l'istanza corrente è uguale a <paramref name="other" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.GetHashCode">
      <summary>Restituisce il codice hash per l'istanza.</summary>
      <returns>Codice hash per l'istanza.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Equality(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Implicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Inequality(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.EntityHandle.IsNil" />
    <member name="P:System.Reflection.Metadata.EntityHandle.Kind" />
    <member name="T:System.Reflection.Metadata.EventAccessors" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Adder" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Others" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Raiser" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Remover" />
    <member name="T:System.Reflection.Metadata.EventDefinition" />
    <member name="M:System.Reflection.Metadata.EventDefinition.GetAccessors" />
    <member name="M:System.Reflection.Metadata.EventDefinition.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.EventDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.EventDefinition.Name" />
    <member name="P:System.Reflection.Metadata.EventDefinition.Type" />
    <member name="T:System.Reflection.Metadata.EventDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.Equals(System.Reflection.Metadata.EventDefinitionHandle)">
      <summary>Indica se l'oggetto corrente è uguale a un altro oggetto dello stesso tipo.</summary>
      <param name="other">Oggetto da confrontare con l'oggetto corrente.</param>
      <returns>
        <see langword="true" /> se l'oggetto corrente è uguale al parametro <paramref name="other" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Equality(System.Reflection.Metadata.EventDefinitionHandle,System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.EventDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.EventDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Implicit(System.Reflection.Metadata.EventDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Implicit(System.Reflection.Metadata.EventDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Inequality(System.Reflection.Metadata.EventDefinitionHandle,System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.EventDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.EventDefinitionHandleCollection" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#EventDefinitionHandle}#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di scorrere la raccolta.</summary>
      <returns>Enumeratore che può essere usato per scorrere la raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di eseguire l'iterazione di una raccolta.</summary>
      <returns>Oggetto <see cref="T:System.Collections.IEnumerator" /> che può essere usato per eseguire l'iterazione della raccolta.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.EventDefinitionHandleCollection.Count">
      <summary>Ottiene il numero di elementi nella raccolta.</summary>
      <returns>Numero di elementi contenuti nella raccolta.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.MoveNext">
      <summary>Sposta l'enumeratore all'elemento successivo della raccolta.</summary>
      <returns>
        <see langword="true" /> se l'enumeratore è stato spostato correttamente in avanti in corrispondenza dell'elemento successivo, <see langword="false" /> se l'enumeratore ha superato la fine della raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Imposta l'enumeratore sulla propria posizione iniziale, ovvero prima del primo elemento nella raccolta.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Esegue attività definite dall'applicazione, come rilasciare o reimpostare risorse non gestite.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ExceptionRegion" />
    <member name="P:System.Reflection.Metadata.ExceptionRegion.CatchType">
      <summary>Ottiene un handle TypeRef, TypeDef o TypeSpec se l'area rappresenta un catch oppure un token nil in caso contrario (<see langword="default" />(<see cref="T:System.Reflection.Metadata.EntityHandle" />)).</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.FilterOffset">
      <summary>Ottiene l'offset IL dell'inizio del blocco del filtro oppure -1 se l'area non è un filtro.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.HandlerLength">
      <summary>Ottiene la lunghezza, in byte, del gestore eccezioni.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.HandlerOffset">
      <summary>Ottiene l'offset IL iniziale del gestore eccezioni.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.Kind" />
    <member name="P:System.Reflection.Metadata.ExceptionRegion.TryLength">
      <summary>Ottiene la lunghezza, in byte, del blocco try.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.TryOffset">
      <summary>Ottiene l'offset IL iniziale del blocco try.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ExceptionRegionKind" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Catch" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Fault" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Filter" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Finally" />
    <member name="T:System.Reflection.Metadata.ExportedType" />
    <member name="M:System.Reflection.Metadata.ExportedType.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ExportedType.Attributes" />
    <member name="P:System.Reflection.Metadata.ExportedType.Implementation">
      <summary>Ottiene un handle per risolvere l'implementazione del tipo di destinazione.</summary>
      <returns>
        <list type="bullet">
          <item>
            <description>
              <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" /> che rappresenta un altro modulo nell'assembly.</description>
          </item>
          <item>
            <description>
              <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" /> che rappresenta un altro assembly se <see cref="P:System.Reflection.Metadata.ExportedType.IsForwarder" /> è <see langword="true" /> .</description>
          </item>
          <item>
            <description>
              <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" /> oggetto che rappresenta il tipo di dichiarazione esportato in cui è annidato.</description>
          </item>
        </list>
      </returns>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedType.IsForwarder" />
    <member name="P:System.Reflection.Metadata.ExportedType.Name">
      <summary>Ottiene il nome del tipo di destinazione oppure <see langword="default" /> se il tipo è annidato o definito in uno spazio dei nomi radice.</summary>
      <returns>
        <see cref="T:System.Reflection.Metadata.StringHandle" />Istanza struct.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedType.Namespace">
      <summary>Ottiene il nome completo dello spazio dei nomi contenente il tipo di destinazione oppure <see langword="default" /> se il tipo è annidato o definito in uno spazio dei nomi radice.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedType.NamespaceDefinition">
      <summary>Ottiene l'handle di definizione dello spazio dei nomi in cui è definito il tipo di destinazione oppure <see langword="default" /> se il tipo è annidato o definito in uno spazio dei nomi radice.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ExportedTypeHandle" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.Equals(System.Reflection.Metadata.ExportedTypeHandle)">
      <summary>Indica se l'oggetto corrente è uguale a un altro oggetto dello stesso tipo.</summary>
      <param name="other">Oggetto da confrontare con l'oggetto corrente.</param>
      <returns>
        <see langword="true" /> se l'oggetto corrente è uguale al parametro <paramref name="other" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Equality(System.Reflection.Metadata.ExportedTypeHandle,System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ExportedTypeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ExportedTypeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Implicit(System.Reflection.Metadata.ExportedTypeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Implicit(System.Reflection.Metadata.ExportedTypeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Inequality(System.Reflection.Metadata.ExportedTypeHandle,System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.ExportedTypeHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ExportedTypeHandleCollection">
      <summary>Rappresenta una raccolta di istanze di <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ExportedTypeHandle}#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di scorrere la raccolta.</summary>
      <returns>Enumeratore che può essere usato per scorrere la raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di eseguire l'iterazione di una raccolta.</summary>
      <returns>Oggetto <see cref="T:System.Collections.IEnumerator" /> che può essere usato per eseguire l'iterazione della raccolta.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedTypeHandleCollection.Count">
      <summary>Ottiene il numero di elementi nella raccolta.</summary>
      <returns>Numero di elementi contenuti nella raccolta.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.MoveNext">
      <summary>Sposta l'enumeratore all'elemento successivo della raccolta.</summary>
      <returns>
        <see langword="true" /> se l'enumeratore è stato spostato correttamente in avanti in corrispondenza dell'elemento successivo, <see langword="false" /> se l'enumeratore ha superato la fine della raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Imposta l'enumeratore sulla propria posizione iniziale, ovvero prima del primo elemento nella raccolta.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Esegue attività definite dall'applicazione, come rilasciare o reimpostare risorse non gestite.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.FieldDefinition" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetDeclaringType" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetDefaultValue" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetMarshallingDescriptor" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetOffset">
      <summary>Restituisce l'offset di layout di campo oppure, se questo non è disponibile, restituisce -1.</summary>
      <returns>Offset di layout di campo oppure, se questo non è disponibile, -1.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetRelativeVirtualAddress" />
    <member name="P:System.Reflection.Metadata.FieldDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.FieldDefinition.Name" />
    <member name="P:System.Reflection.Metadata.FieldDefinition.Signature" />
    <member name="T:System.Reflection.Metadata.FieldDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.Equals(System.Reflection.Metadata.FieldDefinitionHandle)">
      <summary>Indica se l'oggetto corrente è uguale a un altro oggetto dello stesso tipo.</summary>
      <param name="other">Oggetto da confrontare con l'oggetto corrente.</param>
      <returns>
        <see langword="true" /> se l'oggetto corrente è uguale al parametro <paramref name="other" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Equality(System.Reflection.Metadata.FieldDefinitionHandle,System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.FieldDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.FieldDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Implicit(System.Reflection.Metadata.FieldDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Implicit(System.Reflection.Metadata.FieldDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Inequality(System.Reflection.Metadata.FieldDefinitionHandle,System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.FieldDefinitionHandleCollection" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#FieldDefinitionHandle}#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di scorrere la raccolta.</summary>
      <returns>Enumeratore che può essere usato per scorrere la raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di eseguire l'iterazione di una raccolta.</summary>
      <returns>Oggetto <see cref="T:System.Collections.IEnumerator" /> che può essere usato per eseguire l'iterazione della raccolta.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandleCollection.Count">
      <summary>Ottiene il numero di elementi nella raccolta.</summary>
      <returns>Numero di elementi contenuti nella raccolta.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.MoveNext">
      <summary>Sposta l'enumeratore all'elemento successivo della raccolta.</summary>
      <returns>
        <see langword="true" /> se l'enumeratore è stato spostato correttamente in avanti in corrispondenza dell'elemento successivo, <see langword="false" /> se l'enumeratore ha superato la fine della raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Imposta l'enumeratore sulla propria posizione iniziale, ovvero prima del primo elemento nella raccolta.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Esegue attività definite dall'applicazione, come rilasciare o reimpostare risorse non gestite.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameter" />
    <member name="M:System.Reflection.Metadata.GenericParameter.GetConstraints" />
    <member name="M:System.Reflection.Metadata.GenericParameter.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.GenericParameter.Attributes">
      <summary>Ottiene gli attributi che specificano la varianza e i vincoli.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameter.Index">
      <summary>Ottiene l'indice in base zero del parametro all'interno della dichiarazione di tipo o metodo generico.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameter.Name">
      <summary>Ottiene il nome del parametro generico.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameter.Parent">
      <summary>Ottiene un oggetto <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> o <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> che rappresenta l'oggetto padre del parametro generico.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterConstraint" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraint.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.GenericParameterConstraint.Parameter">
      <summary>Ottiene l'oggetto <see cref="T:System.Reflection.Metadata.GenericParameterHandle" /> vincolato.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraint.Type">
      <summary>Ottiene un handle (<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> o <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />) che specifica da quale tipo il parametro generico è vincolato a derivare o quale interfaccia il parametro generico è vincolato a implementare.</summary>
      <returns>Istanza di <see cref="T:System.Reflection.Metadata.EntityHandle" />.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterConstraintHandle" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.Equals(System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <summary>Indica se l'oggetto corrente è uguale a un altro oggetto dello stesso tipo.</summary>
      <param name="other">Oggetto da confrontare con l'oggetto corrente.</param>
      <returns>
        <see langword="true" /> se l'oggetto corrente è uguale al parametro <paramref name="other" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Equality(System.Reflection.Metadata.GenericParameterConstraintHandle,System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.GenericParameterConstraintHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.GenericParameterConstraintHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Implicit(System.Reflection.Metadata.GenericParameterConstraintHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Implicit(System.Reflection.Metadata.GenericParameterConstraintHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Inequality(System.Reflection.Metadata.GenericParameterConstraintHandle,System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.GenericParameterConstraintHandleCollection">
      <summary>Rappresenta una raccolta di vincoli di un parametro di tipo generico.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#GenericParameterConstraintHandle}#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di scorrere la raccolta.</summary>
      <returns>Enumeratore che può essere usato per scorrere la raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di eseguire l'iterazione di una raccolta.</summary>
      <returns>Oggetto <see cref="T:System.Collections.IEnumerator" /> che può essere usato per eseguire l'iterazione della raccolta.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Count">
      <summary>Ottiene il numero di elementi nella raccolta.</summary>
      <returns>Numero di elementi contenuti nella raccolta.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Item(System.Int32)">
      <summary>Ottiene l'elemento in corrispondenza dell'indice specificato nell'elenco di sola lettura.</summary>
      <param name="index">Indice in base zero dell'elemento da ottenere.</param>
      <returns>Elemento in corrispondenza dell'indice specificato nell'elenco di sola lettura.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.MoveNext">
      <summary>Sposta l'enumeratore all'elemento successivo della raccolta.</summary>
      <returns>
        <see langword="true" /> se l'enumeratore è stato spostato correttamente in avanti in corrispondenza dell'elemento successivo, <see langword="false" /> se l'enumeratore ha superato la fine della raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Imposta l'enumeratore sulla propria posizione iniziale, ovvero prima del primo elemento nella raccolta.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Esegue attività definite dall'applicazione, come rilasciare o reimpostare risorse non gestite.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterHandle" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.Equals(System.Reflection.Metadata.GenericParameterHandle)">
      <summary>Indica se l'oggetto corrente è uguale a un altro oggetto dello stesso tipo.</summary>
      <param name="other">Oggetto da confrontare con l'oggetto corrente.</param>
      <returns>
        <see langword="true" /> se l'oggetto corrente è uguale al parametro <paramref name="other" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Equality(System.Reflection.Metadata.GenericParameterHandle,System.Reflection.Metadata.GenericParameterHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.GenericParameterHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.GenericParameterHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Implicit(System.Reflection.Metadata.GenericParameterHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Implicit(System.Reflection.Metadata.GenericParameterHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Inequality(System.Reflection.Metadata.GenericParameterHandle,System.Reflection.Metadata.GenericParameterHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.GenericParameterHandleCollection">
      <summary>Rappresenta una raccolta di parametri di tipo generico di un metodo o di un tipo.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#GenericParameterHandle}#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di scorrere la raccolta.</summary>
      <returns>Enumeratore che può essere usato per scorrere la raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di eseguire l'iterazione di una raccolta.</summary>
      <returns>Oggetto <see cref="T:System.Collections.IEnumerator" /> che può essere usato per eseguire l'iterazione della raccolta.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Count">
      <summary>Ottiene il numero di elementi nella raccolta.</summary>
      <returns>Numero di elementi contenuti nella raccolta.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Item(System.Int32)">
      <summary>Ottiene l'elemento in corrispondenza dell'indice specificato nell'elenco di sola lettura.</summary>
      <param name="index">Indice in base zero dell'elemento da ottenere.</param>
      <returns>Elemento in corrispondenza dell'indice specificato nell'elenco di sola lettura.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.MoveNext">
      <summary>Sposta l'enumeratore all'elemento successivo della raccolta.</summary>
      <returns>
        <see langword="true" /> se l'enumeratore è stato spostato correttamente in avanti in corrispondenza dell'elemento successivo, <see langword="false" /> se l'enumeratore ha superato la fine della raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Imposta l'enumeratore sulla propria posizione iniziale, ovvero prima del primo elemento nella raccolta.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Esegue attività definite dall'applicazione, come rilasciare o reimpostare risorse non gestite.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GuidHandle" />
    <member name="M:System.Reflection.Metadata.GuidHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.Equals(System.Reflection.Metadata.GuidHandle)">
      <summary>Indica se l'oggetto corrente è uguale a un altro oggetto dello stesso tipo.</summary>
      <param name="other">Oggetto da confrontare con l'oggetto corrente.</param>
      <returns>
        <see langword="true" /> se l'oggetto corrente è uguale al parametro <paramref name="other" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Equality(System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.GuidHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Implicit(System.Reflection.Metadata.GuidHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Inequality(System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.GuidHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.Handle">
      <summary>Rappresenta qualsiasi entità di metadati (ad esempio un riferimento a un tipo, una definizione di tipo, una specifica del tipo, una definizione di metodo o un attributo personalizzato) o un valore (una stringa, un BLOB, un GUID o una stringa utente).</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Handle.AssemblyDefinition" />
    <member name="F:System.Reflection.Metadata.Handle.ModuleDefinition" />
    <member name="M:System.Reflection.Metadata.Handle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.Handle.Equals(System.Reflection.Metadata.Handle)">
      <summary>Indica se l'oggetto corrente è uguale a un altro oggetto dello stesso tipo.</summary>
      <param name="other">Oggetto da confrontare con l'oggetto corrente.</param>
      <returns>
        <see langword="true" /> se l'oggetto corrente è uguale al parametro <paramref name="other" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Handle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.Handle.op_Equality(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.Handle.op_Inequality(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.Handle.IsNil" />
    <member name="P:System.Reflection.Metadata.Handle.Kind" />
    <member name="T:System.Reflection.Metadata.HandleComparer" />
    <member name="M:System.Reflection.Metadata.HandleComparer.Compare(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>Confronta due handle di entità.</summary>
      <param name="x">Primo handle di entità da confrontare.</param>
      <param name="y">Secondo handle di entità da confrontare.</param>
      <returns>Zero se i due handle di entità sono uguali. Valore diverso da zero se non lo sono.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.Compare(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <summary>Confronta due handle.</summary>
      <param name="x">Primo handle da confrontare.</param>
      <param name="y">Secondo handle da confrontare.</param>
      <returns>Zero se i due handle sono uguali. Valore diverso da zero se non lo sono.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.Equals(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>Determina se gli oggetti specificati sono uguali.</summary>
      <param name="x">Primo oggetto di tipo <paramref name="T" /> da confrontare.</param>
      <param name="y">Secondo oggetto di tipo <paramref name="T" /> da confrontare.</param>
      <returns>
        <see langword="true" /> se gli oggetti specificati sono uguali; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.Equals(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <summary>Determina se gli oggetti specificati sono uguali.</summary>
      <param name="x">Primo oggetto di tipo <paramref name="T" /> da confrontare.</param>
      <param name="y">Secondo oggetto di tipo <paramref name="T" /> da confrontare.</param>
      <returns>
        <see langword="true" /> se gli oggetti specificati sono uguali; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.GetHashCode(System.Reflection.Metadata.EntityHandle)">
      <summary>Viene restituito un codice hash per l'oggetto specificato.</summary>
      <param name="obj">Oggetto <see cref="T:System.Object" /> per cui è necessario che sia restituito un codice hash.</param>
      <returns>Codice hash per l'oggetto specificato.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.GetHashCode(System.Reflection.Metadata.Handle)">
      <summary>Viene restituito un codice hash per l'oggetto specificato.</summary>
      <param name="obj">Oggetto <see cref="T:System.Object" /> per cui è necessario che sia restituito un codice hash.</param>
      <returns>Codice hash per l'oggetto specificato.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.HandleComparer.Default" />
    <member name="T:System.Reflection.Metadata.HandleKind" />
    <member name="F:System.Reflection.Metadata.HandleKind.AssemblyDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.AssemblyFile" />
    <member name="F:System.Reflection.Metadata.HandleKind.AssemblyReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.Blob" />
    <member name="F:System.Reflection.Metadata.HandleKind.Constant" />
    <member name="F:System.Reflection.Metadata.HandleKind.CustomAttribute" />
    <member name="F:System.Reflection.Metadata.HandleKind.CustomDebugInformation" />
    <member name="F:System.Reflection.Metadata.HandleKind.DeclarativeSecurityAttribute" />
    <member name="F:System.Reflection.Metadata.HandleKind.Document" />
    <member name="F:System.Reflection.Metadata.HandleKind.EventDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.ExportedType" />
    <member name="F:System.Reflection.Metadata.HandleKind.FieldDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.GenericParameter" />
    <member name="F:System.Reflection.Metadata.HandleKind.GenericParameterConstraint" />
    <member name="F:System.Reflection.Metadata.HandleKind.Guid" />
    <member name="F:System.Reflection.Metadata.HandleKind.ImportScope" />
    <member name="F:System.Reflection.Metadata.HandleKind.InterfaceImplementation" />
    <member name="F:System.Reflection.Metadata.HandleKind.LocalConstant" />
    <member name="F:System.Reflection.Metadata.HandleKind.LocalScope" />
    <member name="F:System.Reflection.Metadata.HandleKind.LocalVariable" />
    <member name="F:System.Reflection.Metadata.HandleKind.ManifestResource" />
    <member name="F:System.Reflection.Metadata.HandleKind.MemberReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodDebugInformation" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodImplementation" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodSpecification" />
    <member name="F:System.Reflection.Metadata.HandleKind.ModuleDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.ModuleReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.NamespaceDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.Parameter" />
    <member name="F:System.Reflection.Metadata.HandleKind.PropertyDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.StandaloneSignature" />
    <member name="F:System.Reflection.Metadata.HandleKind.String" />
    <member name="F:System.Reflection.Metadata.HandleKind.TypeDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.TypeReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.TypeSpecification" />
    <member name="F:System.Reflection.Metadata.HandleKind.UserString" />
    <member name="T:System.Reflection.Metadata.IConstructedTypeProvider`1">
      <typeparam name="TType" />
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetArrayType(`0,System.Reflection.Metadata.ArrayShape)">
      <summary>Ottiene il simbolo di tipo per una matrice generalizzata del tipo di elemento e della forma specificati.</summary>
      <param name="elementType">Tipo degli elementi nella matrice.</param>
      <param name="shape">Forma (numero di dimensioni, dimensioni e limiti inferiori) della matrice.</param>
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetByReferenceType(`0)">
      <summary>Ottiene il simbolo di tipo per un puntatore gestito al tipo di elemento specificato.</summary>
      <param name="elementType" />
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetGenericInstantiation(`0,System.Collections.Immutable.ImmutableArray{`0})">
      <summary>Ottiene il simbolo di tipo per una creazione di istanza generica del tipo generico specificato con gli argomenti tipo specificati.</summary>
      <param name="genericType" />
      <param name="typeArguments" />
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetPointerType(`0)">
      <summary>Ottiene il simbolo di tipo per un puntatore non gestito al tipo di elemento specificato.</summary>
      <param name="elementType" />
    </member>
    <member name="T:System.Reflection.Metadata.ICustomAttributeTypeProvider`1">
      <typeparam name="TType" />
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.GetSystemType">
      <summary>Ottiene la rappresentazione <typeparamref name="TType" /> per <see cref="T:System.Type" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.GetTypeFromSerializedName(System.String)">
      <summary>Ottiene il simbolo del tipo per il nome del tipo serializzato specificato.</summary>
      <param name="name">Il nome del tipo serializzato nel formato detto "notazione reflection" (come riconosciuto dal metodo <see cref="M:System.Type.GetType(System.String)" />).</param>
      <exception cref="T:System.BadImageFormatException">Il nome non è valido.</exception>
      <returns>Istanza di <typeparamref name="TType" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.GetUnderlyingEnumType(`0)">
      <summary>Ottiene il tipo sottostante del simbolo del tipo enumerazione specificato.</summary>
      <param name="type">Tipo di enumerazione.</param>
      <exception cref="T:System.BadImageFormatException">Il simbolo del tipo specificato non rappresenta un'enumerazione.</exception>
      <returns>Codice di tipo che indica il tipo sottostante dell'enumerazione.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.IsSystemType(`0)">
      <summary>Verifica se il tipo specificato rappresenta un oggetto <see cref="T:System.Type" />.</summary>
      <param name="type">Tipo da verificare.</param>
      <returns>
        <see langword="true" /> se il tipo specificato è un oggetto <see cref="T:System.Type" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ILOpCode" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Add" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Add_ovf" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Add_ovf_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.And" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Arglist" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Beq" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Beq_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bne_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bne_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Box" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Br" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Br_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Break" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brfalse" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brfalse_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brtrue" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brtrue_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Call" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Calli" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Callvirt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Castclass" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ceq" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cgt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cgt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ckfinite" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Clt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Clt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Constrained" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i1_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i2_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i4_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i8_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u1_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u2_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u4_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u8_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_r_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cpblk" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cpobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Div" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Div_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Dup" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Endfilter" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Endfinally" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Initblk" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Initobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Isinst" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Jmp" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarga" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarga_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_5" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_6" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_7" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_m1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelema" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldflda" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldftn" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldlen" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloca" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloca_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldnull" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldsfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldsflda" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldstr" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldtoken" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldvirtftn" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Leave" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Leave_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Localloc" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mkrefany" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mul" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mul_ovf" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mul_ovf_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Neg" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Newarr" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Newobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Nop" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Not" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Or" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Pop" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Readonly" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Refanytype" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Refanyval" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Rem" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Rem_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ret" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Rethrow" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Shl" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Shr" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Shr_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sizeof" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Starg" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Starg_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stsfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sub" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sub_ovf" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sub_ovf_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Switch" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Tail" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Throw" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Unaligned" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Unbox" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Unbox_any" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Volatile" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Xor" />
    <member name="T:System.Reflection.Metadata.ILOpCodeExtensions" />
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.GetBranchOperandSize(System.Reflection.Metadata.ILOpCode)">
      <summary>Calcola la dimensione dell'operando dell'istruzione per il ramo specificato.</summary>
      <param name="opCode">Codice operativo del ramo.</param>
      <exception cref="T:System.ArgumentException">Il valore <paramref name="opCode" /> specificato non è un codice operativo del ramo.</exception>
      <returns>1 se <paramref name="opCode" /> è un ramo breve o 4 se è un ramo lungo.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.GetLongBranch(System.Reflection.Metadata.ILOpCode)">
      <summary>Ottiene una forma estesa del codice operativo del ramo specificato.</summary>
      <param name="opCode">Codice operativo del ramo.</param>
      <exception cref="T:System.ArgumentException">Il valore <paramref name="opCode" /> specificato non è un codice operativo del ramo.</exception>
      <returns>Forma estesa del codice operativo del ramo.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.GetShortBranch(System.Reflection.Metadata.ILOpCode)">
      <summary>Ottiene una forma breve del codice operativo del ramo specificato.</summary>
      <param name="opCode">Codice operativo del ramo.</param>
      <exception cref="T:System.ArgumentException">Il valore <paramref name="opCode" /> specificato non è un codice operativo del ramo.</exception>
      <returns>Forma breve del codice operativo del ramo.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.IsBranch(System.Reflection.Metadata.ILOpCode)">
      <summary>Verifica se il codice operativo specificato è un ramo per un'etichetta.</summary>
      <param name="opCode" />
      <returns>
        <see langword="true" /> se il codice operativo specificato è un ramo per un'etichetta, in caso contrario <see langword="false" />.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImageFormatLimitationException">
      <summary>Eccezione generata quando un tentativo di scrivere metadati supera un limite specificato dalla specifica di formato. Ad esempio, quando viene superato il limite delle dimensioni dell'heap.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" /> con dati serializzati.</summary>
      <param name="info">Oggetto che contiene i dati oggetto serializzati.</param>
      <param name="context">Informazioni contestuali sull'origine o sulla destinazione.</param>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor(System.String)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" /> con un messaggio di errore specificato.</summary>
      <param name="message">Messaggio di errore nel quale viene indicata la causa dell'eccezione</param>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor(System.String,System.Exception)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" /> con un messaggio di errore e l'eccezione che ha causato l'eccezione corrente.</summary>
      <param name="message">Messaggio di errore nel quale viene indicata la causa dell'eccezione</param>
      <param name="innerException">L'eccezione che ha causato l'eccezione corrente o <see langword="null" /> se non è stata specificata un'eccezione interna.</param>
    </member>
    <member name="T:System.Reflection.Metadata.ImportDefinition" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.Alias" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.Kind" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.TargetAssembly" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.TargetNamespace" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.TargetType" />
    <member name="T:System.Reflection.Metadata.ImportDefinitionCollection" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ImportDefinition}#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di scorrere la raccolta.</summary>
      <returns>Enumeratore che può essere usato per scorrere la raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di eseguire l'iterazione di una raccolta.</summary>
      <returns>Oggetto <see cref="T:System.Collections.IEnumerator" /> che può essere usato per eseguire l'iterazione della raccolta.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.MoveNext">
      <summary>Sposta l'enumeratore all'elemento successivo della raccolta.</summary>
      <exception cref="T:System.BadImageFormatException">Formato BLOB non valido.</exception>
      <returns>
        <see langword="true" /> se l'enumeratore è stato spostato correttamente in avanti in corrispondenza dell'elemento successivo, <see langword="false" /> se l'enumeratore ha superato la fine della raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.Reset">
      <summary>Imposta l'enumeratore sulla propria posizione iniziale, ovvero prima del primo elemento nella raccolta.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Esegue attività definite dall'applicazione, come rilasciare o reimpostare risorse non gestite.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImportDefinitionKind" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasAssemblyNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasAssemblyReference" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasType" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportAssemblyNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportAssemblyReferenceAlias" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportType" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportXmlNamespace" />
    <member name="T:System.Reflection.Metadata.ImportScope">
      <summary>Fornisce informazioni sull'ambito lessicale in cui è disponibile un gruppo di importazioni. Queste informazioni sono archiviate nei metadati di debug.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScope.GetImports" />
    <member name="P:System.Reflection.Metadata.ImportScope.ImportsBlob" />
    <member name="P:System.Reflection.Metadata.ImportScope.Parent" />
    <member name="T:System.Reflection.Metadata.ImportScopeCollection" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ImportScopeHandle}#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di scorrere la raccolta.</summary>
      <returns>Enumeratore che può essere usato per scorrere la raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di eseguire l'iterazione di una raccolta.</summary>
      <returns>Oggetto <see cref="T:System.Collections.IEnumerator" /> che può essere usato per eseguire l'iterazione della raccolta.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ImportScopeCollection.Count">
      <summary>Ottiene il numero di elementi nella raccolta.</summary>
      <returns>Numero di elementi contenuti nella raccolta.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImportScopeCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.Enumerator.MoveNext">
      <summary>Sposta l'enumeratore all'elemento successivo della raccolta.</summary>
      <returns>
        <see langword="true" /> se l'enumeratore è stato spostato correttamente in avanti in corrispondenza dell'elemento successivo, <see langword="false" /> se l'enumeratore ha superato la fine della raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Imposta l'enumeratore sulla propria posizione iniziale, ovvero prima del primo elemento nella raccolta.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Esegue attività definite dall'applicazione, come rilasciare o reimpostare risorse non gestite.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ImportScopeCollection.Enumerator.Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ImportScopeCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImportScopeHandle" />
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.Equals(System.Reflection.Metadata.ImportScopeHandle)">
      <summary>Indica se l'oggetto corrente è uguale a un altro oggetto dello stesso tipo.</summary>
      <param name="other">Oggetto da confrontare con l'oggetto corrente.</param>
      <returns>
        <see langword="true" /> se l'oggetto corrente è uguale al parametro <paramref name="other" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Equality(System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.ImportScopeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ImportScopeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ImportScopeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Implicit(System.Reflection.Metadata.ImportScopeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Implicit(System.Reflection.Metadata.ImportScopeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Inequality(System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.ImportScopeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.ImportScopeHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.InterfaceImplementation" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementation.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.InterfaceImplementation.Interface">
      <summary>Ottiene l'interfaccia implementata (<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> o <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />).</summary>
    </member>
    <member name="T:System.Reflection.Metadata.InterfaceImplementationHandle" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.Equals(System.Reflection.Metadata.InterfaceImplementationHandle)">
      <summary>Indica se l'oggetto corrente è uguale a un altro oggetto dello stesso tipo.</summary>
      <param name="other">Oggetto da confrontare con l'oggetto corrente.</param>
      <returns>
        <see langword="true" /> se l'oggetto corrente è uguale al parametro <paramref name="other" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Equality(System.Reflection.Metadata.InterfaceImplementationHandle,System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.InterfaceImplementationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.InterfaceImplementationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Implicit(System.Reflection.Metadata.InterfaceImplementationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Implicit(System.Reflection.Metadata.InterfaceImplementationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Inequality(System.Reflection.Metadata.InterfaceImplementationHandle,System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.InterfaceImplementationHandleCollection" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#InterfaceImplementationHandle}#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di scorrere la raccolta.</summary>
      <returns>Enumeratore che può essere usato per scorrere la raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di eseguire l'iterazione di una raccolta.</summary>
      <returns>Oggetto <see cref="T:System.Collections.IEnumerator" /> che può essere usato per eseguire l'iterazione della raccolta.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Count">
      <summary>Ottiene il numero di elementi nella raccolta.</summary>
      <returns>Numero di elementi contenuti nella raccolta.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.MoveNext">
      <summary>Sposta l'enumeratore all'elemento successivo della raccolta.</summary>
      <returns>
        <see langword="true" /> se l'enumeratore è stato spostato correttamente in avanti in corrispondenza dell'elemento successivo, <see langword="false" /> se l'enumeratore ha superato la fine della raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Imposta l'enumeratore sulla propria posizione iniziale, ovvero prima del primo elemento nella raccolta.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Esegue attività definite dall'applicazione, come rilasciare o reimpostare risorse non gestite.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ISignatureTypeProvider`2">
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetFunctionPointerType(System.Reflection.Metadata.MethodSignature{`0})">
      <summary>Ottiene il simbolo del tipo per il tipo di puntatore a funzione del metodo dato <paramref name="signature" />.</summary>
      <param name="signature" />
      <returns>Simbolo del tipo per il tipo di puntatore a funzione.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetGenericMethodParameter(`1,System.Int32)">
      <summary>Ottiene il simbolo del tipo per il parametro metodo generico in corrispondenza dell'elemento in base zero <paramref name="index" />.</summary>
      <param name="genericContext" />
      <param name="index" />
      <returns>Simbolo del tipo per il parametro metodo generico in corrispondenza di <paramref name="index" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetGenericTypeParameter(`1,System.Int32)">
      <summary>Ottiene il simbolo del tipo per il parametro tipo generico in corrispondenza dell'elemento in base zero <paramref name="index" />.</summary>
      <param name="genericContext" />
      <param name="index" />
      <returns>Simbolo del tipo per il parametro tipo generico in corrispondenza dell'elemento in base zero <paramref name="index" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetModifiedType(`0,`0,System.Boolean)">
      <summary>Ottiene il simbolo del tipo per un tipo al quale è applicato un modificatore personalizzato.</summary>
      <param name="modifier">Tipo di modificatore applicato.</param>
      <param name="unmodifiedType">Simbolo del tipo per il tipo sottostante senza modificatori applicati.</param>
      <param name="isRequired">
        <see langword="true" /> se il modificatore è obbligatorio, <see langword="false" /> se è facoltativo.</param>
      <returns>Simbolo del tipo.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetPinnedType(`0)">
      <summary>Ottiene il simbolo del tipo per un tipo di variabile locale contrassegnato come bloccato.</summary>
      <param name="elementType" />
      <returns>Simbolo del tipo per il tipo di variabile locale.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetTypeFromSpecification(System.Reflection.Metadata.MetadataReader,`1,System.Reflection.Metadata.TypeSpecificationHandle,System.Byte)">
      <summary>Ottiene il simbolo del tipo per una specifica del tipo.</summary>
      <param name="reader">Lettore di metadati passato al decodificatore di firma. Può essere <see langword="null" />.</param>
      <param name="genericContext">Contesto passato al decodificatore di firma.</param>
      <param name="handle">Handle di specifica del tipo.</param>
      <param name="rawTypeKind">Classificazione del tipo, specificata nella firma. Per interpretare questo valore, usare <see cref="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)" />.</param>
      <returns>Simbolo del tipo per la specifica del tipo.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ISimpleTypeProvider`1">
      <typeparam name="TType" />
    </member>
    <member name="M:System.Reflection.Metadata.ISimpleTypeProvider`1.GetPrimitiveType(System.Reflection.Metadata.PrimitiveTypeCode)">
      <summary>Ottiene il simbolo del tipo per un tipo primitivo.</summary>
      <param name="typeCode" />
      <returns>Simbolo del tipo per <param name="typeCode" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISimpleTypeProvider`1.GetTypeFromDefinition(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.TypeDefinitionHandle,System.Byte)">
      <summary>Ottiene il simbolo del tipo per una definizione del tipo.</summary>
      <param name="reader">Lettore di metadati passato al decodificatore di firma. Può essere <see langword="null" />.</param>
      <param name="handle">Handle di definizione del tipo.</param>
      <param name="rawTypeKind">Classificazione del tipo, specificata nella firma. Per interpretare questo valore, usare <see cref="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)" />.</param>
      <returns>Simbolo del tipo.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISimpleTypeProvider`1.GetTypeFromReference(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.TypeReferenceHandle,System.Byte)">
      <summary>Ottiene il simbolo del tipo per un riferimento del tipo.</summary>
      <param name="reader">Lettore di metadati passato al decodificatore di firma. Può essere <see langword="null" />.</param>
      <param name="handle">Handle di definizione del tipo.</param>
      <param name="rawTypeKind">Classificazione del tipo, specificata nella firma. Per interpretare questo valore, usare <see cref="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)" />.</param>
      <returns>Simbolo del tipo.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ISZArrayTypeProvider`1">
      <typeparam name="TType" />
    </member>
    <member name="M:System.Reflection.Metadata.ISZArrayTypeProvider`1.GetSZArrayType(`0)">
      <summary>Ottiene il simbolo del tipo per una matrice unidimensionale del tipo di elemento specificato con un limite inferiore pari a zero.</summary>
      <param name="elementType" />
      <returns>Istanza di <typeparamref name="TType" />.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalConstant">
      <summary>Fornisce informazioni sulle costanti locali. Queste informazioni sono archiviate nei metadati di debug.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstant.Name" />
    <member name="P:System.Reflection.Metadata.LocalConstant.Signature">
      <summary>Ottiene la firma della costante.</summary>
      <returns>Firma costante.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalConstantHandle" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.Equals(System.Reflection.Metadata.LocalConstantHandle)">
      <summary>Indica se l'oggetto corrente è uguale a un altro oggetto dello stesso tipo.</summary>
      <param name="other">Oggetto da confrontare con l'oggetto corrente.</param>
      <returns>
        <see langword="true" /> se l'oggetto corrente è uguale al parametro <paramref name="other" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Equality(System.Reflection.Metadata.LocalConstantHandle,System.Reflection.Metadata.LocalConstantHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.LocalConstantHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.LocalConstantHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Implicit(System.Reflection.Metadata.LocalConstantHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Implicit(System.Reflection.Metadata.LocalConstantHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Inequality(System.Reflection.Metadata.LocalConstantHandle,System.Reflection.Metadata.LocalConstantHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstantHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.LocalConstantHandleCollection" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#LocalConstantHandle}#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di scorrere la raccolta.</summary>
      <returns>Enumeratore che può essere usato per scorrere la raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di eseguire l'iterazione di una raccolta.</summary>
      <returns>Oggetto <see cref="T:System.Collections.IEnumerator" /> che può essere usato per eseguire l'iterazione della raccolta.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstantHandleCollection.Count">
      <summary>Ottiene il numero di elementi nella raccolta.</summary>
      <returns>Numero di elementi contenuti nella raccolta.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.MoveNext">
      <summary>Sposta l'enumeratore all'elemento successivo della raccolta.</summary>
      <returns>
        <see langword="true" /> se l'enumeratore è stato spostato correttamente in avanti in corrispondenza dell'elemento successivo, <see langword="false" /> se l'enumeratore ha superato la fine della raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Imposta l'enumeratore sulla propria posizione iniziale, ovvero prima del primo elemento nella raccolta.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Esegue attività definite dall'applicazione, come rilasciare o reimpostare risorse non gestite.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalScope">
      <summary>Fornisce informazioni sull'ambito di variabili e costanti locali. Queste informazioni sono archiviate nei metadati di debug.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScope.GetChildren" />
    <member name="M:System.Reflection.Metadata.LocalScope.GetLocalConstants" />
    <member name="M:System.Reflection.Metadata.LocalScope.GetLocalVariables" />
    <member name="P:System.Reflection.Metadata.LocalScope.EndOffset" />
    <member name="P:System.Reflection.Metadata.LocalScope.ImportScope" />
    <member name="P:System.Reflection.Metadata.LocalScope.Length" />
    <member name="P:System.Reflection.Metadata.LocalScope.Method" />
    <member name="P:System.Reflection.Metadata.LocalScope.StartOffset" />
    <member name="T:System.Reflection.Metadata.LocalScopeHandle" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.Equals(System.Reflection.Metadata.LocalScopeHandle)">
      <summary>Indica se l'oggetto corrente è uguale a un altro oggetto dello stesso tipo.</summary>
      <param name="other">Oggetto da confrontare con l'oggetto corrente.</param>
      <returns>
        <see langword="true" /> se l'oggetto corrente è uguale al parametro <paramref name="other" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Equality(System.Reflection.Metadata.LocalScopeHandle,System.Reflection.Metadata.LocalScopeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.LocalScopeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.LocalScopeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Implicit(System.Reflection.Metadata.LocalScopeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Implicit(System.Reflection.Metadata.LocalScopeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Inequality(System.Reflection.Metadata.LocalScopeHandle,System.Reflection.Metadata.LocalScopeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.LocalScopeHandleCollection" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#LocalScopeHandle}#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di scorrere la raccolta.</summary>
      <returns>Enumeratore che può essere usato per scorrere la raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di eseguire l'iterazione di una raccolta.</summary>
      <returns>Oggetto <see cref="T:System.Collections.IEnumerator" /> che può essere usato per eseguire l'iterazione della raccolta.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.Count">
      <summary>Ottiene il numero di elementi nella raccolta.</summary>
      <returns>Numero di elementi contenuti nella raccolta.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.MoveNext">
      <summary>Sposta l'enumeratore all'elemento successivo della raccolta.</summary>
      <returns>
        <see langword="true" /> se l'enumeratore è stato spostato correttamente in avanti in corrispondenza dell'elemento successivo, <see langword="false" /> se l'enumeratore ha superato la fine della raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.System#Collections#IEnumerator#Reset">
      <summary>Imposta l'enumeratore sulla propria posizione iniziale, ovvero prima del primo elemento nella raccolta.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.System#IDisposable#Dispose">
      <summary>Esegue attività definite dall'applicazione, come rilasciare o reimpostare risorse non gestite.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.System#Collections#IEnumerator#Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.MoveNext">
      <summary>Sposta l'enumeratore all'elemento successivo della raccolta.</summary>
      <returns>
        <see langword="true" /> se l'enumeratore è stato spostato correttamente in avanti in corrispondenza dell'elemento successivo, <see langword="false" /> se l'enumeratore ha superato la fine della raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Imposta l'enumeratore sulla propria posizione iniziale, ovvero prima del primo elemento nella raccolta.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Esegue attività definite dall'applicazione, come rilasciare o reimpostare risorse non gestite.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalVariable">
      <summary>Fornisce informazioni sulle variabili locali. Queste informazioni sono archiviate nei metadati di debug.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariable.Attributes" />
    <member name="P:System.Reflection.Metadata.LocalVariable.Index" />
    <member name="P:System.Reflection.Metadata.LocalVariable.Name" />
    <member name="T:System.Reflection.Metadata.LocalVariableAttributes" />
    <member name="F:System.Reflection.Metadata.LocalVariableAttributes.DebuggerHidden" />
    <member name="F:System.Reflection.Metadata.LocalVariableAttributes.None" />
    <member name="T:System.Reflection.Metadata.LocalVariableHandle" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.Equals(System.Reflection.Metadata.LocalVariableHandle)">
      <summary>Indica se l'oggetto corrente è uguale a un altro oggetto dello stesso tipo.</summary>
      <param name="other">Oggetto da confrontare con l'oggetto corrente.</param>
      <returns>
        <see langword="true" /> se l'oggetto corrente è uguale al parametro <paramref name="other" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Equality(System.Reflection.Metadata.LocalVariableHandle,System.Reflection.Metadata.LocalVariableHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.LocalVariableHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.LocalVariableHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Implicit(System.Reflection.Metadata.LocalVariableHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Implicit(System.Reflection.Metadata.LocalVariableHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Inequality(System.Reflection.Metadata.LocalVariableHandle,System.Reflection.Metadata.LocalVariableHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariableHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.LocalVariableHandleCollection" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#LocalVariableHandle}#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di scorrere la raccolta.</summary>
      <returns>Enumeratore che può essere usato per scorrere la raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di eseguire l'iterazione di una raccolta.</summary>
      <returns>Oggetto <see cref="T:System.Collections.IEnumerator" /> che può essere usato per eseguire l'iterazione della raccolta.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariableHandleCollection.Count">
      <summary>Ottiene il numero di elementi nella raccolta.</summary>
      <returns>Numero di elementi contenuti nella raccolta.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.MoveNext">
      <summary>Sposta l'enumeratore all'elemento successivo della raccolta.</summary>
      <returns>
        <see langword="true" /> se l'enumeratore è stato spostato correttamente in avanti in corrispondenza dell'elemento successivo, <see langword="false" /> se l'enumeratore ha superato la fine della raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Imposta l'enumeratore sulla propria posizione iniziale, ovvero prima del primo elemento nella raccolta.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Esegue attività definite dall'applicazione, come rilasciare o reimpostare risorse non gestite.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ManifestResource" />
    <member name="M:System.Reflection.Metadata.ManifestResource.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ManifestResource.Attributes">
      <summary>Ottiene gli attributi della risorsa del manifesto.</summary>
      <returns>Combinazione bit per bit dei valori di enumerazione che specificano gli attributi della risorsa di manifesto.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResource.Implementation">
      <summary>Ottiene l'handle dell'entità di implementazione.</summary>
      <returns>Istanza di EntityHandle. Se la <see cref="P:System.Reflection.Metadata.EntityHandle.IsNil" /> proprietà è <see langword="true" /> , l'handle restituito avrà valori predefiniti.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResource.Name">
      <summary>Ottiene il nome della risorsa.</summary>
      <returns>Nome della risorsa.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResource.Offset">
      <summary>Ottiene l'offset di byte all'interno del file di riferimento da cui inizia questo record di risorsa.</summary>
      <returns>Offset dei byte all'interno del file a cui si fa riferimento in corrispondenza del quale inizia il record di risorse.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ManifestResourceHandle" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.Equals(System.Reflection.Metadata.ManifestResourceHandle)">
      <summary>Indica se l'oggetto corrente è uguale a un altro oggetto dello stesso tipo.</summary>
      <param name="other">Oggetto da confrontare con l'oggetto corrente.</param>
      <returns>
        <see langword="true" /> se l'oggetto corrente è uguale al parametro <paramref name="other" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Equality(System.Reflection.Metadata.ManifestResourceHandle,System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ManifestResourceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ManifestResourceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Implicit(System.Reflection.Metadata.ManifestResourceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Implicit(System.Reflection.Metadata.ManifestResourceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Inequality(System.Reflection.Metadata.ManifestResourceHandle,System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResourceHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ManifestResourceHandleCollection">
      <summary>Rappresenta una raccolta di istanze di <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ManifestResourceHandle}#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di scorrere la raccolta.</summary>
      <returns>Enumeratore che può essere usato per scorrere la raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di eseguire l'iterazione di una raccolta.</summary>
      <returns>Oggetto <see cref="T:System.Collections.IEnumerator" /> che può essere usato per eseguire l'iterazione della raccolta.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResourceHandleCollection.Count">
      <summary>Ottiene il numero di elementi nella raccolta.</summary>
      <returns>Numero di elementi contenuti nella raccolta.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.MoveNext">
      <summary>Sposta l'enumeratore all'elemento successivo della raccolta.</summary>
      <returns>
        <see langword="true" /> se l'enumeratore è stato spostato correttamente in avanti in corrispondenza dell'elemento successivo, <see langword="false" /> se l'enumeratore ha superato la fine della raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Imposta l'enumeratore sulla propria posizione iniziale, ovvero prima del primo elemento nella raccolta.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Esegue attività definite dall'applicazione, come rilasciare o reimpostare risorse non gestite.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MemberReference" />
    <member name="M:System.Reflection.Metadata.MemberReference.DecodeFieldSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReference.DecodeMethodSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReference.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.MemberReference.GetKind">
      <summary>Determina se il membro fa riferimento a un metodo o a un campo.</summary>
      <exception cref="T:System.BadImageFormatException">La firma del riferimento del membro non è valida.</exception>
      <returns>Uno dei valori di enumerazione che indica il tipo di riferimento del membro.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReference.Name" />
    <member name="P:System.Reflection.Metadata.MemberReference.Parent">
      <summary>Ottiene l'handle dell'entità padre.</summary>
      <returns>Istanza dell'handle di entità. Se la <see cref="P:System.Reflection.Metadata.EntityHandle.IsNil" /> proprietà è <see langword="true" /> , l'handle restituito avrà valori predefiniti.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReference.Signature">
      <summary>Ottiene un handle al BLOB della firma.</summary>
      <returns>Handle per il BLOB della firma.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MemberReferenceHandle" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.Equals(System.Reflection.Metadata.MemberReferenceHandle)">
      <summary>Indica se l'oggetto corrente è uguale a un altro oggetto dello stesso tipo.</summary>
      <param name="other">Oggetto da confrontare con l'oggetto corrente.</param>
      <returns>
        <see langword="true" /> se l'oggetto corrente è uguale al parametro <paramref name="other" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Equality(System.Reflection.Metadata.MemberReferenceHandle,System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MemberReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MemberReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Implicit(System.Reflection.Metadata.MemberReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Implicit(System.Reflection.Metadata.MemberReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Inequality(System.Reflection.Metadata.MemberReferenceHandle,System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.MemberReferenceHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.MemberReferenceHandleCollection">
      <summary>Rappresenta una raccolta di istanze di <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MemberReferenceHandle}#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di scorrere la raccolta.</summary>
      <returns>Enumeratore che può essere usato per scorrere la raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di eseguire l'iterazione di una raccolta.</summary>
      <returns>Oggetto <see cref="T:System.Collections.IEnumerator" /> che può essere usato per eseguire l'iterazione della raccolta.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReferenceHandleCollection.Count">
      <summary>Ottiene il numero di elementi nella raccolta.</summary>
      <returns>Numero di elementi contenuti nella raccolta.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.MoveNext">
      <summary>Sposta l'enumeratore all'elemento successivo della raccolta.</summary>
      <returns>
        <see langword="true" /> se l'enumeratore è stato spostato correttamente in avanti in corrispondenza dell'elemento successivo, <see langword="false" /> se l'enumeratore ha superato la fine della raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Imposta l'enumeratore sulla propria posizione iniziale, ovvero prima del primo elemento nella raccolta.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Esegue attività definite dall'applicazione, come rilasciare o reimpostare risorse non gestite.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MemberReferenceKind">
      <summary>Specifica le costanti che indicano se un oggetto <see cref="T:System.Reflection.Metadata.MemberReference" /> fa riferimento a un metodo o un campo.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MemberReferenceKind.Field">
      <summary>
        <see cref="T:System.Reflection.Metadata.MemberReference" /> fa riferimento a un campo.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MemberReferenceKind.Method">
      <summary>
        <see cref="T:System.Reflection.Metadata.MemberReference" /> fa riferimento a un metodo.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataKind" />
    <member name="F:System.Reflection.Metadata.MetadataKind.Ecma335">
      <summary>Metadati dell'interfaccia della riga di comando.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataKind.ManagedWindowsMetadata">
      <summary>Metadati di Windows generati da compilatori gestiti.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataKind.WindowsMetadata">
      <summary>Metadati di Windows.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataReader">
      <summary>Legge i metadati come definito dalla specifica dell'interfaccia della riga di comando ECMA 335.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Reflection.Metadata.MetadataReader" /> dai metadati archiviati nella posizione di memoria specificata.</summary>
      <param name="metadata">Puntatore al primo byte in un blocco di metadati.</param>
      <param name="length">Numero di byte nel blocco.</param>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32,System.Reflection.Metadata.MetadataReaderOptions)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Reflection.Metadata.MetadataReader" /> dai metadati archiviati nella posizione di memoria specificata.</summary>
      <param name="metadata" />
      <param name="length" />
      <param name="options" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32,System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Reflection.Metadata.MetadataReader" /> dai metadati archiviati nella posizione di memoria specificata.</summary>
      <param name="metadata" />
      <param name="length" />
      <param name="options" />
      <param name="utf8Decoder" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" /> non è positivo.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="metadata" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">La codifica di <paramref name="utf8Decoder" /> non è <see cref="T:System.Text.UTF8Encoding" />.</exception>
      <exception cref="T:System.PlatformNotSupportedException">La piattaforma corrente è big-endian.</exception>
      <exception cref="T:System.BadImageFormatException">Intestazione di metadati non valida.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetAssemblyDefinition" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetAssemblyFile(System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetAssemblyReference(System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobBytes(System.Reflection.Metadata.BlobHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobContent(System.Reflection.Metadata.BlobHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobReader(System.Reflection.Metadata.BlobHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobReader(System.Reflection.Metadata.StringHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetConstant(System.Reflection.Metadata.ConstantHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomAttribute(System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomAttributes(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomDebugInformation(System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomDebugInformation(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetDeclarativeSecurityAttribute(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetDocument(System.Reflection.Metadata.DocumentHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetEventDefinition(System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetExportedType(System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetFieldDefinition(System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetGenericParameter(System.Reflection.Metadata.GenericParameterHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetGenericParameterConstraint(System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetGuid(System.Reflection.Metadata.GuidHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetImportScope(System.Reflection.Metadata.ImportScopeHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetInterfaceImplementation(System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalConstant(System.Reflection.Metadata.LocalConstantHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalScope(System.Reflection.Metadata.LocalScopeHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalScopes(System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalScopes(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalVariable(System.Reflection.Metadata.LocalVariableHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetManifestResource(System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMemberReference(System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodDebugInformation(System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodDebugInformation(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodDefinition(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodImplementation(System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodSpecification(System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetModuleDefinition" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetModuleReference(System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetNamespaceDefinition(System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetNamespaceDefinitionRoot" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetParameter(System.Reflection.Metadata.ParameterHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetPropertyDefinition(System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetStandaloneSignature(System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetString(System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetString(System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetString(System.Reflection.Metadata.StringHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetTypeDefinition(System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetTypeReference(System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetTypeSpecification(System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetUserString(System.Reflection.Metadata.UserStringHandle)">
      <param name="handle" />
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.AssemblyFiles" />
    <member name="P:System.Reflection.Metadata.MetadataReader.AssemblyReferences" />
    <member name="P:System.Reflection.Metadata.MetadataReader.CustomAttributes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.CustomDebugInformation" />
    <member name="P:System.Reflection.Metadata.MetadataReader.DebugMetadataHeader">
      <summary>Ottiene le informazioni decodificate dal flusso #Pdb oppure <see langword="null" /> se il flusso non è presente.</summary>
      <returns>Informazioni decodificate dal flusso #Pdb o <see langword="null" /> se il flusso non è presente.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.DeclarativeSecurityAttributes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.Documents" />
    <member name="P:System.Reflection.Metadata.MetadataReader.EventDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.ExportedTypes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.FieldDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.ImportScopes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.IsAssembly">
      <summary>Ottiene un valore che indica se i metadati rappresentano un assembly.</summary>
      <returns>
        <see langword="true" /> Se i metadati rappresentano un assembly; in caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.LocalConstants" />
    <member name="P:System.Reflection.Metadata.MetadataReader.LocalScopes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.LocalVariables" />
    <member name="P:System.Reflection.Metadata.MetadataReader.ManifestResources" />
    <member name="P:System.Reflection.Metadata.MetadataReader.MemberReferences" />
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataKind">
      <summary>Ottiene il tipo di metadati.</summary>
      <returns>Uno dei valori di enumerazione che specifica il tipo di metadati.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataLength">
      <summary>Ottiene la lunghezza dei dati sottostanti.</summary>
      <returns>Lunghezza dei dati sottostanti.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataPointer">
      <summary>Ottiene il puntatore ai dati sottostanti.</summary>
      <returns>Puntatore ai dati sottostanti.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataVersion">
      <summary>Ottiene la stringa della versione letta dall'intestazione dei metadati.</summary>
      <returns>Stringa di versione letta dall'intestazione dei metadati.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MethodDebugInformation" />
    <member name="P:System.Reflection.Metadata.MetadataReader.MethodDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.Options">
      <summary>Ottiene la funzione <see cref="T:System.Reflection.Metadata.MetadataReaderOptions" /> passata al costruttore.</summary>
      <returns>Combinazione bit per bit dei valori di enumerazione che descrive il <see cref="T:System.Reflection.Metadata.MetadataReaderOptions" /> valore enum.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.PropertyDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.StringComparer">
      <summary>Ottiene l'operatore di confronto usato per confrontare le stringhe archiviate nei metadati.</summary>
      <returns>Operatore di confronto utilizzato per confrontare le stringhe archiviate nei metadati.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.TypeDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.TypeReferences" />
    <member name="P:System.Reflection.Metadata.MetadataReader.UTF8Decoder">
      <summary>Ottiene il decodificatore usato dal lettore per generare le istanze delle stringhe dalle sequenze di byte con codifica UTF8.</summary>
      <returns>Il decodificatore utilizzato dal Reader per produrre istanze di stringa da sequenze di byte con codifica UTF8.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataReaderOptions" />
    <member name="F:System.Reflection.Metadata.MetadataReaderOptions.ApplyWindowsRuntimeProjections">
      <summary>Le proiezioni di Windows Runtime sono abilitate (attivato per impostazione predefinita).</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataReaderOptions.Default">
      <summary>Opzioni usate quando si ottiene un <see cref="T:System.Reflection.Metadata.MetadataReader" /> tramite un overload che non accetta un argomento <see cref="T:System.Reflection.Metadata.MetadataReaderOptions" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataReaderOptions.None">
      <summary>Tutte le opzioni sono disabilitate.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataReaderProvider">
      <summary>Fornisce un <see cref="T:System.Reflection.Metadata.MetadataReader" /> per i metadati archiviati in una matrice di byte, un blocco di memoria o un flusso.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.Dispose">
      <summary>Elimina tutta la memoria allocata dal lettore.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromMetadataImage(System.Byte*,System.Int32)">
      <summary>Crea un provider di metadati su un'immagine archiviata in memoria.</summary>
      <param name="start">Puntatore all'inizio del BLOB di metadati.</param>
      <param name="size">Dimensioni del BLOB di metadati.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="start" /> è <see cref="F:System.IntPtr.Zero" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> è negativo.</exception>
      <returns>Il nuovo provider di metadati.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromMetadataImage(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>Crea un provider in una matrice di byte.</summary>
      <param name="image">Immagine di metadati.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="image" /> è <see langword="null" />.</exception>
      <returns>Il nuovo provider.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromMetadataStream(System.IO.Stream,System.Reflection.Metadata.MetadataStreamOptions,System.Int32)">
      <summary>Crea un provider per un flusso delle dimensioni specificate con inizio nella posizione corrente.</summary>
      <param name="stream">Istanza di <see cref="T:System.IO.Stream" />.</param>
      <param name="options">Opzioni che specificano la modalità di lettura delle sezioni dell'immagine dal flusso.</param>
      <param name="size">Dimensioni del BLOB di metadati nel flusso. Se non è specificato, si presuppone che il BLOB di metadati si estenda fino alla fine del flusso.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="stream" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="stream" /> non supporta le operazioni read (lettura) e seek (ricerca).</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Le dimensioni sono negative o si estendono oltre la fine del flusso.</exception>
      <exception cref="T:System.IO.IOException">Errore durante la lettura dal flusso (solo quando è specificato <see cref="F:System.Reflection.Metadata.MetadataStreamOptions.PrefetchMetadata" />).</exception>
      <returns>Il nuovo provider.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromPortablePdbImage(System.Byte*,System.Int32)">
      <summary>Crea un provider di metadati PDB portatile su un BLOB archiviato in memoria.</summary>
      <param name="start">Puntatore all'inizio della posizione del BLOB PDB.</param>
      <param name="size">Dimensioni del BLOB PDB portatile.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="start" /> è <see cref="F:System.IntPtr.Zero" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> è negativo.</exception>
      <returns>Il nuovo provider di metadati PDB portatile.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromPortablePdbImage(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>Crea un provider di metadati PDB portatile su una matrice di byte.</summary>
      <param name="image">Immagine PDB portatile.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="image" /> è <see langword="null" />.</exception>
      <returns>Il nuovo provider di metadati PDB portatile.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromPortablePdbStream(System.IO.Stream,System.Reflection.Metadata.MetadataStreamOptions,System.Int32)">
      <summary>Crea un provider per un flusso delle dimensioni specificate con inizio nella posizione corrente.</summary>
      <param name="stream">Flusso.</param>
      <param name="options">Opzioni che specificano la modalità di lettura delle sezioni dell'immagine dal flusso.</param>
      <param name="size">Dimensioni del BLOB di metadati nel flusso. Se non è specificato, si presuppone che il BLOB di metadati si estenda fino alla fine del flusso.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="stream" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="stream" /> non supporta le operazioni read (lettura) e seek (ricerca).</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Le dimensioni sono negative o si estendono oltre la fine del flusso.</exception>
      <returns>Istanza di <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.GetMetadataReader(System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)">
      <summary>Ottiene un oggetto <see cref="T:System.Reflection.Metadata.MetadataReader" /> da un oggetto <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />.</summary>
      <param name="options">Combinazione bit per bit dei valori di enumerazione che rappresenta la configurazione durante la lettura dei metadati.</param>
      <param name="utf8Decoder">Codifica da utilizzare.</param>
      <exception cref="T:System.ArgumentException">La codifica di <paramref name="utf8Decoder" /> non è <see cref="T:System.Text.UTF8Encoding" />.</exception>
      <exception cref="T:System.PlatformNotSupportedException">La piattaforma corrente è big-endian.</exception>
      <exception cref="T:System.IO.IOException">Errore di I/O durante la lettura dal flusso sottostante.</exception>
      <exception cref="T:System.ObjectDisposedException">Il provider è stato eliminato.</exception>
      <returns>Istanza di <see cref="T:System.Reflection.Metadata.MetadataReader" />.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataStreamOptions" />
    <member name="F:System.Reflection.Metadata.MetadataStreamOptions.Default">
      <summary>Per impostazione predefinita, il flusso viene eliminato quando <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> viene eliminato e le sezioni dell'immagine PE sono lette in modo differito.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataStreamOptions.LeaveOpen">
      <summary>Mantiene il flusso aperto quando <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> viene eliminato.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataStreamOptions.PrefetchMetadata">
      <summary>
        <para>Legge immediatamente i metadati PDB in memoria.</para>
        <para>Il file sottostante potrebbe essere chiuso e persino eliminato dopo la costruzione di <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />. <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> chiude automaticamente il flusso prima del completamento da parte del costruttore, a meno che non sia specificato <see cref="F:System.Reflection.Metadata.MetadataStreamOptions.LeaveOpen" />.</para>
      </summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataStringComparer">
      <summary>Fornisce helper di confronto di stringhe per eseguire query sulle stringhe nei metadati evitando l'allocazione, se possibile.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.DocumentNameBlobHandle,System.String)">
      <param name="handle" />
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.DocumentNameBlobHandle,System.String,System.Boolean)">
      <param name="handle" />
      <param name="value" />
      <param name="ignoreCase" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.NamespaceDefinitionHandle,System.String)">
      <param name="handle" />
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.NamespaceDefinitionHandle,System.String,System.Boolean)">
      <param name="handle" />
      <param name="value" />
      <param name="ignoreCase" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.StringHandle,System.String)">
      <param name="handle" />
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.StringHandle,System.String,System.Boolean)">
      <param name="handle" />
      <param name="value" />
      <param name="ignoreCase" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.StartsWith(System.Reflection.Metadata.StringHandle,System.String)">
      <param name="handle" />
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.StartsWith(System.Reflection.Metadata.StringHandle,System.String,System.Boolean)">
      <param name="handle" />
      <param name="value" />
      <param name="ignoreCase" />
    </member>
    <member name="T:System.Reflection.Metadata.MetadataStringDecoder">
      <summary>Fornisce a <see cref="T:System.Reflection.Metadata.MetadataReader" /> un meccanismo personalizzato per la decodifica delle sequenze di byte nei metadati che rappresentano il testo.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringDecoder.#ctor(System.Text.Encoding)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Reflection.Metadata.MetadataStringDecoder" /> usando la codifica specificata.</summary>
      <param name="encoding">Codifica da utilizzare.</param>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringDecoder.GetString(System.Byte*,System.Int32)">
      <summary>Ottiene le stringhe per le sequenze di byte nei metadati. Ne esegue l'override per memorizzare le stringhe nella cache, se necessario. In caso contrario, viene implementato tramite l'inoltro diretto a <see cref="P:System.Reflection.Metadata.MetadataStringDecoder.Encoding" /> e ogni chiamata allocherà una nuova stringa.</summary>
      <param name="bytes">Puntatore ai byte da decodificare.</param>
      <param name="byteCount">Numero di byte da decodificare.</param>
      <returns>Stringa decodificata.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataStringDecoder.DefaultUTF8">
      <summary>Ottiene il decodificatore predefinito usato da <see cref="T:System.Reflection.Metadata.MetadataReader" /> per decodificare UTF-8 quando non vengono forniti decodificatori al costruttore.</summary>
      <returns>Il decodificatore predefinito usato da <see cref="T:System.Reflection.Metadata.MetadataReader" /> per decodificare UTF-8.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataStringDecoder.Encoding">
      <summary>Ottiene la codifica usata da questa istanza.</summary>
      <returns>Codifica utilizzata da questa istanza.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodBodyBlock" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.Create(System.Reflection.Metadata.BlobReader)">
      <param name="reader" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.GetILBytes" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.GetILContent" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.GetILReader" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.ExceptionRegions" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.LocalSignature" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.LocalVariablesInitialized" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.MaxStack" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.Size">
      <summary>Ottiene le dimensioni del corpo del metodo, che includono le aree di intestazione, linguaggio intermedio ed eccezione.</summary>
      <returns>Dimensioni del corpo del metodo.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDebugInformation">
      <summary>Fornisce le informazioni di debug associate a una definizione di metodo. Queste informazioni sono archiviate nei metadati di debug.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformation.GetSequencePoints">
      <summary>Restituisce una raccolta di punti di sequenza decodificati da <see cref="P:System.Reflection.Metadata.MethodDebugInformation.SequencePointsBlob" />.</summary>
      <returns>Raccolta di punti di sequenza.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformation.GetStateMachineKickoffMethod">
      <summary>Restituisce il metodo di avvio della macchina a stati.</summary>
      <returns>Metodo di avvio della macchina a stati, se corrisponde al metodo <c>MoveNext</c> della macchina a stati. In caso contrario, restituisce un handle la cui proprietà <see cref="P:System.Reflection.Metadata.MethodDefinitionHandle.IsNil" /> è <see langword="true" />.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformation.Document">
      <summary>Ottiene l'handle del documento singolo contenente tutti i punti di sequenza del metodo.</summary>
      <returns>Handle del singolo documento contenente tutti i punti di sequenza del metodo o un handle la cui <see cref="P:System.Reflection.Metadata.DocumentHandle.IsNil" /> proprietà è <see langword="true" /> se il metodo non dispone di punti di sequenza o si estende su più documenti.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformation.LocalSignature">
      <summary>Restituisce un handle di firma locale.</summary>
      <returns>Handle di firma locale o handle la cui <see cref="P:System.Reflection.Metadata.StandaloneSignatureHandle.IsNil" /> proprietà è <see langword="true" /> se il metodo non definisce variabili locali.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformation.SequencePointsBlob">
      <summary>Restituisce un BLOB di codifica di punti di sequenza.</summary>
      <returns>Un punto di sequenza di codifica BLOB o un handle <see cref="P:System.Reflection.Metadata.BlobHandle.IsNil" /> la cui proprietà è <see langword="true" /> se il metodo non dispone di punti di sequenza.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDebugInformationHandle" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.Equals(System.Reflection.Metadata.MethodDebugInformationHandle)">
      <summary>Indica se l'oggetto corrente è uguale a un altro oggetto dello stesso tipo.</summary>
      <param name="other">Oggetto da confrontare con l'oggetto corrente.</param>
      <returns>
        <see langword="true" /> se l'oggetto corrente è uguale al parametro <paramref name="other" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Equality(System.Reflection.Metadata.MethodDebugInformationHandle,System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodDebugInformationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodDebugInformationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Implicit(System.Reflection.Metadata.MethodDebugInformationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Implicit(System.Reflection.Metadata.MethodDebugInformationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Inequality(System.Reflection.Metadata.MethodDebugInformationHandle,System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.ToDefinitionHandle">
      <summary>Restituisce un handle a un oggetto <see cref="T:System.Reflection.Metadata.MethodDefinition" /> corrispondente a questo handle.</summary>
      <returns>Handle di definizione di metodo che corrisponde a questo handle.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.MethodDebugInformationHandleCollection" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MethodDebugInformationHandle}#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di scorrere la raccolta.</summary>
      <returns>Enumeratore che può essere usato per scorrere la raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di eseguire l'iterazione di una raccolta.</summary>
      <returns>Oggetto <see cref="T:System.Collections.IEnumerator" /> che può essere usato per eseguire l'iterazione della raccolta.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Count">
      <summary>Ottiene il numero di elementi nella raccolta.</summary>
      <returns>Numero di elementi contenuti nella raccolta.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.MoveNext">
      <summary>Sposta l'enumeratore all'elemento successivo della raccolta.</summary>
      <returns>
        <see langword="true" /> se l'enumeratore è stato spostato correttamente in avanti in corrispondenza dell'elemento successivo, <see langword="false" /> se l'enumeratore ha superato la fine della raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Imposta l'enumeratore sulla propria posizione iniziale, ovvero prima del primo elemento nella raccolta.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Esegue attività definite dall'applicazione, come rilasciare o reimpostare risorse non gestite.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDefinition" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetDeclarativeSecurityAttributes" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetDeclaringType" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetGenericParameters" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetImport" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetParameters" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.ImplAttributes" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.Name" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.RelativeVirtualAddress" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.Signature" />
    <member name="T:System.Reflection.Metadata.MethodDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.Equals(System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary>Indica se l'oggetto corrente è uguale a un altro oggetto dello stesso tipo.</summary>
      <param name="other">Oggetto da confrontare con l'oggetto corrente.</param>
      <returns>
        <see langword="true" /> se l'oggetto corrente è uguale al parametro <paramref name="other" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Equality(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Implicit(System.Reflection.Metadata.MethodDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Implicit(System.Reflection.Metadata.MethodDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Inequality(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.ToDebugInformationHandle">
      <summary>Restituisce un handle a un oggetto <see cref="T:System.Reflection.Metadata.MethodDebugInformation" /> corrispondente a questo handle.</summary>
      <returns>Handle di informazioni di debug di metodo che corrisponde a questo handle.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.MethodDefinitionHandleCollection" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MethodDefinitionHandle}#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di scorrere la raccolta.</summary>
      <returns>Enumeratore che può essere usato per scorrere la raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di eseguire l'iterazione di una raccolta.</summary>
      <returns>Oggetto <see cref="T:System.Collections.IEnumerator" /> che può essere usato per eseguire l'iterazione della raccolta.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandleCollection.Count">
      <summary>Ottiene il numero di elementi nella raccolta.</summary>
      <returns>Numero di elementi contenuti nella raccolta.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.MoveNext">
      <summary>Sposta l'enumeratore all'elemento successivo della raccolta.</summary>
      <returns>
        <see langword="true" /> se l'enumeratore è stato spostato correttamente in avanti in corrispondenza dell'elemento successivo, <see langword="false" /> se l'enumeratore ha superato la fine della raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Imposta l'enumeratore sulla propria posizione iniziale, ovvero prima del primo elemento nella raccolta.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Esegue attività definite dall'applicazione, come rilasciare o reimpostare risorse non gestite.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodImplementation" />
    <member name="M:System.Reflection.Metadata.MethodImplementation.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.MethodImplementation.MethodBody" />
    <member name="P:System.Reflection.Metadata.MethodImplementation.MethodDeclaration" />
    <member name="P:System.Reflection.Metadata.MethodImplementation.Type" />
    <member name="T:System.Reflection.Metadata.MethodImplementationHandle" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.Equals(System.Reflection.Metadata.MethodImplementationHandle)">
      <summary>Indica se l'oggetto corrente è uguale a un altro oggetto dello stesso tipo.</summary>
      <param name="other">Oggetto da confrontare con l'oggetto corrente.</param>
      <returns>
        <see langword="true" /> se l'oggetto corrente è uguale al parametro <paramref name="other" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Equality(System.Reflection.Metadata.MethodImplementationHandle,System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodImplementationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodImplementationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Implicit(System.Reflection.Metadata.MethodImplementationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Implicit(System.Reflection.Metadata.MethodImplementationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Inequality(System.Reflection.Metadata.MethodImplementationHandle,System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.MethodImplementationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.MethodImplementationHandleCollection" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MethodImplementationHandle}#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di scorrere la raccolta.</summary>
      <returns>Enumeratore che può essere usato per scorrere la raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di eseguire l'iterazione di una raccolta.</summary>
      <returns>Oggetto <see cref="T:System.Collections.IEnumerator" /> che può essere usato per eseguire l'iterazione della raccolta.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodImplementationHandleCollection.Count">
      <summary>Ottiene il numero di elementi nella raccolta.</summary>
      <returns>Numero di elementi contenuti nella raccolta.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.MoveNext">
      <summary>Sposta l'enumeratore all'elemento successivo della raccolta.</summary>
      <returns>
        <see langword="true" /> se l'enumeratore è stato spostato correttamente in avanti in corrispondenza dell'elemento successivo, <see langword="false" /> se l'enumeratore ha superato la fine della raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Imposta l'enumeratore sulla propria posizione iniziale, ovvero prima del primo elemento nella raccolta.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Esegue attività definite dall'applicazione, come rilasciare o reimpostare risorse non gestite.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodImport" />
    <member name="P:System.Reflection.Metadata.MethodImport.Attributes" />
    <member name="P:System.Reflection.Metadata.MethodImport.Module" />
    <member name="P:System.Reflection.Metadata.MethodImport.Name" />
    <member name="T:System.Reflection.Metadata.MethodSignature`1">
      <summary>Rappresenta una firma di metodo (definizione, riferimento o autonomo) o di proprietà. Nel caso delle proprietà, la firma corrisponde a quella di un getter con <see cref="T:System.Reflection.Metadata.SignatureHeader" />di distinzione.</summary>
      <typeparam name="TType">Tipo di metodo.</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.MethodSignature`1.#ctor(System.Reflection.Metadata.SignatureHeader,`0,System.Int32,System.Int32,System.Collections.Immutable.ImmutableArray{`0})">
      <summary>Inizializza una nuova istanza della struttura <see cref="T:System.Reflection.Metadata.MethodSignature`1" /> usando le informazioni specificate per intestazione, tipo restituito e parametro.</summary>
      <param name="header">Le informazioni del byte di apertura della firma (tipo, convenzione di chiamata, flag).</param>
      <param name="returnType">Tipo restituito del metodo.</param>
      <param name="requiredParameterCount">Numero di parametri richiesti.</param>
      <param name="genericParameterCount">Numero di parametri di tipo generico.</param>
      <param name="parameterTypes">Tipi di parametro.</param>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.GenericParameterCount">
      <summary>Ottiene il numero di parametri di tipo generico per il metodo.</summary>
      <returns>Il numero di parametri di tipo generico oppure 0 per i metodi non generici.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.Header">
      <summary>Ottiene le informazioni del byte di apertura della firma (tipo, convenzione di chiamata, flag).</summary>
      <returns>Firma dell'intestazione.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.ParameterTypes">
      <summary>Ottiene i tipi dei parametri del metodo.</summary>
      <returns>Raccolta non modificabile di tipi di parametro.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.RequiredParameterCount">
      <summary>Ottiene il numero di parametri richiesti per il metodo.</summary>
      <returns>Numero di parametri richiesti.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.ReturnType">
      <summary>Ottiene il tipo restituito del metodo.</summary>
      <returns>Tipo restituito.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodSpecification" />
    <member name="M:System.Reflection.Metadata.MethodSpecification.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecification.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.MethodSpecification.Method">
      <summary>Ottiene un handle di <see langword="MethodDef" /> o <see langword="MemberRef" /> che specifica a quale metodo generico l'istanza fa riferimento, ovvero di quale metodo generico è un'istanza.</summary>
      <returns>
        <see langword="MethodDef" />Handle o <see langword="MemberRef" /> che specifica il metodo generico a cui questa istanza fa riferimento.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSpecification.Signature">
      <summary>Ottiene un handle al BLOB della firma.</summary>
      <returns>Handle per il BLOB della firma.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodSpecificationHandle" />
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.Equals(System.Reflection.Metadata.MethodSpecificationHandle)">
      <summary>Indica se l'oggetto corrente è uguale a un altro oggetto dello stesso tipo.</summary>
      <param name="other">Oggetto da confrontare con l'oggetto corrente.</param>
      <returns>
        <see langword="true" /> se l'oggetto corrente è uguale al parametro <paramref name="other" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Equality(System.Reflection.Metadata.MethodSpecificationHandle,System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodSpecificationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodSpecificationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Implicit(System.Reflection.Metadata.MethodSpecificationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Implicit(System.Reflection.Metadata.MethodSpecificationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Inequality(System.Reflection.Metadata.MethodSpecificationHandle,System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.MethodSpecificationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ModuleDefinition" />
    <member name="M:System.Reflection.Metadata.ModuleDefinition.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.BaseGenerationId" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.Generation" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.GenerationId" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.Mvid" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.Name" />
    <member name="T:System.Reflection.Metadata.ModuleDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.Equals(System.Reflection.Metadata.ModuleDefinitionHandle)">
      <summary>Indica se l'oggetto corrente è uguale a un altro oggetto dello stesso tipo.</summary>
      <param name="other">Oggetto da confrontare con l'oggetto corrente.</param>
      <returns>
        <see langword="true" /> se l'oggetto corrente è uguale al parametro <paramref name="other" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Equality(System.Reflection.Metadata.ModuleDefinitionHandle,System.Reflection.Metadata.ModuleDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ModuleDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ModuleDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Implicit(System.Reflection.Metadata.ModuleDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Implicit(System.Reflection.Metadata.ModuleDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Inequality(System.Reflection.Metadata.ModuleDefinitionHandle,System.Reflection.Metadata.ModuleDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.ModuleDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ModuleReference" />
    <member name="M:System.Reflection.Metadata.ModuleReference.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ModuleReference.Name" />
    <member name="T:System.Reflection.Metadata.ModuleReferenceHandle" />
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.Equals(System.Reflection.Metadata.ModuleReferenceHandle)">
      <summary>Indica se l'oggetto corrente è uguale a un altro oggetto dello stesso tipo.</summary>
      <param name="other">Oggetto da confrontare con l'oggetto corrente.</param>
      <returns>
        <see langword="true" /> se l'oggetto corrente è uguale al parametro <paramref name="other" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Equality(System.Reflection.Metadata.ModuleReferenceHandle,System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ModuleReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ModuleReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Implicit(System.Reflection.Metadata.ModuleReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Implicit(System.Reflection.Metadata.ModuleReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Inequality(System.Reflection.Metadata.ModuleReferenceHandle,System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.ModuleReferenceHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.NamespaceDefinition" />
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.ExportedTypes">
      <summary>Ottiene tutti i tipi esportati che risiedono direttamente in uno spazio dei nomi.</summary>
      <returns>Matrice non modificabile di handle di tipo esportati.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.Name">
      <summary>Ottiene il nome non qualificato della definizione dello spazio dei nomi.</summary>
      <returns>Nome non qualificato della definizione dello spazio dei nomi.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.NamespaceDefinitions">
      <summary>Ottiene le definizioni dello spazio dei nomi che sono figli diretti della definizione dello spazio dei nomi corrente.</summary>
      <returns>Matrice non modificabile di definizioni dello spazio dei nomi che sono elementi figlio diretti della definizione dello spazio dei nomi corrente.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.Parent">
      <summary>Ottiene lo spazio dei nomi padre.</summary>
      <returns>Spazio dei nomi padre.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.TypeDefinitions">
      <summary>Ottiene tutte le definizioni di tipi che risiedono direttamente in uno spazio dei nomi.</summary>
      <returns>Matrice non modificabile di handle di definizione di tipo.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.NamespaceDefinitionHandle">
      <summary>Fornisce un handle per una definizione dello spazio dei nomi.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.Equals(System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <summary>Indica se l'oggetto corrente è uguale a un altro oggetto dello stesso tipo.</summary>
      <param name="other">Oggetto da confrontare con l'oggetto corrente.</param>
      <returns>
        <see langword="true" /> se l'oggetto corrente è uguale al parametro <paramref name="other" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Equality(System.Reflection.Metadata.NamespaceDefinitionHandle,System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.NamespaceDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Implicit(System.Reflection.Metadata.NamespaceDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Inequality(System.Reflection.Metadata.NamespaceDefinitionHandle,System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.Parameter" />
    <member name="M:System.Reflection.Metadata.Parameter.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.Parameter.GetDefaultValue" />
    <member name="M:System.Reflection.Metadata.Parameter.GetMarshallingDescriptor" />
    <member name="P:System.Reflection.Metadata.Parameter.Attributes" />
    <member name="P:System.Reflection.Metadata.Parameter.Name" />
    <member name="P:System.Reflection.Metadata.Parameter.SequenceNumber" />
    <member name="T:System.Reflection.Metadata.ParameterHandle" />
    <member name="M:System.Reflection.Metadata.ParameterHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.Equals(System.Reflection.Metadata.ParameterHandle)">
      <summary>Indica se l'oggetto corrente è uguale a un altro oggetto dello stesso tipo.</summary>
      <param name="other">Oggetto da confrontare con l'oggetto corrente.</param>
      <returns>
        <see langword="true" /> se l'oggetto corrente è uguale al parametro <paramref name="other" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Equality(System.Reflection.Metadata.ParameterHandle,System.Reflection.Metadata.ParameterHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ParameterHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ParameterHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Implicit(System.Reflection.Metadata.ParameterHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Implicit(System.Reflection.Metadata.ParameterHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Inequality(System.Reflection.Metadata.ParameterHandle,System.Reflection.Metadata.ParameterHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.ParameterHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ParameterHandleCollection">
      <summary>Contiene una raccolta di parametri di un metodo specificato.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ParameterHandle}#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di scorrere la raccolta.</summary>
      <returns>Enumeratore che può essere usato per scorrere la raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di eseguire l'iterazione di una raccolta.</summary>
      <returns>Oggetto <see cref="T:System.Collections.IEnumerator" /> che può essere usato per eseguire l'iterazione della raccolta.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ParameterHandleCollection.Count">
      <summary>Ottiene il numero di elementi nella raccolta.</summary>
      <returns>Numero di elementi contenuti nella raccolta.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ParameterHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.MoveNext">
      <summary>Sposta l'enumeratore all'elemento successivo della raccolta.</summary>
      <returns>
        <see langword="true" /> se l'enumeratore è stato spostato correttamente in avanti in corrispondenza dell'elemento successivo, <see langword="false" /> se l'enumeratore ha superato la fine della raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Imposta l'enumeratore sulla propria posizione iniziale, ovvero prima del primo elemento nella raccolta.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Esegue attività definite dall'applicazione, come rilasciare o reimpostare risorse non gestite.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.PEReaderExtensions" />
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader)">
      <summary>Ottiene un oggetto <see cref="T:System.Reflection.Metadata.MetadataReader" /> da un oggetto <see cref="T:System.Reflection.PortableExecutable.PEReader" />.</summary>
      <param name="peReader">L'istanza <see cref="T:System.Reflection.PortableExecutable.PEReader" /> corrente.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peReader" /> è <see langword="null" />.</exception>
      <exception cref="T:System.PlatformNotSupportedException">La piattaforma corrente è big-endian.</exception>
      <exception cref="T:System.IO.IOException">Errore di I/O durante la lettura dal flusso sottostante.</exception>
      <returns>Lettore di metadati.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader,System.Reflection.Metadata.MetadataReaderOptions)">
      <summary>Ottiene un lettore di metadati con la configurazione di lettura dei metadati specificata da un elemento <see cref="T:System.Reflection.PortableExecutable.PEReader" />.</summary>
      <param name="peReader">L'istanza <see cref="T:System.Reflection.PortableExecutable.PEReader" /> corrente.</param>
      <param name="options">Valore di enumerazione che indica la configurazione di lettura dei metadati.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peReader" /> è <see langword="null" />.</exception>
      <exception cref="T:System.PlatformNotSupportedException">La piattaforma corrente è big-endian.</exception>
      <exception cref="T:System.IO.IOException">Errore di I/O durante la lettura dal flusso sottostante.</exception>
      <returns>Lettore di metadati con la configurazione di lettura dei metadati specificata.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader,System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)">
      <summary>Ottiene un lettore di metadati con la configurazione di lettura e codifica dei metadati specificata da un elemento <see cref="T:System.Reflection.PortableExecutable.PEReader" />.</summary>
      <param name="peReader">L'istanza <see cref="T:System.Reflection.PortableExecutable.PEReader" /> corrente.</param>
      <param name="options">Valore di enumerazione che indica la configurazione di lettura dei metadati.</param>
      <param name="utf8Decoder">Decodificatore stringa dei metadati con la configurazione di codifica.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peReader" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">La codifica di <paramref name="utf8Decoder" /> non è <see cref="T:System.Text.UTF8Encoding" />.</exception>
      <exception cref="T:System.PlatformNotSupportedException">La piattaforma corrente è big-endian.</exception>
      <exception cref="T:System.IO.IOException">Errore di I/O durante la lettura dal flusso sottostante.</exception>
      <returns>&gt;Lettore di metadati con la configurazione di lettura e codifica dei metadati specificata.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMethodBody(System.Reflection.PortableExecutable.PEReader,System.Int32)">
      <summary>Restituisce un blocco di corpo di un metodo con l'indirizzo RVA (Relative Virtual Address) specificato;</summary>
      <param name="peReader">L'istanza <see cref="T:System.Reflection.PortableExecutable.PEReader" /> corrente.</param>
      <param name="relativeVirtualAddress">Indirizzo RVA (Relative Virtual Address).</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peReader" /> è <see langword="null" />.</exception>
      <exception cref="T:System.BadImageFormatException">Il corpo non è disponibile nei metadati o non è valido.</exception>
      <exception cref="T:System.InvalidOperationException">La sezione in cui è archiviato il metodo non è disponibile.</exception>
      <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante la lettura dal flusso sottostante.</exception>
      <returns>Istanza del corpo del blocco del metodo.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.PrimitiveSerializationTypeCode">
      <summary>Specifica le costanti che definiscono i codici di tipo usati per codificare tipi di valori primitivi in un blob del valore <see cref="T:System.Reflection.Metadata.CustomAttribute" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Boolean">
      <summary>Tipo <see cref="T:System.Boolean" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Byte">
      <summary>Tipo intero senza segno a 1 byte.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Char">
      <summary>Tipo <see cref="T:System.Char" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Double">
      <summary>Tipo a virgola mobile a 8 byte.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Int16">
      <summary>Tipo intero con segno a 2 byte.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Int32">
      <summary>Tipo intero con segno a 4 byte.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Int64">
      <summary>Tipo intero con segno a 8 byte.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.SByte">
      <summary>Tipo intero con segno a 1 byte.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Single">
      <summary>Tipo a virgola mobile a 4 byte.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.String">
      <summary>Tipo <see cref="T:System.String" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.UInt16">
      <summary>Tipo intero senza segno a 2 byte.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.UInt32">
      <summary>Tipo intero senza segno a 4 byte.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.UInt64">
      <summary>Tipo intero senza segno a 8 byte.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.PrimitiveTypeCode">
      <summary>Specifica le costanti che definiscono i tipi primitivi trovati nelle firme dei metadati.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Boolean">
      <summary>Tipo <see cref="T:System.Boolean" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Byte">
      <summary>Tipo <see cref="T:System.Byte" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Char">
      <summary>Tipo <see cref="T:System.Char" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Double">
      <summary>Tipo <see cref="T:System.Double" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Int16">
      <summary>Tipo <see cref="T:System.Int16" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Int32">
      <summary>Tipo <see cref="T:System.Int32" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Int64">
      <summary>Tipo <see cref="T:System.Int64" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.IntPtr">
      <summary>Tipo <see cref="T:System.IntPtr" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Object">
      <summary>Tipo <see cref="T:System.Object" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.SByte">
      <summary>Tipo <see cref="T:System.SByte" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Single">
      <summary>Tipo <see cref="T:System.Single" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.String">
      <summary>Tipo <see cref="T:System.String" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.TypedReference">
      <summary>Riferimento tipizzato.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UInt16">
      <summary>Tipo <see cref="T:System.UInt16" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UInt32">
      <summary>Tipo <see cref="T:System.UInt32" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UInt64">
      <summary>Tipo <see cref="T:System.UInt64" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UIntPtr">
      <summary>Tipo <see cref="T:System.UIntPtr" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Void">
      <summary>Tipo <see cref="T:System.Void" />.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.PropertyAccessors" />
    <member name="P:System.Reflection.Metadata.PropertyAccessors.Getter" />
    <member name="P:System.Reflection.Metadata.PropertyAccessors.Others" />
    <member name="P:System.Reflection.Metadata.PropertyAccessors.Setter" />
    <member name="T:System.Reflection.Metadata.PropertyDefinition" />
    <member name="M:System.Reflection.Metadata.PropertyDefinition.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinition.GetAccessors" />
    <member name="M:System.Reflection.Metadata.PropertyDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.PropertyDefinition.GetDefaultValue" />
    <member name="P:System.Reflection.Metadata.PropertyDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.PropertyDefinition.Name" />
    <member name="P:System.Reflection.Metadata.PropertyDefinition.Signature" />
    <member name="T:System.Reflection.Metadata.PropertyDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.Equals(System.Reflection.Metadata.PropertyDefinitionHandle)">
      <summary>Indica se l'oggetto corrente è uguale a un altro oggetto dello stesso tipo.</summary>
      <param name="other">Oggetto da confrontare con l'oggetto corrente.</param>
      <returns>
        <see langword="true" /> se l'oggetto corrente è uguale al parametro <paramref name="other" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Equality(System.Reflection.Metadata.PropertyDefinitionHandle,System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.PropertyDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.PropertyDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Implicit(System.Reflection.Metadata.PropertyDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Implicit(System.Reflection.Metadata.PropertyDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Inequality(System.Reflection.Metadata.PropertyDefinitionHandle,System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.PropertyDefinitionHandleCollection" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#PropertyDefinitionHandle}#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di scorrere la raccolta.</summary>
      <returns>Enumeratore che può essere usato per scorrere la raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di eseguire l'iterazione di una raccolta.</summary>
      <returns>Oggetto <see cref="T:System.Collections.IEnumerator" /> che può essere usato per eseguire l'iterazione della raccolta.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Count">
      <summary>Ottiene il numero di elementi nella raccolta.</summary>
      <returns>Numero di elementi contenuti nella raccolta.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.MoveNext">
      <summary>Sposta l'enumeratore all'elemento successivo della raccolta.</summary>
      <returns>
        <see langword="true" /> se l'enumeratore è stato spostato correttamente in avanti in corrispondenza dell'elemento successivo, <see langword="false" /> se l'enumeratore ha superato la fine della raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Imposta l'enumeratore sulla propria posizione iniziale, ovvero prima del primo elemento nella raccolta.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Esegue attività definite dall'applicazione, come rilasciare o reimpostare risorse non gestite.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ReservedBlob`1">
      <summary>Rappresenta un handle e un BLOB corrispondente in un heap di metadati riservato per l'aggiornamento del contenuto futuro.</summary>
      <typeparam name="THandle" />
    </member>
    <member name="M:System.Reflection.Metadata.ReservedBlob`1.CreateWriter">
      <summary>Restituisce un oggetto <see cref="T:System.Reflection.Metadata.BlobWriter" /> da usare per aggiornare il contenuto.</summary>
      <returns>BLOB writer da usare per aggiornare il contenuto.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ReservedBlob`1.Content" />
    <member name="P:System.Reflection.Metadata.ReservedBlob`1.Handle">
      <summary>Ottiene l'handle di BLOB riservato.</summary>
      <returns>Handle del blocco riservato.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.SequencePoint" />
    <member name="F:System.Reflection.Metadata.SequencePoint.HiddenLine" />
    <member name="M:System.Reflection.Metadata.SequencePoint.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.SequencePoint.Equals(System.Reflection.Metadata.SequencePoint)">
      <summary>Indica se l'oggetto corrente è uguale a un altro oggetto dello stesso tipo.</summary>
      <param name="other">Oggetto da confrontare con l'oggetto corrente.</param>
      <returns>
        <see langword="true" /> se l'oggetto corrente è uguale al parametro <paramref name="other" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SequencePoint.GetHashCode" />
    <member name="P:System.Reflection.Metadata.SequencePoint.Document" />
    <member name="P:System.Reflection.Metadata.SequencePoint.EndColumn" />
    <member name="P:System.Reflection.Metadata.SequencePoint.EndLine" />
    <member name="P:System.Reflection.Metadata.SequencePoint.IsHidden" />
    <member name="P:System.Reflection.Metadata.SequencePoint.Offset" />
    <member name="P:System.Reflection.Metadata.SequencePoint.StartColumn" />
    <member name="P:System.Reflection.Metadata.SequencePoint.StartLine" />
    <member name="T:System.Reflection.Metadata.SequencePointCollection" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#SequencePoint}#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di scorrere la raccolta.</summary>
      <returns>Enumeratore che può essere usato per scorrere la raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SequencePointCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di eseguire l'iterazione di una raccolta.</summary>
      <returns>Oggetto <see cref="T:System.Collections.IEnumerator" /> che può essere usato per eseguire l'iterazione della raccolta.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.SequencePointCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.Enumerator.MoveNext">
      <summary>Sposta l'enumeratore all'elemento successivo della raccolta.</summary>
      <returns>
        <see langword="true" /> se l'enumeratore è stato spostato correttamente in avanti in corrispondenza dell'elemento successivo, <see langword="false" /> se l'enumeratore ha superato la fine della raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SequencePointCollection.Enumerator.Reset">
      <summary>Imposta l'enumeratore sulla propria posizione iniziale, ovvero prima del primo elemento nella raccolta.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.SequencePointCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Esegue attività definite dall'applicazione, come rilasciare o reimpostare risorse non gestite.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.SequencePointCollection.Enumerator.Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SequencePointCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.SerializationTypeCode">
      <summary>Specifica i codici dei tipi usati per codificare i tipi di valori in un blob <see cref="T:System.Reflection.Metadata.CustomAttributeValue`1" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Boolean">
      <summary>Valore equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Boolean" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Byte">
      <summary>Valore equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Byte" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Char">
      <summary>Valore equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Char" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Double">
      <summary>Valore equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Double" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Enum">
      <summary>L'argomento dell'attributo è un'istanza Enum.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int16">
      <summary>Valore equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int16" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int32">
      <summary>Valore equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int32" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int64">
      <summary>Valore equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int64" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Invalid">
      <summary>Valore equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Invalid" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.SByte">
      <summary>Valore equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.SByte" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Single">
      <summary>Valore equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Single" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.String">
      <summary>Valore equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.String" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.SZArray">
      <summary>Valore equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.SZArray" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.TaggedObject">
      <summary>L'argomento dell'attributo è sottoposto a conversione boxing (passato a un parametro, campo o proprietà di tipo Object) e include informazioni sul tipo nel blob dell'attributo.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Type">
      <summary>L'argomento dell'attributo è un'istanza <see cref="T:System.Type" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt16">
      <summary>Valore equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt16" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt32">
      <summary>Valore equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt32" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt64">
      <summary>Valore equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt64" />.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureAttributes">
      <summary>Specifica i flag aggiuntivi applicabili alle firme del metodo. I valori sottostanti dei campi di questo tipo corrispondono alla rappresentazione del byte di firma iniziale rappresentato da una struttura <see cref="T:System.Reflection.Metadata.SignatureHeader" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis">
      <summary>Indica il primo parametro dichiarato in modo esplicito che rappresenta il puntatore dell'istanza.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.Generic">
      <summary>Metodo generico.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.Instance">
      <summary>Metodo di istanza.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.None">
      <summary>Nessun flag.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureCallingConvention">
      <summary>Specifica in che modo gli argomenti di una determinata firma vengono passati dal chiamante al destinatario. I valori sottostanti dei campi di questo tipo corrispondono alla rappresentazione del byte di firma iniziale rappresentato da una struttura <see cref="T:System.Reflection.Metadata.SignatureHeader" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.CDecl">
      <summary>Stile di convenzione di chiamata C/C++ non gestita in cui lo stack di chiamate viene svuotato dal chiamante.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.Default">
      <summary>Convenzione di chiamata gestita con un elenco di argomenti a lunghezza fissa.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.FastCall">
      <summary>Convenzione di chiamata non gestita in cui quando possibile gli argomenti vengono passati in registri.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.StdCall">
      <summary>Convenzione di chiamata non gestita in cui lo stack di chiamate viene svuotato dal destinatario.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.ThisCall">
      <summary>Stile di convenzione di chiamata C++ non gestita per chiamare funzioni membro di istanze con un elenco di argomenti fissi.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.Unmanaged">
      <summary>Indica che le specifiche della convenzione di chiamata non gestita vengono codificate come modopts.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.VarArgs">
      <summary>Convenzione di chiamata gestita per il passaggio di argomenti aggiuntivi.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureHeader">
      <summary>Rappresenta le caratteristiche di firma specificate dal byte iniziale dei BLOB di firma.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureHeader.CallingConventionOrKindMask">
      <summary>Ottiene il valore della maschera per la tipologia della firma o la convenzione di chiamata. Il valore predefinito di <see cref="F:System.Reflection.Metadata.SignatureHeader.CallingConventionOrKindMask" /> è 15 (0x0F).</summary>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.#ctor(System.Byte)">
      <summary>Inizializza una nuova istanza della struttura <see cref="T:System.Reflection.Metadata.SignatureHeader" /> utilizzando il valore di byte specificato.</summary>
      <param name="rawValue">Byte.</param>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.#ctor(System.Reflection.Metadata.SignatureKind,System.Reflection.Metadata.SignatureCallingConvention,System.Reflection.Metadata.SignatureAttributes)">
      <summary>Inizializza una nuova istanza della struttura <see cref="T:System.Reflection.Metadata.SignatureHeader" /> usando la tipologia della firma, la convenzione di chiamata e gli attributi della firma specificati.</summary>
      <param name="kind">Tipologia della firma.</param>
      <param name="convention">Convenzione di chiamata.</param>
      <param name="attributes">Attributi della firma.</param>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.Equals(System.Object)">
      <summary>Confronta l'oggetto specificato con questo elemento <see cref="T:System.Reflection.Metadata.SignatureHeader" /> per verificare l'uguaglianza.</summary>
      <param name="obj">Oggetto da confrontare.</param>
      <returns>
        <see langword="true" /> se gli oggetti sono uguali. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.Equals(System.Reflection.Metadata.SignatureHeader)">
      <summary>Confronta due oggetti <see cref="T:System.Reflection.Metadata.SignatureHeader" /> per stabilirne l'uguaglianza dei valori.</summary>
      <param name="other">Valore da confrontare.</param>
      <returns>
        <see langword="true" /> se i valori sono uguali; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.GetHashCode">
      <summary>Ottiene un codice hash per l'oggetto corrente.</summary>
      <returns>Codice hash per l'oggetto corrente.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.op_Equality(System.Reflection.Metadata.SignatureHeader,System.Reflection.Metadata.SignatureHeader)">
      <summary>Confronta due oggetti <see cref="T:System.Reflection.Metadata.SignatureHeader" /> per stabilirne l'uguaglianza dei valori.</summary>
      <param name="left">Primo valore da confrontare.</param>
      <param name="right">Secondo valore da confrontare.</param>
      <returns>
        <see langword="true" /> se i valori sono uguali; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.op_Inequality(System.Reflection.Metadata.SignatureHeader,System.Reflection.Metadata.SignatureHeader)">
      <summary>Determina se due valori <see cref="T:System.Reflection.Metadata.SignatureHeader" /> sono diversi.</summary>
      <param name="left">Primo valore da confrontare.</param>
      <param name="right">Secondo valore da confrontare.</param>
      <returns>
        <see langword="true" /> se i valori sono diversi; in caso contrario <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.ToString">
      <summary>Restituisce una stringa che rappresenta l'oggetto corrente.</summary>
      <returns>Stringa che rappresenta l'oggetto corrente.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.Attributes">
      <summary>Ottiene gli attributi della firma.</summary>
      <returns>Attributi.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.CallingConvention">
      <summary>Ottiene la convenzione di chiamata.</summary>
      <returns>Convenzione di chiamata.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.HasExplicitThis">
      <summary>Ottiene un valore che indica se questa struttura <see cref="T:System.Reflection.Metadata.SignatureHeader" /> ha l'attributo di firma <see cref="F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis" />.</summary>
      <returns>
        <see langword="true" /> Se l' <see cref="F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis" /> attributo è presente; in caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.IsGeneric">
      <summary>Ottiene un valore che indica se questa struttura <see cref="T:System.Reflection.Metadata.SignatureHeader" /> ha l'attributo di firma <see cref="F:System.Reflection.Metadata.SignatureAttributes.Generic" />.</summary>
      <returns>
        <see langword="true" /> Se l' <see cref="F:System.Reflection.Metadata.SignatureAttributes.Generic" /> attributo è presente; in caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.IsInstance">
      <summary>Ottiene un valore che indica se questa struttura <see cref="T:System.Reflection.Metadata.SignatureHeader" /> ha l'attributo di firma <see cref="F:System.Reflection.Metadata.SignatureAttributes.Instance" />.</summary>
      <returns>
        <see langword="true" /> Se l' <see cref="F:System.Reflection.Metadata.SignatureAttributes.Instance" /> attributo è presente; in caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.Kind">
      <summary>Ottiene la tipologia della firma.</summary>
      <returns>Tipologia della firma.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.RawValue">
      <summary>Ottiene il valore non elaborato del byte intestazione.</summary>
      <returns>Valore non elaborato del byte dell'intestazione.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureKind">
      <summary>Specifica la tipologia della firma. I valori sottostanti dei campi di questo tipo corrispondono alla rappresentazione del byte di firma iniziale rappresentato da una struttura <see cref="T:System.Reflection.Metadata.SignatureHeader" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.Field">
      <summary>Firma di campo.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.LocalVariables">
      <summary>Firma della variabile locale.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.Method">
      <summary>Firma di riferimento del metodo, definizione del metodo o metodo autonomo.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.MethodSpecification">
      <summary>Firma di specifica del metodo.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.Property">
      <summary>Firma di proprietà.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureTypeCode">
      <summary>Specifica costanti che definiscono i codici del tipo usati nella codifica della firma.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Array">
      <summary>Rappresenta un elemento <see cref="T:System.Array" /> generalizzato nelle firme.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Boolean">
      <summary>Rappresenta un elemento <see cref="T:System.Boolean" /> nelle firme.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.ByReference">
      <summary>Rappresenta i puntatori gestiti (valori restituiti e parametri byref) nelle firme. È seguito nel BLOB dalla codifica di firma del tipo sottostante.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Byte">
      <summary>Rappresenta un elemento <see cref="T:System.Byte" /> nelle firme.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Char">
      <summary>Rappresenta un elemento <see cref="T:System.Char" /> nelle firme.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Double">
      <summary>Rappresenta un elemento <see cref="T:System.Double" /> nelle firme.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.FunctionPointer">
      <summary>Rappresenta i tipi di puntatore funzione nelle firme.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericMethodParameter">
      <summary>Rappresenta un parametro di metodo generico usato all'interno di una firma.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericTypeInstance">
      <summary>Rappresenta la creazione di un'istanza di un tipo generico nelle firme.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericTypeParameter">
      <summary>Rappresenta un parametro di tipo generico usato all'interno di una firma.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int16">
      <summary>Rappresenta un elemento <see cref="T:System.Int16" /> nelle firme.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int32">
      <summary>Rappresenta un elemento <see cref="T:System.Int32" /> nelle firme.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int64">
      <summary>Rappresenta un elemento <see cref="T:System.Int64" /> nelle firme.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.IntPtr">
      <summary>Rappresenta un elemento <see cref="T:System.IntPtr" /> nelle firme.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Invalid">
      <summary>Rappresenta un codice di tipo non valido o non inizializzato. Non viene visualizzato nelle firme valide.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Object">
      <summary>Rappresenta un elemento <see cref="T:System.Object" /> nelle firme.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.OptionalModifier">
      <summary>Rappresenta un modificatore personalizzato applicato a un tipo all'interno di una firma che può essere ignorato dal chiamante.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Pinned">
      <summary>Rappresenta una variabile locale bloccata da Garbage Collector.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Pointer">
      <summary>Rappresenta un puntatore non gestito nelle firme. È seguito nel BLOB dalla codifica di firma del tipo sottostante.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.RequiredModifier">
      <summary>Rappresenta un modificatore personalizzato applicato a un tipo all'interno di una firma che deve essere elaborato dal chiamante.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.SByte">
      <summary>Rappresenta un elemento <see cref="T:System.SByte" /> nelle firme.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Sentinel">
      <summary>Rappresenta un marcatore che indica la fine degli argomenti fissi e l'inizio degli argomenti variabili.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Single">
      <summary>Rappresenta un elemento <see cref="T:System.Single" /> nelle firme.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.String">
      <summary>Rappresenta un elemento <see cref="T:System.String" /> nelle firme.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.SZArray">
      <summary>Rappresenta un elemento <see cref="T:System.Array" /> unidimensionale con limite inferiore pari a 0.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.TypedReference">
      <summary>Rappresenta un riferimento tipizzato nelle firme.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.TypeHandle">
      <summary>Precede un <see cref="T:System.Reflection.Metadata.EntityHandle" /> di tipo nelle firme. Nei metadati non elaborati la codifica avviene come ELEMENT_TYPE_CLASS (0x12) per i tipi di riferimento o ELEMENT_TYPE_VALUETYPE (0x11) per i tipi di valore. Viene eseguita la compressione in un codice singolo perché le proiezioni di Windows Runtime possono proiettare dal tipo classe al tipo valore e viceversa e, in questi casi, il codice non elaborato è fuorviante.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt16">
      <summary>Rappresenta un elemento <see cref="T:System.UInt16" /> nelle firme.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt32">
      <summary>Rappresenta un elemento <see cref="T:System.UInt32" /> nelle firme.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt64">
      <summary>Rappresenta un elemento <see cref="T:System.UInt64" /> nelle firme.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UIntPtr">
      <summary>Rappresenta un elemento <see cref="T:System.UIntPtr" /> nelle firme.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Void">
      <summary>Rappresenta <see cref="T:System.Void" /> nelle firme.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureTypeKind">
      <summary>Indica la definizione del tipo della firma.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeKind.Class">
      <summary>La definizione o il riferimento del tipo indica una classe.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeKind.Unknown">
      <summary>Nel contesto corrente non è noto se il riferimento o la definizione del tipo è un tipo classe o un tipo valore.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeKind.ValueType">
      <summary>La definizione o il riferimento del tipo indica un tipo valore.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.StandaloneSignature" />
    <member name="M:System.Reflection.Metadata.StandaloneSignature.DecodeLocalSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignature.DecodeMethodSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignature.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.StandaloneSignature.GetKind">
      <summary>Determina il tipo di firma, che può essere <see cref="F:System.Reflection.Metadata.SignatureKind.Method" /> o <see cref="F:System.Reflection.Metadata.SignatureKind.LocalVariables" />.</summary>
      <exception cref="T:System.BadImageFormatException">La firma non è valida.</exception>
      <returns>Valore di enumerazione che indica il tipo di firma.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.StandaloneSignature.Signature">
      <summary>Ottiene un handle al BLOB della firma.</summary>
      <returns>Handle per il BLOB della firma.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.StandaloneSignatureHandle" />
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.Equals(System.Reflection.Metadata.StandaloneSignatureHandle)">
      <summary>Indica se l'oggetto corrente è uguale a un altro oggetto dello stesso tipo.</summary>
      <param name="other">Oggetto da confrontare con l'oggetto corrente.</param>
      <returns>
        <see langword="true" /> se l'oggetto corrente è uguale al parametro <paramref name="other" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Equality(System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.StandaloneSignatureHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.StandaloneSignatureHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Implicit(System.Reflection.Metadata.StandaloneSignatureHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Implicit(System.Reflection.Metadata.StandaloneSignatureHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Inequality(System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.StandaloneSignatureHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.StandaloneSignatureKind">
      <summary>Indica se un elemento <see cref="T:System.Reflection.Metadata.StandaloneSignature" /> rappresenta una firma di metodo autonomo o di variabile locale.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.StandaloneSignatureKind.LocalVariables">
      <summary>L'elemento <see cref="T:System.Reflection.Metadata.MemberReference" /> fa riferimento a una firma di variabile locale.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.StandaloneSignatureKind.Method">
      <summary>L'elemento <see cref="T:System.Reflection.Metadata.StandaloneSignature" /> rappresenta una firma di metodo autonomo.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.StringHandle" />
    <member name="M:System.Reflection.Metadata.StringHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.Equals(System.Reflection.Metadata.StringHandle)">
      <summary>Indica se l'oggetto corrente è uguale a un altro oggetto dello stesso tipo.</summary>
      <param name="other">Oggetto da confrontare con l'oggetto corrente.</param>
      <returns>
        <see langword="true" /> se l'oggetto corrente è uguale al parametro <paramref name="other" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.StringHandle.op_Equality(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.StringHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.op_Implicit(System.Reflection.Metadata.StringHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.op_Inequality(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.StringHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.TypeDefinition" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetDeclarativeSecurityAttributes" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetDeclaringType">
      <summary>Restituisce il tipo di inclusione di un tipo nidificato specificato.</summary>
      <returns>Il tipo di inclusione del tipo nidificato specificato o un handle la cui proprietà <see cref="P:System.Reflection.Metadata.TypeDefinitionHandle.IsNil" /> è <see langword="true" /> se il tipo non è nidificato.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetEvents" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetFields" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetGenericParameters" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetInterfaceImplementations" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetLayout" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetMethodImplementations" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetMethods" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetNestedTypes">
      <summary>Restituisce una matrice di tipi nidificati nel tipo specificato.</summary>
      <returns>Una matrice non modificabile di handle di definizione del tipo che rappresentano i tipi nidificati nel tipo specificato.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetProperties" />
    <member name="P:System.Reflection.Metadata.TypeDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.TypeDefinition.BaseType">
      <summary>Ottiene il tipo di base della definizione del tipo: <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> o <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />.</summary>
      <returns>Tipo di base della definizione del tipo.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.IsNested">
      <summary>Ottiene un valore che indica se si tratta di un tipo nidificato.</summary>
      <returns>
        <see langword="true" /> Se è un tipo annidato; <see langword="false" /> in caso contrario,.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.Name">
      <summary>Ottiene il nome del tipo.</summary>
      <returns>Nome del tipo.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.Namespace">
      <summary>Ottiene il nome completo dello spazio dei nomi in cui è definito il tipo.</summary>
      <returns>Nome completo dello spazio dei nomi in cui è definito il tipo oppure handle la cui <see cref="P:System.Reflection.Metadata.StringHandle.IsNil" /> proprietà è <see langword="true" /> se il tipo è annidato o definito in uno spazio dei nomi radice.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.NamespaceDefinition">
      <summary>Ottiene l'handle di definizione dello spazio dei nomi in cui è definito il tipo.</summary>
      <returns>Handle di definizione dello spazio dei nomi in cui è definito il tipo oppure un handle la cui <see cref="P:System.Reflection.Metadata.NamespaceDefinitionHandle.IsNil" /> proprietà è <see langword="true" />  se il tipo è annidato o definito in uno spazio dei nomi radice.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.Equals(System.Reflection.Metadata.TypeDefinitionHandle)">
      <summary>Indica se l'oggetto corrente è uguale a un altro oggetto dello stesso tipo.</summary>
      <param name="other">Oggetto da confrontare con l'oggetto corrente.</param>
      <returns>
        <see langword="true" /> se l'oggetto corrente è uguale al parametro <paramref name="other" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Equality(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.TypeDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.TypeDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Implicit(System.Reflection.Metadata.TypeDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Implicit(System.Reflection.Metadata.TypeDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Inequality(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.TypeDefinitionHandleCollection">
      <summary>Contiene una raccolta di istanze di <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#TypeDefinitionHandle}#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di scorrere la raccolta.</summary>
      <returns>Enumeratore che può essere usato per scorrere la raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di eseguire l'iterazione di una raccolta.</summary>
      <returns>Oggetto <see cref="T:System.Collections.IEnumerator" /> che può essere usato per eseguire l'iterazione della raccolta.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandleCollection.Count">
      <summary>Ottiene il numero di elementi nella raccolta.</summary>
      <returns>Numero di elementi contenuti nella raccolta.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.MoveNext">
      <summary>Sposta l'enumeratore all'elemento successivo della raccolta.</summary>
      <returns>
        <see langword="true" /> se l'enumeratore è stato spostato correttamente in avanti in corrispondenza dell'elemento successivo, <see langword="false" /> se l'enumeratore ha superato la fine della raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Imposta l'enumeratore sulla propria posizione iniziale, ovvero prima del primo elemento nella raccolta.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Esegue attività definite dall'applicazione, come rilasciare o reimpostare risorse non gestite.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeLayout" />
    <member name="M:System.Reflection.Metadata.TypeLayout.#ctor(System.Int32,System.Int32)">
      <param name="size" />
      <param name="packingSize" />
    </member>
    <member name="P:System.Reflection.Metadata.TypeLayout.IsDefault" />
    <member name="P:System.Reflection.Metadata.TypeLayout.PackingSize" />
    <member name="P:System.Reflection.Metadata.TypeLayout.Size" />
    <member name="T:System.Reflection.Metadata.TypeReference" />
    <member name="P:System.Reflection.Metadata.TypeReference.Name">
      <summary>Ottiene il nome del tipo di destinazione.</summary>
      <returns>Nome del tipo di destinazione.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReference.Namespace">
      <summary>Ottiene il nome completo dello spazio dei nomi in cui è definito il tipo di destinazione.</summary>
      <returns>Nome completo dello spazio dei nomi in cui è definito il tipo di destinazione oppure handle la cui <see cref="P:System.Reflection.Metadata.StringHandle.IsNil" /> proprietà è <see langword="true" /> se il tipo è annidato o definito in uno spazio dei nomi radice.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReference.ResolutionScope">
      <summary>Ottiene l'ambito di soluzione in cui è definito il tipo di destinazione ed è identificato in modo univoco dagli oggetti <see cref="P:System.Reflection.Metadata.TypeReference.Namespace" /> e <see cref="P:System.Reflection.Metadata.TypeReference.Name" /> specificati.</summary>
      <returns>Ambito di risoluzione in cui il tipo di destinazione è definito in modo univoco.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeReferenceHandle" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.Equals(System.Reflection.Metadata.TypeReferenceHandle)">
      <summary>Indica se l'oggetto corrente è uguale a un altro oggetto dello stesso tipo.</summary>
      <param name="other">Oggetto da confrontare con l'oggetto corrente.</param>
      <returns>
        <see langword="true" /> se l'oggetto corrente è uguale al parametro <paramref name="other" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Equality(System.Reflection.Metadata.TypeReferenceHandle,System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.TypeReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.TypeReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Implicit(System.Reflection.Metadata.TypeReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Implicit(System.Reflection.Metadata.TypeReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Inequality(System.Reflection.Metadata.TypeReferenceHandle,System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.TypeReferenceHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.TypeReferenceHandleCollection">
      <summary>Contiene una raccolta di istanze di <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#TypeReferenceHandle}#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di scorrere la raccolta.</summary>
      <returns>Enumeratore che può essere usato per scorrere la raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di eseguire l'iterazione di una raccolta.</summary>
      <returns>Oggetto <see cref="T:System.Collections.IEnumerator" /> che può essere usato per eseguire l'iterazione della raccolta.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReferenceHandleCollection.Count">
      <summary>Ottiene il numero di elementi nella raccolta.</summary>
      <returns>Numero di elementi contenuti nella raccolta.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.MoveNext">
      <summary>Sposta l'enumeratore all'elemento successivo della raccolta.</summary>
      <returns>
        <see langword="true" /> se l'enumeratore è stato spostato correttamente in avanti in corrispondenza dell'elemento successivo, <see langword="false" /> se l'enumeratore ha superato la fine della raccolta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Imposta l'enumeratore sulla propria posizione iniziale, ovvero prima del primo elemento nella raccolta.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Esegue attività definite dall'applicazione, come rilasciare o reimpostare risorse non gestite.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Ottiene l'elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Elemento della raccolta in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeSpecification" />
    <member name="M:System.Reflection.Metadata.TypeSpecification.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecification.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.TypeSpecification.Signature" />
    <member name="T:System.Reflection.Metadata.TypeSpecificationHandle" />
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.Equals(System.Reflection.Metadata.TypeSpecificationHandle)">
      <summary>Indica se l'oggetto corrente è uguale a un altro oggetto dello stesso tipo.</summary>
      <param name="other">Oggetto da confrontare con l'oggetto corrente.</param>
      <returns>
        <see langword="true" /> se l'oggetto corrente è uguale al parametro <paramref name="other" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Equality(System.Reflection.Metadata.TypeSpecificationHandle,System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.TypeSpecificationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.TypeSpecificationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Implicit(System.Reflection.Metadata.TypeSpecificationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Implicit(System.Reflection.Metadata.TypeSpecificationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Inequality(System.Reflection.Metadata.TypeSpecificationHandle,System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.TypeSpecificationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.UserStringHandle">
      <summary>Rappresenta un handle per l'heap delle stringhe utente.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.Equals(System.Reflection.Metadata.UserStringHandle)">
      <summary>Indica se l'oggetto corrente è uguale a un altro oggetto dello stesso tipo.</summary>
      <param name="other">Oggetto da confrontare con l'oggetto corrente.</param>
      <returns>
        <see langword="true" /> se l'oggetto corrente è uguale al parametro <paramref name="other" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Equality(System.Reflection.Metadata.UserStringHandle,System.Reflection.Metadata.UserStringHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.UserStringHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Implicit(System.Reflection.Metadata.UserStringHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Inequality(System.Reflection.Metadata.UserStringHandle,System.Reflection.Metadata.UserStringHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.UserStringHandle.IsNil" />
    <member name="T:System.Reflection.MethodImportAttributes" />
    <member name="F:System.Reflection.MethodImportAttributes.BestFitMappingDisable" />
    <member name="F:System.Reflection.MethodImportAttributes.BestFitMappingEnable" />
    <member name="F:System.Reflection.MethodImportAttributes.BestFitMappingMask" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionCDecl" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionFastCall" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionMask" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionStdCall" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionThisCall" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionWinApi" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetAnsi" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetAuto" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetMask" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetUnicode" />
    <member name="F:System.Reflection.MethodImportAttributes.ExactSpelling" />
    <member name="F:System.Reflection.MethodImportAttributes.None" />
    <member name="F:System.Reflection.MethodImportAttributes.SetLastError" />
    <member name="F:System.Reflection.MethodImportAttributes.ThrowOnUnmappableCharDisable" />
    <member name="F:System.Reflection.MethodImportAttributes.ThrowOnUnmappableCharEnable" />
    <member name="F:System.Reflection.MethodImportAttributes.ThrowOnUnmappableCharMask" />
    <member name="T:System.Reflection.MethodSemanticsAttributes" />
    <member name="F:System.Reflection.MethodSemanticsAttributes.Adder">
      <summary>
        <para>Usato per aggiungere un gestore per un evento. Corrisponde al flag <see langword="AddOn" /> nella specifica ECMA-335 CLI.</para>
        <para>Al nome dei metodi di aggiunta conformi a CLS viene aggiunto il prefisso <see langword="add_" />.</para>
      </summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Getter">
      <summary>
        <para>Legge il valore della proprietà.</para>
        <para>Il nome dei getter conformi a CLS viene definito con l'aggiunta del prefisso get_.</para>
      </summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Other">
      <summary>Altro metodo per una proprietà (non un getter o un setter) o per un evento (non di aggiunta, rimozione o generazione).</summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Raiser">
      <summary>
        <para>Usato per indicare che si è verificato un evento. Corrisponde al flag <see langword="Fire" /> nella specifica ECMA-335 CLI.</para>
        <para> Il nome dei metodi di generazione conformi a CLS viene definito con l'aggiunta del prefisso <see langword="raise_" />.</para>
      </summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Remover">
      <summary>
        <para>Usato per rimuovere un gestore per un evento. Corrisponde al flag <see langword="RemoveOn" /> nella specifica ECMA-335 CLI.</para>
        <para>Il nome dei metodi di rimozione conformi a CLS viene definito con l'aggiunta del prefisso <see langword="remove_" />.</para>
      </summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Setter">
      <summary>
        <para>Usato per modificare il valore della proprietà.</para>
        <para>Il nome dei setter conformi a CLS viene definito con l'aggiunta del prefisso <see langword="set_" />.</para>
      </summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.Characteristics" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.AggressiveWSTrim" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.Bit32Machine" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.BytesReversedHi" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.BytesReversedLo" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.DebugStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.Dll" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.ExecutableImage" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.LargeAddressAware" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.LineNumsStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.LocalSymsStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.NetRunFromSwap" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.RelocsStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.RemovableRunFromSwap" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.System" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.UpSystemOnly" />
    <member name="T:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData">
      <summary>Fornisce informazioni su un file di database di debug programma (PDB, Program Debug Database).</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData.Age">
      <summary>Iterazione del PDB. La prima iterazione è 1. L'iterazione viene incrementata ogni volta che il contenuto del PDB viene aumentato.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData.Guid">
      <summary>Identificatore univoco globale (GUID, Globally Unique Identifier) del PDB associato.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData.Path">
      <summary>Percorso del file con estensione pdb contenente le informazioni di debug per il file PE/COFF.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.CoffHeader">
      <summary>Rappresenta l'intestazione di un file COFF.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.Characteristics">
      <summary>Ottiene i flag che indicano gli attributi del file.</summary>
      <returns>Flag che indicano gli attributi del file.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.Machine">
      <summary>Ottiene il tipo del computer di destinazione.</summary>
      <returns>Tipo del computer di destinazione.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.NumberOfSections">
      <summary>Ottiene il numero di sezioni. Indica la dimensione della tabella della sezione che segue immediatamente le intestazioni.</summary>
      <returns>Numero di sezioni.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.NumberOfSymbols">
      <summary>Ottiene il numero di voci incluse nella tabella dei simboli. Questi dati possono essere usati per individuare la tabella di stringhe che segue immediatamente la tabella dei simboli. Questo valore deve essere zero per un'immagine PE.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.PointerToSymbolTable">
      <summary>Ottiene il puntatore del file alla tabella dei simboli COFF.</summary>
      <returns>Puntatore di file alla tabella dei simboli COFF oppure zero se non è presente alcuna tabella dei simboli COFF. Questo valore deve essere zero per un'immagine PE.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.SizeOfOptionalHeader">
      <summary>Ottiene la dimensione dell'intestazione facoltativa, obbligatoria per i file eseguibili ma non per i file oggetto. Questo valore deve essere zero per file oggetto.</summary>
      <returns>Dimensione dell'intestazione facoltativa.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.TimeDateStamp">
      <summary>Ottiene un valore che indica la data e l'ora di creazione del file.</summary>
      <returns>32 bit bassi del numero di secondi a partire 00:00 dal 1 ° gennaio 1970, che indica quando è stato creato il file.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.CorFlags">
      <summary>COR20Flags</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.CorFlags.ILLibrary" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.ILOnly" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.NativeEntryPoint" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.Prefers32Bit" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.Requires32Bit" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.StrongNameSigned" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.TrackDebugData" />
    <member name="T:System.Reflection.PortableExecutable.CorHeader" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.CodeManagerTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.EntryPointTokenOrRelativeVirtualAddress" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.ExportAddressTableJumpsDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.Flags" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.MajorRuntimeVersion" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.ManagedNativeHeaderDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.MetadataDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.MinorRuntimeVersion" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.ResourcesDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.StrongNameSignatureDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.VtableFixupsDirectory" />
    <member name="T:System.Reflection.PortableExecutable.DebugDirectoryBuilder" />
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.#ctor">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Reflection.PortableExecutable.DebugDirectoryBuilder" />.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddCodeViewEntry(System.String,System.Reflection.Metadata.BlobContentId,System.UInt16)">
      <summary>Aggiunge una voce CodeView.</summary>
      <param name="pdbPath">Percorso del PDB. Non deve essere vuoto.</param>
      <param name="pdbContentId">ID univoco del contenuto del PDB.</param>
      <param name="portablePdbVersion">Versione del formato del PDB portatile, ad esempio 0x0100 per 1.0, oppure 0 se il PDB non è portatile.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="pdbPath" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="pdbPath" /> contiene un carattere NUL.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="portablePdbVersion" /> è minore di 0x0100.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddEmbeddedPortablePdbEntry(System.Reflection.Metadata.BlobBuilder,System.UInt16)">
      <summary>Aggiunge una voce del PDB portatile incorporata.</summary>
      <param name="debugMetadata">Generatore di metadati del PDB portatile.</param>
      <param name="portablePdbVersion">Versione del formato del PDB portatile, ad esempio 0x0100 per 1.0.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="debugMetadata" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="portablePdbVersion" /> è minore di 0x0100.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddEntry(System.Reflection.PortableExecutable.DebugDirectoryEntryType,System.UInt32,System.UInt32)">
      <summary>Aggiunge una voce del tipo specificato.</summary>
      <param name="type">Tipo di voce.</param>
      <param name="version">Versione della voce.</param>
      <param name="stamp">Stamp della voce.</param>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddEntry``1(System.Reflection.PortableExecutable.DebugDirectoryEntryType,System.UInt32,System.UInt32,``0,System.Action{System.Reflection.Metadata.BlobBuilder,``0})">
      <summary>Aggiunge una voce del tipo specificato e ne serializza i dati.</summary>
      <param name="type">Tipo di voce.</param>
      <param name="version">Versione della voce.</param>
      <param name="stamp">Stamp della voce.</param>
      <param name="data">Dati da passare a <paramref name="dataSerializer" />.</param>
      <param name="dataSerializer">Serializzatore per la serializzazione dei dati in un <see cref="T:System.Reflection.Metadata.BlobBuilder" />.</param>
      <typeparam name="TData">Tipo di dati passati a <paramref name="dataSerializer" /> .</typeparam>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddPdbChecksumEntry(System.String,System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>Aggiunge la voce di checksum PDB.</summary>
      <param name="algorithmName">Nome dell'algoritmo hash (ad esempio, "SHA256").</param>
      <param name="checksum">Checksum.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="algorithmName" /> o <paramref name="checksum" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="algorithmName" /> o <paramref name="checksum" /> è vuoto.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddReproducibleEntry">
      <summary>Aggiunge una voce riproducibile.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.DebugDirectoryEntry">
      <summary>Identifica la posizione, le dimensioni e il formato di un blocco di informazioni di debug.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryEntry.#ctor(System.UInt32,System.UInt16,System.UInt16,System.Reflection.PortableExecutable.DebugDirectoryEntryType,System.Int32,System.Int32,System.Int32)">
      <summary>Inizializza una nuova istanza della struttura <see cref="T:System.Reflection.PortableExecutable.DebugDirectoryEntry" />.</summary>
      <param name="stamp" />
      <param name="majorVersion" />
      <param name="minorVersion" />
      <param name="type" />
      <param name="dataSize" />
      <param name="dataRelativeVirtualAddress" />
      <param name="dataPointer" />
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.DataPointer">
      <summary>Ottiene il puntatore del file ai dati di debug.</summary>
      <returns>Puntatore di file ai dati di debug.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.DataRelativeVirtualAddress">
      <summary>Ottiene l'indirizzo dei dati di debug quando vengono caricati, relativi alla base dell'immagine.</summary>
      <returns>Indirizzo dei dati di debug relativi alla base dell'immagine.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.DataSize">
      <summary>Ottiene le dimensioni dei dati di debug (esclusa la directory di debug).</summary>
      <returns>dimensione dei dati di debug (esclusa la directory di debug).</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.IsPortableCodeView">
      <summary>Ottiene un valore che indica se la voce è una voce <see cref="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView" /> che punta a un PDB portatile.</summary>
      <returns>
        <see langword="true" /> Se la voce è una <see cref="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView" /> voce che punta a un PDB portatile; in caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.MajorVersion">
      <summary>Ottiene il numero di versione principale del formato dei dati di debug.</summary>
      <returns>Numero di versione principale del formato dati di debug.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.MinorVersion">
      <summary>Ottiene il numero di versione secondaria del formato dei dati di debug.</summary>
      <returns>Numero di versione secondario del formato dati di debug.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.Stamp">
      <summary>Ottiene l'ora e la data di creazione dei dati di debug se il file PE/COFF non è deterministico; in caso contrario, ottiene un valore basato sull'hash del contenuto.</summary>
      <returns>per un file PE/COFF non deterministico, la data e l'ora di creazione dei dati di debug; in caso contrario, un valore basato sull'hash del contenuto.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.Type">
      <summary>Ottiene il formato delle informazioni di debug.</summary>
      <returns>Formato delle informazioni di debug.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.DebugDirectoryEntryType">
      <summary>Enumerazione che descrive il formato delle informazioni di debug di <see cref="T:System.Reflection.PortableExecutable.DebugDirectoryEntry" />.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView">
      <summary>Descrizione del file PDB associato.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Coff">
      <summary>Informazioni di debug COFF (numeri di riga, tabella dei simboli e tabella di stringhe). Questo tipo di informazioni di debug è indicato anche dai campi nelle intestazioni dei file.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.EmbeddedPortablePdb">
      <summary>
        <para>La voce punta a un BLOB contenente un PDB portatile incorporato. Il BLOB del PDB portatile incorporato ha il formato seguente:</para>
        <para>- blob ::= uncompressed-size data</para>
        <para>- I dati si estendono sul resto del BLOB e contengono un PDB portatile compresso Deflate.</para>
      </summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.PdbChecksum">
      <summary>La voce archivia un hash di crittografia del contenuto del file dei simboli con cui è stato compilato il file PE/COFF. L'hash può essere usato per convalidare che un determinato file PDB è stato compilato con il file PE/COFF e non è stato modificato in alcun modo. Possono essere presenti più voci se sono stati generati più PDB durante la compilazione del file PE/COFF, ad esempio simboli privati e pubblici.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Reproducible">
      <summary>La presenza di questa voce indica un file PE/COFF deterministico. Per altre informazioni, vedere la sezione Osservazioni.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Unknown">
      <summary>Valore sconosciuto che deve essere ignorato da tutti gli strumenti.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.DirectoryEntry" />
    <member name="F:System.Reflection.PortableExecutable.DirectoryEntry.RelativeVirtualAddress" />
    <member name="F:System.Reflection.PortableExecutable.DirectoryEntry.Size" />
    <member name="M:System.Reflection.PortableExecutable.DirectoryEntry.#ctor(System.Int32,System.Int32)">
      <param name="relativeVirtualAddress" />
      <param name="size" />
    </member>
    <member name="T:System.Reflection.PortableExecutable.DllCharacteristics">
      <summary>Descrive le caratteristiche di una libreria di collegamento dinamico.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.AppContainer">
      <summary>L'immagine deve essere eseguita all'interno di un AppContainer.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.DynamicBase">
      <summary>La DLL può essere rilocata.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.HighEntropyVirtualAddressSpace">
      <summary>L'immagine può gestire uno spazio indirizzi virtuali a 64 bit a entropia elevata.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NoBind">
      <summary>Non associare questa immagine.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NoIsolation">
      <summary>L'immagine riconosce l'isolamento e non lo vuole.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NoSeh">
      <summary>L'immagine non usa SEH. Nessun gestore SE può trovarsi in questa immagine.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NxCompatible">
      <summary>L'immagine è compatibile con NX.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ProcessInit">
      <summary>Riservato.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ProcessTerm">
      <summary>Riservato.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.TerminalServerAware">
      <summary>L'immagine è compatibile con Terminal Server.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ThreadInit">
      <summary>Riservato.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ThreadTerm">
      <summary>Riservato.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.WdmDriver">
      <summary>Il driver usa il modello WDM.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.Machine">
      <summary>Specifica l'architettura della CPU del computer di destinazione.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Alpha">
      <summary>Alpha.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Alpha64">
      <summary>ALPHA64.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.AM33">
      <summary>Matsushita AM33.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Amd64">
      <summary>AMD64 (K8).</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Arm">
      <summary>ARM little endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Arm64">
      <summary>ARM64.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.ArmThumb2">
      <summary>ARM Thumb-2 little endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Ebc">
      <summary>Codice byte EFI.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.I386">
      <summary>Intel 386.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.IA64">
      <summary>Intel 64.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.M32R">
      <summary>M32R little-endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.MIPS16">
      <summary>MIPS.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.MipsFpu">
      <summary>MIPS con FPU.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.MipsFpu16">
      <summary>MIPS16 con FPU.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.PowerPC">
      <summary>IBM PowerPC little endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.PowerPCFP">
      <summary>PowerPCFP.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH3">
      <summary>Hitachi SH3 little endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH3Dsp">
      <summary>Hitachi SH3 DSP.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH3E">
      <summary>Hitachi SH3 little endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH4">
      <summary>Hitachi SH4 little endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH5">
      <summary>Hitachi SH5.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Thumb">
      <summary>Thumb.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Tricore">
      <summary>Infineon.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Unknown">
      <summary>CPU di destinazione sconosciuta o non specificata.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.WceMipsV2">
      <summary>MIPS little-endian WCE v2.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.ManagedPEBuilder" />
    <member name="F:System.Reflection.PortableExecutable.ManagedPEBuilder.ManagedResourcesDataAlignment" />
    <member name="F:System.Reflection.PortableExecutable.ManagedPEBuilder.MappedFieldDataAlignment" />
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.#ctor(System.Reflection.PortableExecutable.PEHeaderBuilder,System.Reflection.Metadata.Ecma335.MetadataRootBuilder,System.Reflection.Metadata.BlobBuilder,System.Reflection.Metadata.BlobBuilder,System.Reflection.Metadata.BlobBuilder,System.Reflection.PortableExecutable.ResourceSectionBuilder,System.Reflection.PortableExecutable.DebugDirectoryBuilder,System.Int32,System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.PortableExecutable.CorFlags,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Reflection.Metadata.BlobContentId})">
      <param name="header" />
      <param name="metadataRootBuilder" />
      <param name="ilStream" />
      <param name="mappedFieldData" />
      <param name="managedResources" />
      <param name="nativeResources" />
      <param name="debugDirectoryBuilder" />
      <param name="strongNameSignatureSize" />
      <param name="entryPoint" />
      <param name="flags" />
      <param name="deterministicIdProvider" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.CreateSections" />
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.GetDirectories" />
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.SerializeSection(System.String,System.Reflection.PortableExecutable.SectionLocation)">
      <param name="name" />
      <param name="location" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.Sign(System.Reflection.Metadata.BlobBuilder,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Byte[]})">
      <param name="peImage" />
      <param name="signatureProvider" />
    </member>
    <member name="T:System.Reflection.PortableExecutable.PdbChecksumDebugDirectoryData">
      <summary>Rappresenta una voce di directory di debug di checksum PDB.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PdbChecksumDebugDirectoryData.AlgorithmName">
      <summary>Nome dell'algoritmo hash di crittografia usato per calcolare il checksum.</summary>
      <returns>Stringa che rappresenta il nome dell'algoritmo hash di crittografia utilizzato per calcolare il checksum.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PdbChecksumDebugDirectoryData.Checksum">
      <summary>Checksum del contenuto PDB.</summary>
      <returns>Matrice non modificabile di byte che rappresenta il checksum del contenuto PDB.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEBuilder" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.#ctor(System.Reflection.PortableExecutable.PEHeaderBuilder,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Reflection.Metadata.BlobContentId})">
      <param name="header" />
      <param name="deterministicIdProvider" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.CreateSections" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.GetDirectories" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.GetSections" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.Serialize(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.SerializeSection(System.String,System.Reflection.PortableExecutable.SectionLocation)">
      <param name="name" />
      <param name="location" />
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEBuilder.Header" />
    <member name="P:System.Reflection.PortableExecutable.PEBuilder.IdProvider" />
    <member name="P:System.Reflection.PortableExecutable.PEBuilder.IsDeterministic" />
    <member name="T:System.Reflection.PortableExecutable.PEBuilder.Section" />
    <member name="F:System.Reflection.PortableExecutable.PEBuilder.Section.Characteristics" />
    <member name="F:System.Reflection.PortableExecutable.PEBuilder.Section.Name" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.Section.#ctor(System.String,System.Reflection.PortableExecutable.SectionCharacteristics)">
      <param name="name" />
      <param name="characteristics" />
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEDirectoriesBuilder">
      <summary>Compila le directory PE.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEDirectoriesBuilder.#ctor">
      <summary>Inizializza un'istanza della classe <see cref="T:System.Reflection.PortableExecutable.PEDirectoriesBuilder" />.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.AddressOfEntryPoint">
      <summary>Indirizzo del punto di ingresso relativo alla base dell'immagine quando il file di tipo PE viene caricato in memoria.</summary>
      <returns>Per le immagini del programma, questo è l'indirizzo iniziale. Per i driver di dispositivo, questo è l'indirizzo della funzione di inizializzazione. Un punto di ingresso è facoltativo per le dll. Quando non è presente alcun punto di ingresso, questo campo deve essere zero.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.BaseRelocationTable">
      <summary>Voce di directory dell'immagine della tabella di rilocazione di base.</summary>
      <returns>Istanza della voce di directory.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.BoundImportTable">
      <summary>Voce di directory dell'immagine di importazione associata.</summary>
      <returns>Istanza della voce di directory.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.CopyrightTable">
      <summary>Voce di directory dell'immagine dell'architettura/copyright.</summary>
      <returns>Istanza della voce di directory.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.CorHeaderTable">
      <summary>Voce di directory dell'immagine della tabella descrittori COM.</summary>
      <returns>Istanza della voce di directory.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.DebugTable">
      <summary>Voce di directory dell'immagine della tabella di debug.</summary>
      <returns>Istanza della voce di directory.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.DelayImportTable">
      <summary>Voce di directory dell'immagine della tabella di importazione ritardata.</summary>
      <returns>Istanza della voce di directory.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ExceptionTable">
      <summary>Voce di directory dell'immagine della tabella di eccezione.</summary>
      <returns>Istanza della voce di directory.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ExportTable">
      <summary>Voce di directory dell'immagine della tabella di esportazione.</summary>
      <returns>Istanza della voce di directory.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.GlobalPointerTable">
      <summary>Voce di directory dell'immagine della tabella del puntatore globale.</summary>
      <returns>Istanza della voce di directory.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ImportAddressTable">
      <summary>Voce della directory dell'immagine della tabella di indirizzi di importazione.</summary>
      <returns>Istanza della voce di directory.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ImportTable">
      <summary>Voce di directory dell'immagine della tabella di importazione.</summary>
      <returns>Istanza della voce di directory.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.LoadConfigTable">
      <summary>Voce di directory dell'immagine della tabella di configurazione per il caricamento.</summary>
      <returns>Istanza della voce di directory.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ResourceTable">
      <summary>Voce di directory dell'immagine della tabella di risorse.</summary>
      <returns>Istanza della voce di directory.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ThreadLocalStorageTable">
      <summary>Voce di directory dell'immagine della tabella di archiviazione thread-local (TLS).</summary>
      <returns>Istanza della voce di directory.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEHeader" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.AddressOfEntryPoint">
      <summary>Ottiene l'indirizzo del punto di ingresso relativo alla base dell'immagine quando il file di tipo PE viene caricato in memoria.</summary>
      <returns>Indirizzo del punto di ingresso relativo alla base dell'immagine.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BaseOfCode">
      <summary>Ottiene l'indirizzo della sezione di inizio del codice relativa alla base dell'immagine quando l'immagine viene caricata in memoria.</summary>
      <returns>Indirizzo della sezione di inizio del codice relativa alla base dell'immagine.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BaseOfData">
      <summary>Ottiene l'indirizzo della sezione di inizio dei dati relativa alla base dell'immagine quando l'immagine viene caricata in memoria.</summary>
      <returns>Indirizzo della sezione di inizio dei dati relativa alla base dell'immagine.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BaseRelocationTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BoundImportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CertificateTableDirectory">
      <summary>Ottiene la voce della tabella dei certificati, che fa riferimento a una tabella di certificati di attributi.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CheckSum">
      <summary>Ottiene il checksum del file di immagine.</summary>
      <returns>Checksum del file di immagine.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CopyrightTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CorHeaderTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.DebugTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.DelayImportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.DllCharacteristics" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ExceptionTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ExportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.FileAlignment">
      <summary>Ottiene il fattore di allineamento (in byte) usato per allineare i dati non elaborati delle sezioni nel file di immagine.</summary>
      <returns>Potenza di 2 compreso tra 512 e 64K inclusi. Il valore predefinito è 512.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.GlobalPointerTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ImageBase">
      <summary>Ottiene l'indirizzo preferito del primo byte dell'immagine quando viene caricata in memoria.</summary>
      <returns>Indirizzo preferito, ovvero un multiplo di 64K.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ImportAddressTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ImportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.LoadConfigTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.Magic">
      <summary>Ottiene un valore che identifica il formato del file di immagine.</summary>
      <returns>Formato del file di immagine.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorImageVersion">
      <summary>Ottiene il numero di versione principale dell'immagine.</summary>
      <returns>Numero di versione principale dell'immagine.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorLinkerVersion">
      <summary>Ottiene il numero di versione principale del linker.</summary>
      <returns>Numero di versione principale del linker.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorOperatingSystemVersion">
      <summary>Ottiene il numero di versione principale del sistema operativo richiesto.</summary>
      <returns>Numero di versione principale del sistema operativo richiesto.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorSubsystemVersion">
      <summary>Ottiene il numero di versione principale del sottosistema.</summary>
      <returns>Numero di versione principale del sottosistema.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorImageVersion">
      <summary>Ottiene il numero di versione secondaria dell'immagine.</summary>
      <returns>Numero di versione secondaria dell'immagine.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorLinkerVersion">
      <summary>Ottiene il numero di versione secondaria del linker.</summary>
      <returns>Numero di versione secondaria del linker.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorOperatingSystemVersion">
      <summary>Ottiene il numero di versione secondaria del sistema operativo richiesto.</summary>
      <returns>Numero di versione secondaria del sistema operativo richiesto.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorSubsystemVersion">
      <summary>Ottiene il numero di versione secondaria del sottosistema.</summary>
      <returns>Numero di versione secondaria del sottosistema.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.NumberOfRvaAndSizes">
      <summary>Ottiene il numero di voci della directory di dati nella parte restante del <see cref="T:System.Reflection.PortableExecutable.PEHeader" />. Ognuna descrive una posizione e una dimensione.</summary>
      <returns>Numero di voci della directory di dati nella parte restante di <see cref="T:System.Reflection.PortableExecutable.PEHeader" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ResourceTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SectionAlignment">
      <summary>Ottiene l'allineamento (in byte) delle sezioni quando vengono caricate in memoria.</summary>
      <returns>Numero maggiore o uguale a <see cref="P:System.Reflection.PortableExecutable.PEHeader.FileAlignment" /> . Il valore predefinito è la dimensione della pagina per l'architettura.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfCode">
      <summary>Ottiene le dimensioni della sezione del codice (testo) o la somma di tutte le sezioni di codice se sono presenti più sezioni.</summary>
      <returns>dimensioni della sezione del codice (testo) o della somma di tutte le sezioni di codice se sono presenti più sezioni.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeaders">
      <summary>Ottiene le dimensioni combinate di uno stub MS DOS, un'intestazione PE e le intestazioni di sezione arrotondate per eccesso a un multiplo di FileAlignment.</summary>
      <returns>Dimensioni combinate di uno stub MS DOS, un'intestazione PE e intestazioni di sezione arrotondate per eccesso a un multiplo di FileAlignment.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapCommit">
      <summary>Ottiene le dimensioni dello spazio dell'heap locale di cui eseguire il commit.</summary>
      <returns>dimensioni dello spazio dell'heap locale di cui eseguire il commit.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapReserve">
      <summary>Ottiene le dimensioni dello spazio dell'heap locale da riservare. Viene eseguito il commit solo di <see cref="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapCommit" />; il resto viene reso disponibile una pagina alla volta fino a quando non vengono raggiunte le dimensioni riservate.</summary>
      <returns>Dimensioni dello spazio dell'heap locale da riservare.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfImage">
      <summary>Ottiene le dimensioni (in byte) dell'immagine, incluse tutte le intestazioni, quando l'immagine viene caricata in memoria.</summary>
      <returns>Dimensioni (in byte) dell'immagine, ovvero un multiplo di <see cref="P:System.Reflection.PortableExecutable.PEHeader.SectionAlignment" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfInitializedData">
      <summary>Ottiene le dimensioni della sezione dei dati inizializzati o la somma di tutte queste sezioni se sono presenti più sezioni di dati.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackCommit">
      <summary>Ottiene le dimensioni dello stack di cui eseguire il commit.</summary>
      <returns>Dimensioni dello stack di cui eseguire il commit.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackReserve">
      <summary>Ottiene le dimensioni dello stack da riservare. Viene eseguito il commit solo di <see cref="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackCommit" />; il resto viene reso disponibile una pagina alla volta fino a quando non vengono raggiunte le dimensioni riservate.</summary>
      <returns>Dimensioni dello stack da riservare.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfUninitializedData">
      <summary>Ottiene le dimensioni della sezione dei dati non inizializzati (BSS) o la somma di tutte queste sezioni se sono presenti più sezioni BSS.</summary>
      <returns>Dimensioni della sezione di dati non inizializzati (BSS) o della somma di tutte le sezioni.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.Subsystem">
      <summary>Ottiene il nome del sottosistema necessario per eseguire l'immagine.</summary>
      <returns>nome del sottosistema necessario per eseguire l'immagine.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ThreadLocalStorageTableDirectory" />
    <member name="T:System.Reflection.PortableExecutable.PEHeaderBuilder">
      <summary>Definisce l'intestazione per un file eseguibile di tipo PE.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaderBuilder.#ctor(System.Reflection.PortableExecutable.Machine,System.Int32,System.Int32,System.UInt64,System.Byte,System.Byte,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.Reflection.PortableExecutable.Subsystem,System.Reflection.PortableExecutable.DllCharacteristics,System.Reflection.PortableExecutable.Characteristics,System.UInt64,System.UInt64,System.UInt64,System.UInt64)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Reflection.PortableExecutable.PEHeader" />.</summary>
      <param name="machine">Architettura della CPU del computer di destinazione.</param>
      <param name="sectionAlignment">Allineamento (in byte) delle sezioni quando vengono caricate in memoria. Deve essere maggiore o uguale a <paramref name="fileAlignment" />. Il valore predefinito è la dimensione della pagina per l'architettura.</param>
      <param name="fileAlignment">Fattore di allineamento (in byte) usato per allineare i dati non elaborati delle sezioni nel file di immagine. Il valore deve essere una potenza di 2 compresa tra 512 e 64K (inclusi). Il valore predefinito è 512. Se <paramref name="sectionAlignment" /> è inferiore alle dimensioni della pagina dell'architettura, <paramref name="fileAlignment" /> deve corrispondere a <paramref name="sectionAlignment" />.</param>
      <param name="imageBase">Indirizzo preferito del primo byte dell'immagine quando viene caricata in memoria; deve essere un multiplo di 64K.</param>
      <param name="majorLinkerVersion">Numero di versione principale del linker.</param>
      <param name="minorLinkerVersion">Numero di versione secondaria del linker.</param>
      <param name="majorOperatingSystemVersion">Numero di versione principale del sistema operativo richiesto.</param>
      <param name="minorOperatingSystemVersion">Numero di versione secondaria del sistema operativo richiesto.</param>
      <param name="majorImageVersion">Numero di versione principale dell'immagine.</param>
      <param name="minorImageVersion">Numero di versione secondaria dell'immagine.</param>
      <param name="majorSubsystemVersion">Numero di versione principale del sottosistema.</param>
      <param name="minorSubsystemVersion">Numero di versione secondaria del sottosistema.</param>
      <param name="subsystem">Sottosistema necessario per eseguire l'immagine.</param>
      <param name="dllCharacteristics">Oggetto che descrive le caratteristiche della libreria di collegamento dinamico.</param>
      <param name="imageCharacteristics">Oggetto che descrive le caratteristiche dell'immagine.</param>
      <param name="sizeOfStackReserve">Dimensioni dello stack da riservare. Viene eseguito il commit solo di <paramref name="sizeOfStackCommit" />; il resto viene reso disponibile una pagina alla volta fino a quando non vengono raggiunte le dimensioni riservate.</param>
      <param name="sizeOfStackCommit">Dimensioni dello stack di cui eseguire il commit.</param>
      <param name="sizeOfHeapReserve">Dimensioni dello spazio dell'heap locale da riservare. Viene eseguito il commit solo di <paramref name="sizeOfHeapCommit" />; il resto viene reso disponibile una pagina alla volta fino a quando non vengono raggiunte le dimensioni riservate.</param>
      <param name="sizeOfHeapCommit">Dimensioni dello spazio dell'heap locale di cui eseguire il commit.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="fileAlignment" /> non è una potenza di 2 compresa tra 512 e 64K.
-oppure-

<paramref name="sectionAlignment" /> non è una potenza di 2.

-oppure-

<paramref name="sectionAlignment" /> è minore di <paramref name="fileAlignment" />.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaderBuilder.CreateExecutableHeader">
      <summary>Crea un'intestazione eseguibile.</summary>
      <returns>Istanza di <see cref="T:System.Reflection.PortableExecutable.PEHeaderBuilder" /> che rappresenta l'intestazione eseguibile.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaderBuilder.CreateLibraryHeader">
      <summary>Crea un'intestazione di libreria.</summary>
      <returns>Istanza di <see cref="T:System.Reflection.PortableExecutable.PEHeaderBuilder" /> che rappresenta l'intestazione di libreria.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.DllCharacteristics">
      <summary>Restituisce le caratteristiche della libreria del linker dinamica.</summary>
      <returns>Oggetto che descrive le caratteristiche della libreria dynamic linker.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.FileAlignment">
      <summary>Fattore di allineamento (in byte) usato per allineare i dati non elaborati delle sezioni nel file di immagine. Il valore deve essere una potenza di 2 compresa tra 512 e 64K (inclusi). Il valore predefinito è 512. Se l'allineamento della sezione è inferiore alle dimensioni di pagina dell'architettura, l'allineamento del file deve corrispondere all'allineamento della sezione.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.ImageBase">
      <summary>Indirizzo preferito del primo byte dell'immagine quando viene caricata in memoria; deve essere un multiplo di 64K.</summary>
      <returns>Numero che rappresenta l'indirizzo preferito del primo byte di immagine quando viene caricato in memoria.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.ImageCharacteristics">
      <summary>Restituisce le caratteristiche dell'immagine.</summary>
      <returns>Oggetto che rappresenta le caratteristiche dell'immagine.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.Machine">
      <summary>Architettura della CPU del computer di destinazione.</summary>
      <returns>Uno dei valori di enumerazione che rappresenta le diverse architetture della CPU.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorImageVersion">
      <summary>Numero di versione principale dell'immagine.</summary>
      <returns>Numero delle dimensioni di un oggetto <see cref="T:System.UInt16" /> che rappresenta il numero di versione principale dell'immagine.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorLinkerVersion">
      <summary>Numero di versione principale del linker.</summary>
      <returns>Numero di dimensioni di un oggetto <see cref="T:System.Byte" /> che rappresenta il numero di versione principale del linker.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorOperatingSystemVersion">
      <summary>Numero di versione principale del sistema operativo richiesto.</summary>
      <returns>Numero delle dimensioni di un oggetto <see cref="T:System.UInt16" /> che rappresenta il numero di versione principale del sistema operativo richiesto.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorSubsystemVersion">
      <summary>Numero di versione principale del sottosistema.</summary>
      <returns>Numero delle dimensioni di un oggetto <see cref="T:System.UInt16" /> che rappresenta il numero di versione principale del sottosistema.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorImageVersion">
      <summary>Numero di versione secondaria dell'immagine.</summary>
      <returns>Numero delle dimensioni di un oggetto <see cref="T:System.UInt16" /> che rappresenta il numero di versione secondario dell'immagine.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorLinkerVersion">
      <summary>Numero di versione secondaria del linker.</summary>
      <returns>Numero di dimensioni di un oggetto <see cref="T:System.Byte" /> che rappresenta il numero di versione secondario del linker.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorOperatingSystemVersion">
      <summary>Numero di versione secondaria del sistema operativo richiesto.</summary>
      <returns>Numero delle dimensioni di un oggetto <see cref="T:System.UInt16" /> che rappresenta il numero di versione secondario del sistema operativo richiesto.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorSubsystemVersion">
      <summary>Numero di versione secondaria del sottosistema.</summary>
      <returns>Numero delle dimensioni di un oggetto <see cref="T:System.UInt16" /> che rappresenta il numero di versione secondario del sottosistema.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SectionAlignment">
      <summary>Allineamento (in byte) delle sezioni quando vengono caricate in memoria.</summary>
      <returns>Numero che rappresenta l'allineamento (in byte) delle sezioni quando vengono caricate in memoria. Deve essere maggiore o uguale all'allineamento del file. Il valore predefinito è la dimensione della pagina per l'architettura.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfHeapCommit">
      <summary>Dimensioni dello spazio dell'heap locale di cui eseguire il commit.</summary>
      <returns>Numero che rappresenta le dimensioni dello spazio dell'heap locale di cui eseguire il commit.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfHeapReserve">
      <summary>Dimensioni dello spazio dell'heap locale da riservare. Viene eseguito il commit solo di <see cref="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfHeapCommit" />; il resto viene reso disponibile una pagina alla volta fino a quando non vengono raggiunte le dimensioni riservate.</summary>
      <returns>Numero che rappresenta le dimensioni dello spazio dell'heap locale da riservare.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfStackCommit">
      <summary>Dimensioni dello stack di cui eseguire il commit.</summary>
      <returns>Numero che rappresenta le dimensioni dello stack di cui eseguire il commit.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfStackReserve">
      <summary>Dimensioni dello stack da riservare. Viene eseguito il commit solo di <see cref="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfStackCommit" />; il resto viene reso disponibile una pagina alla volta fino a quando non vengono raggiunte le dimensioni riservate.</summary>
      <returns>Numero che rappresenta le dimensioni dello stack da riservare.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.Subsystem">
      <summary>Sottosistema necessario per eseguire l'immagine.</summary>
      <returns>Istanza di <see cref="T:System.Reflection.PortableExecutable.Subsystem" />.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEHeaders">
      <summary>Definisce un tipo che legge le intestazioni PE (Portable Executable) e COFF (Common Object File Format) da un flusso.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream)">
      <summary>Crea una nuova istanza della classe <see cref="T:System.Reflection.PortableExecutable.PEHeaders" /> che legge le intestazioni PE dalla posizione corrente nel flusso specificato.</summary>
      <param name="peStream">Flusso contenente l'immagine PE che inizia dalla posizione corrente del flusso e termina alla fine del flusso.</param>
      <exception cref="T:System.BadImageFormatException">Il formato dei dati letti dal flusso non è valido.</exception>
      <exception cref="T:System.IO.IOException">Errore durante la lettura del flusso.</exception>
      <exception cref="T:System.ArgumentException">Il flusso non supporta operazioni di ricerca.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peStream" /> è <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream,System.Int32)">
      <summary>Crea una nuova istanza della classe <see cref="T:System.Reflection.PortableExecutable.PEHeaders" /> che legge le intestazioni PE da un flusso che rappresenta un'immagine PE delle dimensioni specificate.</summary>
      <param name="peStream">Flusso contenente l'immagine PE delle dimensioni specificate che inizia dalla posizione corrente.</param>
      <param name="size">Dimensioni dell'immagine PE.</param>
      <exception cref="T:System.BadImageFormatException">Il formato dei dati letti dal flusso non è valido.</exception>
      <exception cref="T:System.IO.IOException">Errore durante la lettura del flusso.</exception>
      <exception cref="T:System.ArgumentException">Il flusso non supporta operazioni di ricerca.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peStream" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> è negativo o si estende oltre la fine del flusso.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream,System.Int32,System.Boolean)">
      <summary>Crea una nuova istanza della classe <see cref="T:System.Reflection.PortableExecutable.PEHeaders" /> che legge le intestazioni PE da un flusso che rappresenta un'immagine PE delle dimensioni specificate e indica se l'immagine PE è stata caricata in memoria.</summary>
      <param name="peStream">Flusso contenente l'immagine PE delle dimensioni specificate che inizia dalla posizione corrente.</param>
      <param name="size">Dimensioni dell'immagine PE.</param>
      <param name="isLoadedImage">
        <see langword="true" /> se l'immagine PE è stata caricata in memoria dal caricatore del sistema operativo; in caso contrario, <see langword="false" />.</param>
      <exception cref="T:System.BadImageFormatException">Il formato dei dati letti dal flusso non è valido.</exception>
      <exception cref="T:System.IO.IOException">Errore durante la lettura del flusso.</exception>
      <exception cref="T:System.ArgumentException">Il flusso non supporta operazioni di ricerca.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peStream" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> è negativo o si estende oltre la fine del flusso.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.GetContainingSectionIndex(System.Int32)">
      <summary>Esegue la ricerca nelle sezioni dell'immagine PE della sezione contenente l'indirizzo RVA (Relative Virtual Address) specificato.</summary>
      <param name="relativeVirtualAddress">Indirizzo RVA (Relative Virtual Address) da cercare.</param>
      <returns>Indice della sezione contenente <paramref name="relativeVirtualAddress" /> oppure -1 se la ricerca ha esito negativo.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.TryGetDirectoryOffset(System.Reflection.PortableExecutable.DirectoryEntry,System.Int32@)">
      <summary>Ottiene l'offset, in byte, dall'inizio dell'immagine ai dati della directory specificati.</summary>
      <param name="directory">Voce di directory PE.</param>
      <param name="offset">Quando il metodo viene restituito, contiene l'offset dall'inizio dell'immagine ai dati della directory specificati.</param>
      <returns>
        <see langword="true" /> se vengono trovati i dati della directory; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CoffHeader">
      <summary>Ottiene l'intestazione COFF dell'immagine.</summary>
      <returns>Intestazione COFF dell'immagine.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CoffHeaderStartOffset">
      <summary>Ottiene l'offset di byte dall'inizio dell'immagine PE all'inizio dell'intestazione COFF.</summary>
      <returns>Offset di byte dall'inizio dell'immagine PE all'inizio dell'intestazione COFF.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CorHeader">
      <summary>Ottiene l'intestazione COR.</summary>
      <returns>L'intestazione COR o <see langword="null" /> se l'immagine non ne contiene una.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CorHeaderStartOffset">
      <summary>Ottiene l'offset di byte dall'inizio dell'immagine all'intestazione COR.</summary>
      <returns>Offset di byte dall'inizio dell'immagine all'intestazione del CdR oppure-1 se l'immagine non contiene un'intestazione COR.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsCoffOnly">
      <summary>Ottiene un valore che indica se l'immagine è solo COFF.</summary>
      <returns>
        <see langword="true" /> Se l'immagine è solo COFF; in caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsConsoleApplication">
      <summary>Ottiene un valore che indica se l'immagine rappresenta un'applicazione console di Windows.</summary>
      <returns>
        <see langword="true" /> Se l'immagine è un'applicazione console di Windows; in caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsDll">
      <summary>Ottiene un valore che indica se l'immagine rappresenta una libreria di collegamento dinamico.</summary>
      <returns>
        <see langword="true" /> Se l'immagine è una DLL; in caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsExe">
      <summary>Ottiene un valore che indica se l'immagine rappresenta un eseguibile.</summary>
      <returns>
        <see langword="true" /> Se l'immagine è un eseguibile; in caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.MetadataSize">
      <summary>Ottiene le dimensioni dei metadati dell'interfaccia della riga di comando.</summary>
      <returns>dimensioni dei metadati dell'interfaccia della riga di comando oppure 0 se l'immagine non contiene metadati.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.MetadataStartOffset">
      <summary>Ottiene l'offset, in byte, dall'inizio dell'immagine PE all'inizio dei metadati dell'interfaccia della riga di comando.</summary>
      <returns>Offset (in byte) dall'inizio dell'immagine PE all'inizio dei metadati dell'interfaccia della riga di comando oppure-1 se l'immagine non contiene metadati.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.PEHeader">
      <summary>Ottiene l'intestazione PE dell'immagine.</summary>
      <returns>Intestazione PE dell'immagine o <see langword="null" /> se l'immagine è solo COFF.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.PEHeaderStartOffset">
      <summary>Ottiene l'offset di byte dell'intestazione dall'inizio dell'immagine.</summary>
      <returns>Offset di byte dell'intestazione dall'inizio dell'immagine.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.SectionHeaders">
      <summary>Ottiene le intestazioni di sezione PE.</summary>
      <returns>Matrice contenente le intestazioni della sezione PE.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEMagic" />
    <member name="F:System.Reflection.PortableExecutable.PEMagic.PE32" />
    <member name="F:System.Reflection.PortableExecutable.PEMagic.PE32Plus" />
    <member name="T:System.Reflection.PortableExecutable.PEMemoryBlock" />
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetContent">
      <summary>Legge il contenuto dell'intero blocco in una matrice.</summary>
      <returns>Matrice di byte non modificabile.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetContent(System.Int32,System.Int32)">
      <summary>Legge il contenuto di una parte del blocco in una matrice.</summary>
      <param name="start">Posizione iniziale nel blocco.</param>
      <param name="length">Numero di byte da leggere.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">L'intervallo specificato non è contenuto all'interno del blocco.</exception>
      <returns>Matrice di byte non modificabile.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetReader">
      <summary>Crea un <see cref="T:System.Reflection.Metadata.BlobReader" /> per un BLOB che si estende sull'intero blocco.</summary>
      <returns>Lettore per un BLOB che si estende sull'intero blocco.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetReader(System.Int32,System.Int32)">
      <summary>Crea un <see cref="T:System.Reflection.Metadata.BlobReader" /> per un BLOB che si estende su una parte del blocco.</summary>
      <param name="start">Posizione iniziale nel blocco.</param>
      <param name="length">Numero di byte nella parte del blocco.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">L'intervallo specificato non è contenuto all'interno del blocco.</exception>
      <returns>Lettore per un BLOB che si estende su una parte del blocco.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEMemoryBlock.Length">
      <summary>Ottiene la lunghezza del blocco.</summary>
      <returns>Lunghezza del blocco.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEMemoryBlock.Pointer">
      <summary>Ottiene un puntatore al primo byte del blocco.</summary>
      <returns>Puntatore al primo byte del blocco.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEReader">
      <summary>Fornisce un lettore per i file eseguibili di tipo PE (Portable Executable).</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.Byte*,System.Int32)">
      <summary>Crea un lettore per i file eseguibili di tipo PE su un'immagine PE archiviata in memoria.</summary>
      <param name="peImage">Puntatore all'inizio dell'immagine PE.</param>
      <param name="size">Dimensioni dell'immagine PE.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peImage" /> è <see cref="F:System.IntPtr.Zero" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> è negativo.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.Byte*,System.Int32,System.Boolean)">
      <summary>Crea un lettore per i file eseguibili di tipo PE su un'immagine PE archiviata in memoria. Un flag indica se l'immagine è già stata caricata in memoria.</summary>
      <param name="peImage">Puntatore all'inizio dell'immagine PE.</param>
      <param name="size">Dimensioni dell'immagine PE.</param>
      <param name="isLoadedImage">
        <see langword="true" /> se l'immagine PE è stata caricata in memoria dal caricatore del sistema operativo; in caso contrario, <see langword="false" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peImage" /> è <see cref="F:System.IntPtr.Zero" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> è negativo.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>Crea un lettore per i file eseguibili di tipo PE su un'immagine PE archiviata in una matrice di byte.</summary>
      <param name="peImage">Matrice di byte non modificabile che rappresenta l'immagine PE.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peImage" /> è <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream)">
      <summary>Crea un lettore per i file eseguibili di tipo PE su un'immagine PE archiviata in un flusso.</summary>
      <param name="peStream">Flusso dell'immagine PE.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peStream" /> è <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream,System.Reflection.PortableExecutable.PEStreamOptions)">
      <summary>Crea un lettore per i file eseguibili di tipo PE su un'immagine PE archiviata in un flusso che inizia dalla posizione corrente e termina alla fine del flusso.</summary>
      <param name="peStream">Flusso dell'immagine PE.</param>
      <param name="options">Opzioni che specificano la modalità di lettura delle sezioni dell'immagine PE dal flusso.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peStream" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Il valore di <paramref name="options" />non è valido.</exception>
      <exception cref="T:System.IO.IOException">Errore durante la lettura dal flusso (solo in caso di prelettura dei dati).</exception>
      <exception cref="T:System.BadImageFormatException">
        <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata" /> viene specificato e le intestazioni PE dell'immagine non sono valide.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream,System.Reflection.PortableExecutable.PEStreamOptions,System.Int32)">
      <summary>Crea un lettore per i file eseguibili di tipo PE su un'immagine PE delle dimensioni specificate che inizia dalla posizione corrente del flusso.</summary>
      <param name="peStream">Flusso dell'immagine PE.</param>
      <param name="options">Opzioni che specificano la modalità di lettura delle sezioni dell'immagine PE dal flusso.</param>
      <param name="size">Dimensioni dell'immagine PE.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> è negativo o si estende oltre la fine del flusso.</exception>
      <exception cref="T:System.IO.IOException">Errore durante la lettura dal flusso (solo in caso di prelettura dei dati).</exception>
      <exception cref="T:System.BadImageFormatException">
        <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata" /> viene specificato e le intestazioni PE dell'immagine non sono valide.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.Dispose">
      <summary>Elimina tutta la memoria allocata dal lettore.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetEntireImage">
      <summary>Ottiene un oggetto <see cref="T:System.Reflection.PortableExecutable.PEMemoryBlock" /> che contiene l'intera immagine PE.</summary>
      <exception cref="T:System.InvalidOperationException">L'intera immagine PE non è disponibile.</exception>
      <returns>Blocco di memoria che contiene l'intera immagine PE.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetMetadata">
      <summary>Carica una sezione PE che contiene i metadati dell'interfaccia della riga di comando.</summary>
      <exception cref="T:System.InvalidOperationException">L'immagine PE non contiene metadati (<see cref="P:System.Reflection.PortableExecutable.PEReader.HasMetadata" /> restituisce <see langword="false" />).</exception>
      <exception cref="T:System.BadImageFormatException">Le intestazioni PE contengono dati non validi.</exception>
      <exception cref="T:System.IO.IOException">Errore di I/O durante la lettura dal flusso sottostante.</exception>
      <returns>Blocco di memoria che contiene i metadati dell'interfaccia della riga di comando.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetSectionData(System.Int32)">
      <summary>Carica la sezione PE che contiene l'indirizzo RVA (Relative Virtual Address) specificato in memoria e restituisce un blocco di memoria che inizia in corrispondenza di tale indirizzo e termina alla fine della sezione che lo contiene.</summary>
      <param name="relativeVirtualAddress">Indirizzo RVA (Relative Virtual Address) dei dati da leggere.</param>
      <exception cref="T:System.BadImageFormatException">Le intestazioni PE contengono dati non validi.</exception>
      <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante la lettura dal flusso sottostante.</exception>
      <exception cref="T:System.InvalidOperationException">L'immagine PE non è disponibile.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="relativeVirtualAddress" /> è negativo.</exception>
      <returns>Blocco di memoria che inizia in corrispondenza di <paramref name="relativeVirtualAddress" /> e termina alla fine della sezione che lo contiene oppure un blocco vuoto se <paramref name="relativeVirtualAddress" /> non rappresenta una posizione in una delle sezioni PE di questa immagine PE.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetSectionData(System.String)">
      <summary>Carica la sezione PE con il nome specificato in memoria e restituisce un blocco di memoria che si estende sulla sezione.</summary>
      <param name="sectionName">Nome della sezione.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="sectionName" /> è <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'immagine PE non è disponibile.</exception>
      <returns>Blocco di memoria che si estende sulla sezione o un blocco vuoto se nessuna sezione dell'oggetto <paramref name="sectionName" /> specificato esiste nell'immagine PE.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadCodeViewDebugDirectoryData(System.Reflection.PortableExecutable.DebugDirectoryEntry)">
      <summary>Legge i dati a cui punta la voce della directory di debug specificata e li interpreta come CodeView.</summary>
      <param name="entry">Istanza della voce della directory di debug.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="entry" /> non è una voce CodeView.</exception>
      <exception cref="T:System.BadImageFormatException">Formato dei dati non valido.</exception>
      <exception cref="T:System.IO.IOException">Errore di I/O durante la lettura dal flusso sottostante.</exception>
      <exception cref="T:System.InvalidOperationException">L'immagine PE non è disponibile.</exception>
      <returns>Istanza dei dati della directory di debug in formato CodeView.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadDebugDirectory">
      <summary>Legge tutte le voci della tabella della directory di debug.</summary>
      <exception cref="T:System.BadImageFormatException">Formato della voce non valido.</exception>
      <exception cref="T:System.IO.IOException">Errore di I/O durante la lettura dal flusso sottostante.</exception>
      <exception cref="T:System.InvalidOperationException">L'immagine PE non è disponibile.</exception>
      <returns>Matrice delle voci della tabella della directory di debug.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadEmbeddedPortablePdbDebugDirectoryData(System.Reflection.PortableExecutable.DebugDirectoryEntry)">
      <summary>Legge i dati a cui punta la voce della directory di debug specificata e li interpreta come BLOB del PDB portatile incorporato.</summary>
      <param name="entry">Voce della directory di debug i cui dati devono essere letti.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="entry" /> non è una voce <see cref="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.EmbeddedPortablePdb" />.</exception>
      <exception cref="T:System.BadImageFormatException">Formato dei dati non valido.</exception>
      <exception cref="T:System.InvalidOperationException">Immagine PE non disponibile.</exception>
      <returns>Provider di un lettore di metadati per la lettura di un'immagine PDB portatile.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadPdbChecksumDebugDirectoryData(System.Reflection.PortableExecutable.DebugDirectoryEntry)">
      <summary>Legge i dati a cui punta la voce della directory di debug specificata e li interpreta come voce di checksum PDB.</summary>
      <param name="entry">Voce della directory di debug i cui dati devono essere letti.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="entry" /> non è una voce di checksum PDB.</exception>
      <exception cref="T:System.BadImageFormatException">Formato dei dati non valido.</exception>
      <exception cref="T:System.IO.IOException">Errore di I/O durante la lettura dal flusso sottostante.</exception>
      <exception cref="T:System.InvalidOperationException">L'immagine PE non è disponibile.</exception>
      <returns>Voce di checksum PDB.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.TryOpenAssociatedPortablePdb(System.String,System.Func{System.String,System.IO.Stream},System.Reflection.Metadata.MetadataReaderProvider@,System.String@)">
      <summary>Apre un PDB portatile associato a questa immagine PE.</summary>
      <param name="peImagePath">Percorso dell'immagine PE. Il percorso viene usato per individuare il file PDB che si trova nella directory contenente il file PE.</param>
      <param name="pdbFileStreamProvider">Se specificato, viene chiamato per aprire un <see cref="T:System.IO.Stream" /> per un percorso di file specificato. Si prevede che il provider restituisca un <see cref="T:System.IO.Stream" /> leggibile e ricercabile oppure <see langword="null" /> se il file di destinazione non esiste o deve essere ignorato per qualche motivo. Il provider deve generare <see cref="T:System.IO.IOException" /> se non riesce ad aprire il file a causa di un errore di I/O imprevisto.</param>
      <param name="pdbReaderProvider">Se ha esito positivo, nuova istanza di <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> da usare per leggere il PDB portatile.</param>
      <param name="pdbPath">Se l'operazione ha esito positivo e il PDB viene trovato in un file, il percorso del file o <see langword="null" /> se il PDB è incorporato nell'immagine PE.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peImagePath" /> o <paramref name="pdbFileStreamProvider" /> è <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Il flusso restituito da <paramref name="pdbFileStreamProvider" /> non supporta le operazioni di lettura e ricerca.</exception>
      <exception cref="T:System.BadImageFormatException">Non è stato trovato alcun file PDB corrispondente a causa di un errore: l'immagine PE o il PDB non è valido.</exception>
      <exception cref="T:System.IO.IOException">Non è stato trovato alcun file PDB corrispondente a causa di un errore: si è verificato un errore di i/o durante la lettura dell'immagine PE o del PDB.</exception>
      <returns>
        <see langword="true" /> se all'immagine PE è associato un PDB e il PDB è stato aperto correttamente; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.HasMetadata">
      <summary>Ottiene un valore che indica se l'immagine PE contiene metadati dell'interfaccia della riga di comando.</summary>
      <exception cref="T:System.BadImageFormatException">Le intestazioni PE contengono dati non validi.</exception>
      <exception cref="T:System.IO.IOException">Errore durante la lettura dal flusso sottostante.</exception>
      <returns>
        <see langword="true" /> Se l'immagine PE contiene metadati dell'interfaccia della riga di comando; in caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.IsEntireImageAvailable">
      <summary>Ottiene un valore che indica se il lettore può accedere all'intera immagine PE.</summary>
      <returns>
        <see langword="true" /> Se il lettore può accedere all'intera immagine PE; in caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.IsLoadedImage">
      <summary>Ottiene un valore che indica se l'immagine PE è stata caricata in memoria dal caricatore del sistema operativo.</summary>
      <returns>
        <see langword="true" /> se l'immagine PE è stata caricata in memoria dal caricatore del sistema operativo; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.PEHeaders">
      <summary>Ottiene le intestazioni PE.</summary>
      <exception cref="T:System.BadImageFormatException">Le intestazioni contengono dati non validi.</exception>
      <exception cref="T:System.IO.IOException">Errore durante la lettura del flusso.</exception>
      <returns>Intestazioni PE per questa immagine PE.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEStreamOptions">
      <summary>Fornisce opzioni che specificano come vengono lette le sezioni di un'immagine PE da un flusso.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.Default">
      <summary>Per impostazione predefinita, il flusso viene eliminato quando <see cref="T:System.Reflection.PortableExecutable.PEReader" /> viene eliminato e le sezioni dell'immagine PE sono lette in modo differito.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.IsLoadedImage">
      <summary>Indica che l'immagine PE sottostante è stata caricata in memoria dal caricatore del sistema operativo.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen">
      <summary>Mantiene il flusso aperto quando <see cref="T:System.Reflection.PortableExecutable.PEReader" /> viene eliminato.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchEntireImage">
      <summary>Legge immediatamente l'intera immagine in memoria. <see cref="T:System.Reflection.PortableExecutable.PEReader" /> chiude automaticamente il flusso prima del completamento da parte del costruttore, a meno che non sia specificato <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen" />.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata">
      <summary>
        <para>Legge immediatamente la sezione dei metadati in memoria.</para>
        <para>La lettura da altre sezioni del file non è consentita (<see cref="T:System.InvalidOperationException" /> viene generato da <see cref="T:System.Reflection.PortableExecutable.PEReader" />).</para>
        <para>
          <see cref="T:System.Reflection.PortableExecutable.PEReader" /> chiude automaticamente il flusso prima del completamento da parte del costruttore, a meno che non sia specificato <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen" />. Il file sottostante può essere chiuso e persino eliminato dopo la costruzione di <see cref="T:System.Reflection.PortableExecutable.PEReader" />.</para>
      </summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.ResourceSectionBuilder">
      <summary>Definisce la classe di base per un generatore di sezioni di risorse PE. Derivare da <see cref="T:System.Reflection.PortableExecutable.ResourceSectionBuilder" /> per fornire la logica di serializzazione per le risorse native.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.ResourceSectionBuilder.#ctor">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Reflection.PortableExecutable.ResourceSectionBuilder" />.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.ResourceSectionBuilder.Serialize(System.Reflection.Metadata.BlobBuilder,System.Reflection.PortableExecutable.SectionLocation)">
      <summary>Serializza la risorsa specificata.</summary>
      <param name="builder">BLOB contenente i dati da serializzare.</param>
      <param name="location">Posizione in cui serializzare <paramref name="builder" />.</param>
    </member>
    <member name="T:System.Reflection.PortableExecutable.SectionCharacteristics" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align1024Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align128Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align16Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align1Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align2048Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align256Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align2Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align32Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align4096Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align4Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align512Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align64Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align8192Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align8Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.AlignMask" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.ContainsCode" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.ContainsInitializedData" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.ContainsUninitializedData" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.GPRel" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerComdat" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerInfo" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerNRelocOvfl" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerOther" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerRemove" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Mem16Bit" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemDiscardable" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemExecute" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemFardata" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemLocked" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemNotCached" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemNotPaged" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemPreload" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemProtected" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemPurgeable" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemRead" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemShared" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemSysheap" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemWrite" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.NoDeferSpecExc" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeCopy" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeDSect" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeGroup" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeNoLoad" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeNoPad" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeOver" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeReg" />
    <member name="T:System.Reflection.PortableExecutable.SectionHeader">
      <summary>Fornisce informazioni sull'intestazione di sezione di un file PE/COFF.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.Name">
      <summary>Ottiene il nome della sezione.</summary>
      <returns>Nome della sezione.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.NumberOfLineNumbers">
      <summary>Ottiene il numero di voci per numero di riga per la sezione.</summary>
      <returns>Numero di voci di numeri di riga per la sezione.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.NumberOfRelocations">
      <summary>Ottiene il numero di voci di rilocazione per la sezione.</summary>
      <returns>Numero di voci di rilocazione per la sezione. Il valore è zero per le immagini PE.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToLineNumbers">
      <summary>Ottiene il puntatore del file all'inizio delle voci per numero di riga per la sezione.</summary>
      <returns>Puntatore di file all'inizio delle voci del numero di riga per la sezione oppure zero se non sono presenti numeri di riga COFF.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToRawData">
      <summary>Ottiene il puntatore del file alla prima pagina della sezione all'interno del file COFF.</summary>
      <returns>Puntatore di file alla prima pagina della sezione all'interno del file COFF.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToRelocations">
      <summary>Ottiene il puntatore del file all'inizio delle voci di rilocazione per la sezione.</summary>
      <returns>Puntatore di file all'inizio delle voci di rilocazione per la sezione. È impostato su zero per le immagini PE o se non sono presenti rilocazioni.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.SectionCharacteristics">
      <summary>Ottiene i flag che descrivono le caratteristiche della sezione.</summary>
      <returns>Flag che descrivono le caratteristiche della sezione.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.SizeOfRawData">
      <summary>Ottiene le dimensioni della sezione (per i file oggetto) o le dimensioni dei dati inizializzati su disco (per i file di immagine).</summary>
      <returns>Dimensioni della sezione (per i file oggetto) o dimensione dei dati inizializzati su disco (per i file di immagine).</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.VirtualAddress">
      <summary>Ottiene l'indirizzo virtuale della sezione.</summary>
      <returns>Indirizzo virtuale della sezione.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.VirtualSize">
      <summary>Ottiene le dimensioni totali della sezione quando viene caricata in memoria.</summary>
      <returns>Dimensione totale della sezione quando viene caricata in memoria.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.SectionLocation" />
    <member name="M:System.Reflection.PortableExecutable.SectionLocation.#ctor(System.Int32,System.Int32)">
      <param name="relativeVirtualAddress" />
      <param name="pointerToRawData" />
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionLocation.PointerToRawData" />
    <member name="P:System.Reflection.PortableExecutable.SectionLocation.RelativeVirtualAddress" />
    <member name="T:System.Reflection.PortableExecutable.Subsystem">
      <summary>Descrive il requisito del sottosistema per l'immagine.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiApplication">
      <summary>Applicazione EFI (Extensible Firmware Interface).</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiBootServiceDriver">
      <summary>Driver EFI con servizi di avvio.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiRom">
      <summary>Immagine ROM di EFI.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiRuntimeDriver">
      <summary>Driver EFI con servizi di runtime.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.Native">
      <summary>L'immagine non richiede un sottosistema.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.NativeWindows">
      <summary>L'immagine è un driver nativo Win9x.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.OS2Cui">
      <summary>L'immagine viene eseguita nel sottosistema di caratteri OS/2.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.PosixCui">
      <summary>L'immagine viene eseguita nel sottosistema di caratteri Posix.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.Unknown">
      <summary>Sottosistema sconosciuto.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsBootApplication">
      <summary>Applicazione di avvio.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsCEGui">
      <summary>L'immagine viene eseguita nel sottosistema Windows CE.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsCui">
      <summary>L'immagine viene eseguita nel sottosistema di caratteri Windows.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsGui">
      <summary>L'immagine viene eseguita nel sottosistema GUI Windows.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.Xbox">
      <summary>Sistema Xbox.</summary>
    </member>
  </members>
</doc>