<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Linq.Expressions</name>
  </assembly>
  <members>
    <member name="T:System.Dynamic.BinaryOperationBinder">
      <summary>Representa a operação dinâmica binária no site de chamada, fornecendo a semântica de associação e os detalhes sobre a operação.</summary>
    </member>
    <member name="M:System.Dynamic.BinaryOperationBinder.#ctor(System.Linq.Expressions.ExpressionType)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Dynamic.BinaryOperationBinder" />.</summary>
      <param name="operation">O tipo de operação binária.</param>
    </member>
    <member name="M:System.Dynamic.BinaryOperationBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Executa a associação da operação binária dinâmica.</summary>
      <param name="target">O destino da operação dinâmica.</param>
      <param name="args">Uma matriz de argumentos da operação dinâmica.</param>
      <returns>O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.BinaryOperationBinder.FallbackBinaryOperation(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>Executa a associação da operação binária dinâmica caso o objeto dinâmico de destino não possa ser associado.</summary>
      <param name="target">O destino da operação binária dinâmica.</param>
      <param name="arg">O operando do lado direito da operação binária dinâmica.</param>
      <returns>O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.BinaryOperationBinder.FallbackBinaryOperation(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>Quando substituído na classe derivada, executa a associação da operação binária dinâmica caso o objeto dinâmico de destino não possa ser associado.</summary>
      <param name="target">O destino da operação binária dinâmica.</param>
      <param name="arg">O operando do lado direito da operação binária dinâmica.</param>
      <param name="errorSuggestion">O resultado da associação caso a associação falhe ou seja nula.</param>
      <returns>O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="P:System.Dynamic.BinaryOperationBinder.Operation">
      <summary>O tipo de operação binária.</summary>
      <returns>O <see cref="T:System.Linq.Expressions.ExpressionType" /> objeto que representa o tipo de operação binária.</returns>
    </member>
    <member name="P:System.Dynamic.BinaryOperationBinder.ReturnType">
      <summary>O tipo de resultado da operação.</summary>
      <returns>O tipo de resultado da operação.</returns>
    </member>
    <member name="T:System.Dynamic.BindingRestrictions">
      <summary>Representa um conjunto de restrições de associação no <see cref="T:System.Dynamic.DynamicMetaObject" /> sob o qual a associação dinâmica é válida.</summary>
    </member>
    <member name="F:System.Dynamic.BindingRestrictions.Empty">
      <summary>Representa um conjunto vazio de restrições de associação. Este campo é somente leitura.</summary>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.Combine(System.Collections.Generic.IList{System.Dynamic.DynamicMetaObject})">
      <summary>Combina as restrições de associação da lista de instâncias de <see cref="T:System.Dynamic.DynamicMetaObject" /> em um conjunto de restrições.</summary>
      <param name="contributingObjects">A lista de instâncias de <see cref="T:System.Dynamic.DynamicMetaObject" /> das quais as restrições serão combinadas.</param>
      <returns>O novo conjunto de restrições de associação.</returns>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.GetExpressionRestriction(System.Linq.Expressions.Expression)">
      <summary>Cria a restrição de associação que verifica a expressão de propriedades imutáveis arbitrárias.</summary>
      <param name="expression">A expressão que representa as restrições.</param>
      <returns>As novas restrições de associação.</returns>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.GetInstanceRestriction(System.Linq.Expressions.Expression,System.Object)">
      <summary>Cria a restrição de associação que verifica a expressão para a identidade da instância de objeto.</summary>
      <param name="expression">A expressão a ser testada.</param>
      <param name="instance">A instância de objeto exata a ser testada.</param>
      <returns>As novas restrições de associação.</returns>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.GetTypeRestriction(System.Linq.Expressions.Expression,System.Type)">
      <summary>Cria a restrição de associação que verifica a expressão para a identidade do tipo de runtime.</summary>
      <param name="expression">A expressão a ser testada.</param>
      <param name="type">O tipo exato a ser testado.</param>
      <returns>As novas restrições de associação.</returns>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.Merge(System.Dynamic.BindingRestrictions)">
      <summary>Mescla o conjunto de restrições de associação com as restrições de associação atuais.</summary>
      <param name="restrictions">O conjunto de restrições com o qual mesclar as restrições de associação atuais.</param>
      <returns>O novo conjunto de restrições de associação.</returns>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.ToExpression">
      <summary>Cria o <see cref="T:System.Linq.Expressions.Expression" /> que representa as restrições de associação.</summary>
      <returns>A árvore de expressão que representa as restrições.</returns>
    </member>
    <member name="T:System.Dynamic.CallInfo">
      <summary>Descreve os argumentos do processo de associação dinâmica.</summary>
    </member>
    <member name="M:System.Dynamic.CallInfo.#ctor(System.Int32,System.Collections.Generic.IEnumerable{System.String})">
      <summary>Cria um novo CallInfo que representa argumentos do processo de associação dinâmica.</summary>
      <param name="argCount">O número de argumentos.</param>
      <param name="argNames">Os nomes de argumentos.</param>
    </member>
    <member name="M:System.Dynamic.CallInfo.#ctor(System.Int32,System.String[])">
      <summary>Cria um novo <c>PositionalArgumentInfo</c>.</summary>
      <param name="argCount">O número de argumentos.</param>
      <param name="argNames">Os nomes de argumentos.</param>
    </member>
    <member name="M:System.Dynamic.CallInfo.Equals(System.Object)">
      <summary>Determina se a instância de CallInfo especificada é considerada igual à atual.</summary>
      <param name="obj">A instância de <see cref="T:System.Dynamic.CallInfo" /> a ser comparada à instância atual.</param>
      <returns>
        <see langword="true" /> se a instância especificada for igual à atual; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Dynamic.CallInfo.GetHashCode">
      <summary>Serve como uma função de hash do <see cref="T:System.Dynamic.CallInfo" /> atual.</summary>
      <returns>Um código hash do <see cref="T:System.Dynamic.CallInfo" /> atual.</returns>
    </member>
    <member name="P:System.Dynamic.CallInfo.ArgumentCount">
      <summary>O número de argumentos.</summary>
      <returns>O número de argumentos.</returns>
    </member>
    <member name="P:System.Dynamic.CallInfo.ArgumentNames">
      <summary>Os nomes de argumentos.</summary>
      <returns>A coleção somente leitura de nomes de argumentos.</returns>
    </member>
    <member name="T:System.Dynamic.ConvertBinder">
      <summary>Representa a operação dinâmica de conversão no site de chamada, fornecendo a semântica de associação e os detalhes sobre a operação.</summary>
    </member>
    <member name="M:System.Dynamic.ConvertBinder.#ctor(System.Type,System.Boolean)">
      <summary>Inicializa uma nova instância do <see cref="T:System.Dynamic.ConvertBinder" />.</summary>
      <param name="type">O tipo para o qual converter.</param>
      <param name="explicit">Será true se a conversão deve considerar conversões explícitas, caso contrário, false.</param>
    </member>
    <member name="M:System.Dynamic.ConvertBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Executa a associação da operação de conversão dinâmica.</summary>
      <param name="target">O destino da operação de conversão dinâmica.</param>
      <param name="args">Uma matriz de argumentos da operação de conversão dinâmica.</param>
      <returns>O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.ConvertBinder.FallbackConvert(System.Dynamic.DynamicMetaObject)">
      <summary>Executará a associação de uma operação de conversão dinâmica se o objeto dinâmico de destino não puder ser associado.</summary>
      <param name="target">O destino da operação de conversão dinâmica.</param>
      <returns>O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.ConvertBinder.FallbackConvert(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>Quando substituído na classe derivada, executará a associação de uma operação de conversão dinâmica se o objeto dinâmico de destino não puder ser associado.</summary>
      <param name="target">O destino da operação de conversão dinâmica.</param>
      <param name="errorSuggestion">O resultado da associação a ser usado se a associação falhar ou nulo.</param>
      <returns>O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="P:System.Dynamic.ConvertBinder.Explicit">
      <summary>Obtém o valor que indica se a conversão deve considerar conversões explícitas.</summary>
      <returns>
        <see langword="true" /> Se houver uma conversão explícita; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Dynamic.ConvertBinder.ReturnType">
      <summary>O tipo de resultado da operação.</summary>
      <returns>O <see cref="T:System.Type" /> objeto que representa o tipo de resultado da operação.</returns>
    </member>
    <member name="P:System.Dynamic.ConvertBinder.Type">
      <summary>O tipo para o qual converter.</summary>
      <returns>O <see cref="T:System.Type" /> objeto que representa o tipo para o qual converter.</returns>
    </member>
    <member name="T:System.Dynamic.CreateInstanceBinder">
      <summary>Representa a operação de criação dinâmica no site de chamada, fornecendo a semântica de associação e os detalhes sobre a operação.</summary>
    </member>
    <member name="M:System.Dynamic.CreateInstanceBinder.#ctor(System.Dynamic.CallInfo)">
      <summary>Inicializa uma nova instância do <see cref="T:System.Dynamic.CreateInstanceBinder" />.</summary>
      <param name="callInfo">A assinatura dos argumentos no site da chamada.</param>
    </member>
    <member name="M:System.Dynamic.CreateInstanceBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Executa a associação da operação de criação dinâmica.</summary>
      <param name="target">O destino da operação de criação dinâmica.</param>
      <param name="args">Uma matriz de argumentos da operação de criação dinâmica.</param>
      <returns>O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.CreateInstanceBinder.FallbackCreateInstance(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Executará a associação de uma operação de criação dinâmica se o objeto dinâmico de destino não puder ser associado.</summary>
      <param name="target">O destino da operação de criação dinâmica.</param>
      <param name="args">Os argumentos da operação de criação dinâmica.</param>
      <returns>O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.CreateInstanceBinder.FallbackCreateInstance(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary>Quando substituído na classe derivada, executará a associação de uma operação de criação dinâmica se o objeto dinâmico de destino não puder ser associado.</summary>
      <param name="target">O destino da operação de criação dinâmica.</param>
      <param name="args">Os argumentos da operação de criação dinâmica.</param>
      <param name="errorSuggestion">O resultado da associação a ser usado se a associação falhar ou nulo.</param>
      <returns>O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="P:System.Dynamic.CreateInstanceBinder.CallInfo">
      <summary>Obtém a assinatura dos argumentos no site da chamada.</summary>
      <returns>A assinatura dos argumentos no site da chamada.</returns>
    </member>
    <member name="P:System.Dynamic.CreateInstanceBinder.ReturnType">
      <summary>O tipo de resultado da operação.</summary>
      <returns>O <see cref="T:System.Type" /> objeto que representa o tipo de resultado da operação.</returns>
    </member>
    <member name="T:System.Dynamic.DeleteIndexBinder">
      <summary>Representa a operação de índice de exclusão dinâmica no site de chamada, fornecendo a semântica de associação e os detalhes sobre a operação.</summary>
    </member>
    <member name="M:System.Dynamic.DeleteIndexBinder.#ctor(System.Dynamic.CallInfo)">
      <summary>Inicializa uma nova instância do <see cref="T:System.Dynamic.DeleteIndexBinder" />.</summary>
      <param name="callInfo">A assinatura dos argumentos no site da chamada.</param>
    </member>
    <member name="M:System.Dynamic.DeleteIndexBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Executa a associação da operação dinâmica de exclusão de índice.</summary>
      <param name="target">O destino da operação dinâmica de exclusão de índice.</param>
      <param name="args">Uma matriz de argumentos da operação dinâmica de exclusão de índice.</param>
      <returns>O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.DeleteIndexBinder.FallbackDeleteIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Executará a associação de uma operação dinâmica de exclusão de índice se o objeto dinâmico de destino não puder ser associado.</summary>
      <param name="target">O destino da operação dinâmica de exclusão de índice.</param>
      <param name="indexes">Os argumentos da operação dinâmica de exclusão de índice.</param>
      <returns>O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.DeleteIndexBinder.FallbackDeleteIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary>Quando substituído na classe derivada, executará a associação da operação dinâmica de exclusão de índice se o objeto dinâmico de destino não puder ser associado.</summary>
      <param name="target">O destino da operação dinâmica de exclusão de índice.</param>
      <param name="indexes">Os argumentos da operação dinâmica de exclusão de índice.</param>
      <param name="errorSuggestion">O resultado da associação a ser usado se a associação falhar ou nulo.</param>
      <returns>O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="P:System.Dynamic.DeleteIndexBinder.CallInfo">
      <summary>Obtém a assinatura dos argumentos no site da chamada.</summary>
      <returns>A assinatura dos argumentos no site da chamada.</returns>
    </member>
    <member name="P:System.Dynamic.DeleteIndexBinder.ReturnType">
      <summary>O tipo de resultado da operação.</summary>
      <returns>O <see cref="T:System.Type" /> objeto que representa o tipo de resultado da operação.</returns>
    </member>
    <member name="T:System.Dynamic.DeleteMemberBinder">
      <summary>Representa a operação de membro de exclusão dinâmica no site de chamada, fornecendo a semântica de associação e os detalhes sobre a operação.</summary>
    </member>
    <member name="M:System.Dynamic.DeleteMemberBinder.#ctor(System.String,System.Boolean)">
      <summary>Inicializa uma nova instância do <see cref="T:System.Dynamic.DeleteIndexBinder" />.</summary>
      <param name="name">O nome do membro a ser excluído.</param>
      <param name="ignoreCase">Será verdadeiro se o nome precisar ser correspondido ignorando maiúsculas e minúsculas; caso contrário, será falso.</param>
    </member>
    <member name="M:System.Dynamic.DeleteMemberBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Executa a associação da operação de membro de exclusão dinâmico.</summary>
      <param name="target">O destino da operação de exclusão de membro dinâmica.</param>
      <param name="args">Uma matriz de argumentos da operação de exclusão de membro dinâmica.</param>
      <returns>O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.DeleteMemberBinder.FallbackDeleteMember(System.Dynamic.DynamicMetaObject)">
      <summary>Executará a associação da operação de exclusão de membro dinâmica se o objeto dinâmico de destino não puder ser associado.</summary>
      <param name="target">O destino da operação de exclusão de membro dinâmica.</param>
      <returns>O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.DeleteMemberBinder.FallbackDeleteMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>Quando substituída na classe derivada, executa a associação de uma operação de exclusão de membro dinâmica se o objeto dinâmico de destino não pode ser associado.</summary>
      <param name="target">O destino da operação de exclusão de membro dinâmica.</param>
      <param name="errorSuggestion">O resultado da associação a ser usado se a associação falhar ou nulo.</param>
      <returns>O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="P:System.Dynamic.DeleteMemberBinder.IgnoreCase">
      <summary>Obtém o valor que indica se a comparação de cadeias de caracteres deve ignorar as maiúsculas e minúsculas do nome do membro.</summary>
      <returns>
        <see langword="true" /> se a comparação de cadeia de caracteres deve ignorar maiúsculas e minúsculas; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Dynamic.DeleteMemberBinder.Name">
      <summary>Obtém o nome do membro a ser excluído.</summary>
      <returns>O nome do membro a ser excluído.</returns>
    </member>
    <member name="P:System.Dynamic.DeleteMemberBinder.ReturnType">
      <summary>O tipo de resultado da operação.</summary>
      <returns>O <see cref="T:System.Type" /> objeto que representa o tipo de resultado da operação.</returns>
    </member>
    <member name="T:System.Dynamic.DynamicMetaObject">
      <summary>Representa a associação dinâmica e uma lógica de associação de um objeto que participa da associação dinâmica.</summary>
    </member>
    <member name="F:System.Dynamic.DynamicMetaObject.EmptyMetaObjects">
      <summary>Representa uma matriz vazia do tipo <see cref="T:System.Dynamic.DynamicMetaObject" />. Este campo é somente leitura.</summary>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.#ctor(System.Linq.Expressions.Expression,System.Dynamic.BindingRestrictions)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Dynamic.DynamicMetaObject" />.</summary>
      <param name="expression">A expressão que representa este <see cref="T:System.Dynamic.DynamicMetaObject" /> durante o processo de associação dinâmica.</param>
      <param name="restrictions">O conjunto de restrições de associação sob o qual a associação é válida.</param>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.#ctor(System.Linq.Expressions.Expression,System.Dynamic.BindingRestrictions,System.Object)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Dynamic.DynamicMetaObject" />.</summary>
      <param name="expression">A expressão que representa este <see cref="T:System.Dynamic.DynamicMetaObject" /> durante o processo de associação dinâmica.</param>
      <param name="restrictions">O conjunto de restrições de associação sob o qual a associação é válida.</param>
      <param name="value">O valor de runtime representado pelo <see cref="T:System.Dynamic.DynamicMetaObject" />.</param>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Dynamic.DynamicMetaObject)">
      <summary>Executa a associação da operação binária dinâmica.</summary>
      <param name="binder">Uma instância do <see cref="T:System.Dynamic.BinaryOperationBinder" /> que representa os detalhes da operação dinâmica.</param>
      <param name="arg">Uma instância do <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o lado direito da operação binária.</param>
      <returns>O novo <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindConvert(System.Dynamic.ConvertBinder)">
      <summary>Executa a associação da operação de conversão dinâmica.</summary>
      <param name="binder">Uma instância do <see cref="T:System.Dynamic.ConvertBinder" /> que representa os detalhes da operação dinâmica.</param>
      <returns>O novo <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindCreateInstance(System.Dynamic.CreateInstanceBinder,System.Dynamic.DynamicMetaObject[])">
      <summary>Executa a associação da operação da instância de criação dinâmica.</summary>
      <param name="binder">Uma instância do <see cref="T:System.Dynamic.CreateInstanceBinder" /> que representa os detalhes da operação dinâmica.</param>
      <param name="args">Uma matriz de <see cref="T:System.Dynamic.DynamicMetaObject" /> instâncias – argumentos para a operação da instância de criação.</param>
      <returns>O novo <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Dynamic.DynamicMetaObject[])">
      <summary>Executa a associação da operação dinâmica de exclusão de índice.</summary>
      <param name="binder">Uma instância do <see cref="T:System.Dynamic.DeleteIndexBinder" /> que representa os detalhes da operação dinâmica.</param>
      <param name="indexes">Uma matriz de instâncias <see cref="T:System.Dynamic.DynamicMetaObject" /> – índices para a operação de índice de exclusão.</param>
      <returns>O novo <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindDeleteMember(System.Dynamic.DeleteMemberBinder)">
      <summary>Executa a associação da operação de membro de exclusão dinâmico.</summary>
      <param name="binder">Uma instância do <see cref="T:System.Dynamic.DeleteMemberBinder" /> que representa os detalhes da operação dinâmica.</param>
      <returns>O novo <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindGetIndex(System.Dynamic.GetIndexBinder,System.Dynamic.DynamicMetaObject[])">
      <summary>Executa a associação da operação dinâmica de obtenção de índice.</summary>
      <param name="binder">Uma instância do <see cref="T:System.Dynamic.GetIndexBinder" /> que representa os detalhes da operação dinâmica.</param>
      <param name="indexes">Uma matriz de instâncias <see cref="T:System.Dynamic.DynamicMetaObject" /> – índices para a operação de índice get.</param>
      <returns>O novo <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindGetMember(System.Dynamic.GetMemberBinder)">
      <summary>Executa a associação da operação de obtenção de membro dinâmica.</summary>
      <param name="binder">Uma instância do <see cref="T:System.Dynamic.GetMemberBinder" /> que representa os detalhes da operação dinâmica.</param>
      <returns>O novo <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindInvoke(System.Dynamic.InvokeBinder,System.Dynamic.DynamicMetaObject[])">
      <summary>Executa a associação da operação de invocação dinâmica.</summary>
      <param name="binder">Uma instância do <see cref="T:System.Dynamic.InvokeBinder" /> que representa os detalhes da operação dinâmica.</param>
      <param name="args">Uma matriz de instâncias <see cref="T:System.Dynamic.DynamicMetaObject" /> – argumentos para a operação de invocação.</param>
      <returns>O novo <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindInvokeMember(System.Dynamic.InvokeMemberBinder,System.Dynamic.DynamicMetaObject[])">
      <summary>Executa a associação da operação de invocação de membro dinâmica.</summary>
      <param name="binder">Uma instância do <see cref="T:System.Dynamic.InvokeMemberBinder" /> que representa os detalhes da operação dinâmica.</param>
      <param name="args">Uma matriz de instâncias <see cref="T:System.Dynamic.DynamicMetaObject" /> – argumentos para a operação do membro de invocação.</param>
      <returns>O novo <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindSetIndex(System.Dynamic.SetIndexBinder,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary>Executa a associação da operação dinâmica de definição de índice.</summary>
      <param name="binder">Uma instância do <see cref="T:System.Dynamic.SetIndexBinder" /> que representa os detalhes da operação dinâmica.</param>
      <param name="indexes">Uma matriz de instâncias <see cref="T:System.Dynamic.DynamicMetaObject" /> – índices para a operação de índice de definição.</param>
      <param name="value">O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o valor para a operação de índice de obtenção.</param>
      <returns>O novo <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindSetMember(System.Dynamic.SetMemberBinder,System.Dynamic.DynamicMetaObject)">
      <summary>Executa a associação da operação de membro de conjunto dinâmico.</summary>
      <param name="binder">Uma instância do <see cref="T:System.Dynamic.SetMemberBinder" /> que representa os detalhes da operação dinâmica.</param>
      <param name="value">O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o valor para a operação de membro do conjunto.</param>
      <returns>O novo <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindUnaryOperation(System.Dynamic.UnaryOperationBinder)">
      <summary>Executa a associação da operação unária dinâmica.</summary>
      <param name="binder">Uma instância do <see cref="T:System.Dynamic.UnaryOperationBinder" /> que representa os detalhes da operação dinâmica.</param>
      <returns>O novo <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.Create(System.Object,System.Linq.Expressions.Expression)">
      <summary>Cria um metaobjeto para o objeto especificado.</summary>
      <param name="value">O objeto para o qual obter um metaobjeto.</param>
      <param name="expression">A expressão que representa este <see cref="T:System.Dynamic.DynamicMetaObject" /> durante o processo de associação dinâmica.</param>
      <returns>Se o objeto fornecido implementa <see cref="T:System.Dynamic.IDynamicMetaObjectProvider" /> e não é um objeto remoto de fora do AppDomain atual, retorna o metaobjeto específico do objeto retornado por <see cref="M:System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(System.Linq.Expressions.Expression)" />. Caso contrário, um novo metaobjeto simples sem restrições é criado e retornado.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.GetDynamicMemberNames">
      <summary>Retorna a enumeração de todos os nomes de membro dinâmico.</summary>
      <returns>A lista de nomes de membro dinâmico.</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.Expression">
      <summary>A expressão que representa o <see cref="T:System.Dynamic.DynamicMetaObject" /> durante o processo de associação dinâmica.</summary>
      <returns>A expressão que representa o <see cref="T:System.Dynamic.DynamicMetaObject" /> durante o processo de associação dinâmica.</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.HasValue">
      <summary>Obtém um valor que indica se o <see cref="T:System.Dynamic.DynamicMetaObject" /> tem o valor de runtime.</summary>
      <returns>
        <see langword="true" /> Se o <see cref="T:System.Dynamic.DynamicMetaObject" /> tiver o valor de tempo de execução; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.LimitType">
      <summary>Obtém o tipo de limite do <see cref="T:System.Dynamic.DynamicMetaObject" />.</summary>
      <returns>
        <see cref="P:System.Dynamic.DynamicMetaObject.RuntimeType" /> Se o valor de tempo de execução estiver disponível, um tipo de <see cref="P:System.Dynamic.DynamicMetaObject.Expression" /> caso contrário.</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.Restrictions">
      <summary>O conjunto de restrições de associação sob o qual a associação é válida.</summary>
      <returns>O conjunto de restrições de associação.</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.RuntimeType">
      <summary>Obtém o <see cref="T:System.Type" /> do valor de runtime ou nulo se o <see cref="T:System.Dynamic.DynamicMetaObject" /> não tiver nenhum valor associado a ele.</summary>
      <returns>O <see cref="T:System.Type" /> do valor de tempo de execução ou NULL.</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.Value">
      <summary>O valor de runtime representado por esse <see cref="T:System.Dynamic.DynamicMetaObject" />.</summary>
      <returns>O valor de runtime representado por esse <see cref="T:System.Dynamic.DynamicMetaObject" />.</returns>
    </member>
    <member name="T:System.Dynamic.DynamicMetaObjectBinder">
      <summary>Representa o associador de site de chamada dinâmica que participa do protocolo de associação <see cref="T:System.Dynamic.DynamicMetaObject" />.</summary>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.#ctor">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Dynamic.DynamicMetaObjectBinder" />.</summary>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Quando substituído na classe derivada, executa a associação da operação dinâmica.</summary>
      <param name="target">O destino da operação dinâmica.</param>
      <param name="args">Uma matriz de argumentos da operação dinâmica.</param>
      <returns>O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.Bind(System.Object[],System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.LabelTarget)">
      <summary>Executa a associação em runtime da operação dinâmica em um conjunto de argumentos.</summary>
      <param name="args">Uma matriz de argumentos para a operação dinâmica.</param>
      <param name="parameters">A matriz de instâncias de <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representam os parâmetros do site de chamada no processo de associação.</param>
      <param name="returnLabel">Um LabelTarget usado para retornar o resultado da associação dinâmica.</param>
      <returns>Uma expressão que executa testes nos argumentos de operação dinâmica e executa a operação dinâmica se os testes forem válidos. Se os testes falham em ocorrências posteriores da operação dinâmica, Bind será chamado novamente para gerar um novo <see cref="T:System.Linq.Expressions.Expression" /> para os novos tipos de argumento.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.Defer(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Transfere a associação da operação até um momento posterior quando os valores de runtime de todos os argumentos de operação dinâmica forem computados.</summary>
      <param name="target">O destino da operação dinâmica.</param>
      <param name="args">Uma matriz de argumentos da operação dinâmica.</param>
      <returns>O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.Defer(System.Dynamic.DynamicMetaObject[])">
      <summary>Transfere a associação da operação até um momento posterior quando os valores de runtime de todos os argumentos de operação dinâmica forem computados.</summary>
      <param name="args">Uma matriz de argumentos da operação dinâmica.</param>
      <returns>O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.GetUpdateExpression(System.Type)">
      <summary>Obtém uma expressão que fará com que a associação seja atualizada. Indica que a associação da expressão deixou de ser válida. Normalmente, é usado quando a "versão" de um objeto dinâmico foi alterada.</summary>
      <param name="type">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> da expressão resultante, qualquer tipo é permitido.</param>
      <returns>A expressão de atualização.</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObjectBinder.ReturnType">
      <summary>O tipo de resultado da operação.</summary>
      <returns>O <see cref="T:System.Type" /> objeto que representa o tipo de resultado da operação.</returns>
    </member>
    <member name="T:System.Dynamic.DynamicObject">
      <summary>Fornece uma classe base para especificar o comportamento dinâmico no tempo de execução. Essa classe deve ser herdada. Não é possível instanciá-la diretamente.</summary>
    </member>
    <member name="M:System.Dynamic.DynamicObject.#ctor">
      <summary>Habilita os tipos derivados para inicializarem uma nova instância do tipo <see cref="T:System.Dynamic.DynamicObject" />.</summary>
    </member>
    <member name="M:System.Dynamic.DynamicObject.GetDynamicMemberNames">
      <summary>Retorna a enumeração de todos os nomes de membro dinâmico.</summary>
      <returns>Uma sequência que contém os nomes de membro dinâmico.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.GetMetaObject(System.Linq.Expressions.Expression)">
      <summary>Fornece um <see cref="T:System.Dynamic.DynamicMetaObject" /> que expede para os métodos virtuais dinâmicos. O objeto pode ser encapsulado em outro <see cref="T:System.Dynamic.DynamicMetaObject" /> para fornecer um comportamento personalizado para ações individuais. Esse método dá suporte à infraestrutura do Dynamic Language Runtime para implementadores de linguagem e não se destina a ser usado diretamente do seu código.</summary>
      <param name="parameter">A expressão que representa o <see cref="T:System.Dynamic.DynamicMetaObject" /> para expedir para os métodos virtuais dinâmicos.</param>
      <returns>Um objeto do tipo <see cref="T:System.Dynamic.DynamicMetaObject" />.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
      <summary>Fornece implementação para operações binárias. As classes derivadas da classe <see cref="T:System.Dynamic.DynamicObject" /> podem substituir esse método a fim de especificar o comportamento dinâmico para operações como adição e multiplicação.</summary>
      <param name="binder">Fornece informações sobre a operação binária. A propriedade <c>binder.Operation</c> retorna um objeto <see cref="T:System.Linq.Expressions.ExpressionType" />. Por exemplo, para a instrução <c>sum = first + second</c>, em que <c>first</c> e <c>second</c> são derivados da classe <see langword="DynamicObject" />, <c>binder.Operation</c> retorna <c>ExpressionType.Add</c>.</param>
      <param name="arg">O operando direito da operação binária. Por exemplo, para a instrução <c>sum = first + second</c>, em que <c>first</c> e <c>second</c> são derivados da classe <see langword="DynamicObject" />, <paramref name="arg" /> é igual a <c>second</c>.</param>
      <param name="result">O resultado da operação binária.</param>
      <returns>
        <see langword="true" /> se a operação for bem-sucedida; caso contrário, <see langword="false" />. Se esse método retornar <see langword="false" />, o associador de tempo de execução da linguagem determinará o comportamento. (Na maioria dos casos, uma exceção de tempo de execução específica a um idioma é gerada.)</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
      <summary>Fornece implementação para operações de conversão de tipo. As classes derivadas da classe <see cref="T:System.Dynamic.DynamicObject" /> podem substituir este método para especificar o comportamento dinâmico para operações que convertem um objeto de um tipo em outro.</summary>
      <param name="binder">Fornece informações sobre a operação de conversão. A propriedade <c>binder.Type</c> fornece o tipo para o qual o objeto deve ser convertido. Por exemplo, a instrução <c>(String)sampleObject</c> em C# (<c>CType(sampleObject, Type)</c> em Visual Basic), em que <c>sampleObject</c> é uma instância da classe derivada da classe <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Type</c> retorna o tipo <see cref="T:System.String" />. A propriedade <c>binder.Explicit</c> fornece informações sobre o tipo de conversão que ocorre. Ela retorna <see langword="true" /> para conversão explícita e <see langword="false" /> para conversão implícita.</param>
      <param name="result">O resultado da operação de conversão de tipo.</param>
      <returns>
        <see langword="true" /> se a operação for bem-sucedida; caso contrário, <see langword="false" />. Se esse método retornar <see langword="false" />, o associador de tempo de execução da linguagem determinará o comportamento. (Na maioria dos casos, uma exceção de tempo de execução específica a um idioma é gerada.)</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)">
      <summary>Fornece a implementação para operações que inicializam uma nova instância de um objeto dinâmico. Esse método não se destina ao uso em C# ou Visual Basic.</summary>
      <param name="binder">Fornece informações sobre a operação de inicialização.</param>
      <param name="args">Os argumentos que são passados ao objeto durante inicialização. Por exemplo, para a operação <c>new SampleType(100)</c>, em que <c>SampleType</c> é o tipo derivado da classe <see cref="T:System.Dynamic.DynamicObject" />, <c>args[0]</c> é igual a 100.</param>
      <param name="result">O resultado da inicialização.</param>
      <returns>
        <see langword="true" /> se a operação for bem-sucedida; caso contrário, <see langword="false" />. Se esse método retornar <see langword="false" />, o associador de tempo de execução da linguagem determinará o comportamento. (Na maioria dos casos, uma exceção de tempo de execução específica a um idioma é gerada.)</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Object[])">
      <summary>Fornece a implementação para operações que excluem um objeto pelo índice. Esse método não se destina ao uso em C# ou Visual Basic.</summary>
      <param name="binder">Fornece informações sobre a exclusão.</param>
      <param name="indexes">Os índices a serem excluídos.</param>
      <returns>
        <see langword="true" /> se a operação for bem-sucedida; caso contrário, <see langword="false" />. Se esse método retornar <see langword="false" />, o associador de tempo de execução da linguagem determinará o comportamento. (Na maioria dos casos, uma exceção de tempo de execução específica a um idioma é gerada.)</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryDeleteMember(System.Dynamic.DeleteMemberBinder)">
      <summary>Fornece a implementação para operações que excluem um membro de objeto. Esse método não se destina ao uso em C# ou Visual Basic.</summary>
      <param name="binder">Fornece informações sobre a exclusão.</param>
      <returns>
        <see langword="true" /> se a operação for bem-sucedida; caso contrário, <see langword="false" />. Se esse método retornar <see langword="false" />, o associador de tempo de execução da linguagem determinará o comportamento. (Na maioria dos casos, uma exceção de tempo de execução específica a um idioma é gerada.)</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)">
      <summary>Fornece a implementação para operações que obtêm um valor por índice. As classes derivadas da classe <see cref="T:System.Dynamic.DynamicObject" /> podem substituir esse método para especificar o comportamento dinâmico das operações de indexação.</summary>
      <param name="binder">Fornece informações sobre a operação.</param>
      <param name="indexes">Os índices usados na operação. Por exemplo, para a operação <c>sampleObject[3]</c> em C# (<c>sampleObject(3)</c> em Visual Basic), em que <c>sampleObject</c> é derivado da classe <see langword="DynamicObject" />, <c>indexes[0]</c> é igual a 3.</param>
      <param name="result">O resultado da operação de índice.</param>
      <returns>
        <see langword="true" /> se a operação for bem-sucedida; caso contrário, <see langword="false" />. Se esse método retornar <see langword="false" />, o associador de tempo de execução da linguagem determinará o comportamento. (Na maioria dos casos, uma exceção de tempo de execução é gerada.)</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
      <summary>Fornece a implementação para operações que obtêm valores de membro. As classes derivadas da classe <see cref="T:System.Dynamic.DynamicObject" /> podem substituir este método para especificar o comportamento dinâmico para operações como obtenção de um valor para uma propriedade.</summary>
      <param name="binder">Fornece informações sobre o objeto que chamou a operação dinâmica. A propriedade <c>binder.Name</c> fornece o nome do membro no qual a operação dinâmica é executada. Por exemplo, para a instrução <c>Console.WriteLine(sampleObject.SampleProperty)</c>, em que <c>sampleObject</c> é uma instância da classe derivada da classe <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Name</c> retorna "SampleProperty". A propriedade <c>binder.IgnoreCase</c> especifica se o nome do membro diferencia maiúsculas de minúsculas.</param>
      <param name="result">O resultado da operação get. Por exemplo, se o método é chamado para uma propriedade, atribua <paramref name="result" /> para o valor da propriedade.</param>
      <returns>
        <see langword="true" /> se a operação for bem-sucedida; caso contrário, <see langword="false" />. Se esse método retornar <see langword="false" />, o associador de tempo de execução da linguagem determinará o comportamento. (Na maioria dos casos, uma exceção de tempo de execução é gerada.)</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
      <summary>Fornece a implementação para operações que invocam um objeto. Classes derivadas da classe <see cref="T:System.Dynamic.DynamicObject" /> podem substituir este método para especificar o comportamento dinâmico para operações como invocar um objeto ou um delegado.</summary>
      <param name="binder">Fornece informações sobre a operação de invocação.</param>
      <param name="args">Os argumentos que são passados ao objeto durante a operação de invocação. Por exemplo, para a operação <c>sampleObject(100)</c>, em que <c>sampleObject</c> é derivado da classe <see cref="T:System.Dynamic.DynamicObject" />, <c>args[0]</c> é igual a 100.</param>
      <param name="result">O resultado da invocação do objeto.</param>
      <returns>
        <see langword="true" /> se a operação for bem-sucedida; caso contrário, <see langword="false" />. Se esse método retornar <see langword="false" />, o associador de tempo de execução da linguagem determinará o comportamento. (Na maioria dos casos, uma exceção de tempo de execução específica a um idioma é gerada.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
      <summary>Fornece a implementação para operações que invocam um membro. As classes derivadas da classe <see cref="T:System.Dynamic.DynamicObject" /> podem substituir esse método a fim de especificar o comportamento dinâmico para operações como chamar um método.</summary>
      <param name="binder">Fornece informações sobre a operação dinâmica. A propriedade <c>binder.Name</c> fornece o nome do membro no qual a operação dinâmica é executada. Por exemplo, para a instrução <c>sampleObject.SampleMethod(100)</c>, em que <c>sampleObject</c> é uma instância da classe derivada da classe <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Name</c> retorna "SampleMethod". A propriedade <c>binder.IgnoreCase</c> especifica se o nome do membro diferencia maiúsculas de minúsculas.</param>
      <param name="args">Os argumentos passados ao membro do objeto durante a operação de invocação. Por exemplo, para a instrução <c>sampleObject.SampleMethod(100)</c>, em que <c>sampleObject</c> é derivado da classe <see cref="T:System.Dynamic.DynamicObject" />, <c>args[0]</c> é igual a 100.</param>
      <param name="result">O resultado da invocação do membro.</param>
      <returns>
        <see langword="true" /> se a operação for bem-sucedida; caso contrário, <see langword="false" />. Se esse método retornar <see langword="false" />, o associador de tempo de execução da linguagem determinará o comportamento. (Na maioria dos casos, uma exceção de tempo de execução específica a um idioma é gerada.)</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
      <summary>Fornece a implementação para operações que definem um valor por índice. As classes derivadas da classe <see cref="T:System.Dynamic.DynamicObject" /> podem substituir este método para especificar o comportamento dinâmico para operações que acessam os objetos por um índice especificado.</summary>
      <param name="binder">Fornece informações sobre a operação.</param>
      <param name="indexes">Os índices usados na operação. Por exemplo, para a operação <c>sampleObject[3] = 10</c> em C# (<c>sampleObject(3) = 10</c> em Visual Basic), em que <c>sampleObject</c> é derivado da classe <see cref="T:System.Dynamic.DynamicObject" />, <c>indexes[0]</c> é igual a 3.</param>
      <param name="value">O valor a ser definido para o objeto que tem o índice especificado. Por exemplo, para a operação <c>sampleObject[3] = 10</c> em C# (<c>sampleObject(3) = 10</c> em Visual Basic), em que <c>sampleObject</c> é derivado da classe <see cref="T:System.Dynamic.DynamicObject" />, <paramref name="value" /> é igual a 10.</param>
      <returns>
        <see langword="true" /> se a operação for bem-sucedida; caso contrário, <see langword="false" />. Se esse método retornar <see langword="false" />, o associador de tempo de execução da linguagem determinará o comportamento. (Na maioria dos casos, uma exceção de tempo de execução específica a um idioma é gerada.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
      <summary>Fornece a implementação para operações que definem valores de membro. As classes derivadas da classe <see cref="T:System.Dynamic.DynamicObject" /> podem substituir este método para especificar o comportamento dinâmico para operações como definição de um valor para uma propriedade.</summary>
      <param name="binder">Fornece informações sobre o objeto que chamou a operação dinâmica. A propriedade <c>binder.Name</c> fornece o nome do membro ao qual o valor está sendo atribuído. Por exemplo, para a instrução <c>sampleObject.SampleProperty = "Test"</c>, em que <c>sampleObject</c> é a instância da classe derivada da classe <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Name</c> retorna "SampleProperty". A propriedade <c>binder.IgnoreCase</c> especifica se o nome do membro diferencia maiúsculas de minúsculas.</param>
      <param name="value">O valor a ser definido para o membro. Por exemplo, para <c>sampleObject.SampleProperty = "Test"</c>, em que <c>sampleObject</c> é a instância da classe derivada da classe <see cref="T:System.Dynamic.DynamicObject" />, o <paramref name="value" /> é "Test".</param>
      <returns>
        <see langword="true" /> se a operação for bem-sucedida; caso contrário, <see langword="false" />. Se esse método retornar <see langword="false" />, o associador de tempo de execução da linguagem determinará o comportamento. (Na maioria dos casos, uma exceção de tempo de execução específica a um idioma é gerada.)</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
      <summary>Fornece implementação para operações unárias. As classes derivadas da classe <see cref="T:System.Dynamic.DynamicObject" /> podem substituir este método para especificar o comportamento dinâmico para operações como uma negação, incremento ou decremento.</summary>
      <param name="binder">Fornece informações sobre a operação unária. A propriedade <c>binder.Operation</c> retorna um objeto <see cref="T:System.Linq.Expressions.ExpressionType" />. Por exemplo, para a instrução <c>negativeNumber = -number</c>, em que <c>number</c> é derivado da classe <see langword="DynamicObject" />, <c>binder.Operation</c> retorna "Negate".</param>
      <param name="result">O resultado da operação unária.</param>
      <returns>
        <see langword="true" /> se a operação for bem-sucedida; caso contrário, <see langword="false" />. Se esse método retornar <see langword="false" />, o associador de tempo de execução da linguagem determinará o comportamento. (Na maioria dos casos, uma exceção de tempo de execução específica a um idioma é gerada.)</returns>
    </member>
    <member name="T:System.Dynamic.ExpandoObject">
      <summary>Representa um objeto cujos membros podem ser adicionados e removidos no tempo de execução dinamicamente.</summary>
    </member>
    <member name="E:System.Dynamic.ExpandoObject.System#ComponentModel#INotifyPropertyChanged#PropertyChanged">
      <summary>Ocorre quando um valor de propriedade é alterado.</summary>
    </member>
    <member name="M:System.Dynamic.ExpandoObject.#ctor">
      <summary>Inicializa um novo <see langword="ExpandoObject" /> que não tem membros.</summary>
    </member>
    <member name="M:System.Dynamic.ExpandoObject.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retorna um enumerador que itera pela coleção.</summary>
      <returns>Um <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Dynamic.ExpandoObject.System#Dynamic#IDynamicMetaObjectProvider#GetMetaObject(System.Linq.Expressions.Expression)">
      <summary>O MetaObject fornecido expedirá para os métodos virtuais dinâmicos. O objeto pode ser encapsulado em outro MetaObject para fornecer um comportamento personalizado para ações individuais.</summary>
      <param name="parameter">A expressão que representa o MetaObject para expedir para os métodos virtuais dinâmicos.</param>
      <returns>O objeto do tipo <see cref="T:System.Dynamic.DynamicMetaObject" />.</returns>
    </member>
    <member name="T:System.Dynamic.GetIndexBinder">
      <summary>Representa a operação de índice de obtenção dinâmica no site de chamada, fornecendo a semântica de associação e os detalhes sobre a operação.</summary>
    </member>
    <member name="M:System.Dynamic.GetIndexBinder.#ctor(System.Dynamic.CallInfo)">
      <summary>Inicializa uma nova instância do <see cref="T:System.Dynamic.GetIndexBinder" />.</summary>
      <param name="callInfo">A assinatura dos argumentos no site da chamada.</param>
    </member>
    <member name="M:System.Dynamic.GetIndexBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Executa a associação da operação dinâmica de obtenção de índice.</summary>
      <param name="target">O destino da operação dinâmica de obtenção de índice.</param>
      <param name="args">Uma matriz de argumentos da operação dinâmica de obtenção de índice.</param>
      <returns>O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.GetIndexBinder.FallbackGetIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Executará a associação de uma operação dinâmica de obtenção de índice se o objeto dinâmico de destino não puder ser associado.</summary>
      <param name="target">O destino da operação dinâmica de obtenção de índice.</param>
      <param name="indexes">Os argumentos da operação dinâmica de obtenção de índice.</param>
      <returns>O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.GetIndexBinder.FallbackGetIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary>Quando substituída na classe derivada, executará a associação da operação dinâmica de obtenção de índice se o objeto dinâmico de destino não puder ser associado.</summary>
      <param name="target">O destino da operação dinâmica de obtenção de índice.</param>
      <param name="indexes">Os argumentos da operação dinâmica de obtenção de índice.</param>
      <param name="errorSuggestion">O resultado da associação a ser usado se a associação falhar ou nulo.</param>
      <returns>O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="P:System.Dynamic.GetIndexBinder.CallInfo">
      <summary>Obtém a assinatura dos argumentos no site da chamada.</summary>
      <returns>A assinatura dos argumentos no site da chamada.</returns>
    </member>
    <member name="P:System.Dynamic.GetIndexBinder.ReturnType">
      <summary>O tipo de resultado da operação.</summary>
      <returns>O <see cref="T:System.Type" /> objeto que representa o tipo de resultado da operação.</returns>
    </member>
    <member name="T:System.Dynamic.GetMemberBinder">
      <summary>Representa a operação de membro de obtenção dinâmica no site de chamada, fornecendo a semântica de associação e os detalhes sobre a operação.</summary>
    </member>
    <member name="M:System.Dynamic.GetMemberBinder.#ctor(System.String,System.Boolean)">
      <summary>Inicializa uma nova instância do <see cref="T:System.Dynamic.GetMemberBinder" />.</summary>
      <param name="name">O nome do membro a ser obtido.</param>
      <param name="ignoreCase">Será verdadeiro se o nome precisar ser correspondido ignorando maiúsculas e minúsculas; caso contrário, será falso.</param>
    </member>
    <member name="M:System.Dynamic.GetMemberBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Executa a associação da operação de obtenção de membro dinâmica.</summary>
      <param name="target">O destino da operação de obtenção de membro dinâmica.</param>
      <param name="args">Uma matriz de argumentos da operação de obtenção de membro dinâmica.</param>
      <returns>O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.GetMemberBinder.FallbackGetMember(System.Dynamic.DynamicMetaObject)">
      <summary>Executará a associação da operação de obtenção de membro dinâmica se o objeto dinâmico de destino não puder ser associado.</summary>
      <param name="target">O destino da operação de obtenção de membro dinâmica.</param>
      <returns>O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.GetMemberBinder.FallbackGetMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>Quando substituída na classe derivada, executa a associação de uma operação de obtenção de membro dinâmica se o objeto dinâmico de destino não pode ser associado.</summary>
      <param name="target">O destino da operação de obtenção de membro dinâmica.</param>
      <param name="errorSuggestion">O resultado da associação a ser usado se a associação falhar ou nulo.</param>
      <returns>O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="P:System.Dynamic.GetMemberBinder.IgnoreCase">
      <summary>Obtém o valor que indica se a comparação de cadeias de caracteres deve ignorar as maiúsculas e minúsculas do nome do membro.</summary>
      <returns>
        <see langword="true" /> Se o caso for ignorado; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Dynamic.GetMemberBinder.Name">
      <summary>Obtém o nome do membro a ser obtido.</summary>
      <returns>O nome do membro a ser obtido.</returns>
    </member>
    <member name="P:System.Dynamic.GetMemberBinder.ReturnType">
      <summary>O tipo de resultado da operação.</summary>
      <returns>O <see cref="T:System.Type" /> objeto que representa o tipo de resultado da operação.</returns>
    </member>
    <member name="T:System.Dynamic.IDynamicMetaObjectProvider">
      <summary>Representa um objeto dinâmico, que pode ter suas operações associadas no runtime.</summary>
    </member>
    <member name="M:System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(System.Linq.Expressions.Expression)">
      <summary>Retorna o <see cref="T:System.Dynamic.DynamicMetaObject" /> responsável pelas operações de associação executadas neste objeto.</summary>
      <param name="parameter">A representação em árvore de expressão do valor do runtime.</param>
      <returns>O <see cref="T:System.Dynamic.DynamicMetaObject" /> para associar a este objeto.</returns>
    </member>
    <member name="T:System.Dynamic.IInvokeOnGetBinder">
      <summary>Representa informações sobre uma operação de membro de obtenção dinâmico que indica se o membro de get deve invocar propriedades ao executar a operação get.</summary>
    </member>
    <member name="P:System.Dynamic.IInvokeOnGetBinder.InvokeOnGet">
      <summary>Obtém o valor que indica se essa operação de obtenção de membro deve invocar propriedades ao executar a operação get. O valor padrão quando essa interface não está presente é true.</summary>
      <returns>
        <see langword="true" /> Se essa operação get member deve invocar Propriedades quando executam a operação get; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="T:System.Dynamic.InvokeBinder">
      <summary>Representa a operação dinâmica de invocação no site de chamada, fornecendo a semântica de associação e os detalhes sobre a operação.</summary>
    </member>
    <member name="M:System.Dynamic.InvokeBinder.#ctor(System.Dynamic.CallInfo)">
      <summary>Inicializa uma nova instância do <see cref="T:System.Dynamic.InvokeBinder" />.</summary>
      <param name="callInfo">A assinatura dos argumentos no site da chamada.</param>
    </member>
    <member name="M:System.Dynamic.InvokeBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Executa a associação da operação de invocação dinâmica.</summary>
      <param name="target">O destino da operação de invocação dinâmica.</param>
      <param name="args">Uma matriz de argumentos da operação de invocação dinâmica.</param>
      <returns>O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.InvokeBinder.FallbackInvoke(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Executará a associação de uma operação de invocação dinâmica se o objeto dinâmico de destino não puder ser associado.</summary>
      <param name="target">O destino da operação de invocação dinâmica.</param>
      <param name="args">Os argumentos da operação de invocação dinâmica.</param>
      <returns>O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.InvokeBinder.FallbackInvoke(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary>Executará a associação de uma operação de invocação dinâmica se o objeto dinâmico de destino não puder ser associado.</summary>
      <param name="target">O destino da operação de invocação dinâmica.</param>
      <param name="args">Os argumentos da operação de invocação dinâmica.</param>
      <param name="errorSuggestion">O resultado da associação a ser usado se a associação falhar ou nulo.</param>
      <returns>O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="P:System.Dynamic.InvokeBinder.CallInfo">
      <summary>Obtém a assinatura dos argumentos no site da chamada.</summary>
      <returns>A assinatura dos argumentos no site da chamada.</returns>
    </member>
    <member name="P:System.Dynamic.InvokeBinder.ReturnType">
      <summary>O tipo de resultado da operação.</summary>
      <returns>O <see cref="T:System.Type" /> objeto que representa o tipo de resultado da operação.</returns>
    </member>
    <member name="T:System.Dynamic.InvokeMemberBinder">
      <summary>Representa a operação dinâmica de membro de invocação no site de chamada, fornecendo a semântica de associação e os detalhes sobre a operação.</summary>
    </member>
    <member name="M:System.Dynamic.InvokeMemberBinder.#ctor(System.String,System.Boolean,System.Dynamic.CallInfo)">
      <summary>Inicializa uma nova instância do <see cref="T:System.Dynamic.InvokeMemberBinder" />.</summary>
      <param name="name">O nome do membro a ser invocado.</param>
      <param name="ignoreCase">true se o nome precisar ser correspondido ignorando maiúsculas e minúsculas; caso contrário, false.</param>
      <param name="callInfo">A assinatura dos argumentos no site da chamada.</param>
    </member>
    <member name="M:System.Dynamic.InvokeMemberBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Executa a associação da operação de invocação de membro dinâmica.</summary>
      <param name="target">O destino da operação de invocação de membro dinâmica.</param>
      <param name="args">Uma matriz de argumentos da operação de invocação de membro dinâmica.</param>
      <returns>O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.InvokeMemberBinder.FallbackInvoke(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary>Quando substituída na classe derivada, executa a associação de uma operação de invocação dinâmica se o objeto dinâmico de destino não pode ser associado.</summary>
      <param name="target">O destino da operação de invocação dinâmica.</param>
      <param name="args">Os argumentos da operação de invocação dinâmica.</param>
      <param name="errorSuggestion">O resultado da associação a ser usado se a associação falhar ou nulo.</param>
      <returns>O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.InvokeMemberBinder.FallbackInvokeMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Executará a associação da operação de invocação de membro dinâmica se o objeto dinâmico de destino não puder ser associado.</summary>
      <param name="target">O destino da operação de invocação de membro dinâmica.</param>
      <param name="args">Os argumentos da operação de invocação de membro dinâmica.</param>
      <returns>O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.InvokeMemberBinder.FallbackInvokeMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary>Quando substituída na classe derivada, executa a associação de uma operação de invocação de membro dinâmica se o objeto dinâmico de destino não pode ser associado.</summary>
      <param name="target">O destino da operação de invocação de membro dinâmica.</param>
      <param name="args">Os argumentos da operação de invocação de membro dinâmica.</param>
      <param name="errorSuggestion">O resultado da associação a ser usado se a associação falhar ou nulo.</param>
      <returns>O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="P:System.Dynamic.InvokeMemberBinder.CallInfo">
      <summary>Obtém a assinatura dos argumentos no site da chamada.</summary>
      <returns>A assinatura dos argumentos no site da chamada.</returns>
    </member>
    <member name="P:System.Dynamic.InvokeMemberBinder.IgnoreCase">
      <summary>Obtém o valor que indica se a comparação de cadeias de caracteres deve ignorar as maiúsculas e minúsculas do nome do membro.</summary>
      <returns>
        <see langword="true" /> Se o caso for ignorado; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Dynamic.InvokeMemberBinder.Name">
      <summary>Obtém o nome do membro a ser invocado.</summary>
      <returns>O nome do membro a ser invocado.</returns>
    </member>
    <member name="P:System.Dynamic.InvokeMemberBinder.ReturnType">
      <summary>O tipo de resultado da operação.</summary>
      <returns>O <see cref="T:System.Type" /> objeto que representa o tipo de resultado da operação.</returns>
    </member>
    <member name="T:System.Dynamic.SetIndexBinder">
      <summary>Representa a operação de índice de definição dinâmica no site de chamada, fornecendo a semântica de associação e os detalhes sobre a operação.</summary>
    </member>
    <member name="M:System.Dynamic.SetIndexBinder.#ctor(System.Dynamic.CallInfo)">
      <summary>Inicializa uma nova instância do <see cref="T:System.Dynamic.SetIndexBinder" />.</summary>
      <param name="callInfo">A assinatura dos argumentos no site da chamada.</param>
    </member>
    <member name="M:System.Dynamic.SetIndexBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Executa a associação da operação dinâmica de definição de índice.</summary>
      <param name="target">O destino da operação dinâmica de definição de índice.</param>
      <param name="args">Uma matriz de argumentos da operação dinâmica de definição de índice.</param>
      <returns>O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.SetIndexBinder.FallbackSetIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary>Executará a associação de uma operação dinâmica de definição de índice se o objeto dinâmico de destino não puder ser associado.</summary>
      <param name="target">O destino da operação dinâmica de definição de índice.</param>
      <param name="indexes">Os argumentos da operação dinâmica de definição de índice.</param>
      <param name="value">O valor a ser definido para a coleção.</param>
      <returns>O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.SetIndexBinder.FallbackSetIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>Quando substituído na classe derivada, executará a associação da operação dinâmica de definição de índice se o objeto dinâmico de destino não puder ser associado.</summary>
      <param name="target">O destino da operação dinâmica de definição de índice.</param>
      <param name="indexes">Os argumentos da operação dinâmica de definição de índice.</param>
      <param name="value">O valor a ser definido para a coleção.</param>
      <param name="errorSuggestion">O resultado da associação a ser usado se a associação falhar ou nulo.</param>
      <returns>O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="P:System.Dynamic.SetIndexBinder.CallInfo">
      <summary>Obtém a assinatura dos argumentos no site da chamada.</summary>
      <returns>A assinatura dos argumentos no site da chamada.</returns>
    </member>
    <member name="P:System.Dynamic.SetIndexBinder.ReturnType">
      <summary>O tipo de resultado da operação.</summary>
      <returns>O <see cref="T:System.Type" /> objeto que representa o tipo de resultado da operação.</returns>
    </member>
    <member name="T:System.Dynamic.SetMemberBinder">
      <summary>Representa a operação de membro de definição dinâmica no site de chamada, fornecendo a semântica de associação e os detalhes sobre a operação.</summary>
    </member>
    <member name="M:System.Dynamic.SetMemberBinder.#ctor(System.String,System.Boolean)">
      <summary>Inicializa uma nova instância do <see cref="T:System.Dynamic.SetMemberBinder" />.</summary>
      <param name="name">O nome do membro a ser obtido.</param>
      <param name="ignoreCase">Será verdadeiro se o nome precisar ser correspondido ignorando maiúsculas e minúsculas; caso contrário, será falso.</param>
    </member>
    <member name="M:System.Dynamic.SetMemberBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Executa a associação da operação de membro de conjunto dinâmico.</summary>
      <param name="target">O destino da operação dinâmica de definição de membro.</param>
      <param name="args">Uma matriz de argumentos da operação dinâmica de definição de membro.</param>
      <returns>O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.SetMemberBinder.FallbackSetMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>Executará a associação da operação dinâmica de definição de membro se o objeto dinâmico de destino não puder ser associado.</summary>
      <param name="target">O destino da operação dinâmica de definição de membro.</param>
      <param name="value">O valor a ser definido para o membro.</param>
      <returns>O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.SetMemberBinder.FallbackSetMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>Executará a associação da operação dinâmica de definição de membro se o objeto dinâmico de destino não puder ser associado.</summary>
      <param name="target">O destino da operação dinâmica de definição de membro.</param>
      <param name="value">O valor a ser definido para o membro.</param>
      <param name="errorSuggestion">O resultado da associação a ser usado se a associação falhar ou nulo.</param>
      <returns>O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="P:System.Dynamic.SetMemberBinder.IgnoreCase">
      <summary>Obtém o valor que indica se a comparação de cadeias de caracteres deve ignorar as maiúsculas e minúsculas do nome do membro.</summary>
      <returns>
        <see langword="true" /> Se o caso for ignorado; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Dynamic.SetMemberBinder.Name">
      <summary>Obtém o nome do membro a ser obtido.</summary>
      <returns>O nome do membro a ser obtido.</returns>
    </member>
    <member name="P:System.Dynamic.SetMemberBinder.ReturnType">
      <summary>O tipo de resultado da operação.</summary>
      <returns>O <see cref="T:System.Type" /> objeto que representa o tipo de resultado da operação.</returns>
    </member>
    <member name="T:System.Dynamic.UnaryOperationBinder">
      <summary>Representa a operação dinâmica unária no site de chamada, fornecendo a semântica de associação e os detalhes sobre a operação.</summary>
    </member>
    <member name="M:System.Dynamic.UnaryOperationBinder.#ctor(System.Linq.Expressions.ExpressionType)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Dynamic.BinaryOperationBinder" />.</summary>
      <param name="operation">O tipo de operação unária.</param>
    </member>
    <member name="M:System.Dynamic.UnaryOperationBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Executa a associação da operação unária dinâmica.</summary>
      <param name="target">O destino da operação dinâmica.</param>
      <param name="args">Uma matriz de argumentos da operação dinâmica.</param>
      <returns>O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.UnaryOperationBinder.FallbackUnaryOperation(System.Dynamic.DynamicMetaObject)">
      <summary>Executa a associação da operação unária dinâmica caso o objeto dinâmico de destino não possa ser associado.</summary>
      <param name="target">O destino da operação unária dinâmica.</param>
      <returns>O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.UnaryOperationBinder.FallbackUnaryOperation(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>Executa a associação da operação unária dinâmica caso o objeto dinâmico de destino não possa ser associado.</summary>
      <param name="target">O destino da operação unária dinâmica.</param>
      <param name="errorSuggestion">O resultado da associação no caso de falha da associação ou nulo.</param>
      <returns>O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="P:System.Dynamic.UnaryOperationBinder.Operation">
      <summary>O tipo de operação unária.</summary>
      <returns>O objeto do <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa o tipo de operação unário.</returns>
    </member>
    <member name="P:System.Dynamic.UnaryOperationBinder.ReturnType">
      <summary>O tipo de resultado da operação.</summary>
      <returns>O <see cref="T:System.Type" /> objeto que representa o tipo de resultado da operação.</returns>
    </member>
    <member name="T:System.Linq.Expressions.BinaryExpression">
      <summary>Representa uma expressão com um operador binário.</summary>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Expede o método específico de visita para esse tipo de nó. Por exemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chama o <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor">O visitante com o qual visitar esse nó.</param>
      <returns>O resultado de visitar esse nó.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Reduce">
      <summary>Reduz o nó de expressão binária para uma expressão mais simples.</summary>
      <returns>A expressão reduzida.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Update(System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression,System.Linq.Expressions.Expression)">
      <summary>Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="left">A propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> do resultado.</param>
      <param name="conversion">A propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> do resultado.</param>
      <param name="right">A propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> do resultado.</param>
      <returns>Essa expressão se nenhum filho foi alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.CanReduce">
      <summary>Obtém um valor que indica se o nó da árvore de expressão pode ser reduzido.</summary>
      <returns>
        <see langword="true" /> Se o nó da árvore de expressão puder ser reduzido; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Conversion">
      <summary>Obtém a função de conversão de tipo que é usada por uma operação de atribuição composta ou de união.</summary>
      <returns>Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que representa uma função de conversão de tipo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.IsLifted">
      <summary>Obtém um valor que indica se o nó da árvore de expressão representa uma chamada cancelada a um operador.</summary>
      <returns>
        <see langword="true" /> Se o nó representa uma chamada levantada; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull">
      <summary>Obtém um valor que indica se o nó da árvore de expressão representa uma chamada cancelada a um operador cujo tipo de retorno é elevado para um tipo que permite valor nulo.</summary>
      <returns>
        <see langword="true" /> Se o tipo de retorno do operador for elevado para um tipo anulável; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Left">
      <summary>Obtém o operando esquerdo da operação binária.</summary>
      <returns>Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o operando esquerdo da operação binária.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Method">
      <summary>Obtém o método de implementação para a operação binária.</summary>
      <returns>O <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Right">
      <summary>Obtém o operando direito da operação binária.</summary>
      <returns>Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o operando direito da operação binária.</returns>
    </member>
    <member name="T:System.Linq.Expressions.BlockExpression">
      <summary>Representa um bloco que contém uma sequência de expressões em que variáveis podem ser definidas.</summary>
    </member>
    <member name="M:System.Linq.Expressions.BlockExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Expede o método específico de visita para esse tipo de nó. Por exemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chama o <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor">O visitante com o qual visitar esse nó.</param>
      <returns>O resultado de visitar esse nó.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BlockExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="variables">A propriedade <see cref="P:System.Linq.Expressions.BlockExpression.Variables" /> do resultado.</param>
      <param name="expressions">A propriedade <see cref="P:System.Linq.Expressions.BlockExpression.Expressions" /> do resultado.</param>
      <returns>Essa expressão se nenhum filho tiver sido alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Expressions">
      <summary>Obtém as expressões neste bloco.</summary>
      <returns>A coleção somente leitura que contém todas as expressões neste bloco.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.NodeType">
      <summary>Retorna o tipo de nó dessa expressão. Nós de extensão devem retornar <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> ao substituírem esse método.</summary>
      <returns>O <see cref="T:System.Linq.Expressions.ExpressionType" /> da expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Result">
      <summary>Obtém a última expressão neste bloco.</summary>
      <returns>O <see cref="T:System.Linq.Expressions.Expression" /> objeto que representa a última expressão neste bloco.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Type">
      <summary>Obtém o tipo estático da expressão que esse <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>O <see cref="P:System.Linq.Expressions.BlockExpression.Type" /> que representa o tipo estático da expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Variables">
      <summary>Obtém as variáveis definidas neste bloco.</summary>
      <returns>A coleção somente leitura que contém todas as variáveis definidas neste bloco.</returns>
    </member>
    <member name="T:System.Linq.Expressions.CatchBlock">
      <summary>Representa uma instrução catch em um bloco try.</summary>
    </member>
    <member name="M:System.Linq.Expressions.CatchBlock.ToString">
      <summary>Retorna um valor <see cref="T:System.String" /> que representa o <see cref="T:System.Object" /> atual.</summary>
      <returns>Um <see cref="T:System.String" /> que representa o <see cref="T:System.Object" /> atual.</returns>
    </member>
    <member name="M:System.Linq.Expressions.CatchBlock.Update(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="variable">A propriedade <see cref="P:System.Linq.Expressions.CatchBlock.Variable" /> do resultado.</param>
      <param name="filter">A propriedade <see cref="P:System.Linq.Expressions.CatchBlock.Filter" /> do resultado.</param>
      <param name="body">A propriedade <see cref="P:System.Linq.Expressions.CatchBlock.Body" /> do resultado.</param>
      <returns>Essa expressão se nenhum filho foi alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Body">
      <summary>Obtém o corpo do bloco catch.</summary>
      <returns>O <see cref="T:System.Linq.Expressions.Expression" /> objeto que representa o corpo da captura.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Filter">
      <summary>Obtém o corpo do filtro <see cref="T:System.Linq.Expressions.CatchBlock" />.</summary>
      <returns>O <see cref="T:System.Linq.Expressions.Expression" /> objeto que representa o corpo do <see cref="T:System.Linq.Expressions.CatchBlock" /> filtro.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Test">
      <summary>Obtém o tipo de <see cref="T:System.Exception" /> que esse manipulador captura.</summary>
      <returns>O <see cref="T:System.Type" /> objeto que representa o tipo desse <see cref="T:System.Exception" /> manipulador captura.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Variable">
      <summary>Obtém uma referência para o objeto <see cref="T:System.Exception" /> capturado por este manipulador.</summary>
      <returns>O <see cref="T:System.Linq.Expressions.ParameterExpression" /> objeto que representa uma referência ao <see cref="T:System.Exception" /> objeto capturado por este manipulador.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ConditionalExpression">
      <summary>Representa uma expressão com um operador condicional.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ConditionalExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Expede o método específico de visita para esse tipo de nó. Por exemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chama o <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor">O visitante com o qual visitar esse nó.</param>
      <returns>O resultado de visitar esse nó.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ConditionalExpression.Update(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="test">A propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> do resultado.</param>
      <param name="ifTrue">A propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> do resultado.</param>
      <param name="ifFalse">A propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> do resultado.</param>
      <returns>Essa expressão se nenhum filho tiver sido alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.IfFalse">
      <summary>Obtém a expressão a ser executada se o teste for avaliado como <see langword="false" />.</summary>
      <returns>Um <see cref="T:System.Linq.Expressions.Expression" /> que representa a expressão a ser executada se o teste for <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.IfTrue">
      <summary>Obtém a expressão a ser executada se o teste for avaliado como <see langword="true" />.</summary>
      <returns>Um <see cref="T:System.Linq.Expressions.Expression" /> que representa a expressão a ser executada se o teste for <see langword="true" /> .</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.NodeType">
      <summary>Retorna o tipo de nó dessa expressão. Nós de extensão devem retornar <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> ao substituírem esse método.</summary>
      <returns>O <see cref="T:System.Linq.Expressions.ExpressionType" /> da expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.Test">
      <summary>Obtém o teste da operação condicional.</summary>
      <returns>Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o teste da operação condicional.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.Type">
      <summary>Obtém o tipo estático da expressão que esse <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>O <see cref="P:System.Linq.Expressions.ConditionalExpression.Type" /> que representa o tipo estático da expressão.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ConstantExpression">
      <summary>Representa uma expressão que tem um valor constante.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ConstantExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Expede o método específico de visita para esse tipo de nó. Por exemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chama o <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor">O visitante com o qual visitar esse nó.</param>
      <returns>O resultado de visitar esse nó.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.NodeType">
      <summary>Retorna o tipo de nó dessa Expressão. Nós de extensão devem retornar <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> ao substituírem esse método.</summary>
      <returns>O <see cref="T:System.Linq.Expressions.ExpressionType" /> da expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.Type">
      <summary>Obtém o tipo estático da expressão que esse <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>O <see cref="P:System.Linq.Expressions.ConstantExpression.Type" /> que representa o tipo estático da expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.Value">
      <summary>Obtém o valor da expressão de constante.</summary>
      <returns>Um <see cref="T:System.Object" /> igual ao valor da expressão representada.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DebugInfoExpression">
      <summary>Emite ou limpa um ponto de sequência para informações de depuração. Isso permite que o depurador realce o código-fonte correto durante a depuração.</summary>
    </member>
    <member name="M:System.Linq.Expressions.DebugInfoExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Expede o método específico de visita para esse tipo de nó. Por exemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chama o <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor">O visitante com o qual visitar esse nó.</param>
      <returns>O resultado de visitar esse nó.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.Document">
      <summary>Obtém o <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que representa o arquivo de origem.</summary>
      <returns>O <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que representa o arquivo de origem.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.EndColumn">
      <summary>Obtém a coluna final deste <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>O número da coluna final do código que foi usado para gerar a expressão encapsulada.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.EndLine">
      <summary>Obtém a linha final deste <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>O número da linha final do código que foi usado para gerar a expressão encapsulada.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.IsClear">
      <summary>Obtém o valor para indicar se o <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> é para limpar um ponto de sequência.</summary>
      <returns>
        <see langword="true" /> Se <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> for para limpar um ponto de sequência; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.NodeType">
      <summary>Retorna o tipo de nó deste <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>O <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa essa expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.StartColumn">
      <summary>Obtém a coluna inicial deste <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>O número da coluna inicial do código que foi usado para gerar a expressão encapsulada.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.StartLine">
      <summary>Obtém a linha inicial deste <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>O número da linha inicial do código que foi usado para gerar a expressão encapsulada.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.Type">
      <summary>Obtém o tipo estático da expressão que esse <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>O <see cref="P:System.Linq.Expressions.DebugInfoExpression.Type" /> que representa o tipo estático da expressão.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DefaultExpression">
      <summary>Representa o valor padrão de um tipo ou uma expressão vazia.</summary>
    </member>
    <member name="P:System.Linq.Expressions.DefaultExpression.NodeType">
      <summary>Retorna o tipo de nó dessa expressão. Nós de extensão devem retornar <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> ao substituírem esse método.</summary>
      <returns>O <see cref="T:System.Linq.Expressions.ExpressionType" /> da expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DefaultExpression.Type">
      <summary>Obtém o tipo estático da expressão que esse <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>O <see cref="P:System.Linq.Expressions.DefaultExpression.Type" /> que representa o tipo estático da expressão.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DynamicExpression">
      <summary>Representa uma operação dinâmica.</summary>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Expede o método específico de visita para esse tipo de nó. Por exemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chama o <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor">O visitante com o qual visitar esse nó.</param>
      <returns>O resultado de visitar esse nó.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido.</summary>
      <param name="binder">O associador de runtime para a operação dinâmica.</param>
      <param name="returnType">O tipo de resultado da expressão dinâmica.</param>
      <param name="arguments">Os argumentos para a operação dinâmica.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidos para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido.</summary>
      <param name="binder">O associador de runtime para a operação dinâmica.</param>
      <param name="returnType">O tipo de resultado da expressão dinâmica.</param>
      <param name="arg0">O primeiro argumento para a operação dinâmica.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidos para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido.</summary>
      <param name="binder">O associador de runtime para a operação dinâmica.</param>
      <param name="returnType">O tipo de resultado da expressão dinâmica.</param>
      <param name="arg0">O primeiro argumento para a operação dinâmica.</param>
      <param name="arg1">O segundo argumento para a operação dinâmica.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidos para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido.</summary>
      <param name="binder">O associador de runtime para a operação dinâmica.</param>
      <param name="returnType">O tipo de resultado da expressão dinâmica.</param>
      <param name="arg0">O primeiro argumento para a operação dinâmica.</param>
      <param name="arg1">O segundo argumento para a operação dinâmica.</param>
      <param name="arg2">O terceiro argumento para a operação dinâmica.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidos para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido.</summary>
      <param name="binder">O associador de runtime para a operação dinâmica.</param>
      <param name="returnType">O tipo de resultado da expressão dinâmica.</param>
      <param name="arg0">O primeiro argumento para a operação dinâmica.</param>
      <param name="arg1">O segundo argumento para a operação dinâmica.</param>
      <param name="arg2">O terceiro argumento para a operação dinâmica.</param>
      <param name="arg3">O quarto argumento para a operação dinâmica.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidos para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression[])">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido.</summary>
      <param name="binder">O associador de runtime para a operação dinâmica.</param>
      <param name="returnType">O tipo de resultado da expressão dinâmica.</param>
      <param name="arguments">Os argumentos para a operação dinâmica.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidos para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido.</summary>
      <param name="delegateType">O tipo do delegado usado pelo <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">O associador de runtime para a operação dinâmica.</param>
      <param name="arguments">Os argumentos para a operação dinâmica.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidos para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido e um argumento.</summary>
      <param name="delegateType">O tipo do delegado usado pelo <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">O associador de runtime para a operação dinâmica.</param>
      <param name="arg0">O argumento para a operação dinâmica.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidos para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido e dois argumentos.</summary>
      <param name="delegateType">O tipo do delegado usado pelo <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">O associador de runtime para a operação dinâmica.</param>
      <param name="arg0">O primeiro argumento para a operação dinâmica.</param>
      <param name="arg1">O segundo argumento para a operação dinâmica.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidos para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido e três argumentos.</summary>
      <param name="delegateType">O tipo do delegado usado pelo <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">O associador de runtime para a operação dinâmica.</param>
      <param name="arg0">O primeiro argumento para a operação dinâmica.</param>
      <param name="arg1">O segundo argumento para a operação dinâmica.</param>
      <param name="arg2">O terceiro argumento para a operação dinâmica.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidos para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido e quatro argumentos.</summary>
      <param name="delegateType">O tipo do delegado usado pelo <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">O associador de runtime para a operação dinâmica.</param>
      <param name="arg0">O primeiro argumento para a operação dinâmica.</param>
      <param name="arg1">O segundo argumento para a operação dinâmica.</param>
      <param name="arg2">O terceiro argumento para a operação dinâmica.</param>
      <param name="arg3">O quarto argumento para a operação dinâmica.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidos para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression[])">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido.</summary>
      <param name="delegateType">O tipo do delegado usado pelo <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">O associador de runtime para a operação dinâmica.</param>
      <param name="arguments">Os argumentos para a operação dinâmica.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidos para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)">
      <summary>Retorna o argumento no índice, lançando se o índice estiver fora dos limites. Você não deve usar esse membro. Ele só é público devido a refatoração de assembly e é usado internamente para otimizações de desempenho.</summary>
      <param name="index">O índice do argumento.</param>
      <returns>Retorna <see cref="T:System.Linq.Expressions.Expression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.System#Linq#Expressions#IDynamicExpression#CreateCallSite">
      <summary>Opcionalmente, cria e retorna o CallSite para o cache embutido polimórfico de DynamicExpression. Você não deve usar esse membro. Ele só é público devido a refatoração de assembly e é usado internamente para otimizações de desempenho.</summary>
      <returns>Retorna <see cref="T:System.Object" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.System#Linq#Expressions#IDynamicExpression#Rewrite(System.Linq.Expressions.Expression[])">
      <summary>Regrava este nó substituindo os argumentos da expressão dinâmica pelos valores fornecidos. O número de <paramref name="args" /> precisa corresponder ao número da expressão atual. Você não deve usar esse tipo. Ele só é público devido a refatoração de assembly e é usado internamente para otimizações de desempenho. Esse método auxiliar permite que a regravação de nós seja independente da classe de implementação específica derivada de DynamicExpression que está sendo usada no local da chamada.</summary>
      <param name="args">Os argumentos.</param>
      <returns>Retorna <see cref="T:System.Linq.Expressions.Expression" />, a expressão reescrita.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Compara o valor enviado para o parâmetro, <paramref name="arguments" />, para a propriedade <see langword="Arguments" /> da instância atual do <see langword="DynamicExpression" />. Se os valores do parâmetro e a propriedade forem iguais, a instância atual será retornada. Se não forem iguais, uma nova instância <see langword="DynamicExpression" /> será retornada idêntica à instância atual, exceto se a propriedade <see langword="Arguments" /> for definida como o valor do parâmetro <paramref name="arguments" />.</summary>
      <param name="arguments">A propriedade <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> do resultado.</param>
      <returns>Essa expressão se nenhum filho foi alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.Arguments">
      <summary>Obtém os argumentos para a operação dinâmica.</summary>
      <returns>As coleções somente leitura que contêm os argumentos para a operação dinâmica.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.Binder">
      <summary>Obtém o <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />, que determina o comportamento de tempo de execução do site dinâmico.</summary>
      <returns>O <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> , que determina o comportamento de tempo de execução do site dinâmico.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.DelegateType">
      <summary>Obtém o tipo do delegado usado pelo <see cref="T:System.Runtime.CompilerServices.CallSite" />.</summary>
      <returns>O <see cref="T:System.Type" /> objeto que representa o tipo do delegado usado pelo <see cref="T:System.Runtime.CompilerServices.CallSite" /> .</returns>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.NodeType">
      <summary>Retorna o tipo de nó dessa expressão. Nós de extensão devem retornar <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> ao substituírem esse método.</summary>
      <returns>O <see cref="T:System.Linq.Expressions.ExpressionType" /> da expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount">
      <summary>Retorna o número de argumentos para o nó de árvore de expressão. Você não deve usar esse membro. Ele só é público devido a refatoração de assembly e é usado internamente para otimizações de desempenho.</summary>
      <returns>Retorna <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.Type">
      <summary>Obtém o tipo estático da expressão que esse <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>O <see cref="P:System.Linq.Expressions.DynamicExpression.Type" /> que representa o tipo estático da expressão.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DynamicExpressionVisitor">
      <summary>Representa um visitante ou regravador de árvores de expressão dinâmica.</summary>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpressionVisitor.#ctor">
      <summary>Inicializa uma nova instância de <see cref="T:System.Linq.Expressions.DynamicExpressionVisitor" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpressionVisitor.VisitDynamic(System.Linq.Expressions.DynamicExpression)">
      <summary>Visita os filhos de <see cref="T:System.Linq.Expressions.DynamicExpression" />.</summary>
      <param name="node">A expressão a ser visitada.</param>
      <returns>Retorna <see cref="T:System.Linq.Expressions.Expression" />, a expressão modificada, se ela ou alguma subexpressão tiver sido modificada, caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ElementInit">
      <summary>Representa um inicializador para um único elemento de uma coleção <see cref="T:System.Collections.IEnumerable" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ElementInit.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)">
      <summary>Retorna o argumento no índice, lançando se o índice estiver fora dos limites.  Você não deve usar esse membro.  Ele só é público devido a refatoração de assembly e é usado internamente para otimizações de desempenho.</summary>
      <param name="index">O índice do argumento.</param>
      <returns>Retorna <see cref="T:System.Linq.Expressions.Expression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ElementInit.ToString">
      <summary>Retorna uma representação textual de um objeto <see cref="T:System.Linq.Expressions.ElementInit" />.</summary>
      <returns>Uma representação textual do objeto <see cref="T:System.Linq.Expressions.ElementInit" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ElementInit.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="arguments">A propriedade <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> do resultado.</param>
      <returns>Essa expressão se nenhum filho foi alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.AddMethod">
      <summary>Obtém o método de instância que é usado para adicionar um elemento a uma coleção <see cref="T:System.Collections.IEnumerable" />.</summary>
      <returns>Um <see cref="T:System.Reflection.MethodInfo" /> que representa um método de instância que adiciona um elemento a uma coleção.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.Arguments">
      <summary>Obtém a coleção de argumentos que são passados para um método que adiciona um elemento a uma coleção <see cref="T:System.Collections.IEnumerable" />.</summary>
      <returns>Um <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> dos <see cref="T:System.Linq.Expressions.Expression" /> objetos que representam os argumentos para um método que adiciona um elemento a uma coleção.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.System#Linq#Expressions#IArgumentProvider#ArgumentCount">
      <summary>Retorna o número de argumentos para o nó de árvore de expressão.  Você não deve usar esse membro.  Ele só é público devido a refatoração de assembly e é usado internamente para otimizações de desempenho.</summary>
      <returns>Retorna <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:System.Linq.Expressions.Expression">
      <summary>Fornece a classe base da qual são derivadas as classes que representam nós de árvore de expressão. Também contém métodos de fábrica <see langword="static" /> (<see langword="Shared" /> no Visual Basic) para criar os diferentes tipos de nós. Esta é uma classe <see langword="abstract" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.Expression.#ctor">
      <summary>Constrói uma nova instância de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.Expression.#ctor(System.Linq.Expressions.ExpressionType,System.Type)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <param name="nodeType">O <see cref="T:System.Linq.Expressions.ExpressionType" /> para definir como tipo de nó.</param>
      <param name="type">O <see cref="P:System.Linq.Expressions.Expression.Type" /> desse <see cref="T:System.Linq.Expressions.Expression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Expede o método específico de visita para esse tipo de nó. Por exemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chama o <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor">O visitante com o qual visitar esse nó.</param>
      <returns>O resultado de visitar esse nó.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de adição que não tem verificação de estouro.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O operador de adição não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de adição que não tem verificação de estouro. O método de implementação pode ser especificado.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> é <see langword="null" /> e o operador de adição não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de adição que não tem a verificação de estouro.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de adição que não tem a verificação de estouro.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de adição que não tem a verificação de estouro.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <param name="conversion">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de adição que tem verificação de estouro.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de adição que tem verificação de estouro.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de adição que tem verificação de estouro.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <param name="conversion">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de adição que tem verificação de estouro.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O operador de adição não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de adição que tem verificação de estouro. O método de implementação pode ser especificado.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> é <see langword="null" /> e o operador de adição não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="AND" /> bit a bit.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O operador <see langword="AND" /> bit a bit não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.And" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="AND" /> bit a bit. O método de implementação pode ser especificado.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> é <see langword="null" /> e o operador <see langword="AND" /> bit a bit não é definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.And" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="AND" /> condicional que avalia o segundo operando somente se o primeiro operando é avaliado como <see langword="true" />.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O operador <see langword="AND" /> bit a bit não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.  
  
- ou - 
 <paramref name="left" />.Type e <paramref name="right" />.Type não são do mesmo tipo booliano.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="AND" /> condicional que avalia o segundo operando somente se o primeiro operando é resolvido para verdadeiro. O método de implementação pode ser especificado.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> é <see langword="null" /> e o operador <see langword="AND" /> bit a bit não é definido para <paramref name="left" />.Type e <paramref name="right" />.Type.  
  
- ou - 
 <paramref name="method" /> é <see langword="null" /> e Type.<paramref name="left" /> e Type.<paramref name="right" /> não são do mesmo tipo booliano.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição AND bit a bit.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição AND bit a bit.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição AND bit a bit.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <param name="conversion">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.IndexExpression" /> para acessar uma matriz multidimensional.</summary>
      <param name="array">Uma expressão que representa a matriz multidimensional.</param>
      <param name="indexes">Uma <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém as expressões usadas para indexar a matriz.</param>
      <returns>O <see cref="T:System.Linq.Expressions.IndexExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.IndexExpression" /> para acessar uma matriz.</summary>
      <param name="array">Uma expressão que representa a matriz a ser indexada.</param>
      <param name="indexes">Uma matriz que contém as expressões usadas para indexar a matriz.</param>
      <returns>O <see cref="T:System.Linq.Expressions.IndexExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa a aplicação de um operador de índice de matriz a uma matriz de classificação superior a um.</summary>
      <param name="array">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> igual a ele.</param>
      <param name="indexes">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> ou <paramref name="indexes" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type não representa um tipo de matriz.  
  
- ou - 
A classificação de <paramref name="array" />.Type não corresponde ao número de elementos em <paramref name="indexes" />.  
  
- ou - 
A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um ou mais elementos de <paramref name="indexes" /> não representa o tipo <see cref="T:System.Int32" />.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa a aplicação de um operador de índice de matriz a uma matriz de classificação um.</summary>
      <param name="array">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="index">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> ou <paramref name="index" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type não representa um tipo de matriz.  
  
- ou - 
 <paramref name="array" />.Type representa um tipo de matriz cuja classificação não é 1.  
  
- ou - 
 <paramref name="index" />.Type não representa o tipo <see cref="T:System.Int32" />.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ArrayIndex" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa a aplicação de um operador de índice de matriz a uma matriz multidimensional.</summary>
      <param name="array">Uma matriz de instâncias <see cref="T:System.Linq.Expressions.Expression" />/índices para a operação de índice da matriz.</param>
      <param name="indexes">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> ou <paramref name="indexes" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type não representa um tipo de matriz.  
  
- ou - 
A classificação de <paramref name="array" />.Type não corresponde ao número de elementos em <paramref name="indexes" />.  
  
- ou - 
A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um ou mais elementos de <paramref name="indexes" /> não representa o tipo <see cref="T:System.Int32" />.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayLength(System.Linq.Expressions.Expression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma expressão para obter o comprimento de uma matriz unidimensional.</summary>
      <param name="array">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type não representa um tipo de matriz.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ArrayLength" /> e a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a <paramref name="array" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Assign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Assign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MemberInfo,System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.MemberAssignment" /> que representa a inicialização de um campo ou propriedade.</summary>
      <param name="member">Um <see cref="T:System.Reflection.MemberInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> igual a ele.</param>
      <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> ou <paramref name="expression" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> não representa um campo ou propriedade.  
  
- ou - 
A propriedade representada por <paramref name="member" /> não tem um acessador <see langword="set" />.  
  
- ou - 
 <paramref name="expression" />.Type não é atribuível ao tipo de campo ou à propriedade que <paramref name="member" /> representa.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.MemberAssignment" /> que tem <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> igual a <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" /> e as propriedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> e <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> definidas para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.MemberAssignment" /> que representa a inicialização de um membro usando um método de acessador de propriedade.</summary>
      <param name="propertyAccessor">Um <see cref="T:System.Reflection.MethodInfo" /> que representa um método de acessador de propriedade.</param>
      <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> ou <paramref name="expression" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> não representa um método de acessador de propriedade.  
  
- ou - 
A propriedade acessada por <paramref name="propertyAccessor" /> não tem um acessador <see langword="set" />.  
  
- ou - 
 <paramref name="expression" />.Type não é atribuível ao tipo de campo ou à propriedade que <paramref name="member" /> representa.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.MemberAssignment" /> que tem a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> igual a <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" />, a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> definida para o <see cref="T:System.Reflection.PropertyInfo" /> que representa a propriedade acessada em <paramref name="propertyAccessor" /> e a propriedade <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> definida para <paramref name="expression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém as expressões determinadas e não tem variáveis.</summary>
      <param name="expressions">As expressões no bloco.</param>
      <returns>O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém as expressões e variáveis determinadas.</summary>
      <param name="variables">As variáveis no bloco.</param>
      <param name="expressions">As expressões no bloco.</param>
      <returns>O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém as expressões e variáveis determinadas.</summary>
      <param name="variables">As variáveis no bloco.</param>
      <param name="expressions">As expressões no bloco.</param>
      <returns>O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém duas expressões e não tem variáveis.</summary>
      <param name="arg0">A primeira expressão no bloco.</param>
      <param name="arg1">A segunda expressão no bloco.</param>
      <returns>O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém três expressões e não tem variáveis.</summary>
      <param name="arg0">A primeira expressão no bloco.</param>
      <param name="arg1">A segunda expressão no bloco.</param>
      <param name="arg2">A terceira expressão no bloco.</param>
      <returns>O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém quatro expressões e não tem variáveis.</summary>
      <param name="arg0">A primeira expressão no bloco.</param>
      <param name="arg1">A segunda expressão no bloco.</param>
      <param name="arg2">A terceira expressão no bloco.</param>
      <param name="arg3">A quarta expressão no bloco.</param>
      <returns>O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém cinco expressões e não tem variáveis.</summary>
      <param name="arg0">A primeira expressão no bloco.</param>
      <param name="arg1">A segunda expressão no bloco.</param>
      <param name="arg2">A terceira expressão no bloco.</param>
      <param name="arg3">A quarta expressão no bloco.</param>
      <param name="arg4">A quinta expressão no bloco.</param>
      <returns>O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression[])">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém as expressões determinadas e não tem variáveis.</summary>
      <param name="expressions">As expressões no bloco.</param>
      <returns>O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém as expressões fornecidas, não tem variáveis e tem um tipo de resultado específico.</summary>
      <param name="type">O tipo de resultado do bloco.</param>
      <param name="expressions">As expressões no bloco.</param>
      <returns>O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém as expressões e variáveis determinadas.</summary>
      <param name="type">O tipo de resultado do bloco.</param>
      <param name="variables">As variáveis no bloco.</param>
      <param name="expressions">As expressões no bloco.</param>
      <returns>O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém as expressões e variáveis determinadas.</summary>
      <param name="type">O tipo de resultado do bloco.</param>
      <param name="variables">As variáveis no bloco.</param>
      <param name="expressions">As expressões no bloco.</param>
      <returns>O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Linq.Expressions.Expression[])">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém as expressões fornecidas, não tem variáveis e tem um tipo de resultado específico.</summary>
      <param name="type">O tipo de resultado do bloco.</param>
      <param name="expressions">As expressões no bloco.</param>
      <returns>O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução break.</summary>
      <param name="target">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Break, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para <paramref name="target" /> e um valor nulo a ser passado para o rótulo de destino ao saltar.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução break. O valor passado para o rótulo no salto pode ser especificado.</summary>
      <param name="target">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</param>
      <param name="value">O valor que será passado para o rótulo associado ao saltar.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Break, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para <paramref name="target" /> e <paramref name="value" /> a ser passado para o rótulo de destino ao saltar.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução break com o tipo especificado. O valor passado para o rótulo no salto pode ser especificado.</summary>
      <param name="target">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</param>
      <param name="value">O valor que será passado para o rótulo associado ao saltar.</param>
      <param name="type">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Break, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para <paramref name="target" />, a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> definida para <paramref name="type" /> e <paramref name="value" /> a serem passados para o rótulo de destino após saltar.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução break com o tipo especificado.</summary>
      <param name="target">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</param>
      <param name="type">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Break, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para <paramref name="target" /> e a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> definida para <paramref name="type" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método que não aceita argumentos.</summary>
      <param name="instance">Um <see cref="T:System.Linq.Expressions.Expression" /> que especifica a instância de uma chamada de método de instância (passa <see langword="null" /> para um método <see langword="static" /> (<see langword="Shared" /> no Visual Basic)).</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="instance" /> é <see langword="null" /> e <paramref name="method" /> representa um método de instância.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="instance" />. O tipo não é atribuível ao tipo de declaração de método representada pelo <paramref name="method" />.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método que aceita argumentos.</summary>
      <param name="instance">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> igual a (passar <see langword="null" /> para um método <see langword="static" /> [<see langword="Shared" /> no Visual Basic]).</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> igual a ele.</param>
      <param name="arguments">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="instance" /> é <see langword="null" /> e <paramref name="method" /> representa um método de instância.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="instance" />. O tipo não é atribuível ao tipo de declaração de método representada pelo <paramref name="method" />.  
  
- ou - 
O número de elementos em <paramref name="arguments" /> não é igual ao número de parâmetros para o método representado por <paramref name="method" />.  
  
- ou - 
Um ou mais dos elementos de <paramref name="arguments" /> não é atribuível ao parâmetro correspondente para o método representado por <paramref name="method" />.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método que aceita dois argumentos.</summary>
      <param name="instance">Um <see cref="T:System.Linq.Expressions.Expression" /> que especifica a instância de uma chamada de instância. (passar nulo para um método estático [compartilhado no Visual Basic]).</param>
      <param name="method">O <see cref="T:System.Reflection.MethodInfo" /> que representa o método de destino.</param>
      <param name="arg0">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o primeiro argumento.</param>
      <param name="arg1">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o segundo argumento.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método que usa três argumentos.</summary>
      <param name="instance">Um <see cref="T:System.Linq.Expressions.Expression" /> que especifica a instância de uma chamada de instância. (passar nulo para um método estático [compartilhado no Visual Basic]).</param>
      <param name="method">O <see cref="T:System.Reflection.MethodInfo" /> que representa o método de destino.</param>
      <param name="arg0">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o primeiro argumento.</param>
      <param name="arg1">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o segundo argumento.</param>
      <param name="arg2">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o terceiro argumento.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método que aceita argumentos.</summary>
      <param name="instance">Um <see cref="T:System.Linq.Expressions.Expression" /> que especifica a instância de uma chamada de método de instância (passa <see langword="null" /> para um método <see langword="static" /> (<see langword="Shared" /> no Visual Basic)).</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> igual a ele.</param>
      <param name="arguments">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="instance" /> é <see langword="null" /> e <paramref name="method" /> representa um método de instância.  
  
- ou - 
 <paramref name="arguments" /> não é <see langword="null" /> e um ou mais dos seus elementos é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="instance" />. O tipo não é atribuível ao tipo de declaração de método representada pelo <paramref name="method" />.  
  
- ou - 
O número de elementos em <paramref name="arguments" /> não é igual ao número de parâmetros para o método representado por <paramref name="method" />.  
  
- ou - 
Um ou mais dos elementos de <paramref name="arguments" /> não é atribuível ao parâmetro correspondente para o método representado por <paramref name="method" />.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.String,System.Type[],System.Linq.Expressions.Expression[])">
      <summary>Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método chamando o método de fábrica apropriado.</summary>
      <param name="instance">Um <see cref="T:System.Linq.Expressions.Expression" /> cujo valor da propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> será pesquisado quanto a um método específico.</param>
      <param name="methodName">O nome do método.</param>
      <param name="typeArguments">Uma matriz de objetos <see cref="T:System.Type" /> que especificam os parâmetros de tipo do método genérico. Esse argumento deve ser nulo quando methodName especifica um método não genérico.</param>
      <param name="arguments">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representa os argumentos para o método.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="instance" /> ou <paramref name="methodName" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Nenhum método cujo nome é <paramref name="methodName" />, cujos parâmetros de tipo correspondem a <paramref name="typeArguments" /> e cujos tipos de parâmetro correspondem a <paramref name="arguments" /> foi encontrado em <paramref name="instance" />.Type ou em seus tipos base.  
  
- ou - 
Mais de um método cujo nome é <paramref name="methodName" />, cujos parâmetros de tipo correspondem a <paramref name="typeArguments" /> e cujos tipos de parâmetro correspondem a <paramref name="arguments" /> foi encontrado em <paramref name="instance" />.Type ou em seus tipos base.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> igual a <paramref name="instance" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definido como o <see cref="T:System.Reflection.MethodInfo" /> que representa o método de instância especificado e <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> definido como os argumentos especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método estático (compartilhado no Visual Basic).</summary>
      <param name="method">O <see cref="T:System.Reflection.MethodInfo" /> que representa o método de destino.</param>
      <param name="arguments">Uma coleção de <see cref="T:System.Linq.Expressions.Expression" /> que representa os argumentos de chamada.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método <see langword="static" /> (<see langword="Shared" /> no Visual Basic) que aceita um argumento.</summary>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> igual a ele.</param>
      <param name="arg0">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o primeiro argumento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> é nulo.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método estático que aceita dois argumentos.</summary>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> igual a ele.</param>
      <param name="arg0">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o primeiro argumento.</param>
      <param name="arg1">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o segundo argumento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> é nulo.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método estático que usa três argumentos.</summary>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> igual a ele.</param>
      <param name="arg0">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o primeiro argumento.</param>
      <param name="arg1">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o segundo argumento.</param>
      <param name="arg2">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o terceiro argumento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> é nulo.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método estático que aceita quatro argumentos.</summary>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> igual a ele.</param>
      <param name="arg0">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o primeiro argumento.</param>
      <param name="arg1">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o segundo argumento.</param>
      <param name="arg2">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o terceiro argumento.</param>
      <param name="arg3">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o quarto argumento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> é nulo.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método estático que aceita cinco argumentos.</summary>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> igual a ele.</param>
      <param name="arg0">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o primeiro argumento.</param>
      <param name="arg1">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o segundo argumento.</param>
      <param name="arg2">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o terceiro argumento.</param>
      <param name="arg3">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o quarto argumento.</param>
      <param name="arg4">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o quinto argumento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> é nulo.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método <see langword="static" /> (<see langword="Shared" /> no Visual Basic) que tem argumentos.</summary>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> que representa um método <see langword="static" /> (<see langword="Shared" /> no Visual Basic) igual ao qual definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arguments">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">O número de elementos em <paramref name="arguments" /> não é igual ao número de parâmetros para o método representado por <paramref name="method" />.  
  
- ou - 
Um ou mais dos elementos de <paramref name="arguments" /> não é atribuível ao parâmetro correspondente para o método representado por <paramref name="method" />.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Type,System.String,System.Type[],System.Linq.Expressions.Expression[])">
      <summary>Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método <see langword="static" /> (<see langword="Shared" /> no Visual Basic) chamando o método de fábrica apropriado.</summary>
      <param name="type">O tipo que contém o método <see langword="static" /> especificado (<see langword="Shared" /> no Visual Basic).</param>
      <param name="methodName">O nome do método.</param>
      <param name="typeArguments">Uma matriz de objetos <see cref="T:System.Type" /> que especificam os parâmetros de tipo do método genérico. Esse argumento deve ser nulo quando methodName especifica um método não genérico.</param>
      <param name="arguments">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representam os argumentos para o método.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> ou <paramref name="methodName" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Nenhum método cujo nome é <paramref name="methodName" />, cujos parâmetros de tipo correspondem a <paramref name="typeArguments" /> e cujos tipos de parâmetro correspondem a <paramref name="arguments" /> foi encontrado em <paramref name="type" /> ou em seus tipos base.  
  
- ou - 
Mais de um método cujo nome é <paramref name="methodName" />, cujos parâmetros de tipo correspondem a <paramref name="typeArguments" /> e cujos tipos de parâmetro correspondem a <paramref name="arguments" /> foi encontrado em <paramref name="type" /> ou em seus tipos base.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definida como o <see cref="T:System.Reflection.MethodInfo" /> que representa o método <see langword="static" /> especificado (<see langword="Shared" /> no Visual Basic) e a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> definida como os argumentos especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa uma instrução catch com uma referência para o objeto <see cref="T:System.Exception" /> capturado para uso no corpo do manipulador.</summary>
      <param name="variable">Uma <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representa uma referência para o objeto <see cref="T:System.Exception" /> capturado por este manipulador.</param>
      <param name="body">O corpo da instrução catch.</param>
      <returns>O <see cref="T:System.Linq.Expressions.CatchBlock" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa uma instrução catch com um filtro <see cref="T:System.Exception" /> e uma referência para o objeto <see cref="T:System.Exception" /> capturado.</summary>
      <param name="variable">Uma <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representa uma referência para o objeto <see cref="T:System.Exception" /> capturado por este manipulador.</param>
      <param name="body">O corpo da instrução catch.</param>
      <param name="filter">O corpo do filtro <see cref="T:System.Exception" />.</param>
      <returns>O <see cref="T:System.Linq.Expressions.CatchBlock" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa uma instrução catch.</summary>
      <param name="type">O <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que esse <see cref="T:System.Linq.Expressions.CatchBlock" /> tratará.</param>
      <param name="body">O corpo da instrução catch.</param>
      <returns>O <see cref="T:System.Linq.Expressions.CatchBlock" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa uma instrução catch com um filtro <see cref="T:System.Exception" />, mas nenhuma referência ao objeto <see cref="T:System.Exception" /> capturado.</summary>
      <param name="type">O <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que esse <see cref="T:System.Linq.Expressions.CatchBlock" /> tratará.</param>
      <param name="body">O corpo da instrução catch.</param>
      <param name="filter">O corpo do filtro <see cref="T:System.Exception" />.</param>
      <returns>O <see cref="T:System.Linq.Expressions.CatchBlock" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ClearDebugInfo(System.Linq.Expressions.SymbolDocumentInfo)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> para limpar um ponto de sequência.</summary>
      <param name="document">O <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que representa o arquivo de origem.</param>
      <returns>Uma instância de <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> para limpar um ponto de sequência.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de união.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> do <paramref name="left" /> não representa um tipo de referência nem um tipo de valor que permite um valor null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="left" />.Type e <paramref name="right" />.Type não são conversíveis entre si.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de união, dada uma função de conversão.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="conversion">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="left" />.Type e <paramref name="right" />.Type não são conversíveis entre si.  
  
- ou - 
 <paramref name="conversion" /> não é <see langword="null" /> e <paramref name="conversion" />. O tipo é um tipo delegado que não aceita exatamente um argumento.</exception>
      <exception cref="T:System.InvalidOperationException">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> do <paramref name="left" /> não representa um tipo de referência nem um tipo de valor que permite um valor null.  
  
- ou - 
A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="left" /> representa um tipo que não é atribuível ao tipo de parâmetro do tipo delegado <paramref name="conversion" />.Type.  
  
- ou - 
A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="right" /> não é igual ao tipo de retorno do tipo delegado <paramref name="conversion" />.Type.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa uma instrução condicional.</summary>
      <param name="test">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> igual a ele.</param>
      <param name="ifTrue">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> igual a ele.</param>
      <param name="ifFalse">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="test" />, <paramref name="ifTrue" /> ou <paramref name="ifFalse" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="test" />.Type não é <see cref="T:System.Boolean" />.  
  
- ou - 
 <paramref name="ifTrue" />.Type não é igual a <paramref name="ifFalse" />.Type.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> e as propriedades <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> e <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Type)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa uma instrução condicional.</summary>
      <param name="test">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> igual a ele.</param>
      <param name="ifTrue">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> igual a ele.</param>
      <param name="ifFalse">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> igual a ele.</param>
      <param name="type">Um <see cref="P:System.Linq.Expressions.Expression.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> e as propriedades <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> e <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Constant(System.Object)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.ConstantExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> definida para o valor especificado.</summary>
      <param name="value">Um <see cref="T:System.Object" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> igual a ele.</param>
      <returns>Uma <see cref="T:System.Linq.Expressions.ConstantExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> e a propriedade <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> definida para o valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Constant(System.Object,System.Type)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.ConstantExpression" /> que tem as propriedades <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> e <see cref="P:System.Linq.Expressions.Expression.Type" /> definidas com os valores especificados.</summary>
      <param name="value">Um <see cref="T:System.Object" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> igual a ele.</param>
      <param name="type">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="value" /> não é <see langword="null" /> e <paramref name="type" /> não pode ser atribuído do tipo dinâmico de <paramref name="value" />.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.ConstantExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> e as propriedades <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> e <see cref="P:System.Linq.Expressions.Expression.Type" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução continue.</summary>
      <param name="target">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Continue, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para <paramref name="target" /> e um valor nulo a ser passado para o rótulo de destino ao saltar.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução continue com o tipo especificado.</summary>
      <param name="target">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</param>
      <param name="type">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Continue, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para <paramref name="target" />, a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> definida para <paramref name="type" /> e um valor nulo a ser passado para o rótulo de destino ao saltar.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação de conversão de tipo.</summary>
      <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</param>
      <param name="type">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="type" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Não há nenhum operador de conversão definido entre <paramref name="expression" />.Type e <paramref name="type" />.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> e as propriedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.Expression.Type" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação de conversão para a qual o método de implementação é especificado.</summary>
      <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</param>
      <param name="type">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="type" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente um argumento.</exception>
      <exception cref="T:System.InvalidOperationException">Não há nenhum operador de conversão definido entre <paramref name="expression" />.Type e <paramref name="type" />.  
  
- ou - 
 <paramref name="expression" />.Type não é atribuível ao tipo de argumento do método representado pelo <paramref name="method" />.  
  
- ou - 
O tipo de retorno do método representado por <paramref name="method" /> não é atribuível ao <paramref name="type" />.  
  
- ou - 
 <paramref name="expression" />.Type ou <paramref name="type" /> é um tipo de valor que permite valor nulo e o tipo de valor que não permite valor nulo correspondente não é igual ao tipo de argumento ou ao tipo de retorno, respectivamente, do método representado por <paramref name="method" />.</exception>
      <exception cref="T:System.Reflection.AmbiguousMatchException">Foi encontrado mais de um método que corresponde à descrição de <paramref name="method" />.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> e as propriedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação de conversão que lança uma exceção se o tipo de destino está estourado.</summary>
      <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</param>
      <param name="type">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="type" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Não há nenhum operador de conversão definido entre <paramref name="expression" />.Type e <paramref name="type" />.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.Expression.Type" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação de conversão que lança uma exceção se o tipo de destino está estourado e para o qual o método de implementação é especificado.</summary>
      <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</param>
      <param name="type">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="type" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente um argumento.</exception>
      <exception cref="T:System.InvalidOperationException">Não há nenhum operador de conversão definido entre <paramref name="expression" />.Type e <paramref name="type" />.  
  
- ou - 
 <paramref name="expression" />.Type não é atribuível ao tipo de argumento do método representado pelo <paramref name="method" />.  
  
- ou - 
O tipo de retorno do método representado por <paramref name="method" /> não é atribuível ao <paramref name="type" />.  
  
- ou - 
 <paramref name="expression" />.Type ou <paramref name="type" /> é um tipo de valor que permite valor nulo e o tipo de valor que não permite valor nulo correspondente não é igual ao tipo de argumento ou ao tipo de retorno, respectivamente, do método representado por <paramref name="method" />.</exception>
      <exception cref="T:System.Reflection.AmbiguousMatchException">Foi encontrado mais de um método que corresponde à descrição de <paramref name="method" />.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DebugInfo(System.Linq.Expressions.SymbolDocumentInfo,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> com o intervalo especificado.</summary>
      <param name="document">O <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que representa o arquivo de origem.</param>
      <param name="startLine">A linha inicial deste <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Deve ser maior que 0.</param>
      <param name="startColumn">A coluna inicial deste <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Deve ser maior que 0.</param>
      <param name="endLine">A linha final deste <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Deve ser maior ou igual à linha inicial.</param>
      <param name="endColumn">A coluna final deste <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Se a linha final é a mesma que a linha inicial, ela deve ser maior ou igual à coluna inicial. Em qualquer caso, ela deve ser maior que 0.</param>
      <returns>Uma instância de <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa o decremento da expressão em 1.</summary>
      <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para diminuir.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão decrementada.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa o decremento da expressão em 1.</summary>
      <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para diminuir.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão decrementada.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Default(System.Type)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.DefaultExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> definida para o tipo especificado.</summary>
      <param name="type">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.DefaultExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> e a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> definida para o tipo especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de divisão.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para o qual definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para o qual definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O operador de divisão não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de divisão. O método de implementação pode ser especificado.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> é <see langword="null" /> e o operador de divisão não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de divisão de adição que não tem verificação de estouro.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de divisão de adição que não tem verificação de estouro.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de divisão de adição que não tem verificação de estouro.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <param name="conversion">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido.</summary>
      <param name="binder">O associador de runtime para a operação dinâmica.</param>
      <param name="returnType">O tipo de resultado da expressão dinâmica.</param>
      <param name="arguments">Os argumentos para a operação dinâmica.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem a <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidas para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido.</summary>
      <param name="binder">O associador de runtime para a operação dinâmica.</param>
      <param name="returnType">O tipo de resultado da expressão dinâmica.</param>
      <param name="arg0">O primeiro argumento para a operação dinâmica.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem a <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidas para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido.</summary>
      <param name="binder">O associador de runtime para a operação dinâmica.</param>
      <param name="returnType">O tipo de resultado da expressão dinâmica.</param>
      <param name="arg0">O primeiro argumento para a operação dinâmica.</param>
      <param name="arg1">O segundo argumento para a operação dinâmica.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem a <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidas para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido.</summary>
      <param name="binder">O associador de runtime para a operação dinâmica.</param>
      <param name="returnType">O tipo de resultado da expressão dinâmica.</param>
      <param name="arg0">O primeiro argumento para a operação dinâmica.</param>
      <param name="arg1">O segundo argumento para a operação dinâmica.</param>
      <param name="arg2">O terceiro argumento para a operação dinâmica.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem a <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidas para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido.</summary>
      <param name="binder">O associador de runtime para a operação dinâmica.</param>
      <param name="returnType">O tipo de resultado da expressão dinâmica.</param>
      <param name="arg0">O primeiro argumento para a operação dinâmica.</param>
      <param name="arg1">O segundo argumento para a operação dinâmica.</param>
      <param name="arg2">O terceiro argumento para a operação dinâmica.</param>
      <param name="arg3">O quarto argumento para a operação dinâmica.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem a <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidas para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression[])">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido.</summary>
      <param name="binder">O associador de runtime para a operação dinâmica.</param>
      <param name="returnType">O tipo de resultado da expressão dinâmica.</param>
      <param name="arguments">Os argumentos para a operação dinâmica.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem a <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidas para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.ElementInit" />, dado um <see cref="T:System.Collections.Generic.IEnumerable`1" /> como o segundo argumento.</summary>
      <param name="addMethod">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> igual a ele.</param>
      <param name="arguments">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> igual aos quais definir a propriedade <see cref="P:System.Linq.Expressions.ElementInit.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="addMethod" /> ou <paramref name="arguments" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">O método representado por <paramref name="addMethod" /> não é nomeado "Add" (não diferencia maiúsculas de minúsculas).  
  
- ou - 
O método representado por <paramref name="addMethod" /> não é um método de instância.  
  
- ou - 
 <paramref name="arguments" /> não contém o mesmo número de elementos que o número de parâmetros para o método representado por <paramref name="addMethod" />.  
  
- ou - 
A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um ou mais elementos de <paramref name="arguments" /> não pode ser atribuída ao tipo do parâmetro correspondente do método representado por <paramref name="addMethod" />.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.ElementInit" /> que tem as propriedades <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> e <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> definidas para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.ElementInit" />, dada uma matriz de valores como o segundo argumento.</summary>
      <param name="addMethod">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> igual a ele.</param>
      <param name="arguments">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> igual aos quais definir a propriedade <see cref="P:System.Linq.Expressions.ElementInit.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="addMethod" /> ou <paramref name="arguments" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">O método representado por addMethod não é nomeado "Add" (não diferencia maiúsculas de minúsculas).  
  
- ou - 
O método representado por addMethod não é um método de instância.  
  
- ou - 
arguments não contém o mesmo número de elementos que o número de parâmetros para o método representado por addMethod.  
  
- ou - 
A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um ou mais elementos de <paramref name="arguments" /> não pode ser atribuída ao tipo do parâmetro correspondente do método representado por <paramref name="addMethod" />.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.ElementInit" /> que tem as propriedades <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> e <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> definidas para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Empty">
      <summary>Cria uma expressão vazia com o tipo <see cref="T:System.Void" />.</summary>
      <returns>O <see cref="T:System.Linq.Expressions.DefaultExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> e a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> definida como <see cref="T:System.Void" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação de igualdade.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O operador de igualdade não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação de igualdade. O método de implementação pode ser especificado.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="liftToNull">
        <see langword="true" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="true" />; <see langword="false" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="false" />.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> é <see langword="null" /> e o operador de igualdade não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="XOR" /> bit a bit, usando <c>op_ExclusiveOr</c> para tipos definidos pelo usuário.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O operador <see langword="XOR" /> não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="XOR" /> bit a bit, usando <c>op_ExclusiveOr</c> para tipos definidos pelo usuário. O método de implementação pode ser especificado.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> é <see langword="null" /> e o operador <see langword="XOR" /> não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição XOR bit a bit, usando <c>op_ExclusiveOr</c> para tipos definidos pelo usuário.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição XOR bit a bit, usando <c>op_ExclusiveOr</c> para tipos definidos pelo usuário.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição XOR bit a bit, usando <c>op_ExclusiveOr</c> para tipos definidos pelo usuário.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <param name="conversion">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Reflection.FieldInfo)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa o acesso a um campo.</summary>
      <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> igual a ele. Para <see langword="static" /> (<see langword="Shared" /> no Visual Basic), <paramref name="expression" /> deve ser <see langword="null" />.</param>
      <param name="field">O <see cref="T:System.Reflection.FieldInfo" /> com um valor igual ao qual a <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> propriedade será definida.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="field" /> é <see langword="null" />.  
  
- ou - 
O campo representado por <paramref name="field" /> não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) e <paramref name="expression" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type não pode ser atribuído ao tipo declarativo do campo representado por <paramref name="field" />.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.MemberExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> e as propriedades <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> e <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.String)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa o acesso a um campo dado o nome do campo.</summary>
      <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> cujo <see cref="P:System.Linq.Expressions.Expression.Type" /> contém um campo chamado <paramref name="fieldName" />. Pode ser nulo para campos estáticos.</param>
      <param name="fieldName">O nome de um campo a ser acessado.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="fieldName" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">Nenhum campo nomeado <paramref name="fieldName" /> é definido no tipo <paramref name="expression" /> ou em seus tipos base.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.MemberExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> definida como <paramref name="expression" /> e a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> definida como o <see cref="T:System.Reflection.FieldInfo" /> que representa o campo indicado por <paramref name="fieldName" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Type,System.String)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa o acesso a um campo.</summary>
      <param name="expression">O objeto recipiente do campo. Pode ser nulo para campos estáticos.</param>
      <param name="type">O <see cref="P:System.Linq.Expressions.Expression.Type" /> que contém o campo.</param>
      <param name="fieldName">O campo a ser acessado.</param>
      <returns>O <see cref="T:System.Linq.Expressions.MemberExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetActionType(System.Type[])">
      <summary>Cria um objeto <see cref="T:System.Type" /> que representa um tipo de delegado genérico <c>System.Action</c> que tem argumentos de tipo específicos.</summary>
      <param name="typeArgs">Uma matriz de um a dezesseis objetos <see cref="T:System.Type" /> que especifica os argumentos de tipo para o tipo de delegado <see langword="System.Action" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="typeArgs" /> contém mais de dezesseis elementos.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="typeArgs" /> é <see langword="null" />.</exception>
      <returns>O tipo de um delegado <c>System.Action</c> que tem os argumentos de tipo especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetDelegateType(System.Type[])">
      <summary>Obtém um objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa um tipo de delegado genérico <c>System.Func</c> ou <c>System.Action</c> que tem argumentos de tipo específicos.</summary>
      <param name="typeArgs">Os argumentos de tipo do delegado.</param>
      <returns>O tipo de delegado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetFuncType(System.Type[])">
      <summary>Cria um objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa um tipo de delegado genérico <c>System.Func</c>, que tem argumentos de tipo específicos. O último argumento de tipo especifica o tipo de retorno do delegado criado.</summary>
      <param name="typeArgs">Uma matriz de um a dezessete objetos <see cref="T:System.Type" /> que especifica os argumentos de tipo para o tipo de delegado <see langword="System.Func" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="typeArgs" /> contém menos de um ou mais de dezessete elementos.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="typeArgs" /> é <see langword="null" />.</exception>
      <returns>O tipo de um delegado <c>System.Func</c> que tem os argumentos de tipo especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução "go to".</summary>
      <param name="target">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Goto, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para o valor especificado e um valor nulo a ser passado para o rótulo de destino após saltar.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução "go to". O valor passado para o rótulo no salto pode ser especificado.</summary>
      <param name="target">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</param>
      <param name="value">O valor que será passado para o rótulo associado ao saltar.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Goto, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para <paramref name="target" /> e <paramref name="value" /> a ser passado para o rótulo de destino ao saltar.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução "go to" com o tipo especificado. O valor passado para o rótulo no salto pode ser especificado.</summary>
      <param name="target">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</param>
      <param name="value">O valor que será passado para o rótulo associado ao saltar.</param>
      <param name="type">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Goto, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para <paramref name="target" />, a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> definida para <paramref name="type" /> e <paramref name="value" /> a ser passado para o rótulo de destino ao saltar.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução "go to" com o tipo especificado.</summary>
      <param name="target">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</param>
      <param name="type">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Goto, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para o valor especificado, a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> definida para <paramref name="type" /> e um valor nulo a serem passados para o rótulo de destino após saltar.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação numérica "maior que".</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O operador “maior que” não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação numérica "maior que". O método de implementação pode ser especificado.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="liftToNull">
        <see langword="true" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="true" />; <see langword="false" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="false" />.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> é <see langword="null" /> e o operador "maior que" não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação numérica "maior ou igual a".</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O operador “maior ou igual a” não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação numérica "maior ou igual a".</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="liftToNull">
        <see langword="true" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="true" />; <see langword="false" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="false" />.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> é <see langword="null" /> e o operador "maior ou igual a" não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa um bloco condicional com uma instrução <see langword="if" />.</summary>
      <param name="test">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> igual a ele.</param>
      <param name="ifTrue">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> e as propriedades <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> e <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> definidas como os valores especificados. A propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> foi definida como a expressão padrão e o tipo do <see cref="T:System.Linq.Expressions.ConditionalExpression" /> resultante retornado por esse método é <see cref="T:System.Void" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa um bloco condicional com as instruções <see langword="if" /> e <see langword="else" />.</summary>
      <param name="test">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> igual a ele.</param>
      <param name="ifTrue">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> igual a ele.</param>
      <param name="ifFalse">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> e as propriedades <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> e <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> definidas com os valores especificados. O tipo de <see cref="T:System.Linq.Expressions.ConditionalExpression" /> resultante retornado por esse método é <see cref="T:System.Void" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa o incremento do valor da expressão em 1.</summary>
      <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> a ser incrementado.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão incrementada.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa o incremento da expressão em 1.</summary>
      <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> a ser incrementado.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão incrementada.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Cria um <see cref="T:System.Linq.Expressions.InvocationExpression" /> que se aplica a uma expressão de delegado ou lambda para uma lista de expressões de argumento.</summary>
      <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa a expressão de delegado ou lambda à qual aplicar.</param>
      <param name="arguments">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> que representam os argumentos aos quais a expressão de delegado ou lambda é aplicada.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type não representa um tipo de delegado nem um <see cref="T:System.Linq.Expressions.Expression`1" />.  
  
- ou - 
A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="arguments" /> não é atribuível ao tipo de parâmetro correspondente ao delegado representado por <paramref name="expression" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="arguments" /> não contém o mesmo número de elementos da lista de parâmetros para o delegado representado por <paramref name="expression" />.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.InvocationExpression" /> que se aplica à expressão de delegado ou lambda especificada para os argumentos fornecidos.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Cria um <see cref="T:System.Linq.Expressions.InvocationExpression" /> que se aplica a uma expressão de delegado ou lambda para uma lista de expressões de argumento.</summary>
      <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa a expressão de delegado ou lambda a ser aplicada.</param>
      <param name="arguments">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representam os argumentos aos quais que a expressão de delegado ou lambda são aplicados.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type não representa um tipo de delegado nem um <see cref="T:System.Linq.Expressions.Expression`1" />.  
  
- ou - 
A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="arguments" /> não é atribuível ao tipo de parâmetro correspondente ao delegado representado por <paramref name="expression" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="arguments" /> não contém o mesmo número de elementos da lista de parâmetros para o delegado representado por <paramref name="expression" />.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.InvocationExpression" /> que se aplica à expressão de delegado ou lambda especificada para os argumentos fornecidos.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression)">
      <summary>Retorna se a expressão é avaliada como false.</summary>
      <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> a ser avaliado.</param>
      <returns>Uma instância de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Retorna se a expressão é avaliada como false.</summary>
      <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> a ser avaliado.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</param>
      <returns>Uma instância de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression)">
      <summary>Retorna se a expressão é avaliada como true.</summary>
      <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> a ser avaliado.</param>
      <returns>Uma instância de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Retorna se a expressão é avaliada como true.</summary>
      <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> a ser avaliado.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</param>
      <returns>Uma instância de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label">
      <summary>Cria um <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa um rótulo com um tipo void e sem nenhum nome.</summary>
      <returns>O novo <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.LabelExpression" /> que representa um rótulo com um valor padrão.</summary>
      <param name="target">O <see cref="T:System.Linq.Expressions.LabelTarget" /> ao qual esse <see cref="T:System.Linq.Expressions.LabelExpression" /> será associado.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.LabelExpression" /> sem um valor padrão.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.LabelExpression" /> que representa um rótulo com o valor padrão fornecido.</summary>
      <param name="target">O <see cref="T:System.Linq.Expressions.LabelTarget" /> ao qual esse <see cref="T:System.Linq.Expressions.LabelExpression" /> será associado.</param>
      <param name="defaultValue">O valor desse <see cref="T:System.Linq.Expressions.LabelExpression" /> quando o rótulo é acessado por meio de fluxo de controle normal.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.LabelExpression" /> com o valor padrão fornecido.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.String)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa um rótulo com um tipo void e o nome fornecido.</summary>
      <param name="name">O nome do rótulo.</param>
      <returns>O novo <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Type)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa um rótulo com o tipo fornecido.</summary>
      <param name="type">O tipo de valor que é passado ao saltar para o rótulo.</param>
      <returns>O novo <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Type,System.String)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa um rótulo com o tipo e nome fornecidos.</summary>
      <param name="type">O tipo de valor que é passado ao saltar para o rótulo.</param>
      <param name="name">O nome do rótulo.</param>
      <returns>O novo <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Cria um <see cref="T:System.Linq.Expressions.LambdaExpression" /> construindo primeiro um tipo delegado do corpo da expressão, um parâmetro que indica se a otimização da parte final da chamada será aplicada e uma coleção enumerável de expressões de parâmetro. Ele pode ser usado quando o tipo de delegado não é conhecido em tempo de compilação.</summary>
      <param name="body">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
      <param name="tailCall">Um <see cref="T:System.Boolean" /> que indica se a otimização de chamada final será aplicada ao compilar a expressão criada.</param>
      <param name="parameters">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a Lambda e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary>Cria um <see cref="T:System.Linq.Expressions.LambdaExpression" /> construindo primeiro um tipo delegado do corpo da expressão, um parâmetro que indica se a otimização da parte final da chamada será aplicada e uma matriz de expressões de parâmetro. Ele pode ser usado quando o tipo de delegado não é conhecido em tempo de compilação.</summary>
      <param name="body">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
      <param name="tailCall">Um <see cref="T:System.Boolean" /> que indica se a otimização de chamada final será aplicada ao compilar a expressão criada.</param>
      <param name="parameters">Uma matriz que contém os objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para popular a coleção <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a Lambda e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Cria um <see cref="T:System.Linq.Expressions.LambdaExpression" /> construindo primeiro um tipo delegado do corpo da expressão e uma coleção enumerável de expressões de parâmetro. Ele pode ser usado quando o tipo de delegado não é conhecido em tempo de compilação.</summary>
      <param name="body">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
      <param name="parameters">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a Lambda e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary>Cria um <see cref="T:System.Linq.Expressions.LambdaExpression" /> construindo primeiro um tipo delegado do corpo da expressão e uma matriz de expressões de parâmetro. Ele pode ser usado quando o tipo de delegado não é conhecido em tempo de compilação.</summary>
      <param name="body">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
      <param name="parameters">Uma matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="body" /> é <see langword="null" />.  
  
- ou - 
Um ou mais elementos de <paramref name="parameters" /> são <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="parameters" /> contém mais de dezesseis elementos.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Cria um <see cref="T:System.Linq.Expressions.LambdaExpression" /> construindo primeiro um tipo delegado do corpo da expressão, o nome do lambda, um parâmetro que indica se a otimização da parte final da chamada será aplicada e uma coleção enumerável de expressões de parâmetro. Ele pode ser usado quando o tipo de delegado não é conhecido em tempo de compilação.</summary>
      <param name="body">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
      <param name="name">O nome para o lambda. Usada para emitir informações de depuração.</param>
      <param name="tailCall">Um <see cref="T:System.Boolean" /> que indica se a otimização de chamada final será aplicada ao compilar a expressão criada.</param>
      <param name="parameters">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a Lambda e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Cria um <see cref="T:System.Linq.Expressions.LambdaExpression" /> construindo primeiro um tipo delegado do corpo da expressão, o nome do lambda e uma coleção enumerável de expressões de parâmetro. Ele pode ser usado quando o tipo de delegado não é conhecido em tempo de compilação.</summary>
      <param name="body">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
      <param name="name">O nome para o lambda. Usada para emitir informações de depuração.</param>
      <param name="parameters">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a Lambda e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Cria um <see cref="T:System.Linq.Expressions.LambdaExpression" /> em que o tipo delegado é conhecido no tempo de compilação, com um parâmetro que indica se a otimização da parte final da chamada será aplicada e uma coleção enumerável de expressões de parâmetro.</summary>
      <param name="delegateType">Um <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa a assinatura de delegado para o lambda.</param>
      <param name="body">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
      <param name="tailCall">Um <see cref="T:System.Boolean" /> que indica se a otimização de chamada final será aplicada ao compilar a expressão criada.</param>
      <param name="parameters">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a Lambda e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary>Cria um <see cref="T:System.Linq.Expressions.LambdaExpression" /> em que o tipo delegado é conhecido no tempo de compilação, com um parâmetro que indica se a otimização da parte final da chamada será aplicada e uma matriz de expressões de parâmetro.</summary>
      <param name="delegateType">Um <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa a assinatura de delegado para o lambda.</param>
      <param name="body">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
      <param name="tailCall">Um <see cref="T:System.Boolean" /> que indica se a otimização de chamada final será aplicada ao compilar a expressão criada.</param>
      <param name="parameters">Uma matriz que contém os objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para popular a coleção <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a Lambda e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Cria um <see cref="T:System.Linq.Expressions.LambdaExpression" /> em que o tipo delegado é conhecido no tempo de compilação, com uma coleção enumerável de expressões de parâmetro.</summary>
      <param name="delegateType">Um <see cref="T:System.Type" /> que representa uma assinatura de delegado para lambda.</param>
      <param name="body">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
      <param name="parameters">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="delegateType" /> ou <paramref name="body" /> é <see langword="null" />.  
  
- ou - 
Um ou mais elementos em <paramref name="parameters" /> são <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="delegateType" /> não representa um tipo de delegado.  
  
- ou - 
 <paramref name="body" />.Type representa um tipo que não é atribuível ao tipo de retorno do tipo de delegado representado por <paramref name="delegateType" />.  
  
- ou - 
 <paramref name="parameters" /> não contém o mesmo número de elementos da lista de parâmetros para o tipo de delegado representado por <paramref name="delegateType" />.  
  
- ou - 
A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="parameters" /> não é atribuível do tipo de parâmetro correspondente do tipo de delegado representado por <paramref name="delegateType" />.</exception>
      <returns>Um objeto que representa uma expressão lambda que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary>Cria um <see cref="T:System.Linq.Expressions.LambdaExpression" /> em que o tipo delegado é conhecido no tempo de compilação, com uma matriz de expressões de parâmetro.</summary>
      <param name="delegateType">Um <see cref="T:System.Type" /> que representa uma assinatura de delegado para lambda.</param>
      <param name="body">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
      <param name="parameters">Uma matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="delegateType" /> ou <paramref name="body" /> é <see langword="null" />.  
  
- ou - 
Um ou mais elementos em <paramref name="parameters" /> são <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="delegateType" /> não representa um tipo de delegado.  
  
- ou - 
 <paramref name="body" />.Type representa um tipo que não é atribuível ao tipo de retorno do tipo de delegado representado por <paramref name="delegateType" />.  
  
- ou - 
 <paramref name="parameters" /> não contém o mesmo número de elementos da lista de parâmetros para o tipo de delegado representado por <paramref name="delegateType" />.  
  
- ou - 
A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="parameters" /> não é atribuível do tipo de parâmetro correspondente do tipo de delegado representado por <paramref name="delegateType" />.</exception>
      <returns>Um objeto que representa uma expressão lambda que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Cria um <see cref="T:System.Linq.Expressions.LambdaExpression" /> em que o tipo delegado é conhecido no tempo de compilação, com o nome do lambda, um parâmetro que indica se a otimização da parte final da chamada será aplicada e uma coleção enumerável de expressões de parâmetro.</summary>
      <param name="delegateType">Um <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa a assinatura de delegado para o lambda.</param>
      <param name="body">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
      <param name="name">O nome para o lambda. Usada para emitir informações de depuração.</param>
      <param name="tailCall">Um <see cref="T:System.Boolean" /> que indica se a otimização de chamada final será aplicada ao compilar a expressão criada.</param>
      <param name="parameters">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a Lambda e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Cria um <see cref="T:System.Linq.Expressions.LambdaExpression" /> em que o tipo delegado é conhecido no tempo de compilação, com o nome do lambda e uma coleção enumerável de expressões de parâmetro.</summary>
      <param name="delegateType">Um <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa a assinatura de delegado para o lambda.</param>
      <param name="body">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
      <param name="name">O nome para o lambda. Usada para emitir informações de depuração.</param>
      <param name="parameters">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a Lambda e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Cria um <see cref="T:System.Linq.Expressions.Expression`1" /> em que o tipo delegado é conhecido no tempo de compilação, com um parâmetro que indica se a otimização da parte final da chamada será aplicada e uma coleção enumerável de expressões de parâmetro.</summary>
      <param name="body">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
      <param name="tailCall">Um <see cref="T:System.Boolean" /> que indica se a otimização de chamada final será aplicada ao compilar a expressão criada.</param>
      <param name="parameters">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">O tipo de delegado.</typeparam>
      <returns>Um <see cref="T:System.Linq.Expressions.Expression`1" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary>Cria um <see cref="T:System.Linq.Expressions.Expression`1" /> em que o tipo delegado é conhecido no tempo de compilação, com um parâmetro que indica se a otimização da parte final da chamada será aplicada e uma matriz de expressões de parâmetro.</summary>
      <param name="body">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
      <param name="tailCall">Um <see cref="T:System.Boolean" /> que indica se a otimização de chamada final será aplicada ao compilar a expressão criada.</param>
      <param name="parameters">Uma matriz que contém os objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para popular a coleção <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">O tipo de delegado.</typeparam>
      <returns>Um <see cref="T:System.Linq.Expressions.Expression`1" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Cria um <see cref="T:System.Linq.Expressions.Expression`1" /> em que o tipo delegado é conhecido no tempo de compilação, com uma coleção enumerável de expressões de parâmetro.</summary>
      <param name="body">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
      <param name="parameters">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Um tipo de delegado.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="body" /> é <see langword="null" />.  
  
- ou - 
Um ou mais elementos em <paramref name="parameters" /> são <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="TDelegate" /> não é um tipo de delegado.  
  
- ou - 
 <paramref name="body" />.Type representa um tipo que não pode ser atribuído ao tipo de retorno de <paramref name="TDelegate" />.  
  
- ou - 
 <paramref name="parameters" /> não contém o mesmo número de elementos que a lista de parâmetros de <paramref name="TDelegate" />.  
  
- ou - 
A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="parameters" /> não pode ser atribuída do tipo de parâmetro correspondente de <paramref name="TDelegate" />.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.Expression`1" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary>Cria um <see cref="T:System.Linq.Expressions.Expression`1" /> em que o tipo delegado é conhecido no tempo de compilação, com uma matriz de expressões de parâmetro.</summary>
      <param name="body">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
      <param name="parameters">Uma matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Um tipo de delegado.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="body" /> é <see langword="null" />.  
  
- ou - 
Um ou mais elementos em <paramref name="parameters" /> são <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="TDelegate" /> não é um tipo de delegado.  
  
- ou - 
 <paramref name="body" />.Type representa um tipo que não pode ser atribuído ao tipo de retorno de <paramref name="TDelegate" />.  
  
- ou - 
 <paramref name="parameters" /> não contém o mesmo número de elementos que a lista de parâmetros de <paramref name="TDelegate" />.  
  
- ou - 
A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="parameters" /> não pode ser atribuída do tipo de parâmetro correspondente de <paramref name="TDelegate" />.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.Expression`1" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Cria um <see cref="T:System.Linq.Expressions.Expression`1" /> em que o tipo delegado é conhecido no tempo de compilação, com o nome do lambda, um parâmetro que indica se a otimização da parte final da chamada será aplicada e uma coleção enumerável de expressões de parâmetro.</summary>
      <param name="body">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
      <param name="name">O nome do lambda. Usado para gerar informações de depuração.</param>
      <param name="tailCall">Um <see cref="T:System.Boolean" /> que indica se a otimização de chamada final será aplicada ao compilar a expressão criada.</param>
      <param name="parameters">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">O tipo de delegado.</typeparam>
      <returns>Um <see cref="T:System.Linq.Expressions.Expression`1" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Cria um <see cref="T:System.Linq.Expressions.Expression`1" /> em que o tipo delegado é conhecido no tempo de compilação, com o nome do lambda e uma coleção enumerável de expressões de parâmetro.</summary>
      <param name="body">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
      <param name="name">O nome do lambda. Usado para gerar informações de depuração.</param>
      <param name="parameters">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">O tipo de delegado.</typeparam>
      <returns>Um <see cref="T:System.Linq.Expressions.Expression`1" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de deslocamento à esquerda bit a bit.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O operador de deslocamento à esquerda não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de deslocamento à esquerda bit a bit.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> é <see langword="null" /> e o operador de deslocamento à esquerda não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de deslocamento à esquerda bit a bit.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de deslocamento à esquerda bit a bit.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de deslocamento à esquerda bit a bit.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <param name="conversion">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação numérica "menor que".</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O operador “menor que” não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação numérica "menor que".</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="liftToNull">
        <see langword="true" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="true" />; <see langword="false" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="false" />.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> é <see langword="null" /> e o operador "menor que" não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação numérica "menor ou igual a".</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O operador "menor ou igual a" não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação numérica "menor ou igual a".</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="liftToNull">
        <see langword="true" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="true" />; <see langword="false" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="false" />.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> é <see langword="null" /> e o operador "menor ou igual a" não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Cria um <see cref="T:System.Linq.Expressions.MemberListBinding" /> em que o membro é um campo ou propriedade.</summary>
      <param name="member">Um <see cref="T:System.Reflection.MemberInfo" /> que representa um campo ou propriedade igual à qual definir a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="initializers">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ElementInit" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> é <see langword="null" />.  
  
- ou - 
Um ou mais elementos de <paramref name="initializers" /> são <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> não representa um campo ou propriedade.  
  
- ou - 
O <see cref="P:System.Reflection.FieldInfo.FieldType" /> ou <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> do campo ou propriedade representada por <paramref name="member" /> não implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.MemberListBinding" /> que tem a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> igual a <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> e as propriedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> e <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Linq.Expressions.ElementInit[])">
      <summary>Cria um <see cref="T:System.Linq.Expressions.MemberListBinding" /> em que o membro é um campo ou propriedade.</summary>
      <param name="member">Um <see cref="T:System.Reflection.MemberInfo" /> que representa um campo ou propriedade igual à qual definir a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="initializers">Uma matriz de objetos <see cref="T:System.Linq.Expressions.ElementInit" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> é <see langword="null" />.  
  
- ou - 
Um ou mais elementos de <paramref name="initializers" /> são <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> não representa um campo ou propriedade.  
  
- ou - 
O <see cref="P:System.Reflection.FieldInfo.FieldType" /> ou <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> do campo ou propriedade representada por <paramref name="member" /> não implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.MemberListBinding" /> que tem a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> igual a <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> e as propriedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> e <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Cria um <see cref="T:System.Linq.Expressions.MemberListBinding" /> com base em um método de acessador de propriedade especificado.</summary>
      <param name="propertyAccessor">Um <see cref="T:System.Reflection.MethodInfo" /> que representa um método de acessador de propriedade.</param>
      <param name="initializers">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ElementInit" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> é <see langword="null" />.  
  
- ou - 
Um ou mais elementos de <paramref name="initializers" /> são <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> não representa um método de acessador de propriedade.  
  
- ou - 
O <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> da propriedade acessada pelo método representado por <paramref name="propertyAccessor" /> não implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.MemberListBinding" /> que tem a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> igual a <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> definida para o <see cref="T:System.Reflection.MemberInfo" /> que representa a propriedade acessada em <paramref name="propertyAccessor" /> e <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> populada com os elementos de <paramref name="initializers" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Linq.Expressions.ElementInit[])">
      <summary>Cria um objeto <see cref="T:System.Linq.Expressions.MemberListBinding" /> com base em um método de acessador de propriedade especificado.</summary>
      <param name="propertyAccessor">Um <see cref="T:System.Reflection.MethodInfo" /> que representa um método de acessador de propriedade.</param>
      <param name="initializers">Uma matriz de objetos <see cref="T:System.Linq.Expressions.ElementInit" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> é <see langword="null" />.  
  
- ou - 
Um ou mais elementos de <paramref name="initializers" /> são <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> não representa um método de acessador de propriedade.  
  
- ou - 
O <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> da propriedade acessada pelo método representado por <paramref name="propertyAccessor" /> não implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.MemberListBinding" /> que tem a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> igual a <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> definida para o <see cref="T:System.Reflection.MemberInfo" /> que representa a propriedade acessada em <paramref name="propertyAccessor" /> e <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> populada com os elementos de <paramref name="initializers" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Cria um <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa objetos <see cref="T:System.Linq.Expressions.ElementInit" /> especificados para inicializar uma coleção.</summary>
      <param name="newExpression">Um <see cref="T:System.Linq.Expressions.NewExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> igual a ele.</param>
      <param name="initializers">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ElementInit" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> ou <paramref name="initializers" /> é <see langword="null" />.  
  
- ou - 
Um ou mais elementos de <paramref name="initializers" /> são <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type não implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.ListInitExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e as propriedades <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> e <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Cria um <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa um método chamado "Add" para adicionar elementos a uma coleção.</summary>
      <param name="newExpression">Um <see cref="T:System.Linq.Expressions.NewExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> igual a ele.</param>
      <param name="initializers">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> ou <paramref name="initializers" /> é <see langword="null" />.  
  
- ou - 
Um ou mais elementos de <paramref name="initializers" /> são <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type não implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
      <exception cref="T:System.InvalidOperationException">Não há nenhum método de instância nomeado "Add" (não diferencia maiúsculas de minúsculas) declarado em <paramref name="newExpression" />.Type ou no tipo base dele.  
  
- ou - 
O método add no <paramref name="newExpression" />.Type ou no tipo base dele não aceita exatamente um argumento.  
  
- ou - 
O tipo representado pela propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> do primeiro elemento de <paramref name="initializers" /> não é atribuível ao tipo de argumento do método add em <paramref name="newExpression" />.Type ou no tipo base dele.  
  
- ou - 
Existe mais de um método compatível com o argumento nomeado "Add" (não diferencia maiúsculas de minúsculas) em <paramref name="newExpression" />.Type e/ou o tipo base dele.</exception>
      <returns>Uma <see cref="T:System.Linq.Expressions.ListInitExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e a propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> definida para o valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.ElementInit[])">
      <summary>Cria um <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa objetos <see cref="T:System.Linq.Expressions.ElementInit" /> especificados para inicializar uma coleção.</summary>
      <param name="newExpression">Um <see cref="T:System.Linq.Expressions.NewExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> igual a ele.</param>
      <param name="initializers">Uma matriz de objetos <see cref="T:System.Linq.Expressions.ElementInit" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> ou <paramref name="initializers" /> é <see langword="null" />.  
  
- ou - 
Um ou mais elementos de <paramref name="initializers" /> são <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type não implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.ListInitExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e as propriedades <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> e <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.Expression[])">
      <summary>Cria um <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa um método chamado "Add" para adicionar elementos a uma coleção.</summary>
      <param name="newExpression">Um <see cref="T:System.Linq.Expressions.NewExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> igual a ele.</param>
      <param name="initializers">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> ou <paramref name="initializers" /> é <see langword="null" />.  
  
- ou - 
Um ou mais elementos de <paramref name="initializers" /> são <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type não implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
      <exception cref="T:System.InvalidOperationException">Não há nenhum método de instância nomeado "Add" (não diferencia maiúsculas de minúsculas) declarado em <paramref name="newExpression" />.Type ou no tipo base dele.  
  
- ou - 
O método add no <paramref name="newExpression" />.Type ou no tipo base dele não aceita exatamente um argumento.  
  
- ou - 
O tipo representado pela propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> do primeiro elemento de <paramref name="initializers" /> não é atribuível ao tipo de argumento do método add em <paramref name="newExpression" />.Type ou no tipo base dele.  
  
- ou - 
Existe mais de um método compatível com o argumento nomeado "Add" (não diferencia maiúsculas de minúsculas) em <paramref name="newExpression" />.Type e/ou o tipo base dele.</exception>
      <returns>Uma <see cref="T:System.Linq.Expressions.ListInitExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e a propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> definida para o valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Cria um <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa um método especificado para adicionar elementos a uma coleção.</summary>
      <param name="newExpression">Um <see cref="T:System.Linq.Expressions.NewExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> igual a ele.</param>
      <param name="addMethod">Um <see cref="T:System.Reflection.MethodInfo" /> que representa um método de instância nomeado "Add" (não diferencia maiúsculas de minúsculas), que adiciona um elemento a uma coleção.</param>
      <param name="initializers">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> ou <paramref name="initializers" /> é <see langword="null" />.  
  
- ou - 
Um ou mais elementos de <paramref name="initializers" /> são <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type não implementa <see cref="T:System.Collections.IEnumerable" />.  
  
- ou - 
 <paramref name="addMethod" /> não é <see langword="null" /> e não representa um método de instância nomeado "Add" (não diferencia maiúsculas de minúsculas) que aceita exatamente um argumento.  
  
- ou - 
 <paramref name="addMethod" /> não é <see langword="null" /> e o tipo representado pela propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um ou mais elementos de <paramref name="initializers" /> não pode ser atribuída ao tipo de argumento do método representado por <paramref name="addMethod" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="addMethod" /> é <see langword="null" /> e nenhum método de instância nomeado "Add" que aceita um argumento de tipo compatível existe no <paramref name="newExpression" />.Type ou no tipo base dele.</exception>
      <returns>Uma <see cref="T:System.Linq.Expressions.ListInitExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e a propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> definida para o valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Cria um <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa um método especificado para adicionar elementos a uma coleção.</summary>
      <param name="newExpression">Um <see cref="T:System.Linq.Expressions.NewExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> igual a ele.</param>
      <param name="addMethod">Um <see cref="T:System.Reflection.MethodInfo" /> que representa um método de instância que aceita um argumento, que adiciona um elemento a uma coleção.</param>
      <param name="initializers">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> ou <paramref name="initializers" /> é <see langword="null" />.  
  
- ou - 
Um ou mais elementos de <paramref name="initializers" /> são <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type não implementa <see cref="T:System.Collections.IEnumerable" />.  
  
- ou - 
 <paramref name="addMethod" /> não é <see langword="null" /> e não representa um método de instância nomeado "Add" (não diferencia maiúsculas de minúsculas) que aceita exatamente um argumento.  
  
- ou - 
 <paramref name="addMethod" /> não é <see langword="null" /> e o tipo representado pela propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um ou mais elementos de <paramref name="initializers" /> não pode ser atribuída ao tipo de argumento do método representado por <paramref name="addMethod" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="addMethod" /> é <see langword="null" /> e nenhum método de instância nomeado "Add" que aceita um argumento de tipo compatível existe no <paramref name="newExpression" />.Type ou no tipo base dele.</exception>
      <returns>Uma <see cref="T:System.Linq.Expressions.ListInitExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e a propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> definida para o valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.LoopExpression" /> com o corpo fornecido.</summary>
      <param name="body">O corpo do loop.</param>
      <returns>O <see cref="T:System.Linq.Expressions.LoopExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.LoopExpression" /> com o destino corpo e interrupção determinado.</summary>
      <param name="body">O corpo do loop.</param>
      <param name="break">O destino de interrupção usado pelo corpo do loop.</param>
      <returns>O <see cref="T:System.Linq.Expressions.LoopExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.LoopExpression" /> com o corpo fornecido.</summary>
      <param name="body">O corpo do loop.</param>
      <param name="break">O destino de interrupção usado pelo corpo do loop.</param>
      <param name="continue">O destino continue usado pelo corpo do loop.</param>
      <returns>O <see cref="T:System.Linq.Expressions.LoopExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" />, considerando os operandos esquerdos e direito, chamando um método de fábrica apropriado.</summary>
      <param name="binaryType">O <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica o tipo de operação binária.</param>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o operando esquerdo.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o operando direito.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> não corresponde a um nó de expressão binária.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <returns>O <see cref="T:System.Linq.Expressions.BinaryExpression" /> que resulta de chamar o método de fábrica apropriado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" />, dado o operando esquerdo, o operando direito e o método de implementação, chamando o método de fábrica apropriado.</summary>
      <param name="binaryType">O <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica o tipo de operação binária.</param>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o operando esquerdo.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o operando direito.</param>
      <param name="liftToNull">
        <see langword="true" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="true" />; <see langword="false" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="false" />.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> que especifica o método de implementação.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> não corresponde a um nó de expressão binária.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <returns>O <see cref="T:System.Linq.Expressions.BinaryExpression" /> que resulta de chamar o método de fábrica apropriado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" />, dado o operando esquerdo, o operando direito, o método de implementação e a função de conversão de tipo, chamando o método de fábrica apropriado.</summary>
      <param name="binaryType">O <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica o tipo de operação binária.</param>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o operando esquerdo.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o operando direito.</param>
      <param name="liftToNull">
        <see langword="true" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="true" />; <see langword="false" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="false" />.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> que especifica o método de implementação.</param>
      <param name="conversion">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que representa uma função de conversão de tipo. Esse parâmetro é usado somente se <paramref name="binaryType" /> é <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> ou uma atribuição composta.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> não corresponde a um nó de expressão binária.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <returns>O <see cref="T:System.Linq.Expressions.BinaryExpression" /> que resulta de chamar o método de fábrica apropriado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeCatchBlock(System.Type,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa uma instrução catch com os elementos especificados.</summary>
      <param name="type">O <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que esse <see cref="T:System.Linq.Expressions.CatchBlock" /> tratará.</param>
      <param name="variable">Uma <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representa uma referência para o objeto <see cref="T:System.Exception" /> capturado por este manipulador.</param>
      <param name="body">O corpo da instrução catch.</param>
      <param name="filter">O corpo do filtro <see cref="T:System.Exception" />.</param>
      <returns>O <see cref="T:System.Linq.Expressions.CatchBlock" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido.</summary>
      <param name="delegateType">O tipo do delegado usado pelo <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">O associador de runtime para a operação dinâmica.</param>
      <param name="arguments">Os argumentos para a operação dinâmica.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidas para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido e um argumento.</summary>
      <param name="delegateType">O tipo do delegado usado pelo <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">O associador de runtime para a operação dinâmica.</param>
      <param name="arg0">O argumento para a operação dinâmica.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidas para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido e dois argumentos.</summary>
      <param name="delegateType">O tipo do delegado usado pelo <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">O associador de runtime para a operação dinâmica.</param>
      <param name="arg0">O primeiro argumento para a operação dinâmica.</param>
      <param name="arg1">O segundo argumento para a operação dinâmica.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidas para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido e três argumentos.</summary>
      <param name="delegateType">O tipo do delegado usado pelo <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">O associador de runtime para a operação dinâmica.</param>
      <param name="arg0">O primeiro argumento para a operação dinâmica.</param>
      <param name="arg1">O segundo argumento para a operação dinâmica.</param>
      <param name="arg2">O terceiro argumento para a operação dinâmica.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidas para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido e quatro argumentos.</summary>
      <param name="delegateType">O tipo do delegado usado pelo <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">O associador de runtime para a operação dinâmica.</param>
      <param name="arg0">O primeiro argumento para a operação dinâmica.</param>
      <param name="arg1">O segundo argumento para a operação dinâmica.</param>
      <param name="arg2">O terceiro argumento para a operação dinâmica.</param>
      <param name="arg3">O quarto argumento para a operação dinâmica.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidas para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression[])">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido.</summary>
      <param name="delegateType">O tipo do delegado usado pelo <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">O associador de runtime para a operação dinâmica.</param>
      <param name="arguments">Os argumentos para a operação dinâmica.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidas para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeGoto(System.Linq.Expressions.GotoExpressionKind,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa um link do <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> especificado. O valor passado para o rótulo ao saltar também pode ser especificado.</summary>
      <param name="kind">O <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> do <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="target">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</param>
      <param name="value">O valor que será passado para o rótulo associado ao saltar.</param>
      <param name="type">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a <paramref name="kind" />, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para <paramref name="target" />, a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> definida para <paramref name="type" /> e <paramref name="value" /> a ser passado para o rótulo de destino ao saltar.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeIndex(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Cria um <see cref="T:System.Linq.Expressions.IndexExpression" /> que representa o acesso a uma propriedade indexada em um objeto.</summary>
      <param name="instance">O objeto ao qual a propriedade pertence. Deve ser nulo se a propriedade for <see langword="static" /> (<see langword="shared" /> no Visual Basic).</param>
      <param name="indexer">Um <see cref="T:System.Linq.Expressions.Expression" /> representando a propriedade a indexar.</param>
      <param name="arguments">Um <c>IEnumerable&lt;Expression&gt;</c> (<c>IEnumerable (Of Expression)</c> no Visual Basic) que contém os argumentos que serão usados para indexar a propriedade.</param>
      <returns>O <see cref="T:System.Linq.Expressions.IndexExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeMemberAccess(System.Linq.Expressions.Expression,System.Reflection.MemberInfo)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa o acesso a um campo ou uma propriedade.</summary>
      <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o objeto ao qual o membro pertence. Isso pode ser nulo para membros estáticos.</param>
      <param name="member">O <see cref="T:System.Reflection.MemberInfo" /> que descreve a propriedade ou o campo a ser acessado.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> não representa um campo ou propriedade.</exception>
      <returns>O <see cref="T:System.Linq.Expressions.MemberExpression" /> que resulta de chamar o método de fábrica apropriado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeTry(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock})">
      <summary>Cria um <see cref="T:System.Linq.Expressions.TryExpression" /> que representa um bloco try com os elementos especificados.</summary>
      <param name="type">O tipo de resultado da expressão try. Se for null, o corpo e todos os manipuladores devem ter tipo idêntico.</param>
      <param name="body">O corpo do bloco try.</param>
      <param name="finally">O corpo do bloco finally. Passe null se o bloco try não tem bloco finally associado a ele.</param>
      <param name="fault">O corpo do bloco de falha. Passe null se o bloco try não tem bloco fault associado a ele.</param>
      <param name="handlers">Uma coleção de <see cref="T:System.Linq.Expressions.CatchBlock" />s representando as instruções catch a serem associados com o bloco try.</param>
      <returns>O <see cref="T:System.Linq.Expressions.TryExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type)">
      <summary>Dado um determinado operando, cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> chamando o método de fábrica apropriado.</summary>
      <param name="unaryType">O <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica o tipo de operação unária.</param>
      <param name="operand">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o operando.</param>
      <param name="type">O <see cref="T:System.Type" /> que especifica o tipo no qual converter (passe <see langword="null" /> se não for aplicável).</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="operand" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="unaryType" /> não corresponde a um nó de expressão unária.</exception>
      <returns>O <see cref="T:System.Linq.Expressions.UnaryExpression" /> que resulta de chamar o método de fábrica apropriado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" />, dado um operando e um método de implementação, chamando o método de fábrica apropriado.</summary>
      <param name="unaryType">O <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica o tipo de operação unária.</param>
      <param name="operand">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o operando.</param>
      <param name="type">O <see cref="T:System.Type" /> que especifica o tipo no qual converter (passe <see langword="null" /> se não for aplicável).</param>
      <param name="method">O <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="operand" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="unaryType" /> não corresponde a um nó de expressão unária.</exception>
      <returns>O <see cref="T:System.Linq.Expressions.UnaryExpression" /> que resulta de chamar o método de fábrica apropriado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Cria um <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa a inicialização recursiva de membros de um campo ou propriedade.</summary>
      <param name="member">O <see cref="T:System.Reflection.MemberInfo" /> com um valor igual ao qual a <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> propriedade será definida.</param>
      <param name="bindings">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> ou <paramref name="bindings" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> não representa um campo ou propriedade.  
  
- ou - 
A propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> de um elemento de <paramref name="bindings" /> não representa um membro do tipo do campo ou propriedade representada por <paramref name="member" />.Type.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que tem a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> igual a <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> e as propriedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> e <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Linq.Expressions.MemberBinding[])">
      <summary>Cria um <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa a inicialização recursiva de membros de um campo ou propriedade.</summary>
      <param name="member">O <see cref="T:System.Reflection.MemberInfo" /> com um valor igual ao qual a <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> propriedade será definida.</param>
      <param name="bindings">Uma matriz de objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> ou <paramref name="bindings" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> não representa um campo ou propriedade.  
  
- ou - 
A propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> de um elemento de <paramref name="bindings" /> não representa um membro do tipo do campo ou propriedade representada por <paramref name="member" />.Type.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que tem a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> igual a <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> e as propriedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> e <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Cria um <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa a inicialização recursiva de membros de um membro que é acessado usando um método de acessador de propriedade.</summary>
      <param name="propertyAccessor">O <see cref="T:System.Reflection.MethodInfo" /> que representa um método de acessador de propriedade.</param>
      <param name="bindings">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> ou <paramref name="bindings" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> não representa um método de acessador de propriedade.  
  
- ou - 
A propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> de um elemento de <paramref name="bindings" /> não representa um membro do tipo da propriedade acessada pelo método representado por <paramref name="propertyAccessor" />.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que tem a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> igual a <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> definida para o <see cref="T:System.Reflection.PropertyInfo" /> que representa a propriedade acessada em <paramref name="propertyAccessor" /> e propriedades <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> definidas para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Linq.Expressions.MemberBinding[])">
      <summary>Cria um <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa a inicialização recursiva de membros de um membro que é acessado usando um método de acessador de propriedade.</summary>
      <param name="propertyAccessor">O <see cref="T:System.Reflection.MethodInfo" /> que representa um método de acessador de propriedade.</param>
      <param name="bindings">Uma matriz de objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> ou <paramref name="bindings" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> não representa um método de acessador de propriedade.  
  
- ou - 
A propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> de um elemento de <paramref name="bindings" /> não representa um membro do tipo da propriedade acessada pelo método representado por <paramref name="propertyAccessor" />.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que tem a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> igual a <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> definida para o <see cref="T:System.Reflection.PropertyInfo" /> que representa a propriedade acessada em <paramref name="propertyAccessor" /> e propriedades <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> definidas para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Representa uma expressão que cria um novo objeto e inicializa uma propriedade do objeto.</summary>
      <param name="newExpression">Um <see cref="T:System.Linq.Expressions.NewExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> igual a ele.</param>
      <param name="bindings">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> ou <paramref name="bindings" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">A propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> de um elemento de <paramref name="bindings" /> não representa um membro do tipo representado por <paramref name="newExpression" />.Type.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.MemberInitExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> e as propriedades <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> e <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.MemberBinding[])">
      <summary>Cria um <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
      <param name="newExpression">Um <see cref="T:System.Linq.Expressions.NewExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> igual a ele.</param>
      <param name="bindings">Uma matriz de objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> ou <paramref name="bindings" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">A propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> de um elemento de <paramref name="bindings" /> não representa um membro do tipo representado por <paramref name="newExpression" />.Type.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.MemberInitExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> e as propriedades <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> e <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação restante aritmética.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O operador modulus não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação restante aritmética.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> é <see langword="null" /> e operador de módulo não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição pendente.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição pendente.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição pendente.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <param name="conversion">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de multiplicação que não tem verificação de estouro.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O operador de multiplicação não está definido como <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de multiplicação que não tem verificação de estouro.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> é <see langword="null" /> e o operador de multiplicação não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de multiplicação que não tem verificação de estouro.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de multiplicação que não tem verificação de estouro.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de multiplicação que não tem verificação de estouro.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <param name="conversion">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de multiplicação que tem verificação de estouro.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de multiplicação que tem verificação de estouro.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de multiplicação que tem verificação de estouro.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <param name="conversion">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de multiplicação que tem verificação de estouro.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O operador de multiplicação não está definido como <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de multiplicação que tem verificação de estouro.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> é <see langword="null" /> e o operador de multiplicação não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação aritmética de negação.</summary>
      <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O operador de menos unário não está definido para <paramref name="expression" />.Type.</exception>
      <returns>Uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> e a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> definida para o valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação aritmética de negação.</summary>
      <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente um argumento.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> é <see langword="null" /> e o operador unário de menos não foi definido para <paramref name="expression" />.Type.  
  
- ou - 
 <paramref name="expression" />.Type (ou o respectivo tipo que não permite valor nulo correspondente se ele é um tipo que permite valor nulo) não é atribuível ao tipo de argumento do método representado por <paramref name="method" />.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> e as propriedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação aritmética de negação de adição que tem verificação de estouro.</summary>
      <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O operador de menos unário não está definido para <paramref name="expression" />.Type.</exception>
      <returns>Uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> e a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> definida para o valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação aritmética de negação de adição que tem verificação de estouro. O método de implementação pode ser especificado.</summary>
      <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente um argumento.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> é <see langword="null" /> e o operador unário de menos não foi definido para <paramref name="expression" />.Type.  
  
- ou - 
 <paramref name="expression" />.Type (ou o respectivo tipo que não permite valor nulo correspondente se ele é um tipo que permite valor nulo) não é atribuível ao tipo de argumento do método representado por <paramref name="method" />.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.NewExpression" /> que representa uma chamada ao construtor especificado que não aceita nenhum argumento.</summary>
      <param name="constructor">O <see cref="T:System.Reflection.ConstructorInfo" /> com um valor igual ao qual a <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> propriedade será definida.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">O construtor representado por <paramref name="constructor" /> tem pelo menos um parâmetro.</exception>
      <returns>Uma <see cref="T:System.Linq.Expressions.NewExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e a propriedade <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> definida para o valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Cria um <see cref="T:System.Linq.Expressions.NewExpression" /> que representa uma chamada ao construtor especificado com os argumentos especificados.</summary>
      <param name="constructor">O <see cref="T:System.Reflection.ConstructorInfo" /> com um valor igual ao qual a <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> propriedade será definida.</param>
      <param name="arguments">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> é <see langword="null" />.  
  
- ou - 
Um elemento de <paramref name="arguments" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">O parâmetro <paramref name="arguments" /> não contém o mesmo número de elementos que o número de parâmetros do construtor representado por <paramref name="constructor" />.  
  
- ou - 
A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="arguments" /> não pode ser atribuída ao tipo do parâmetro correspondente do construtor representado por <paramref name="constructor" />.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.NewExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e as propriedades <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> e <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo})">
      <summary>Cria um <see cref="T:System.Linq.Expressions.NewExpression" /> que representa uma chamada ao construtor especificado com os argumentos especificados. Os membros que acessam os campos inicializados pelo construtor são especificados.</summary>
      <param name="constructor">O <see cref="T:System.Reflection.ConstructorInfo" /> com um valor igual ao qual a <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> propriedade será definida.</param>
      <param name="arguments">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <param name="members">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Reflection.MemberInfo" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.NewExpression.Members" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> é <see langword="null" />.  
  
- ou - 
Um elemento de <paramref name="arguments" /> é <see langword="null" />.  
  
- ou - 
Um elemento de <paramref name="members" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">O parâmetro <paramref name="arguments" /> não contém o mesmo número de elementos que o número de parâmetros do construtor representado por <paramref name="constructor" />.  
  
- ou - 
A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="arguments" /> não pode ser atribuída ao tipo do parâmetro correspondente do construtor representado por <paramref name="constructor" />.  
  
- ou - 
O parâmetro <paramref name="members" /> não tem o mesmo número de elementos de <paramref name="arguments" />.  
  
- ou - 
Um elemento de <paramref name="arguments" /> tem uma propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa um tipo que não é atribuível ao tipo do membro que é representado pelo elemento correspondente de <paramref name="members" />.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.NewExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e as propriedades <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> e <see cref="P:System.Linq.Expressions.NewExpression.Members" /> definidas para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Reflection.MemberInfo[])">
      <summary>Cria um <see cref="T:System.Linq.Expressions.NewExpression" /> que representa uma chamada ao construtor especificado com os argumentos especificados. Os membros que acessam os campos inicializados pelo construtor são especificados como uma matriz.</summary>
      <param name="constructor">O <see cref="T:System.Reflection.ConstructorInfo" /> com um valor igual ao qual a <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> propriedade será definida.</param>
      <param name="arguments">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <param name="members">Uma matriz de objetos <see cref="T:System.Reflection.MemberInfo" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.NewExpression.Members" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> é <see langword="null" />.  
  
- ou - 
Um elemento de <paramref name="arguments" /> é <see langword="null" />.  
  
- ou - 
Um elemento de <paramref name="members" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">O parâmetro <paramref name="arguments" /> não contém o mesmo número de elementos que o número de parâmetros do construtor representado por <paramref name="constructor" />.  
  
- ou - 
A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="arguments" /> não pode ser atribuída ao tipo do parâmetro correspondente do construtor representado por <paramref name="constructor" />.  
  
- ou - 
O parâmetro <paramref name="members" /> não tem o mesmo número de elementos de <paramref name="arguments" />.  
  
- ou - 
Um elemento de <paramref name="arguments" /> tem uma propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa um tipo que não é atribuível ao tipo do membro que é representado pelo elemento correspondente de <paramref name="members" />.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.NewExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e as propriedades <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> e <see cref="P:System.Linq.Expressions.NewExpression.Members" /> definidas para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Linq.Expressions.Expression[])">
      <summary>Cria um <see cref="T:System.Linq.Expressions.NewExpression" /> que representa uma chamada ao construtor especificado com os argumentos especificados.</summary>
      <param name="constructor">O <see cref="T:System.Reflection.ConstructorInfo" /> com um valor igual ao qual a <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> propriedade será definida.</param>
      <param name="arguments">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> é <see langword="null" />.  
  
- ou - 
Um elemento de <paramref name="arguments" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">O tamanho de <paramref name="arguments" /> corresponde ao número de parâmetros do construtor representado por <paramref name="constructor" />.  
  
- ou - 
A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="arguments" /> não pode ser atribuída ao tipo do parâmetro correspondente do construtor representado por <paramref name="constructor" />.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.NewExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e as propriedades <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> e <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Type)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.NewExpression" /> que representa uma chamada para o construtor sem parâmetro do tipo especificado.</summary>
      <param name="type">Um <see cref="T:System.Type" /> contém um construtor que não aceita argumentos.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">O tipo que <paramref name="type" /> representa não tem um construtor sem parâmetros.</exception>
      <returns>A <see cref="T:System.Linq.Expressions.NewExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e a propriedade <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> definida como o <see cref="T:System.Reflection.ConstructorInfo" /> que representa o construtor sem parâmetros para o tipo especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa a criação de uma matriz que tem uma classificação especificada.</summary>
      <param name="type">Um <see cref="T:System.Type" /> que representa o tipo de elemento da matriz.</param>
      <param name="bounds">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> ou <paramref name="bounds" /> é <see langword="null" />.  
  
- ou - 
Um elemento de <paramref name="bounds" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="bounds" /> não representa um tipo integral.</exception>
      <returns>Uma <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> e a propriedade <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> definida para o valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Linq.Expressions.Expression[])">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa a criação de uma matriz que tem uma classificação especificada.</summary>
      <param name="type">Um <see cref="T:System.Type" /> que representa o tipo de elemento da matriz.</param>
      <param name="bounds">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> ou <paramref name="bounds" /> é <see langword="null" />.  
  
- ou - 
Um elemento de <paramref name="bounds" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="bounds" /> não representa um tipo integral.</exception>
      <returns>Uma <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> e a propriedade <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> definida para o valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Cria um <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa a criação de uma matriz unidimensional e a inicialização dela de uma lista de elementos.</summary>
      <param name="type">Um <see cref="T:System.Type" /> que representa o tipo de elemento da matriz.</param>
      <param name="initializers">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> ou <paramref name="initializers" /> é <see langword="null" />.  
  
- ou - 
Um elemento de <paramref name="initializers" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento <paramref name="initializers" /> representa um tipo que não é atribuível ao tipo representado por <paramref name="type" />.</exception>
      <returns>Uma <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> e a propriedade <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> definida para o valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Linq.Expressions.Expression[])">
      <summary>Cria um <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa a criação de uma matriz unidimensional e a inicialização dela de uma lista de elementos.</summary>
      <param name="type">Um <see cref="T:System.Type" /> que representa o tipo de elemento da matriz.</param>
      <param name="initializers">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> ou <paramref name="initializers" /> é <see langword="null" />.  
  
- ou - 
Um elemento de <paramref name="initializers" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="initializers" /> representa um tipo que não é atribuível ao tipo <paramref name="type" />.</exception>
      <returns>Uma <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> e a propriedade <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> definida para o valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação de complemento bit a bit.</summary>
      <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O não operador unário não é definido para <paramref name="expression" />.Type.</exception>
      <returns>Uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> e a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> definida para o valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação de complemento bit a bit. O método de implementação pode ser especificado.</summary>
      <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente um argumento.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> é <see langword="null" /> e o operador não unário não foi definido para <paramref name="expression" />.Type.  
  
- ou - 
 <paramref name="expression" />.Type (ou o respectivo tipo que não permite valor nulo correspondente se ele é um tipo que permite valor nulo) não é atribuível ao tipo de argumento do método representado por <paramref name="method" />.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> e as propriedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação de desigualdade.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O operador de desigualdade não está definido como <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação de desigualdade.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="liftToNull">
        <see langword="true" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="true" />; <see langword="false" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="false" />.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> é <see langword="null" /> e o operador de desigualdade não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression)">
      <summary>Retorna a expressão que representa o complemento de um.</summary>
      <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <returns>Uma instância de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Retorna a expressão que representa o complemento de um.</summary>
      <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</param>
      <returns>Uma instância de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="OR" /> bit a bit.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O operador <see langword="OR" /> bit a bit não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="OR" /> bit a bit.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> é <see langword="null" /> e o operador <see langword="OR" /> bit a bit não é definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição OR bit a bit.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição OR bit a bit.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição OR bit a bit.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <param name="conversion">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="OR" /> condicional que avalia o segundo operando somente se o primeiro operando é avaliado como <see langword="false" />.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O operador <see langword="OR" /> bit a bit não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.  
  
- ou - 
 <paramref name="left" />.Type e <paramref name="right" />.Type não são do mesmo tipo booliano.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="OR" /> condicional que avalia o segundo operando somente se o primeiro operando é avaliado como <see langword="false" />.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> é <see langword="null" /> e o operador <see langword="OR" /> bit a bit não é definido para <paramref name="left" />.Type e <paramref name="right" />.Type.  
  
- ou - 
 <paramref name="method" /> é <see langword="null" /> e Type.<paramref name="left" /> e Type.<paramref name="right" /> não são do mesmo tipo booliano.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Parameter(System.Type)">
      <summary>Cria um nó de <see cref="T:System.Linq.Expressions.ParameterExpression" /> que pode ser usado para identificar um parâmetro ou uma variável em uma árvore de expressão.</summary>
      <param name="type">O tipo do parâmetro ou da variável.</param>
      <returns>Um nó de <see cref="T:System.Linq.Expressions.ParameterExpression" /> com o nome e tipo especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Parameter(System.Type,System.String)">
      <summary>Cria um nó de <see cref="T:System.Linq.Expressions.ParameterExpression" /> que pode ser usado para identificar um parâmetro ou uma variável em uma árvore de expressão.</summary>
      <param name="type">O tipo do parâmetro ou da variável.</param>
      <param name="name">O nome do parâmetro ou variável, usado para fins de depuração ou impressão apenas.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> é <see langword="null" />.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.ParameterExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Parameter" /> e as propriedades <see cref="P:System.Linq.Expressions.Expression.Type" /> e <see cref="P:System.Linq.Expressions.ParameterExpression.Name" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a atribuição da expressão seguida de um decremento subsequente da expressão original em 1.</summary>
      <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> no qual aplicar as operações.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão resultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a atribuição da expressão seguida de um decremento subsequente da expressão original em 1.</summary>
      <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> no qual aplicar as operações.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão resultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a atribuição da expressão seguida de um incremento de 1 à expressão original.</summary>
      <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> no qual aplicar as operações.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão resultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a atribuição da expressão seguida de um incremento de 1 à expressão original.</summary>
      <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> no qual aplicar as operações.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão resultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa a elevação de um número a uma potência.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O operador de exponenciação não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.  
  
- ou - 
 <paramref name="left" />.Type e/ou <paramref name="right" />.Type não são <see cref="T:System.Double" />.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa a elevação de um número a uma potência.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> é <see langword="null" /> e o operador de exponenciação não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.  
  
- ou - 
 <paramref name="method" /> é <see langword="null" /> e <paramref name="left" />.Type e/ou <paramref name="right" />.Type não são <see cref="T:System.Double" />.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa elevar uma expressão a uma potência e atribuir o resultado de volta à expressão.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa elevar uma expressão a uma potência e atribuir o resultado de volta à expressão.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa elevar uma expressão a uma potência e atribuir o resultado de volta à expressão.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <param name="conversion">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que decrementa a expressão por 1 e atribui o resultado de volta à expressão.</summary>
      <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> no qual aplicar as operações.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão resultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que decrementa a expressão por 1 e atribui o resultado de volta à expressão.</summary>
      <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> no qual aplicar as operações.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão resultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que incrementa a expressão em 1 e atribui o resultado de volta à expressão.</summary>
      <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> no qual aplicar as operações.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão resultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que incrementa a expressão em 1 e atribui o resultado de volta à expressão.</summary>
      <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> no qual aplicar as operações.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão resultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa o acesso a uma propriedade usando um método de acessador de propriedade.</summary>
      <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> igual a ele. Pode ser nulo para propriedades estáticas.</param>
      <param name="propertyAccessor">O <see cref="T:System.Reflection.MethodInfo" /> que representa um método de acessador de propriedade.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> é <see langword="null" />.  
  
- ou - 
O método representado por <paramref name="propertyAccessor" /> não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) e <paramref name="expression" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />. O tipo não é atribuível ao tipo de declaração de método representada pelo <paramref name="propertyAccessor" />.  
  
- ou - 
O método representado por <paramref name="propertyAccessor" /> não é um método de acessador de propriedade.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.MemberExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> definida como <paramref name="expression" /> e a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> definida como o <see cref="T:System.Reflection.PropertyInfo" /> que representa a propriedade acessada em <paramref name="propertyAccessor" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa o acesso a uma propriedade.</summary>
      <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> igual a ele. Pode ser nulo para propriedades estáticas.</param>
      <param name="property">O <see cref="T:System.Reflection.PropertyInfo" /> com um valor igual ao qual a <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> propriedade será definida.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="property" /> é <see langword="null" />.  
  
- ou - 
A propriedade que o <paramref name="property" /> representa não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) e o <paramref name="expression" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type não é atribuível ao tipo de declaração da propriedade que o <paramref name="property" /> representa.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.MemberExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> e as propriedades <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> e <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Cria um <see cref="T:System.Linq.Expressions.IndexExpression" /> que representa o acesso a uma propriedade indexada.</summary>
      <param name="instance">O objeto ao qual a propriedade pertence. Se a propriedade for estática/compartilhada, ela deverá ser nula.</param>
      <param name="indexer">O <see cref="T:System.Reflection.PropertyInfo" /> que representa a propriedade de índice.</param>
      <param name="arguments">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> de objetos <see cref="T:System.Linq.Expressions.Expression" /> que são usados para indexar a propriedade.</param>
      <returns>O <see cref="T:System.Linq.Expressions.IndexExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Linq.Expressions.Expression[])">
      <summary>Cria um <see cref="T:System.Linq.Expressions.IndexExpression" /> que representa o acesso a uma propriedade indexada.</summary>
      <param name="instance">O objeto ao qual a propriedade pertence. Se a propriedade for estática/compartilhada, ela deverá ser nula.</param>
      <param name="indexer">O <see cref="T:System.Reflection.PropertyInfo" /> que representa a propriedade de índice.</param>
      <param name="arguments">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que são usados para a propriedade de índice.</param>
      <returns>O <see cref="T:System.Linq.Expressions.IndexExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa o acesso a uma propriedade.</summary>
      <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> cujo <see cref="P:System.Linq.Expressions.Expression.Type" /> contém uma propriedade chamada <paramref name="propertyName" />. Pode ser <see langword="null" /> para propriedades estáticas.</param>
      <param name="propertyName">O nome de uma propriedade a ser acessada.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="propertyName" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">Nenhuma propriedade nomeada <paramref name="propertyName" /> é definida no tipo <paramref name="expression" /> ou em seus tipos base.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.MemberExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> definida como <paramref name="expression" /> e a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> definida como o <see cref="T:System.Reflection.PropertyInfo" /> que representa a propriedade indicada por <paramref name="propertyName" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String,System.Linq.Expressions.Expression[])">
      <summary>Cria um <see cref="T:System.Linq.Expressions.IndexExpression" /> que representa o acesso a uma propriedade indexada.</summary>
      <param name="instance">O objeto ao qual a propriedade pertence. Se a propriedade for estática/compartilhada, ela deverá ser nula.</param>
      <param name="propertyName">o nome do indexador.</param>
      <param name="arguments">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que são usados para a propriedade de índice.</param>
      <returns>O <see cref="T:System.Linq.Expressions.IndexExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Type,System.String)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.MemberExpression" /> acessando uma propriedade.</summary>
      <param name="expression">O objeto recipiente da propriedade. Pode ser nulo para propriedades estáticas.</param>
      <param name="type">O <see cref="P:System.Linq.Expressions.Expression.Type" /> que contém a propriedade.</param>
      <param name="propertyName">A propriedade a ser acessada.</param>
      <returns>O <see cref="T:System.Linq.Expressions.MemberExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PropertyOrField(System.Linq.Expressions.Expression,System.String)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa o acesso a uma propriedade ou campo.</summary>
      <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> cujo <see cref="P:System.Linq.Expressions.Expression.Type" /> contém uma propriedade ou campo chamado <paramref name="propertyOrFieldName" />. Isso pode ser nulo para membros estáticos.</param>
      <param name="propertyOrFieldName">O nome de uma propriedade ou campo a ser acessado.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="propertyOrFieldName" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">Nenhuma propriedade nomeado <paramref name="propertyOrFieldName" /> é definido em <paramref name="expression" />.Type ou em seus tipos base.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.MemberExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> definida como <paramref name="expression" /> e a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> definida como o <see cref="T:System.Reflection.PropertyInfo" /> ou <see cref="T:System.Reflection.FieldInfo" /> que representa a propriedade indicada por <paramref name="propertyOrFieldName" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Quote(System.Linq.Expressions.Expression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma expressão que tem um valor constante do tipo <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> é <see langword="null" />.</exception>
      <returns>Uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> e a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> definida para o valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Reduce">
      <summary>Reduz esse nó a uma expressão mais simples. Se CanReduce retornar true, ele deverá retornar uma expressão válida. Esse método pode retornar outro nó que também precisa ser reduzido.</summary>
      <returns>A expressão reduzida.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReduceAndCheck">
      <summary>Reduz esse nó a uma expressão mais simples. Se CanReduce retornar true, ele deverá retornar uma expressão válida. Esse método pode retornar outro nó que também precisa ser reduzido.</summary>
      <returns>A expressão reduzida.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReduceExtensions">
      <summary>Reduz a expressão a um tipo de nó conhecido (que não é um nó de extensão) ou apenas retorna a expressão se ele já é um tipo conhecido.</summary>
      <returns>A expressão reduzida.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReferenceEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação de igualdade de referência.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReferenceNotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação de desigualdade de referência.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Rethrow">
      <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa um relançamento de uma exceção.</summary>
      <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa um relançamento de uma exceção.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Rethrow(System.Type)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa um relançamento de uma exceção com um determinado tipo.</summary>
      <param name="type">O novo <see cref="T:System.Type" /> da expressão.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa um relançamento de uma exceção.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa um demonstrativo de retorno.</summary>
      <param name="target">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Return, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para <paramref name="target" /> e um valor nulo a ser passado para o rótulo de destino ao saltar.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa um demonstrativo de retorno. O valor passado para o rótulo no salto pode ser especificado.</summary>
      <param name="target">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</param>
      <param name="value">O valor que será passado para o rótulo associado ao saltar.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Continuar, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida como <paramref name="target" /> e <paramref name="value" /> a ser passado para o rótulo de destino ao saltar.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução return com o tipo especificado. O valor passado para o rótulo no salto pode ser especificado.</summary>
      <param name="target">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</param>
      <param name="value">O valor que será passado para o rótulo associado ao saltar.</param>
      <param name="type">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Continue, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para <paramref name="target" />, a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> definida para <paramref name="type" /> e <paramref name="value" /> a ser passado para o rótulo de destino ao saltar.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução return com o tipo especificado.</summary>
      <param name="target">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</param>
      <param name="type">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Return, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para <paramref name="target" />, a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> definida para <paramref name="type" /> e um valor nulo a ser passado para o rótulo de destino ao saltar.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de deslocamento à direita bit a bit.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O operador de deslocamento à direita não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de deslocamento à direita bit a bit.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> é <see langword="null" /> e o operador de deslocamento à direita não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de deslocamento à direita bit a bit.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de deslocamento à direita bit a bit.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de deslocamento à direita bit a bit.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <param name="conversion">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Cria uma instância de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <param name="variables">Uma coleção de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />.</param>
      <returns>Uma instância de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> e a propriedade <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> definida para o valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Linq.Expressions.ParameterExpression[])">
      <summary>Cria uma instância de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <param name="variables">Uma matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />.</param>
      <returns>Uma instância de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> e a propriedade <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> definida para o valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de subtração que não tem verificação de estouro.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O operador de subtração não está definido como <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de subtração que não tem verificação de estouro.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> é <see langword="null" /> e o operador de subtração não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de subtração que não tem a verificação de estouro.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de subtração que não tem a verificação de estouro.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de subtração que não tem a verificação de estouro.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <param name="conversion">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de subtração que tem verificação de estouro.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de subtração que tem verificação de estouro.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de subtração que tem verificação de estouro.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <param name="conversion">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de subtração que tem verificação de estouro.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O operador de subtração não está definido como <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de subtração que tem verificação de estouro.</summary>
      <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> é <see langword="null" /> e o operador de subtração não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])">
      <summary>Cria um <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa uma instrução <see langword="switch" /> que tem um caso padrão.</summary>
      <param name="switchValue">O valor a ser testado para cada caso.</param>
      <param name="defaultBody">O resultado da opção se <paramref name="switchValue" /> não corresponde a nenhum dos casos.</param>
      <param name="cases">O conjunto de casos para esta expressão de comutador.</param>
      <returns>O <see cref="T:System.Linq.Expressions.SwitchExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})">
      <summary>Cria um <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa uma instrução <see langword="switch" /> que tem um caso padrão.</summary>
      <param name="switchValue">O valor a ser testado para cada caso.</param>
      <param name="defaultBody">O resultado da opção se <paramref name="switchValue" /> não corresponde a nenhum dos casos.</param>
      <param name="comparison">O método de comparação de igualdade para usar.</param>
      <param name="cases">O conjunto de casos para esta expressão de comutador.</param>
      <returns>O <see cref="T:System.Linq.Expressions.SwitchExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])">
      <summary>Cria um <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa uma instrução <see langword="switch" /> que tem um caso padrão.</summary>
      <param name="switchValue">O valor a ser testado para cada caso.</param>
      <param name="defaultBody">O resultado da opção se <paramref name="switchValue" /> não corresponde a nenhum dos casos.</param>
      <param name="comparison">O método de comparação de igualdade para usar.</param>
      <param name="cases">O conjunto de casos para esta expressão de comutador.</param>
      <returns>O <see cref="T:System.Linq.Expressions.SwitchExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa uma instrução <see langword="switch" /> sem um caso padrão.</summary>
      <param name="switchValue">O valor a ser testado para cada caso.</param>
      <param name="cases">O conjunto de casos para esta expressão de comutador.</param>
      <returns>O <see cref="T:System.Linq.Expressions.SwitchExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})">
      <summary>Cria um <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa uma instrução <see langword="switch" /> que tem um caso padrão.</summary>
      <param name="type">O tipo de resultado da opção.</param>
      <param name="switchValue">O valor a ser testado para cada caso.</param>
      <param name="defaultBody">O resultado da opção se <paramref name="switchValue" /> não corresponde a nenhum dos casos.</param>
      <param name="comparison">O método de comparação de igualdade para usar.</param>
      <param name="cases">O conjunto de casos para esta expressão de comutador.</param>
      <returns>O <see cref="T:System.Linq.Expressions.SwitchExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])">
      <summary>Cria um <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa uma instrução <see langword="switch" /> que tem um caso padrão.</summary>
      <param name="type">O tipo de resultado da opção.</param>
      <param name="switchValue">O valor a ser testado para cada caso.</param>
      <param name="defaultBody">O resultado da opção se <paramref name="switchValue" /> não corresponde a nenhum dos casos.</param>
      <param name="comparison">O método de comparação de igualdade para usar.</param>
      <param name="cases">O conjunto de casos para esta expressão de comutador.</param>
      <returns>O <see cref="T:System.Linq.Expressions.SwitchExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Cria um objeto <see cref="T:System.Linq.Expressions.SwitchCase" /> a ser usado em um objeto <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <param name="body">O corpo do caso.</param>
      <param name="testValues">Os valores de teste do caso.</param>
      <returns>O <see cref="T:System.Linq.Expressions.SwitchCase" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Cria um <see cref="T:System.Linq.Expressions.SwitchCase" /> para uso em um <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <param name="body">O corpo do caso.</param>
      <param name="testValues">Os valores de teste do caso.</param>
      <returns>O <see cref="T:System.Linq.Expressions.SwitchCase" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String)">
      <summary>Cria uma instância de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <param name="fileName">Uma <see cref="T:System.String" /> igual à qual definir o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que tem a propriedade <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> definida para o valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid)">
      <summary>Cria uma instância de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <param name="fileName">Uma <see cref="T:System.String" /> igual à qual definir o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
      <param name="language">Uma <see cref="T:System.Guid" /> igual à qual definir o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que tem as propriedades <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> e <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> definidas para o valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid)">
      <summary>Cria uma instância de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <param name="fileName">Uma <see cref="T:System.String" /> igual à qual definir o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
      <param name="language">Uma <see cref="T:System.Guid" /> igual à qual definir o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />.</param>
      <param name="languageVendor">Uma <see cref="T:System.Guid" /> igual à qual definir o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que tem as propriedades <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> e <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> definidas para o valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid,System.Guid)">
      <summary>Cria uma instância de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <param name="fileName">Uma <see cref="T:System.String" /> igual à qual definir o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
      <param name="language">Uma <see cref="T:System.Guid" /> igual à qual definir o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />.</param>
      <param name="languageVendor">Uma <see cref="T:System.Guid" /> igual à qual definir o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />.</param>
      <param name="documentType">Uma <see cref="T:System.Guid" /> igual à qual definir o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" />.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que tem as propriedades <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> e <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> definidas para o valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma geração de uma exceção.</summary>
      <param name="value">Um <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a exceção.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression,System.Type)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa um lançamento de uma exceção com um determinado tipo.</summary>
      <param name="value">Um <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="type">O novo <see cref="T:System.Type" /> da expressão.</param>
      <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a exceção.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ToString">
      <summary>Retorna uma representação textual de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Uma representação textual de <see cref="T:System.Linq.Expressions.Expression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryCatch(System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])">
      <summary>Cria um <see cref="T:System.Linq.Expressions.TryExpression" /> representando um bloco try com qualquer número de instruções catch e nem um bloco fault nem finally.</summary>
      <param name="body">O corpo do bloco try.</param>
      <param name="handlers">A matriz de zero ou mais expressões <see cref="T:System.Linq.Expressions.CatchBlock" /> representando as instruções catch a serem associados com o bloco try.</param>
      <returns>O <see cref="T:System.Linq.Expressions.TryExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryCatchFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.TryExpression" /> representando um bloco try com qualquer número de instruções catch e um bloco finally.</summary>
      <param name="body">O corpo do bloco try.</param>
      <param name="finally">O corpo do bloco finally.</param>
      <param name="handlers">A matriz de zero ou mais expressões <see cref="T:System.Linq.Expressions.CatchBlock" /> representando as instruções catch a serem associados com o bloco try.</param>
      <returns>O <see cref="T:System.Linq.Expressions.TryExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryFault(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.TryExpression" /> representando um bloco try com um bloco fault e nenhuma instrução catch.</summary>
      <param name="body">O corpo do bloco try.</param>
      <param name="fault">O corpo do bloco de falha.</param>
      <returns>O <see cref="T:System.Linq.Expressions.TryExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.TryExpression" /> representando um bloco try com um bloco finally e nenhuma instrução catch.</summary>
      <param name="body">O corpo do bloco try.</param>
      <param name="finally">O corpo do bloco finally.</param>
      <returns>O <see cref="T:System.Linq.Expressions.TryExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryGetActionType(System.Type[],System.Type@)">
      <summary>Cria um objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa um tipo de delegado genérico System.Action que tem argumentos de tipo específicos.</summary>
      <param name="typeArgs">Uma matriz de objetos Type que especifica os argumentos de tipo para o tipo de delegado System.Action.</param>
      <param name="actionType">Quando esse método retorna, ele contém o tipo de delegado genérico System.Action, que tem argumentos de tipo específicos. Contém NULL se não houver nenhum delegado System. Action genérico que corresponda a <paramref name="typeArgs" /> . Este parâmetro é passado não inicializado.</param>
      <returns>
        <see langword="true" /> se o tipo de delegado genérico System.Action foi criado para um <paramref name="typeArgs" /> específico; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryGetFuncType(System.Type[],System.Type@)">
      <summary>Cria um objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa um tipo de delegado genérico System.Func, que tem argumentos de tipo específicos. O último argumento de tipo especifica o tipo de retorno do delegado criado.</summary>
      <param name="typeArgs">Uma matriz de objetos Type que especifica os argumentos de tipo para o tipo de delegado System.Func.</param>
      <param name="funcType">Quando esse método retorna, ele contém o tipo de delegado genérico System.Func, que tem argumentos de tipo específicos. Contém NULL se não houver nenhum delegado System. Func genérico que corresponda a <paramref name="typeArgs" /> . Este parâmetro é passado não inicializado.</param>
      <returns>
        <see langword="true" /> se o tipo de delegado genérico System.Func foi criado para um <paramref name="typeArgs" /> específico; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeAs(System.Linq.Expressions.Expression,System.Type)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma conversão boxing ou de referência explícita em que <see langword="null" /> será fornecido se a conversão falhar.</summary>
      <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</param>
      <param name="type">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="type" /> é <see langword="null" />.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.TypeAs" /> e as propriedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.Expression.Type" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> que compara a identidade de tipo de tempo de execução.</summary>
      <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="T:System.Linq.Expressions.Expression" /> igual a ele.</param>
      <param name="type">Um <see cref="P:System.Linq.Expressions.Expression.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> igual a ele.</param>
      <returns>Uma <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> para a qual a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> é igual a <see cref="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" /> e para a qual as propriedades <see cref="T:System.Linq.Expressions.Expression" /> e <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> estão definidas para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeIs(System.Linq.Expressions.Expression,System.Type)">
      <summary>Cria um <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</summary>
      <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> igual a ele.</param>
      <param name="type">Um <see cref="P:System.Linq.Expressions.Expression.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="type" /> é <see langword="null" />.</exception>
      <returns>Uma <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> para a qual a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> é igual a <see cref="F:System.Linq.Expressions.ExpressionType.TypeIs" /> e para a qual as propriedades <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> e <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> estão definidas para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação unária de adição.</summary>
      <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O operador de mais unário não foi definido para <paramref name="expression" />.Type.</exception>
      <returns>Uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> e a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> definida para o valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação unária de adição.</summary>
      <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</param>
      <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente um argumento.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> é <see langword="null" /> e o operador unário de mais de não foi definido para <paramref name="expression" />.Type.  
  
- ou - 
 <paramref name="expression" />.Type (ou o respectivo tipo que não permite valor nulo correspondente se ele é um tipo que permite valor nulo) não é atribuível ao tipo de argumento do método representado por <paramref name="method" />.</exception>
      <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> e as propriedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Unbox(System.Linq.Expressions.Expression,System.Type)">
      <summary>Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma conversão unboxing explícita.</summary>
      <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para realizar conversão unboxing.</param>
      <param name="type">O novo <see cref="T:System.Type" /> da expressão.</param>
      <returns>Uma instância de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Variable(System.Type)">
      <summary>Cria um nó de <see cref="T:System.Linq.Expressions.ParameterExpression" /> que pode ser usado para identificar um parâmetro ou uma variável em uma árvore de expressão.</summary>
      <param name="type">O tipo do parâmetro ou da variável.</param>
      <returns>Um nó de <see cref="T:System.Linq.Expressions.ParameterExpression" /> com o nome e o tipo especificados</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Variable(System.Type,System.String)">
      <summary>Cria um nó de <see cref="T:System.Linq.Expressions.ParameterExpression" /> que pode ser usado para identificar um parâmetro ou uma variável em uma árvore de expressão.</summary>
      <param name="type">O tipo do parâmetro ou da variável.</param>
      <param name="name">O nome do parâmetro ou da variável. Esse nome é usado apenas para finalidades de depuração ou de impressão.</param>
      <returns>Um nó de <see cref="T:System.Linq.Expressions.ParameterExpression" /> com o nome e tipo especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.VisitChildren(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Reduz o nó e, em seguida, chama o delegado visitante na expressão reduzida. O método gera uma exceção se o nó não é reduzível.</summary>
      <param name="visitor">Uma instância de <see cref="T:System.Func`2" />.</param>
      <returns>A expressão que está sendo visitada ou uma expressão que deve substituí-la na árvore.</returns>
    </member>
    <member name="P:System.Linq.Expressions.Expression.CanReduce">
      <summary>Indica que o nó pode ser reduzido a um nó mais simples. Se isso retornar verdadeiro, Reduce() poderá ser chamado para produzir a forma reduzida.</summary>
      <returns>
        <see langword="true" /> Se o nó puder ser reduzido; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Linq.Expressions.Expression.NodeType">
      <summary>Obtém o tipo de nó deste <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Um dos valores de <see cref="T:System.Linq.Expressions.ExpressionType" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.Expression.Type">
      <summary>Obtém o tipo estático da expressão que esse <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>O <see cref="T:System.Type" /> que representa o tipo estático da expressão.</returns>
    </member>
    <member name="T:System.Linq.Expressions.Expression`1">
      <summary>Representa uma expressão lambda fortemente tipada como uma estrutura de dados na forma de uma árvore de expressão. Essa classe não pode ser herdada.</summary>
      <typeparam name="TDelegate">O tipo do delegado que o <see cref="T:System.Linq.Expressions.Expression`1" /> representa.</typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Compile">
      <summary>Compila a expressão lambda descrita pela árvore de expressão em um código executável e produz um delegado que representa a expressão lambda.</summary>
      <returns>Um delegado do tipo <paramref name="TDelegate" /> que representa a expressão lambda compilada descrita pelo <see cref="T:System.Linq.Expressions.Expression`1" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Compile(System.Boolean)">
      <summary>Compila a expressão lambda descrita pela árvore de expressão em um código interpretado ou compilado e produz um delegado que representa a expressão lambda.</summary>
      <param name="preferInterpretation">
        <see langword="true" /> para indicar que a expressão deverá ser compilada em um formato interpretado, se ele estiver disponível; <see langword="false" /> caso contrário.</param>
      <returns>Um delegado que representa a expressão lambda compilada descrita pelo <see cref="T:System.Linq.Expressions.Expression`1" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Compile(System.Runtime.CompilerServices.DebugInfoGenerator)">
      <summary>Produz um delegado que representa a expressão lambda.</summary>
      <param name="debugInfoGenerator">O gerador de informações de depuração usado pelo compilador para marcar pontos de sequência e anotar as variáveis locais.</param>
      <returns>Um delegado que contém a versão compilada da expressão lambda.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="body">A propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> do resultado.</param>
      <param name="parameters">A propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> do resultado.</param>
      <returns>Essa expressão se nenhum filho foi alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ExpressionType">
      <summary>Descreve os tipos de nós para os nós de uma árvore de expressão.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Add">
      <summary>Uma operação de adição, tal como <c>a + b</c>, sem verificação de estouro, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddAssign">
      <summary>Uma operação de adição de atribuição composta, tal como <c>(a += b)</c>, sem verificação de estouro, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddAssignChecked">
      <summary>Uma operação de adição de atribuição composta, tal como <c>(a += b)</c>, com verificação de estouro, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddChecked">
      <summary>Uma operação de adição, tal como <c>(a + b)</c>, com verificação de estouro, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.And">
      <summary>Uma operação <see langword="AND" /> lógica ou bit a bit, tal como <c>(a &amp; b)</c> em C# e <c>(a And b)</c> no Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AndAlso">
      <summary>Uma operação <see langword="AND" /> condicional que avalia o segundo operando somente se o primeiro operando é avaliado como <see langword="true" />. Ele corresponde a <c>(a &amp;&amp; b)</c> em C# e <c>(a AndAlso b)</c> no Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AndAssign">
      <summary>Uma operação de atribuição de associação de nível lógico ou de bits lógica <see langword="AND" /> , como <c>(a &amp; = b)</c> em C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ArrayIndex">
      <summary>Uma operação de indexação em uma matriz unidimensional, tal como <c>array[index]</c> em C# ou <c>array(index)</c> no Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ArrayLength">
      <summary>Uma operação que obtém o tamanho de uma matriz unidimensional, tal como <c>array.Length</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Assign">
      <summary>Uma operação de atribuição, tal como <c>(a = b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Block">
      <summary>Um bloco de expressões.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Call">
      <summary>Uma chamada de método, como na expressão <c>obj.sampleMethod()</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Coalesce">
      <summary>Um nó que representa uma operação de união nula, tal como <c>(a ?? b)</c> em C# ou <c>If(a, b)</c> no Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Conditional">
      <summary>Uma operação condicional, tal como <c>a &gt; b ? a : b</c> em C# ou <c>If(a &gt; b, a, b)</c> no Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Constant">
      <summary>Um valor constante.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Convert">
      <summary>Uma operação de conversão ou transmissão, tal como <c>(SampleType)obj</c> em C# ou <c>CType(obj, SampleType)</c> no Visual Basic. Para uma conversão numérica, se o valor convertido é muito grande para o tipo de destino, nenhuma exceção é lançada.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ConvertChecked">
      <summary>Uma operação de conversão ou transmissão, tal como <c>(SampleType)obj</c> em C# ou <c>CType(obj, SampleType)</c> no Visual Basic. Para uma conversão numérica, se o valor convertido não se ajusta ao tipo de destino, nenhuma exceção será lançada.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.DebugInfo">
      <summary>Informações de depuração.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Decrement">
      <summary>Uma operação de decremento unária, tal como <c>(a – 1)</c> em C# e Visual Basic. O objeto <c>a</c> não deve ser modificado no lugar em que se encontra.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Default">
      <summary>Um valor padrão.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Divide">
      <summary>Uma operação de divisão, tal como <c>(a / b)</c>, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.DivideAssign">
      <summary>Uma operação de divisão de atribuição composta, tal como <c>(a /= b)</c>, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Dynamic">
      <summary>Uma operação dinâmica.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Equal">
      <summary>Um nó que representa uma comparação de igualdade, tal como <c>(a == b)</c> em C# ou <c>(a = b)</c> no Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ExclusiveOr">
      <summary>Uma operação <see langword="XOR" /> lógica ou bit a bit, tal como <c>(a ^ b)</c> em C# e <c>(a Xor b)</c> no Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign">
      <summary>Uma operação de atribuição composta <see langword="XOR" /> lógica ou bit a bit como <c>(a ^= b)</c> em C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Extension">
      <summary>Uma expressão de extensão.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Goto">
      <summary>Uma expressão "go to", tal como <c>goto Rótulo</c> em C# ou <c>GoTo Rótulo</c> no Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.GreaterThan">
      <summary>Uma comparação "maior que", tal como <c>(a &gt; b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual">
      <summary>Uma comparação "maior que ou igual a" como <c>(a &gt;= b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Increment">
      <summary>Uma operação de incremento unária como <c>(a + 1)</c> em C# e Visual Basic. O objeto <c>a</c> não deve ser modificado no lugar em que se encontra.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Index">
      <summary>Uma operação de índice ou uma operação que acessa uma propriedade que aceita argumentos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Invoke">
      <summary>Uma operação que invoca uma expressão delegada ou lambda, tal como <c>sampleDelegate.Invoke()</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.IsFalse">
      <summary>Um valor de condição <see langword="false" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.IsTrue">
      <summary>Um valor de condição <see langword="true" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Label">
      <summary>Um rótulo.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Lambda">
      <summary>Uma expressão lambda, tal como <c>a =&gt; a + a</c> em C# ou <c>Function(a) a + a</c> no Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LeftShift">
      <summary>Uma operação bit a bit de deslocamento à esquerda, tal como <c>(a &lt;&lt; b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign">
      <summary>Uma atribuição composta bit a bit de deslocamento à esquerda, tal como <c>(a &lt;&lt;= b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LessThan">
      <summary>Uma comparação "menor que", tal como <c>(a &lt; b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual">
      <summary>Uma comparação "menor que ou igual a", tal como <c>(a &lt;= b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ListInit">
      <summary>Uma operação que cria um novo objeto <see cref="T:System.Collections.IEnumerable" /> e o inicializa de uma lista de elementos, tais como <c>new List&lt;SampleType&gt;(){ a, b, c }</c> em C# ou <c>Dim sampleList = { a, b, c }</c> no Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Loop">
      <summary>Um loop, assim como <c>for</c> ou <c>while</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MemberAccess">
      <summary>Uma operação que lê de um campo ou propriedade, tal como <c>obj.SampleProperty</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MemberInit">
      <summary>Uma operação que cria um novo objeto e inicializa um ou mais de seus membros, tal como <c>new Point { X = 1, Y = 2 }</c> em C# ou <c>New Point With {.X = 1, .Y = 2}</c> no Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Modulo">
      <summary>Uma operação aritmética restante, tal como <c>(a % b)</c> em C# ou <c>(a Mod b)</c> no Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ModuloAssign">
      <summary>Uma operação aritmética restante de atribuição composta, tal como <c>(a %= b)</c> em C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Multiply">
      <summary>Uma operação de multiplicação, tal como <c>(a * b)</c>, sem verificação de estouro, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyAssign">
      <summary>Uma operação de multiplicação de atribuição composta, tal como <c>(a *= b)</c>, sem verificação de estouro, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked">
      <summary>Uma operação de multiplicação de atribuição composta, tal como <c>(a *= b)</c>, que tem verificação de estouro, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyChecked">
      <summary>Uma operação de multiplicação, tal como <c>(a * b)</c>, com verificação de estouro, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Negate">
      <summary>Uma operação de negação aritmética, tal como <c>(-a)</c>. O objeto <c>a</c> não deve ser modificado no lugar em que se encontra.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NegateChecked">
      <summary>Uma operação de negação aritmética, tal como <c>(-a)</c>, que tem a verificação de estouro. O objeto <c>a</c> não deve ser modificado no lugar em que se encontra.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.New">
      <summary>Uma operação que chama um construtor para criar um novo objeto, tal como <c>new SampleType()</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NewArrayBounds">
      <summary>Uma operação que cria uma nova matriz e na qual os limites de cada dimensão são especificados, tal como <c>new SampleType[dim1, dim2]</c> em C# ou <c>New SampleType(dim1, dim2)</c> no Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NewArrayInit">
      <summary>Uma operação que cria uma nova matriz unidirecional e a inicializa de uma lista de elementos, tal como <c>new SampleType[]{a, b, c}</c> em C# ou <c>New SampleType(){a, b, c}</c> no Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Not">
      <summary>Uma operação de negação lógica ou de complemento bit a bit. Em C#, é equivalente a <c>(~a)</c> para tipos integrais e a <c>(!a)</c> para valores boolianos. No Visual Basic, é equivalente a <c>(Not a)</c>. O objeto <c>a</c> não deve ser modificado no lugar em que se encontra.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NotEqual">
      <summary>Uma comparação de desigualdade, tal como <c>(a != b)</c> em C# ou <c>(a &lt;&gt; b)</c> no Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OnesComplement">
      <summary>Uma operação de um complemento, tal como <c>(~a)</c> em C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Or">
      <summary>Uma operação <see langword="OR" /> lógica ou bit a bit, tal como <c>(a ^ b)</c> em C# e <c>(a Or b)</c> no Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OrAssign">
      <summary>Uma atribuição composta <see langword="OR" /> lógica ou bit a bit, tal como <c>(a |= b)</c> em C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OrElse">
      <summary>Uma operação <see langword="OR" /> condicional de curto-circuito, tal como <c>(a || b)</c> em C# ou <c>(a OrElse b)</c> no Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Parameter">
      <summary>Uma referência a um parâmetro ou uma variável que é definida no contexto da expressão. Para obter mais informações, consulte <see cref="T:System.Linq.Expressions.ParameterExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PostDecrementAssign">
      <summary>Um decremento de sufixo unário, tal como <c>(a--)</c>. O objeto <c>a</c> deve ser modificado no lugar.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PostIncrementAssign">
      <summary>Um incremento de sufixo unário, tal como <c>(a++)</c>. O objeto <c>a</c> deve ser modificado no lugar.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Power">
      <summary>Uma operação matemática que eleva um número a uma potência, tal como <c>(a ^ b)</c> no Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PowerAssign">
      <summary>Uma operação de atribuição composta que eleva um número a uma potência, tal como <c>(a ^= b)</c> no Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PreDecrementAssign">
      <summary>Um decremento de prefixo unário, tal como <c>(--a)</c>. O objeto <c>a</c> deve ser modificado no lugar.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PreIncrementAssign">
      <summary>Um incremento de prefixo unário, como <c>(++a)</c>. O objeto <c>a</c> deve ser modificado no lugar.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Quote">
      <summary>Uma expressão que tem um valor constante do tipo <see cref="T:System.Linq.Expressions.Expression" />. Um nó <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> pode conter referências a parâmetros que são definidas no contexto da expressão que ele representa.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RightShift">
      <summary>Uma operação bit a bit de deslocamento à direita, tal como <c>(a &gt;&gt; b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RightShiftAssign">
      <summary>Uma operação de atribuição composta de deslocamento à direita, tal como <c>(a &gt;&gt;= b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RuntimeVariables">
      <summary>Uma lista de variáveis de tempo de execução. Para obter mais informações, consulte <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Subtract">
      <summary>Uma operação de subtração como <c>(a – b)</c>, sem verificação de estouro, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractAssign">
      <summary>Uma operação de subtração de atribuição composta como <c>(a -= b)</c>, sem verificação de estouro, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked">
      <summary>Uma operação de subtração de atribuição composta como <c>(a -= b)</c>, com verificação de estouro, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractChecked">
      <summary>Uma operação aritmética de subtração, como <c>(a – b)</c>, com verificação de estouro, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Switch">
      <summary>Uma operação do comutador, como <see langword="switch" /> em C# ou <see langword="Select Case" /> no Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Throw">
      <summary>Uma operação que gera uma exceção, tal como <c>throw new Exception()</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Try">
      <summary>Uma expressão <see langword="try-catch" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeAs">
      <summary>Uma referência explícita ou conversão boxing na qual <see langword="null" /> será fornecido se a conversão falhar, como <c>(obj as SampleType)</c> em C# ou <c>TryCast(obj, SampleType)</c> no Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeEqual">
      <summary>Um teste de tipo exato.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeIs">
      <summary>Um tipo de teste, tal como <c>obj is SampleType</c> em C# ou <c>TypeOf obj is SampleType</c> no Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.UnaryPlus">
      <summary>Uma operação de mais unária, tal como <c>(+a)</c>. O resultado de uma operação de mais unária predefinida é o valor do operando, mas implementações definidas pelo usuário podem ter resultados incomuns.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Unbox">
      <summary>Uma operação do tipo valor de unbox, como instruções <see langword="unbox" /> e <see langword="unbox.any" /> no MSIL.</summary>
    </member>
    <member name="T:System.Linq.Expressions.ExpressionVisitor">
      <summary>Representa um visitante ou regravador para árvores de expressão.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.#ctor">
      <summary>Inicializa uma nova instância de <see cref="T:System.Linq.Expressions.ExpressionVisitor" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit(System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.Expression})">
      <summary>Envia a lista de expressões para um dos métodos de visita mais especializados nessa classe.</summary>
      <param name="nodes">As expressões a visitar.</param>
      <returns>A lista de expressões modificada, se qualquer um dos elementos tiver sido modificado; caso contrário, retornará a lista de expressões original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit(System.Linq.Expressions.Expression)">
      <summary>Envia a expressão a um dos métodos de visita mais especializados nessa classe.</summary>
      <param name="node">A expressão a ser visitada.</param>
      <returns>A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.Func{``0,``0})">
      <summary>Visita todos os nós na coleção usando um visitante de elemento especificado.</summary>
      <param name="nodes">Os nós a visitar.</param>
      <param name="elementVisitor">Um delegado que visita um único elemento, substituindo-o opcionalmente por um novo elemento.</param>
      <typeparam name="T">O tipo dos nós.</typeparam>
      <returns>A lista de nós modificada, se qualquer dos elementos tiver sido modificado; caso contrário, retornará a lista de nós original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitAndConvert``1(``0,System.String)">
      <summary>Visita uma expressão, convertendo os resultados de volta ao tipo de expressão original.</summary>
      <param name="node">A expressão a ser visitada.</param>
      <param name="callerName">O nome do método de chamada; usado para relatar uma mensagem de erro melhor.</param>
      <typeparam name="T">O tipo de expressão.</typeparam>
      <exception cref="T:System.InvalidOperationException">O método visit para este nó retornou um tipo diferente.</exception>
      <returns>A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitAndConvert``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.String)">
      <summary>Visitas todas as expressões na coleção, convertendo os resultados de volta para o tipo de expressão original.</summary>
      <param name="nodes">As expressões a visitar.</param>
      <param name="callerName">O nome do método de chamada; usado para relatar uma mensagem de erro melhor.</param>
      <typeparam name="T">O tipo das expressões.</typeparam>
      <exception cref="T:System.InvalidOperationException">O método visit para uma das expressões retornou um tipo diferente.</exception>
      <returns>A coleção de expressões modificada, se qualquer expressão foi modificada; caso contrário, retorna a coleção de expressões original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitBinary(System.Linq.Expressions.BinaryExpression)">
      <summary>Visita os filhos de <see cref="T:System.Linq.Expressions.BinaryExpression" />.</summary>
      <param name="node">A expressão a ser visitada.</param>
      <returns>A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitBlock(System.Linq.Expressions.BlockExpression)">
      <summary>Visita os filhos de <see cref="T:System.Linq.Expressions.BlockExpression" />.</summary>
      <param name="node">A expressão a ser visitada.</param>
      <returns>A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitCatchBlock(System.Linq.Expressions.CatchBlock)">
      <summary>Visita os filhos de <see cref="T:System.Linq.Expressions.CatchBlock" />.</summary>
      <param name="node">A expressão a ser visitada.</param>
      <returns>A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitConditional(System.Linq.Expressions.ConditionalExpression)">
      <summary>Visita os filhos de <see cref="T:System.Linq.Expressions.ConditionalExpression" />.</summary>
      <param name="node">A expressão a ser visitada.</param>
      <returns>A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitConstant(System.Linq.Expressions.ConstantExpression)">
      <summary>Visita o <see cref="T:System.Linq.Expressions.ConstantExpression" />.</summary>
      <param name="node">A expressão a ser visitada.</param>
      <returns>A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitDebugInfo(System.Linq.Expressions.DebugInfoExpression)">
      <summary>Visita o <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <param name="node">A expressão a ser visitada.</param>
      <returns>A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitDefault(System.Linq.Expressions.DefaultExpression)">
      <summary>Visita o <see cref="T:System.Linq.Expressions.DefaultExpression" />.</summary>
      <param name="node">A expressão a ser visitada.</param>
      <returns>A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitDynamic(System.Linq.Expressions.DynamicExpression)">
      <summary>Visita os filhos de <see cref="T:System.Linq.Expressions.DynamicExpression" />.</summary>
      <param name="node">A expressão a ser visitada.</param>
      <returns>A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitElementInit(System.Linq.Expressions.ElementInit)">
      <summary>Visita os filhos de <see cref="T:System.Linq.Expressions.ElementInit" />.</summary>
      <param name="node">A expressão a ser visitada.</param>
      <returns>A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitExtension(System.Linq.Expressions.Expression)">
      <summary>Visita os filhos da expressão de extensão.</summary>
      <param name="node">A expressão a ser visitada.</param>
      <returns>A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitGoto(System.Linq.Expressions.GotoExpression)">
      <summary>Visita os filhos de <see cref="T:System.Linq.Expressions.GotoExpression" />.</summary>
      <param name="node">A expressão a ser visitada.</param>
      <returns>A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitIndex(System.Linq.Expressions.IndexExpression)">
      <summary>Visita os filhos de <see cref="T:System.Linq.Expressions.IndexExpression" />.</summary>
      <param name="node">A expressão a ser visitada.</param>
      <returns>A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitInvocation(System.Linq.Expressions.InvocationExpression)">
      <summary>Visita os filhos de <see cref="T:System.Linq.Expressions.InvocationExpression" />.</summary>
      <param name="node">A expressão a ser visitada.</param>
      <returns>A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLabel(System.Linq.Expressions.LabelExpression)">
      <summary>Visita os filhos de <see cref="T:System.Linq.Expressions.LabelExpression" />.</summary>
      <param name="node">A expressão a ser visitada.</param>
      <returns>A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLabelTarget(System.Linq.Expressions.LabelTarget)">
      <summary>Visita o <see cref="T:System.Linq.Expressions.LabelTarget" />.</summary>
      <param name="node">A expressão a ser visitada.</param>
      <returns>A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLambda``1(System.Linq.Expressions.Expression{``0})">
      <summary>Visita os filhos de <see cref="T:System.Linq.Expressions.Expression`1" />.</summary>
      <param name="node">A expressão a ser visitada.</param>
      <typeparam name="T">O tipo do delegado.</typeparam>
      <returns>A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitListInit(System.Linq.Expressions.ListInitExpression)">
      <summary>Visita os filhos de <see cref="T:System.Linq.Expressions.ListInitExpression" />.</summary>
      <param name="node">A expressão a ser visitada.</param>
      <returns>A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLoop(System.Linq.Expressions.LoopExpression)">
      <summary>Visita os filhos de <see cref="T:System.Linq.Expressions.LoopExpression" />.</summary>
      <param name="node">A expressão a ser visitada.</param>
      <returns>A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMember(System.Linq.Expressions.MemberExpression)">
      <summary>Visita os filhos de <see cref="T:System.Linq.Expressions.MemberExpression" />.</summary>
      <param name="node">A expressão a ser visitada.</param>
      <returns>A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberAssignment(System.Linq.Expressions.MemberAssignment)">
      <summary>Visita os filhos de <see cref="T:System.Linq.Expressions.MemberAssignment" />.</summary>
      <param name="node">A expressão a ser visitada.</param>
      <returns>A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberBinding(System.Linq.Expressions.MemberBinding)">
      <summary>Visita os filhos de <see cref="T:System.Linq.Expressions.MemberBinding" />.</summary>
      <param name="node">A expressão a ser visitada.</param>
      <returns>A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberInit(System.Linq.Expressions.MemberInitExpression)">
      <summary>Visita os filhos de <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
      <param name="node">A expressão a ser visitada.</param>
      <returns>A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberListBinding(System.Linq.Expressions.MemberListBinding)">
      <summary>Visita os filhos de <see cref="T:System.Linq.Expressions.MemberListBinding" />.</summary>
      <param name="node">A expressão a ser visitada.</param>
      <returns>A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberMemberBinding(System.Linq.Expressions.MemberMemberBinding)">
      <summary>Visita os filhos de <see cref="T:System.Linq.Expressions.MemberMemberBinding" />.</summary>
      <param name="node">A expressão a ser visitada.</param>
      <returns>A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)">
      <summary>Visita os filhos de <see cref="T:System.Linq.Expressions.MethodCallExpression" />.</summary>
      <param name="node">A expressão a ser visitada.</param>
      <returns>A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitNew(System.Linq.Expressions.NewExpression)">
      <summary>Visita os filhos de <see cref="T:System.Linq.Expressions.NewExpression" />.</summary>
      <param name="node">A expressão a ser visitada.</param>
      <returns>A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitNewArray(System.Linq.Expressions.NewArrayExpression)">
      <summary>Visita os filhos de <see cref="T:System.Linq.Expressions.NewArrayExpression" />.</summary>
      <param name="node">A expressão a ser visitada.</param>
      <returns>A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitParameter(System.Linq.Expressions.ParameterExpression)">
      <summary>Visita o <see cref="T:System.Linq.Expressions.ParameterExpression" />.</summary>
      <param name="node">A expressão a ser visitada.</param>
      <returns>A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitRuntimeVariables(System.Linq.Expressions.RuntimeVariablesExpression)">
      <summary>Visita os filhos de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <param name="node">A expressão a ser visitada.</param>
      <returns>A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitSwitch(System.Linq.Expressions.SwitchExpression)">
      <summary>Visita os filhos de <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <param name="node">A expressão a ser visitada.</param>
      <returns>A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitSwitchCase(System.Linq.Expressions.SwitchCase)">
      <summary>Visita os filhos de <see cref="T:System.Linq.Expressions.SwitchCase" />.</summary>
      <param name="node">A expressão a ser visitada.</param>
      <returns>A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitTry(System.Linq.Expressions.TryExpression)">
      <summary>Visita os filhos de <see cref="T:System.Linq.Expressions.TryExpression" />.</summary>
      <param name="node">A expressão a ser visitada.</param>
      <returns>A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitTypeBinary(System.Linq.Expressions.TypeBinaryExpression)">
      <summary>Visita os filhos de <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</summary>
      <param name="node">A expressão a ser visitada.</param>
      <returns>A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitUnary(System.Linq.Expressions.UnaryExpression)">
      <summary>Visita os filhos de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</summary>
      <param name="node">A expressão a ser visitada.</param>
      <returns>A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="T:System.Linq.Expressions.GotoExpression">
      <summary>Representa um salto incondicional. Isso inclui o instruções de retorno, interrupção e continuação, entre outros saltos.</summary>
    </member>
    <member name="M:System.Linq.Expressions.GotoExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="target">A propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> do resultado.</param>
      <param name="value">A propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Value" /> do resultado.</param>
      <returns>Essa expressão se nenhum filho foi alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Kind">
      <summary>O tipo da expressão "go to". Serve apenas para fins informativos.</summary>
      <returns>O <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> objeto que representa a espécie da expressão "go to".</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.NodeType">
      <summary>Retorna o tipo de nó deste <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>O <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa essa expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Target">
      <summary>O rótulo de destino para o qual este nó salta.</summary>
      <returns>O <see cref="T:System.Linq.Expressions.LabelTarget" /> objeto que representa o rótulo de destino para este nó.</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Type">
      <summary>Obtém o tipo estático da expressão que esse <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>O <see cref="P:System.Linq.Expressions.GotoExpression.Type" /> que representa o tipo estático da expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Value">
      <summary>O valor passado para o destino ou nulo, se o destino é do tipo System.Void.</summary>
      <returns>O <see cref="T:System.Linq.Expressions.Expression" /> objeto que representa o valor passado para o destino ou nulo.</returns>
    </member>
    <member name="T:System.Linq.Expressions.GotoExpressionKind">
      <summary>Especifica qual tipo de link esta <see cref="T:System.Linq.Expressions.GotoExpression" /> representa.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Break">
      <summary>Uma <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução break.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Continue">
      <summary>Uma <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução continue.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Goto">
      <summary>Uma <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa um link para um local.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Return">
      <summary>Uma <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução return.</summary>
    </member>
    <member name="T:System.Linq.Expressions.IArgumentProvider">
      <summary>Fornece uma interface interna para acessar os argumentos de vários nós de árvore (DynamicExpression, ElementInit, MethodCallExpression, InvocationExpression, NewExpression e IndexExpression).  Esta API é somente para uso interno.</summary>
    </member>
    <member name="M:System.Linq.Expressions.IArgumentProvider.GetArgument(System.Int32)">
      <summary>Retorna o argumento no <paramref name="index" />, gerando se o <paramref name="index" /> estiver fora dos limites. Esta API é somente para uso interno.</summary>
      <param name="index">O índice do argumento.</param>
      <returns>O argumento no índice.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IArgumentProvider.ArgumentCount">
      <summary>Retorna o número de argumentos para o nó de árvore de expressão. Esta API é somente para uso interno.</summary>
      <returns>O número de argumentos para o nó da árvore de expressão como <see cref="T:System.Int32" /> .</returns>
    </member>
    <member name="T:System.Linq.Expressions.IDynamicExpression">
      <summary>Fornece uma interface interna para acessar os argumentos de nós de árvore DynamicExpression, bem como funcionalidades de CallSite e de regravação.  Você não deve usar essa API.  Ela só é pública devido à refatoração de DLL e existe somente para otimizações de desempenho internas.</summary>
    </member>
    <member name="M:System.Linq.Expressions.IDynamicExpression.CreateCallSite">
      <summary>Opcionalmente, cria e retorna o CallSite para o cache embutido polimórfico de DynamicExpression.  Você não deve usar esse tipo.  Ele só é público devido a refatoração de assembly e é usado internamente para otimizações de desempenho.</summary>
      <returns>O CallSite para o cache embutido polimórfico de DynamicExpression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.IDynamicExpression.Rewrite(System.Linq.Expressions.Expression[])">
      <summary>Regrava esse nó substituindo argumentos da expressão dinâmica pelos valores fornecidos.  O número de <paramref name="args" /> precisa corresponder ao número da expressão atual.  Você não deve usar esse tipo.  Ele só é público devido a refatoração de assembly e é usado internamente para otimizações de desempenho.  Esse método auxiliar permite que a regravação de nós seja independente da classe de implementação específica derivada de DynamicExpression que está sendo usada no local da chamada.</summary>
      <param name="args">Os argumentos usados para substituir esse nó.</param>
      <returns>O nó regravado, mas se nenhuma alteração foi feita, retorna o mesmo nó.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IDynamicExpression.DelegateType">
      <summary>Obtém o tipo de delegado usado pelo CallSite, que é o tipo das regras usadas no cache embutido polimórfico da expressão dinâmica.</summary>
      <returns>O tipo delegado usado pelo chamada.</returns>
    </member>
    <member name="T:System.Linq.Expressions.IndexExpression">
      <summary>Representa uma propriedade ou uma matriz de indexação.</summary>
    </member>
    <member name="M:System.Linq.Expressions.IndexExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)">
      <summary>Retorna o argumento no índice, lançando se o índice estiver fora dos limites.  Você não deve usar esse membro.  Ele só é público devido a refatoração de assembly e é usado internamente para otimizações de desempenho.</summary>
      <param name="index">O índice do argumento.</param>
      <returns>Retorna <see cref="T:System.Linq.Expressions.Expression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.IndexExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="object">A propriedade <see cref="P:System.Linq.Expressions.IndexExpression.Object" /> do resultado.</param>
      <param name="arguments">A propriedade <see cref="P:System.Linq.Expressions.IndexExpression.Arguments" /> do resultado.</param>
      <returns>Essa expressão se nenhum filho foi alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Arguments">
      <summary>Obtém os argumentos que será usado para indexar a propriedade ou a matriz.</summary>
      <returns>A coleção somente leitura que contém os argumentos que serão usados para indexar a propriedade ou a matriz.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Indexer">
      <summary>Obtém o <see cref="T:System.Reflection.PropertyInfo" /> para a propriedade se a expressão representa uma propriedade indexada; caso contrário, retorna um valor nulo.</summary>
      <returns>O <see cref="T:System.Reflection.PropertyInfo" /> para a propriedade se a expressão representa uma propriedade indexada, caso contrário, NULL.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.NodeType">
      <summary>Retorna o tipo de nó deste <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>O <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa essa expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Object">
      <summary>Um objeto a indexar.</summary>
      <returns>O <see cref="T:System.Linq.Expressions.Expression" /> que representa o objeto a ser indexado.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount">
      <summary>Retorna o número de argumentos para o nó de árvore de expressão.  Você não deve usar esse membro.  Ele só é público devido a refatoração de assembly e é usado internamente para otimizações de desempenho.</summary>
      <returns>Retorna <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Type">
      <summary>Obtém o tipo estático da expressão que esse <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>O <see cref="P:System.Linq.Expressions.IndexExpression.Type" /> que representa o tipo estático da expressão.</returns>
    </member>
    <member name="T:System.Linq.Expressions.InvocationExpression">
      <summary>Representa uma expressão que se aplica a um delegado ou a expressão lambda para uma lista de expressões de argumento.</summary>
    </member>
    <member name="M:System.Linq.Expressions.InvocationExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)">
      <summary>Retorna o argumento no índice, lançando se o índice estiver fora dos limites.  Você não deve usar esse membro.  Ele só é público devido a refatoração de assembly e é usado internamente para otimizações de desempenho.</summary>
      <param name="index">O índice do argumento.</param>
      <returns>O argumento no índice, gerando exceção se o índice está fora dos limites, assim como <see cref="T:System.Linq.Expressions.Expression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.InvocationExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="expression">A propriedade <see cref="P:System.Linq.Expressions.InvocationExpression.Expression" /> do resultado.</param>
      <param name="arguments">A propriedade <see cref="P:System.Linq.Expressions.InvocationExpression.Arguments" /> do resultado.</param>
      <returns>Essa expressão se nenhum filho foi alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Arguments">
      <summary>Obtém os argumentos aos quais que a expressão de delegado ou lambda é aplicada.</summary>
      <returns>Um <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> dos <see cref="T:System.Linq.Expressions.Expression" /> objetos que representam os argumentos aos quais o delegado é aplicado.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Expression">
      <summary>Obtém a expressão de delegado ou lambda a aplicar.</summary>
      <returns>Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o delegado a ser aplicado.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.NodeType">
      <summary>Retorna o tipo de nó dessa expressão. Nós de extensão devem retornar <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> ao substituírem esse método.</summary>
      <returns>O <see cref="T:System.Linq.Expressions.ExpressionType" /> da expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount">
      <summary>Retorna o número de argumentos para o nó de árvore de expressão.  Você não deve usar esse membro.  Ele só é público devido a refatoração de assembly e é usado internamente para otimizações de desempenho.</summary>
      <returns>O número de argumentos para o nó da árvore de expressão como <see cref="T:System.Int32" /> .</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Type">
      <summary>Obtém o tipo estático da expressão que esse <see cref="P:System.Linq.Expressions.InvocationExpression.Expression" /> representa.</summary>
      <returns>O <see cref="P:System.Linq.Expressions.InvocationExpression.Type" /> que representa o tipo estático da expressão.</returns>
    </member>
    <member name="T:System.Linq.Expressions.LabelExpression">
      <summary>Representa um rótulo, que pode ser colocado em qualquer contexto <see cref="T:System.Linq.Expressions.Expression" />. Se for o destino do salto, ele receberá o valor fornecido pela <see cref="T:System.Linq.Expressions.GotoExpression" /> correspondente. Caso contrário, ele receberá o valor em <see cref="P:System.Linq.Expressions.LabelExpression.DefaultValue" />. Se <see cref="T:System.Type" /> for igual a System.Void, nenhum valor deverá ser fornecido.</summary>
    </member>
    <member name="M:System.Linq.Expressions.LabelExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="target">A propriedade <see cref="P:System.Linq.Expressions.LabelExpression.Target" /> do resultado.</param>
      <param name="defaultValue">A propriedade <see cref="P:System.Linq.Expressions.LabelExpression.DefaultValue" /> do resultado</param>
      <returns>Essa expressão se nenhum filho foi alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.DefaultValue">
      <summary>O valor de <see cref="T:System.Linq.Expressions.LabelExpression" /> quando o rótulo é acessado por meio de fluxo de controle normal (por exemplo, não saltou).</summary>
      <returns>O objeto Expressão que representa o valor de <see cref="T:System.Linq.Expressions.LabelExpression" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.NodeType">
      <summary>Retorna o tipo de nó deste <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>O <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa essa expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.Target">
      <summary>O <see cref="T:System.Linq.Expressions.LabelTarget" /> ao qual o rótulo está associado.</summary>
      <returns>O <see cref="T:System.Linq.Expressions.LabelTarget" /> ao qual o rótulo está associado.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.Type">
      <summary>Obtém o tipo estático da expressão que esse <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>O <see cref="P:System.Linq.Expressions.LabelExpression.Type" /> que representa o tipo estático da expressão.</returns>
    </member>
    <member name="T:System.Linq.Expressions.LabelTarget">
      <summary>Usado para representar o destino de um <see cref="T:System.Linq.Expressions.GotoExpression" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.LabelTarget.ToString">
      <summary>Retorna um valor <see cref="T:System.String" /> que representa o <see cref="T:System.Object" /> atual.</summary>
      <returns>Um <see cref="T:System.String" /> que representa o <see cref="T:System.Object" /> atual.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelTarget.Name">
      <summary>Obtém o nome do rótulo.</summary>
      <returns>O nome do rótulo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelTarget.Type">
      <summary>O tipo de valor que é passado ao saltar para o rótulo (ou <see cref="T:System.Void" />, caso nenhum valor deva ser passado).</summary>
      <returns>O <see cref="T:System.Type" /> objeto que representa o tipo do valor que é passado ao saltar para o rótulo ou <see cref="T:System.Void" /> se nenhum valor deve ser passado</returns>
    </member>
    <member name="T:System.Linq.Expressions.LambdaExpression">
      <summary>Descreve uma expressão lambda. Isso captura um bloco de código semelhante a um corpo de método do .NET.</summary>
    </member>
    <member name="M:System.Linq.Expressions.LambdaExpression.Compile">
      <summary>Produz um delegado que representa a expressão lambda.</summary>
      <returns>Um <see cref="T:System.Delegate" /> que contém a versão compilada da expressão lambda.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LambdaExpression.Compile(System.Boolean)">
      <summary>Produz um delegado interpretado ou compilado que representa a expressão lambda.</summary>
      <param name="preferInterpretation">
        <see langword="true" /> para indicar que a expressão deverá ser compilada em um formato interpretado, se ele estiver disponível; <see langword="false" /> caso contrário.</param>
      <returns>Um delegado que representa a expressão lambda compilada descrita pelo objeto <see cref="T:System.Linq.Expressions.LambdaExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LambdaExpression.Compile(System.Runtime.CompilerServices.DebugInfoGenerator)">
      <summary>Produz um delegado que representa a expressão lambda.</summary>
      <param name="debugInfoGenerator">O gerador de informações de depuração usado pelo compilador para marcar pontos de sequência e anotar as variáveis locais.</param>
      <returns>Um delegado que contém a versão compilada da expressão lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Body">
      <summary>Obtém o corpo da expressão lambda.</summary>
      <returns>Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o corpo da expressão lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Name">
      <summary>Obtém o nome da expressão lambda.</summary>
      <returns>O nome da expressão lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.NodeType">
      <summary>Retorna o tipo de nó deste <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>O <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa essa expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Parameters">
      <summary>Obtém os parâmetros da expressão lambda.</summary>
      <returns>Um <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representam os parâmetros da expressão lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.ReturnType">
      <summary>Obtém o tipo de retorno da expressão lambda.</summary>
      <returns>O <see cref="T:System.Type" /> objeto que representa o tipo da expressão lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.TailCall">
      <summary>Obtém o valor que indica se a expressão lambda será compilada com a otimização de chamada tail.</summary>
      <returns>
        <see langword="true" /> se a expressão lambda será compilada com a otimização da chamada tail; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Type">
      <summary>Obtém o tipo estático da expressão que esse <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>O <see cref="P:System.Linq.Expressions.LambdaExpression.Type" /> que representa o tipo estático da expressão.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ListInitExpression">
      <summary>Representa uma chamada de construtor com um inicializador de coleção.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ListInitExpression.Reduce">
      <summary>Reduz o nó de expressão binária para uma expressão mais simples.</summary>
      <returns>A expressão reduzida.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ListInitExpression.Update(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="newExpression">A propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> do resultado.</param>
      <param name="initializers">A propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> do resultado.</param>
      <returns>Essa expressão se nenhum filho foi alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.CanReduce">
      <summary>Obtém um valor que indica se o nó da árvore de expressão pode ser reduzido.</summary>
      <returns>
        <see langword="true" /> Se o nó puder ser reduzido; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.Initializers">
      <summary>Obtém os inicializadores de elemento usados para inicializar uma coleção.</summary>
      <returns>Um <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> dos <see cref="T:System.Linq.Expressions.ElementInit" /> objetos que representam os elementos que são usados para inicializar a coleção.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.NewExpression">
      <summary>Obtém a expressão que contém uma chamada para o construtor de um tipo de coleção.</summary>
      <returns>Um <see cref="T:System.Linq.Expressions.NewExpression" /> que representa a chamada para o construtor de um tipo de coleção.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.NodeType">
      <summary>Retorna o tipo de nó deste <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>O <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa essa expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.Type">
      <summary>Obtém o tipo estático da expressão que esse <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>O <see cref="P:System.Linq.Expressions.ListInitExpression.Type" /> que representa o tipo estático da expressão.</returns>
    </member>
    <member name="T:System.Linq.Expressions.LoopExpression">
      <summary>Representa um loop infinito. Pode ser encerrado com "quebra".</summary>
    </member>
    <member name="M:System.Linq.Expressions.LoopExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="breakLabel">A propriedade <see cref="P:System.Linq.Expressions.LoopExpression.BreakLabel" /> do resultado.</param>
      <param name="continueLabel">A propriedade <see cref="P:System.Linq.Expressions.LoopExpression.ContinueLabel" /> do resultado.</param>
      <param name="body">A propriedade <see cref="P:System.Linq.Expressions.LoopExpression.Body" /> do resultado.</param>
      <returns>Essa expressão se nenhum filho foi alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.Body">
      <summary>Obtém o <see cref="T:System.Linq.Expressions.Expression" /> que é o corpo do loop.</summary>
      <returns>O <see cref="T:System.Linq.Expressions.Expression" /> que é o corpo do loop.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.BreakLabel">
      <summary>Obtém o <see cref="T:System.Linq.Expressions.LabelTarget" /> que é usado pelo corpo do loop como um destino de instrução de interromper.</summary>
      <returns>O <see cref="T:System.Linq.Expressions.LabelTarget" /> que é usado pelo corpo do loop como um destino de instrução break.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.ContinueLabel">
      <summary>Obtém o <see cref="T:System.Linq.Expressions.LabelTarget" /> que é usado pelo corpo do loop como um destino de instrução de continuar.</summary>
      <returns>O <see cref="T:System.Linq.Expressions.LabelTarget" /> que é usado pelo corpo do loop como um destino da instrução Continue.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.NodeType">
      <summary>Retorna o tipo de nó dessa expressão. Nós de extensão devem retornar <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> ao substituírem esse método.</summary>
      <returns>O <see cref="T:System.Linq.Expressions.ExpressionType" /> da expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.Type">
      <summary>Obtém o tipo estático da expressão que esse <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>O <see cref="P:System.Linq.Expressions.LoopExpression.Type" /> que representa o tipo estático da expressão.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberAssignment">
      <summary>Representa a operação de atribuição para um campo ou propriedade de um objeto.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MemberAssignment.Update(System.Linq.Expressions.Expression)">
      <summary>Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="expression">A propriedade <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> do resultado.</param>
      <returns>Essa expressão se nenhum filho foi alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberAssignment.Expression">
      <summary>Obtém a expressão a ser atribuída ao campo ou à propriedade.</summary>
      <returns>O <see cref="T:System.Linq.Expressions.Expression" /> que representa o valor a ser atribuído ao campo ou à propriedade.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberBinding">
      <summary>Fornece a classe base da qual derivam as classes que representam as associações que são usadas para inicializar os membros de derivação de um objeto recém-criado.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MemberBinding.#ctor(System.Linq.Expressions.MemberBindingType,System.Reflection.MemberInfo)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Linq.Expressions.MemberBinding" />.</summary>
      <param name="type">O <see cref="T:System.Linq.Expressions.MemberBindingType" /> que discrimina o tipo de associação representado.</param>
      <param name="member">O <see cref="T:System.Reflection.MemberInfo" /> que representa um campo ou propriedade a ser inicializado.</param>
    </member>
    <member name="M:System.Linq.Expressions.MemberBinding.ToString">
      <summary>Retorna uma representação textual de <see cref="T:System.Linq.Expressions.MemberBinding" />.</summary>
      <returns>Uma representação textual de <see cref="T:System.Linq.Expressions.MemberBinding" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberBinding.BindingType">
      <summary>Obtém o tipo de associação representado.</summary>
      <returns>Um dos valores de <see cref="T:System.Linq.Expressions.MemberBindingType" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberBinding.Member">
      <summary>Obtém o campo ou a propriedade a ser inicializado.</summary>
      <returns>O <see cref="T:System.Reflection.MemberInfo" /> que representa o campo ou a propriedade a ser inicializada.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberBindingType">
      <summary>Descreve os tipos de associação usados em objetos <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.Assignment">
      <summary>Uma associação que representa a inicialização de um membro com o valor de uma expressão.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.ListBinding">
      <summary>Uma associação que representa a inicialização de um membro do tipo <see cref="T:System.Collections.IList" /> ou <see cref="T:System.Collections.Generic.ICollection`1" /> de uma lista de elementos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.MemberBinding">
      <summary>Uma associação que representa inicializar recursivamente os membros de um membro.</summary>
    </member>
    <member name="T:System.Linq.Expressions.MemberExpression">
      <summary>Representa o acesso a um campo ou propriedade.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MemberExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Expede o método específico de visita para esse tipo de nó. Por exemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chama o <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor">O visitante com o qual visitar esse nó.</param>
      <returns>O resultado de visitar esse nó.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="expression">A propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> do resultado.</param>
      <returns>Essa expressão se nenhum filho foi alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.Expression">
      <summary>Obtém o objeto recipiente do campo ou da propriedade.</summary>
      <returns>Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o objeto recipiente do campo ou da propriedade.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.Member">
      <summary>Obtém o campo ou a propriedade a ser acessada.</summary>
      <returns>O <see cref="T:System.Reflection.MemberInfo" /> que representa o campo ou a propriedade a ser acessada.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.NodeType">
      <summary>Retorna o tipo de nó deste <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />.</summary>
      <returns>O <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa essa expressão.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberInitExpression">
      <summary>Representa a chamada de um construtor e a inicialização de um ou mais membros do novo objeto.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MemberInitExpression.Reduce">
      <summary>Reduz o <see cref="T:System.Linq.Expressions.MemberInitExpression" /> a uma expressão mais simples.</summary>
      <returns>A expressão reduzida.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberInitExpression.Update(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="newExpression">A propriedade <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> do resultado.</param>
      <param name="bindings">A propriedade <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> do resultado.</param>
      <returns>Essa expressão se nenhum filho foi alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.Bindings">
      <summary>Obtém as associações que descrevem como inicializar os membros do objeto recém-criado.</summary>
      <returns>Um <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> dos <see cref="T:System.Linq.Expressions.MemberBinding" /> objetos que descrevem como inicializar os membros.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.CanReduce">
      <summary>Obtém um valor que indica se o nó da árvore de expressão pode ser reduzido.</summary>
      <returns>
        <see langword="true" /> Se o nó puder ser reduzido; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.NewExpression">
      <summary>Obtém a expressão que representa a chamada do construtor.</summary>
      <returns>Um <see cref="T:System.Linq.Expressions.NewExpression" /> que representa a chamada de construtor.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.NodeType">
      <summary>Retorna o tipo de nó dessa Expressão. Nós de extensão devem retornar <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> ao substituírem esse método.</summary>
      <returns>O <see cref="T:System.Linq.Expressions.ExpressionType" /> da expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.Type">
      <summary>Obtém o tipo estático da expressão que esse <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>O <see cref="P:System.Linq.Expressions.MemberInitExpression.Type" /> que representa o tipo estático da expressão.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberListBinding">
      <summary>Representa os elementos de inicialização de um membro da coleção de um objeto recém-criado.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MemberListBinding.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="initializers">A propriedade <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> do resultado.</param>
      <returns>Essa expressão se nenhum filho foi alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberListBinding.Initializers">
      <summary>Obtém os inicializadores de elemento para inicializar um membro da coleção de um objeto recém-criado.</summary>
      <returns>Um <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> dos <see cref="T:System.Linq.Expressions.ElementInit" /> objetos para os quais inicializar um membro da coleção.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberMemberBinding">
      <summary>Representa os membros de inicialização de um membro de um objeto recém-criado.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MemberMemberBinding.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="bindings">A propriedade <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> do resultado.</param>
      <returns>Essa expressão se nenhum filho foi alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberMemberBinding.Bindings">
      <summary>Obtém as associações que descrevem como inicializar os membros de um membro.</summary>
      <returns>Um <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> dos <see cref="T:System.Linq.Expressions.MemberBinding" /> objetos que descrevem como inicializar os membros do membro.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MethodCallExpression">
      <summary>Representa uma chamada para um método estático ou uma instância.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Expede o método específico de visita para esse tipo de nó. Por exemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chama o <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor">O visitante com o qual visitar esse nó.</param>
      <returns>O resultado de visitar esse nó.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)">
      <summary>Retorna o argumento no índice, lançando se o índice estiver fora dos limites.  Você não deve usar esse membro.  Ele só é público devido a refatoração de assembly e é usado internamente para otimizações de desempenho.</summary>
      <param name="index">O índice do argumento.</param>
      <returns>Retorna <see cref="T:System.Linq.Expressions.Expression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="object">A propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> do resultado.</param>
      <param name="arguments">A propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> do resultado.</param>
      <returns>Essa expressão se nenhum filho foi alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Arguments">
      <summary>Obtém uma coleção de expressões que representam os argumentos do método chamado.</summary>
      <returns>Um <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> dos <see cref="T:System.Linq.Expressions.Expression" /> objetos que representam os argumentos para o método chamado.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Method">
      <summary>Obtém o <see cref="T:System.Reflection.MethodInfo" /> para o método a ser chamado.</summary>
      <returns>O <see cref="T:System.Reflection.MethodInfo" /> que representa o método chamado.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.NodeType">
      <summary>Retorna o tipo de nó deste <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>O <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa essa expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Object">
      <summary>Obtém o <see cref="T:System.Linq.Expressions.Expression" /> que representa a instância para chamadas de método de instância ou nulo para chamadas de método estático.</summary>
      <returns>Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o objeto de recebimento do método.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount">
      <summary>Retorna o número de argumentos para o nó de árvore de expressão.  Você não deve usar esse membro.  Ele só é público devido a refatoração de assembly e é usado internamente para otimizações de desempenho.</summary>
      <returns>O número de argumentos para o nó da árvore de expressão como  <see cref="T:System.Int32" /> .</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Type">
      <summary>Obtém o tipo estático da expressão que esse <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>O <see cref="P:System.Linq.Expressions.MethodCallExpression.Type" /> que representa o tipo estático da expressão.</returns>
    </member>
    <member name="T:System.Linq.Expressions.NewArrayExpression">
      <summary>Representa a criação de uma nova matriz e possível inicialização dos elementos da nova matriz.</summary>
    </member>
    <member name="M:System.Linq.Expressions.NewArrayExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Expede o método específico de visita para esse tipo de nó. Por exemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chama o <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor">O visitante com o qual visitar esse nó.</param>
      <returns>O resultado de visitar esse nó.</returns>
    </member>
    <member name="M:System.Linq.Expressions.NewArrayExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="expressions">A propriedade <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> do resultado.</param>
      <returns>Essa expressão se nenhum filho foi alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewArrayExpression.Expressions">
      <summary>Obterá os limites da matriz se o valor da propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> for <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" />, ou os valores para inicializar os elementos da nova matriz se o valor da propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> for <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" />.</summary>
      <returns>Um <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> dos <see cref="T:System.Linq.Expressions.Expression" /> objetos que representam os limites da matriz ou os valores de inicialização.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewArrayExpression.Type">
      <summary>Obtém o tipo estático da expressão que esse <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>O <see cref="P:System.Linq.Expressions.NewArrayExpression.Type" /> que representa o tipo estático da expressão.</returns>
    </member>
    <member name="T:System.Linq.Expressions.NewExpression">
      <summary>Representa uma chamada de construtor.</summary>
    </member>
    <member name="M:System.Linq.Expressions.NewExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Expede o método específico de visita para esse tipo de nó. Por exemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chama o <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor">O visitante com o qual visitar esse nó.</param>
      <returns>O resultado de visitar esse nó.</returns>
    </member>
    <member name="M:System.Linq.Expressions.NewExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)">
      <summary>Retorna o argumento no índice, lançando se o índice estiver fora dos limites.</summary>
      <param name="index">O índice do argumento.</param>
      <returns>O argumento no índice, lançando se o índice estiver fora dos limites.</returns>
    </member>
    <member name="M:System.Linq.Expressions.NewExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="arguments">A propriedade <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> do resultado.</param>
      <returns>Essa expressão se nenhum filho foi alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Arguments">
      <summary>Obtém os argumentos para o construtor.</summary>
      <returns>Uma coleção de <see cref="T:System.Linq.Expressions.Expression" /> objetos que representam os argumentos para o construtor.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Constructor">
      <summary>Obtém o construtor chamado.</summary>
      <returns>O <see cref="T:System.Reflection.ConstructorInfo" /> que representa o construtor chamado.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Members">
      <summary>Obtém os membros que podem recuperar os valores dos campos que foram inicializados com os argumentos de construtor.</summary>
      <returns>Uma coleção de <see cref="T:System.Reflection.MemberInfo" /> objetos que representam os membros que podem recuperar os valores dos campos que foram inicializados com argumentos de construtor.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.NodeType">
      <summary>Retorna o tipo de nó deste <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>O <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa essa expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount">
      <summary>Obtém o número de argumentos para o nó de árvore de expressão.</summary>
      <returns>O número de argumentos para o nó da árvore de expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Type">
      <summary>Obtém o tipo estático da expressão que esse <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>O <see cref="P:System.Linq.Expressions.NewExpression.Type" /> que representa o tipo estático da expressão.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ParameterExpression">
      <summary>Representa uma expressão de parâmetro nomeada.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ParameterExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Expede o método específico de visita para esse tipo de nó. Por exemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chama o <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor">O visitante com o qual visitar esse nó.</param>
      <returns>O resultado de visitar esse nó.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.IsByRef">
      <summary>Indica que esta <c>ParameterExpression</c> deve ser tratada como um parâmetro <see langword="ByRef" />.</summary>
      <returns>
        <see langword="true" /> Se essa <c>parameterid</c> for um <see langword="ByRef" /> parâmetro; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.Name">
      <summary>Obtém o nome do parâmetro ou variável.</summary>
      <returns>Uma <see cref="T:System.String" /> que contém o nome do parâmetro.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.NodeType">
      <summary>Retorna o tipo de nó deste <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>O <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa essa expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.Type">
      <summary>Obtém o tipo estático da expressão que esse <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>O <see cref="P:System.Linq.Expressions.ParameterExpression.Type" /> que representa o tipo estático da expressão.</returns>
    </member>
    <member name="T:System.Linq.Expressions.RuntimeVariablesExpression">
      <summary>Uma expressão que fornece permissões de leitura/gravação em runtime para variáveis.</summary>
    </member>
    <member name="M:System.Linq.Expressions.RuntimeVariablesExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="variables">A propriedade <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> do resultado.</param>
      <returns>Essa expressão se nenhum filho foi alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.NodeType">
      <summary>Retorna o tipo de nó dessa Expressão. Nós de extensão devem retornar <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> ao substituírem esse método.</summary>
      <returns>O <see cref="T:System.Linq.Expressions.ExpressionType" /> da expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.Type">
      <summary>Obtém o tipo estático da expressão que esse <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>O <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Type" /> que representa o tipo estático da expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables">
      <summary>As variáveis ou parâmetros aos quais fornecer acesso de runtime.</summary>
      <returns>A coleção somente leitura que contém parâmetros que receberão o acesso de tempo de execução.</returns>
    </member>
    <member name="T:System.Linq.Expressions.SwitchCase">
      <summary>Representa uma ocorrência de um <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.SwitchCase.ToString">
      <summary>Retorna um valor <see cref="T:System.String" /> que representa o <see cref="T:System.Object" /> atual.</summary>
      <returns>Um <see cref="T:System.String" /> que representa o <see cref="T:System.Object" /> atual.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchCase.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Linq.Expressions.Expression)">
      <summary>Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="testValues">A propriedade <see cref="P:System.Linq.Expressions.SwitchCase.TestValues" /> do resultado.</param>
      <param name="body">A propriedade <see cref="P:System.Linq.Expressions.SwitchCase.Body" /> do resultado.</param>
      <returns>Essa expressão se nenhum filho foi alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchCase.Body">
      <summary>Obtém o corpo do caso.</summary>
      <returns>O <see cref="T:System.Linq.Expressions.Expression" /> objeto que representa o corpo do bloco de caso.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchCase.TestValues">
      <summary>Obtém os valores do caso. Esse caso é selecionado para execução quando o <see cref="P:System.Linq.Expressions.SwitchExpression.SwitchValue" /> corresponde a qualquer um desses valores.</summary>
      <returns>A coleção somente leitura dos valores para esse bloco de caso.</returns>
    </member>
    <member name="T:System.Linq.Expressions.SwitchExpression">
      <summary>Representa uma expressão de controle que trata de várias seleções passando o controle para <see cref="T:System.Linq.Expressions.SwitchCase" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.SwitchExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase},System.Linq.Expressions.Expression)">
      <summary>Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="switchValue">A propriedade <see cref="P:System.Linq.Expressions.SwitchExpression.SwitchValue" /> do resultado.</param>
      <param name="cases">A propriedade <see cref="P:System.Linq.Expressions.SwitchExpression.Cases" /> do resultado.</param>
      <param name="defaultBody">A propriedade <see cref="P:System.Linq.Expressions.SwitchExpression.DefaultBody" /> do resultado.</param>
      <returns>Essa expressão se nenhum filho foi alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Cases">
      <summary>Obtém a coleção de objetos <see cref="T:System.Linq.Expressions.SwitchCase" /> para o comutador.</summary>
      <returns>A coleção de objetos <see cref="T:System.Linq.Expressions.SwitchCase" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Comparison">
      <summary>Obtém o método de comparação de igualdade, se houver.</summary>
      <returns>O <see cref="T:System.Reflection.MethodInfo" /> objeto que representa o método de comparação de igualdade.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.DefaultBody">
      <summary>Obtém o teste para o comutador.</summary>
      <returns>O <see cref="T:System.Linq.Expressions.Expression" /> objeto que representa o teste para a opção.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.NodeType">
      <summary>Retorna o tipo de nó dessa Expressão. Nós de extensão devem retornar <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> ao substituírem esse método.</summary>
      <returns>O <see cref="T:System.Linq.Expressions.ExpressionType" /> da expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.SwitchValue">
      <summary>Obtém o teste para o comutador.</summary>
      <returns>O <see cref="T:System.Linq.Expressions.Expression" /> objeto que representa o teste para a opção.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Type">
      <summary>Obtém o tipo estático da expressão que esse <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>O <see cref="P:System.Linq.Expressions.SwitchExpression.Type" /> que representa o tipo estático da expressão.</returns>
    </member>
    <member name="T:System.Linq.Expressions.SymbolDocumentInfo">
      <summary>Armazena as informações necessárias para emitir informações de símbolo de depuração para um arquivo de origem, especificamente o nome do arquivo e o identificador de linguagem exclusivo.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType">
      <summary>Retorna o identificador exclusivo do tipo do documento, se houver. Define GUID como padrão para um arquivo de texto.</summary>
      <returns>O identificador exclusivo do tipo de documento.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.FileName">
      <summary>O nome do arquivo de origem.</summary>
      <returns>A cadeia de caracteres que representa o nome do arquivo de origem.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.Language">
      <summary>Retorna o identificador exclusivo da linguagem, se houver.</summary>
      <returns>O identificador exclusivo do idioma</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor">
      <summary>Retorna o identificador exclusivo do fornecedor da linguagem, se houver.</summary>
      <returns>O identificador exclusivo do fornecedor do idioma.</returns>
    </member>
    <member name="T:System.Linq.Expressions.TryExpression">
      <summary>Representa um bloco try/catch/finally/fault.</summary>
    </member>
    <member name="M:System.Linq.Expressions.TryExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock},System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="body">A propriedade <see cref="P:System.Linq.Expressions.TryExpression.Body" /> do resultado.</param>
      <param name="handlers">A propriedade <see cref="P:System.Linq.Expressions.TryExpression.Handlers" /> do resultado.</param>
      <param name="finally">A propriedade <see cref="P:System.Linq.Expressions.TryExpression.Finally" /> do resultado.</param>
      <param name="fault">A propriedade <see cref="P:System.Linq.Expressions.TryExpression.Fault" /> do resultado.</param>
      <returns>Essa expressão se nenhum filho foi alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Body">
      <summary>Obtém o <see cref="T:System.Linq.Expressions.Expression" /> que representa o corpo do bloco try.</summary>
      <returns>O <see cref="T:System.Linq.Expressions.Expression" /> que representa o corpo do bloco try.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Fault">
      <summary>Obtém o <see cref="T:System.Linq.Expressions.Expression" /> que representa o bloco de falha.</summary>
      <returns>O <see cref="T:System.Linq.Expressions.Expression" /> que representa o bloco de falha.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Finally">
      <summary>Obtém o <see cref="T:System.Linq.Expressions.Expression" /> que representa o bloco finally.</summary>
      <returns>O <see cref="T:System.Linq.Expressions.Expression" /> que representa o bloco finally.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Handlers">
      <summary>Obtém a coleção de expressões <see cref="T:System.Linq.Expressions.CatchBlock" /> associadas ao bloco try.</summary>
      <returns>A coleção de <see cref="T:System.Linq.Expressions.CatchBlock" /> expressões associadas ao bloco try.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.NodeType">
      <summary>Retorna o tipo de nó deste <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>O <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa essa expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Type">
      <summary>Obtém o tipo estático da expressão que esse <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>O <see cref="P:System.Linq.Expressions.TryExpression.Type" /> que representa o tipo estático da expressão.</returns>
    </member>
    <member name="T:System.Linq.Expressions.TypeBinaryExpression">
      <summary>Representa uma operação entre uma expressão e um tipo.</summary>
    </member>
    <member name="M:System.Linq.Expressions.TypeBinaryExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="expression">A propriedade <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> do resultado.</param>
      <returns>Essa expressão se nenhum filho foi alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.Expression">
      <summary>Obtém o operando de expressão de uma operação de teste de tipo.</summary>
      <returns>Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o operando de expressão de uma operação de teste de tipo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.NodeType">
      <summary>Retorna o tipo de nó dessa Expressão. Nós de extensão devem retornar <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> ao substituírem esse método.</summary>
      <returns>O <see cref="T:System.Linq.Expressions.ExpressionType" /> da expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.Type">
      <summary>Obtém o tipo estático da expressão que esse <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> representa.</summary>
      <returns>O <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Type" /> que representa o tipo estático da expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand">
      <summary>Obtém o operando de tipo de uma operação de teste de tipo.</summary>
      <returns>Um <see cref="T:System.Type" /> que representa o operando de tipo de uma operação de teste de tipo.</returns>
    </member>
    <member name="T:System.Linq.Expressions.UnaryExpression">
      <summary>Representa uma expressão com um operador unário.</summary>
    </member>
    <member name="M:System.Linq.Expressions.UnaryExpression.Reduce">
      <summary>Reduz o nó de expressão para uma expressão mais simples.</summary>
      <returns>A expressão reduzida.</returns>
    </member>
    <member name="M:System.Linq.Expressions.UnaryExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="operand">A propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> do resultado.</param>
      <returns>Essa expressão se nenhum filho foi alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.CanReduce">
      <summary>Obtém um valor que indica se o nó da árvore de expressão pode ser reduzido.</summary>
      <returns>
        <see langword="true" /> se um nó puder ser reduzido; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.IsLifted">
      <summary>Obtém um valor que indica se o nó da árvore de expressão representa uma chamada cancelada a um operador.</summary>
      <returns>
        <see langword="true" /> Se o nó representa uma chamada levantada; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.IsLiftedToNull">
      <summary>Obtém um valor que indica se o nó da árvore de expressão representa uma chamada cancelada a um operador cujo tipo de retorno é elevado para um tipo que permite valor nulo.</summary>
      <returns>
        <see langword="true" /> Se o tipo de retorno do operador for elevado para um tipo anulável; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Method">
      <summary>Obtém o método de implementação para a operação unária.</summary>
      <returns>O <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.NodeType">
      <summary>Retorna o tipo de nó deste <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>O <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa essa expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Operand">
      <summary>Obtém o operando da operação unária.</summary>
      <returns>Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o operando da operação unária.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Type">
      <summary>Obtém o tipo estático da expressão que esse <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>O <see cref="P:System.Linq.Expressions.UnaryExpression.Type" /> que representa o tipo estático da expressão.</returns>
    </member>
    <member name="T:System.Linq.IOrderedQueryable">
      <summary>Representa o resultado de uma operação de classificação.</summary>
    </member>
    <member name="T:System.Linq.IOrderedQueryable`1">
      <summary>Representa o resultado de uma operação de classificação.</summary>
      <typeparam name="T">O tipo de conteúdo da fonte de dados.</typeparam>
    </member>
    <member name="T:System.Linq.IQueryable">
      <summary>Fornece a funcionalidade para avaliar as consultas em uma fonte de dados específica no qual o tipo de dado não foi especificado.</summary>
    </member>
    <member name="P:System.Linq.IQueryable.ElementType">
      <summary>Obtém o tipo de elemento que é retornado quando a árvore de expressão associada a esta instância do <see cref="T:System.Linq.IQueryable" /> é executada.</summary>
      <returns>Um <see cref="T:System.Type" /> que representa o tipo de elemento que é retornado quando a árvore de expressão associada a este objeto é executada.</returns>
    </member>
    <member name="P:System.Linq.IQueryable.Expression">
      <summary>Obtém a árvore de expressão que é associada à instância de <see cref="T:System.Linq.IQueryable" />.</summary>
      <returns>A <see cref="T:System.Linq.Expressions.Expression" /> associada a essa instância de <see cref="T:System.Linq.IQueryable" />.</returns>
    </member>
    <member name="P:System.Linq.IQueryable.Provider">
      <summary>Obtém o provedor de consulta associado esta fonte de dados.</summary>
      <returns>A <see cref="T:System.Linq.IQueryProvider" /> associado a essa fonte de dados.</returns>
    </member>
    <member name="T:System.Linq.IQueryable`1">
      <summary>Fornece a funcionalidade para avaliar as consultas em uma fonte de dados específica no qual o tipo de dado é conhecido.</summary>
      <typeparam name="T">O tipo de dados na fonte de dados.</typeparam>
    </member>
    <member name="T:System.Linq.IQueryProvider">
      <summary>Define métodos para criar e executar consultas que são descritas por um objeto <see cref="T:System.Linq.IQueryable" />.</summary>
    </member>
    <member name="M:System.Linq.IQueryProvider.CreateQuery(System.Linq.Expressions.Expression)">
      <summary>Constrói um objeto <see cref="T:System.Linq.IQueryable" /> que pode avaliar a consulta representada por uma árvore de expressão especificada.</summary>
      <param name="expression">Uma árvore de expressão que representa uma consulta LINQ.</param>
      <returns>Um objeto <see cref="T:System.Linq.IQueryable" /> que pode avaliar a consulta representada pela árvore de expressão especificada.</returns>
    </member>
    <member name="M:System.Linq.IQueryProvider.CreateQuery``1(System.Linq.Expressions.Expression)">
      <summary>Constrói um objeto <see cref="T:System.Linq.IQueryable`1" /> que pode avaliar a consulta representada por uma árvore de expressão especificada.</summary>
      <param name="expression">Uma árvore de expressão que representa uma consulta LINQ.</param>
      <typeparam name="TElement">O tipo dos elementos do <see cref="T:System.Linq.IQueryable`1" /> que é retornado.</typeparam>
      <returns>Um objeto <see cref="T:System.Linq.IQueryable`1" /> que pode avaliar a consulta representada pela árvore de expressão especificada.</returns>
    </member>
    <member name="M:System.Linq.IQueryProvider.Execute(System.Linq.Expressions.Expression)">
      <summary>Executa a consulta representada por uma árvore de expressão especificada.</summary>
      <param name="expression">Uma árvore de expressão que representa uma consulta LINQ.</param>
      <returns>O valor resultante da execução da consulta especificada.</returns>
    </member>
    <member name="M:System.Linq.IQueryProvider.Execute``1(System.Linq.Expressions.Expression)">
      <summary>Executa a consulta fortemente tipada representada por uma árvore de expressão especificada.</summary>
      <param name="expression">Uma árvore de expressão que representa uma consulta LINQ.</param>
      <typeparam name="TResult">O tipo do valor resultante da execução da consulta.</typeparam>
      <returns>O valor resultante da execução da consulta especificada.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.CallSite">
      <summary>Uma classe base de sites dinâmicos de chamada. Esse tipo é usado como um tipo de parâmetro para os destinos de site dinâmicos.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSite.Create(System.Type,System.Runtime.CompilerServices.CallSiteBinder)">
      <summary>Cria um site de chamada com o associador e o tipo de delegado fornecidos.</summary>
      <param name="delegateType">O tipo de delegado do site de chamada.</param>
      <param name="binder">O associador do site de chamada.</param>
      <returns>O novo site de chamada.</returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.CallSite.Binder">
      <summary>Classe responsável pela associação das operações dinâmicas no site dinâmico.</summary>
      <returns>O <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> objeto responsável por associar operações dinâmicas.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.CallSite`1">
      <summary>Tipo de site dinâmico.</summary>
      <typeparam name="T">O tipo de delegado.</typeparam>
    </member>
    <member name="F:System.Runtime.CompilerServices.CallSite`1.Target">
      <summary>O cache de Nível 0 – um delegado especializado com base no histórico do site.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSite`1.Create(System.Runtime.CompilerServices.CallSiteBinder)">
      <summary>Cria uma instância do site de chamada dinâmico, inicializada com o associador responsável pela associação em runtime das operações dinâmicas neste site de chamada.</summary>
      <param name="binder">O associador responsável pela associação em runtime das operações dinâmicas neste site de chamada.</param>
      <returns>A nova instância do site de chamada dinâmico.</returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.CallSite`1.Update">
      <summary>O delegado de atualização. Chamado quando o site dinâmico apresenta perda no cache.</summary>
      <returns>O delegado de atualização.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.CallSiteBinder">
      <summary>Classe responsável pela associação em runtime das operações dinâmicas no site de chamada dinâmico.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSiteBinder.#ctor">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSiteBinder.Bind(System.Object[],System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.LabelTarget)">
      <summary>Executa a associação em runtime da operação dinâmica em um conjunto de argumentos.</summary>
      <param name="args">Uma matriz de argumentos para a operação dinâmica.</param>
      <param name="parameters">A matriz de instâncias de <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representam os parâmetros do site de chamada no processo de associação.</param>
      <param name="returnLabel">Um LabelTarget usado para retornar o resultado da associação dinâmica.</param>
      <returns>Uma expressão que executa testes nos argumentos de operação dinâmica e executa a operação dinâmica se os testes forem válidos. Se os testes falham em ocorrências posteriores da operação dinâmica, Bind será chamado novamente para gerar um novo <see cref="T:System.Linq.Expressions.Expression" /> para os novos tipos de argumento.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSiteBinder.BindDelegate``1(System.Runtime.CompilerServices.CallSite{``0},System.Object[])">
      <summary>Dá suporte à associação em runtime de baixo nível. As classes podem substituir isso e fornecer um delegado direto para a implementação da regra. Isso pode habilitar o salvamento de regras em disco, a presença de regras especializadas disponíveis em runtime ou o fornecimento de uma política diferente de armazenamento em cache.</summary>
      <param name="site">O CallSite para o qual a associação está sendo executada.</param>
      <param name="args">Os argumentos para o associador.</param>
      <typeparam name="T">O tipo de destino do chamada.</typeparam>
      <returns>Um novo delegado que substitui o destino de CallSite.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSiteBinder.CacheTarget``1(``0)">
      <summary>Adiciona um destino ao cache de destinos conhecidos. Os destinos armazenados em cache serão verificados antes de chamar BindDelegate para produzir a nova regra.</summary>
      <param name="target">O delegado de destino a ser adicionado ao cache.</param>
      <typeparam name="T">O tipo de destino que está sendo adicionado.</typeparam>
    </member>
    <member name="P:System.Runtime.CompilerServices.CallSiteBinder.UpdateLabel">
      <summary>Obtém um rótulo que pode ser usado para fazer com que a associação seja atualizada. Indica que a associação da expressão deixou de ser válida. Normalmente, é usado quando a "versão" de um objeto dinâmico foi alterada.</summary>
      <returns>O <see cref="T:System.Linq.Expressions.LabelTarget" /> objeto que representa um rótulo que pode ser usado para disparar a atualização de associação.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.CallSiteHelpers">
      <summary>Classe que contém métodos auxiliares para CallSites do DLR.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSiteHelpers.IsInternalFrame(System.Reflection.MethodBase)">
      <summary>Verifica se um <see cref="T:System.Reflection.MethodBase" /> é usado internamente pelo DLR e não deve ser exibido na pilha do código de linguagem.</summary>
      <param name="mb">A entrada <see cref="T:System.Reflection.MethodBase" /></param>
      <returns>
        <see langword="true" /> se um <see cref="T:System.Reflection.MethodBase" /> for usado internamente pelo DLR e não precisar ser exibido na pilha do código de linguagem. Caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.DebugInfoGenerator">
      <summary>Gera informações de depuração para expressões lambda em uma árvore de expressão.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.DebugInfoGenerator.#ctor">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Runtime.CompilerServices.DebugInfoGenerator" />.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.DebugInfoGenerator.CreatePdbGenerator">
      <summary>Cria um gerador de símbolo PDB (banco de dados de programa).</summary>
      <returns>Um gerador de símbolo PDB.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.DebugInfoGenerator.MarkSequencePoint(System.Linq.Expressions.LambdaExpression,System.Int32,System.Linq.Expressions.DebugInfoExpression)">
      <summary>Marca um ponto de sequência no código de MSIL (Microsoft Intermediate Language).</summary>
      <param name="method">A expressão lambda que é gerada.</param>
      <param name="ilOffset">O deslocamento dentro do código MSIL no qual marcar o ponto de sequência.</param>
      <param name="sequencePoint">Informações de depuração que correspondem ao ponto de sequência.</param>
    </member>
    <member name="T:System.Runtime.CompilerServices.DynamicAttribute">
      <summary>Indica que o uso do <see cref="T:System.Object" /> em um membro deve ser tratado como um tipo expedido dinamicamente.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.DynamicAttribute.#ctor">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Runtime.CompilerServices.DynamicAttribute" />.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.DynamicAttribute.#ctor(System.Boolean[])">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Runtime.CompilerServices.DynamicAttribute" />.</summary>
      <param name="transformFlags">Especifica, em uma passagem de prefixo de construção de um tipo, que ocorrências <see cref="T:System.Object" /> devem ser tratadas como um tipo expedido dinamicamente.</param>
    </member>
    <member name="P:System.Runtime.CompilerServices.DynamicAttribute.TransformFlags">
      <summary>Especifica, em uma passagem de prefixo de construção de um tipo, que ocorrências <see cref="T:System.Object" /> devem ser tratadas como um tipo expedido dinamicamente.</summary>
      <returns>A lista de <see cref="T:System.Object" /> ocorrências que devem ser tratadas como um tipo expedido dinamicamente.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.IRuntimeVariables">
      <summary>Representa os valores das variáveis de tempo de execução.</summary>
    </member>
    <member name="P:System.Runtime.CompilerServices.IRuntimeVariables.Count">
      <summary>Obtém uma contagem das variáveis de tempo de execução.</summary>
      <returns>O número de variáveis de tempo de execução.</returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.IRuntimeVariables.Item(System.Int32)">
      <summary>Obtém o valor da variável de tempo de execução no índice especificado.</summary>
      <param name="index">O índice baseado em zero da variável de tempo de execução cujo valor será retornado.</param>
      <returns>O valor da variável de tempo de execução.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1">
      <summary>O construtor para coleção somente leitura.</summary>
      <typeparam name="T">O tipo do elemento de coleção.</typeparam>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.#ctor">
      <summary>Constrói um <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>Constrói um <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />, copiando o conteúdo da coleção fornecida.</summary>
      <param name="collection">Coleção da qual copiar elementos.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.#ctor(System.Int32)">
      <summary>Constrói um <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> com uma capacidade inicial fornecida. O conteúdo está vazio, mas o construtor terá reservado espaço para o número fornecido de elementos antes que as realocações sejam necessárias.</summary>
      <param name="capacity">Capacidade inicial.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Add(`0)">
      <summary>Adiciona um item ao <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
      <param name="item">O objeto a ser adicionado ao <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Clear">
      <summary>Remove todos os itens do <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Contains(`0)">
      <summary>Determinará se o <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> contiver um valor específico.</summary>
      <param name="item">o objeto a ser localizado no <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</param>
      <returns>
        <see langword="true" /> se o item for encontrado no <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.CopyTo(`0[],System.Int32)">
      <summary>Copia os elementos do <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> para um <see cref="T:System.Array" />, começando em no índice <see cref="T:System.Array" /> determinado.</summary>
      <param name="array">O <see cref="T:System.Array" /> unidimensional que é o destino dos elementos copiados de <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</param>
      <param name="arrayIndex">O índice de base zero na matriz no qual a cópia começa.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.GetEnumerator">
      <summary>Retorna um enumerador que itera pela coleção.</summary>
      <returns>Um <see cref="T:System.Collections.Generic.IEnumerator`1" /> que pode ser usado para ser iterado por meio da coleção.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.IndexOf(`0)">
      <summary>Retorna o índice da primeira ocorrência de um valor fornecido no construtor.</summary>
      <param name="item">Um item a ser pesquisado.</param>
      <returns>O índice da primeira ocorrência de um item.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Insert(System.Int32,`0)">
      <summary>Insere um item na <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> no índice especificado.</summary>
      <param name="index">O índice baseado em zero no qual o item deve ser inserido.</param>
      <param name="item">O objeto a ser inserido no <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Remove(`0)">
      <summary>Remove a primeira ocorrência de um objeto específico do <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
      <param name="item">O objeto a remover do <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</param>
      <returns>
        <see langword="true" /> se o item foi removido com êxito do <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />; caso contrário, false. Esse método também retornará false se o item não for encontrado no <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> original.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.RemoveAt(System.Int32)">
      <summary>Remove o item <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> no índice especificado.</summary>
      <param name="index">O índice com base em zero do item a ser removido.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Reverse">
      <summary>Inverte a ordem dos elementos em todo o <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Reverse(System.Int32,System.Int32)">
      <summary>Inverte a ordem dos elementos no intervalo especificado.</summary>
      <param name="index">O índice inicial baseado em zero do intervalo a ser revertido.</param>
      <param name="count">O número de elementos no intervalo a serem revertidos.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
      <summary>Copia os elementos do <see cref="T:System.Collections.Generic.ICollection`1" /> para uma matriz, começando no índice da matriz especificada.</summary>
      <param name="array">A matriz unidimensional que é o destino dos elementos copiados de <see cref="T:System.Collections.Generic.ICollection`1" />. A matriz deve ter indexação com base em zero.</param>
      <param name="index">O índice com base em zero em <paramref name="array" /> no qual a cópia começa.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retorna um enumerador que itera pela coleção.</summary>
      <returns>Um <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#Add(System.Object)">
      <summary>Adiciona um item ao <see cref="T:System.Collections.IList" />.</summary>
      <param name="value">O <see cref="T:System.Object" /> para adicionar ao <see cref="T:System.Collections.IList" />.</param>
      <returns>A posição na qual o novo elemento foi inserido.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#Contains(System.Object)">
      <summary>Determinará se o <see cref="T:System.Collections.IList" /> contiver um valor específico.</summary>
      <param name="value">O <see cref="T:System.Object" /> a ser localizado no <see cref="T:System.Collections.IList" />.</param>
      <returns>
        <see langword="true" /> se <paramref name="item" /> for encontrado no <see cref="T:System.Collections.IList" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#IndexOf(System.Object)">
      <summary>Determina o índice de um item específico em <see cref="T:System.Collections.IList" />.</summary>
      <param name="value">O objeto a ser localizado no <see cref="T:System.Collections.IList" />.</param>
      <returns>O índice de <paramref name="item" /> se encontrado na lista; caso contrário, -1.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#Insert(System.Int32,System.Object)">
      <summary>Insere um item na <see cref="T:System.Collections.IList" /> no índice especificado.</summary>
      <param name="index">O índice de base zero no qual o <paramref name="item" /> deve ser inserido.</param>
      <param name="value">O objeto a ser inserido no <see cref="T:System.Collections.IList" />.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#Remove(System.Object)">
      <summary>Remove a primeira ocorrência de um objeto específico do <see cref="T:System.Collections.IList" />.</summary>
      <param name="value">O objeto a remover do <see cref="T:System.Collections.IList" />.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.ToArray">
      <summary>Copia os elementos do <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> em uma nova matriz.</summary>
      <returns>Uma matriz que contém cópias dos elementos do <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.ToReadOnlyCollection">
      <summary>Cria um <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> que contém todos os elementos do <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />, evitando copiar os elementos para a nova matriz, se possível. Redefinirá o <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> depois que o <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> tiver sido criado.</summary>
      <returns>Uma nova instância de <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Capacity">
      <summary>Obtém ou define a capacidade deste <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
      <returns>A capacidade deste <c>ReadOnlyCollectionBuilder.</c></returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Count">
      <summary>Obtém o número de elementos no <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
      <returns>O número de elementos em <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Item(System.Int32)">
      <summary>Obtém ou define o elemento no índice especificado.</summary>
      <param name="index">O índice com base em zero do elemento a ser obtido ou definido.</param>
      <returns>O elemento no índice especificado.</returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
      <summary>Obtém um valor que indica se o <see cref="T:System.Collections.Generic.ICollection`1" /> é somente leitura.</summary>
      <returns>
        <see langword="true" /> se o <see cref="T:System.Collections.Generic.ICollection`1" /> for somente leitura; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#ICollection#IsSynchronized">
      <summary>Obtém um valor que indica se o acesso à <see cref="T:System.Collections.ICollection" /> é sincronizado (thread-safe).</summary>
      <returns>
        <see langword="true" /> caso o acesso ao <see cref="T:System.Collections.ICollection" /> seja sincronizado (thread-safe); do contrário, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#ICollection#SyncRoot">
      <summary>Obtém um objeto que pode ser usado para sincronizar o acesso ao <see cref="T:System.Collections.ICollection" />.</summary>
      <returns>Um objeto que pode ser usado para sincronizar o acesso à <see cref="T:System.Collections.ICollection" />.</returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#IsFixedSize">
      <summary>Obtém um valor que indica se o <see cref="T:System.Collections.IList" /> tem um tamanho fixo.</summary>
      <returns>
        <see langword="true" /> se o <see cref="T:System.Collections.IList" /> tiver um valor fixo; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#IsReadOnly">
      <summary>Obtém um valor que indica se o <see cref="T:System.Collections.IList" /> é somente leitura.</summary>
      <returns>
        <see langword="true" /> se o <see cref="T:System.Collections.IList" /> for somente leitura; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#Item(System.Int32)">
      <summary>Obtém ou define o elemento no índice especificado.</summary>
      <param name="index">O índice com base em zero do elemento a ser obtido ou definido.</param>
      <returns>O elemento no índice especificado.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.RuleCache`1">
      <summary>Representa um cache de regras de associação em runtime.</summary>
      <typeparam name="T">O tipo de delegado.</typeparam>
    </member>
  </members>
</doc>