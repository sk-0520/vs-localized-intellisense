<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Reflection.Metadata</name>
  </assembly>
  <members>
    <member name="T:System.Reflection.AssemblyFlags" />
    <member name="F:System.Reflection.AssemblyFlags.ContentTypeMask">
      <summary>Le type de contenu masque les bits qui correspondent aux valeurs de <see cref="T:System.Reflection.AssemblyContentType" />.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.DisableJitCompileOptimizer">
      <summary>L'optimisation du compilateur juste-à-temps (JIT) est désactivée pour l'assembly.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.EnableJitCompileTracking">
      <summary>Le suivi du compilateur juste-à-temps (JIT) est activé pour l'assembly.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.PublicKey">
      <summary>La référence d’assembly contient la clé publique complète (non hachée). Non applicable à la définition de l’assembly.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.Retargetable">
      <summary>L’implémentation de l’assembly référencé utilisé au moment de l’exécution n’est pas censée correspondre à la version affichée au moment de la compilation.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.WindowsRuntime">
      <summary>L’assembly contient le code Windows Runtime.</summary>
    </member>
    <member name="T:System.Reflection.AssemblyHashAlgorithm">
      <summary>Spécifie tous les algorithmes de hachage utilisés pour hacher les fichiers d’assembly et pour générer le nom fort.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.MD5">
      <summary>Récupère l'algorithme de message résumé MD5.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.None">
      <summary>Masque indiquant l'absence d'algorithme de hachage.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha1">
      <summary>Récupère une révision de l’algorithme de hachage sécurisé qui corrige un défaut non publié dans SHA.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha256">
      <summary>Récupère une version de l’algorithme de hachage sécurisé avec une taille de hachage de 256 bits.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha384">
      <summary>Récupère une version de l’algorithme de hachage sécurisé avec une taille de hachage de 384 bits.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha512">
      <summary>Récupère une version de l’algorithme de hachage sécurisé avec une taille de hachage de 512 bits.</summary>
    </member>
    <member name="T:System.Reflection.DeclarativeSecurityAction">
      <summary>Spécifie les actions de sécurité qui peuvent être effectuées à l’aide de la sécurité déclarative.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.Assert">
      <summary>Le code appelant peut accéder à la ressource identifiée par l'objet d'autorisation actif, même si les appelants qui sont plus haut dans la pile n'ont pas reçu l'autorisation d'y accéder.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.Demand">
      <summary>Vérifiez que l’autorisation spécifiée a été accordée à tous les appelants dans la chaîne d’appel.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.Deny">
      <summary>Sans vérifications supplémentaires, refusez la demande pour l’autorisation spécifiée.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.InheritanceDemand">
      <summary>La classe dérivée qui hérite de la classe ou qui substitue une méthode doit avoir l’autorisation spécifiée.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.LinkDemand">
      <summary>Vérifiez que l’autorisation spécifiée a été accordée à l’appelant immédiat.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.None">
      <summary>Aucune action de sécurité déclarative.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.PermitOnly">
      <summary>Sans contrôles supplémentaires, refusez la demande pour toutes les autorisations autres que celles spécifiées.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.RequestMinimum">
      <summary>Requête des autorisations minimales pour que le code s’exécute. Cette action ne peut être utilisée que dans la portée de l’assembly.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.RequestOptional">
      <summary>Requête d’autorisations supplémentaires et facultatives (non requises pour l’exécution). Cette requête refuse implicitement toutes les autres autorisations qui ne sont pas spécifiquement demandées. Cette action ne peut être utilisée que dans la portée de l’assembly.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.RequestRefuse">
      <summary>Requête pour que les autorisations qui peuvent être utilisées abusivement ne soient pas accordées au code appelant. Cette action ne peut être utilisée que dans la portée de l’assembly.</summary>
    </member>
    <member name="T:System.Reflection.ManifestResourceAttributes" />
    <member name="F:System.Reflection.ManifestResourceAttributes.Private">
      <summary>La ressource n’est pas exportée à partir de l’assembly.</summary>
    </member>
    <member name="F:System.Reflection.ManifestResourceAttributes.Public">
      <summary>La ressource est exportée à partir de l’assembly.</summary>
    </member>
    <member name="F:System.Reflection.ManifestResourceAttributes.VisibilityMask">
      <summary>Masque uniquement les attributs liés à la visibilité.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ArrayShape">
      <summary>Représente la forme d’un type tableau.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ArrayShape.#ctor(System.Int32,System.Collections.Immutable.ImmutableArray{System.Int32},System.Collections.Immutable.ImmutableArray{System.Int32})">
      <summary>Initialise une nouvelle instance de la structure <see cref="T:System.Reflection.Metadata.ArrayShape" />.</summary>
      <param name="rank">Nombre de dimensions dans le tableau.</param>
      <param name="sizes">Taille de chaque dimension.</param>
      <param name="lowerBounds">Limite inférieure de chaque dimension.</param>
    </member>
    <member name="P:System.Reflection.Metadata.ArrayShape.LowerBounds">
      <summary>Obtient les limites inférieures de toutes les dimensions. La longueur peut être plus petite que le rang, auquel cas les dimensions de fin ont des limites inférieures non spécifiées.</summary>
      <returns>Tableau de limites inférieures.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ArrayShape.Rank">
      <summary>Obtient le nombre de dimensions dans le tableau.</summary>
      <returns>Nombre de dimensions.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ArrayShape.Sizes">
      <summary>Obtient les tailles de toutes les dimensions.</summary>
      <returns>Tableau de tailles.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyDefinition" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinition.GetAssemblyName" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinition.GetDeclarativeSecurityAttributes" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Culture" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Flags" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.HashAlgorithm" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Name" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.PublicKey" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Version" />
    <member name="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.Equals(System.Reflection.Metadata.AssemblyDefinitionHandle)">
      <summary>Indique si l'objet actuel est égal à un autre objet du même type.</summary>
      <param name="other">Objet à comparer à cet objet.</param>
      <returns>
        <see langword="true" /> si l'objet actuel est égal au paramètre <paramref name="other" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Equality(System.Reflection.Metadata.AssemblyDefinitionHandle,System.Reflection.Metadata.AssemblyDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.AssemblyDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.AssemblyDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Implicit(System.Reflection.Metadata.AssemblyDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Implicit(System.Reflection.Metadata.AssemblyDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Inequality(System.Reflection.Metadata.AssemblyDefinitionHandle,System.Reflection.Metadata.AssemblyDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.AssemblyFile" />
    <member name="M:System.Reflection.Metadata.AssemblyFile.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.AssemblyFile.ContainsMetadata">
      <summary>Obtient une valeur qui indique si le fichier contient des métadonnées.</summary>
      <returns>
        <see langword="true" /> Si le fichier contient des métadonnées ; <see langword="false" /> sinon,.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFile.HashValue">
      <summary>Obtient la valeur de hachage calculée à l’aide du contenu du fichier <see cref="P:System.Reflection.Metadata.AssemblyDefinition.HashAlgorithm" />.</summary>
      <returns>
        <see cref="T:System.Reflection.Metadata.BlobHandle" />Instance représentant la valeur de hachage du contenu du fichier.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFile.Name">
      <summary>Obtient le nom de fichier, y compris son extension.</summary>
      <returns>
        <see cref="T:System.Reflection.Metadata.StringHandle" />Instance représentant le nom de fichier avec son extension.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyFileHandle" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.Equals(System.Reflection.Metadata.AssemblyFileHandle)">
      <summary>Indique si l'objet actuel est égal à un autre objet du même type.</summary>
      <param name="other">Objet à comparer à cet objet.</param>
      <returns>
        <see langword="true" /> si l'objet actuel est égal au paramètre <paramref name="other" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Equality(System.Reflection.Metadata.AssemblyFileHandle,System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.AssemblyFileHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.AssemblyFileHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Implicit(System.Reflection.Metadata.AssemblyFileHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Implicit(System.Reflection.Metadata.AssemblyFileHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Inequality(System.Reflection.Metadata.AssemblyFileHandle,System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFileHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.AssemblyFileHandleCollection">
      <summary>Représente une collection de <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#AssemblyFileHandle}#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein de la collection.</summary>
      <returns>Énumérateur permettant d'effectuer une itération au sein de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein d’une collection.</summary>
      <returns>Objet <see cref="T:System.Collections.IEnumerator" /> pouvant être utilisé pour itérer au sein de la collection.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFileHandleCollection.Count">
      <summary>Obtient le nombre d’éléments de la collection.</summary>
      <returns>Nombre d'éléments dans la collection.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.MoveNext">
      <summary>Avance l’énumérateur à l’élément suivant de la collection.</summary>
      <returns>
        <see langword="true" /> si l'énumérateur a pu avancer jusqu'à l'élément suivant ; <see langword="false" /> si l'énumérateur a dépassé la fin de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Rétablit l'énumérateur à sa position initiale, qui précède le premier élément de la collection.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Exécute les tâches définies par l'application associées à la libération ou à la redéfinition des ressources non managées.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyReference" />
    <member name="M:System.Reflection.Metadata.AssemblyReference.GetAssemblyName" />
    <member name="M:System.Reflection.Metadata.AssemblyReference.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Culture" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Flags" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.HashValue" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Name" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.PublicKeyOrToken" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Version" />
    <member name="T:System.Reflection.Metadata.AssemblyReferenceHandle" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.Equals(System.Reflection.Metadata.AssemblyReferenceHandle)">
      <summary>Indique si l'objet actuel est égal à un autre objet du même type.</summary>
      <param name="other">Objet à comparer à cet objet.</param>
      <returns>
        <see langword="true" /> si l'objet actuel est égal au paramètre <paramref name="other" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Equality(System.Reflection.Metadata.AssemblyReferenceHandle,System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.AssemblyReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.AssemblyReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Implicit(System.Reflection.Metadata.AssemblyReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Implicit(System.Reflection.Metadata.AssemblyReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Inequality(System.Reflection.Metadata.AssemblyReferenceHandle,System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.AssemblyReferenceHandleCollection">
      <summary>Collection de références d’assembly.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#AssemblyReferenceHandle}#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein de la collection.</summary>
      <returns>Énumérateur permettant d'effectuer une itération au sein de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein d’une collection.</summary>
      <returns>Objet <see cref="T:System.Collections.IEnumerator" /> pouvant être utilisé pour itérer au sein de la collection.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Count">
      <summary>Obtient le nombre d’éléments de la collection.</summary>
      <returns>Nombre d'éléments dans la collection.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.MoveNext">
      <summary>Avance l’énumérateur à l’élément suivant de la collection.</summary>
      <returns>
        <see langword="true" /> si l'énumérateur a pu avancer jusqu'à l'élément suivant ; <see langword="false" /> si l'énumérateur a dépassé la fin de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Rétablit l'énumérateur à sa position initiale, qui précède le premier élément de la collection.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Exécute les tâches définies par l'application associées à la libération ou à la redéfinition des ressources non managées.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Blob" />
    <member name="M:System.Reflection.Metadata.Blob.GetBytes" />
    <member name="P:System.Reflection.Metadata.Blob.IsDefault" />
    <member name="P:System.Reflection.Metadata.Blob.Length" />
    <member name="T:System.Reflection.Metadata.BlobBuilder" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.#ctor(System.Int32)">
      <param name="capacity" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Align(System.Int32)">
      <param name="alignment" />
      <exception cref="T:System.InvalidOperationException">Le générateur ne peut pas être écrit. Il a été lié à un autre générateur.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.AllocateChunk(System.Int32)">
      <param name="minimalSize" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Clear" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.ContentEquals(System.Reflection.Metadata.BlobBuilder)">
      <summary>Compare le contenu actuel de cet auteur à un autre.</summary>
      <param name="other">Instance <see cref="T:System.Reflection.Metadata.BlobBuilder" /> à comparer à cette instance.</param>
      <exception cref="T:System.InvalidOperationException">Le contenu n’est pas disponible. Le générateur a été lié à un autre générateur.</exception>
      <returns>
        <see langword="true" /> s'ils sont égaux ; sinon <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Free" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.FreeChunk" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.GetBlobs">
      <summary>Retourne une séquence de tous les objets blob qui représentent le contenu du générateur.</summary>
      <exception cref="T:System.InvalidOperationException">Le contenu n’est pas disponible. Le générateur a été lié à un autre générateur.</exception>
      <returns>Séquence d’objets blob.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.LinkPrefix(System.Reflection.Metadata.BlobBuilder)">
      <param name="prefix" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="prefix" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Le générateur ne peut pas être écrit. Il a été lié à un autre générateur.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.LinkSuffix(System.Reflection.Metadata.BlobBuilder)">
      <param name="suffix" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="suffix" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Le générateur ne peut pas être écrit. Il a été lié à un autre générateur.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.PadTo(System.Int32)">
      <param name="position" />
      <exception cref="T:System.InvalidOperationException">Le générateur ne peut pas être écrit. Il a été lié à un autre générateur.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ReserveBytes(System.Int32)">
      <summary>Réserve un bloc contigu d’octets.</summary>
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> est un nombre négatif.</exception>
      <exception cref="T:System.InvalidOperationException">Le générateur ne peut pas être écrit. Il a été lié à un autre générateur.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToArray">
      <exception cref="T:System.InvalidOperationException">Le contenu n’est pas disponible. Le générateur a été lié à un autre générateur.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToArray(System.Int32,System.Int32)">
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">La plage spécifiée par <paramref name="start" /> et <paramref name="byteCount" /> se situe en dehors des limites de contenu de la mémoire tampon.</exception>
      <exception cref="T:System.InvalidOperationException">Le contenu n’est pas disponible. Le générateur a été lié à un autre générateur.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToImmutableArray">
      <exception cref="T:System.InvalidOperationException">Le contenu n’est pas disponible. Le générateur a été lié à un autre générateur.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToImmutableArray(System.Int32,System.Int32)">
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">La plage spécifiée par <paramref name="start" /> et <paramref name="byteCount" /> se situe en dehors des limites de contenu de la mémoire tampon.</exception>
      <exception cref="T:System.InvalidOperationException">Le contenu n’est pas disponible. Le générateur a été lié à un autre générateur.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.TryWriteBytes(System.IO.Stream,System.Int32)">
      <summary>Tente d’écrire une séquence d’octets dans le générateur. Une valeur de retour indique le nombre d’octets écrits avec succès.</summary>
      <param name="source" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> est un nombre négatif.</exception>
      <exception cref="T:System.InvalidOperationException">Le générateur ne peut pas être écrit. Il a été lié à un autre générateur.</exception>
      <returns>Le nombre d’octets écrits avec succès à partir de <paramref name="source" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBoolean(System.Boolean)">
      <summary>Écrit une valeur <see cref="T:System.Boolean" /> dans le générateur.</summary>
      <param name="value">Valeur à écrire.</param>
      <exception cref="T:System.InvalidOperationException">Le générateur ne peut pas être écrit. Il a été lié à un autre générateur.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteByte(System.Byte)">
      <summary>Écrit une valeur <see cref="T:System.Byte" /> dans le générateur.</summary>
      <param name="value">Valeur à écrire.</param>
      <exception cref="T:System.InvalidOperationException">Le générateur ne peut pas être écrit. Il a été lié à un autre générateur.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte*,System.Int32)">
      <summary>Écrit un nombre spécifié d’octets d’une mémoire tampon dans le générateur.</summary>
      <param name="buffer" />
      <param name="byteCount">Nombre d'octets à écrire.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> est un nombre négatif.</exception>
      <exception cref="T:System.InvalidOperationException">Le générateur ne peut pas être écrit. Il a été lié à un autre générateur.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte,System.Int32)">
      <summary>Écrit un nombre spécifié d’occurrences d’une valeur d’octet dans le générateur.</summary>
      <param name="value" />
      <param name="byteCount">Le nombre d’occurrences <paramref name="value" /> à écrire.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> est un nombre négatif.</exception>
      <exception cref="T:System.InvalidOperationException">Le générateur ne peut pas être écrit. Il a été lié à un autre générateur.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte[])">
      <summary>Écrit le contenu d’un tableau d’octets dans le générateur.</summary>
      <param name="buffer">Tableau d'octets à écrire.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Le générateur ne peut pas être écrit. Il a été lié à un autre générateur.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte[],System.Int32,System.Int32)">
      <summary>Écrit un nombre spécifié d’octets commençant à un index spécifié dans un tableau d’octets dans le générateur.</summary>
      <param name="buffer" />
      <param name="start" />
      <param name="byteCount">Nombre d'octets à écrire.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">La plage spécifiée par <paramref name="start" /> et <paramref name="byteCount" /> se situe en dehors des limites de <paramref name="buffer" />.</exception>
      <exception cref="T:System.InvalidOperationException">Le générateur ne peut pas être écrit. Il a été lié à un autre générateur.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>Écrit le contenu d’un tableau d’octets immuable dans le générateur.</summary>
      <param name="buffer">Tableau à écrire.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Le générateur ne peut pas être écrit. Il a été lié à un autre générateur.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte},System.Int32,System.Int32)">
      <summary>Écrit un nombre spécifié d’octets commençant à un index spécifié dans un tableau immuable dans le générateur.</summary>
      <param name="buffer" />
      <param name="start" />
      <param name="byteCount">Nombre d'octets à écrire.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">La plage spécifiée par <paramref name="start" /> et <paramref name="byteCount" /> se situe en dehors des limites de <paramref name="buffer" />.</exception>
      <exception cref="T:System.InvalidOperationException">Le générateur ne peut pas être écrit. Il a été lié à un autre générateur.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteCompressedInteger(System.Int32)">
      <summary>Implémente l’encodage d’entiers non signés compressés tel que défini par le chapitre 23,2 ECMA-335-II : blobs et signatures.</summary>
      <param name="value">Valeur à écrire.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="value" /> ne peut pas être représenté comme un entier non signé compressé.</exception>
      <exception cref="T:System.InvalidOperationException">Le générateur ne peut pas être écrit. Il a été lié à un autre générateur.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteCompressedSignedInteger(System.Int32)">
      <summary>Implémente l’encodage d’entier signé compressé, tel que défini par le chapitre 23,2 de l’ECMA-335-II : blobs et signatures.</summary>
      <param name="value">Valeur à écrire.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="value" /> ne peut pas être représenté comme un entier signé compressé.</exception>
      <exception cref="T:System.InvalidOperationException">Le générateur ne peut pas être écrit. Il a été lié à un autre générateur.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteConstant(System.Object)">
      <summary>Écrit une valeur constante (voir la section 22.9 ECMA-335 Partition II) à la position actuelle.</summary>
      <param name="value">Valeur de constante à écrire.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="value" /> n’est pas d’un type de constante.</exception>
      <exception cref="T:System.InvalidOperationException">Le générateur ne peut pas être écrit. Il a été lié à un autre générateur.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteContentTo(System.IO.Stream)">
      <param name="destination" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="destination" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Le contenu n’est pas disponible. Le générateur a été lié à un autre générateur.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteContentTo(System.Reflection.Metadata.BlobBuilder)">
      <param name="destination" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="destination" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Le contenu n’est pas disponible. Le générateur a été lié à un autre générateur.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteContentTo(System.Reflection.Metadata.BlobWriter@)">
      <param name="destination" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="destination" /> est la valeur par défaut (<see cref="T:System.Reflection.Metadata.BlobWriter" />).</exception>
      <exception cref="T:System.InvalidOperationException">Le contenu n’est pas disponible. Le générateur a été lié à un autre générateur.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteDateTime(System.DateTime)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Le générateur ne peut pas être écrit. Il a été lié à un autre générateur.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteDecimal(System.Decimal)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Le générateur ne peut pas être écrit. Il a été lié à un autre générateur.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteDouble(System.Double)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Le générateur ne peut pas être écrit. Il a été lié à un autre générateur.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteGuid(System.Guid)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Le générateur ne peut pas être écrit. Il a été lié à un autre générateur.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt16(System.Int16)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Le générateur ne peut pas être écrit. Il a été lié à un autre générateur.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt16BE(System.Int16)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Le générateur ne peut pas être écrit. Il a été lié à un autre générateur.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt32(System.Int32)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Le générateur ne peut pas être écrit. Il a été lié à un autre générateur.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt32BE(System.Int32)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Le générateur ne peut pas être écrit. Il a été lié à un autre générateur.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt64(System.Int64)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Le générateur ne peut pas être écrit. Il a été lié à un autre générateur.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteReference(System.Int32,System.Boolean)">
      <summary>Écrit une référence dans un tas (offset de tas) ou une table (nombre de ligne).</summary>
      <param name="reference">Offset de tas ou nombre de ligne d’une table.</param>
      <param name="isSmall">
        <see langword="true" /> pour encoder la référence en tant qu’entier 16 bits, <see langword="false" /> pour encoder en tant qu’entier 32 bits.</param>
      <exception cref="T:System.InvalidOperationException">Le générateur ne peut pas être écrit. Il a été lié à un autre générateur.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteSByte(System.SByte)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Le générateur ne peut pas être écrit. Il a été lié à un autre générateur.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteSerializedString(System.String)">
      <summary>Écrit une chaîne au format SerString (voir Attributs personnalisés 23.3 ECMA-335-II).</summary>
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Le générateur ne peut pas être écrit. Il a été lié à un autre générateur.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteSingle(System.Single)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Le générateur ne peut pas être écrit. Il a été lié à un autre générateur.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt16(System.UInt16)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Le générateur ne peut pas être écrit. Il a été lié à un autre générateur.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt16BE(System.UInt16)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Le générateur ne peut pas être écrit. Il a été lié à un autre générateur.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt32(System.UInt32)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Le générateur ne peut pas être écrit. Il a été lié à un autre générateur.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt32BE(System.UInt32)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Le générateur ne peut pas être écrit. Il a été lié à un autre générateur.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt64(System.UInt64)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Le générateur ne peut pas être écrit. Il a été lié à un autre générateur.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUserString(System.String)">
      <summary>Écrit une chaîne au format de tas de chaîne de l’utilisateur (#US) (voir #Tas d’objets blob et #US ECMA-335-II 24.2.4).</summary>
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Le générateur ne peut pas être écrit. Il a été lié à un autre générateur.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUTF16(System.Char[])">
      <summary>Écrit un tableau de caractères encodé au format UTF16 (little-endian) à la position actuelle.</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Le générateur ne peut pas être écrit. Il a été lié à un autre générateur.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUTF16(System.String)">
      <summary>Écrit une chaîne encodée au format UTF16 (little-endian) à la position actuelle.</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Le générateur ne peut pas être écrit. Il a été lié à un autre générateur.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUTF8(System.String,System.Boolean)">
      <summary>Écrit une chaîne encodée au format UTF8 à la position actuelle.</summary>
      <param name="value">Valeur constante.</param>
      <param name="allowUnpairedSurrogates">
        <see langword="true" /> pour encoder des substituts non couplés comme spécifié ; <see langword="false" /> pour les remplacer par un caractère U+FFFD.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Le générateur ne peut pas être écrit. Il a été lié à un autre générateur.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.BlobBuilder.ChunkCapacity" />
    <member name="P:System.Reflection.Metadata.BlobBuilder.Count" />
    <member name="P:System.Reflection.Metadata.BlobBuilder.FreeBytes" />
    <member name="T:System.Reflection.Metadata.BlobBuilder.Blobs" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.MoveNext">
      <summary>Avance l’énumérateur à l’élément suivant de la collection.</summary>
      <returns>
        <see langword="true" /> si l'énumérateur a pu avancer jusqu'à l'élément suivant ; <see langword="false" /> si l'énumérateur a dépassé la fin de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.Reset">
      <summary>Rétablit l'énumérateur à sa position initiale, qui précède le premier élément de la collection.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#Blob}#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein de la collection.</summary>
      <returns>Énumérateur permettant d'effectuer une itération au sein de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein d’une collection.</summary>
      <returns>Objet <see cref="T:System.Collections.IEnumerator" /> pouvant être utilisé pour itérer au sein de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.System#IDisposable#Dispose">
      <summary>Exécute les tâches définies par l'application associées à la libération ou à la redéfinition des ressources non managées.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.BlobBuilder.Blobs.Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.BlobBuilder.Blobs.System#Collections#IEnumerator#Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.BlobContentId" />
    <member name="M:System.Reflection.Metadata.BlobContentId.#ctor(System.Byte[])">
      <param name="id" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.#ctor(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="id" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.#ctor(System.Guid,System.UInt32)">
      <param name="guid" />
      <param name="stamp" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.Equals(System.Reflection.Metadata.BlobContentId)">
      <summary>Indique si l'objet actuel est égal à un autre objet du même type.</summary>
      <param name="other">Objet à comparer à cet objet.</param>
      <returns>
        <see langword="true" /> si l'objet actuel est égal au paramètre <paramref name="other" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.FromHash(System.Byte[])">
      <param name="hashCode" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.FromHash(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="hashCode" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.GetHashCode" />
    <member name="M:System.Reflection.Metadata.BlobContentId.GetTimeBasedProvider" />
    <member name="M:System.Reflection.Metadata.BlobContentId.op_Equality(System.Reflection.Metadata.BlobContentId,System.Reflection.Metadata.BlobContentId)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.op_Inequality(System.Reflection.Metadata.BlobContentId,System.Reflection.Metadata.BlobContentId)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.BlobContentId.Guid" />
    <member name="P:System.Reflection.Metadata.BlobContentId.IsDefault" />
    <member name="P:System.Reflection.Metadata.BlobContentId.Stamp" />
    <member name="T:System.Reflection.Metadata.BlobHandle" />
    <member name="M:System.Reflection.Metadata.BlobHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.Equals(System.Reflection.Metadata.BlobHandle)">
      <summary>Indique si l'objet actuel est égal à un autre objet du même type.</summary>
      <param name="other">Objet à comparer à cet objet.</param>
      <returns>
        <see langword="true" /> si l'objet actuel est égal au paramètre <paramref name="other" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Equality(System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.BlobHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.BlobHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Implicit(System.Reflection.Metadata.BlobHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Inequality(System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.BlobHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.BlobHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.BlobReader" />
    <member name="M:System.Reflection.Metadata.BlobReader.#ctor(System.Byte*,System.Int32)">
      <summary>Crée un lecteur du bloc de mémoire spécifié.</summary>
      <param name="buffer">Un pointeur du début du bloc de mémoire.</param>
      <param name="length">La longueur en octets du bloc de mémoire.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" />est <see langword="null" /> et <paramref name="length" /> est supérieur à zéro.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" /> est un nombre négatif.</exception>
      <exception cref="T:System.PlatformNotSupportedException">La plateforme actuelle n’est pas little-endian.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.Align(System.Byte)">
      <summary>Repositionne le lecteur vers l’avant par le nombre d’octets requis pour satisfaire l’alignement donné.</summary>
      <param name="alignment" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.IndexOf(System.Byte)">
      <summary>Recherche un octet spécifié dans l’objet blob suivant la position actuelle.</summary>
      <param name="value">Valeur de type octet à trouver.</param>
      <returns>L’index par rapport à la position actuelle, ou -1 si l’octet est introuvable dans l’objet blob suivant la position actuelle.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBlobHandle">
      <summary>Lit un descripteur de tas d’objets blob encodé sous la forme d’un entier compressé.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBoolean" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadByte" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBytes(System.Int32)">
      <summary>Lit les octets à partir de la position actuelle.</summary>
      <param name="byteCount">Nombre d'octets à lire.</param>
      <exception cref="T:System.BadImageFormatException">
        <paramref name="byteCount" /> octet(s) indisponible(s).</exception>
      <returns>Tableau d'octets.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBytes(System.Int32,System.Byte[],System.Int32)">
      <summary>Lit les octets à partir de la position actuelle et les écrit dans la mémoire tampon spécifiée, en commençant à l’offset spécifié.</summary>
      <param name="byteCount">Nombre d'octets à lire.</param>
      <param name="buffer">La mémoire tampon de destination où le lecteur d’octets sera écrit.</param>
      <param name="bufferOffset">L’offset dans la mémoire tampon de destination où le lecteur d’octets sera écrit.</param>
      <exception cref="T:System.BadImageFormatException">
        <paramref name="byteCount" /> octet(s) indisponible(s).</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadChar" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadCompressedInteger">
      <summary>Lit la valeur d’un entier non signé compressé. Consultez la spécification de métadonnées section II. 23.2 : blobs et signatures.</summary>
      <exception cref="T:System.BadImageFormatException">Les données à la position actuelle n’étaient pas un entier valide compressé.</exception>
      <returns>Valeur de l’entier compressé qui a été lu.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadCompressedSignedInteger">
      <summary>Lit la valeur d’un entier signé compressé. Consultez la spécification de métadonnées section II. 23.2 : blobs et signatures.</summary>
      <exception cref="T:System.BadImageFormatException">Les données à la position actuelle n’étaient pas un entier valide compressé.</exception>
      <returns>Valeur de l’entier compressé qui a été lu.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadConstant(System.Reflection.Metadata.ConstantTypeCode)">
      <summary>Lit une valeur constante (voir la section 22.9 ECMA-335 Partition II) depuis la position actuelle.</summary>
      <param name="typeCode" />
      <exception cref="T:System.BadImageFormatException">Erreur lors de la lecture de l’objet blob.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="typeCode" /> n’est pas un <see cref="T:System.Reflection.Metadata.ConstantTypeCode" /> valide.</exception>
      <returns>Valeur de constante encadrée. Pour éviter d’allouer l’objet, utilisez des méthodes Read* directement.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadDateTime" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadDecimal">
      <summary>Lit un nombre <see cref="T:System.Decimal" />.</summary>
      <exception cref="T:System.BadImageFormatException">Les données à la position actuelle n’étaient pas un entier valide <see cref="T:System.Decimal" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadDouble" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadGuid" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadInt16" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadInt32" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadInt64" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSByte" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSerializationTypeCode">
      <summary>Lit un code type encodé dans une valeur d’attribut personnalisé sérialisé.</summary>
      <returns>
        <see cref="F:System.Reflection.Metadata.SerializationTypeCode.Invalid" /> si l’encodage n’est pas valide.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSerializedString">
      <summary>Lit une chaîne encodée comme entier compressé contenant sa longueur suivie de son contenu au format UTF8. Les chaînes null sont encodées en un seul octet 0xFF.</summary>
      <exception cref="T:System.BadImageFormatException">L’encodage est invalide.</exception>
      <returns>Valeur de chaîne, ou <see langword="null" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSignatureHeader" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSignatureTypeCode">
      <summary>Lit un code type encodé dans une signature.</summary>
      <returns>Le code type encodé dans la valeur d’attribut personnalisé sérialisé si l’encodage est valide, ou <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Invalid" /> si l’encodage n’est pas valide.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSingle" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadTypeHandle">
      <summary>Lit un descripteur type encodé dans une signature TypeDefOrRefOrSpecEncoded (voir ECMA-335 II.23.2.8).</summary>
      <returns>Le descripteur lorsque l’encodage est valide. Sinon, un descripteur où la propriété <see cref="P:System.Reflection.Metadata.EntityHandle.IsNil" /> est <see langword="true" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUInt16" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUInt32" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUInt64" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUTF16(System.Int32)">
      <summary>Lit une chaîne encodée au format UTF16 (little-endian) au départ de la position actuelle.</summary>
      <param name="byteCount">Nombre d'octets à lire.</param>
      <exception cref="T:System.BadImageFormatException">
        <paramref name="byteCount" /> octet(s) indisponible(s).</exception>
      <returns>Chaîne.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUTF8(System.Int32)">
      <summary>Lit une chaîne encodée au format UTF8 (little-endian) au départ de la position actuelle.</summary>
      <param name="byteCount">Nombre d'octets à lire.</param>
      <exception cref="T:System.BadImageFormatException">
        <paramref name="byteCount" /> octet(s) indisponible(s).</exception>
      <returns>Chaîne.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.Reset">
      <summary>Repositionne le lecteur au début du bloc de mémoire sous-jacent.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.TryReadCompressedInteger(System.Int32@)">
      <summary>Lit la valeur d’un entier non signé compressé. Consultez la spécification de métadonnées section II. 23.2 : blobs et signatures.</summary>
      <param name="value">Valeur de l’entier compressé qui a été lu.</param>
      <returns>
        <see langword="true" /> si la valeur a été lue avec succès. <see langword="false" /> si les données à la position actuelle n’étaient pas un entier valide compressé.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.TryReadCompressedSignedInteger(System.Int32@)">
      <summary>Lit la valeur d’un entier signé compressé. Consultez la spécification de métadonnées section II. 23.2 : blobs et signatures.</summary>
      <param name="value">Valeur de l’entier compressé qui a été lu.</param>
      <returns>
        <see langword="true" /> si la valeur a été lue avec succès. <see langword="false" /> si les données à la position actuelle n’étaient pas un entier valide compressé.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.CurrentPointer">
      <summary>Obtient un pointeur vers l’octet à la position actuelle du lecteur.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.Length">
      <summary>Obtient la longueur totale du bloc de mémoire sous-jacent.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.Offset">
      <summary>Obtient ou définit l’offset à partir du début de l’objet blob à la position actuelle.</summary>
      <exception cref="T:System.BadImageFormatException">L’offset est défini en dehors des limites du lecteur sous-jacent.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.RemainingBytes">
      <summary>Obtient le nombre d’octets restants depuis la position actuelle à la fin du bloc de mémoire sous-jacent.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.StartPointer">
      <summary>Obtient un pointeur vers l’octet au début du bloc de mémoire sous-jacent.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.BlobWriter" />
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Byte[])">
      <param name="buffer" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Byte[],System.Int32,System.Int32)">
      <param name="buffer" />
      <param name="start" />
      <param name="count" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Int32)">
      <param name="size" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Reflection.Metadata.Blob)">
      <param name="blob" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.Align(System.Int32)">
      <param name="alignment" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.Clear" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ContentEquals(System.Reflection.Metadata.BlobWriter)">
      <summary>Compare le contenu actuel de cet auteur à un autre.</summary>
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.PadTo(System.Int32)">
      <param name="offset" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.ToArray" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ToArray(System.Int32,System.Int32)">
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">La plage spécifiée par <paramref name="start" /> et <paramref name="byteCount" /> se situe en dehors des limites de contenu de la mémoire tampon.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.ToImmutableArray" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ToImmutableArray(System.Int32,System.Int32)">
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">La plage spécifiée par <paramref name="start" /> et <paramref name="byteCount" /> se situe en dehors des limites de contenu de la mémoire tampon.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBoolean(System.Boolean)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteByte(System.Byte)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte*,System.Int32)">
      <param name="buffer" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> est un nombre négatif.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte,System.Int32)">
      <param name="value" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> est un nombre négatif.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte[])">
      <param name="buffer" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte[],System.Int32,System.Int32)">
      <param name="buffer" />
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">La plage spécifiée par <paramref name="start" /> et <paramref name="byteCount" /> se situe en dehors des limites de <paramref name="buffer" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="buffer" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte},System.Int32,System.Int32)">
      <param name="buffer" />
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">La plage spécifiée par <paramref name="start" /> et <paramref name="byteCount" /> se situe en dehors des limites de <paramref name="buffer" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.IO.Stream,System.Int32)">
      <param name="source" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> est un nombre négatif.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Reflection.Metadata.BlobBuilder)">
      <param name="source" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteCompressedInteger(System.Int32)">
      <summary>Implémente l’encodage d’entiers non signés compressés tel que défini par le chapitre 23,2 ECMA-335-II : blobs et signatures.</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="value" /> ne peut pas être représenté comme un entier non signé compressé.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteCompressedSignedInteger(System.Int32)">
      <summary>Implémente l’encodage d’entier signé compressé, tel que défini par le chapitre 23,2 de l’ECMA-335-II : blobs et signatures.</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="value" /> ne peut pas être représenté comme un entier signé compressé.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteConstant(System.Object)">
      <summary>Écrit une valeur constante (voir la section 22.9 ECMA-335 Partition II) à la position actuelle.</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentException">
        <paramref name="value" /> n’est pas d’un type de constante.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteDateTime(System.DateTime)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteDecimal(System.Decimal)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteDouble(System.Double)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteGuid(System.Guid)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt16(System.Int16)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt16BE(System.Int16)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt32(System.Int32)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt32BE(System.Int32)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt64(System.Int64)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteReference(System.Int32,System.Boolean)">
      <summary>Écrit une référence dans un tas (offset de tas) ou une table (nombre de ligne).</summary>
      <param name="reference">Offset de tas ou nombre de ligne d’une table.</param>
      <param name="isSmall">
        <see langword="true" /> pour encoder la référence en tant qu’entier 16 bits, <see langword="false" /> pour encoder en tant qu’entier 32 bits.</param>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteSByte(System.SByte)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteSerializedString(System.String)">
      <summary>Écrit une chaîne au format SerString (voir Attributs personnalisés 23.3 ECMA-335-II).</summary>
      <param name="str" />
      <exception cref="T:System.InvalidOperationException">Le générateur ne peut pas être écrit. Il a été lié à un autre générateur.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteSingle(System.Single)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt16(System.UInt16)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt16BE(System.UInt16)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt32(System.UInt32)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt32BE(System.UInt32)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt64(System.UInt64)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUserString(System.String)">
      <summary>Écrit une chaîne au format de tas de chaîne de l’utilisateur (#US) (voir #Tas d’objets blob et #US ECMA-335-II 24.2.4).</summary>
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Le générateur ne peut pas être écrit. Il a été lié à un autre générateur.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUTF16(System.Char[])">
      <summary>Écrit une chaîne encodée au format UTF16 (little-endian) à la position actuelle.</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUTF16(System.String)">
      <summary>Écrit une chaîne encodée au format UTF16 (little-endian) à la position actuelle.</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUTF8(System.String,System.Boolean)">
      <summary>Écrit une chaîne encodée au format UTF8 à la position actuelle.</summary>
      <param name="value" />
      <param name="allowUnpairedSurrogates" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.BlobWriter.Blob" />
    <member name="P:System.Reflection.Metadata.BlobWriter.Length" />
    <member name="P:System.Reflection.Metadata.BlobWriter.Offset" />
    <member name="P:System.Reflection.Metadata.BlobWriter.RemainingBytes" />
    <member name="T:System.Reflection.Metadata.Constant" />
    <member name="P:System.Reflection.Metadata.Constant.Parent">
      <summary>Obtient le descripteur parent (<see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />).</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Constant.TypeCode">
      <summary>Obtient un code de type qui identifie le type de la valeur de constante.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Constant.Value">
      <summary>Obtient une valeur constante.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ConstantHandle" />
    <member name="M:System.Reflection.Metadata.ConstantHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.Equals(System.Reflection.Metadata.ConstantHandle)">
      <summary>Indique si l'objet actuel est égal à un autre objet du même type.</summary>
      <param name="other">Objet à comparer à cet objet.</param>
      <returns>
        <see langword="true" /> si l'objet actuel est égal au paramètre <paramref name="other" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Equality(System.Reflection.Metadata.ConstantHandle,System.Reflection.Metadata.ConstantHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ConstantHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ConstantHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Implicit(System.Reflection.Metadata.ConstantHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Implicit(System.Reflection.Metadata.ConstantHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Inequality(System.Reflection.Metadata.ConstantHandle,System.Reflection.Metadata.ConstantHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.ConstantHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ConstantTypeCode">
      <summary>Spécifie des valeurs qui représentent des types de constantes de métadonnées.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Boolean">
      <summary>Type booléen.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Byte">
      <summary>Entier non signé sur 1 octet.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Char">
      <summary>Type de caractère.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Double">
      <summary>Type à virgule flottante sur 8 octets.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Int16">
      <summary>Type entier signé sur 2 octets.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Int32">
      <summary>Type entier signé sur 4 octets.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Int64">
      <summary>Type entier signé sur 8 octets.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Invalid">
      <summary>Type non valide.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.NullReference">
      <summary>Référence null.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.SByte">
      <summary>Type entier signé sur 1 octet.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Single">
      <summary>Type à virgule flottante sur 4 octets.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.String">
      <summary>Type <see cref="T:System.String" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.UInt16">
      <summary>Type entier non signé sur 2 octets.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.UInt32">
      <summary>Type entier non signé sur 4 octets.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.UInt64">
      <summary>Type entier non signé sur 8 octets.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttribute" />
    <member name="M:System.Reflection.Metadata.CustomAttribute.DecodeValue``1(System.Reflection.Metadata.ICustomAttributeTypeProvider{``0})">
      <summary>Décode les arguments encodés dans l’objet blob de valeur.</summary>
      <param name="provider" />
      <typeparam name="TType" />
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttribute.Constructor">
      <summary>Obtient le constructeur (<see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />) du type de l'attribut personnalisé.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttribute.Parent">
      <summary>Obtient le handle de l’entité de métadonnées à laquelle l’attribut est appliqué.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttribute.Value">
      <summary>Obtient la valeur de l'attribut.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeHandle" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.Equals(System.Reflection.Metadata.CustomAttributeHandle)">
      <summary>Indique si l'objet actuel est égal à un autre objet du même type.</summary>
      <param name="other">Objet à comparer à cet objet.</param>
      <returns>
        <see langword="true" /> si l'objet actuel est égal au paramètre <paramref name="other" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Equality(System.Reflection.Metadata.CustomAttributeHandle,System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.CustomAttributeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.CustomAttributeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Implicit(System.Reflection.Metadata.CustomAttributeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Implicit(System.Reflection.Metadata.CustomAttributeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Inequality(System.Reflection.Metadata.CustomAttributeHandle,System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.CustomAttributeHandleCollection" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#CustomAttributeHandle}#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein de la collection.</summary>
      <returns>Énumérateur permettant d'effectuer une itération au sein de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein d’une collection.</summary>
      <returns>Objet <see cref="T:System.Collections.IEnumerator" /> pouvant être utilisé pour itérer au sein de la collection.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeHandleCollection.Count">
      <summary>Obtient le nombre d’éléments de la collection.</summary>
      <returns>Nombre d'éléments dans la collection.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.MoveNext">
      <summary>Avance l’énumérateur à l’élément suivant de la collection.</summary>
      <returns>
        <see langword="true" /> si l'énumérateur a pu avancer jusqu'à l'élément suivant ; <see langword="false" /> si l'énumérateur a dépassé la fin de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Rétablit l'énumérateur à sa position initiale, qui précède le premier élément de la collection.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Exécute les tâches définies par l'application associées à la libération ou à la redéfinition des ressources non managées.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeNamedArgument`1">
      <summary>Représente un argument nommé décodé à partir d’une signature d’attribut personnalisé.</summary>
      <typeparam name="TType">Type utilisé pour représenter les types de valeurs décodées à partir de la signature d’attribut personnalisé.</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeNamedArgument`1.#ctor(System.String,System.Reflection.Metadata.CustomAttributeNamedArgumentKind,`0,System.Object)">
      <summary>Initialise une nouvelle instance de la structure <see cref="T:System.Reflection.Metadata.CustomAttributeNamedArgument`1" /> à l’aide du nom, du genre, du type et de la valeur spécifiés.</summary>
      <param name="name">Nom de l’argument.</param>
      <param name="kind">Type de l’argument.</param>
      <param name="type">Type de l’argument.</param>
      <param name="value">Valeur de l’argument.</param>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Kind">
      <summary>Obtient le genre d’argument.</summary>
      <returns>Genre d’argument.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Name">
      <summary>Obtient le nom de l’argument.</summary>
      <returns>Nom de l’argument.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Type">
      <summary>Obtient le type de l’argument.</summary>
      <returns>Type de l'argument.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Value">
      <summary>Obtient la valeur de l’argument.</summary>
      <returns>Objet contenant la valeur de l’argument.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeNamedArgumentKind">
      <summary>Spécifie des constantes qui définissent les genres d’arguments dans une signature d’attribut personnalisé.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.CustomAttributeNamedArgumentKind.Field">
      <summary>Argument de champ.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.CustomAttributeNamedArgumentKind.Property">
      <summary>Argument de propriété.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeTypedArgument`1">
      <summary>Représente un argument typé d’un attribut de métadonnées personnalisé.</summary>
      <typeparam name="TType">Type de l’argument.</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeTypedArgument`1.#ctor(`0,System.Object)">
      <summary>Initialise une nouvelle instance de la structure <see cref="T:System.Reflection.Metadata.CustomAttributeTypedArgument`1" /> à l’aide de la valeur et du type d’argument spécifiés.</summary>
      <param name="type">Type de l’argument.</param>
      <param name="value">Valeur de l'argument.</param>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeTypedArgument`1.Type">
      <summary>Obtient le type de l’argument.</summary>
      <returns>Type de l'argument.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeTypedArgument`1.Value">
      <summary>Obtient la valeur de l’argument.</summary>
      <returns>Valeur de l'argument.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeValue`1">
      <summary>Représente un attribut personnalisé du type spécifié par <paramref name="TType" />.</summary>
      <typeparam name="TType">Type d'attribut.</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeValue`1.#ctor(System.Collections.Immutable.ImmutableArray{System.Reflection.Metadata.CustomAttributeTypedArgument{`0}},System.Collections.Immutable.ImmutableArray{System.Reflection.Metadata.CustomAttributeNamedArgument{`0}})">
      <summary>Initialise une nouvelle instance de la structure <see cref="T:System.Reflection.Metadata.CustomAttributeValue`1" /> à l’aide des arguments nommés et des arguments fixes spécifiés.</summary>
      <param name="fixedArguments">Arguments fixes.</param>
      <param name="namedArguments">Arguments nommés.</param>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeValue`1.FixedArguments">
      <summary>Obtient les arguments fixes de l’attribut personnalisé.</summary>
      <returns>Tableau d’arguments immuable.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeValue`1.NamedArguments">
      <summary>Obtient les arguments nommés pour la valeur d’attribut personnalisé.</summary>
      <returns>Tableau d’arguments immuable.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomDebugInformation" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformation.Kind" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformation.Parent" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformation.Value" />
    <member name="T:System.Reflection.Metadata.CustomDebugInformationHandle" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.Equals(System.Reflection.Metadata.CustomDebugInformationHandle)">
      <summary>Indique si l'objet actuel est égal à un autre objet du même type.</summary>
      <param name="other">Objet à comparer à cet objet.</param>
      <returns>
        <see langword="true" /> si l'objet actuel est égal au paramètre <paramref name="other" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Equality(System.Reflection.Metadata.CustomDebugInformationHandle,System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.CustomDebugInformationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.CustomDebugInformationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Implicit(System.Reflection.Metadata.CustomDebugInformationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Implicit(System.Reflection.Metadata.CustomDebugInformationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Inequality(System.Reflection.Metadata.CustomDebugInformationHandle,System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.CustomDebugInformationHandleCollection" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#CustomDebugInformationHandle}#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein de la collection.</summary>
      <returns>Énumérateur permettant d'effectuer une itération au sein de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein d’une collection.</summary>
      <returns>Objet <see cref="T:System.Collections.IEnumerator" /> pouvant être utilisé pour itérer au sein de la collection.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Count">
      <summary>Obtient le nombre d’éléments de la collection.</summary>
      <returns>Nombre d'éléments dans la collection.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.MoveNext">
      <summary>Avance l’énumérateur à l’élément suivant de la collection.</summary>
      <returns>
        <see langword="true" /> si l'énumérateur a pu avancer jusqu'à l'élément suivant ; <see langword="false" /> si l'énumérateur a dépassé la fin de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Rétablit l'énumérateur à sa position initiale, qui précède le premier élément de la collection.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Exécute les tâches définies par l'application associées à la libération ou à la redéfinition des ressources non managées.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.DebugMetadataHeader" />
    <member name="P:System.Reflection.Metadata.DebugMetadataHeader.EntryPoint" />
    <member name="P:System.Reflection.Metadata.DebugMetadataHeader.Id" />
    <member name="P:System.Reflection.Metadata.DebugMetadataHeader.IdStartOffset">
      <summary>Obtient le décalage (en octets) entre le début de l’objet blob de métadonnées et le début de l’objet blob <see cref="P:System.Reflection.Metadata.DebugMetadataHeader.Id" />.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttribute" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttribute.Action" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttribute.Parent" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttribute.PermissionSet" />
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.Equals(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <summary>Indique si l'objet actuel est égal à un autre objet du même type.</summary>
      <param name="other">Objet à comparer à cet objet.</param>
      <returns>
        <see langword="true" /> si l'objet actuel est égal au paramètre <paramref name="other" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Equality(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle,System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.DeclarativeSecurityAttributeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.DeclarativeSecurityAttributeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Implicit(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Implicit(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Inequality(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle,System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#DeclarativeSecurityAttributeHandle}#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein de la collection.</summary>
      <returns>Énumérateur permettant d'effectuer une itération au sein de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein d’une collection.</summary>
      <returns>Objet <see cref="T:System.Collections.IEnumerator" /> pouvant être utilisé pour itérer au sein de la collection.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Count">
      <summary>Obtient le nombre d’éléments de la collection.</summary>
      <returns>Nombre d'éléments dans la collection.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.MoveNext">
      <summary>Avance l’énumérateur à l’élément suivant de la collection.</summary>
      <returns>
        <see langword="true" /> si l'énumérateur a pu avancer jusqu'à l'élément suivant ; <see langword="false" /> si l'énumérateur a dépassé la fin de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Rétablit l'énumérateur à sa position initiale, qui précède le premier élément de la collection.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Exécute les tâches définies par l'application associées à la libération ou à la redéfinition des ressources non managées.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Document">
      <summary>Document source dans les métadonnées de débogage.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.Hash">
      <summary>Obtient le hachage du contenu du document.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.HashAlgorithm">
      <summary>Obtient l’algorithme de hachage utilisé pour calculer <see cref="P:System.Reflection.Metadata.Document.Hash" /> (SHA1, SHA256, etc.).</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.Language">
      <summary>Obtient le langage du code source (C#, VB, F#, etc.).</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.Name">
      <summary>Obtient l’objet blob du nom du document.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.DocumentHandle" />
    <member name="M:System.Reflection.Metadata.DocumentHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.Equals(System.Reflection.Metadata.DocumentHandle)">
      <summary>Indique si l'objet actuel est égal à un autre objet du même type.</summary>
      <param name="other">Objet à comparer à cet objet.</param>
      <returns>
        <see langword="true" /> si l'objet actuel est égal au paramètre <paramref name="other" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Equality(System.Reflection.Metadata.DocumentHandle,System.Reflection.Metadata.DocumentHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.DocumentHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.DocumentHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Implicit(System.Reflection.Metadata.DocumentHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Implicit(System.Reflection.Metadata.DocumentHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Inequality(System.Reflection.Metadata.DocumentHandle,System.Reflection.Metadata.DocumentHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.DocumentHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.DocumentHandleCollection" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#DocumentHandle}#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein de la collection.</summary>
      <returns>Énumérateur permettant d'effectuer une itération au sein de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein d’une collection.</summary>
      <returns>Objet <see cref="T:System.Collections.IEnumerator" /> pouvant être utilisé pour itérer au sein de la collection.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.DocumentHandleCollection.Count">
      <summary>Obtient le nombre d’éléments de la collection.</summary>
      <returns>Nombre d'éléments dans la collection.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.DocumentHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.MoveNext">
      <summary>Avance l’énumérateur à l’élément suivant de la collection.</summary>
      <returns>
        <see langword="true" /> si l'énumérateur a pu avancer jusqu'à l'élément suivant ; <see langword="false" /> si l'énumérateur a dépassé la fin de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Rétablit l'énumérateur à sa position initiale, qui précède le premier élément de la collection.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Exécute les tâches définies par l'application associées à la libération ou à la redéfinition des ressources non managées.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.DocumentNameBlobHandle">
      <summary>
        <see cref="T:System.Reflection.Metadata.BlobHandle" /> représentant un objet blob sur le segment #Blob dans le PDB portable structuré comme Nom de document.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.Equals(System.Reflection.Metadata.DocumentNameBlobHandle)">
      <summary>Indique si l'objet actuel est égal à un autre objet du même type.</summary>
      <param name="other">Objet à comparer à cet objet.</param>
      <returns>
        <see langword="true" /> si l'objet actuel est égal au paramètre <paramref name="other" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Equality(System.Reflection.Metadata.DocumentNameBlobHandle,System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Explicit(System.Reflection.Metadata.BlobHandle)~System.Reflection.Metadata.DocumentNameBlobHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Implicit(System.Reflection.Metadata.DocumentNameBlobHandle)~System.Reflection.Metadata.BlobHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Inequality(System.Reflection.Metadata.DocumentNameBlobHandle,System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.DocumentNameBlobHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder.Shape(System.Int32,System.Collections.Immutable.ImmutableArray{System.Int32},System.Collections.Immutable.ImmutableArray{System.Int32})">
      <summary>Encode la forme de tableau.</summary>
      <param name="rank">Nombre de dimensions dans le tableau (doit être 1 ou plus).</param>
      <param name="sizes">Tailles de dimension. Le tableau peut être plus petit que <paramref name="rank" /> mais pas plus long.</param>
      <param name="lowerBounds">Limites inférieures de la dimension, ou valeur par défaut (<see cref="T:System.Collections.Immutable.ImmutableArray`1" />) pour affecter la valeur 0 à toutes les limites inférieures <paramref name="rank" />.
Le tableau peut être plus petit que <paramref name="rank" /> mais pas plus long.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="rank" /> est en dehors de la plage [1, 0xffff], inférieure à <see langword="sizes.Length" /> ou inférieure à <see langword="lowerBounds.Length" /> .</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="sizes" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.BlobEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.CustomAttributeSignature(System.Action{System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder},System.Action{System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder})">
      <summary>Encode un objet blob de signature d’attribut personnalisé.</summary>
      <param name="fixedArguments">Appelé en premier, pour encoder les arguments fixes.</param>
      <param name="namedArguments">Appelé en second, pour encoder les arguments nommés.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="fixedArguments" /> ou <paramref name="namedArguments" /> est <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.CustomAttributeSignature(System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder@,System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder@)">
      <summary>Encode un objet blob de signature d’attribut personnalisé.
Retourne une paire d’encodeurs qui doivent être utilisés dans l’ordre dans lequel ils apparaissent dans la liste de paramètres.</summary>
      <param name="fixedArguments">Utilisé en premier, pour encoder les arguments fixes.</param>
      <param name="namedArguments">Utilisé en second, pour encoder les arguments nommés.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.FieldSignature">
      <summary>Encode l’objet blob de signature de champ.</summary>
      <returns>Encodeur du type de champ.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.LocalVariableSignature(System.Int32)">
      <summary>Encode la signature de variable locale.</summary>
      <param name="variableCount">Nombre de variables locales.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="variableCount" /> est en dehors de la plage [0, 0x1fffffff].</exception>
      <returns>Encodeur d’une séquence de variables locales.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.MethodSignature(System.Reflection.Metadata.SignatureCallingConvention,System.Int32,System.Boolean)">
      <summary>Encode l’objet blob de signature de méthode.</summary>
      <param name="convention">Convention d’appel.</param>
      <param name="genericParameterCount">Nombre de paramètres génériques.</param>
      <param name="isInstanceMethod">
        <see langword="true" /> pour encoder une signature de méthode d’instance, <see langword="false" /> pour encoder une signature de méthode statique.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="genericParameterCount" /> est en dehors de la plage [0, 0xffff].</exception>
      <returns>Encodeur du reste de la signature, notamment la valeur de retour et les paramètres.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.MethodSpecificationSignature(System.Int32)">
      <summary>Encode l’objet blob de signature de spécification de méthode.</summary>
      <param name="genericArgumentCount">Nombre d’arguments génériques.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="genericArgumentCount" /> est en dehors de la plage [0, 0xffff].</exception>
      <returns>Encodeur des arguments génériques.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.PermissionSetArguments(System.Int32)">
      <summary>Encode les arguments de jeu d’autorisations.</summary>
      <param name="argumentCount">Nombre d’arguments dans le jeu.</param>
      <returns>Encodeur des arguments du jeu.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.PermissionSetBlob(System.Int32)">
      <summary>Encode un objet blob de jeu d’autorisations.</summary>
      <param name="attributeCount">Nombre d’attributs dans le jeu.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="attributeCount" /> est en dehors de la plage [0, 0x1fffffff].</exception>
      <returns>Encodeur des jeux d’autorisations.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.PropertySignature(System.Boolean)">
      <summary>Encode un objet blob de signature de propriété.</summary>
      <param name="isInstanceProperty">
        <see langword="true" /> pour encoder une signature de propriété d’instance, <see langword="false" /> pour encoder une signature de propriété statique.</param>
      <returns>Encodeur du reste de la signature, notamment la valeur de retour et les paramètres, qui a la même structure que la signature de méthode.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.TypeSpecificationSignature">
      <summary>Encode une signature de spécification de type.</summary>
      <returns>Encodeur de type du type structuré représenté par la spécification de type (il ne doit pas encoder un type primitif).</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.BlobEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.CodedIndex" />
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.CustomAttributeType(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcule un index codé CustomAttributeType pour le handle spécifié.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" /></param>
      <exception cref="T:System.ArgumentException">Le type de poignée est inattendu.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasConstant(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcule un index codé HasConstant pour le handle spécifié.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />ou <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" /></param>
      <exception cref="T:System.ArgumentException">Le type de poignée est inattendu.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasCustomAttribute(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcule un index codé HasCustomAttribute pour le handle spécifié.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />, <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />, <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />, <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" /> ou <see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />.</param>
      <exception cref="T:System.ArgumentException">Le type de poignée est inattendu.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasCustomDebugInformation(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcule un index codé HasCustomDebugInformation pour le handle spécifié.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />, <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />, <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />, <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" />, <see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.DocumentHandle" />, <see cref="T:System.Reflection.Metadata.LocalScopeHandle" />, <see cref="T:System.Reflection.Metadata.LocalVariableHandle" />, <see cref="T:System.Reflection.Metadata.LocalConstantHandle" /> ou <see cref="T:System.Reflection.Metadata.ImportScopeHandle" />.</param>
      <exception cref="T:System.ArgumentException">Le type de poignée est inattendu.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasDeclSecurity(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcule un index codé HasDeclSecurity pour le handle spécifié.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />ou <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" /></param>
      <exception cref="T:System.ArgumentException">Le type de poignée est inattendu.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasFieldMarshal(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcule un index codé HasFieldMarshal pour le handle spécifié.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.ParameterHandle" /> ou <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" /></param>
      <exception cref="T:System.ArgumentException">Le type de poignée est inattendu.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasSemantics(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcule un index codé HasSemantics pour le handle spécifié.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" /></param>
      <exception cref="T:System.ArgumentException">Le type de poignée est inattendu.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.Implementation(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcule un index codé d’implémentation pour le handle spécifié.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" /> ou <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" /></param>
      <exception cref="T:System.ArgumentException">Le type de poignée est inattendu.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.MemberForwarded(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcule un index codé MemberForwarded pour le handle spécifié.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.FieldDefinition" />, <see cref="T:System.Reflection.Metadata.MethodDefinition" /></param>
      <exception cref="T:System.ArgumentException">Le type de poignée est inattendu.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.MemberRefParent(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcule un index codé MemberRefParent pour le handle spécifié.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <exception cref="T:System.ArgumentException">Le type de poignée est inattendu.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.MethodDefOrRef(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcule un index codé MethodDefOrRef pour le handle spécifié.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" /></param>
      <exception cref="T:System.ArgumentException">Le type de poignée est inattendu.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.ResolutionScope(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcule un index codé ResolutionScope pour le handle spécifié.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /></param>
      <exception cref="T:System.ArgumentException">Le type de poignée est inattendu.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.TypeDefOrRef(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcule un index codé TypeDefOrRef pour le handle spécifié.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /></param>
      <exception cref="T:System.ArgumentException">Le type de poignée est inattendu.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.TypeDefOrRefOrSpec(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcule un index codé TypeDefOrRefOrSpec pour le handle spécifié.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /></param>
      <exception cref="T:System.ArgumentException">Le type de poignée est inattendu.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.TypeOrMethodDef(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcule un index codé TypeOrMethodDef pour le handle spécifié.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /></param>
      <exception cref="T:System.ArgumentException">Le type de poignée est inattendu.</exception>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.ControlFlowBuilder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.#ctor" />
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddCatchRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>Ajoute une région catch.</summary>
      <param name="tryStart">Étiquette marquant la première instruction du bloc try.</param>
      <param name="tryEnd">Étiquette marquant l’instruction qui suit immédiatement le bloc try.</param>
      <param name="handlerStart">Étiquette marquant la première instruction du gestionnaire.</param>
      <param name="handlerEnd">Étiquette marquant l’instruction qui suit immédiatement le gestionnaire.</param>
      <param name="catchType">Type d’exception à intercepter : <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <exception cref="T:System.ArgumentException">Une étiquette n’a pas été définie par un encodeur d’instruction auquel ce générateur est associé.

- ou -

<paramref name="catchType" /> n’est pas une poignée de type valide.</exception>
      <exception cref="T:System.ArgumentNullException">Une étiquette a une valeur par défaut.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddFaultRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary>Ajoute une région fault.</summary>
      <param name="tryStart">Étiquette marquant la première instruction du bloc try.</param>
      <param name="tryEnd">Étiquette marquant l’instruction qui suit immédiatement le bloc try.</param>
      <param name="handlerStart">Étiquette marquant la première instruction du gestionnaire.</param>
      <param name="handlerEnd">Étiquette marquant l’instruction qui suit immédiatement le gestionnaire.</param>
      <exception cref="T:System.ArgumentException">Une étiquette n’a pas été définie par un encodeur d’instruction auquel ce générateur est associé.</exception>
      <exception cref="T:System.ArgumentNullException">Une étiquette a une valeur par défaut.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddFilterRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary>Ajoute une région catch.</summary>
      <param name="tryStart">Étiquette marquant la première instruction du bloc try.</param>
      <param name="tryEnd">Étiquette marquant l’instruction qui suit immédiatement le bloc try.</param>
      <param name="handlerStart">Étiquette marquant la première instruction du gestionnaire.</param>
      <param name="handlerEnd">Étiquette marquant l’instruction qui suit immédiatement le gestionnaire.</param>
      <param name="filterStart">Étiquette marquant la première instruction du bloc filter.</param>
      <exception cref="T:System.ArgumentException">Une étiquette n’a pas été définie par un encodeur d’instruction auquel ce générateur est associé.</exception>
      <exception cref="T:System.ArgumentNullException">Une étiquette a une valeur par défaut.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddFinallyRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary>Ajoute une région finally.</summary>
      <param name="tryStart">Étiquette marquant la première instruction du bloc try.</param>
      <param name="tryEnd">Étiquette marquant l’instruction qui suit immédiatement le bloc try.</param>
      <param name="handlerStart">Étiquette marquant la première instruction du gestionnaire.</param>
      <param name="handlerEnd">Étiquette marquant l’instruction qui suit immédiatement le gestionnaire.</param>
      <exception cref="T:System.ArgumentException">Une étiquette n’a pas été définie par un encodeur d’instruction auquel ce générateur est associé.</exception>
      <exception cref="T:System.ArgumentNullException">Une étiquette a une valeur par défaut.</exception>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.ElementType" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.ObjectArray" />
    <member name="P:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Boolean" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Byte" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Char" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Double" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Enum(System.String)">
      <param name="enumTypeName" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Int16" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Int32" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Int64" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.PrimitiveType(System.Reflection.Metadata.PrimitiveSerializationTypeCode)">
      <param name="type" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.SByte" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Single" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.String" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.SystemType" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.UInt16" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.UInt32" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.UInt64" />
    <member name="P:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder.Count(System.Int32)">
      <param name="count" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder.AddModifier(System.Reflection.Metadata.EntityHandle,System.Boolean)">
      <summary>Encode un modificateur personnalisé.</summary>
      <param name="type">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <param name="isOptional">Est un modificateur facultatif.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="type" /> est <see langword="null" /> ou d’un type inattendu.</exception>
      <returns>Encodeur des modificateurs suivants.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry" />
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.#ctor(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.Ecma335.EditAndContinueOperation)">
      <param name="handle" />
      <param name="operation" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Equals(System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry)">
      <summary>Indique si l'objet actuel est égal à un autre objet du même type.</summary>
      <param name="other">Objet à comparer à cet objet.</param>
      <returns>
        <see langword="true" /> si l'objet actuel est égal au paramètre <paramref name="other" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.GetHashCode" />
    <member name="P:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Handle" />
    <member name="P:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Operation" />
    <member name="T:System.Reflection.Metadata.Ecma335.EditAndContinueOperation" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddEvent" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddField" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddMethod" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddParameter" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddProperty" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.Default" />
    <member name="T:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.Add(System.Reflection.Metadata.ExceptionRegionKind,System.Int32,System.Int32,System.Int32,System.Int32,System.Reflection.Metadata.EntityHandle,System.Int32)">
      <summary>Ajoute une clause d’exception.</summary>
      <param name="kind">Genre de clause.</param>
      <param name="tryOffset">Décalage de début du bloc try.</param>
      <param name="tryLength">Longueur du bloc try.</param>
      <param name="handlerOffset">Décalage de début du gestionnaire.</param>
      <param name="handlerLength">Longueur du gestionnaire.</param>
      <param name="catchType">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /> ou Nil si <paramref name="kind" /> n’est pas <see cref="F:System.Reflection.Metadata.ExceptionRegionKind.Catch" /></param>
      <param name="filterOffset">Décalage du bloc filter, ou 0 si <paramref name="kind" /> n’est pas <see cref="F:System.Reflection.Metadata.ExceptionRegionKind.Filter" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="catchType" /> n'est pas valide.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="kind" /> a une valeur non valide.
          
- ou -

<paramref name="tryOffset" />, <paramref name="tryLength" /> , <paramref name="handlerOffset" /> ou <paramref name="handlerLength" /> est en dehors de la plage.</exception>
      <exception cref="T:System.InvalidOperationException">Le corps de méthode n’a pas été déclaré comme ayant des régions d’exception.</exception>
      <returns>Encodeur pour la clause suivante.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddCatch(System.Int32,System.Int32,System.Int32,System.Int32,System.Reflection.Metadata.EntityHandle)">
      <summary>Ajoute une clause fault.</summary>
      <param name="tryOffset">Décalage de début du bloc try.</param>
      <param name="tryLength">Longueur du bloc try.</param>
      <param name="handlerOffset">Décalage de début du gestionnaire.</param>
      <param name="handlerLength">Longueur du gestionnaire.</param>
      <param name="catchType">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="catchType" /> n'est pas valide.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="tryOffset" />, <paramref name="tryLength" /><paramref name="handlerOffset" /> ou <paramref name="handlerLength" /> est en dehors de la plage.</exception>
      <exception cref="T:System.InvalidOperationException">Le corps de méthode n’a pas été déclaré comme ayant des régions d’exception.</exception>
      <returns>Encodeur pour la clause suivante.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddFault(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>Ajoute une clause fault.</summary>
      <param name="tryOffset">Décalage de début du bloc try.</param>
      <param name="tryLength">Longueur du bloc try.</param>
      <param name="handlerOffset">Décalage de début du gestionnaire.</param>
      <param name="handlerLength">Longueur du gestionnaire.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="tryOffset" />, <paramref name="tryLength" /><paramref name="handlerOffset" /> ou <paramref name="handlerLength" /> est en dehors de la plage.</exception>
      <exception cref="T:System.InvalidOperationException">Le corps de méthode n’a pas été déclaré comme ayant des régions d’exception.</exception>
      <returns>Encodeur pour la clause suivante.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddFilter(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>Ajoute une clause fault.</summary>
      <param name="tryOffset">Décalage de début du bloc try.</param>
      <param name="tryLength">Longueur du bloc try.</param>
      <param name="handlerOffset">Décalage de début du gestionnaire.</param>
      <param name="handlerLength">Longueur du gestionnaire.</param>
      <param name="filterOffset">Décalage du bloc filter.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="tryOffset" />, <paramref name="tryLength" /><paramref name="handlerOffset" /> ou <paramref name="handlerLength" /> est en dehors de la plage.</exception>
      <exception cref="T:System.InvalidOperationException">Le corps de méthode n’a pas été déclaré comme ayant des régions d’exception.</exception>
      <returns>Encodeur pour la clause suivante.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddFinally(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>Ajoute une clause finally.</summary>
      <param name="tryOffset">Décalage de début du bloc try.</param>
      <param name="tryLength">Longueur du bloc try.</param>
      <param name="handlerOffset">Décalage de début du gestionnaire.</param>
      <param name="handlerLength">Longueur du gestionnaire.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="tryOffset" />, <paramref name="tryLength" /><paramref name="handlerOffset" /> ou <paramref name="handlerLength" /> est en dehors de la plage.</exception>
      <exception cref="T:System.InvalidOperationException">Le corps de méthode n’a pas été déclaré comme ayant des régions d’exception.</exception>
      <returns>Encodeur pour la clause suivante.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.IsSmallExceptionRegion(System.Int32,System.Int32)">
      <summary>Retourne <see langword="true" /> si la région est adaptée à un petit format.</summary>
      <param name="startOffset">Décalage de début de la région.</param>
      <param name="length">Longueur de la région.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.IsSmallRegionCount(System.Int32)">
      <summary>Retourne <see langword="true" /> si le nombre de régions d’exception est adapté à un petit format.</summary>
      <param name="exceptionRegionCount">Nombre de régions d’exception.</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.Builder">
      <summary>Générateur sous-jacent.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.HasSmallFormat">
      <summary>
        <see langword="true" /> si l’encodeur utilise un petit format.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.ExportedTypeExtensions">
      <summary>Fournit une méthode d’extension pour accéder à la colonne TypeDefinitionId de la table ExportedType.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExportedTypeExtensions.GetTypeDefinitionId(System.Reflection.Metadata.ExportedType)">
      <summary>Obtient un indicateur sur le numéro de ligne probable du type de cible dans la table TypeDef de son module.
Si les espaces de noms et les noms ne correspondent pas, la résolution revient à une recherche complète de la table TypeDef cible. Ignoré et doit être égal à zéro si <see cref="P:System.Reflection.Metadata.ExportedType.IsForwarder" /> est <see langword="true" />.</summary>
      <param name="exportedType" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder.AddArgument" />
    <member name="P:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes" />
    <member name="F:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes.HasExplicitThis" />
    <member name="F:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes.HasThis" />
    <member name="F:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes.None" />
    <member name="T:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder.AddArgument" />
    <member name="P:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.HeapIndex" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.Blob" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.Guid" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.String" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.UserString" />
    <member name="T:System.Reflection.Metadata.Ecma335.InstructionEncoder">
      <summary>Encode des instructions.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.#ctor(System.Reflection.Metadata.BlobBuilder,System.Reflection.Metadata.Ecma335.ControlFlowBuilder)">
      <summary>Crée un encodeur alimenté par le code et les générateurs de flux de contrôle.</summary>
      <param name="codeBuilder">Générateur dans lequel écrire des instructions encodées.</param>
      <param name="controlFlowBuilder">Étiquettes de suivi, branches et gestionnaires d’exceptions du générateur.
Doit être spécifié pour pouvoir utiliser certaines des méthodes de fabrique de flux de contrôle de <see cref="T:System.Reflection.Metadata.Ecma335.InstructionEncoder" />, comme <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Branch(System.Reflection.Metadata.ILOpCode,System.Reflection.Metadata.Ecma335.LabelHandle)" />, <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.DefineLabel" />, <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.MarkLabel(System.Reflection.Metadata.Ecma335.LabelHandle)" />, etc.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Branch(System.Reflection.Metadata.ILOpCode,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary>Encode une instruction de branche.</summary>
      <param name="code">Instruction de branche à encoder.</param>
      <param name="label">Étiquette de l’emplacement cible dans le flux d’instructions.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="code" /> n’est pas une instruction de branche.

- ou - 
<paramref name="label" /> n’a pas été définie par cet encodeur.</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="label" /> a une valeur par défaut.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.EntityHandle)">
      <summary>Encode une instruction <c>call</c> et son opérande.</summary>
      <param name="methodHandle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.MemberReferenceHandle)">
      <summary>Encode une instruction <c>call</c> et son opérande.</summary>
      <param name="methodHandle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary>Encode une instruction <c>call</c> et son opérande.</summary>
      <param name="methodHandle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.MethodSpecificationHandle)">
      <summary>Encode une instruction <c>call</c> et son opérande.</summary>
      <param name="methodHandle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.CallIndirect(System.Reflection.Metadata.StandaloneSignatureHandle)">
      <summary>Encode une instruction <c>calli</c> et son opérande.</summary>
      <param name="signature" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.DefineLabel">
      <summary>Définit une étiquette qui peut être utilisée ultérieurement pour marquer et référer à un emplacement dans le flux d’instructions.</summary>
      <exception cref="T:System.InvalidOperationException">
        <see cref="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder" /> a la valeur <see langword="null" />.</exception>
      <returns>Handle de l’étiquette.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadArgument(System.Int32)">
      <summary>Encode l’instruction de chargement des arguments.</summary>
      <param name="argumentIndex">Index de l’argument.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="argumentIndex" /> est un nombre négatif.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadArgumentAddress(System.Int32)">
      <summary>Encode l’instruction de chargement des adresses d’argument.</summary>
      <param name="argumentIndex">Index de l’argument.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="argumentIndex" /> est un nombre négatif.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantI4(System.Int32)">
      <summary>Encode l’instruction de chargement des constantes <see cref="T:System.Int32" />.</summary>
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantI8(System.Int64)">
      <summary>Encode l’instruction de chargement des constantes <see cref="T:System.Int64" />.</summary>
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantR4(System.Single)">
      <summary>Encode l’instruction de chargement des constantes <see cref="T:System.Single" />.</summary>
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantR8(System.Double)">
      <summary>Encode l’instruction de chargement des constantes <see cref="T:System.Double" />.</summary>
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadLocal(System.Int32)">
      <summary>Encode l’instruction de chargement des variables locales.</summary>
      <param name="slotIndex">Index de l’emplacement des variables locales.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="slotIndex" /> est un nombre négatif.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadLocalAddress(System.Int32)">
      <summary>Encode l’instruction de chargement des adresses de variable locale.</summary>
      <param name="slotIndex">Index de l’emplacement des variables locales.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="slotIndex" /> est un nombre négatif.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)">
      <summary>Encode une instruction <c>ldstr</c> et son opérande.</summary>
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.MarkLabel(System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary>Associe l’étiquette spécifiée au décalage IL actuel.</summary>
      <param name="label">Étiquette à marquer.</param>
      <exception cref="T:System.InvalidOperationException">
        <see cref="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="label" /> n’a pas été définie par cet encodeur.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="label" /> a une valeur par défaut.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.OpCode(System.Reflection.Metadata.ILOpCode)">
      <summary>Encode le code d’opération spécifié.</summary>
      <param name="code" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.StoreArgument(System.Int32)">
      <summary>Encode l’instruction de stockage des arguments.</summary>
      <param name="argumentIndex">Index de l’argument.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="argumentIndex" /> est un nombre négatif.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.StoreLocal(System.Int32)">
      <summary>Encode l’instruction de stockage des variables locales.</summary>
      <param name="slotIndex">Index de l’emplacement des variables locales.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="slotIndex" /> est un nombre négatif.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Token(System.Int32)">
      <summary>Encode un jeton.</summary>
      <param name="token" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Token(System.Reflection.Metadata.EntityHandle)">
      <summary>Encode un jeton.</summary>
      <param name="handle" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.CodeBuilder">
      <summary>Générateur sous-jacent dans lequel les instructions encodées sont écrites.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder">
      <summary>Étiquettes de suivi, branches et gestionnaires d’exceptions du générateur.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.Offset">
      <summary>Décalage de l’instruction encodée suivante.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.LabelHandle" />
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.Equals(System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary>Indique si l'objet actuel est égal à un autre objet du même type.</summary>
      <param name="other">Objet à comparer à cet objet.</param>
      <returns>
        <see langword="true" /> si l'objet actuel est égal au paramètre <paramref name="other" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.op_Equality(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.op_Inequality(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.LabelHandle.Id">
      <summary>ID de base 1 identifiant l’étiquette dans le contexte d’un <see cref="T:System.Reflection.Metadata.Ecma335.ControlFlowBuilder" />.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.LabelHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.Ecma335.LiteralEncoder">
      <summary>Fournit des méthodes d'encodage des littéraux.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder">Crée une nouvelle instance de la classe <see cref="T:System.Reflection.Metadata.Ecma335.LiteralEncoder" /> avec le générateur d’objets Blob spécifié.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.Scalar">
      <summary>Renvoie l’encodeur utilisé pour encoder la valeur du littéral.</summary>
      <returns>Encodeur de la valeur du littéral.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedScalar(System.Action{System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.ScalarEncoder})">
      <summary>Encode le type et la valeur d'un littéral en utilisant les délégués spécifiés.</summary>
      <param name="type">Délégué utilisé pour encoder le type du littéral. Appelé en premier par cette méthode.</param>
      <param name="scalar">Délégué utilisé pour encoder la valeur du littéral. Appelé en second par cette méthode.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> ou <paramref name="scalar" /> est <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedScalar(System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder@,System.Reflection.Metadata.Ecma335.ScalarEncoder@)">
      <summary>Retourne une paire d’encodeurs qui doivent être utilisés pour encoder le type et la valeur d’un littéral dans l’ordre dans lequel ils apparaissent dans la liste de paramètres.</summary>
      <param name="type">Lorsque cette méthode est retournée, encodeur de type d’élément d'attribut personnalisé utilisé pour encoder le type du littéral.</param>
      <param name="scalar">Lorsque cette méthode est retournée, encodeur scalaire utilisé pour encoder la valeur du littéral.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedVector(System.Action{System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.VectorEncoder})">
      <summary>Encode le type et les éléments du littéral d’un vecteur en utilisant les délégués spécifiés.</summary>
      <param name="arrayType">Délégué utilisé pour encoder le type du vecteur. Appelé en premier par cette méthode.</param>
      <param name="vector">Délégué utilisé pour encoder les éléments du vecteur. Appelé en second par cette méthode.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="arrayType" /> ou <paramref name="vector" /> est <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedVector(System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder@,System.Reflection.Metadata.Ecma335.VectorEncoder@)">
      <summary>Retourne une paire d’encodeurs qui doivent être utilisés pour encoder le type et les éléments du vecteur d’un littéral dans l’ordre dans lequel ils apparaissent dans la liste de paramètres.</summary>
      <param name="arrayType">Lorsque cette méthode est retournée, encodeur de type de tableau d'attributs personnalisé utilisé pour encoder le type du vecteur.</param>
      <param name="vector">Lorsque cette méthode est retournée, encodeur de vecteur utilisé pour encoder les éléments du vecteur.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.Vector">
      <summary>Obtient un encodeur de vecteur utilisé pour encoder les éléments d'un vecteur.</summary>
      <returns>Encodeur de vecteur utilisé pour encoder les éléments d'un vecteur.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.LiteralEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.LiteralsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralsEncoder.AddLiteral" />
    <member name="P:System.Reflection.Metadata.Ecma335.LiteralsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder.AddVariable" />
    <member name="P:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.CustomModifiers" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.Type(System.Boolean,System.Boolean)">
      <param name="isByRef" />
      <param name="isPinned" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.TypedReference" />
    <member name="P:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataAggregator" />
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataAggregator.#ctor(System.Collections.Generic.IReadOnlyList{System.Int32},System.Collections.Generic.IReadOnlyList{System.Int32},System.Collections.Generic.IReadOnlyList{System.Reflection.Metadata.MetadataReader})">
      <param name="baseTableRowCounts" />
      <param name="baseHeapSizes" />
      <param name="deltaReaders" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataAggregator.#ctor(System.Reflection.Metadata.MetadataReader,System.Collections.Generic.IReadOnlyList{System.Reflection.Metadata.MetadataReader})">
      <param name="baseReader" />
      <param name="deltaReaders" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataAggregator.GetGenerationHandle(System.Reflection.Metadata.Handle,System.Int32@)">
      <summary>Calcule le handle de l’entité dans la génération de métadonnées dans laquelle elle est définie, en fonction du handle d’une entité dans les métadonnées d’agrégat.</summary>
      <param name="handle">Handle d’une entité dans les métadonnées d’agrégat.</param>
      <param name="generation">Génération dans laquelle l’entité est définie.</param>
      <returns>Handle de l’entité dans les métadonnées <paramref name="generation" />.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataBuilder">
      <summary>La classe MetadataBuilder lit et écrit des métadonnées d’un assembly de manière très performante. Elle est conçue pour être utilisée par les compilateurs et d’autres outils de génération d’assemblys.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>Crée un générateur pour les tables de métadonnées et les tas.</summary>
      <param name="userStringHeapStartOffset">Décalage de début du tas de chaînes utilisateur. La taille cumulée des tas de chaînes utilisateur de toutes les générations EnC précédentes doit être égale à 0, sauf si les métadonnées sont des métadonnées delta EnC.</param>
      <param name="stringHeapStartOffset">Décalage de début du tas de chaînes. La taille cumulée des tas de chaînes de toutes les générations EnC précédentes doit être égale à 0, sauf si les métadonnées sont des métadonnées delta EnC.</param>
      <param name="blobHeapStartOffset">Décalage de début du tas d’objets blob. La taille cumulée des tas d’objets blob de toutes les générations EnC précédentes doit être égale à 0, sauf si les métadonnées sont des métadonnées delta EnC.</param>
      <param name="guidHeapStartOffset">Décalage de début du tas GUID. La taille cumulée des tas GUID de toutes les générations EnC précédentes doit être égale à 0, sauf si les métadonnées sont des métadonnées delta EnC.</param>
      <exception cref="T:System.Reflection.Metadata.ImageFormatLimitationException">Le décalage est trop grand.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Le décalage est négatif.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="guidHeapStartOffset" /> n’est pas un multiple de la taille du GUID.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddAssembly(System.Reflection.Metadata.StringHandle,System.Version,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Reflection.AssemblyFlags,System.Reflection.AssemblyHashAlgorithm)">
      <param name="name" />
      <param name="version" />
      <param name="culture" />
      <param name="publicKey" />
      <param name="flags" />
      <param name="hashAlgorithm" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddAssemblyFile(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Boolean)">
      <param name="name" />
      <param name="hashValue" />
      <param name="containsMetadata" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddAssemblyReference(System.Reflection.Metadata.StringHandle,System.Version,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Reflection.AssemblyFlags,System.Reflection.Metadata.BlobHandle)">
      <param name="name" />
      <param name="version" />
      <param name="culture" />
      <param name="publicKeyOrToken" />
      <param name="flags" />
      <param name="hashValue" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddConstant(System.Reflection.Metadata.EntityHandle,System.Object)">
      <summary>Ajoute une valeur par défaut pour un paramètre, un champ ou une propriété.</summary>
      <param name="parent">Handle de l’entité parente, qui peut être l’un des éléments suivants : <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />.</param>
      <param name="value">Valeur constante.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" /> n’a pas le type de poignée attendu.</exception>
      <returns>Handle pour la constante ajoutée.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddCustomAttribute(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Ajoute un attribut personnalisé.</summary>
      <param name="parent">Entité à laquelle attacher l’attribut personnalisé : <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />, <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />, <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />, <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" /> ou <see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />.</param>
      <param name="constructor">Constructeur d’attribut personnalisé : <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />.</param>
      <param name="value">Objet blob de valeur d’attribut personnalisé.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" /> n’a pas le type de poignée attendu.</exception>
      <returns>Handle pour l’attribut personnalisé ajouté.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddCustomDebugInformation(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Ajoute des informations de débogage personnalisées.</summary>
      <param name="parent">Entité à laquelle attacher les informations de débogage : <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />, <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />, <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />, <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" />, <see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.DocumentHandle" />, <see cref="T:System.Reflection.Metadata.LocalScopeHandle" />, <see cref="T:System.Reflection.Metadata.LocalVariableHandle" />, <see cref="T:System.Reflection.Metadata.LocalConstantHandle" /> ou <see cref="T:System.Reflection.Metadata.ImportScopeHandle" />.</param>
      <param name="kind">Type d’information. Détermine la structure de l’objet blob <paramref name="value" />.</param>
      <param name="value">Objet blob d’informations de débogage personnalisées.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" /> n’a pas le type de poignée attendu.</exception>
      <returns>Handle pour les informations de débogage personnalisées ajoutées.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddDeclarativeSecurityAttribute(System.Reflection.Metadata.EntityHandle,System.Reflection.DeclarativeSecurityAction,System.Reflection.Metadata.BlobHandle)">
      <summary>Ajoute un attribut de sécurité déclarative à un type, une méthode ou un assembly.</summary>
      <param name="parent">Handle de l’entité parente, qui peut être l’un des éléments suivants : <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />.</param>
      <param name="action">Action de sécurité déclarative.</param>
      <param name="permissionSet">Objet blob du jeu d’autorisations.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" /> n’a pas le type de poignée attendu.</exception>
      <returns>Handle pour l’attribut de sécurité déclarative ajouté.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddDocument(System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.GuidHandle)">
      <summary>Ajoute des informations de débogage de document.</summary>
      <param name="name">Objet blob de nom de document.</param>
      <param name="hashAlgorithm">GUID de l’algorithme de hachage utilisé pour calculer la valeur de <paramref name="hash" />.</param>
      <param name="hash">Hachage du contenu du document.</param>
      <param name="language">GUID du langage.</param>
      <returns>Handle pour le document ajouté.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEncLogEntry(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.Ecma335.EditAndContinueOperation)">
      <param name="entity" />
      <param name="code" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEncMapEntry(System.Reflection.Metadata.EntityHandle)">
      <param name="entity" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEvent(System.Reflection.EventAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>Ajoute une définition d’événement.</summary>
      <param name="attributes">Attributs de l’événement.</param>
      <param name="name">Nom de l'événement.</param>
      <param name="type">Type de l’événement : <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="type" /> n’a pas le type de poignée attendu.</exception>
      <returns>Handle pour la définition d’événement ajoutée.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEventMap(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="declaringType" />
      <param name="eventList" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddExportedType(System.Reflection.TypeAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle,System.Int32)">
      <summary>Ajoute un type exporté.</summary>
      <param name="attributes">Attributs du type.</param>
      <param name="namespace">Espace de noms du type.</param>
      <param name="name">Nom du type.</param>
      <param name="implementation">Handle de l’entité d’implémentation, qui peut être l’un des éléments suivants : <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" /> ou <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />.</param>
      <param name="typeDefinitionId">ID de définition du type.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="implementation" /> n’a pas le type de poignée attendu.</exception>
      <returns>Handle pour le type exporté ajouté.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddFieldDefinition(System.Reflection.FieldAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Ajoute une définition de champ.</summary>
      <param name="attributes">Attributs du champ.</param>
      <param name="name">Nom du champ.</param>
      <param name="signature">Signature du champ. Utilisez <see cref="M:System.Reflection.Metadata.Ecma335.BlobEncoder.FieldSignature" /> pour construire l’objet blob.</param>
      <returns>Handle pour la définition de champ ajoutée.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddFieldLayout(System.Reflection.Metadata.FieldDefinitionHandle,System.Int32)">
      <summary>Définit la disposition d’un champ d’une définition de champ.</summary>
      <param name="field">Handle de définition de champ.</param>
      <param name="offset">Décalage d’octet du champ dans l’instance de type déclarant.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddFieldRelativeVirtualAddress(System.Reflection.Metadata.FieldDefinitionHandle,System.Int32)">
      <summary>Ajoute un mappage d’un champ à sa valeur initiale stockée dans l’image PE.</summary>
      <param name="field">Handle de définition de champ.</param>
      <param name="offset">Décalage dans le bloc de l’image PE qui stocke les valeurs initiales des champs mappés (généralement dans la section .text).</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="offset" /> est un nombre négatif.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddGenericParameter(System.Reflection.Metadata.EntityHandle,System.Reflection.GenericParameterAttributes,System.Reflection.Metadata.StringHandle,System.Int32)">
      <summary>Ajoute une définition de paramètre générique.</summary>
      <param name="parent">Handle de l’entité parente, qui peut être <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />.</param>
      <param name="attributes">Attributs du paramètre générique.</param>
      <param name="name">Nom du paramètre.</param>
      <param name="index">Index du paramètre de base zéro.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" /> n’a pas le type de poignée attendu.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> est supérieur à <see cref="F:System.UInt16.MaxValue" />.</exception>
      <returns>Handle pour le paramètre générique ajouté.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddGenericParameterConstraint(System.Reflection.Metadata.GenericParameterHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>Ajoute une contrainte de type à un paramètre générique.</summary>
      <param name="genericParameter">Paramètre générique à limiter.</param>
      <param name="constraint">Contrainte de type, qui peut être l’un des éléments suivants : <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="genericParameter" /> n’a pas le type de poignée attendu.</exception>
      <returns>Handle pour la contrainte de paramètre générique ajoutée.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddImportScope(System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Ajoute des informations de débogage de portée locale.</summary>
      <param name="parentScope">Handle de portée parente.</param>
      <param name="imports">Handle de portée d’importation.</param>
      <returns>Handle pour la portée d’importation ajoutée.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddInterfaceImplementation(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>Ajoute une implémentation d’interface à un type.</summary>
      <param name="type">Type implémentant l’interface.</param>
      <param name="implementedInterface">Interface qui est implémentée, qui peut être l’un des éléments suivants : <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="implementedInterface" /> n’a pas le type de poignée attendu.</exception>
      <returns>Handle pour l’implémentation d’interface ajoutée.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddLocalConstant(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Ajoute des informations de débogage de constante locale.</summary>
      <param name="name">Nom de la variable.</param>
      <param name="signature">Objet blob LocalConstantSig.</param>
      <returns>Handle pour la constante locale ajoutée.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddLocalScope(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.LocalVariableHandle,System.Reflection.Metadata.LocalConstantHandle,System.Int32,System.Int32)">
      <summary>Ajoute des informations de débogage de portée locale.</summary>
      <param name="method">Méthode conteneur.</param>
      <param name="importScope">Handle de la portée d’importation associée.</param>
      <param name="variableList">Si la portée déclare des variables, affectez-lui le handle de la première. Sinon, affectez-lui le handle de la première variable déclarée par la définition de portée suivante. Si aucune portée ne définit de variables, <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.LocalVariableHandle(1)" />.</param>
      <param name="constantList">Si la portée déclare des constantes, affectez-lui le handle de la première. Sinon, affectez-lui le handle de la première constante déclarée par la définition de portée suivante. Si aucune portée ne définit de constantes, <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.LocalConstantHandle(1)" />.</param>
      <param name="startOffset">Décalage de la première instruction couverte par la portée.</param>
      <param name="length">Longueur (en octets) de la portée.</param>
      <returns>Handle pour la portée locale ajoutée.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddLocalVariable(System.Reflection.Metadata.LocalVariableAttributes,System.Int32,System.Reflection.Metadata.StringHandle)">
      <summary>Ajoute des informations de débogage de variable locale.</summary>
      <param name="attributes">Attributs de la variable locale.</param>
      <param name="index">Index de base zéro de la variable locale dans la signature locale.</param>
      <param name="name">Nom de la variable.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> est supérieur à <see cref="F:System.UInt16.MaxValue" />.</exception>
      <returns>Handle pour la variable locale ajoutée.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddManifestResource(System.Reflection.ManifestResourceAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle,System.UInt32)">
      <summary>Ajoute une ressource de manifeste.</summary>
      <param name="attributes">Attributs de la ressource de manifeste.</param>
      <param name="name">Nom de la ressource de manifeste.</param>
      <param name="implementation">Handle de l’entité d’implémentation, qui peut être l’un des éléments suivants : <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" /> ou <see langword="null" />.</param>
      <param name="offset">Spécifie le décalage d’octet dans le fichier référencé à partir duquel commence cet enregistrement de ressource.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="implementation" /> n’a pas le type de poignée attendu.</exception>
      <returns>Handle pour la ressource de manifeste ajoutée.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMarshallingDescriptor(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Ajoute des informations de marshaling à un champ ou à un paramètre.</summary>
      <param name="parent">Handle de l’entité parente, qui peut être l’un des éléments suivants : <see cref="T:System.Reflection.Metadata.ParameterHandle" /> ou <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />.</param>
      <param name="descriptor">Objet blob du descripteur.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" /> n’a pas le type de poignée attendu.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMemberReference(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Ajoute une ligne de table MemberRef.</summary>
      <param name="parent">Entité conteneur, qui peut être l’un des éléments suivants : <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <param name="name">Nom du membre.</param>
      <param name="signature">Signature du membre.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" /> n’a pas le type de poignée attendu.</exception>
      <returns>Handle pour la référence de membre ajoutée.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodDebugInformation(System.Reflection.Metadata.DocumentHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Ajoute des informations de débogage de méthode.</summary>
      <param name="document">Handle d’un document unique contenant tous les points de séquence de la méthode, ou <see langword="null" /> si la méthode n’a pas de points de séquence ou s’étend sur plusieurs documents.</param>
      <param name="sequencePoints">Objet blob de points de séquence, ou <see langword="null" /> si la méthode n’a pas de points de séquence.</param>
      <returns>Handle pour les informations de débogage de méthode ajoutées.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodDefinition(System.Reflection.MethodAttributes,System.Reflection.MethodImplAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Int32,System.Reflection.Metadata.ParameterHandle)">
      <summary>Ajoute une définition de méthode.</summary>
      <param name="attributes">Attributs de la méthode.</param>
      <param name="implAttributes">Attributs d’implémentation de la méthode.</param>
      <param name="name">Nom de la méthode.</param>
      <param name="signature">Signature de méthode.</param>
      <param name="bodyOffset">Décalage dans le bloc de l’image PE qui stocke les corps de méthode (flux IL), ou -1 si la méthode n’a pas de corps.</param>
      <param name="parameterList">Si la méthode déclare des paramètres dans la table Params, affectez-lui le handle du premier. Sinon, affectez-lui le handle du premier paramètre déclaré par la définition de méthode suivante. Si aucun paramètre n’est déclaré dans le module, <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.ParameterHandle(1)" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="bodyOffset" /> est inférieur à -1.</exception>
      <returns>Handle pour la définition de méthode ajoutée.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodImplementation(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>Définit une implémentation pour une déclaration de méthode dans un type.</summary>
      <param name="type">Définition de type.</param>
      <param name="methodBody">Handle de l’entité de corps de méthode, qui peut être l’un des éléments suivants : <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />.</param>
      <param name="methodDeclaration">Handle de l’entité de déclaration de méthode, qui peut être l’un des éléments suivants : <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="methodBody" /> ou <paramref name="methodDeclaration" /> n’a pas le type de poignée attendu.</exception>
      <returns>Handle pour l’implémentation de méthode ajoutée.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodImport(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.MethodImportAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.ModuleReferenceHandle)">
      <summary>Ajoute des informations d’importation à une définition de méthode.</summary>
      <param name="method">Handle de la définition de méthode.</param>
      <param name="attributes">Attributs d’importation de la méthode.</param>
      <param name="name">Nom de la méthode non managée.</param>
      <param name="module">Module contenant la méthode non managée.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodSemantics(System.Reflection.Metadata.EntityHandle,System.Reflection.MethodSemanticsAttributes,System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary>Associe une méthode (getter, setter, adder, etc.) à une propriété ou à un événement.</summary>
      <param name="association">Handle de l’entité d’association, qui peut être l’un des éléments suivants : <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />.</param>
      <param name="semantics">Attributs des sémantiques de la méthode.</param>
      <param name="methodDefinition">Définition de la méthode.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="association" /> n’a pas le type de poignée attendu.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodSpecification(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Ajoute une spécification de méthode (instanciation).</summary>
      <param name="method">Handle de l’entité de méthode générique, qui peut être l’un des éléments suivants : <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />.</param>
      <param name="instantiation">Objet blob d’instanciation qui encode les arguments génériques de la méthode.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’a pas le type de poignée attendu.</exception>
      <returns>Handle pour la spécification de méthode ajoutée.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddModule(System.Int32,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle)">
      <param name="generation" />
      <param name="moduleName" />
      <param name="mvid" />
      <param name="encId" />
      <param name="encBaseId" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddModuleReference(System.Reflection.Metadata.StringHandle)">
      <param name="moduleName" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddNestedType(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.TypeDefinitionHandle)">
      <summary>Définit une relation d’imbrication avec les définitions de type spécifiées.</summary>
      <param name="type">Handle de définition de type imbriqué.</param>
      <param name="enclosingType">Handle de définition de type englobant.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddParameter(System.Reflection.ParameterAttributes,System.Reflection.Metadata.StringHandle,System.Int32)">
      <summary>Ajoute une définition de paramètre.</summary>
      <param name="attributes">Attributs du paramètre.</param>
      <param name="name">Optionnel. Nom du paramètre.</param>
      <param name="sequenceNumber">Numéro de séquence du paramètre. La valeur 0 fait référence au type de retour de la méthode de propriétaire ; ses paramètres sont ensuite numérotés à partir de 1.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="sequenceNumber" /> est supérieur à <see cref="F:System.UInt16.MaxValue" />.</exception>
      <returns>Handle pour le paramètre ajouté.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddProperty(System.Reflection.PropertyAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Ajoute une définition de propriété.</summary>
      <param name="attributes">Attributs de la propriété.</param>
      <param name="name">Nom de la propriété.</param>
      <param name="signature">Signature de la propriété.</param>
      <returns>Handle pour la définition de propriété ajoutée.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddPropertyMap(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="declaringType" />
      <param name="propertyList" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddStandaloneSignature(System.Reflection.Metadata.BlobHandle)">
      <param name="signature" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddStateMachineMethod(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary>Ajoute des informations de débogage de méthode d’ordinateur d’état.</summary>
      <param name="moveNextMethod">Handle de la méthode <see langword="MoveNext" /> de l’ordinateur d’état (méthode générée par le compilateur).</param>
      <param name="kickoffMethod">Handle de la méthode de démarrage (méthode iterator/async définie par l’utilisateur).</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeDefinition(System.Reflection.TypeAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.FieldDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary>Ajoute une définition de type.</summary>
      <param name="attributes">Attributs du type.</param>
      <param name="namespace">Espace de noms du type.</param>
      <param name="name">Nom du type.</param>
      <param name="baseType">Handle de l’entité de type de base, qui peut être l’un des éléments suivants : <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /> ou <see langword="null" />.</param>
      <param name="fieldList">Si le type déclare des champs, affectez-lui le handle du premier. Sinon, affectez-lui le handle du premier champ déclaré par la définition de type suivante. Si aucun type ne définit de champs dans le module, <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.FieldDefinitionHandle(1)" />.</param>
      <param name="methodList">Si le type déclare des méthodes, handle de la première. Sinon, handle de la première méthode déclarée par la définition de type suivante. Si aucun type ne définit de méthodes dans le module, <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDefinitionHandle(1)" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="baseType" /> n’a pas le type de poignée attendu.</exception>
      <returns>Handle pour la définition de type ajoutée.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeLayout(System.Reflection.Metadata.TypeDefinitionHandle,System.UInt16,System.UInt32)">
      <summary>Définit une disposition de type d’une définition de type.</summary>
      <param name="type">Définition de type.</param>
      <param name="packingSize">Spécifie que les champs doivent être placés dans l’instance de type à des adresses d’octets qui sont un multiple de <paramref name="packingSize" />, ou à l’alignement naturel pour ce type de champ, selon celui qui est le plus petit. Sa valeur doit être l’une des suivantes : 0, 1, 2, 4, 8, 16, 32, 64 ou 128. La valeur zéro indique que la taille de compression utilisée doit correspondre à la valeur par défaut de la plateforme actuelle.</param>
      <param name="size">Indique une taille minimale de l’instance de type et est destinée à tenir compte du remplissage. La quantité de mémoire allouée est la taille maximale calculée à partir de la disposition et <paramref name="size" />. Notez que, si cette directive s’applique à un type valeur, la taille est inférieure à 1 Mo.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeReference(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle)">
      <summary>Ajoute une référence de type.</summary>
      <param name="resolutionScope">Entité déclarant le type de cible, qui peut être l’un des éléments suivants : <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> ou <see langword="null" />.</param>
      <param name="namespace">Espace de noms de la référence de type.</param>
      <param name="name">Nom de la référence de type.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="resolutionScope" /> n’a pas le type de poignée attendu.</exception>
      <returns>Handle pour la référence de type ajoutée.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeSpecification(System.Reflection.Metadata.BlobHandle)">
      <param name="signature" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlob(System.Byte[])">
      <summary>Ajoute l’objet blob spécifié au tas d’objets blob, s’il n’y figure pas déjà.</summary>
      <param name="value">Tableau contenant l’objet blob.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> a la valeur <see langword="null" />.</exception>
      <returns>Handle pour l’objet blob ajouté ou existant.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlob(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>Ajoute l’objet blob spécifié à partir d’un tableau d’octets au tas d’objets blob, s’il n’y figure pas déjà.</summary>
      <param name="value">Tableau contenant l’objet blob.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> a la valeur <see langword="null" />.</exception>
      <returns>Handle pour l’objet blob ajouté ou existant.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlob(System.Reflection.Metadata.BlobBuilder)">
      <summary>Ajoute l’objet blob spécifié à partir d’un tableau d’octets immuable au tas d’objets blob, s’il n’y figure pas déjà.</summary>
      <param name="value">Instance du générateur d’objets blob contenant l’objet blob.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> a la valeur <see langword="null" />.</exception>
      <returns>Handle pour l’objet blob ajouté ou existant.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlobUTF16(System.String)">
      <summary>Encode une chaîne avec l’encodage UTF16 dans un objet blob et l’ajoute au tas d’objets blob, si elle n’y figure pas déjà.</summary>
      <param name="value">Chaîne à ajouter.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> a la valeur <see langword="null" />.</exception>
      <returns>Handle pour l’objet blob ajouté ou existant.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlobUTF8(System.String,System.Boolean)">
      <summary>Encode une chaîne avec l’encodage UTF8 dans un objet blob et l’ajoute au tas d’objets blob, si elle n’y figure pas déjà.</summary>
      <param name="value">Valeur à ajouter.</param>
      <param name="allowUnpairedSurrogates">
        <see langword="true" /> pour encoder les substituts non couplés comme spécifié ; <see langword="false" /> pour les remplacer par le caractère U+FFFD.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> a la valeur <see langword="null" />.</exception>
      <returns>Handle pour l’objet blob ajouté ou existant.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddConstantBlob(System.Object)">
      <summary>Encode une valeur constante dans un objet blob et l’ajoute au tas d’objets blob, si elle n’y figure pas déjà. Utilise UTF16 pour encoder des constantes de chaîne.</summary>
      <param name="value">Valeur constante à ajouter.</param>
      <returns>Handle pour l’objet blob ajouté ou existant.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddDocumentName(System.String)">
      <summary>Encode un nom de document de débogage et l’ajoute au tas d’objets blob, s’il n’y figure pas déjà.</summary>
      <param name="value">Nom du document à ajouter.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> a la valeur <see langword="null" />.</exception>
      <returns>Handle pour l’objet blob de nom de document ajouté ou existant.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddGuid(System.Guid)">
      <summary>Ajoute le GUID spécifié au tas GUID, s’il n’y figure pas déjà.</summary>
      <param name="guid">GUID à ajouter.</param>
      <returns>Handle pour le GUID ajouté ou existant.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddString(System.String)">
      <summary>Ajoute la chaîne spécifiée au tas de chaînes, si elle n’y figure pas déjà.</summary>
      <param name="value">Chaîne à ajouter.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> a la valeur <see langword="null" />.</exception>
      <returns>Handle pour la chaîne ajoutée ou existante.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddUserString(System.String)">
      <summary>Ajoute la chaîne spécifiée au tas de chaînes utilisateur, si elle n’y figure pas déjà.</summary>
      <param name="value">Chaîne à ajouter.</param>
      <exception cref="T:System.Reflection.Metadata.ImageFormatLimitationException">L’espace restant sur le segment de mémoire est trop petit pour tenir dans la chaîne.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> a la valeur <see langword="null" />.</exception>
      <returns>Handle pour la chaîne ajoutée ou existante. Cette valeur peut être utilisée dans <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetRowCount(System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary>Retourne le nombre actuel d’éléments dans la table spécifiée.</summary>
      <param name="table">Index de la table.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="table" /> n’est pas un index de table valide.</exception>
      <returns>Nombre d’éléments dans la table.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetRowCounts">
      <summary>Retourne le nombre actuel d’éléments dans chaque table.</summary>
      <returns>Tableau de taille <see cref="F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount" />, chaque élément étant rempli avec le nombre de lignes actuel de la table correspondante.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.ReserveGuid">
      <summary>Réserve de l’espace sur le tas GUID pour un GUID.</summary>
      <exception cref="T:System.Reflection.Metadata.ImageFormatLimitationException">L’espace restant sur le segment de mémoire est trop petit pour tenir dans la chaîne.</exception>
      <returns>Handle pour le GUID réservé et <see cref="T:System.Reflection.Metadata.Blob" /> représentant l’objet blob GUID tel qu’il est stocké sur le tas.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.ReserveUserString(System.Int32)">
      <summary>Réserve de l’espace sur le tas de chaînes utilisateur pour une chaîne de la longueur spécifiée.</summary>
      <param name="length">Nombre de caractères à réserver.</param>
      <exception cref="T:System.Reflection.Metadata.ImageFormatLimitationException">L’espace restant sur le segment de mémoire est trop petit pour tenir dans la chaîne.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" /> est un nombre négatif.</exception>
      <returns>Handle pour la chaîne utilisateur réservée et <see cref="T:System.Reflection.Metadata.Blob" /> représentant l’intégralité de l’objet blob de la chaîne utilisateur (avec sa longueur et son caractère de fin). Le handle peut être utilisé dans <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)" />.
Utilisez <see cref="M:System.Reflection.Metadata.BlobWriter.WriteUserString(System.String)" /> pour remplir l’objet blob.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.SetCapacity(System.Reflection.Metadata.Ecma335.HeapIndex,System.Int32)">
      <summary>Définit la capacité du tas spécifié.</summary>
      <param name="heap">Index du tas.</param>
      <param name="byteCount">Nombre d’octets.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="heap" /> n’est pas un index de segment de mémoire valide.

- ou -

<paramref name="byteCount" /> est un nombre négatif.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.SetCapacity(System.Reflection.Metadata.Ecma335.TableIndex,System.Int32)">
      <summary>Définit la capacité de la table spécifiée.</summary>
      <param name="table">Index de la table.</param>
      <param name="rowCount">Nombre de lignes du tableau.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="table" /> n’est pas un index de table valide.

- ou -

<paramref name="rowCount" /> est un nombre négatif.</exception>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions">
      <summary>Fournit des méthodes d'extension pour utiliser certains éléments bruts des tas et tables de métadonnées ECMA-335.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetEditAndContinueLogEntries(System.Reflection.Metadata.MetadataReader)">
      <summary>Énumère les entrées du journal EnC.</summary>
      <param name="reader" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetEditAndContinueMapEntries(System.Reflection.Metadata.MetadataReader)">
      <summary>Énumère les entrées du journal EnC.</summary>
      <param name="reader" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetHeapMetadataOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.HeapIndex)">
      <summary>Retourne le décalage du début des métadonnées au tas spécifié.</summary>
      <param name="reader" />
      <param name="heapIndex" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="heapIndex" /> n’est pas un index de segment de mémoire valide.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetHeapSize(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.HeapIndex)">
      <summary>Retourne la taille du tas spécifié.</summary>
      <param name="reader" />
      <param name="heapIndex" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="heapIndex" /> n’est pas un index de segment de mémoire valide.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.BlobHandle)">
      <summary>Retourne le handle à l’élément <see cref="T:System.Reflection.Metadata.Blob" /> qui suit celui fourni dans le tas <see cref="T:System.Reflection.Metadata.Blob" />, ou un handle nul si c’est le dernier.</summary>
      <param name="reader" />
      <param name="handle" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.StringHandle)">
      <summary>Retourne le handle à la chaîne qui suit celle fournie dans le tas String, ou un handle nul si c’est le dernier.</summary>
      <param name="reader" />
      <param name="handle" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.UserStringHandle)">
      <summary>Retourne le handle à l’élément UserString qui suit celle fournie dans le tas UserString, ou un handle nul si c’est le dernier.</summary>
      <param name="reader" />
      <param name="handle" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableMetadataOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary>Retourne le décalage du début des métadonnées à la table spécifiée.</summary>
      <param name="reader" />
      <param name="tableIndex" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="tableIndex" /> n’est pas un index de table valide.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableRowCount(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary>Retourne le nombre de lignes dans la table spécifiée.</summary>
      <param name="reader" />
      <param name="tableIndex" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="tableIndex" /> n’est pas un index de table valide.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableRowSize(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary>Retourne la taille d’une ligne dans la table spécifiée.</summary>
      <param name="reader" />
      <param name="tableIndex" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="tableIndex" /> n’est pas un index de table valide.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTypesWithEvents(System.Reflection.Metadata.MetadataReader)">
      <summary>Énumérez les types qui définissent un ou plusieurs événements.</summary>
      <param name="reader" />
      <returns>La séquence résultante correspond exactement aux entrées de la table EventMap, c'est-à-dire que le n-ième élément <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> retourné est consigné dans la n-ième ligne de la table EventMap.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTypesWithProperties(System.Reflection.Metadata.MetadataReader)">
      <summary>Énumérez les types qui définissent une ou plusieurs propriétés.</summary>
      <param name="reader" />
      <returns>La séquence résultante correspond exactement aux entrées de la table de mappage des propriétés, c'est-à-dire que le n-ième élément <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> retourné est consigné dans la n-ième ligne de la table de mappage des propriétés.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)">
      <summary>Selon un handle de type et un type brut dans une signature blob, détermine si le type cible est un type valeur ou un type référence.</summary>
      <param name="reader" />
      <param name="typeHandle" />
      <param name="rawTypeKind" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataRootBuilder">
      <summary>Générateur d’une racine de métadonnées à incorporer dans une image exécutable portable.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.#ctor(System.Reflection.Metadata.Ecma335.MetadataBuilder,System.String,System.Boolean)">
      <summary>Crée un constructeur d'une racine de métadonnées.</summary>
      <param name="tablesAndHeaps">Générateur rempli avec les entités de métadonnées stockées dans les tables et les valeurs stockées dans les tas. Les entités et les valeurs seront énumérées lors de la sérialisation de la racine de métadonnées.</param>
      <param name="metadataVersion">Chaîne de version écrite dans l'en-tête des métadonnées. La valeur par défaut est « v4.0.30319 ».</param>
      <param name="suppressValidation">
        <see langword="true" /> pour supprimer la validation de base des tables de métadonnées pendant la sérialisation ; sinon, <paramref name="false" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="tablesAndHeaps" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="metadataVersion" /> est trop long (le nombre d’octets du codage UTF8 doit être inférieur à 255).</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.Serialize(System.Reflection.Metadata.BlobBuilder,System.Int32,System.Int32)">
      <summary>Sérialise le contenu de la racine de métadonnées dans le <see cref="T:System.Reflection.Metadata.BlobBuilder" /> donné.</summary>
      <param name="builder">Générateur dans lequel écrire.</param>
      <param name="methodBodyStreamRva">Adresse virtuelle relative du début du flux du corps de la méthode. Utilisé pour calculer la valeur finale des champs RVA de la table MethodDef.</param>
      <param name="mappedFieldDataStreamRva">Adresse virtuelle relative du début du flux de données d’initialisation des champs. Utilisé pour calculer la valeur finale des champs RVA de la table FieldRVA.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="builder" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="methodBodyStreamRva" /> ou <paramref name="mappedFieldDataStreamRva" /> est un nombre négatif.</exception>
      <exception cref="T:System.InvalidOperationException">Une table de métadonnées n’est pas triée comme l’exige la spécification et <see cref="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.SuppressValidation" /> est <see langword="false" />.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.MetadataVersion">
      <summary>Version des métadonnées.</summary>
      <returns>Chaîne qui représente la version des métadonnées.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.Sizes">
      <summary>Retourne des tailles de diverses structures de métadonnées.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.SuppressValidation">
      <summary>Détermine si la validation de base des tables de métadonnées doit être supprimée. La validation vérifie que les entrées dans les tables ont été ajoutées dans l’ordre requis par la spécification ECMA. Elle n’applique pas toutes les exigences de spécification aux tables de métadonnées.</summary>
      <returns>
        <see langword="true" /> pour supprimer la validation de base des tables de métadonnées ; Sinon, <see langword="false" /> .</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataSizes">
      <summary>Fournit des informations sur les tailles de diverses structures de métadonnées.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataSizes.GetAlignedHeapSize(System.Reflection.Metadata.Ecma335.HeapIndex)">
      <summary>Retourne la taille alignée du tas spécifié.</summary>
      <param name="index" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataSizes.ExternalRowCounts">
      <summary>Nombre de lignes de la table externe.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataSizes.HeapSizes">
      <summary>Tailles de tas exactes (non alignées).</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataSizes.RowCounts">
      <summary>Nombres de lignes de table.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataTokens" />
    <member name="F:System.Reflection.Metadata.Ecma335.MetadataTokens.HeapCount">
      <summary>Nombre maximum de tableaux pouvant être présentes dans les métadonnées Ecma335.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount">
      <summary>Nombre maximum de tableaux pouvant être présentes dans les métadonnées Ecma335.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.AssemblyFileHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.AssemblyReferenceHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.BlobHandle(System.Int32)">
      <param name="offset" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ConstantHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.CustomAttributeHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.CustomDebugInformationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.DeclarativeSecurityAttributeHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.DocumentHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.DocumentNameBlobHandle(System.Int32)">
      <param name="offset" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.EntityHandle(System.Int32)">
      <summary>Crée un handle d’entité à partir d'une valeur de jeton.</summary>
      <param name="token" />
      <exception cref="T:System.ArgumentException">
        <paramref name="token" /> n’est pas un jeton d’entité de métadonnées valide.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.EntityHandle(System.Reflection.Metadata.Ecma335.TableIndex,System.Int32)">
      <summary>Crée un <see cref="T:System.Reflection.Metadata.EntityHandle" /> à partir d'une valeur de jeton.</summary>
      <param name="tableIndex" />
      <param name="rowNumber" />
      <exception cref="T:System.ArgumentException">
        <paramref name="tableIndex" /> n’est pas un index de table valide.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.EventDefinitionHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ExportedTypeHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.FieldDefinitionHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GenericParameterConstraintHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GenericParameterHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.BlobHandle)">
      <summary>Obtient le décalage des données du tas de métadonnées qui correspond au <paramref name="handle" /> spécifié.</summary>
      <param name="handle" />
      <returns>Décalage basé sur 0, ou -1 si <paramref name="handle" /> ne peut être interprété que dans le contexte d'un élément <see cref="T:System.Reflection.Metadata.MetadataReader" /> ou <see cref="T:System.Reflection.Metadata.Ecma335.MetadataBuilder" /> spécifique.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.GuidHandle)">
      <summary>Obtient le décalage des données du tas de métadonnées qui correspond au <paramref name="handle" /> spécifié.</summary>
      <param name="handle" />
      <returns>Index basé sur 1 dans le tas #Guid. Contrairement aux autres tas, qui représentent essentiellement des tableaux d'octets, le tas #Guid est un tableau de GUID de 16 octets.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.Handle)">
      <summary>Obtient le décalage des données du tas de métadonnées qui correspond au <paramref name="handle" /> spécifié.</summary>
      <param name="handle" />
      <returns>Décalage dans le tas correspondant, ou -1 si <paramref name="handle" /> ne peut être interprété que dans le contexte d’un élément de <see cref="T:System.Reflection.Metadata.MetadataReader" /> ou <see cref="T:System.Reflection.Metadata.Ecma335.MetadataBuilder" /> spécifique.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Handle)">
      <summary>Obtient le décalage des données du tas de métadonnées correspondant à l’élément <paramref name="handle" /> spécifié dans le contexte de <paramref name="reader" />.</summary>
      <param name="reader" />
      <param name="handle" />
      <exception cref="T:System.NotSupportedException">L’opération n’est pas prise en charge pour la <paramref name="handle" /> spécifiée.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="handle" /> n'est pas valide.</exception>
      <returns>Décalage basé sur zéro, ou -1 si <paramref name="handle" /> n'est pas un handle de tas de métadonnées.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.StringHandle)">
      <summary>Obtient le décalage des données du tas de métadonnées qui correspond au <paramref name="handle" /> spécifié.</summary>
      <param name="handle" />
      <returns>Décalage basé sur 0, ou -1 si <paramref name="handle" /> ne peut être interprété que dans le contexte d'un élément <see cref="T:System.Reflection.Metadata.MetadataReader" /> ou <see cref="T:System.Reflection.Metadata.Ecma335.MetadataBuilder" /> spécifique.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.UserStringHandle)">
      <summary>Obtient le décalage des données du tas de métadonnées qui correspond au <paramref name="handle" /> spécifié.</summary>
      <param name="handle" />
      <returns>Décalage basé sur zéro.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.EntityHandle)">
      <summary>Obtient le numéro de ligne d'une entrée de table de métadonnées correspondant à l’élément <paramref name="handle" /> spécifié.</summary>
      <param name="handle" />
      <returns>Décalage basé sur 1, ou -1 si <paramref name="handle" /> ne peut être interprété que dans le contexte d'un élément <see cref="T:System.Reflection.Metadata.MetadataReader" /> spécifique.
Consultez <see cref="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)">
      <summary>Obtient le numéro de ligne d'une entrée de table de métadonnées correspondant à l’élément <paramref name="handle" /> spécifié dans le contexte de <paramref name="reader" />.</summary>
      <param name="reader" />
      <param name="handle" />
      <exception cref="T:System.ArgumentException">La <paramref name="handle" /> n’est pas une poignée de table de métadonnées valide.</exception>
      <returns>Numéro de ligne basé sur 1.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.EntityHandle)">
      <summary>Obtient le jeton de métadonnées de l’élément <paramref name="handle" /> spécifié.</summary>
      <param name="handle" />
      <returns>Jeton de métadonnées, ou -0 si <paramref name="handle" /> ne peut être interprété que dans le contexte d'un élément <see cref="T:System.Reflection.Metadata.MetadataReader" /> spécifique.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.Handle)">
      <summary>Obtient le jeton de métadonnées de l’élément <paramref name="handle" /> spécifié.</summary>
      <param name="handle" />
      <exception cref="T:System.ArgumentException">La poignée représente une entité de métadonnées qui n’a pas de jeton.
Un jeton peut uniquement être récupéré pour une poignée de table de métadonnées ou une poignée de segment de mémoire de type <see cref="F:System.Reflection.Metadata.HandleKind.UserString" />.</exception>
      <returns>Jeton de métadonnées, ou -0 si <paramref name="handle" /> ne peut être interprété que dans le contexte d'un élément <see cref="T:System.Reflection.Metadata.MetadataReader" /> spécifique.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)">
      <summary>Obtient le jeton de métadonnées de l’élément <paramref name="handle" /> spécifié dans le contexte de <paramref name="reader" />.</summary>
      <param name="reader" />
      <param name="handle" />
      <exception cref="T:System.NotSupportedException">L’opération n’est pas prise en charge pour la <paramref name="handle" /> spécifiée.</exception>
      <returns>Jeton de métadonnées.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Handle)">
      <summary>Obtient le jeton de métadonnées de l’élément <paramref name="handle" /> spécifié dans le contexte de <paramref name="reader" />.</summary>
      <param name="reader" />
      <param name="handle" />
      <exception cref="T:System.ArgumentException">La poignée représente une entité de métadonnées qui n’a pas de jeton.
Un jeton peut uniquement être récupéré pour une poignée de table de métadonnées ou une poignée de segment de mémoire de type <see cref="F:System.Reflection.Metadata.HandleKind.UserString" />.</exception>
      <exception cref="T:System.NotSupportedException">L’opération n’est pas prise en charge pour la <paramref name="handle" /> spécifiée.</exception>
      <returns>Jeton de métadonnées.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GuidHandle(System.Int32)">
      <param name="offset" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.Handle(System.Int32)">
      <summary>Crée un handle à partir d'une valeur de jeton.</summary>
      <param name="token" />
      <exception cref="T:System.ArgumentException">
        <paramref name="token" /> n’est pas un jeton de métadonnées valide.
Il doit encoder une entité de table de métadonnées ou un décalage dans le segment de mémoire <see cref="F:System.Reflection.Metadata.HandleKind.UserString" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.Handle(System.Reflection.Metadata.Ecma335.TableIndex,System.Int32)">
      <summary>Crée un <see cref="T:System.Reflection.Metadata.EntityHandle" /> à partir d'une valeur de jeton.</summary>
      <param name="tableIndex" />
      <param name="rowNumber" />
      <exception cref="T:System.ArgumentException">
        <paramref name="tableIndex" /> n’est pas un index de table valide.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ImportScopeHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.InterfaceImplementationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.LocalConstantHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.LocalScopeHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.LocalVariableHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ManifestResourceHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MemberReferenceHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDebugInformationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDefinitionHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodImplementationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodSpecificationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ModuleReferenceHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ParameterHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.PropertyDefinitionHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.StandaloneSignatureHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.StringHandle(System.Int32)">
      <param name="offset" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TryGetHeapIndex(System.Reflection.Metadata.HandleKind,System.Reflection.Metadata.Ecma335.HeapIndex@)">
      <summary>Obtient l’élément <see cref="T:System.Reflection.Metadata.Ecma335.HeapIndex" /> du tas correspondant à l’élément <see cref="T:System.Reflection.Metadata.HandleKind" /> spécifié.</summary>
      <param name="type">Type de handle.</param>
      <param name="index">Index du tas.</param>
      <returns>
        <see langword="true" /> si le type de handle correspond à un tas Ecma335 ; <see langword="false" /> sinon.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TryGetTableIndex(System.Reflection.Metadata.HandleKind,System.Reflection.Metadata.Ecma335.TableIndex@)">
      <summary>Obtient l’élément <see cref="T:System.Reflection.Metadata.Ecma335.TableIndex" /> du tableau correspondant à l’élément <see cref="T:System.Reflection.Metadata.HandleKind" /> spécifié.</summary>
      <param name="type">Type de handle.</param>
      <param name="index">Index du tableau.</param>
      <returns>
        <see langword="true" /> si le type de handle correspond à un tableau Ecma335 ou Portable PDB ; <see langword="false" /> sinon.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TypeDefinitionHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TypeReferenceHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TypeSpecificationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.UserStringHandle(System.Int32)">
      <param name="offset" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MethodBodyAttributes">
      <summary>Définit les attributs du corps de la méthode.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MethodBodyAttributes.InitLocals">
      <summary>Initialise les variables locales que la méthode définit à zéro et alloue dynamiquement de la mémoire locale.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MethodBodyAttributes.None">
      <summary>N’effectue aucune initialisation de la mémoire locale.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder">
      <summary>Fournit un encodeur pour un flux de corps de méthode.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Int32,System.Int32,System.Int32,System.Boolean,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes)">
      <summary>Encode un corps de méthode et l’ajoute au flux du corps de la méthode à l’aide de la taille de code, de la taille de pile maximale, du nombre de régions d’exception, du descripteur de signature des variables locales et des attributs du corps de la méthode fournis, tout en permettant d’indiquer si les régions d’exception doivent être encodées au format réduit ou non.</summary>
      <param name="codeSize">Le nombre d’octets à réserver pour les instructions.</param>
      <param name="maxStack">Taille de pile maximale.</param>
      <param name="exceptionRegionCount">Le nombre de régions d’exception.</param>
      <param name="hasSmallExceptionRegions">
        <see langword="true" /> si les régions d’exception doivent être encodées au format réduit ; <see langword="false" /> dans le cas contraire.</param>
      <param name="localVariablesSignature">Descripteur de signature des variables locales.</param>
      <param name="attributes">Les attributs du corps de la méthode.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="codeSize" />, <paramref name="exceptionRegionCount" /> ou <paramref name="maxStack" /> est en dehors de la plage autorisée.</exception>
      <returns>Le décalage du corps encodé dans le flux du corps de la méthode.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Int32,System.Int32,System.Int32,System.Boolean,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes,System.Boolean)">
      <summary>Encode un corps de méthode et l’ajoute au flux du corps de la méthode à l’aide de la taille de code, de la taille de pile maximale, du nombre de régions d’exception, du descripteur de signature des variables locales et des attributs du corps de la méthode fournis, tout en permettant d’indiquer si les régions d’exception doivent être encodées au format réduit ou non et si la méthode doit être allouée à partir du pool dynamique de mémoire locale ou non.</summary>
      <param name="codeSize">Le nombre d’octets à réserver pour les instructions.</param>
      <param name="maxStack">Taille de pile maximale.</param>
      <param name="exceptionRegionCount">Le nombre de régions d’exception.</param>
      <param name="hasSmallExceptionRegions">
        <see langword="true" /> si les régions d’exception doivent être encodées au format réduit ; <see langword="false" /> dans le cas contraire.</param>
      <param name="localVariablesSignature">Descripteur de signature des variables locales.</param>
      <param name="attributes">Les attributs du corps de la méthode.</param>
      <param name="hasDynamicStackAllocation">
        <see langword="true" /> si la méthode alloue à partir du pool dynamique de mémoire locale (l’instruction <see langword="localloc" />) ; <see langword="false" /> dans le cas contraire.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="codeSize" />, <paramref name="exceptionRegionCount" /> ou <paramref name="maxStack" /> est en dehors de la plage autorisée.</exception>
      <returns>Le décalage du corps encodé dans le flux du corps de la méthode.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Reflection.Metadata.Ecma335.InstructionEncoder,System.Int32,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes)">
      <summary>Encode un corps de méthode et l’ajoute au flux du corps de la méthode.</summary>
      <param name="instructionEncoder">L’encodeur d’instruction.</param>
      <param name="maxStack">Taille de pile maximale.</param>
      <param name="localVariablesSignature">Descripteur de signature des variables locales.</param>
      <param name="attributes">Les attributs du corps de la méthode.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="instructionEncoder" /> a une valeur par défaut.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="maxStack" /> est en dehors de la plage [0, <see cref="F:System.UInt16.MaxValue" /> ].</exception>
      <exception cref="T:System.InvalidOperationException">Une étiquette ciblée par une branche dans le flux d’instructions n’a pas été marquée, ou la distance entre une instruction de branche et l’étiquette cible ne correspond pas à la taille de l’opérande d’instruction.</exception>
      <returns>Le décalage du corps encodé dans le flux du corps de la méthode.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Reflection.Metadata.Ecma335.InstructionEncoder,System.Int32,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes,System.Boolean)">
      <summary>Encode un corps de méthode et l’ajoute au flux du corps de la méthode à l’aide de l’encodeur d’instruction, de la taille de pile maximale, du descripteur de signature des variables locales et des attributs du corps de la méthode fournis, tout en permettant d’indiquer si la méthode doit être allouée à partir du pool dynamique de mémoire locale ou non.</summary>
      <param name="instructionEncoder">L’encodeur d’instruction.</param>
      <param name="maxStack">Taille de pile maximale.</param>
      <param name="localVariablesSignature">Descripteur de signature des variables locales.</param>
      <param name="attributes">Les attributs du corps de la méthode.</param>
      <param name="hasDynamicStackAllocation">
        <see langword="true" /> si la méthode alloue à partir du pool dynamique de mémoire locale (le langage intermédiaire contient l’instruction <see langword="localloc" />) ; <see langword="false" /> dans le cas contraire.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="instructionEncoder" /> a une valeur par défaut.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="maxStack" /> est en dehors de la plage [0, <see cref="F:System.UInt16.MaxValue" /> ].</exception>
      <exception cref="T:System.InvalidOperationException">Une étiquette ciblée par une branche dans le flux d’instructions n’a pas été marquée, ou la distance entre une instruction de branche et l’étiquette cible ne correspond pas à la taille de l’opérande d’instruction.</exception>
      <returns>Le décalage du corps encodé dans le flux du corps de la méthode.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody">
      <summary>Décrit un corps de méthode. Cette classe est destinée à être utilisée avec la classe <see cref="T:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder" />.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody.ExceptionRegions">
      <summary>Obtient un objet d’encodeur qui peut être utilisé pour encoder des régions d’exception dans le corps de la méthode.</summary>
      <returns>Instance d’encodeur de région d’exception.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody.Instructions">
      <summary>Obtient un objet blob réservé pour les instructions.</summary>
      <returns>Objet BLOB réservé pour les instructions.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody.Offset">
      <summary>Obtient le décalage du corps de la méthode encodée dans le flux du corps de la méthode.</summary>
      <returns>Offset du corps de la méthode encodée dans le flux du corps de la méthode.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder">
      <summary>Fournit un encodeur pour les signatures de méthode.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.#ctor(System.Reflection.Metadata.BlobBuilder,System.Boolean)">
      <param name="builder" />
      <param name="hasVarArgs" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.Parameters(System.Int32,System.Action{System.Reflection.Metadata.Ecma335.ReturnTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.ParametersEncoder})">
      <summary>Encode le type de retour et les paramètres fournis.</summary>
      <param name="parameterCount">Le nombre de paramètres.</param>
      <param name="returnType">Méthode appelée en premier pour encoder le type de retour.</param>
      <param name="parameters">Méthode appelée en second pour encoder les paramètres.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="returnType" /> ou <paramref name="parameters" /> est <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.Parameters(System.Int32,System.Reflection.Metadata.Ecma335.ReturnTypeEncoder@,System.Reflection.Metadata.Ecma335.ParametersEncoder@)">
      <summary>Encode le type de retour et les paramètres fournis, qui doivent être utilisés dans l’ordre dans lequel ils apparaissent dans la liste de paramètres.</summary>
      <param name="parameterCount">Le nombre de paramètres.</param>
      <param name="returnType">Méthode appelée en premier pour encoder les types de retour.</param>
      <param name="parameters">Méthode appelée en second pour encoder les paramètres.</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.Builder" />
    <member name="P:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.HasVarArgs" />
    <member name="T:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <summary>Initialise une nouvelle instance de la structure <see cref="T:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder" />.</summary>
      <param name="builder">Générateur pour l’encodage de l’argument nommé.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.AddArgument(System.Boolean,System.Action{System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.NameEncoder},System.Action{System.Reflection.Metadata.Ecma335.LiteralEncoder})">
      <summary>Encode un argument nommé (champ ou propriété).</summary>
      <param name="isField">
        <see langword="true" /> pour encoder un champ, <see langword="false" /> pour encoder une propriété.</param>
      <param name="type">Méthode à appeler en premier pour encoder le type de l’argument.</param>
      <param name="name">Méthode à appeler en deuxième pour encoder le nom du champ ou de la propriété.</param>
      <param name="literal">Méthode à appeler en troisième pour encoder la valeur littérale de l’argument.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" />, <paramref name="name" /> ou <paramref name="literal" /> est <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.AddArgument(System.Boolean,System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder@,System.Reflection.Metadata.Ecma335.NameEncoder@,System.Reflection.Metadata.Ecma335.LiteralEncoder@)">
      <summary>Encode un argument nommé (un champ ou une propriété) et retourne trois encodeurs qui doivent être utilisés dans l’ordre dans lequel ils apparaissent dans la liste de paramètres.</summary>
      <param name="isField">
        <see langword="true" /> pour encoder un champ, <see langword="false" /> pour encoder une propriété.</param>
      <param name="type">Méthode à appeler en premier pour encoder le type de l’argument.</param>
      <param name="name">Méthode à appeler en deuxième pour encoder le nom du champ ou de la propriété.</param>
      <param name="literal">Méthode à appeler en troisième pour encoder la valeur littérale de l’argument.</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.Object" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.ScalarType" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.SZArray" />
    <member name="P:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.NameEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NameEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.NameEncoder.Name(System.String)">
      <param name="name" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.NameEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.ParametersEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParametersEncoder.#ctor(System.Reflection.Metadata.BlobBuilder,System.Boolean)">
      <param name="builder" />
      <param name="hasVarArgs" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ParametersEncoder.AddParameter" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParametersEncoder.StartVarArgs" />
    <member name="P:System.Reflection.Metadata.Ecma335.ParametersEncoder.Builder" />
    <member name="P:System.Reflection.Metadata.Ecma335.ParametersEncoder.HasVarArgs" />
    <member name="T:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.CustomModifiers" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.Type(System.Boolean)">
      <param name="isByRef" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.TypedReference" />
    <member name="P:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.PermissionSetEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.AddPermission(System.String,System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="typeName" />
      <param name="encodedArguments" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.AddPermission(System.String,System.Reflection.Metadata.BlobBuilder)">
      <param name="typeName" />
      <param name="encodedArguments" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.PortablePdbBuilder">
      <summary>Représente le générateur d’une image PDB portable.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.#ctor(System.Reflection.Metadata.Ecma335.MetadataBuilder,System.Collections.Immutable.ImmutableArray{System.Int32},System.Reflection.Metadata.MethodDefinitionHandle,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Reflection.Metadata.BlobContentId})">
      <summary>Crée un générateur pour une image PDB portable.</summary>
      <param name="tablesAndHeaps">Un générateur rempli avec les entités de métadonnées de débogage stockées dans les tables et les valeurs stockées dans les tas. Les entités et les valeurs sont énumérées lors de la sérialisation de l’image PDB portable.</param>
      <param name="typeSystemRowCounts">Le nombre de lignes de toutes les tables que les métadonnées système du type associé contiennent. Chaque emplacement du tableau correspond à une table (<see cref="T:System.Reflection.Metadata.Ecma335.TableIndex" />). La longueur du tableau doit être égale à <see cref="F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount" />.</param>
      <param name="entryPoint">Descripteur de définition de méthode de point d’entrée.</param>
      <param name="idProvider">Une fonction qui calcule l’ID du contenu représenté sous la forme d’une séquence d’objets blob. Si elle n’est pas spécifiée, une fonction par défaut qui ignore le contenu et retourne un ID de contenu basé sur l’heure actuelle est utilisée (<see cref="M:System.Reflection.Metadata.BlobContentId.GetTimeBasedProvider" />). Vous devez spécifier une fonction déterministe pour produire une image PDB portable déterministe.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="tablesAndHeaps" /> ou <paramref name="typeSystemRowCounts" /> est <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.Serialize(System.Reflection.Metadata.BlobBuilder)">
      <summary>Sérialise le contenu PDB portable dans le <see cref="T:System.Reflection.Metadata.BlobBuilder" /> donné.</summary>
      <param name="builder">Générateur dans lequel écrire.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="builder" /> a la valeur <see langword="null" />.</exception>
      <returns>ID du contenu sérialisé.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.FormatVersion" />
    <member name="P:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.IdProvider" />
    <member name="P:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.MetadataVersion" />
    <member name="T:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.CustomModifiers" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.Type(System.Boolean)">
      <param name="isByRef" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.TypedReference" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.Void" />
    <member name="P:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.ScalarEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.Constant(System.Object)">
      <summary>Encode une valeur littérale constante.</summary>
      <param name="value">Une constante de type <see cref="T:System.Boolean" />, <see cref="T:System.Byte" />, <see cref="T:System.SByte" />, <see cref="T:System.Int16" />, <see cref="T:System.UInt16" />, <see cref="T:System.Int32" />, <see cref="T:System.UInt32" />, <see cref="T:System.Int64" />, <see cref="T:System.UInt64" />, <see cref="T:System.Single" />, <see cref="T:System.Double" />, <see cref="T:System.Char" /> (codée sous forme d’un caractère Unicode sur deux octets), <see cref="T:System.String" /> (encodée en tant que SerString) ou <see cref="T:System.Enum" /> (encodée comme valeur entière sous-jacente).</param>
      <exception cref="T:System.ArgumentException">Type de constante inattendu.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.NullArray">
      <summary>Encode une valeur <see langword="null" /> littérale de type <see cref="T:System.Array" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.SystemType(System.String)">
      <summary>Encode une valeur littérale de type <see cref="T:System.Type" /> (qui peut être <see langword="null" />).</summary>
      <param name="serializedTypeName">Le nom du type ou <see langword="null" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="serializedTypeName" /> est vide.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ScalarEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.SignatureDecoder`2">
      <summary>Décode les objets blob de signature.</summary>
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.#ctor(System.Reflection.Metadata.ISignatureTypeProvider{`0,`1},System.Reflection.Metadata.MetadataReader,`1)">
      <summary>Crée un <see cref="T:System.Reflection.Metadata.Ecma335.SignatureDecoder`2" />.</summary>
      <param name="provider">Le fournisseur utilisé pour obtenir les symboles de type lorsque la signature est décodée.</param>
      <param name="metadataReader">Le lecteur de métadonnées à partir duquel la signature a été obtenue. Il peut s’agir de <see langword="null" /> si le fournisseur donné l’autorise.</param>
      <param name="genericContext">Contexte supplémentaire nécessaire pour résoudre les paramètres génériques.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeFieldSignature(System.Reflection.Metadata.BlobReader@)">
      <summary>Décode un objet blob de signature de champ et avance le lecteur au-delà de la signature.</summary>
      <param name="blobReader">Lecteur d’objets blob positionné au niveau d’une signature de champ.</param>
      <returns>Le type de champ décodé.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeLocalSignature(System.Reflection.Metadata.BlobReader@)">
      <summary>Décode un objet blob de signature de variable locale et avance le lecteur au-delà de la signature.</summary>
      <param name="blobReader">Lecteur d’objets blob positionné sur une signature de variable locale.</param>
      <exception cref="T:System.BadImageFormatException">La signature de la variable locale n’est pas valide.</exception>
      <returns>Types de variables locales.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeMethodSignature(System.Reflection.Metadata.BlobReader@)">
      <summary>Décode une méthode (définition, référence ou autonome) ou un blob de signature de propriété.</summary>
      <param name="blobReader">Lecteur d’objet blob positionné sur une signature de méthode.</param>
      <exception cref="T:System.BadImageFormatException">La signature de la méthode n’est pas valide.</exception>
      <returns>La signature de la méthode décodée.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeMethodSpecificationSignature(System.Reflection.Metadata.BlobReader@)">
      <summary>Décode un objet blob de signature de spécification de méthode et avance le lecteur au-delà de la signature.</summary>
      <param name="blobReader">Lecteur d’objet blob positionné sur une signature de spécification de méthode valide.</param>
      <returns>Les types utilisés pour instancier une méthode générique via la spécification de la méthode.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeType(System.Reflection.Metadata.BlobReader@,System.Boolean)">
      <summary>Décode un type incorporé dans une signature et avance le lecteur au-delà du type.</summary>
      <param name="blobReader">Le lecteur d’objets blob positionné au premier <see cref="T:System.Reflection.Metadata.SignatureTypeCode" />.</param>
      <param name="allowTypeSpecifications">
        <see langword="true" /> pour autoriser un <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /> à suivre une (CLASS | VALUETYPE) dans la signature ; <see langword="false" /> dans le cas contraire.</param>
      <exception cref="T:System.BadImageFormatException">Le lecteur n’a pas été positionné sur un type de signature valide.</exception>
      <returns>Le texte décodé.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Array(System.Action{System.Reflection.Metadata.Ecma335.SignatureTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.ArrayShapeEncoder})">
      <summary>Encode un type de tableau.</summary>
      <param name="elementType">Appelée en premier pour encoder le type de l’élément.</param>
      <param name="arrayShape">Appelée en second pour encoder la forme du tableau.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="elementType" /> ou <paramref name="arrayShape" /> est <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Array(System.Reflection.Metadata.Ecma335.SignatureTypeEncoder@,System.Reflection.Metadata.Ecma335.ArrayShapeEncoder@)">
      <summary>Encode un type de tableau. Retourne une paire d’encodeurs qui doivent être utilisés dans l’ordre dans lequel ils apparaissent dans la liste de paramètres.</summary>
      <param name="elementType">Utilisez en premier pour encoder le type de l’élément.</param>
      <param name="arrayShape">Utilisez en second pour encoder la forme du tableau.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Boolean" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Byte" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Char" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.CustomModifiers">
      <summary>Démarre une signature d’un type avec des modificateurs personnalisés.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Double" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.FunctionPointer(System.Reflection.Metadata.SignatureCallingConvention,System.Reflection.Metadata.Ecma335.FunctionPointerAttributes,System.Int32)">
      <summary>Démarre une signature de pointeur de fonction.</summary>
      <param name="convention">Convention d’appel.</param>
      <param name="attributes">Attributs du pointeur de fonction.</param>
      <param name="genericParameterCount">Nombre de paramètres génériques.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="attributes" /> n'est pas valide.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="genericParameterCount" /> est en dehors de la plage [0, 0xffff].</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.GenericInstantiation(System.Reflection.Metadata.EntityHandle,System.Int32,System.Boolean)">
      <summary>Démarre une signature d’instanciation générique.</summary>
      <param name="genericType">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />.</param>
      <param name="genericArgumentCount">Nombre d’arguments génériques.</param>
      <param name="isValueType">
        <see langword="true" /> pour marquer le type comme type de valeur, <see langword="false" /> pour le marquer comme type de référence dans la signature.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="genericType" /> n’a pas le type de poignée attendu.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="genericArgumentCount" /> est en dehors de la page [1, 0xffff].</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.GenericMethodTypeParameter(System.Int32)">
      <summary>Encode une référence au paramètre de type d’une méthode générique conteneur.</summary>
      <param name="parameterIndex">Index du paramètre.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="parameterIndex" /> est en dehors de la plage [0, 0xffff].</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.GenericTypeParameter(System.Int32)">
      <summary>Encode une référence au paramètre de type d’un type générique conteneur.</summary>
      <param name="parameterIndex">Index du paramètre.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="parameterIndex" /> est en dehors de la plage [0, 0xffff].</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Int16" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Int32" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Int64" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.IntPtr" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Object" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Pointer">
      <summary>Démarre la signature du pointeur.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.PrimitiveType(System.Reflection.Metadata.PrimitiveTypeCode)">
      <summary>Écrit le code de type primitif.</summary>
      <param name="type">Tout code de type primitif, à l’exception de <see cref="F:System.Reflection.Metadata.PrimitiveTypeCode.TypedReference" /> et <see cref="F:System.Reflection.Metadata.PrimitiveTypeCode.Void" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="type" /> n’est pas valide dans ce contexte.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.SByte" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Single" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.String" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.SZArray">
      <summary>Démarre la signature du tableau (vecteur) SZ.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Type(System.Reflection.Metadata.EntityHandle,System.Boolean)">
      <summary>Encode une référence à un type.</summary>
      <param name="type">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />.</param>
      <param name="isValueType">
        <see langword="true" /> pour marquer le type comme type de valeur, <see langword="false" /> pour le marquer comme type de référence dans la signature.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="type" /> n’a pas le type de poignée attendu.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UInt16" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UInt32" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UInt64" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UIntPtr" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.VoidPointer">
      <summary>Encode un pointeur void (<c>void*</c>).</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.TableIndex" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Assembly" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyOS" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyProcessor" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyRefOS" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyRefProcessor" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ClassLayout" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Constant" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.CustomAttribute" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.CustomDebugInformation" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.DeclSecurity" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Document" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EncLog" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EncMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Event" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EventMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EventPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ExportedType" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Field" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldLayout" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldMarshal" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldRva" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.File" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.GenericParam" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.GenericParamConstraint" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ImplMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ImportScope" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.InterfaceImpl" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.LocalConstant" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.LocalScope" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.LocalVariable" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ManifestResource" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MemberRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodDebugInformation" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodDef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodImpl" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodSemantics" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodSpec" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Module" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ModuleRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.NestedClass" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Param" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ParamPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Property" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.PropertyMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.PropertyPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.StandAloneSig" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.StateMachineMethod" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.TypeDef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.TypeRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.TypeSpec" />
    <member name="T:System.Reflection.Metadata.Ecma335.VectorEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.VectorEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.VectorEncoder.Count(System.Int32)">
      <param name="count" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.VectorEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.EntityHandle">
      <summary>Représente une entité de métadonnées (comme une référence de type, une définition de type, une spécification de type, une définition de méthode ou un attribut personnalisé).</summary>
    </member>
    <member name="F:System.Reflection.Metadata.EntityHandle.AssemblyDefinition" />
    <member name="F:System.Reflection.Metadata.EntityHandle.ModuleDefinition" />
    <member name="M:System.Reflection.Metadata.EntityHandle.Equals(System.Object)">
      <summary>Retourne une valeur qui indique si l’instance actuelle et l’objet spécifié sont égaux.</summary>
      <param name="obj">Objet à comparer à l’instance actuelle.</param>
      <returns>
        <see langword="true" /> si <paramref name="obj" /> est un <see cref="T:System.Reflection.Metadata.EntityHandle" /> égal à l’instance actuelle ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.Equals(System.Reflection.Metadata.EntityHandle)">
      <summary>Retourne une valeur qui indique si l’instance actuelle et le <see cref="T:System.Reflection.Metadata.EntityHandle" /> spécifié sont égaux.</summary>
      <param name="other">Valeur à comparer à l’instance actuelle.</param>
      <returns>
        <see langword="true" /> si l'instance actuelle et <paramref name="other" /> sont égaux ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.GetHashCode">
      <summary>Retourne le code de hachage de cette instance.</summary>
      <returns>Code de hachage de cette instance.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Equality(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Implicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Inequality(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.EntityHandle.IsNil" />
    <member name="P:System.Reflection.Metadata.EntityHandle.Kind" />
    <member name="T:System.Reflection.Metadata.EventAccessors" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Adder" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Others" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Raiser" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Remover" />
    <member name="T:System.Reflection.Metadata.EventDefinition" />
    <member name="M:System.Reflection.Metadata.EventDefinition.GetAccessors" />
    <member name="M:System.Reflection.Metadata.EventDefinition.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.EventDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.EventDefinition.Name" />
    <member name="P:System.Reflection.Metadata.EventDefinition.Type" />
    <member name="T:System.Reflection.Metadata.EventDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.Equals(System.Reflection.Metadata.EventDefinitionHandle)">
      <summary>Indique si l'objet actuel est égal à un autre objet du même type.</summary>
      <param name="other">Objet à comparer à cet objet.</param>
      <returns>
        <see langword="true" /> si l'objet actuel est égal au paramètre <paramref name="other" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Equality(System.Reflection.Metadata.EventDefinitionHandle,System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.EventDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.EventDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Implicit(System.Reflection.Metadata.EventDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Implicit(System.Reflection.Metadata.EventDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Inequality(System.Reflection.Metadata.EventDefinitionHandle,System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.EventDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.EventDefinitionHandleCollection" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#EventDefinitionHandle}#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein de la collection.</summary>
      <returns>Énumérateur permettant d'effectuer une itération au sein de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein d’une collection.</summary>
      <returns>Objet <see cref="T:System.Collections.IEnumerator" /> pouvant être utilisé pour itérer au sein de la collection.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.EventDefinitionHandleCollection.Count">
      <summary>Obtient le nombre d’éléments de la collection.</summary>
      <returns>Nombre d'éléments dans la collection.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.MoveNext">
      <summary>Avance l’énumérateur à l’élément suivant de la collection.</summary>
      <returns>
        <see langword="true" /> si l'énumérateur a pu avancer jusqu'à l'élément suivant ; <see langword="false" /> si l'énumérateur a dépassé la fin de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Rétablit l'énumérateur à sa position initiale, qui précède le premier élément de la collection.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Exécute les tâches définies par l'application associées à la libération ou à la redéfinition des ressources non managées.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ExceptionRegion" />
    <member name="P:System.Reflection.Metadata.ExceptionRegion.CatchType">
      <summary>Obtient un handle TypeRef, TypeDef ou TypeSpec si la région représente un bloc catch, sinon un jeton nil (<see langword="default" />(<see cref="T:System.Reflection.Metadata.EntityHandle" />)).</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.FilterOffset">
      <summary>Obtient l’offset IL du début du bloc de filtre, ou -1 si la région n’est pas un filtre.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.HandlerLength">
      <summary>Obtient la longueur, en octets, du gestionnaire d'exceptions.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.HandlerOffset">
      <summary>Obtient l’offset IL de départ du gestionnaire d'exceptions.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.Kind" />
    <member name="P:System.Reflection.Metadata.ExceptionRegion.TryLength">
      <summary>Obtient la longueur en octets du bloc try.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.TryOffset">
      <summary>Obtient l’offset IL de départ en octets du bloc try.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ExceptionRegionKind" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Catch" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Fault" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Filter" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Finally" />
    <member name="T:System.Reflection.Metadata.ExportedType" />
    <member name="M:System.Reflection.Metadata.ExportedType.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ExportedType.Attributes" />
    <member name="P:System.Reflection.Metadata.ExportedType.Implementation">
      <summary>Obtient un descripteur pour résoudre l’implémentation du type de cible.</summary>
      <returns>
        <list type="bullet">
          <item>
            <description>
              <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" /> représentant un autre module de l’assembly.</description>
          </item>
          <item>
            <description>
              <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" /> représentant un autre assembly si <see cref="P:System.Reflection.Metadata.ExportedType.IsForwarder" /> est <see langword="true" /> .</description>
          </item>
          <item>
            <description>
              <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" /> représentant le type exporté déclarant dans lequel ce a été imbriqué.</description>
          </item>
        </list>
      </returns>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedType.IsForwarder" />
    <member name="P:System.Reflection.Metadata.ExportedType.Name">
      <summary>Obtient le nom du type de cible, ou <see langword="default" /> si le type est imbriqué ou défini dans un espace de noms racine.</summary>
      <returns>
        <see cref="T:System.Reflection.Metadata.StringHandle" />Instance de struct.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedType.Namespace">
      <summary>Obtient le nom complet de l’espace de noms qui contient le type de cible, ou <see langword="default" /> si le type est imbriqué ou défini dans un espace de noms racine.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedType.NamespaceDefinition">
      <summary>Obtient le descripteur de définition de l’espace de noms où le type de cible est défini, ou <see langword="default" /> si le type est imbriqué ou défini dans un espace de noms racine.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ExportedTypeHandle" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.Equals(System.Reflection.Metadata.ExportedTypeHandle)">
      <summary>Indique si l'objet actuel est égal à un autre objet du même type.</summary>
      <param name="other">Objet à comparer à cet objet.</param>
      <returns>
        <see langword="true" /> si l'objet actuel est égal au paramètre <paramref name="other" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Equality(System.Reflection.Metadata.ExportedTypeHandle,System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ExportedTypeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ExportedTypeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Implicit(System.Reflection.Metadata.ExportedTypeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Implicit(System.Reflection.Metadata.ExportedTypeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Inequality(System.Reflection.Metadata.ExportedTypeHandle,System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.ExportedTypeHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ExportedTypeHandleCollection">
      <summary>Représente une collection d'instances <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ExportedTypeHandle}#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein de la collection.</summary>
      <returns>Énumérateur permettant d'effectuer une itération au sein de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein d’une collection.</summary>
      <returns>Objet <see cref="T:System.Collections.IEnumerator" /> pouvant être utilisé pour itérer au sein de la collection.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedTypeHandleCollection.Count">
      <summary>Obtient le nombre d’éléments de la collection.</summary>
      <returns>Nombre d'éléments dans la collection.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.MoveNext">
      <summary>Avance l’énumérateur à l’élément suivant de la collection.</summary>
      <returns>
        <see langword="true" /> si l'énumérateur a pu avancer jusqu'à l'élément suivant ; <see langword="false" /> si l'énumérateur a dépassé la fin de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Rétablit l'énumérateur à sa position initiale, qui précède le premier élément de la collection.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Exécute les tâches définies par l'application associées à la libération ou à la redéfinition des ressources non managées.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.FieldDefinition" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetDeclaringType" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetDefaultValue" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetMarshallingDescriptor" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetOffset">
      <summary>Retourne l’offset de disposition de champ, ou -1 s’il n’est pas disponible.</summary>
      <returns>Offset de disposition de champ, ou -1 s’il n’est pas disponible.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetRelativeVirtualAddress" />
    <member name="P:System.Reflection.Metadata.FieldDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.FieldDefinition.Name" />
    <member name="P:System.Reflection.Metadata.FieldDefinition.Signature" />
    <member name="T:System.Reflection.Metadata.FieldDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.Equals(System.Reflection.Metadata.FieldDefinitionHandle)">
      <summary>Indique si l'objet actuel est égal à un autre objet du même type.</summary>
      <param name="other">Objet à comparer à cet objet.</param>
      <returns>
        <see langword="true" /> si l'objet actuel est égal au paramètre <paramref name="other" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Equality(System.Reflection.Metadata.FieldDefinitionHandle,System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.FieldDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.FieldDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Implicit(System.Reflection.Metadata.FieldDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Implicit(System.Reflection.Metadata.FieldDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Inequality(System.Reflection.Metadata.FieldDefinitionHandle,System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.FieldDefinitionHandleCollection" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#FieldDefinitionHandle}#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein de la collection.</summary>
      <returns>Énumérateur permettant d'effectuer une itération au sein de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein d’une collection.</summary>
      <returns>Objet <see cref="T:System.Collections.IEnumerator" /> pouvant être utilisé pour itérer au sein de la collection.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandleCollection.Count">
      <summary>Obtient le nombre d’éléments de la collection.</summary>
      <returns>Nombre d'éléments dans la collection.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.MoveNext">
      <summary>Avance l’énumérateur à l’élément suivant de la collection.</summary>
      <returns>
        <see langword="true" /> si l'énumérateur a pu avancer jusqu'à l'élément suivant ; <see langword="false" /> si l'énumérateur a dépassé la fin de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Rétablit l'énumérateur à sa position initiale, qui précède le premier élément de la collection.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Exécute les tâches définies par l'application associées à la libération ou à la redéfinition des ressources non managées.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameter" />
    <member name="M:System.Reflection.Metadata.GenericParameter.GetConstraints" />
    <member name="M:System.Reflection.Metadata.GenericParameter.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.GenericParameter.Attributes">
      <summary>Obtient les attributs spécifiant la variance et les contraintes.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameter.Index">
      <summary>Obtient l’index de base zéro du paramètre dans le type générique déclarant ou la déclaration de méthode.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameter.Name">
      <summary>Obtient le nom du paramètre générique.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameter.Parent">
      <summary>Obtient un <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> ou un <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> qui représente le parent de ce paramètre générique.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterConstraint" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraint.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.GenericParameterConstraint.Parameter">
      <summary>Obtient le <see cref="T:System.Reflection.Metadata.GenericParameterHandle" /> avec contraintes.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraint.Type">
      <summary>Obtient un handle (<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />) spécifiant le type duquel ce paramètre générique est contraint de dériver, ou l’interface que ce paramètre générique est contraint d’implémenter.</summary>
      <returns>Instance de <see cref="T:System.Reflection.Metadata.EntityHandle" />.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterConstraintHandle" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.Equals(System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <summary>Indique si l'objet actuel est égal à un autre objet du même type.</summary>
      <param name="other">Objet à comparer à cet objet.</param>
      <returns>
        <see langword="true" /> si l'objet actuel est égal au paramètre <paramref name="other" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Equality(System.Reflection.Metadata.GenericParameterConstraintHandle,System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.GenericParameterConstraintHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.GenericParameterConstraintHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Implicit(System.Reflection.Metadata.GenericParameterConstraintHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Implicit(System.Reflection.Metadata.GenericParameterConstraintHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Inequality(System.Reflection.Metadata.GenericParameterConstraintHandle,System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.GenericParameterConstraintHandleCollection">
      <summary>Représente une collection de contraintes d’un paramètre de type générique.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#GenericParameterConstraintHandle}#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein de la collection.</summary>
      <returns>Énumérateur permettant d'effectuer une itération au sein de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein d’une collection.</summary>
      <returns>Objet <see cref="T:System.Collections.IEnumerator" /> pouvant être utilisé pour itérer au sein de la collection.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Count">
      <summary>Obtient le nombre d’éléments de la collection.</summary>
      <returns>Nombre d'éléments dans la collection.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Item(System.Int32)">
      <summary>Obtient l'élément à l'index spécifié dans la liste en lecture seule.</summary>
      <param name="index">Index de base zéro de l'élément à obtenir.</param>
      <returns>Élément à l'index spécifié dans la liste en lecture seule.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.MoveNext">
      <summary>Avance l’énumérateur à l’élément suivant de la collection.</summary>
      <returns>
        <see langword="true" /> si l'énumérateur a pu avancer jusqu'à l'élément suivant ; <see langword="false" /> si l'énumérateur a dépassé la fin de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Rétablit l'énumérateur à sa position initiale, qui précède le premier élément de la collection.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Exécute les tâches définies par l'application associées à la libération ou à la redéfinition des ressources non managées.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterHandle" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.Equals(System.Reflection.Metadata.GenericParameterHandle)">
      <summary>Indique si l'objet actuel est égal à un autre objet du même type.</summary>
      <param name="other">Objet à comparer à cet objet.</param>
      <returns>
        <see langword="true" /> si l'objet actuel est égal au paramètre <paramref name="other" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Equality(System.Reflection.Metadata.GenericParameterHandle,System.Reflection.Metadata.GenericParameterHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.GenericParameterHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.GenericParameterHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Implicit(System.Reflection.Metadata.GenericParameterHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Implicit(System.Reflection.Metadata.GenericParameterHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Inequality(System.Reflection.Metadata.GenericParameterHandle,System.Reflection.Metadata.GenericParameterHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.GenericParameterHandleCollection">
      <summary>Représente une collection de paramètres de type génériques d’une méthode ou d’un type.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#GenericParameterHandle}#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein de la collection.</summary>
      <returns>Énumérateur permettant d'effectuer une itération au sein de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein d’une collection.</summary>
      <returns>Objet <see cref="T:System.Collections.IEnumerator" /> pouvant être utilisé pour itérer au sein de la collection.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Count">
      <summary>Obtient le nombre d’éléments de la collection.</summary>
      <returns>Nombre d'éléments dans la collection.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Item(System.Int32)">
      <summary>Obtient l'élément à l'index spécifié dans la liste en lecture seule.</summary>
      <param name="index">Index de base zéro de l'élément à obtenir.</param>
      <returns>Élément à l'index spécifié dans la liste en lecture seule.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.MoveNext">
      <summary>Avance l’énumérateur à l’élément suivant de la collection.</summary>
      <returns>
        <see langword="true" /> si l'énumérateur a pu avancer jusqu'à l'élément suivant ; <see langword="false" /> si l'énumérateur a dépassé la fin de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Rétablit l'énumérateur à sa position initiale, qui précède le premier élément de la collection.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Exécute les tâches définies par l'application associées à la libération ou à la redéfinition des ressources non managées.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GuidHandle" />
    <member name="M:System.Reflection.Metadata.GuidHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.Equals(System.Reflection.Metadata.GuidHandle)">
      <summary>Indique si l'objet actuel est égal à un autre objet du même type.</summary>
      <param name="other">Objet à comparer à cet objet.</param>
      <returns>
        <see langword="true" /> si l'objet actuel est égal au paramètre <paramref name="other" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Equality(System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.GuidHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Implicit(System.Reflection.Metadata.GuidHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Inequality(System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.GuidHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.Handle">
      <summary>Représente une entité de métadonnées (comme une référence de type, une définition de type, une spécification de type, une définition de méthode ou un attribut personnalisé) ou une valeur (chaîne, objet blob, GUID ou chaîne utilisateur).</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Handle.AssemblyDefinition" />
    <member name="F:System.Reflection.Metadata.Handle.ModuleDefinition" />
    <member name="M:System.Reflection.Metadata.Handle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.Handle.Equals(System.Reflection.Metadata.Handle)">
      <summary>Indique si l'objet actuel est égal à un autre objet du même type.</summary>
      <param name="other">Objet à comparer à cet objet.</param>
      <returns>
        <see langword="true" /> si l'objet actuel est égal au paramètre <paramref name="other" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Handle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.Handle.op_Equality(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.Handle.op_Inequality(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.Handle.IsNil" />
    <member name="P:System.Reflection.Metadata.Handle.Kind" />
    <member name="T:System.Reflection.Metadata.HandleComparer" />
    <member name="M:System.Reflection.Metadata.HandleComparer.Compare(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>Compare deux handles d’entité.</summary>
      <param name="x">Premier handle d’entité à comparer.</param>
      <param name="y">Deuxième handle d’entité à comparer.</param>
      <returns>Zéro si les handles d’entité sont égaux, et une valeur différente de zéro dans le cas contraire.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.Compare(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <summary>Compare deux handles.</summary>
      <param name="x">Premier handle à comparer.</param>
      <param name="y">Deuxième handle à comparer.</param>
      <returns>Zéro si les deux handles sont égaux et une valeur différente de zéro dans le cas contraire.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.Equals(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>Détermine si les objets spécifiés sont égaux.</summary>
      <param name="x">Premier objet de type <paramref name="T" /> à comparer.</param>
      <param name="y">Deuxième objet de type <paramref name="T" /> à comparer.</param>
      <returns>
        <see langword="true" /> si les objets spécifiés sont égaux ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.Equals(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <summary>Détermine si les objets spécifiés sont égaux.</summary>
      <param name="x">Premier objet de type <paramref name="T" /> à comparer.</param>
      <param name="y">Deuxième objet de type <paramref name="T" /> à comparer.</param>
      <returns>
        <see langword="true" /> si les objets spécifiés sont égaux ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.GetHashCode(System.Reflection.Metadata.EntityHandle)">
      <summary>Retourne un code de hachage pour l'objet spécifié.</summary>
      <param name="obj">
        <see cref="T:System.Object" /> pour lequel un code de hachage doit être retourné.</param>
      <returns>Code de hachage pour l'objet spécifié.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.GetHashCode(System.Reflection.Metadata.Handle)">
      <summary>Retourne un code de hachage pour l'objet spécifié.</summary>
      <param name="obj">
        <see cref="T:System.Object" /> pour lequel un code de hachage doit être retourné.</param>
      <returns>Code de hachage pour l'objet spécifié.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.HandleComparer.Default" />
    <member name="T:System.Reflection.Metadata.HandleKind" />
    <member name="F:System.Reflection.Metadata.HandleKind.AssemblyDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.AssemblyFile" />
    <member name="F:System.Reflection.Metadata.HandleKind.AssemblyReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.Blob" />
    <member name="F:System.Reflection.Metadata.HandleKind.Constant" />
    <member name="F:System.Reflection.Metadata.HandleKind.CustomAttribute" />
    <member name="F:System.Reflection.Metadata.HandleKind.CustomDebugInformation" />
    <member name="F:System.Reflection.Metadata.HandleKind.DeclarativeSecurityAttribute" />
    <member name="F:System.Reflection.Metadata.HandleKind.Document" />
    <member name="F:System.Reflection.Metadata.HandleKind.EventDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.ExportedType" />
    <member name="F:System.Reflection.Metadata.HandleKind.FieldDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.GenericParameter" />
    <member name="F:System.Reflection.Metadata.HandleKind.GenericParameterConstraint" />
    <member name="F:System.Reflection.Metadata.HandleKind.Guid" />
    <member name="F:System.Reflection.Metadata.HandleKind.ImportScope" />
    <member name="F:System.Reflection.Metadata.HandleKind.InterfaceImplementation" />
    <member name="F:System.Reflection.Metadata.HandleKind.LocalConstant" />
    <member name="F:System.Reflection.Metadata.HandleKind.LocalScope" />
    <member name="F:System.Reflection.Metadata.HandleKind.LocalVariable" />
    <member name="F:System.Reflection.Metadata.HandleKind.ManifestResource" />
    <member name="F:System.Reflection.Metadata.HandleKind.MemberReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodDebugInformation" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodImplementation" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodSpecification" />
    <member name="F:System.Reflection.Metadata.HandleKind.ModuleDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.ModuleReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.NamespaceDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.Parameter" />
    <member name="F:System.Reflection.Metadata.HandleKind.PropertyDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.StandaloneSignature" />
    <member name="F:System.Reflection.Metadata.HandleKind.String" />
    <member name="F:System.Reflection.Metadata.HandleKind.TypeDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.TypeReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.TypeSpecification" />
    <member name="F:System.Reflection.Metadata.HandleKind.UserString" />
    <member name="T:System.Reflection.Metadata.IConstructedTypeProvider`1">
      <typeparam name="TType" />
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetArrayType(`0,System.Reflection.Metadata.ArrayShape)">
      <summary>Obtient le symbole de type d’un tableau généralisé du type et de la forme d’élément donnés.</summary>
      <param name="elementType">Type des éléments du tableau.</param>
      <param name="shape">Forme (rang, tailles et limites inférieures) du tableau.</param>
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetByReferenceType(`0)">
      <summary>Obtient le symbole de type d’un pointeur managé vers le type d’élément donné.</summary>
      <param name="elementType" />
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetGenericInstantiation(`0,System.Collections.Immutable.ImmutableArray{`0})">
      <summary>Obtient le symbole de type d’une instanciation générique du type générique spécifié avec les arguments de type donnés.</summary>
      <param name="genericType" />
      <param name="typeArguments" />
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetPointerType(`0)">
      <summary>Obtient le symbole de type d’un pointeur non managé vers le type d’élément donné.</summary>
      <param name="elementType" />
    </member>
    <member name="T:System.Reflection.Metadata.ICustomAttributeTypeProvider`1">
      <typeparam name="TType" />
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.GetSystemType">
      <summary>Obtient la représentation <typeparamref name="TType" /> de <see cref="T:System.Type" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.GetTypeFromSerializedName(System.String)">
      <summary>Obtient le symbole de type du nom de type sérialisé donné.</summary>
      <param name="name">Nom du type sérialisé au format appelé « notation de réflexion » (tel qu’il est interprété par la méthode <see cref="M:System.Type.GetType(System.String)" />).</param>
      <exception cref="T:System.BadImageFormatException">Le nom est mal formé.</exception>
      <returns>Instance de <typeparamref name="TType" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.GetUnderlyingEnumType(`0)">
      <summary>Obtient le type sous-jacent du symbole de type enum donné.</summary>
      <param name="type">Type enum.</param>
      <exception cref="T:System.BadImageFormatException">Le symbole de type donné ne représente pas un enum.</exception>
      <returns>Code de type qui indique le type sous-jacent de l’énumération.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.IsSystemType(`0)">
      <summary>Vérifie si le type donné représente <see cref="T:System.Type" />.</summary>
      <param name="type">Type à vérifier.</param>
      <returns>
        <see langword="true" /> si le type donné est un <see cref="T:System.Type" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ILOpCode" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Add" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Add_ovf" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Add_ovf_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.And" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Arglist" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Beq" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Beq_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bne_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bne_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Box" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Br" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Br_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Break" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brfalse" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brfalse_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brtrue" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brtrue_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Call" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Calli" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Callvirt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Castclass" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ceq" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cgt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cgt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ckfinite" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Clt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Clt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Constrained" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i1_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i2_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i4_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i8_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u1_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u2_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u4_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u8_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_r_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cpblk" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cpobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Div" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Div_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Dup" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Endfilter" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Endfinally" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Initblk" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Initobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Isinst" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Jmp" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarga" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarga_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_5" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_6" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_7" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_m1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelema" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldflda" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldftn" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldlen" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloca" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloca_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldnull" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldsfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldsflda" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldstr" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldtoken" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldvirtftn" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Leave" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Leave_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Localloc" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mkrefany" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mul" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mul_ovf" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mul_ovf_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Neg" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Newarr" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Newobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Nop" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Not" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Or" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Pop" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Readonly" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Refanytype" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Refanyval" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Rem" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Rem_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ret" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Rethrow" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Shl" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Shr" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Shr_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sizeof" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Starg" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Starg_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stsfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sub" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sub_ovf" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sub_ovf_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Switch" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Tail" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Throw" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Unaligned" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Unbox" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Unbox_any" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Volatile" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Xor" />
    <member name="T:System.Reflection.Metadata.ILOpCodeExtensions" />
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.GetBranchOperandSize(System.Reflection.Metadata.ILOpCode)">
      <summary>Calcule la taille de l’opérande d’instruction de la branche spécifiée.</summary>
      <param name="opCode">Code d’opération de la branche.</param>
      <exception cref="T:System.ArgumentException">Le <paramref name="opCode" /> spécifié n’est pas un code d’opération de branche.</exception>
      <returns>1 si <paramref name="opCode" /> est une branche courte, ou 4 s’il s’agit d’une branche longue.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.GetLongBranch(System.Reflection.Metadata.ILOpCode)">
      <summary>Obtient une forme longue du code d’opération de la branche spécifiée.</summary>
      <param name="opCode">Code d’opération de la branche.</param>
      <exception cref="T:System.ArgumentException">Le <paramref name="opCode" /> spécifié n’est pas un code d’opération de branche.</exception>
      <returns>Forme longue du code d’opération de la branche.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.GetShortBranch(System.Reflection.Metadata.ILOpCode)">
      <summary>Obtient une forme courte du code d’opération de la branche spécifiée.</summary>
      <param name="opCode">Code d’opération de la branche.</param>
      <exception cref="T:System.ArgumentException">Le <paramref name="opCode" /> spécifié n’est pas un code d’opération de branche.</exception>
      <returns>Forme courte du code d’opération de la branche.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.IsBranch(System.Reflection.Metadata.ILOpCode)">
      <summary>Vérifie si le code d’opération spécifié est une branche sur une étiquette.</summary>
      <param name="opCode" />
      <returns>
        <see langword="true" /> si le code d’opération spécifié est une branche sur une étiquette ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImageFormatLimitationException">
      <summary>Exception levée lorsqu’une tentative d’écriture de métadonnées dépasse une limite donnée par la spécification du format. Par exemple, quand la limite de taille du tas est dépassée.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" /> avec des données sérialisées.</summary>
      <param name="info">Objet qui contient les données sérialisées de l'objet.</param>
      <param name="context">Informations contextuelles sur la source ou la destination.</param>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor(System.String)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" /> avec un message d'erreur spécifié.</summary>
      <param name="message">Message d'erreur expliquant la raison de cette exception.</param>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor(System.String,System.Exception)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" /> avec un message d'erreur spécifié et l'exception qui est à l'origine de cette exception.</summary>
      <param name="message">Message d'erreur expliquant la raison de cette exception.</param>
      <param name="innerException">L'exception qui est la cause de l'exception actuelle ou <see langword="null" /> si aucune exception interne n'est spécifiée.</param>
    </member>
    <member name="T:System.Reflection.Metadata.ImportDefinition" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.Alias" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.Kind" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.TargetAssembly" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.TargetNamespace" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.TargetType" />
    <member name="T:System.Reflection.Metadata.ImportDefinitionCollection" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ImportDefinition}#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein de la collection.</summary>
      <returns>Énumérateur permettant d'effectuer une itération au sein de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein d’une collection.</summary>
      <returns>Objet <see cref="T:System.Collections.IEnumerator" /> pouvant être utilisé pour itérer au sein de la collection.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.MoveNext">
      <summary>Avance l’énumérateur à l’élément suivant de la collection.</summary>
      <exception cref="T:System.BadImageFormatException">Format de l’objet blob non valide.</exception>
      <returns>
        <see langword="true" /> si l'énumérateur a pu avancer jusqu'à l'élément suivant ; <see langword="false" /> si l'énumérateur a dépassé la fin de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.Reset">
      <summary>Rétablit l'énumérateur à sa position initiale, qui précède le premier élément de la collection.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Exécute les tâches définies par l'application associées à la libération ou à la redéfinition des ressources non managées.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImportDefinitionKind" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasAssemblyNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasAssemblyReference" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasType" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportAssemblyNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportAssemblyReferenceAlias" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportType" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportXmlNamespace" />
    <member name="T:System.Reflection.Metadata.ImportScope">
      <summary>Fournit des informations sur la portée lexicale dans laquelle un groupe d’importations est disponible. Ces informations sont stockées dans les métadonnées de débogage.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScope.GetImports" />
    <member name="P:System.Reflection.Metadata.ImportScope.ImportsBlob" />
    <member name="P:System.Reflection.Metadata.ImportScope.Parent" />
    <member name="T:System.Reflection.Metadata.ImportScopeCollection" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ImportScopeHandle}#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein de la collection.</summary>
      <returns>Énumérateur permettant d'effectuer une itération au sein de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein d’une collection.</summary>
      <returns>Objet <see cref="T:System.Collections.IEnumerator" /> pouvant être utilisé pour itérer au sein de la collection.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ImportScopeCollection.Count">
      <summary>Obtient le nombre d’éléments de la collection.</summary>
      <returns>Nombre d'éléments dans la collection.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImportScopeCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.Enumerator.MoveNext">
      <summary>Avance l’énumérateur à l’élément suivant de la collection.</summary>
      <returns>
        <see langword="true" /> si l'énumérateur a pu avancer jusqu'à l'élément suivant ; <see langword="false" /> si l'énumérateur a dépassé la fin de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Rétablit l'énumérateur à sa position initiale, qui précède le premier élément de la collection.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Exécute les tâches définies par l'application associées à la libération ou à la redéfinition des ressources non managées.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ImportScopeCollection.Enumerator.Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ImportScopeCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImportScopeHandle" />
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.Equals(System.Reflection.Metadata.ImportScopeHandle)">
      <summary>Indique si l'objet actuel est égal à un autre objet du même type.</summary>
      <param name="other">Objet à comparer à cet objet.</param>
      <returns>
        <see langword="true" /> si l'objet actuel est égal au paramètre <paramref name="other" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Equality(System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.ImportScopeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ImportScopeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ImportScopeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Implicit(System.Reflection.Metadata.ImportScopeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Implicit(System.Reflection.Metadata.ImportScopeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Inequality(System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.ImportScopeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.ImportScopeHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.InterfaceImplementation" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementation.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.InterfaceImplementation.Interface">
      <summary>Obtient l’interface implémentée (<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />).</summary>
    </member>
    <member name="T:System.Reflection.Metadata.InterfaceImplementationHandle" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.Equals(System.Reflection.Metadata.InterfaceImplementationHandle)">
      <summary>Indique si l'objet actuel est égal à un autre objet du même type.</summary>
      <param name="other">Objet à comparer à cet objet.</param>
      <returns>
        <see langword="true" /> si l'objet actuel est égal au paramètre <paramref name="other" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Equality(System.Reflection.Metadata.InterfaceImplementationHandle,System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.InterfaceImplementationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.InterfaceImplementationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Implicit(System.Reflection.Metadata.InterfaceImplementationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Implicit(System.Reflection.Metadata.InterfaceImplementationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Inequality(System.Reflection.Metadata.InterfaceImplementationHandle,System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.InterfaceImplementationHandleCollection" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#InterfaceImplementationHandle}#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein de la collection.</summary>
      <returns>Énumérateur permettant d'effectuer une itération au sein de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein d’une collection.</summary>
      <returns>Objet <see cref="T:System.Collections.IEnumerator" /> pouvant être utilisé pour itérer au sein de la collection.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Count">
      <summary>Obtient le nombre d’éléments de la collection.</summary>
      <returns>Nombre d'éléments dans la collection.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.MoveNext">
      <summary>Avance l’énumérateur à l’élément suivant de la collection.</summary>
      <returns>
        <see langword="true" /> si l'énumérateur a pu avancer jusqu'à l'élément suivant ; <see langword="false" /> si l'énumérateur a dépassé la fin de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Rétablit l'énumérateur à sa position initiale, qui précède le premier élément de la collection.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Exécute les tâches définies par l'application associées à la libération ou à la redéfinition des ressources non managées.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ISignatureTypeProvider`2">
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetFunctionPointerType(System.Reflection.Metadata.MethodSignature{`0})">
      <summary>Obtient le symbole de type du type de pointeur de fonction de la méthode <paramref name="signature" /> donnée.</summary>
      <param name="signature" />
      <returns>Symbole de type du type de pointeur de fonction.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetGenericMethodParameter(`1,System.Int32)">
      <summary>Obtient le symbole de type du paramètre de méthode générique au niveau de l’<paramref name="index" /> de base zéro.</summary>
      <param name="genericContext" />
      <param name="index" />
      <returns>Symbole de type du paramètre de méthode générique au niveau de l’<paramref name="index" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetGenericTypeParameter(`1,System.Int32)">
      <summary>Obtient le symbole de type du paramètre de type générique au niveau de l’<paramref name="index" /> de base zéro.</summary>
      <param name="genericContext" />
      <param name="index" />
      <returns>Symbole de type du paramètre de type générique au niveau de l’<paramref name="index" /> de base zéro.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetModifiedType(`0,`0,System.Boolean)">
      <summary>Obtient le symbole de type d’un type avec un modificateur personnalisé appliqué.</summary>
      <param name="modifier">Type de modificateur appliqué.</param>
      <param name="unmodifiedType">Symbole de type du type sous-jacent sans modificateurs appliqués.</param>
      <param name="isRequired">
        <see langword="true" /> si le modificateur est nécessaire, <see langword="false" /> s’il est facultatif.</param>
      <returns>Symbole de type.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetPinnedType(`0)">
      <summary>Obtient le symbole de type d’un type de variable locale qui est marqué comme étant épinglé.</summary>
      <param name="elementType" />
      <returns>Symbole de type du type de variable locale.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetTypeFromSpecification(System.Reflection.Metadata.MetadataReader,`1,System.Reflection.Metadata.TypeSpecificationHandle,System.Byte)">
      <summary>Obtient le symbole de type d’une spécification de type.</summary>
      <param name="reader">Lecteur de métadonnées passé au décodeur de signature. Peut avoir la valeur <see langword="null" />.</param>
      <param name="genericContext">Contexte passé au décodeur de signature.</param>
      <param name="handle">Handle de spécification de type.</param>
      <param name="rawTypeKind">Genre du type tel que spécifié dans la signature. Pour interpréter cette valeur, utilisez <see cref="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)" />.</param>
      <returns>Symbole de type de la spécification de type.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ISimpleTypeProvider`1">
      <typeparam name="TType" />
    </member>
    <member name="M:System.Reflection.Metadata.ISimpleTypeProvider`1.GetPrimitiveType(System.Reflection.Metadata.PrimitiveTypeCode)">
      <summary>Obtient le symbole de type d’un type primitif.</summary>
      <param name="typeCode" />
      <returns>Symbole de type de <param name="typeCode" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISimpleTypeProvider`1.GetTypeFromDefinition(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.TypeDefinitionHandle,System.Byte)">
      <summary>Obtient le symbole de type d’une définition de type.</summary>
      <param name="reader">Lecteur de métadonnées passé au décodeur de signature. Peut avoir la valeur <see langword="null" />.</param>
      <param name="handle">Handle de définition de type.</param>
      <param name="rawTypeKind">Genre du type tel que spécifié dans la signature. Pour interpréter cette valeur, utilisez <see cref="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)" />.</param>
      <returns>Symbole de type.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISimpleTypeProvider`1.GetTypeFromReference(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.TypeReferenceHandle,System.Byte)">
      <summary>Obtient le symbole de type d’une référence de type.</summary>
      <param name="reader">Lecteur de métadonnées passé au décodeur de signature. Peut avoir la valeur <see langword="null" />.</param>
      <param name="handle">Handle de définition de type.</param>
      <param name="rawTypeKind">Genre du type tel que spécifié dans la signature. Pour interpréter cette valeur, utilisez <see cref="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)" />.</param>
      <returns>Symbole de type.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ISZArrayTypeProvider`1">
      <typeparam name="TType" />
    </member>
    <member name="M:System.Reflection.Metadata.ISZArrayTypeProvider`1.GetSZArrayType(`0)">
      <summary>Obtient le symbole de type d’un tableau unidimensionnel du type d’élément donné avec une limite inférieure de zéro.</summary>
      <param name="elementType" />
      <returns>Instance de <typeparamref name="TType" />.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalConstant">
      <summary>Fournit des informations sur les constantes locales. Ces informations sont stockées dans les métadonnées de débogage.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstant.Name" />
    <member name="P:System.Reflection.Metadata.LocalConstant.Signature">
      <summary>Obtient la signature constante.</summary>
      <returns>Signature constante.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalConstantHandle" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.Equals(System.Reflection.Metadata.LocalConstantHandle)">
      <summary>Indique si l'objet actuel est égal à un autre objet du même type.</summary>
      <param name="other">Objet à comparer à cet objet.</param>
      <returns>
        <see langword="true" /> si l'objet actuel est égal au paramètre <paramref name="other" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Equality(System.Reflection.Metadata.LocalConstantHandle,System.Reflection.Metadata.LocalConstantHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.LocalConstantHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.LocalConstantHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Implicit(System.Reflection.Metadata.LocalConstantHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Implicit(System.Reflection.Metadata.LocalConstantHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Inequality(System.Reflection.Metadata.LocalConstantHandle,System.Reflection.Metadata.LocalConstantHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstantHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.LocalConstantHandleCollection" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#LocalConstantHandle}#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein de la collection.</summary>
      <returns>Énumérateur permettant d'effectuer une itération au sein de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein d’une collection.</summary>
      <returns>Objet <see cref="T:System.Collections.IEnumerator" /> pouvant être utilisé pour itérer au sein de la collection.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstantHandleCollection.Count">
      <summary>Obtient le nombre d’éléments de la collection.</summary>
      <returns>Nombre d'éléments dans la collection.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.MoveNext">
      <summary>Avance l’énumérateur à l’élément suivant de la collection.</summary>
      <returns>
        <see langword="true" /> si l'énumérateur a pu avancer jusqu'à l'élément suivant ; <see langword="false" /> si l'énumérateur a dépassé la fin de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Rétablit l'énumérateur à sa position initiale, qui précède le premier élément de la collection.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Exécute les tâches définies par l'application associées à la libération ou à la redéfinition des ressources non managées.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalScope">
      <summary>Fournit des informations sur la portée des variables locales et des constantes. Ces informations sont stockées dans les métadonnées de débogage.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScope.GetChildren" />
    <member name="M:System.Reflection.Metadata.LocalScope.GetLocalConstants" />
    <member name="M:System.Reflection.Metadata.LocalScope.GetLocalVariables" />
    <member name="P:System.Reflection.Metadata.LocalScope.EndOffset" />
    <member name="P:System.Reflection.Metadata.LocalScope.ImportScope" />
    <member name="P:System.Reflection.Metadata.LocalScope.Length" />
    <member name="P:System.Reflection.Metadata.LocalScope.Method" />
    <member name="P:System.Reflection.Metadata.LocalScope.StartOffset" />
    <member name="T:System.Reflection.Metadata.LocalScopeHandle" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.Equals(System.Reflection.Metadata.LocalScopeHandle)">
      <summary>Indique si l'objet actuel est égal à un autre objet du même type.</summary>
      <param name="other">Objet à comparer à cet objet.</param>
      <returns>
        <see langword="true" /> si l'objet actuel est égal au paramètre <paramref name="other" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Equality(System.Reflection.Metadata.LocalScopeHandle,System.Reflection.Metadata.LocalScopeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.LocalScopeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.LocalScopeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Implicit(System.Reflection.Metadata.LocalScopeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Implicit(System.Reflection.Metadata.LocalScopeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Inequality(System.Reflection.Metadata.LocalScopeHandle,System.Reflection.Metadata.LocalScopeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.LocalScopeHandleCollection" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#LocalScopeHandle}#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein de la collection.</summary>
      <returns>Énumérateur permettant d'effectuer une itération au sein de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein d’une collection.</summary>
      <returns>Objet <see cref="T:System.Collections.IEnumerator" /> pouvant être utilisé pour itérer au sein de la collection.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.Count">
      <summary>Obtient le nombre d’éléments de la collection.</summary>
      <returns>Nombre d'éléments dans la collection.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.MoveNext">
      <summary>Avance l’énumérateur à l’élément suivant de la collection.</summary>
      <returns>
        <see langword="true" /> si l'énumérateur a pu avancer jusqu'à l'élément suivant ; <see langword="false" /> si l'énumérateur a dépassé la fin de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.System#Collections#IEnumerator#Reset">
      <summary>Rétablit l'énumérateur à sa position initiale, qui précède le premier élément de la collection.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.System#IDisposable#Dispose">
      <summary>Exécute les tâches définies par l'application associées à la libération ou à la redéfinition des ressources non managées.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.System#Collections#IEnumerator#Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.MoveNext">
      <summary>Avance l’énumérateur à l’élément suivant de la collection.</summary>
      <returns>
        <see langword="true" /> si l'énumérateur a pu avancer jusqu'à l'élément suivant ; <see langword="false" /> si l'énumérateur a dépassé la fin de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Rétablit l'énumérateur à sa position initiale, qui précède le premier élément de la collection.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Exécute les tâches définies par l'application associées à la libération ou à la redéfinition des ressources non managées.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalVariable">
      <summary>Fournit des informations sur les variables locales. Ces informations sont stockées dans les métadonnées de débogage.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariable.Attributes" />
    <member name="P:System.Reflection.Metadata.LocalVariable.Index" />
    <member name="P:System.Reflection.Metadata.LocalVariable.Name" />
    <member name="T:System.Reflection.Metadata.LocalVariableAttributes" />
    <member name="F:System.Reflection.Metadata.LocalVariableAttributes.DebuggerHidden" />
    <member name="F:System.Reflection.Metadata.LocalVariableAttributes.None" />
    <member name="T:System.Reflection.Metadata.LocalVariableHandle" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.Equals(System.Reflection.Metadata.LocalVariableHandle)">
      <summary>Indique si l'objet actuel est égal à un autre objet du même type.</summary>
      <param name="other">Objet à comparer à cet objet.</param>
      <returns>
        <see langword="true" /> si l'objet actuel est égal au paramètre <paramref name="other" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Equality(System.Reflection.Metadata.LocalVariableHandle,System.Reflection.Metadata.LocalVariableHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.LocalVariableHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.LocalVariableHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Implicit(System.Reflection.Metadata.LocalVariableHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Implicit(System.Reflection.Metadata.LocalVariableHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Inequality(System.Reflection.Metadata.LocalVariableHandle,System.Reflection.Metadata.LocalVariableHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariableHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.LocalVariableHandleCollection" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#LocalVariableHandle}#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein de la collection.</summary>
      <returns>Énumérateur permettant d'effectuer une itération au sein de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein d’une collection.</summary>
      <returns>Objet <see cref="T:System.Collections.IEnumerator" /> pouvant être utilisé pour itérer au sein de la collection.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariableHandleCollection.Count">
      <summary>Obtient le nombre d’éléments de la collection.</summary>
      <returns>Nombre d'éléments dans la collection.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.MoveNext">
      <summary>Avance l’énumérateur à l’élément suivant de la collection.</summary>
      <returns>
        <see langword="true" /> si l'énumérateur a pu avancer jusqu'à l'élément suivant ; <see langword="false" /> si l'énumérateur a dépassé la fin de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Rétablit l'énumérateur à sa position initiale, qui précède le premier élément de la collection.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Exécute les tâches définies par l'application associées à la libération ou à la redéfinition des ressources non managées.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ManifestResource" />
    <member name="M:System.Reflection.Metadata.ManifestResource.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ManifestResource.Attributes">
      <summary>Obtient les attributs de la ressource de manifeste.</summary>
      <returns>Combinaison d’opérations de bits des valeurs d’énumération qui spécifient les attributs de ressource de manifeste.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResource.Implementation">
      <summary>Obtient le descripteur de l’entité d'implémentation.</summary>
      <returns>Instance EntityHandle. Si la <see cref="P:System.Reflection.Metadata.EntityHandle.IsNil" /> propriété a la valeur <see langword="true" /> , le handle retourné aura des valeurs par défaut.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResource.Name">
      <summary>Obtient le nom de la ressource.</summary>
      <returns>Nom de la ressource.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResource.Offset">
      <summary>Obtient l’offset d’octet dans le fichier référencé à partir duquel commence cet enregistrement de ressource.</summary>
      <returns>Offset d’octet dans le fichier référencé où commence cet enregistrement de ressource.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ManifestResourceHandle" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.Equals(System.Reflection.Metadata.ManifestResourceHandle)">
      <summary>Indique si l'objet actuel est égal à un autre objet du même type.</summary>
      <param name="other">Objet à comparer à cet objet.</param>
      <returns>
        <see langword="true" /> si l'objet actuel est égal au paramètre <paramref name="other" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Equality(System.Reflection.Metadata.ManifestResourceHandle,System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ManifestResourceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ManifestResourceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Implicit(System.Reflection.Metadata.ManifestResourceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Implicit(System.Reflection.Metadata.ManifestResourceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Inequality(System.Reflection.Metadata.ManifestResourceHandle,System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResourceHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ManifestResourceHandleCollection">
      <summary>Représente une collection d'instances <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ManifestResourceHandle}#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein de la collection.</summary>
      <returns>Énumérateur permettant d'effectuer une itération au sein de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein d’une collection.</summary>
      <returns>Objet <see cref="T:System.Collections.IEnumerator" /> pouvant être utilisé pour itérer au sein de la collection.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResourceHandleCollection.Count">
      <summary>Obtient le nombre d’éléments de la collection.</summary>
      <returns>Nombre d'éléments dans la collection.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.MoveNext">
      <summary>Avance l’énumérateur à l’élément suivant de la collection.</summary>
      <returns>
        <see langword="true" /> si l'énumérateur a pu avancer jusqu'à l'élément suivant ; <see langword="false" /> si l'énumérateur a dépassé la fin de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Rétablit l'énumérateur à sa position initiale, qui précède le premier élément de la collection.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Exécute les tâches définies par l'application associées à la libération ou à la redéfinition des ressources non managées.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MemberReference" />
    <member name="M:System.Reflection.Metadata.MemberReference.DecodeFieldSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReference.DecodeMethodSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReference.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.MemberReference.GetKind">
      <summary>Détermine si le membre référence est une méthode ou un champ.</summary>
      <exception cref="T:System.BadImageFormatException">La signature du membre référence est invalide.</exception>
      <returns>Une des valeurs d'énumération indiquant le genre du membre référence.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReference.Name" />
    <member name="P:System.Reflection.Metadata.MemberReference.Parent">
      <summary>Obtient le descripteur de l’entité parente.</summary>
      <returns>Instance de handle d’entité. Si la <see cref="P:System.Reflection.Metadata.EntityHandle.IsNil" /> propriété a la valeur <see langword="true" /> , le handle retourné aura des valeurs par défaut.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReference.Signature">
      <summary>Obtient un handle vers l’objet blob de signature.</summary>
      <returns>Handle de l’objet blob de signature.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MemberReferenceHandle" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.Equals(System.Reflection.Metadata.MemberReferenceHandle)">
      <summary>Indique si l'objet actuel est égal à un autre objet du même type.</summary>
      <param name="other">Objet à comparer à cet objet.</param>
      <returns>
        <see langword="true" /> si l'objet actuel est égal au paramètre <paramref name="other" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Equality(System.Reflection.Metadata.MemberReferenceHandle,System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MemberReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MemberReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Implicit(System.Reflection.Metadata.MemberReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Implicit(System.Reflection.Metadata.MemberReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Inequality(System.Reflection.Metadata.MemberReferenceHandle,System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.MemberReferenceHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.MemberReferenceHandleCollection">
      <summary>Représente une collection d'instances <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MemberReferenceHandle}#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein de la collection.</summary>
      <returns>Énumérateur permettant d'effectuer une itération au sein de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein d’une collection.</summary>
      <returns>Objet <see cref="T:System.Collections.IEnumerator" /> pouvant être utilisé pour itérer au sein de la collection.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReferenceHandleCollection.Count">
      <summary>Obtient le nombre d’éléments de la collection.</summary>
      <returns>Nombre d'éléments dans la collection.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.MoveNext">
      <summary>Avance l’énumérateur à l’élément suivant de la collection.</summary>
      <returns>
        <see langword="true" /> si l'énumérateur a pu avancer jusqu'à l'élément suivant ; <see langword="false" /> si l'énumérateur a dépassé la fin de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Rétablit l'énumérateur à sa position initiale, qui précède le premier élément de la collection.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Exécute les tâches définies par l'application associées à la libération ou à la redéfinition des ressources non managées.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MemberReferenceKind">
      <summary>Spécifie des constantes qui indiquent si un <see cref="T:System.Reflection.Metadata.MemberReference" /> référence une méthode ou un champ.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MemberReferenceKind.Field">
      <summary>Le <see cref="T:System.Reflection.Metadata.MemberReference" /> référence un champ.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MemberReferenceKind.Method">
      <summary>Le <see cref="T:System.Reflection.Metadata.MemberReference" /> référence une méthode.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataKind" />
    <member name="F:System.Reflection.Metadata.MetadataKind.Ecma335">
      <summary>Métadonnées CLI.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataKind.ManagedWindowsMetadata">
      <summary>Métadonnées Windows générées par des compilateurs gérés.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataKind.WindowsMetadata">
      <summary>Métadonnées Windows.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataReader">
      <summary>Lit les métadonnées comme défini par la spécification de l’interface CLI ECMA 335.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Reflection.Metadata.MetadataReader" /> des métadonnées stockées dans l’emplacement de mémoire donné.</summary>
      <param name="metadata">Pointeur vers le premier octet d’un bloc de métadonnées.</param>
      <param name="length">Nombre d’octets dans le bloc.</param>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32,System.Reflection.Metadata.MetadataReaderOptions)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Reflection.Metadata.MetadataReader" /> des métadonnées stockées dans l’emplacement de mémoire donné.</summary>
      <param name="metadata" />
      <param name="length" />
      <param name="options" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32,System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Reflection.Metadata.MetadataReader" /> des métadonnées stockées dans l’emplacement de mémoire donné.</summary>
      <param name="metadata" />
      <param name="length" />
      <param name="options" />
      <param name="utf8Decoder" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" /> n’est pas positif.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="metadata" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">L’encodage de <paramref name="utf8Decoder" /> n’est pas <see cref="T:System.Text.UTF8Encoding" />.</exception>
      <exception cref="T:System.PlatformNotSupportedException">La plateforme actuelle est avec primauté des octets de poids fort (big-endian).</exception>
      <exception cref="T:System.BadImageFormatException">En-tête de métadonnées incorrect.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetAssemblyDefinition" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetAssemblyFile(System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetAssemblyReference(System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobBytes(System.Reflection.Metadata.BlobHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobContent(System.Reflection.Metadata.BlobHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobReader(System.Reflection.Metadata.BlobHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobReader(System.Reflection.Metadata.StringHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetConstant(System.Reflection.Metadata.ConstantHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomAttribute(System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomAttributes(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomDebugInformation(System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomDebugInformation(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetDeclarativeSecurityAttribute(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetDocument(System.Reflection.Metadata.DocumentHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetEventDefinition(System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetExportedType(System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetFieldDefinition(System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetGenericParameter(System.Reflection.Metadata.GenericParameterHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetGenericParameterConstraint(System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetGuid(System.Reflection.Metadata.GuidHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetImportScope(System.Reflection.Metadata.ImportScopeHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetInterfaceImplementation(System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalConstant(System.Reflection.Metadata.LocalConstantHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalScope(System.Reflection.Metadata.LocalScopeHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalScopes(System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalScopes(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalVariable(System.Reflection.Metadata.LocalVariableHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetManifestResource(System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMemberReference(System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodDebugInformation(System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodDebugInformation(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodDefinition(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodImplementation(System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodSpecification(System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetModuleDefinition" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetModuleReference(System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetNamespaceDefinition(System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetNamespaceDefinitionRoot" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetParameter(System.Reflection.Metadata.ParameterHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetPropertyDefinition(System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetStandaloneSignature(System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetString(System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetString(System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetString(System.Reflection.Metadata.StringHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetTypeDefinition(System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetTypeReference(System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetTypeSpecification(System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetUserString(System.Reflection.Metadata.UserStringHandle)">
      <param name="handle" />
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.AssemblyFiles" />
    <member name="P:System.Reflection.Metadata.MetadataReader.AssemblyReferences" />
    <member name="P:System.Reflection.Metadata.MetadataReader.CustomAttributes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.CustomDebugInformation" />
    <member name="P:System.Reflection.Metadata.MetadataReader.DebugMetadataHeader">
      <summary>Obtient les informations décodées à partir du flux #Pdb, ou <see langword="null" /> si le flux de données n’est pas présent.</summary>
      <returns>Les informations décodées à partir de #Pdb flux, ou <see langword="null" /> si le flux n’est pas présent.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.DeclarativeSecurityAttributes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.Documents" />
    <member name="P:System.Reflection.Metadata.MetadataReader.EventDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.ExportedTypes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.FieldDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.ImportScopes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.IsAssembly">
      <summary>Obtient une valeur qui indique si les métadonnées représentent un assembly.</summary>
      <returns>
        <see langword="true" /> Si les métadonnées représentent un assembly ; Sinon, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.LocalConstants" />
    <member name="P:System.Reflection.Metadata.MetadataReader.LocalScopes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.LocalVariables" />
    <member name="P:System.Reflection.Metadata.MetadataReader.ManifestResources" />
    <member name="P:System.Reflection.Metadata.MetadataReader.MemberReferences" />
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataKind">
      <summary>Obtient le type des métadonnées.</summary>
      <returns>L’une des valeurs d’énumération qui spécifie le type de métadonnées.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataLength">
      <summary>Obtient la longueur des données sous-jacentes.</summary>
      <returns>Longueur des données sous-jacentes.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataPointer">
      <summary>Obtient le pointeur des données sous-jacentes.</summary>
      <returns>Pointeur vers les données sous-jacentes.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataVersion">
      <summary>Obtient la chaîne de version lire à partir de l’en-tête de métadonnées.</summary>
      <returns>Chaîne de version lue à partir de l’en-tête de métadonnées.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MethodDebugInformation" />
    <member name="P:System.Reflection.Metadata.MetadataReader.MethodDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.Options">
      <summary>Obtient le <see cref="T:System.Reflection.Metadata.MetadataReaderOptions" /> passé dans le constructeur.</summary>
      <returns>Combinaison d’opérations de bits des valeurs d’énumération qui décrit la <see cref="T:System.Reflection.Metadata.MetadataReaderOptions" /> valeur enum.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.PropertyDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.StringComparer">
      <summary>Obtient le comparateur utilisé pour comparer les chaînes stockées dans les métadonnées.</summary>
      <returns>Comparateur utilisé pour comparer des chaînes stockées dans les métadonnées.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.TypeDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.TypeReferences" />
    <member name="P:System.Reflection.Metadata.MetadataReader.UTF8Decoder">
      <summary>Obtient le décodeur utilisé par le lecteur pour produire des instances de chaîne à partir de séquences d’octets encodées en UTF-8.</summary>
      <returns>Décodeur utilisé par le lecteur pour produire des instances de chaîne à partir de séquences d’octets encodées en UTF8.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataReaderOptions" />
    <member name="F:System.Reflection.Metadata.MetadataReaderOptions.ApplyWindowsRuntimeProjections">
      <summary>Les projections Windows Runtime sont activées (par défaut).</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataReaderOptions.Default">
      <summary>Les options utilisées lorsqu’un <see cref="T:System.Reflection.Metadata.MetadataReader" /> est obtenu via une surcharge qui ne prend pas d'argument <see cref="T:System.Reflection.Metadata.MetadataReaderOptions" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataReaderOptions.None">
      <summary>Toutes les options sont désactivées.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataReaderProvider">
      <summary>Fournit un <see cref="T:System.Reflection.Metadata.MetadataReader" /> pour les métadonnées stockées dans un tableau d’octets, un bloc de mémoire ou un flux.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.Dispose">
      <summary>Supprime toute la mémoire allouée par le lecteur.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromMetadataImage(System.Byte*,System.Int32)">
      <summary>Crée un fournisseur de métadonnées sur une image stockée en mémoire.</summary>
      <param name="start">Pointeur au début de l’objet blob de métadonnées.</param>
      <param name="size">Taille de l’objet blob de métadonnées.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="start" /> a la valeur <see cref="F:System.IntPtr.Zero" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> est un nombre négatif.</exception>
      <returns>Nouveau fournisseur de métadonnées.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromMetadataImage(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>Crée un fournisseur sur un tableau d’octets.</summary>
      <param name="image">Image de métadonnées.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="image" /> a la valeur <see langword="null" />.</exception>
      <returns>Nouveau fournisseur.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromMetadataStream(System.IO.Stream,System.Reflection.Metadata.MetadataStreamOptions,System.Int32)">
      <summary>Crée un fournisseur pour un flux de la taille spécifiée en commençant à sa position actuelle.</summary>
      <param name="stream">Instance de <see cref="T:System.IO.Stream" />.</param>
      <param name="options">Options qui spécifient comment les sections de l’image sont lues à partir du flux.</param>
      <param name="size">Taille de l’objet blob de métadonnées dans le flux. Si rien n’est spécifié, l’objet blob de métadonnées s’étend par défaut jusqu’à la fin du flux.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="stream" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="stream" /> ne prend pas en charge les opérations de lecture et de recherche.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">La taille est négative ou s’étend au-delà de la fin du flux.</exception>
      <exception cref="T:System.IO.IOException">Erreur de lecture du flux (uniquement quand <see cref="F:System.Reflection.Metadata.MetadataStreamOptions.PrefetchMetadata" /> est spécifié).</exception>
      <returns>Nouveau fournisseur.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromPortablePdbImage(System.Byte*,System.Int32)">
      <summary>Crée un fournisseur de métadonnées PDB portable sur un objet blob stocké en mémoire.</summary>
      <param name="start">Pointeur au début de l’objet blob PDB portable.</param>
      <param name="size">Nom de l’objet blob PDB portable.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="start" /> a la valeur <see cref="F:System.IntPtr.Zero" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> est un nombre négatif.</exception>
      <returns>Nouveau fournisseur de métadonnées PDB portable.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromPortablePdbImage(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>Crée un fournisseur de métadonnées PDB portable sur un tableau d’octets.</summary>
      <param name="image">Image PDB portable.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="image" /> a la valeur <see langword="null" />.</exception>
      <returns>Nouveau fournisseur de métadonnées PDB portable.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromPortablePdbStream(System.IO.Stream,System.Reflection.Metadata.MetadataStreamOptions,System.Int32)">
      <summary>Crée un fournisseur pour un flux de la taille spécifiée en commençant à sa position actuelle.</summary>
      <param name="stream">Flux.</param>
      <param name="options">Options qui spécifient comment les sections de l’image sont lues à partir du flux.</param>
      <param name="size">Taille de l’objet blob de métadonnées dans le flux. Si rien n’est spécifié, l’objet blob de métadonnées s’étend par défaut jusqu’à la fin du flux.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="stream" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="stream" /> ne prend pas en charge les opérations de lecture et de recherche.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">La taille est négative ou s’étend au-delà de la fin du flux.</exception>
      <returns>Instance de <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.GetMetadataReader(System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)">
      <summary>Obtient un <see cref="T:System.Reflection.Metadata.MetadataReader" /> d'un <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /></summary>
      <param name="options">Combinaison d’opérations de bits des valeurs d’énumération qui représentent la configuration lors de la lecture des métadonnées.</param>
      <param name="utf8Decoder">Encodage à utiliser.</param>
      <exception cref="T:System.ArgumentException">L’encodage de <paramref name="utf8Decoder" /> n’est pas <see cref="T:System.Text.UTF8Encoding" />.</exception>
      <exception cref="T:System.PlatformNotSupportedException">La plateforme actuelle est avec primauté des octets de poids fort (big-endian).</exception>
      <exception cref="T:System.IO.IOException">Erreur d’E/S lors de la lecture à partir du flux sous-jacent.</exception>
      <exception cref="T:System.ObjectDisposedException">Le fournisseur a été supprimé.</exception>
      <returns>Instance de <see cref="T:System.Reflection.Metadata.MetadataReader" />.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataStreamOptions" />
    <member name="F:System.Reflection.Metadata.MetadataStreamOptions.Default">
      <summary>Par défaut, le flux est supprimé lorsque <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> est supprimé et que les sections de l’image PE sont lues de manière différée.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataStreamOptions.LeaveOpen">
      <summary>Conserve le flux ouvert lorsque le <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> est supprimé.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataStreamOptions.PrefetchMetadata">
      <summary>
        <para>Lit les métadonnées du fichier PDB en mémoire immédiatement.</para>
        <para>Le fichier sous-jacent peut être fermé et même supprimé une fois le <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> construit. <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> ferme automatiquement le flux au moment où le constructeur retourne une valeur, sauf si <see cref="F:System.Reflection.Metadata.MetadataStreamOptions.LeaveOpen" /> est spécifié.</para>
      </summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataStringComparer">
      <summary>Fournit des applications d’assistance de comparaison de chaînes pour interroger les chaînes dans les métadonnées tout en évitant si possible les allocations.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.DocumentNameBlobHandle,System.String)">
      <param name="handle" />
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.DocumentNameBlobHandle,System.String,System.Boolean)">
      <param name="handle" />
      <param name="value" />
      <param name="ignoreCase" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.NamespaceDefinitionHandle,System.String)">
      <param name="handle" />
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.NamespaceDefinitionHandle,System.String,System.Boolean)">
      <param name="handle" />
      <param name="value" />
      <param name="ignoreCase" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.StringHandle,System.String)">
      <param name="handle" />
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.StringHandle,System.String,System.Boolean)">
      <param name="handle" />
      <param name="value" />
      <param name="ignoreCase" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.StartsWith(System.Reflection.Metadata.StringHandle,System.String)">
      <param name="handle" />
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.StartsWith(System.Reflection.Metadata.StringHandle,System.String,System.Boolean)">
      <param name="handle" />
      <param name="value" />
      <param name="ignoreCase" />
    </member>
    <member name="T:System.Reflection.Metadata.MetadataStringDecoder">
      <summary>Fournit le <see cref="T:System.Reflection.Metadata.MetadataReader" /> avec un mécanisme personnalisé pour décoder les séquences d’octets dans les métadonnées qui représentent du texte.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringDecoder.#ctor(System.Text.Encoding)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Reflection.Metadata.MetadataStringDecoder" /> avec l’encodage donné.</summary>
      <param name="encoding">Encodage à utiliser.</param>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringDecoder.GetString(System.Byte*,System.Int32)">
      <summary>Obtient les chaînes pour les séquences d’octets dans les métadonnées. Remplacez les chaînes de cache si nécessaire. Sinon, elles sont implémentées par envoi directement dans <see cref="P:System.Reflection.Metadata.MetadataStringDecoder.Encoding" /> et chaque appel allouera une nouvelle chaîne.</summary>
      <param name="bytes">Pointeur vers les octets à décoder.</param>
      <param name="byteCount">Nombre d'octets à décoder.</param>
      <returns>Chaîne décodée.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataStringDecoder.DefaultUTF8">
      <summary>Obtient le décodeur par défaut utilisé par <see cref="T:System.Reflection.Metadata.MetadataReader" /> pour décoder le format UTF-8 lorsqu’aucun décodeur n’est fourni au constructeur.</summary>
      <returns>Décodeur par défaut utilisé par <see cref="T:System.Reflection.Metadata.MetadataReader" /> pour décoder UTF-8.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataStringDecoder.Encoding">
      <summary>Obtient l’encodage utilisé par cette instance.</summary>
      <returns>Encodage utilisé par cette instance.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodBodyBlock" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.Create(System.Reflection.Metadata.BlobReader)">
      <param name="reader" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.GetILBytes" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.GetILContent" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.GetILReader" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.ExceptionRegions" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.LocalSignature" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.LocalVariablesInitialized" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.MaxStack" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.Size">
      <summary>Obtient la taille du corps de méthode, ce qui inclut l’en-tête, le langage intermédiaire et les régions d’exception.</summary>
      <returns>Taille du corps de la méthode.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDebugInformation">
      <summary>Fournit les informations de débogage associées à une définition de méthode. Ces informations sont stockées dans les métadonnées de débogage.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformation.GetSequencePoints">
      <summary>Retourne une collection de points de séquence décodés à partir de <see cref="P:System.Reflection.Metadata.MethodDebugInformation.SequencePointsBlob" />.</summary>
      <returns>Collection de points de séquence.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformation.GetStateMachineKickoffMethod">
      <summary>Retourne la méthode de démarrage de la machine à états.</summary>
      <returns>Méthode de démarrage de la machine à états, si la méthode est une méthode <c>MoveNext</c> d’une machine à états. Sinon, la valeur retournée est un handle dont la propriété <see cref="P:System.Reflection.Metadata.MethodDefinitionHandle.IsNil" /> a la valeur <see langword="true" />.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformation.Document">
      <summary>Obtient le handle du document unique contenant tous les points de séquence de la méthode.</summary>
      <returns>Handle du document unique qui contient tous les points de séquence de la méthode, ou un handle dont <see cref="P:System.Reflection.Metadata.DocumentHandle.IsNil" /> la propriété est <see langword="true" /> si la méthode n’a pas de points de séquence ou s’étend sur plusieurs documents.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformation.LocalSignature">
      <summary>Retourne un handle de signature locale.</summary>
      <returns>Handle de signature local, ou handle dont <see cref="P:System.Reflection.Metadata.StandaloneSignatureHandle.IsNil" /> la propriété est <see langword="true" /> si la méthode ne définit aucune variable locale.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformation.SequencePointsBlob">
      <summary>Retourne un objet blob encodant des points de séquence.</summary>
      <returns>Un objet BLOB qui encodage des points de séquence, ou un handle dont <see cref="P:System.Reflection.Metadata.BlobHandle.IsNil" /> la propriété a <see langword="true" /> la propriété si la méthode n’a pas de points de séquence.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDebugInformationHandle" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.Equals(System.Reflection.Metadata.MethodDebugInformationHandle)">
      <summary>Indique si l'objet actuel est égal à un autre objet du même type.</summary>
      <param name="other">Objet à comparer à cet objet.</param>
      <returns>
        <see langword="true" /> si l'objet actuel est égal au paramètre <paramref name="other" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Equality(System.Reflection.Metadata.MethodDebugInformationHandle,System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodDebugInformationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodDebugInformationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Implicit(System.Reflection.Metadata.MethodDebugInformationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Implicit(System.Reflection.Metadata.MethodDebugInformationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Inequality(System.Reflection.Metadata.MethodDebugInformationHandle,System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.ToDefinitionHandle">
      <summary>Retourne un descripteur vers un <see cref="T:System.Reflection.Metadata.MethodDefinition" /> correspondant à ce descripteur.</summary>
      <returns>Handle de définition de méthode qui correspond à ce handle.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.MethodDebugInformationHandleCollection" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MethodDebugInformationHandle}#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein de la collection.</summary>
      <returns>Énumérateur permettant d'effectuer une itération au sein de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein d’une collection.</summary>
      <returns>Objet <see cref="T:System.Collections.IEnumerator" /> pouvant être utilisé pour itérer au sein de la collection.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Count">
      <summary>Obtient le nombre d’éléments de la collection.</summary>
      <returns>Nombre d'éléments dans la collection.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.MoveNext">
      <summary>Avance l’énumérateur à l’élément suivant de la collection.</summary>
      <returns>
        <see langword="true" /> si l'énumérateur a pu avancer jusqu'à l'élément suivant ; <see langword="false" /> si l'énumérateur a dépassé la fin de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Rétablit l'énumérateur à sa position initiale, qui précède le premier élément de la collection.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Exécute les tâches définies par l'application associées à la libération ou à la redéfinition des ressources non managées.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDefinition" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetDeclarativeSecurityAttributes" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetDeclaringType" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetGenericParameters" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetImport" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetParameters" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.ImplAttributes" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.Name" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.RelativeVirtualAddress" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.Signature" />
    <member name="T:System.Reflection.Metadata.MethodDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.Equals(System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary>Indique si l'objet actuel est égal à un autre objet du même type.</summary>
      <param name="other">Objet à comparer à cet objet.</param>
      <returns>
        <see langword="true" /> si l'objet actuel est égal au paramètre <paramref name="other" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Equality(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Implicit(System.Reflection.Metadata.MethodDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Implicit(System.Reflection.Metadata.MethodDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Inequality(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.ToDebugInformationHandle">
      <summary>Retourne un descripteur vers un <see cref="T:System.Reflection.Metadata.MethodDebugInformation" /> correspondant à ce descripteur.</summary>
      <returns>Handle d’informations de débogage de méthode qui correspond à ce handle.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.MethodDefinitionHandleCollection" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MethodDefinitionHandle}#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein de la collection.</summary>
      <returns>Énumérateur permettant d'effectuer une itération au sein de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein d’une collection.</summary>
      <returns>Objet <see cref="T:System.Collections.IEnumerator" /> pouvant être utilisé pour itérer au sein de la collection.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandleCollection.Count">
      <summary>Obtient le nombre d’éléments de la collection.</summary>
      <returns>Nombre d'éléments dans la collection.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.MoveNext">
      <summary>Avance l’énumérateur à l’élément suivant de la collection.</summary>
      <returns>
        <see langword="true" /> si l'énumérateur a pu avancer jusqu'à l'élément suivant ; <see langword="false" /> si l'énumérateur a dépassé la fin de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Rétablit l'énumérateur à sa position initiale, qui précède le premier élément de la collection.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Exécute les tâches définies par l'application associées à la libération ou à la redéfinition des ressources non managées.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodImplementation" />
    <member name="M:System.Reflection.Metadata.MethodImplementation.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.MethodImplementation.MethodBody" />
    <member name="P:System.Reflection.Metadata.MethodImplementation.MethodDeclaration" />
    <member name="P:System.Reflection.Metadata.MethodImplementation.Type" />
    <member name="T:System.Reflection.Metadata.MethodImplementationHandle" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.Equals(System.Reflection.Metadata.MethodImplementationHandle)">
      <summary>Indique si l'objet actuel est égal à un autre objet du même type.</summary>
      <param name="other">Objet à comparer à cet objet.</param>
      <returns>
        <see langword="true" /> si l'objet actuel est égal au paramètre <paramref name="other" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Equality(System.Reflection.Metadata.MethodImplementationHandle,System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodImplementationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodImplementationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Implicit(System.Reflection.Metadata.MethodImplementationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Implicit(System.Reflection.Metadata.MethodImplementationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Inequality(System.Reflection.Metadata.MethodImplementationHandle,System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.MethodImplementationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.MethodImplementationHandleCollection" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MethodImplementationHandle}#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein de la collection.</summary>
      <returns>Énumérateur permettant d'effectuer une itération au sein de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein d’une collection.</summary>
      <returns>Objet <see cref="T:System.Collections.IEnumerator" /> pouvant être utilisé pour itérer au sein de la collection.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodImplementationHandleCollection.Count">
      <summary>Obtient le nombre d’éléments de la collection.</summary>
      <returns>Nombre d'éléments dans la collection.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.MoveNext">
      <summary>Avance l’énumérateur à l’élément suivant de la collection.</summary>
      <returns>
        <see langword="true" /> si l'énumérateur a pu avancer jusqu'à l'élément suivant ; <see langword="false" /> si l'énumérateur a dépassé la fin de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Rétablit l'énumérateur à sa position initiale, qui précède le premier élément de la collection.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Exécute les tâches définies par l'application associées à la libération ou à la redéfinition des ressources non managées.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodImport" />
    <member name="P:System.Reflection.Metadata.MethodImport.Attributes" />
    <member name="P:System.Reflection.Metadata.MethodImport.Module" />
    <member name="P:System.Reflection.Metadata.MethodImport.Name" />
    <member name="T:System.Reflection.Metadata.MethodSignature`1">
      <summary>Représente une méthode (définition, référence ou autonome) ou une signature de propriété. Dans le cas des propriétés, la signature correspond à celle d’un accesseur Get avec un <see cref="T:System.Reflection.Metadata.SignatureHeader" /> de distinction.</summary>
      <typeparam name="TType">Type de la méthode.</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.MethodSignature`1.#ctor(System.Reflection.Metadata.SignatureHeader,`0,System.Int32,System.Int32,System.Collections.Immutable.ImmutableArray{`0})">
      <summary>Initialise une nouvelle instance de la structure <see cref="T:System.Reflection.Metadata.MethodSignature`1" /> avec l’en-tête, le type de retour et les informations de paramètres spécifiés.</summary>
      <param name="header">Informations contenues dans l’octet de tête de la signature (genre, convention d’appel, indicateurs).</param>
      <param name="returnType">Type de retour de la méthode.</param>
      <param name="requiredParameterCount">Nombre de paramètres requis.</param>
      <param name="genericParameterCount">Nombre de paramètres de type générique.</param>
      <param name="parameterTypes">Types de paramètres.</param>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.GenericParameterCount">
      <summary>Obtient le nombre de paramètres de type générique pour la méthode.</summary>
      <returns>Nombre de paramètres de type générique, ou 0 pour les méthodes non génériques.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.Header">
      <summary>Obtient les informations contenues dans l’octet de tête de la signature (genre, convention d’appel, indicateurs).</summary>
      <returns>Signature d’en-tête.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.ParameterTypes">
      <summary>Obtient les types de paramètres de la méthode.</summary>
      <returns>Collection immuable de types de paramètres.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.RequiredParameterCount">
      <summary>Obtient le nombre de paramètres requis pour la méthode.</summary>
      <returns>Nombre de paramètres requis.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.ReturnType">
      <summary>Obtient le type de retour de la méthode.</summary>
      <returns>Type de retour.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodSpecification" />
    <member name="M:System.Reflection.Metadata.MethodSpecification.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecification.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.MethodSpecification.Method">
      <summary>Obtient un handle <see langword="MethodDef" /> ou <see langword="MemberRef" /> spécifiant à quelle méthode générique cette instance fait référence (autrement dit, la méthode générique dont qu’il est une instanciation).</summary>
      <returns>
        <see langword="MethodDef" />Handle ou <see langword="MemberRef" /> spécifiant la méthode générique à laquelle cette instance fait référence.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSpecification.Signature">
      <summary>Obtient un handle vers l’objet blob de signature.</summary>
      <returns>Handle de l’objet blob de signature.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodSpecificationHandle" />
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.Equals(System.Reflection.Metadata.MethodSpecificationHandle)">
      <summary>Indique si l'objet actuel est égal à un autre objet du même type.</summary>
      <param name="other">Objet à comparer à cet objet.</param>
      <returns>
        <see langword="true" /> si l'objet actuel est égal au paramètre <paramref name="other" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Equality(System.Reflection.Metadata.MethodSpecificationHandle,System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodSpecificationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodSpecificationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Implicit(System.Reflection.Metadata.MethodSpecificationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Implicit(System.Reflection.Metadata.MethodSpecificationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Inequality(System.Reflection.Metadata.MethodSpecificationHandle,System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.MethodSpecificationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ModuleDefinition" />
    <member name="M:System.Reflection.Metadata.ModuleDefinition.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.BaseGenerationId" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.Generation" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.GenerationId" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.Mvid" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.Name" />
    <member name="T:System.Reflection.Metadata.ModuleDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.Equals(System.Reflection.Metadata.ModuleDefinitionHandle)">
      <summary>Indique si l'objet actuel est égal à un autre objet du même type.</summary>
      <param name="other">Objet à comparer à cet objet.</param>
      <returns>
        <see langword="true" /> si l'objet actuel est égal au paramètre <paramref name="other" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Equality(System.Reflection.Metadata.ModuleDefinitionHandle,System.Reflection.Metadata.ModuleDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ModuleDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ModuleDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Implicit(System.Reflection.Metadata.ModuleDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Implicit(System.Reflection.Metadata.ModuleDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Inequality(System.Reflection.Metadata.ModuleDefinitionHandle,System.Reflection.Metadata.ModuleDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.ModuleDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ModuleReference" />
    <member name="M:System.Reflection.Metadata.ModuleReference.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ModuleReference.Name" />
    <member name="T:System.Reflection.Metadata.ModuleReferenceHandle" />
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.Equals(System.Reflection.Metadata.ModuleReferenceHandle)">
      <summary>Indique si l'objet actuel est égal à un autre objet du même type.</summary>
      <param name="other">Objet à comparer à cet objet.</param>
      <returns>
        <see langword="true" /> si l'objet actuel est égal au paramètre <paramref name="other" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Equality(System.Reflection.Metadata.ModuleReferenceHandle,System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ModuleReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ModuleReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Implicit(System.Reflection.Metadata.ModuleReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Implicit(System.Reflection.Metadata.ModuleReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Inequality(System.Reflection.Metadata.ModuleReferenceHandle,System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.ModuleReferenceHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.NamespaceDefinition" />
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.ExportedTypes">
      <summary>Obtient tous les types exportés qui résident directement dans un espace de noms.</summary>
      <returns>Tableau immuable de handles de type exportés.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.Name">
      <summary>Obtient le nom non qualifié de la définition de l’espace de noms.</summary>
      <returns>Nom non qualifié de la définition de l’espace de noms.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.NamespaceDefinitions">
      <summary>Obtient les définitions d’espace de noms qui sont des enfants directs de la définition de l’espace de noms actuel.</summary>
      <returns>Tableau immuable de définitions d’espaces de noms qui sont des enfants directs de la définition d’espace de noms actuelle.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.Parent">
      <summary>Obtient l’espace de noms parent.</summary>
      <returns>Espace de noms parent.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.TypeDefinitions">
      <summary>Obtient toutes les définitions de type qui résident directement dans un espace de noms.</summary>
      <returns>Tableau immuable de handles de définition de type.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.NamespaceDefinitionHandle">
      <summary>Fournit un descripteur à une définition d’espace de noms.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.Equals(System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <summary>Indique si l'objet actuel est égal à un autre objet du même type.</summary>
      <param name="other">Objet à comparer à cet objet.</param>
      <returns>
        <see langword="true" /> si l'objet actuel est égal au paramètre <paramref name="other" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Equality(System.Reflection.Metadata.NamespaceDefinitionHandle,System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.NamespaceDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Implicit(System.Reflection.Metadata.NamespaceDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Inequality(System.Reflection.Metadata.NamespaceDefinitionHandle,System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.Parameter" />
    <member name="M:System.Reflection.Metadata.Parameter.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.Parameter.GetDefaultValue" />
    <member name="M:System.Reflection.Metadata.Parameter.GetMarshallingDescriptor" />
    <member name="P:System.Reflection.Metadata.Parameter.Attributes" />
    <member name="P:System.Reflection.Metadata.Parameter.Name" />
    <member name="P:System.Reflection.Metadata.Parameter.SequenceNumber" />
    <member name="T:System.Reflection.Metadata.ParameterHandle" />
    <member name="M:System.Reflection.Metadata.ParameterHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.Equals(System.Reflection.Metadata.ParameterHandle)">
      <summary>Indique si l'objet actuel est égal à un autre objet du même type.</summary>
      <param name="other">Objet à comparer à cet objet.</param>
      <returns>
        <see langword="true" /> si l'objet actuel est égal au paramètre <paramref name="other" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Equality(System.Reflection.Metadata.ParameterHandle,System.Reflection.Metadata.ParameterHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ParameterHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ParameterHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Implicit(System.Reflection.Metadata.ParameterHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Implicit(System.Reflection.Metadata.ParameterHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Inequality(System.Reflection.Metadata.ParameterHandle,System.Reflection.Metadata.ParameterHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.ParameterHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ParameterHandleCollection">
      <summary>Contient une collection de paramètres d’une méthode spécifiée.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ParameterHandle}#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein de la collection.</summary>
      <returns>Énumérateur permettant d'effectuer une itération au sein de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein d’une collection.</summary>
      <returns>Objet <see cref="T:System.Collections.IEnumerator" /> pouvant être utilisé pour itérer au sein de la collection.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ParameterHandleCollection.Count">
      <summary>Obtient le nombre d’éléments de la collection.</summary>
      <returns>Nombre d'éléments dans la collection.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ParameterHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.MoveNext">
      <summary>Avance l’énumérateur à l’élément suivant de la collection.</summary>
      <returns>
        <see langword="true" /> si l'énumérateur a pu avancer jusqu'à l'élément suivant ; <see langword="false" /> si l'énumérateur a dépassé la fin de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Rétablit l'énumérateur à sa position initiale, qui précède le premier élément de la collection.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Exécute les tâches définies par l'application associées à la libération ou à la redéfinition des ressources non managées.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.PEReaderExtensions" />
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader)">
      <summary>Obtient un <see cref="T:System.Reflection.Metadata.MetadataReader" /> d'un <see cref="T:System.Reflection.PortableExecutable.PEReader" /></summary>
      <param name="peReader">Instance actuelle de <see cref="T:System.Reflection.PortableExecutable.PEReader" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peReader" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.PlatformNotSupportedException">La plateforme actuelle est avec primauté des octets de poids fort (big-endian).</exception>
      <exception cref="T:System.IO.IOException">Erreur d’E/S lors de la lecture à partir du flux sous-jacent.</exception>
      <returns>Lecteur de métadonnées.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader,System.Reflection.Metadata.MetadataReaderOptions)">
      <summary>Obtient un lecteur de métadonnées ayant la configuration de lecture des métadonnées spécifiée à partir d’un <see cref="T:System.Reflection.PortableExecutable.PEReader" />.</summary>
      <param name="peReader">Instance actuelle de <see cref="T:System.Reflection.PortableExecutable.PEReader" />.</param>
      <param name="options">Valeur d’énumération qui indique la configuration de lecture des métadonnées.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peReader" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.PlatformNotSupportedException">La plateforme actuelle est avec primauté des octets de poids fort (big-endian).</exception>
      <exception cref="T:System.IO.IOException">Erreur d’E/S lors de la lecture à partir du flux sous-jacent.</exception>
      <returns>Lecteur de métadonnées ayant la configuration de lecture des métadonnées spécifiée.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader,System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)">
      <summary>Obtient un lecteur de métadonnées ayant la configuration de lecture des métadonnées et la configuration d’encodage spécifiées à partir d’un <see cref="T:System.Reflection.PortableExecutable.PEReader" />.</summary>
      <param name="peReader">Instance actuelle de <see cref="T:System.Reflection.PortableExecutable.PEReader" />.</param>
      <param name="options">Valeur d’énumération qui indique la configuration de lecture des métadonnées.</param>
      <param name="utf8Decoder">Décodeur de chaîne de métadonnées ayant la configuration d’encodage.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peReader" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">L’encodage de <paramref name="utf8Decoder" /> n’est pas <see cref="T:System.Text.UTF8Encoding" />.</exception>
      <exception cref="T:System.PlatformNotSupportedException">La plateforme actuelle est avec primauté des octets de poids fort (big-endian).</exception>
      <exception cref="T:System.IO.IOException">Erreur d’E/S lors de la lecture à partir du flux sous-jacent.</exception>
      <returns>&gt;Lecteur de métadonnées ayant la configuration de lecture des métadonnées et la configuration d’encodage spécifiées.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMethodBody(System.Reflection.PortableExecutable.PEReader,System.Int32)">
      <summary>Retourne un corps de bloc de méthode avec l’adresse virtuelle relative (RVA) spécifiée.</summary>
      <param name="peReader">Instance actuelle de <see cref="T:System.Reflection.PortableExecutable.PEReader" />.</param>
      <param name="relativeVirtualAddress">Adresse virtuelle relative (RVA).</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peReader" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.BadImageFormatException">Le corps est introuvable dans les métadonnées ou n’est pas valide.</exception>
      <exception cref="T:System.InvalidOperationException">La section où se trouve la méthode n’est pas disponible.</exception>
      <exception cref="T:System.IO.IOException">Erreur d’E/S survenue lors de la lecture à partir du flux sous-jacent.</exception>
      <returns>Instance de corps de bloc d’une méthode.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.PrimitiveSerializationTypeCode">
      <summary>Spécifie les constantes qui définissent les codes de type utilisés pour encoder les types de valeurs primitives dans un objet blob de valeur <see cref="T:System.Reflection.Metadata.CustomAttribute" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Boolean">
      <summary>Type <see cref="T:System.Boolean" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Byte">
      <summary>Type entier non signé sur 1 octet.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Char">
      <summary>Type <see cref="T:System.Char" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Double">
      <summary>Type à virgule flottante sur 8 octets.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Int16">
      <summary>Type entier signé sur 2 octets.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Int32">
      <summary>Type entier signé sur 4 octets.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Int64">
      <summary>Type entier signé sur 8 octets.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.SByte">
      <summary>Type entier signé sur 1 octet.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Single">
      <summary>Type à virgule flottante sur 4 octets.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.String">
      <summary>Type <see cref="T:System.String" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.UInt16">
      <summary>Type entier non signé sur 2 octets.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.UInt32">
      <summary>Type entier non signé sur 4 octets.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.UInt64">
      <summary>Type entier non signé sur 8 octets.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.PrimitiveTypeCode">
      <summary>Spécifie des constantes qui définissent les types primitifs trouvés dans les signatures de métadonnées.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Boolean">
      <summary>Type <see cref="T:System.Boolean" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Byte">
      <summary>Type <see cref="T:System.Byte" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Char">
      <summary>Type <see cref="T:System.Char" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Double">
      <summary>Type <see cref="T:System.Double" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Int16">
      <summary>Type <see cref="T:System.Int16" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Int32">
      <summary>Type <see cref="T:System.Int32" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Int64">
      <summary>Type <see cref="T:System.Int64" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.IntPtr">
      <summary>Type <see cref="T:System.IntPtr" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Object">
      <summary>Type <see cref="T:System.Object" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.SByte">
      <summary>Type <see cref="T:System.SByte" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Single">
      <summary>Type <see cref="T:System.Single" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.String">
      <summary>Type <see cref="T:System.String" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.TypedReference">
      <summary>Référence typée.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UInt16">
      <summary>Type <see cref="T:System.UInt16" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UInt32">
      <summary>Type <see cref="T:System.UInt32" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UInt64">
      <summary>Type <see cref="T:System.UInt64" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UIntPtr">
      <summary>Type <see cref="T:System.UIntPtr" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Void">
      <summary>Type <see cref="T:System.Void" />.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.PropertyAccessors" />
    <member name="P:System.Reflection.Metadata.PropertyAccessors.Getter" />
    <member name="P:System.Reflection.Metadata.PropertyAccessors.Others" />
    <member name="P:System.Reflection.Metadata.PropertyAccessors.Setter" />
    <member name="T:System.Reflection.Metadata.PropertyDefinition" />
    <member name="M:System.Reflection.Metadata.PropertyDefinition.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinition.GetAccessors" />
    <member name="M:System.Reflection.Metadata.PropertyDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.PropertyDefinition.GetDefaultValue" />
    <member name="P:System.Reflection.Metadata.PropertyDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.PropertyDefinition.Name" />
    <member name="P:System.Reflection.Metadata.PropertyDefinition.Signature" />
    <member name="T:System.Reflection.Metadata.PropertyDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.Equals(System.Reflection.Metadata.PropertyDefinitionHandle)">
      <summary>Indique si l'objet actuel est égal à un autre objet du même type.</summary>
      <param name="other">Objet à comparer à cet objet.</param>
      <returns>
        <see langword="true" /> si l'objet actuel est égal au paramètre <paramref name="other" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Equality(System.Reflection.Metadata.PropertyDefinitionHandle,System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.PropertyDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.PropertyDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Implicit(System.Reflection.Metadata.PropertyDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Implicit(System.Reflection.Metadata.PropertyDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Inequality(System.Reflection.Metadata.PropertyDefinitionHandle,System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.PropertyDefinitionHandleCollection" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#PropertyDefinitionHandle}#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein de la collection.</summary>
      <returns>Énumérateur permettant d'effectuer une itération au sein de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein d’une collection.</summary>
      <returns>Objet <see cref="T:System.Collections.IEnumerator" /> pouvant être utilisé pour itérer au sein de la collection.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Count">
      <summary>Obtient le nombre d’éléments de la collection.</summary>
      <returns>Nombre d'éléments dans la collection.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.MoveNext">
      <summary>Avance l’énumérateur à l’élément suivant de la collection.</summary>
      <returns>
        <see langword="true" /> si l'énumérateur a pu avancer jusqu'à l'élément suivant ; <see langword="false" /> si l'énumérateur a dépassé la fin de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Rétablit l'énumérateur à sa position initiale, qui précède le premier élément de la collection.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Exécute les tâches définies par l'application associées à la libération ou à la redéfinition des ressources non managées.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ReservedBlob`1">
      <summary>Représente un descripteur et un objet blob correspondant sur un tas de métadonnées réservé pour une future mise à jour de contenu.</summary>
      <typeparam name="THandle" />
    </member>
    <member name="M:System.Reflection.Metadata.ReservedBlob`1.CreateWriter">
      <summary>Retourne un <see cref="T:System.Reflection.Metadata.BlobWriter" /> à utiliser pour mettre à jour le contenu.</summary>
      <returns>Enregistreur d’objet blob à utiliser pour mettre à jour le contenu.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ReservedBlob`1.Content" />
    <member name="P:System.Reflection.Metadata.ReservedBlob`1.Handle">
      <summary>Obtient le handle d’objet blob réservé.</summary>
      <returns>Handle mpêcher réservé.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.SequencePoint" />
    <member name="F:System.Reflection.Metadata.SequencePoint.HiddenLine" />
    <member name="M:System.Reflection.Metadata.SequencePoint.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.SequencePoint.Equals(System.Reflection.Metadata.SequencePoint)">
      <summary>Indique si l'objet actuel est égal à un autre objet du même type.</summary>
      <param name="other">Objet à comparer à cet objet.</param>
      <returns>
        <see langword="true" /> si l'objet actuel est égal au paramètre <paramref name="other" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SequencePoint.GetHashCode" />
    <member name="P:System.Reflection.Metadata.SequencePoint.Document" />
    <member name="P:System.Reflection.Metadata.SequencePoint.EndColumn" />
    <member name="P:System.Reflection.Metadata.SequencePoint.EndLine" />
    <member name="P:System.Reflection.Metadata.SequencePoint.IsHidden" />
    <member name="P:System.Reflection.Metadata.SequencePoint.Offset" />
    <member name="P:System.Reflection.Metadata.SequencePoint.StartColumn" />
    <member name="P:System.Reflection.Metadata.SequencePoint.StartLine" />
    <member name="T:System.Reflection.Metadata.SequencePointCollection" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#SequencePoint}#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein de la collection.</summary>
      <returns>Énumérateur permettant d'effectuer une itération au sein de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SequencePointCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein d’une collection.</summary>
      <returns>Objet <see cref="T:System.Collections.IEnumerator" /> pouvant être utilisé pour itérer au sein de la collection.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.SequencePointCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.Enumerator.MoveNext">
      <summary>Avance l’énumérateur à l’élément suivant de la collection.</summary>
      <returns>
        <see langword="true" /> si l'énumérateur a pu avancer jusqu'à l'élément suivant ; <see langword="false" /> si l'énumérateur a dépassé la fin de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SequencePointCollection.Enumerator.Reset">
      <summary>Rétablit l'énumérateur à sa position initiale, qui précède le premier élément de la collection.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.SequencePointCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Exécute les tâches définies par l'application associées à la libération ou à la redéfinition des ressources non managées.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.SequencePointCollection.Enumerator.Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SequencePointCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.SerializationTypeCode">
      <summary>Spécifie des codes de type utilisés pour encoder les types de valeurs dans un objet blob <see cref="T:System.Reflection.Metadata.CustomAttributeValue`1" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Boolean">
      <summary>Valeur équivalente à <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Boolean" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Byte">
      <summary>Valeur équivalente à <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Byte" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Char">
      <summary>Valeur équivalente à <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Char" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Double">
      <summary>Valeur équivalente à <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Double" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Enum">
      <summary>L’argument d’attribut est une instance d’Enum.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int16">
      <summary>Valeur équivalente à <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int16" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int32">
      <summary>Valeur équivalente à <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int32" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int64">
      <summary>Valeur équivalente à <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int64" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Invalid">
      <summary>Valeur équivalente à <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Invalid" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.SByte">
      <summary>Valeur équivalente à <see cref="F:System.Reflection.Metadata.SignatureTypeCode.SByte" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Single">
      <summary>Valeur équivalente à <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Single" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.String">
      <summary>Valeur équivalente à <see cref="F:System.Reflection.Metadata.SignatureTypeCode.String" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.SZArray">
      <summary>Valeur équivalente à <see cref="F:System.Reflection.Metadata.SignatureTypeCode.SZArray" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.TaggedObject">
      <summary>L’argument d’attribut est « boxed » (passé à un paramètre, un champ ou une propriété de type object) et il contient les informations de type dans l’objet blob d’attribut.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Type">
      <summary>L’argument d’attribut est une instance de <see cref="T:System.Type" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt16">
      <summary>Valeur équivalente à <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt16" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt32">
      <summary>Valeur équivalente à <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt32" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt64">
      <summary>Valeur équivalente à <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt64" />.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureAttributes">
      <summary>Spécifie des indicateurs supplémentaires qui peuvent être appliqués à des signatures de méthodes. Les valeurs sous-jacentes des champs de ce type correspondent à la représentation dans l’octet de signature de tête représenté par une structure <see cref="T:System.Reflection.Metadata.SignatureHeader" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis">
      <summary>Indique le premier paramètre déclaré explicitement qui représente le pointeur d’instance.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.Generic">
      <summary>Méthode générique.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.Instance">
      <summary>Méthode d’instance.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.None">
      <summary>Aucun indicateur.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureCallingConvention">
      <summary>Spécifie comment les arguments dans une signature donnée sont transmis de l’appelant vers l’appelé. Les valeurs sous-jacentes des champs de ce type correspondent à la représentation dans l’octet de signature de tête représenté par une structure <see cref="T:System.Reflection.Metadata.SignatureHeader" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.CDecl">
      <summary>Convention d’appel de style C/C++ non managée, où la pile des appels est nettoyée par l’appelant.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.Default">
      <summary>Convention d’appel managée avec une liste d’arguments de longueur fixe.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.FastCall">
      <summary>Convention d’appel non managée, où les arguments sont passés dans des registres quand cela est possible.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.StdCall">
      <summary>Convention d’appel non managée, où la pile des appels est nettoyée par l’appelé.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.ThisCall">
      <summary>Convention d’appel de style C++ non managée pour l’appel de fonctions membres de l’instance appelante avec une liste d’arguments fixe.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.Unmanaged">
      <summary>Indique que les spécificités de la convention d’appel non managée sont encodées en tant que modopts.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.VarArgs">
      <summary>Convention d’appel managée pour passer des arguments supplémentaires.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureHeader">
      <summary>Représente les caractéristiques de signature spécifiées par l’octet de tête d’objets blob de signature.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureHeader.CallingConventionOrKindMask">
      <summary>Obtient la valeur du masque pour le genre de signature ou la convention d’appel. La valeur par défaut de <see cref="F:System.Reflection.Metadata.SignatureHeader.CallingConventionOrKindMask" /> est 15 (0x0F).</summary>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.#ctor(System.Byte)">
      <summary>Initialise une nouvelle instance de la structure <see cref="T:System.Reflection.Metadata.SignatureHeader" /> à l'aide de la valeur d'octet spécifiée.</summary>
      <param name="rawValue">Octet.</param>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.#ctor(System.Reflection.Metadata.SignatureKind,System.Reflection.Metadata.SignatureCallingConvention,System.Reflection.Metadata.SignatureAttributes)">
      <summary>Initialise une nouvelle instance de la structure <see cref="T:System.Reflection.Metadata.SignatureHeader" /> à l’aide du genre de signature, de la convention d’appel et des attributs de signature spécifiés.</summary>
      <param name="kind">Genre de signature.</param>
      <param name="convention">Convention d’appel.</param>
      <param name="attributes">Attributs de la signature.</param>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.Equals(System.Object)">
      <summary>Compare l’égalité entre l’objet spécifié et ce <see cref="T:System.Reflection.Metadata.SignatureHeader" />.</summary>
      <param name="obj">Objet à comparer.</param>
      <returns>
        <see langword="true" /> si les objets sont égaux ; sinon <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.Equals(System.Reflection.Metadata.SignatureHeader)">
      <summary>Compare si deux valeurs <see cref="T:System.Reflection.Metadata.SignatureHeader" /> sont égales.</summary>
      <param name="other">Valeur à comparer.</param>
      <returns>
        <see langword="true" /> si les valeurs sont égales ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.GetHashCode">
      <summary>Obtient un code de hachage pour l’objet actuel.</summary>
      <returns>Code de hachage pour l'objet actuel.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.op_Equality(System.Reflection.Metadata.SignatureHeader,System.Reflection.Metadata.SignatureHeader)">
      <summary>Compare si deux valeurs <see cref="T:System.Reflection.Metadata.SignatureHeader" /> sont égales.</summary>
      <param name="left">Première valeur à comparer.</param>
      <param name="right">Deuxième valeur à comparer.</param>
      <returns>
        <see langword="true" /> si les valeurs sont égales ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.op_Inequality(System.Reflection.Metadata.SignatureHeader,System.Reflection.Metadata.SignatureHeader)">
      <summary>Détermine si deux valeurs <see cref="T:System.Reflection.Metadata.SignatureHeader" /> sont inégales.</summary>
      <param name="left">Première valeur à comparer.</param>
      <param name="right">Deuxième valeur à comparer.</param>
      <returns>
        <see langword="true" /> si les valeurs sont inégales ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.ToString">
      <summary>Retourne une chaîne qui représente l'objet actuel.</summary>
      <returns>Chaîne qui représente l'objet actuel.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.Attributes">
      <summary>Obtient les attributs de signature.</summary>
      <returns>Attributs.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.CallingConvention">
      <summary>Obtient la convention d’appel.</summary>
      <returns>Convention d’appel.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.HasExplicitThis">
      <summary>Obtient une valeur qui indique si cette structure <see cref="T:System.Reflection.Metadata.SignatureHeader" /> a l’attribut de signature <see cref="F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis" />.</summary>
      <returns>
        <see langword="true" /> Si l' <see cref="F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis" /> attribut est présent ; sinon, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.IsGeneric">
      <summary>Obtient une valeur qui indique si cette structure <see cref="T:System.Reflection.Metadata.SignatureHeader" /> a l’attribut de signature <see cref="F:System.Reflection.Metadata.SignatureAttributes.Generic" />.</summary>
      <returns>
        <see langword="true" /> Si l' <see cref="F:System.Reflection.Metadata.SignatureAttributes.Generic" /> attribut est présent ; sinon, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.IsInstance">
      <summary>Obtient une valeur qui indique si cette structure <see cref="T:System.Reflection.Metadata.SignatureHeader" /> a l’attribut de signature <see cref="F:System.Reflection.Metadata.SignatureAttributes.Instance" />.</summary>
      <returns>
        <see langword="true" /> Si l' <see cref="F:System.Reflection.Metadata.SignatureAttributes.Instance" /> attribut est présent ; sinon, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.Kind">
      <summary>Obtient le genre de signature.</summary>
      <returns>Genre de signature.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.RawValue">
      <summary>Obtient la valeur brute de l’octet d’en-tête.</summary>
      <returns>Valeur brute de l’octet d’en-tête.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureKind">
      <summary>Spécifie le genre de signature. Les valeurs sous-jacentes des champs de ce type correspondent à la représentation dans l’octet de signature de tête représenté par une structure <see cref="T:System.Reflection.Metadata.SignatureHeader" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.Field">
      <summary>Signature de champ.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.LocalVariables">
      <summary>Signature de variables locales.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.Method">
      <summary>Référence de méthode, définition de méthode ou signature de méthode autonome.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.MethodSpecification">
      <summary>Signature de spécification de méthode.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.Property">
      <summary>Signature de propriété.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureTypeCode">
      <summary>Spécifie des constantes qui définissent des codes de type utilisés dans l’encodage de la signature.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Array">
      <summary>Représente un <see cref="T:System.Array" /> généralisé dans des signatures.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Boolean">
      <summary>Représente un <see cref="T:System.Boolean" /> dans des signatures.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.ByReference">
      <summary>Représente des pointeurs managés (valeurs de retour et paramètres byref) dans des signatures. Il est suivi dans l’objet blob par l’encodage de signature du type sous-jacent.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Byte">
      <summary>Représente un <see cref="T:System.Byte" /> dans des signatures.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Char">
      <summary>Représente un <see cref="T:System.Char" /> dans des signatures.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Double">
      <summary>Représente un <see cref="T:System.Double" /> dans des signatures.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.FunctionPointer">
      <summary>Représente des types de pointeurs de fonctions dans des signatures.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericMethodParameter">
      <summary>Représente un paramètre de méthode générique utilisé dans une signature.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericTypeInstance">
      <summary>Représente l’instanciation d’un type générique dans des signatures.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericTypeParameter">
      <summary>Représente un paramètre de type générique utilisé dans une signature.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int16">
      <summary>Représente un <see cref="T:System.Int16" /> dans des signatures.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int32">
      <summary>Représente un <see cref="T:System.Int32" /> dans des signatures.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int64">
      <summary>Représente un <see cref="T:System.Int64" /> dans des signatures.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.IntPtr">
      <summary>Représente un <see cref="T:System.IntPtr" /> dans des signatures.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Invalid">
      <summary>Représente un code de type non valide ou non initialisé. Il n’apparaîtra pas dans les signatures valides.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Object">
      <summary>Représente un <see cref="T:System.Object" /> dans des signatures.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.OptionalModifier">
      <summary>Représente un modificateur personnalisé appliqué à un type dans une signature que l’appelant peut ignorer.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Pinned">
      <summary>Représente une variable locale épinglée par le garbage collector.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Pointer">
      <summary>Représente un pointeur non managé dans des signatures. Il est suivi dans l’objet blob par l’encodage de signature du type sous-jacent.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.RequiredModifier">
      <summary>Représente un modificateur personnalisé appliqué à un type dans une signature que l’appelant doit comprendre.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.SByte">
      <summary>Représente un <see cref="T:System.SByte" /> dans des signatures.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Sentinel">
      <summary>Représente un marqueur pour indiquer la fin des arguments fixes et le début des arguments variables.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Single">
      <summary>Représente un <see cref="T:System.Single" /> dans des signatures.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.String">
      <summary>Représente un <see cref="T:System.String" /> dans des signatures.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.SZArray">
      <summary>Représente un <see cref="T:System.Array" /> à une seule dimension avec une limite inférieure égale à zéro.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.TypedReference">
      <summary>Représente une référence typée dans des signatures.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.TypeHandle">
      <summary>Précède un type <see cref="T:System.Reflection.Metadata.EntityHandle" /> dans des signatures. Dans les métadonnées brutes, est encodé comme ELEMENT_TYPE_CLASS (0x12) pour les types référence ou comme ELEMENT_TYPE_VALUETYPE (0x11) pour les types valeur. Cela se réduit à un code unique, car les projections Windows Runtime peuvent projeter de la classe vers le type valeur ou vice versa. Dans ce cas, le code brut est alors trompeur.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt16">
      <summary>Représente un <see cref="T:System.UInt16" /> dans des signatures.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt32">
      <summary>Représente un <see cref="T:System.UInt32" /> dans des signatures.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt64">
      <summary>Représente un <see cref="T:System.UInt64" /> dans des signatures.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UIntPtr">
      <summary>Représente un <see cref="T:System.UIntPtr" /> dans des signatures.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Void">
      <summary>Représente <see cref="T:System.Void" /> dans des signatures.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureTypeKind">
      <summary>Indique la définition de type de la signature.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeKind.Class">
      <summary>La définition ou référence de type fait référence à une classe.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeKind.Unknown">
      <summary>On ignore dans le contexte actuel si la définition ou la référence de type est un type valeur ou classe.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeKind.ValueType">
      <summary>La définition ou référence de type fait référence à un type valeur.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.StandaloneSignature" />
    <member name="M:System.Reflection.Metadata.StandaloneSignature.DecodeLocalSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignature.DecodeMethodSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignature.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.StandaloneSignature.GetKind">
      <summary>Détermine le type de signature, qui peut être <see cref="F:System.Reflection.Metadata.SignatureKind.Method" /> ou <see cref="F:System.Reflection.Metadata.SignatureKind.LocalVariables" />.</summary>
      <exception cref="T:System.BadImageFormatException">La signature n’est pas valide.</exception>
      <returns>Valeur d’énumération qui indique le type de signature.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.StandaloneSignature.Signature">
      <summary>Obtient un handle vers l’objet blob de signature.</summary>
      <returns>Handle de l’objet blob de signature.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.StandaloneSignatureHandle" />
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.Equals(System.Reflection.Metadata.StandaloneSignatureHandle)">
      <summary>Indique si l'objet actuel est égal à un autre objet du même type.</summary>
      <param name="other">Objet à comparer à cet objet.</param>
      <returns>
        <see langword="true" /> si l'objet actuel est égal au paramètre <paramref name="other" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Equality(System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.StandaloneSignatureHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.StandaloneSignatureHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Implicit(System.Reflection.Metadata.StandaloneSignatureHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Implicit(System.Reflection.Metadata.StandaloneSignatureHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Inequality(System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.StandaloneSignatureHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.StandaloneSignatureKind">
      <summary>Indique si un <see cref="T:System.Reflection.Metadata.StandaloneSignature" /> représente une signature de méthode autonome ou de variable locale.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.StandaloneSignatureKind.LocalVariables">
      <summary>Le <see cref="T:System.Reflection.Metadata.MemberReference" /> référence une signature de variable locale.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.StandaloneSignatureKind.Method">
      <summary>Le <see cref="T:System.Reflection.Metadata.StandaloneSignature" /> représente une signature de méthode autonome.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.StringHandle" />
    <member name="M:System.Reflection.Metadata.StringHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.Equals(System.Reflection.Metadata.StringHandle)">
      <summary>Indique si l'objet actuel est égal à un autre objet du même type.</summary>
      <param name="other">Objet à comparer à cet objet.</param>
      <returns>
        <see langword="true" /> si l'objet actuel est égal au paramètre <paramref name="other" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.StringHandle.op_Equality(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.StringHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.op_Implicit(System.Reflection.Metadata.StringHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.op_Inequality(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.StringHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.TypeDefinition" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetDeclarativeSecurityAttributes" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetDeclaringType">
      <summary>Retourne le type englobant d’un type imbriqué spécifié.</summary>
      <returns>Type englobant du type imbriqué spécifié, ou un handle dont la propriété <see cref="P:System.Reflection.Metadata.TypeDefinitionHandle.IsNil" /> a la valeur <see langword="true" /> si le type n’est pas imbriqué.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetEvents" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetFields" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetGenericParameters" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetInterfaceImplementations" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetLayout" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetMethodImplementations" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetMethods" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetNestedTypes">
      <summary>Retourne un tableau de types imbriqués dans le type spécifié.</summary>
      <returns>Tableau immuable de handles de définition de type qui représentent les types imbriqués dans le type spécifié.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetProperties" />
    <member name="P:System.Reflection.Metadata.TypeDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.TypeDefinition.BaseType">
      <summary>Obtient le type de base de la définition de type :<see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />.</summary>
      <returns>Type de base de la définition de type.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.IsNested">
      <summary>Obtient une valeur indiquant s’il s’agit d’un type imbriqué.</summary>
      <returns>
        <see langword="true" /> s’il s’agit d’un type imbriqué ; <see langword="false" /> sinon,.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.Name">
      <summary>Obtient le nom du type.</summary>
      <returns>Nom du type.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.Namespace">
      <summary>Obtient le nom complet de l’espace de noms où le type est défini.</summary>
      <returns>Nom complet de l’espace de noms dans lequel le type est défini, ou handle dont la <see cref="P:System.Reflection.Metadata.StringHandle.IsNil" /> propriété a la propriété <see langword="true" /> si le type est imbriqué ou défini dans un espace de noms racine.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.NamespaceDefinition">
      <summary>Obtient le handle de définition de l’espace de noms où le type est défini.</summary>
      <returns>Le handle de définition de l’espace de noms où le type est défini, ou un handle dont <see cref="P:System.Reflection.Metadata.NamespaceDefinitionHandle.IsNil" /> la propriété a la propriété <see langword="true" />  si le type est imbriqué ou défini dans un espace de noms racine.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.Equals(System.Reflection.Metadata.TypeDefinitionHandle)">
      <summary>Indique si l'objet actuel est égal à un autre objet du même type.</summary>
      <param name="other">Objet à comparer à cet objet.</param>
      <returns>
        <see langword="true" /> si l'objet actuel est égal au paramètre <paramref name="other" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Equality(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.TypeDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.TypeDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Implicit(System.Reflection.Metadata.TypeDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Implicit(System.Reflection.Metadata.TypeDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Inequality(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.TypeDefinitionHandleCollection">
      <summary>Contient une collection d'instances <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#TypeDefinitionHandle}#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein de la collection.</summary>
      <returns>Énumérateur permettant d'effectuer une itération au sein de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein d’une collection.</summary>
      <returns>Objet <see cref="T:System.Collections.IEnumerator" /> pouvant être utilisé pour itérer au sein de la collection.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandleCollection.Count">
      <summary>Obtient le nombre d’éléments de la collection.</summary>
      <returns>Nombre d'éléments dans la collection.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.MoveNext">
      <summary>Avance l’énumérateur à l’élément suivant de la collection.</summary>
      <returns>
        <see langword="true" /> si l'énumérateur a pu avancer jusqu'à l'élément suivant ; <see langword="false" /> si l'énumérateur a dépassé la fin de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Rétablit l'énumérateur à sa position initiale, qui précède le premier élément de la collection.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Exécute les tâches définies par l'application associées à la libération ou à la redéfinition des ressources non managées.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeLayout" />
    <member name="M:System.Reflection.Metadata.TypeLayout.#ctor(System.Int32,System.Int32)">
      <param name="size" />
      <param name="packingSize" />
    </member>
    <member name="P:System.Reflection.Metadata.TypeLayout.IsDefault" />
    <member name="P:System.Reflection.Metadata.TypeLayout.PackingSize" />
    <member name="P:System.Reflection.Metadata.TypeLayout.Size" />
    <member name="T:System.Reflection.Metadata.TypeReference" />
    <member name="P:System.Reflection.Metadata.TypeReference.Name">
      <summary>Obtient le nom du type cible.</summary>
      <returns>Nom du type cible.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReference.Namespace">
      <summary>Obtient le nom complet de l’espace de noms où le type cible est défini.</summary>
      <returns>Nom complet de l’espace de noms dans lequel le type cible est défini ou un handle dont la <see cref="P:System.Reflection.Metadata.StringHandle.IsNil" /> propriété a la propriété <see langword="true" /> si le type est imbriqué ou défini dans un espace de noms racine.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReference.ResolutionScope">
      <summary>Obtient la résolution de portée dans laquelle le type cible est défini et est identifié de manière unique par les <see cref="P:System.Reflection.Metadata.TypeReference.Namespace" /> et <see cref="P:System.Reflection.Metadata.TypeReference.Name" /> spécifiés.</summary>
      <returns>Portée de résolution dans laquelle le type cible est défini de façon unique.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeReferenceHandle" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.Equals(System.Reflection.Metadata.TypeReferenceHandle)">
      <summary>Indique si l'objet actuel est égal à un autre objet du même type.</summary>
      <param name="other">Objet à comparer à cet objet.</param>
      <returns>
        <see langword="true" /> si l'objet actuel est égal au paramètre <paramref name="other" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Equality(System.Reflection.Metadata.TypeReferenceHandle,System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.TypeReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.TypeReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Implicit(System.Reflection.Metadata.TypeReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Implicit(System.Reflection.Metadata.TypeReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Inequality(System.Reflection.Metadata.TypeReferenceHandle,System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.TypeReferenceHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.TypeReferenceHandleCollection">
      <summary>Contient une collection d'instances <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#TypeReferenceHandle}#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein de la collection.</summary>
      <returns>Énumérateur permettant d'effectuer une itération au sein de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein d’une collection.</summary>
      <returns>Objet <see cref="T:System.Collections.IEnumerator" /> pouvant être utilisé pour itérer au sein de la collection.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReferenceHandleCollection.Count">
      <summary>Obtient le nombre d’éléments de la collection.</summary>
      <returns>Nombre d'éléments dans la collection.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.MoveNext">
      <summary>Avance l’énumérateur à l’élément suivant de la collection.</summary>
      <returns>
        <see langword="true" /> si l'énumérateur a pu avancer jusqu'à l'élément suivant ; <see langword="false" /> si l'énumérateur a dépassé la fin de la collection.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Rétablit l'énumérateur à sa position initiale, qui précède le premier élément de la collection.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Exécute les tâches définies par l'application associées à la libération ou à la redéfinition des ressources non managées.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtient l’élément de la collection situé à la position actuelle de l’énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeSpecification" />
    <member name="M:System.Reflection.Metadata.TypeSpecification.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecification.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.TypeSpecification.Signature" />
    <member name="T:System.Reflection.Metadata.TypeSpecificationHandle" />
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.Equals(System.Reflection.Metadata.TypeSpecificationHandle)">
      <summary>Indique si l'objet actuel est égal à un autre objet du même type.</summary>
      <param name="other">Objet à comparer à cet objet.</param>
      <returns>
        <see langword="true" /> si l'objet actuel est égal au paramètre <paramref name="other" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Equality(System.Reflection.Metadata.TypeSpecificationHandle,System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.TypeSpecificationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.TypeSpecificationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Implicit(System.Reflection.Metadata.TypeSpecificationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Implicit(System.Reflection.Metadata.TypeSpecificationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Inequality(System.Reflection.Metadata.TypeSpecificationHandle,System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.TypeSpecificationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.UserStringHandle">
      <summary>Représente un descripteur du tas de la chaîne utilisateur.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.Equals(System.Reflection.Metadata.UserStringHandle)">
      <summary>Indique si l'objet actuel est égal à un autre objet du même type.</summary>
      <param name="other">Objet à comparer à cet objet.</param>
      <returns>
        <see langword="true" /> si l'objet actuel est égal au paramètre <paramref name="other" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Equality(System.Reflection.Metadata.UserStringHandle,System.Reflection.Metadata.UserStringHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.UserStringHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Implicit(System.Reflection.Metadata.UserStringHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Inequality(System.Reflection.Metadata.UserStringHandle,System.Reflection.Metadata.UserStringHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.UserStringHandle.IsNil" />
    <member name="T:System.Reflection.MethodImportAttributes" />
    <member name="F:System.Reflection.MethodImportAttributes.BestFitMappingDisable" />
    <member name="F:System.Reflection.MethodImportAttributes.BestFitMappingEnable" />
    <member name="F:System.Reflection.MethodImportAttributes.BestFitMappingMask" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionCDecl" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionFastCall" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionMask" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionStdCall" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionThisCall" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionWinApi" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetAnsi" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetAuto" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetMask" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetUnicode" />
    <member name="F:System.Reflection.MethodImportAttributes.ExactSpelling" />
    <member name="F:System.Reflection.MethodImportAttributes.None" />
    <member name="F:System.Reflection.MethodImportAttributes.SetLastError" />
    <member name="F:System.Reflection.MethodImportAttributes.ThrowOnUnmappableCharDisable" />
    <member name="F:System.Reflection.MethodImportAttributes.ThrowOnUnmappableCharEnable" />
    <member name="F:System.Reflection.MethodImportAttributes.ThrowOnUnmappableCharMask" />
    <member name="T:System.Reflection.MethodSemanticsAttributes" />
    <member name="F:System.Reflection.MethodSemanticsAttributes.Adder">
      <summary>
        <para>Permet d’ajouter un gestionnaire à un événement. Correspond à l’indicateur <see langword="AddOn" /> dans la spécification de l’infrastructure CLI Ecma 335.</para>
        <para>Les adders conformes à CLS sont nommés avec le préfixe <see langword="add_" />.</para>
      </summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Getter">
      <summary>
        <para>Lit la valeur de la propriété.</para>
        <para>Les getters conformes à CLS sont nommés avec le préfixe get_.</para>
      </summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Other">
      <summary>Autre méthode pour une propriété (pas un getter ou setter) ou un événement (pas un adder, un remover ou un raiser).</summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Raiser">
      <summary>
        <para>Permet d’indiquer qu’un événement s’est produit. Correspond à l’indicateur <see langword="Fire" /> dans la spécification de l’infrastructure CLI Ecma 335.</para>
        <para> Les raisers conformes à CLS sont nommés avec le préfixe <see langword="raise_" />.</para>
      </summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Remover">
      <summary>
        <para>Permet de supprimer un gestionnaire d’un événement. Correspond à l’indicateur <see langword="RemoveOn" /> dans la spécification de l’infrastructure CLI Ecma 335.</para>
        <para>Les removers conformes à CLS sont nommés avec le préfixe <see langword="remove_" />.</para>
      </summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Setter">
      <summary>
        <para>Sert à modifier la valeur de la propriété.</para>
        <para>Les setters conformes à CLS sont nommés avec le préfixe <see langword="set_" />.</para>
      </summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.Characteristics" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.AggressiveWSTrim" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.Bit32Machine" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.BytesReversedHi" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.BytesReversedLo" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.DebugStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.Dll" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.ExecutableImage" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.LargeAddressAware" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.LineNumsStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.LocalSymsStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.NetRunFromSwap" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.RelocsStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.RemovableRunFromSwap" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.System" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.UpSystemOnly" />
    <member name="T:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData">
      <summary>Fournit des informations sur un fichier de base de données de débogage de programme (PDB).</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData.Age">
      <summary>Itération de la PDB. La première itération est 1. L’itération est incrémentée chaque fois que le contenu de la PDB est augmenté.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData.Guid">
      <summary>L'identificateur global unique (GUID, Global Unique Identifier) du PDB associé.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData.Path">
      <summary>Chemin d’accès au fichier .pdb qui contient les informations de débogage pour le fichier PE/COFF.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.CoffHeader">
      <summary>Représente l'en-tête d'un fichier COFF.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.Characteristics">
      <summary>Obtient les indicateurs qui indiquent les attributs du fichier.</summary>
      <returns>Indicateurs qui indiquent les attributs du fichier.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.Machine">
      <summary>Obtient le type de la machine cible.</summary>
      <returns>Type de l’ordinateur cible.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.NumberOfSections">
      <summary>Obtient le nombre de sections. Cela indique la taille de la table de la section, qui suit immédiatement les en-têtes.</summary>
      <returns>Nombre de sections.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.NumberOfSymbols">
      <summary>Obtient le nombre d'entrées dans la table de symboles. Ces données peuvent être utilisées pour localiser la table de chaînes, qui suit immédiatement la table de symboles. Cette valeur doit être égale à zéro pour une image PE.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.PointerToSymbolTable">
      <summary>Obtient le pointeur de fichier vers la table de symboles COFF.</summary>
      <returns>Pointeur de fichier vers la table de symboles COFF, ou zéro si aucune table de symboles COFF n’est présente. Cette valeur doit être égale à zéro pour une image PE.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.SizeOfOptionalHeader">
      <summary>Obtient la taille de l’en-tête facultatif, qui est requis pour les fichiers exécutables, mais pas pour les fichiers objets. Cette valeur doit être égale à zéro pour un fichier objet.</summary>
      <returns>Taille de l’en-tête facultatif.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.TimeDateStamp">
      <summary>Obtient une valeur qui indique quand le fichier a été créé.</summary>
      <returns>32 bits de poids faible du nombre de secondes 00:00 écoulées depuis le 1er janvier 1970, qui indique le moment où le fichier a été créé.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.CorFlags">
      <summary>COR20Flags</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.CorFlags.ILLibrary" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.ILOnly" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.NativeEntryPoint" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.Prefers32Bit" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.Requires32Bit" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.StrongNameSigned" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.TrackDebugData" />
    <member name="T:System.Reflection.PortableExecutable.CorHeader" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.CodeManagerTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.EntryPointTokenOrRelativeVirtualAddress" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.ExportAddressTableJumpsDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.Flags" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.MajorRuntimeVersion" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.ManagedNativeHeaderDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.MetadataDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.MinorRuntimeVersion" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.ResourcesDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.StrongNameSignatureDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.VtableFixupsDirectory" />
    <member name="T:System.Reflection.PortableExecutable.DebugDirectoryBuilder" />
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Reflection.PortableExecutable.DebugDirectoryBuilder" />.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddCodeViewEntry(System.String,System.Reflection.Metadata.BlobContentId,System.UInt16)">
      <summary>Ajoute une entrée CodeView.</summary>
      <param name="pdbPath">Chemin du fichier PDB. Il ne doit pas être vide.</param>
      <param name="pdbContentId">ID unique du contenu du fichier PDB.</param>
      <param name="portablePdbVersion">Version du format PDB Portable (par exemple, 0x0100 pour 1.0), ou 0 si le fichier PDB n’est pas portable.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="pdbPath" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="pdbPath" /> contient un caractère NUL.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="portablePdbVersion" /> est inférieure à 0x0100.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddEmbeddedPortablePdbEntry(System.Reflection.Metadata.BlobBuilder,System.UInt16)">
      <summary>Ajoute une entrée PDB Embedded Portable.</summary>
      <param name="debugMetadata">Générateur de métadonnées PDB Portable.</param>
      <param name="portablePdbVersion">Version du format PDB Portable (par exemple, 0x0100 pour 1.0).</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="debugMetadata" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="portablePdbVersion" /> est inférieure à 0x0100.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddEntry(System.Reflection.PortableExecutable.DebugDirectoryEntryType,System.UInt32,System.UInt32)">
      <summary>Ajoute une entrée du type spécifié.</summary>
      <param name="type">Type d’entrée.</param>
      <param name="version">Version de l’entrée.</param>
      <param name="stamp">Horodatage de l’entrée.</param>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddEntry``1(System.Reflection.PortableExecutable.DebugDirectoryEntryType,System.UInt32,System.UInt32,``0,System.Action{System.Reflection.Metadata.BlobBuilder,``0})">
      <summary>Ajoute une entrée du type spécifié et sérialise ses données.</summary>
      <param name="type">Type d’entrée.</param>
      <param name="version">Version de l’entrée.</param>
      <param name="stamp">Horodatage de l’entrée.</param>
      <param name="data">Données à passer à <paramref name="dataSerializer" />.</param>
      <param name="dataSerializer">Sérialiseur pour sérialiser des données dans un <see cref="T:System.Reflection.Metadata.BlobBuilder" />.</param>
      <typeparam name="TData">Type des données passées à <paramref name="dataSerializer" /> .</typeparam>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddPdbChecksumEntry(System.String,System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>Ajoute une entrée de somme de contrôle PDB.</summary>
      <param name="algorithmName">Nom de l’algorithme de hachage (par exemple « SHA256 »).</param>
      <param name="checksum">Somme de contrôle.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="algorithmName" /> ou <paramref name="checksum" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="algorithmName" /> ou <paramref name="checksum" /> est vide.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddReproducibleEntry">
      <summary>Ajoute une entrée reproductible.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.DebugDirectoryEntry">
      <summary>Identifie l’emplacement, la taille et le format d’un bloc d’informations de débogage.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryEntry.#ctor(System.UInt32,System.UInt16,System.UInt16,System.Reflection.PortableExecutable.DebugDirectoryEntryType,System.Int32,System.Int32,System.Int32)">
      <summary>Initialise une nouvelle instance de la structure <see cref="T:System.Reflection.PortableExecutable.DebugDirectoryEntry" />.</summary>
      <param name="stamp" />
      <param name="majorVersion" />
      <param name="minorVersion" />
      <param name="type" />
      <param name="dataSize" />
      <param name="dataRelativeVirtualAddress" />
      <param name="dataPointer" />
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.DataPointer">
      <summary>Obtient le pointeur de fichier vers les données de débogage.</summary>
      <returns>Pointeur de fichier vers les données de débogage.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.DataRelativeVirtualAddress">
      <summary>Obtient l’adresse des données de débogage quand elles sont chargées, par rapport à la base de l’image.</summary>
      <returns>Adresse des données de débogage par rapport à la base de l’image.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.DataSize">
      <summary>Obtient la taille des données de débogage (répertoire de débogage exclu).</summary>
      <returns>taille des données de débogage (à l’exclusion du répertoire de débogage).</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.IsPortableCodeView">
      <summary>Obtient une valeur qui indique si l’entrée est une entrée <see cref="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView" /> qui pointe vers un fichier PDB portable.</summary>
      <returns>
        <see langword="true" /> Si l’entrée est une <see cref="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView" /> entrée pointant vers un fichier PDB portable ; sinon, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.MajorVersion">
      <summary>Obtient le numéro de version principale du format des données de débogage.</summary>
      <returns>Numéro de version principale du format de données de débogage.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.MinorVersion">
      <summary>Obtient le numéro de version mineure du format des données de débogage.</summary>
      <returns>Numéro de version mineure du format de données de débogage.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.Stamp">
      <summary>Obtient la date et l’heure de création des données de débogage si le fichier PE/COFF n’est pas déterministe ; sinon, obtient une valeur basée sur le hachage du contenu.</summary>
      <returns>pour un fichier PE/COFF non déterministe, l’heure et la date de création des données de débogage ; Sinon, valeur basée sur le hachage du contenu.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.Type">
      <summary>Obtient le format des informations de débogage.</summary>
      <returns>Format des informations de débogage.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.DebugDirectoryEntryType">
      <summary>Énumération qui décrit le format des informations de débogage d’un <see cref="T:System.Reflection.PortableExecutable.DebugDirectoryEntry" />.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView">
      <summary>Description du fichier PDB associé.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Coff">
      <summary>Informations de débogage COFF (numéros de ligne, table de symboles et table de chaînes). Ce type d’informations de débogage est également désigné par des champs dans les en-têtes de fichiers.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.EmbeddedPortablePdb">
      <summary>
        <para>L’entrée pointe vers un objet blob contenant un fichier PDB Embedded Portable. L’objet blob PDB Embedded Portable a le format suivant :</para>
        <para>- blob ::= uncompressed-size data</para>
        <para>- Les données couvrent le reste de l’objet blob et contiennent un fichier PDB Portable compressé à l’aide de l’algorithme Deflate.</para>
      </summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.PdbChecksum">
      <summary>L’entrée stocke un hachage de chiffrement du contenu du fichier de symboles avec lequel le fichier PE/COFF a été généré. Le hachage peut être utilisé pour valider le fait qu’un fichier PDB donné a été généré avec le fichier PE/COFF et qu’il n’a pas été modifié. Plusieurs entrées peuvent être présentes si plusieurs fichiers PDB ont été générés pendant la génération du fichier PE/COFF (par exemple, des symboles privés et publics).</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Reproducible">
      <summary>La présence de cette entrée indique un fichier PE/COFF déterministe. Pour plus d'informations, consultez la section Notes.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Unknown">
      <summary>Valeur inconnue qui doit être ignorée par tous les outils.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.DirectoryEntry" />
    <member name="F:System.Reflection.PortableExecutable.DirectoryEntry.RelativeVirtualAddress" />
    <member name="F:System.Reflection.PortableExecutable.DirectoryEntry.Size" />
    <member name="M:System.Reflection.PortableExecutable.DirectoryEntry.#ctor(System.Int32,System.Int32)">
      <param name="relativeVirtualAddress" />
      <param name="size" />
    </member>
    <member name="T:System.Reflection.PortableExecutable.DllCharacteristics">
      <summary>Décrit les caractéristiques d’une bibliothèque de liens dynamiques.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.AppContainer">
      <summary>L’image doit s’exécuter dans un AppContainer.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.DynamicBase">
      <summary>La DLL peut être déplacée.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.HighEntropyVirtualAddressSpace">
      <summary>L’image peut gérer un espace d’adressage virtuel 64 bits à entropie élevée.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NoBind">
      <summary>Ne liez pas cette image.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NoIsolation">
      <summary>L’image comprend l’isolation et ne la souhaite pas.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NoSeh">
      <summary>L’image n’utilise pas SEH. Aucun gestionnaire SE ne peut résider dans cette image.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NxCompatible">
      <summary>L’image est compatible avec NX.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ProcessInit">
      <summary>Réservé.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ProcessTerm">
      <summary>Réservé.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.TerminalServerAware">
      <summary>L’image prend en charge Terminal Server.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ThreadInit">
      <summary>Réservé.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ThreadTerm">
      <summary>Réservé.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.WdmDriver">
      <summary>Le pilote utilise le modèle WDM.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.Machine">
      <summary>Spécifie l’architecture processeur de l’ordinateur cible.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Alpha">
      <summary>Alpha.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Alpha64">
      <summary>ALPHA64.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.AM33">
      <summary>Matsushita AM33.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Amd64">
      <summary>AMD64 (K8).</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Arm">
      <summary>ARM little endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Arm64">
      <summary>ARM64.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.ArmThumb2">
      <summary>ARM Thumb-2 little endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Ebc">
      <summary>EFI Byte Code.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.I386">
      <summary>Intel 386.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.IA64">
      <summary>Intel 64.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.M32R">
      <summary>M32R little-endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.MIPS16">
      <summary>MIPS.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.MipsFpu">
      <summary>MIPS avec FPU.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.MipsFpu16">
      <summary>MIPS16 avec FPU.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.PowerPC">
      <summary>IBM PowerPC little endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.PowerPCFP">
      <summary>PowerPCFP.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH3">
      <summary>Hitachi SH3 little endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH3Dsp">
      <summary>Hitachi SH3 DSP.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH3E">
      <summary>Hitachi SH3 little endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH4">
      <summary>Hitachi SH4 little endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH5">
      <summary>Hitachi SH5.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Thumb">
      <summary>Thumb.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Tricore">
      <summary>Infineon.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Unknown">
      <summary>Le processeur cible est inconnu ou n’est pas spécifié.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.WceMipsV2">
      <summary>MIPS little-endian WCE v2.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.ManagedPEBuilder" />
    <member name="F:System.Reflection.PortableExecutable.ManagedPEBuilder.ManagedResourcesDataAlignment" />
    <member name="F:System.Reflection.PortableExecutable.ManagedPEBuilder.MappedFieldDataAlignment" />
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.#ctor(System.Reflection.PortableExecutable.PEHeaderBuilder,System.Reflection.Metadata.Ecma335.MetadataRootBuilder,System.Reflection.Metadata.BlobBuilder,System.Reflection.Metadata.BlobBuilder,System.Reflection.Metadata.BlobBuilder,System.Reflection.PortableExecutable.ResourceSectionBuilder,System.Reflection.PortableExecutable.DebugDirectoryBuilder,System.Int32,System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.PortableExecutable.CorFlags,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Reflection.Metadata.BlobContentId})">
      <param name="header" />
      <param name="metadataRootBuilder" />
      <param name="ilStream" />
      <param name="mappedFieldData" />
      <param name="managedResources" />
      <param name="nativeResources" />
      <param name="debugDirectoryBuilder" />
      <param name="strongNameSignatureSize" />
      <param name="entryPoint" />
      <param name="flags" />
      <param name="deterministicIdProvider" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.CreateSections" />
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.GetDirectories" />
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.SerializeSection(System.String,System.Reflection.PortableExecutable.SectionLocation)">
      <param name="name" />
      <param name="location" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.Sign(System.Reflection.Metadata.BlobBuilder,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Byte[]})">
      <param name="peImage" />
      <param name="signatureProvider" />
    </member>
    <member name="T:System.Reflection.PortableExecutable.PdbChecksumDebugDirectoryData">
      <summary>Représente une entrée du répertoire de débogage de somme de contrôle PDB.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PdbChecksumDebugDirectoryData.AlgorithmName">
      <summary>Le nom de l’algorithme de hachage utilisé pour calculer la somme de contrôle.</summary>
      <returns>Chaîne représentant le nom de l’algorithme de hachage de chiffrement utilisé pour calculer la somme de contrôle.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PdbChecksumDebugDirectoryData.Checksum">
      <summary>Somme de contrôle du contenu PDB.</summary>
      <returns>Tableau immuable d’octets représentant la somme de contrôle du contenu PDB.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEBuilder" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.#ctor(System.Reflection.PortableExecutable.PEHeaderBuilder,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Reflection.Metadata.BlobContentId})">
      <param name="header" />
      <param name="deterministicIdProvider" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.CreateSections" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.GetDirectories" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.GetSections" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.Serialize(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.SerializeSection(System.String,System.Reflection.PortableExecutable.SectionLocation)">
      <param name="name" />
      <param name="location" />
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEBuilder.Header" />
    <member name="P:System.Reflection.PortableExecutable.PEBuilder.IdProvider" />
    <member name="P:System.Reflection.PortableExecutable.PEBuilder.IsDeterministic" />
    <member name="T:System.Reflection.PortableExecutable.PEBuilder.Section" />
    <member name="F:System.Reflection.PortableExecutable.PEBuilder.Section.Characteristics" />
    <member name="F:System.Reflection.PortableExecutable.PEBuilder.Section.Name" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.Section.#ctor(System.String,System.Reflection.PortableExecutable.SectionCharacteristics)">
      <param name="name" />
      <param name="characteristics" />
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEDirectoriesBuilder">
      <summary>Génère des répertoires PE.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEDirectoriesBuilder.#ctor">
      <summary>Initialise une instance de la classe <see cref="T:System.Reflection.PortableExecutable.PEDirectoriesBuilder" />.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.AddressOfEntryPoint">
      <summary>Adresse du point d’entrée par rapport à la base de l’image quand le fichier PE est chargé en mémoire.</summary>
      <returns>Pour les images de programme, il s’agit de l’adresse de départ. Pour les pilotes de périphérique, il s’agit de l’adresse de la fonction d’initialisation. Un point d’entrée est facultatif pour les dll. Si aucun point d’entrée n’est présent, ce champ doit être égal à zéro.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.BaseRelocationTable">
      <summary>Entrée de répertoire de l’image de la table de réadressage de base.</summary>
      <returns>Une instance d’entrée de répertoire.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.BoundImportTable">
      <summary>Entrée de répertoire de l’image d’importation liée.</summary>
      <returns>Une instance d’entrée de répertoire.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.CopyrightTable">
      <summary>Entrée de répertoire de l’image de copyright/architecture.</summary>
      <returns>Une instance d’entrée de répertoire.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.CorHeaderTable">
      <summary>Entrée de répertoire de l’image de la table de descripteurs COM.</summary>
      <returns>Une instance d’entrée de répertoire.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.DebugTable">
      <summary>Entrée de répertoire de l’image de la table de débogage.</summary>
      <returns>Une instance d’entrée de répertoire.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.DelayImportTable">
      <summary>Entrée de répertoire de l’image de la table d’importations différées.</summary>
      <returns>Une instance d’entrée de répertoire.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ExceptionTable">
      <summary>Entrée de répertoire de l’image de la table d’exceptions.</summary>
      <returns>Une instance d’entrée de répertoire.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ExportTable">
      <summary>Entrée de répertoire de l’image de la table d’exportations.</summary>
      <returns>Une instance d’entrée de répertoire.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.GlobalPointerTable">
      <summary>Entrée de répertoire de l’image de la table de pointeurs globaux.</summary>
      <returns>Une instance d’entrée de répertoire.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ImportAddressTable">
      <summary>Entrée de répertoire de l’image de la table d’adresses d’importation (IAT).</summary>
      <returns>Une instance d’entrée de répertoire.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ImportTable">
      <summary>Entrée de répertoire de l’image de la table d’importations.</summary>
      <returns>Une instance d’entrée de répertoire.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.LoadConfigTable">
      <summary>Entrée de répertoire de l’image de la table de configurations de chargement.</summary>
      <returns>Une instance d’entrée de répertoire.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ResourceTable">
      <summary>Entrée de répertoire de l’image de la table de ressources.</summary>
      <returns>Une instance d’entrée de répertoire.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ThreadLocalStorageTable">
      <summary>Entrée de répertoire de l’image de table de stockage local des threads (TLS).</summary>
      <returns>Une instance d’entrée de répertoire.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEHeader" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.AddressOfEntryPoint">
      <summary>Obtient l’adresse du point d’entrée par rapport à la base de l’image quand le fichier PE est chargé en mémoire.</summary>
      <returns>Adresse du point d’entrée par rapport à la base de l’image.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BaseOfCode">
      <summary>Obtient l’adresse de la section de début de code par rapport à la base de l’image quand l’image est chargée en mémoire.</summary>
      <returns>Adresse de la section de début de code par rapport à la base de l’image.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BaseOfData">
      <summary>Obtient l’adresse de la section de début de données par rapport à la base de l’image quand l’image est chargée en mémoire.</summary>
      <returns>Adresse de la section de début de données par rapport à la base de l’image.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BaseRelocationTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BoundImportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CertificateTableDirectory">
      <summary>Obtient l’entrée de la table de certificats, qui pointe vers une table de certificats d’attributs.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CheckSum">
      <summary>Obtient la somme de contrôle du fichier image.</summary>
      <returns>Somme de contrôle du fichier image.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CopyrightTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CorHeaderTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.DebugTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.DelayImportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.DllCharacteristics" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ExceptionTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ExportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.FileAlignment">
      <summary>Obtient le facteur d’alignement (en octets) utilisé pour aligner les données brutes des sections dans le fichier image.</summary>
      <returns>Puissance de 2 comprise entre 512 et 64 Ko inclus. La valeur par défaut est 512.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.GlobalPointerTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ImageBase">
      <summary>Obtient l’adresse par défaut du premier octet de l’image quand il est chargé en mémoire.</summary>
      <returns>L’adresse par défaut, qui est un multiple de 64 Ko.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ImportAddressTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ImportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.LoadConfigTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.Magic">
      <summary>Obtient une valeur qui identifie le format du fichier image.</summary>
      <returns>Format du fichier image.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorImageVersion">
      <summary>Obtient le numéro de version principale de l’image.</summary>
      <returns>Numéro de version principale de l’image.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorLinkerVersion">
      <summary>Obtient le numéro de version principale de l’éditeur de liens.</summary>
      <returns>Numéro de version principale de l’éditeur de liens.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorOperatingSystemVersion">
      <summary>Obtient le numéro de version principale du système d’exploitation requis.</summary>
      <returns>Numéro de version principale du système d’exploitation nécessaire.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorSubsystemVersion">
      <summary>Retourne le numéro de version principale du sous-système.</summary>
      <returns>Numéro de version principale du sous-système.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorImageVersion">
      <summary>Obtient le numéro de version secondaire de l’image.</summary>
      <returns>Numéro de version mineure de l’image.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorLinkerVersion">
      <summary>Obtient le numéro de version secondaire de l’éditeur de liens.</summary>
      <returns>Numéro de version mineure de l’éditeur de liens.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorOperatingSystemVersion">
      <summary>Obtient le numéro de version secondaire du système d’exploitation requis.</summary>
      <returns>Numéro de version mineure du système d’exploitation nécessaire.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorSubsystemVersion">
      <summary>Retourne le numéro de version secondaire du sous-système.</summary>
      <returns>Numéro de version mineure du sous-système.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.NumberOfRvaAndSizes">
      <summary>Obtient le nombre d’entrées de répertoire de données dans le reste du <see cref="T:System.Reflection.PortableExecutable.PEHeader" />. Chacune décrit un emplacement et une taille.</summary>
      <returns>Nombre d’entrées de répertoire de données dans le reste de <see cref="T:System.Reflection.PortableExecutable.PEHeader" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ResourceTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SectionAlignment">
      <summary>Obtient l’alignement (en octets) des sections quand elles sont chargées en mémoire.</summary>
      <returns>Nombre supérieur ou égal à <see cref="P:System.Reflection.PortableExecutable.PEHeader.FileAlignment" /> . La valeur par défaut correspond à la taille de page de l’architecture.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfCode">
      <summary>Obtient la taille de la section de code (texte), ou la somme de toutes les sections de code s’il y a plusieurs sections.</summary>
      <returns>la taille de la section de code (texte) ou la somme de toutes les sections de code s’il y a plusieurs sections.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeaders">
      <summary>Obtient la taille combinée d’un stub MS DOS, d’un en-tête PE et des en-têtes de section, arrondie vers le haut à un multiple de FileAlignment.</summary>
      <returns>La taille combinée d’un stub MS DOS, d’un en-tête PE et d’en-têtes de section est arrondie à un multiple de assigne FileAlignment.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapCommit">
      <summary>Obtient la taille de l’espace du segment de mémoire local à valider.</summary>
      <returns>taille de l’espace du tas local à valider.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapReserve">
      <summary>Obtient la taille de l’espace du segment de mémoire local à réserver. Seul <see cref="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapCommit" /> est commité. Le reste est mis à disposition, une page à la fois, jusqu’à ce que la taille de réserve soit atteinte.</summary>
      <returns>Taille de l’espace du tas local à réserver.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfImage">
      <summary>Obtient la taille (en octets) de l’image, y compris tous les en-têtes, quand l’image est chargée en mémoire.</summary>
      <returns>Taille (en octets) de l’image, qui est un multiple de <see cref="P:System.Reflection.PortableExecutable.PEHeader.SectionAlignment" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfInitializedData">
      <summary>Obtient la taille de la section de données initialisées, ou la somme de toutes ces sections s’il y a plusieurs sections de données.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackCommit">
      <summary>Obtient la taille de la pile à valider.</summary>
      <returns>Taille de la pile à commiter.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackReserve">
      <summary>Obtient la taille de la pile à réserver. Seul <see cref="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackCommit" /> est commité. Le reste est mis à disposition, une page à la fois, jusqu’à ce que la taille de réserve soit atteinte.</summary>
      <returns>Taille de la pile à réserver.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfUninitializedData">
      <summary>Obtient la taille de la section de données non initialisées (BSS), ou la somme de toutes ces sections s’il y a plusieurs sections BSS.</summary>
      <returns>Taille de la section de données non initialisées (BSS) ou somme de toutes ces sections.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.Subsystem">
      <summary>Obtient le nom du sous-système requis pour exécuter cette image.</summary>
      <returns>nom du sous-système requis pour exécuter cette image.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ThreadLocalStorageTableDirectory" />
    <member name="T:System.Reflection.PortableExecutable.PEHeaderBuilder">
      <summary>Définit l’en-tête d’un fichier PE (exécutable portable).</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaderBuilder.#ctor(System.Reflection.PortableExecutable.Machine,System.Int32,System.Int32,System.UInt64,System.Byte,System.Byte,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.Reflection.PortableExecutable.Subsystem,System.Reflection.PortableExecutable.DllCharacteristics,System.Reflection.PortableExecutable.Characteristics,System.UInt64,System.UInt64,System.UInt64,System.UInt64)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Reflection.PortableExecutable.PEHeader" />.</summary>
      <param name="machine">Architecture du processeur de la machine cible.</param>
      <param name="sectionAlignment">Alignement (en octets) des sections quand elles sont chargées en mémoire. La valeur doit être supérieure ou égale à <paramref name="fileAlignment" />. La valeur par défaut correspond à la taille de page de l’architecture.</param>
      <param name="fileAlignment">Facteur d’alignement (en octets) utilisé pour aligner les données brutes des sections du fichier image. La valeur doit être une puissance de 2 comprise entre 512 octets et 64 Ko inclus. La valeur par défaut est 512. Si <paramref name="sectionAlignment" /> est inférieur à la taille de page de l’architecture, <paramref name="fileAlignment" /> doit correspondre à <paramref name="sectionAlignment" />.</param>
      <param name="imageBase">Adresse par défaut du premier octet de l’image quand elle est chargée en mémoire ; doit être un multiple de 64 Ko.</param>
      <param name="majorLinkerVersion">Numéro de version principale de l’éditeur de liens.</param>
      <param name="minorLinkerVersion">Numéro de version mineure de l’éditeur de liens.</param>
      <param name="majorOperatingSystemVersion">Numéro de version principale du système d’exploitation nécessaire.</param>
      <param name="minorOperatingSystemVersion">Numéro de version mineure du système d’exploitation nécessaire.</param>
      <param name="majorImageVersion">Numéro de version principale de l’image.</param>
      <param name="minorImageVersion">Numéro de version mineure de l’image.</param>
      <param name="majorSubsystemVersion">Numéro de version principale du sous-système.</param>
      <param name="minorSubsystemVersion">Numéro de version mineure du sous-système.</param>
      <param name="subsystem">Sous-système nécessaire pour exécuter l’image.</param>
      <param name="dllCharacteristics">Objet décrivant les caractéristiques de la bibliothèque de liens dynamiques.</param>
      <param name="imageCharacteristics">Objet décrivant les caractéristiques de l’image.</param>
      <param name="sizeOfStackReserve">Taille de la pile à réserver. Seul <paramref name="sizeOfStackCommit" /> est commité. Le reste est mis à disposition, une page à la fois, jusqu’à ce que la taille de réserve soit atteinte.</param>
      <param name="sizeOfStackCommit">Taille de la pile à commiter.</param>
      <param name="sizeOfHeapReserve">Taille de l’espace du tas local à réserver. Seul <paramref name="sizeOfHeapCommit" /> est commité. Le reste est mis à disposition, une page à la fois, jusqu’à ce que la taille de réserve soit atteinte.</param>
      <param name="sizeOfHeapCommit">Taille de l’espace du tas local à commiter.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="fileAlignment" /> n’est pas une puissance de 2 comprise entre 512 octets et 64 Ko.
- ou -

<paramref name="sectionAlignment" /> n’est pas une puissance de 2.

- ou -

<paramref name="sectionAlignment" /> est inférieur à <paramref name="fileAlignment" />.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaderBuilder.CreateExecutableHeader">
      <summary>Crée un en-tête d’exécutable.</summary>
      <returns>Instance de <see cref="T:System.Reflection.PortableExecutable.PEHeaderBuilder" /> représentant l’en-tête de l’exécutable.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaderBuilder.CreateLibraryHeader">
      <summary>Crée un en-tête de bibliothèque.</summary>
      <returns>Instance de <see cref="T:System.Reflection.PortableExecutable.PEHeaderBuilder" /> représentant l’en-tête de la bibliothèque.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.DllCharacteristics">
      <summary>Retourne les caractéristiques de la bibliothèque de l’éditeur de liens dynamiques.</summary>
      <returns>Objet qui décrit les caractéristiques de la bibliothèque de l’éditeur de liens dynamiques.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.FileAlignment">
      <summary>Facteur d’alignement (en octets) utilisé pour aligner les données brutes des sections du fichier image. La valeur doit être une puissance de 2 comprise entre 512 octets et 64 Ko inclus. La valeur par défaut est 512. Si l’alignement de la section est inférieur à la taille de page de l’architecture, l’alignement du fichier doit correspondre à celui de la section.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.ImageBase">
      <summary>Adresse par défaut du premier octet de l’image quand elle est chargée en mémoire ; doit être un multiple de 64 Ko.</summary>
      <returns>Nombre représentant l’adresse par défaut du premier octet de l’image en cas de chargement en mémoire.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.ImageCharacteristics">
      <summary>Retourne les caractéristiques de l’image.</summary>
      <returns>Objet représentant les caractéristiques de l’image.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.Machine">
      <summary>Architecture du processeur de la machine cible.</summary>
      <returns>L’une des valeurs d’énumération représentant les différentes architectures d’UC.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorImageVersion">
      <summary>Numéro de version principale de l’image.</summary>
      <returns>Nombre de la taille d’un <see cref="T:System.UInt16" /> représentant le numéro de version principale de l’image.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorLinkerVersion">
      <summary>Numéro de version principale de l’éditeur de liens.</summary>
      <returns>Nombre de la taille d’un <see cref="T:System.Byte" /> représentant le numéro de version principale de l’éditeur de liens.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorOperatingSystemVersion">
      <summary>Numéro de version principale du système d’exploitation nécessaire.</summary>
      <returns>Nombre de la taille d’un <see cref="T:System.UInt16" /> représentant le numéro de version principale du système d’exploitation requis.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorSubsystemVersion">
      <summary>Numéro de version principale du sous-système.</summary>
      <returns>Nombre de la taille d’un <see cref="T:System.UInt16" /> représentant le numéro de version principale du sous-système.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorImageVersion">
      <summary>Numéro de version mineure de l’image.</summary>
      <returns>Nombre de la taille d’un <see cref="T:System.UInt16" /> représentant le numéro de version mineure de l’image.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorLinkerVersion">
      <summary>Numéro de version mineure de l’éditeur de liens.</summary>
      <returns>Nombre de la taille d’un <see cref="T:System.Byte" /> représentant le numéro de version mineure de l’éditeur de liens.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorOperatingSystemVersion">
      <summary>Numéro de version mineure du système d’exploitation nécessaire.</summary>
      <returns>Nombre de la taille d’un <see cref="T:System.UInt16" /> représentant le numéro de version mineure du système d’exploitation requis.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorSubsystemVersion">
      <summary>Numéro de version mineure du sous-système.</summary>
      <returns>Nombre de la taille d’un <see cref="T:System.UInt16" /> représentant le numéro de version mineure du sous-système.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SectionAlignment">
      <summary>Alignement (en octets) des sections quand elles sont chargées en mémoire.</summary>
      <returns>Nombre représentant l’alignement (en octets) des sections lorsqu’elles sont chargées en mémoire. Elle doit être supérieure ou égale à l’alignement du fichier. La valeur par défaut correspond à la taille de page de l’architecture.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfHeapCommit">
      <summary>Taille de l’espace du tas local à commiter.</summary>
      <returns>Nombre représentant la taille de l’espace du tas local à valider.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfHeapReserve">
      <summary>Taille de l’espace du tas local à réserver. Seul <see cref="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfHeapCommit" /> est commité. Le reste est mis à disposition, une page à la fois, jusqu’à ce que la taille de réserve soit atteinte.</summary>
      <returns>Nombre représentant la taille de l’espace du tas local à réserver.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfStackCommit">
      <summary>Taille de la pile à commiter.</summary>
      <returns>Nombre représentant la taille de la pile à valider.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfStackReserve">
      <summary>Taille de la pile à réserver. Seul <see cref="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfStackCommit" /> est commité. Le reste est mis à disposition, une page à la fois, jusqu’à ce que la taille de réserve soit atteinte.</summary>
      <returns>Nombre représentant la taille de la pile à réserver.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.Subsystem">
      <summary>Sous-système nécessaire pour exécuter cette image.</summary>
      <returns>Instance de <see cref="T:System.Reflection.PortableExecutable.Subsystem" />.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEHeaders">
      <summary>Définit un type qui lit les en-têtes PE (Portable Executable) et COFF (Common Object File Format) à partir d’un flux.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream)">
      <summary>Instancie une nouvelle instance de la classe <see cref="T:System.Reflection.PortableExecutable.PEHeaders" /> qui lit les en-têtes PE à partir de l’emplacement actuel dans le flux spécifié.</summary>
      <param name="peStream">Flux contenant l’image PE qui commence à la position actuelle du flux et se termine à la fin du flux.</param>
      <exception cref="T:System.BadImageFormatException">Le format des données lues à partir du flux n’est pas valide.</exception>
      <exception cref="T:System.IO.IOException">Erreur lors de la lecture du flux.</exception>
      <exception cref="T:System.ArgumentException">Le flux ne prend pas en charge les opérations de recherche.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peStream" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream,System.Int32)">
      <summary>Instancie une nouvelle instance de la classe <see cref="T:System.Reflection.PortableExecutable.PEHeaders" /> qui lit les en-têtes PE à partir d’un flux qui représente une image PE d’une taille spécifiée.</summary>
      <param name="peStream">Flux contenant l’image PE de la taille donnée en commençant à sa position actuelle.</param>
      <param name="size">Taille de l’image PE.</param>
      <exception cref="T:System.BadImageFormatException">Le format des données lues à partir du flux n’est pas valide.</exception>
      <exception cref="T:System.IO.IOException">Erreur lors de la lecture du flux.</exception>
      <exception cref="T:System.ArgumentException">Le flux ne prend pas en charge les opérations de recherche.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peStream" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">La valeur de <paramref name="size" /> est négative ou s’étend au-delà de la fin du flux.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream,System.Int32,System.Boolean)">
      <summary>Instancie une nouvelle instance de la classe <see cref="T:System.Reflection.PortableExecutable.PEHeaders" /> qui lit les en-têtes PE à partir d’un flux qui représente une image PE d’une taille spécifiée et indique si l’image PE a été chargée en mémoire.</summary>
      <param name="peStream">Flux contenant l’image PE de la taille donnée en commençant à sa position actuelle.</param>
      <param name="size">Taille de l’image PE.</param>
      <param name="isLoadedImage">
        <see langword="true" /> si l’image PE a été chargée en mémoire par le chargeur du système d’exploitation ; sinon, <see langword="false" />.</param>
      <exception cref="T:System.BadImageFormatException">Le format des données lues à partir du flux n’est pas valide.</exception>
      <exception cref="T:System.IO.IOException">Erreur lors de la lecture du flux.</exception>
      <exception cref="T:System.ArgumentException">Le flux ne prend pas en charge les opérations de recherche.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peStream" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">La valeur de <paramref name="size" /> est négative ou s’étend au-delà de la fin du flux.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.GetContainingSectionIndex(System.Int32)">
      <summary>Recherche dans les sections de l’image PE la section contenant l’adresse virtuelle relative spécifiée.</summary>
      <param name="relativeVirtualAddress">Adresse virtuelle relative à rechercher.</param>
      <returns>Index de la section qui contient <paramref name="relativeVirtualAddress" />, ou -1 si la recherche n’aboutit pas.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.TryGetDirectoryOffset(System.Reflection.PortableExecutable.DirectoryEntry,System.Int32@)">
      <summary>Obtient le décalage (en octets) entre le début de l’image et les données de répertoire spécifiées.</summary>
      <param name="directory">Entrée de répertoire PE.</param>
      <param name="offset">La valeur retournée par la méthode contient le décalage entre le début de l’image et les données de répertoire spécifiées.</param>
      <returns>
        <see langword="true" /> si les données de répertoire sont trouvées ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CoffHeader">
      <summary>Obtient l’en-tête COFF de l’image.</summary>
      <returns>En-tête COFF de l’image.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CoffHeaderStartOffset">
      <summary>Obtient le décalage en octets entre le début de l’image PE et le début de l’en-tête COFF.</summary>
      <returns>Offset d’octet à partir du début de l’image PE jusqu’au début de l’en-tête COFF.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CorHeader">
      <summary>Obtient l’en-tête COR.</summary>
      <returns>En-tête COR, ou <see langword="null" /> si l’image n’en a pas.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CorHeaderStartOffset">
      <summary>Obtient le décalage en octets entre le début de l’image et l’en-tête COR.</summary>
      <returns>Offset d’octet à partir du début de l’image vers l’en-tête COR, ou-1 si l’image n’a pas d’en-tête COR.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsCoffOnly">
      <summary>Obtient une valeur qui indique si l’image est au format COFF uniquement.</summary>
      <returns>
        <see langword="true" /> Si l’image est au format COFF uniquement ; Sinon, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsConsoleApplication">
      <summary>Obtient une valeur qui indique si l’image représente une application console Windows.</summary>
      <returns>
        <see langword="true" /> Si l’image est une application console Windows ; Sinon, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsDll">
      <summary>Obtient une valeur qui indique si l’image représente une bibliothèque de liens dynamiques.</summary>
      <returns>
        <see langword="true" /> Si l’image est une DLL ; Sinon, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsExe">
      <summary>Obtient une valeur qui indique si l’image représente un exécutable.</summary>
      <returns>
        <see langword="true" /> Si l’image est un exécutable ; Sinon, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.MetadataSize">
      <summary>Obtient la taille des métadonnées CLI.</summary>
      <returns>taille des métadonnées CLI, ou 0 si l’image ne contient pas de métadonnées.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.MetadataStartOffset">
      <summary>Obtient le décalage (en octets) entre le début de l’image PE et le début des métadonnées CLI.</summary>
      <returns>Décalage (en octets) entre le début de l’image PE et le début des métadonnées CLI, ou-1 si l’image ne contient pas de métadonnées.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.PEHeader">
      <summary>Obtient l’en-tête PE de l’image.</summary>
      <returns>En-tête PE de l’image, ou <see langword="null" /> si l’image est COFF uniquement.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.PEHeaderStartOffset">
      <summary>Obtient le décalage en octets de l’en-tête à partir du début de l’image.</summary>
      <returns>Offset d’octet de l’en-tête à partir du début de l’image.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.SectionHeaders">
      <summary>Obtient les en-têtes de section PE.</summary>
      <returns>Tableau contenant les en-têtes de section PE.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEMagic" />
    <member name="F:System.Reflection.PortableExecutable.PEMagic.PE32" />
    <member name="F:System.Reflection.PortableExecutable.PEMagic.PE32Plus" />
    <member name="T:System.Reflection.PortableExecutable.PEMemoryBlock" />
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetContent">
      <summary>Lit le contenu du bloc entier dans un tableau.</summary>
      <returns>Tableau d’octets immuable.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetContent(System.Int32,System.Int32)">
      <summary>Lit le contenu d’une partie du bloc dans un tableau.</summary>
      <param name="start">Position de départ dans le bloc.</param>
      <param name="length">Nombre d'octets à lire.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">La plage spécifiée n’est pas contenue dans le bloc.</exception>
      <returns>Tableau d’octets immuable.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetReader">
      <summary>Crée un <see cref="T:System.Reflection.Metadata.BlobReader" /> pour un objet blob couvrant la totalité du bloc.</summary>
      <returns>Lecteur pour un objet blob couvrant la totalité du bloc.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetReader(System.Int32,System.Int32)">
      <summary>Crée un <see cref="T:System.Reflection.Metadata.BlobReader" /> pour un objet blob couvrant une partie du bloc.</summary>
      <param name="start">Position de départ dans le bloc.</param>
      <param name="length">Nombre d’octets dans la partie du bloc.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">La plage spécifiée n’est pas contenue dans le bloc.</exception>
      <returns>Lecteur pour un objet blob couvrant une partie du bloc.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEMemoryBlock.Length">
      <summary>Obtient la longueur du bloc.</summary>
      <returns>Longueur du bloc.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEMemoryBlock.Pointer">
      <summary>Obtient un pointeur vers le premier octet du bloc.</summary>
      <returns>Pointeur vers le premier octet du bloc.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEReader">
      <summary>Fournit un lecteur pour les fichiers au format PE (Portable Executable).</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.Byte*,System.Int32)">
      <summary>Crée un lecteur Portable Executable sur une image PE stockée en mémoire.</summary>
      <param name="peImage">Pointeur vers le début du bloc de mémoire.</param>
      <param name="size">Taille de l’image PE.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peImage" /> a la valeur <see cref="F:System.IntPtr.Zero" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> est un nombre négatif.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.Byte*,System.Int32,System.Boolean)">
      <summary>Crée un lecteur Portable Executable sur une image PE stockée en mémoire. Un indicateur précise si l’image a déjà été chargée en mémoire.</summary>
      <param name="peImage">Pointeur vers le début du bloc de mémoire.</param>
      <param name="size">Taille de l’image PE.</param>
      <param name="isLoadedImage">
        <see langword="true" /> si l’image PE a été chargée en mémoire par le chargeur du système d’exploitation ; sinon, <see langword="false" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peImage" /> a la valeur <see cref="F:System.IntPtr.Zero" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> est un nombre négatif.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>Crée un lecteur Portable Executable sur une image PE stockée dans un tableau d’octets.</summary>
      <param name="peImage">Tableau immuable d’octets représentant l’image PE.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peImage" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream)">
      <summary>Crée un lecteur Portable Executable sur une image PE stockée dans un flux.</summary>
      <param name="peStream">Flux d’image PE.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peStream" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream,System.Reflection.PortableExecutable.PEStreamOptions)">
      <summary>Crée un lecteur Portable Executable sur une image PE stockée dans un flux, en commençant à sa position actuelle et en finissant à la fin du flux.</summary>
      <param name="peStream">Flux d’image PE.</param>
      <param name="options">Options spécifiant comment les sections de l’image PE sont lues à partir du flux.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peStream" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="options" /> a une valeur non valide.</exception>
      <exception cref="T:System.IO.IOException">Erreur de lecture du flux (uniquement lors de la prérécupération des données).</exception>
      <exception cref="T:System.BadImageFormatException">
        <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata" /> est spécifié, et les en-têtes PE de l’image ne sont pas valides.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream,System.Reflection.PortableExecutable.PEStreamOptions,System.Int32)">
      <summary>Crée un lecteur Portable Executable sur une image PE de la taille donnée en commençant à la position actuelle du flux.</summary>
      <param name="peStream">Flux d’image PE.</param>
      <param name="options">Options spécifiant comment les sections de l’image PE sont lues à partir du flux.</param>
      <param name="size">Taille de l’image PE.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">La valeur de <paramref name="size" /> est négative ou s’étend au-delà de la fin du flux.</exception>
      <exception cref="T:System.IO.IOException">Erreur de lecture du flux (uniquement lors de la prérécupération des données).</exception>
      <exception cref="T:System.BadImageFormatException">
        <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata" /> est spécifié, et les en-têtes PE de l’image ne sont pas valides.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.Dispose">
      <summary>Supprime toute la mémoire allouée par le lecteur.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetEntireImage">
      <summary>Obtient un objet <see cref="T:System.Reflection.PortableExecutable.PEMemoryBlock" /> contenant la totalité de l’image PE.</summary>
      <exception cref="T:System.InvalidOperationException">La totalité de l’image PE n’est pas disponible.</exception>
      <returns>Bloc de mémoire qui contient la totalité de l’image PE.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetMetadata">
      <summary>Charge une section PE qui contient des métadonnées CLI.</summary>
      <exception cref="T:System.InvalidOperationException">L’image PE ne contient pas de métadonnées (<see cref="P:System.Reflection.PortableExecutable.PEReader.HasMetadata" /> retourne <see langword="false" />).</exception>
      <exception cref="T:System.BadImageFormatException">Les en-têtes PE contiennent des données non valides.</exception>
      <exception cref="T:System.IO.IOException">Erreur d’E/S lors de la lecture à partir du flux sous-jacent.</exception>
      <returns>Bloc de mémoire qui contient les métadonnées CLI.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetSectionData(System.Int32)">
      <summary>Charge la section PE qui contient l’adresse virtuelle relative spécifiée en mémoire, et retourne un bloc de mémoire qui commence à cette adresse et se termine à la fin de la section contenante.</summary>
      <param name="relativeVirtualAddress">Adresse virtuelle relative des données à lire.</param>
      <exception cref="T:System.BadImageFormatException">Les en-têtes PE contiennent des données non valides.</exception>
      <exception cref="T:System.IO.IOException">Une erreur d’E/S est survenue lors de la lecture à partir du flux sous-jacent.</exception>
      <exception cref="T:System.InvalidOperationException">L’image PE n’est pas disponible.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="relativeVirtualAddress" /> est un nombre négatif.</exception>
      <returns>Bloc de mémoire qui commence à <paramref name="relativeVirtualAddress" /> et se termine à la fin de la section contenante, ou bloc vide si <paramref name="relativeVirtualAddress" /> ne représente pas un emplacement dans l’une des sections PE de cette image PE.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetSectionData(System.String)">
      <summary>Charge la section PE avec le nom spécifié en mémoire et retourne un bloc de mémoire qui couvre la section.</summary>
      <param name="sectionName">Nom de la section.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="sectionName" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L’image PE n’est pas disponible.</exception>
      <returns>Bloc de mémoire qui couvre la section, ou bloc vide si aucune section du <paramref name="sectionName" /> donné n’existe dans cette image PE.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadCodeViewDebugDirectoryData(System.Reflection.PortableExecutable.DebugDirectoryEntry)">
      <summary>Lit les données vers lesquelles pointe l’entrée de répertoire de débogage spécifiée, et les interprète en tant que CodeView.</summary>
      <param name="entry">Instance d’entrée de répertoire de débogage.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="entry" /> n’est pas une entrée CodeView.</exception>
      <exception cref="T:System.BadImageFormatException">Le format des données est incorrect.</exception>
      <exception cref="T:System.IO.IOException">Erreur d’E/S lors de la lecture à partir du flux sous-jacent.</exception>
      <exception cref="T:System.InvalidOperationException">L’image PE n’est pas disponible.</exception>
      <returns>Instance de données du répertoire de débogage CodeView.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadDebugDirectory">
      <summary>Lit toutes les entrées de la table de répertoire de débogage.</summary>
      <exception cref="T:System.BadImageFormatException">Le format de l’entrée est incorrect.</exception>
      <exception cref="T:System.IO.IOException">Erreur d’E/S lors de la lecture à partir du flux sous-jacent.</exception>
      <exception cref="T:System.InvalidOperationException">L’image PE n’est pas disponible.</exception>
      <returns>Tableau d’entrées de la table de répertoire de débogage.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadEmbeddedPortablePdbDebugDirectoryData(System.Reflection.PortableExecutable.DebugDirectoryEntry)">
      <summary>Lit les données vers lesquelles pointe l’entrée de répertoire de débogage spécifiée, et les interprète en tant qu’objet blob PDB Embedded Portable.</summary>
      <param name="entry">Entrée de répertoire de débogage dont les données doivent être lues.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="entry" /> n’est pas une entrée <see cref="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.EmbeddedPortablePdb" />.</exception>
      <exception cref="T:System.BadImageFormatException">Le format des données est incorrect.</exception>
      <exception cref="T:System.InvalidOperationException">L’image PE n’est pas disponible.</exception>
      <returns>Fournisseur d’un lecteur de métadonnées pour la lecture d’une image PDB Portable.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadPdbChecksumDebugDirectoryData(System.Reflection.PortableExecutable.DebugDirectoryEntry)">
      <summary>Lit les données vers lesquelles pointe l’entrée de répertoire de débogage spécifiée, et les interprète en tant qu’entrée de somme de contrôle PDB.</summary>
      <param name="entry">Entrée de répertoire de débogage dont les données doivent être lues.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="entry" /> n’est pas une entrée de somme de contrôle PDB.</exception>
      <exception cref="T:System.BadImageFormatException">Le format des données est incorrect.</exception>
      <exception cref="T:System.IO.IOException">Erreur d’E/S lors de la lecture à partir du flux sous-jacent.</exception>
      <exception cref="T:System.InvalidOperationException">L’image PE n’est pas disponible.</exception>
      <returns>Entrée de somme de contrôle PDB.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.TryOpenAssociatedPortablePdb(System.String,System.Func{System.String,System.IO.Stream},System.Reflection.Metadata.MetadataReaderProvider@,System.String@)">
      <summary>Ouvre un fichier PDB Portable associé à cette image PE.</summary>
      <param name="peImagePath">Chemin de l’image PE. Le chemin est utilisé pour localiser le fichier PDB situé dans le répertoire contenant le fichier PE.</param>
      <param name="pdbFileStreamProvider">S’il est spécifié, il est appelé pour ouvrir un <see cref="T:System.IO.Stream" /> pour un chemin de fichier donné. Le fournisseur doit retourner un <see cref="T:System.IO.Stream" /> lisible et pouvant être recherché, ou <see langword="null" /> si le fichier cible n’existe pas ou s’il doit être ignoré pour une raison quelconque. Le fournisseur doit lever <see cref="T:System.IO.IOException" /> s’il ne parvient pas à ouvrir le fichier en raison d’une erreur d’E/S inattendue.</param>
      <param name="pdbReaderProvider">En cas de réussite, nouvelle instance de <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> à utiliser pour lire le fichier PDB Portable.</param>
      <param name="pdbPath">En cas de réussite et si le fichier PDB est trouvé dans un fichier, chemin du fichier, ou <see langword="null" /> si le fichier PDB est incorporé dans l’image PE elle-même.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peImagePath" /> ou <paramref name="pdbFileStreamProvider" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Le flux retourné par <paramref name="pdbFileStreamProvider" /> ne prend pas en charge les opérations de lecture et de recherche.</exception>
      <exception cref="T:System.BadImageFormatException">Aucun fichier PDB correspondant n’a été trouvé en raison d’une erreur : l’image PE ou le PDB n’est pas valide.</exception>
      <exception cref="T:System.IO.IOException">Aucun fichier PDB correspondant n’a été trouvé en raison d’une erreur : une erreur d’e/s s’est produite lors de la lecture de l’image PE ou du fichier PDB.</exception>
      <returns>
        <see langword="true" /> Si un fichier PDB est associé à l’image PE et que ce fichier PDB a été ouvert avec succès ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.HasMetadata">
      <summary>Obtient une valeur qui indique si l’image PE contient des métadonnées CLI.</summary>
      <exception cref="T:System.BadImageFormatException">Les en-têtes PE contiennent des données non valides.</exception>
      <exception cref="T:System.IO.IOException">Erreur lors de la lecture à partir du flux sous-jacent.</exception>
      <returns>
        <see langword="true" /> Si l’image PE contient des métadonnées CLI ; Sinon, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.IsEntireImageAvailable">
      <summary>Obtient une valeur qui indique si le lecteur peut accéder à la totalité de l’image PE.</summary>
      <returns>
        <see langword="true" /> Si le lecteur peut accéder à l’intégralité de l’image PE ; Sinon, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.IsLoadedImage">
      <summary>Obtient une valeur qui indique si l’image PE a été chargée en mémoire par le chargeur du système d’exploitation.</summary>
      <returns>
        <see langword="true" /> si l’image PE a été chargée en mémoire par le chargeur du système d’exploitation ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.PEHeaders">
      <summary>Obtient les en-têtes PE.</summary>
      <exception cref="T:System.BadImageFormatException">Les en-têtes contiennent des données non valides.</exception>
      <exception cref="T:System.IO.IOException">Erreur lors de la lecture du flux.</exception>
      <returns>En-têtes PE pour cette image PE.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEStreamOptions">
      <summary>Fournit des options qui spécifient comment les sections d’une image PE sont lues à partir d’un flux.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.Default">
      <summary>Par défaut, le flux est supprimé lorsque <see cref="T:System.Reflection.PortableExecutable.PEReader" /> est supprimé et que les sections de l’image PE sont lues de manière différée.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.IsLoadedImage">
      <summary>Indique que l’image PE sous-jacente a été chargée en mémoire par le chargeur du système d’exploitation.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen">
      <summary>Conserve le flux ouvert lorsque le <see cref="T:System.Reflection.PortableExecutable.PEReader" /> est supprimé.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchEntireImage">
      <summary>Lit immédiatement l’intégralité de l’image en mémoire. <see cref="T:System.Reflection.PortableExecutable.PEReader" /> ferme automatiquement le flux au moment où le constructeur retourne une valeur, sauf si <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen" /> est spécifié.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata">
      <summary>
        <para>Lit immédiatement la section des métadonnées en mémoire.</para>
        <para>La lecture à partir d’autres sections du fichier n’est pas autorisée (l’exception <see cref="T:System.InvalidOperationException" /> est levée par <see cref="T:System.Reflection.PortableExecutable.PEReader" />).</para>
        <para>
          <see cref="T:System.Reflection.PortableExecutable.PEReader" /> ferme automatiquement le flux au moment où le constructeur retourne une valeur, sauf si <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen" /> est spécifié. Le fichier sous-jacent peut être fermé et même supprimé une fois <see cref="T:System.Reflection.PortableExecutable.PEReader" /> construit.</para>
      </summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.ResourceSectionBuilder">
      <summary>Définit la classe de base pour un générateur de section de ressources PE. Dérivez de <see cref="T:System.Reflection.PortableExecutable.ResourceSectionBuilder" /> afin de fournir une logique de sérialisation pour les ressources natives.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.ResourceSectionBuilder.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Reflection.PortableExecutable.ResourceSectionBuilder" />.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.ResourceSectionBuilder.Serialize(System.Reflection.Metadata.BlobBuilder,System.Reflection.PortableExecutable.SectionLocation)">
      <summary>Sérialise la ressource spécifiée.</summary>
      <param name="builder">Objet blob contenant les données à sérialiser.</param>
      <param name="location">Emplacement vers lequel sérialiser <paramref name="builder" />.</param>
    </member>
    <member name="T:System.Reflection.PortableExecutable.SectionCharacteristics" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align1024Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align128Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align16Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align1Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align2048Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align256Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align2Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align32Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align4096Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align4Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align512Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align64Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align8192Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align8Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.AlignMask" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.ContainsCode" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.ContainsInitializedData" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.ContainsUninitializedData" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.GPRel" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerComdat" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerInfo" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerNRelocOvfl" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerOther" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerRemove" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Mem16Bit" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemDiscardable" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemExecute" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemFardata" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemLocked" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemNotCached" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemNotPaged" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemPreload" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemProtected" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemPurgeable" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemRead" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemShared" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemSysheap" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemWrite" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.NoDeferSpecExc" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeCopy" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeDSect" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeGroup" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeNoLoad" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeNoPad" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeOver" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeReg" />
    <member name="T:System.Reflection.PortableExecutable.SectionHeader">
      <summary>Fournit des informations sur l’en-tête de section d’un fichier PE/COFF.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.Name">
      <summary>Obtient le nom de la section.</summary>
      <returns>Nom de la section.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.NumberOfLineNumbers">
      <summary>Obtient le nombre d’entrées de numéro de ligne pour la section.</summary>
      <returns>Nombre d’entrées de numéro de ligne pour la section.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.NumberOfRelocations">
      <summary>Obtient le nombre d’entrées de réadressage pour la section.</summary>
      <returns>Nombre d’entrées de réadressage pour la section. Sa valeur est zéro pour les images PE.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToLineNumbers">
      <summary>Obtient le pointeur de fichier vers le début des entrées de numéro de ligne pour la section.</summary>
      <returns>Pointeur de fichier vers le début des entrées de numéro de ligne pour la section, ou zéro s’il n’y a pas de numéros de ligne COFF.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToRawData">
      <summary>Obtient le pointeur de fichier vers la première page de la section dans le fichier COFF.</summary>
      <returns>Pointeur de fichier vers la première page de la section dans le fichier COFF.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToRelocations">
      <summary>Obtient le pointeur de fichier vers le début des entrées de réadressage pour la section.</summary>
      <returns>Pointeur de fichier vers le début des entrées de réadressage pour la section. Il a la valeur zéro pour les images PE ou s’il n’y a pas de réadressages.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.SectionCharacteristics">
      <summary>Obtient les indicateurs qui décrivent les caractéristiques de la section.</summary>
      <returns>Indicateurs qui décrivent les caractéristiques de la section.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.SizeOfRawData">
      <summary>Obtient la taille de la section (pour les fichiers objets) ou la taille des données initialisées sur le disque (pour les fichiers image).</summary>
      <returns>La taille de la section (pour les fichiers objets) ou la taille des données initialisées sur le disque (pour les fichiers image).</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.VirtualAddress">
      <summary>Obtient l’adresse virtuelle de la section.</summary>
      <returns>Adresse virtuelle de la section.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.VirtualSize">
      <summary>Obtient la taille totale de la section quand elle est chargée en mémoire.</summary>
      <returns>Taille totale de la section lorsqu’elle est chargée en mémoire.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.SectionLocation" />
    <member name="M:System.Reflection.PortableExecutable.SectionLocation.#ctor(System.Int32,System.Int32)">
      <param name="relativeVirtualAddress" />
      <param name="pointerToRawData" />
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionLocation.PointerToRawData" />
    <member name="P:System.Reflection.PortableExecutable.SectionLocation.RelativeVirtualAddress" />
    <member name="T:System.Reflection.PortableExecutable.Subsystem">
      <summary>Décrit la configuration requise du sous-système pour l’image.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiApplication">
      <summary>Application EFI (Extensible Firmware Interface).</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiBootServiceDriver">
      <summary>Pilote EFI avec services de démarrage.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiRom">
      <summary>Image ROM EFI.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiRuntimeDriver">
      <summary>Pilote EFI avec services de runtime.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.Native">
      <summary>L’image n’a pas besoin d’un sous-système.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.NativeWindows">
      <summary>L’image est un pilote Win9x natif.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.OS2Cui">
      <summary>L’image s’exécute dans le sous-système de caractères OS/2.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.PosixCui">
      <summary>L’image s’exécute dans le sous-système de caractères POSIX.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.Unknown">
      <summary>Sous-système inconnu.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsBootApplication">
      <summary>Application de démarrage.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsCEGui">
      <summary>L’image s’exécute dans le sous-système Windows CE.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsCui">
      <summary>L’image s’exécute dans le sous-système de caractères Windows.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsGui">
      <summary>L’image s’exécute dans le sous-système Windows GUI.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.Xbox">
      <summary>Système Xbox.</summary>
    </member>
  </members>
</doc>