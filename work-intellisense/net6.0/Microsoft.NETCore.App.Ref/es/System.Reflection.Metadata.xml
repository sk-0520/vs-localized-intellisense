<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Reflection.Metadata</name>
  </assembly>
  <members>
    <member name="T:System.Reflection.AssemblyFlags" />
    <member name="F:System.Reflection.AssemblyFlags.ContentTypeMask">
      <summary>Bits enmascarados de tipo de contenido que corresponden a los valores de <see cref="T:System.Reflection.AssemblyContentType" />.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.DisableJitCompileOptimizer">
      <summary>La optimización del compilador Just-In-Time (JIT) está deshabilitada para el ensamblado.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.EnableJitCompileTracking">
      <summary>El seguimiento del compilador Just-In-Time (JIT) está habilitado para el ensamblado.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.PublicKey">
      <summary>La referencia de ensamblado contiene la clave pública completa (sin hash). No es aplicable en la definición de ensamblado.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.Retargetable">
      <summary>No se espera que la implementación del ensamblado al que se hace referencia usado en tiempo de ejecución coincida con la versión que se ha visto en tiempo de compilación.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.WindowsRuntime">
      <summary>El ensamblado contiene código de Windows Runtime.</summary>
    </member>
    <member name="T:System.Reflection.AssemblyHashAlgorithm">
      <summary>Especifica los algoritmos hash utilizados para la creación de hash de archivos de ensamblado y para la generación del nombre seguro.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.MD5">
      <summary>Recupera el algoritmo de la síntesis de mensaje MD5.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.None">
      <summary>Máscara que indica que no hay ningún algoritmo hash.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha1">
      <summary>Recupera una revisión del algoritmo hash seguro (SHA) que corrige un defecto no publicado en SHA.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha256">
      <summary>Recupera una versión del algoritmo hash seguro (SHA) con un tamaño de hash de 256 bits.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha384">
      <summary>Recupera una versión del algoritmo hash seguro (SHA) con un tamaño de hash de 384 bits.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha512">
      <summary>Recupera una versión del algoritmo hash seguro (SHA) con un tamaño de hash de 512 bits.</summary>
    </member>
    <member name="T:System.Reflection.DeclarativeSecurityAction">
      <summary>Especifica las acciones de seguridad que se pueden realizar mediante la seguridad declarativa.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.Assert">
      <summary>El código de llamada puede tener acceso al recurso identificado por el objeto de permiso actual, incluso si los autores de llamada que se encuentran en la parte superior de la pila no tienen permiso de acceso al recurso.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.Demand">
      <summary>Comprueba que a todos los autores de llamada de la cadena de llamadas se les ha concedido el permiso especificado.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.Deny">
      <summary>Sin más comprobaciones, rechaza la demanda del permiso especificado.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.InheritanceDemand">
      <summary>Se requiere que la clase derivada que hereda la clase o que invalida un método tenga el permiso especificado.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.LinkDemand">
      <summary>Comprueba que se ha concedido el permiso especificado al autor de llamada inmediato.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.None">
      <summary>Ninguna acción de seguridad declarativa.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.PermitOnly">
      <summary>Sin más comprobaciones, rechaza la demanda de todos los permisos excepto los especificados.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.RequestMinimum">
      <summary>Solicita los permisos mínimos necesarios para que se ejecute el código. Esta acción solo se puede usar en el ámbito del ensamblado.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.RequestOptional">
      <summary>Solicita permisos adicionales que son opcionales (no es necesaria la ejecución). Esta solicitud rechaza implícitamente todos los demás permisos no solicitados específicamente. Esta acción solo se puede usar en el ámbito del ensamblado.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.RequestRefuse">
      <summary>Solicita que al código de llamada no se le concedan permisos que se puedan usar indebidamente. Esta acción solo se puede usar en el ámbito del ensamblado.</summary>
    </member>
    <member name="T:System.Reflection.ManifestResourceAttributes" />
    <member name="F:System.Reflection.ManifestResourceAttributes.Private">
      <summary>El recurso no se exporta desde el ensamblado.</summary>
    </member>
    <member name="F:System.Reflection.ManifestResourceAttributes.Public">
      <summary>El recurso se exporta desde el ensamblado.</summary>
    </member>
    <member name="F:System.Reflection.ManifestResourceAttributes.VisibilityMask">
      <summary>Enmascara solo los atributos relacionados con la visibilidad.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ArrayShape">
      <summary>Representa la forma de un tipo de matriz.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ArrayShape.#ctor(System.Int32,System.Collections.Immutable.ImmutableArray{System.Int32},System.Collections.Immutable.ImmutableArray{System.Int32})">
      <summary>Inicializa una nueva instancia de la estructura <see cref="T:System.Reflection.Metadata.ArrayShape" />.</summary>
      <param name="rank">Número de dimensiones de la matriz.</param>
      <param name="sizes">Tamaño de cada dimensión.</param>
      <param name="lowerBounds">Límite inferior de cada dimensión.</param>
    </member>
    <member name="P:System.Reflection.Metadata.ArrayShape.LowerBounds">
      <summary>Obtiene los límites inferiores de todas las dimensiones. La longitud puede ser menor que el rango, en cuyo caso las dimensiones finales tienen límites inferiores sin especificar.</summary>
      <returns>Matriz de límites inferiores.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ArrayShape.Rank">
      <summary>Obtiene el número de dimensiones de la matriz.</summary>
      <returns>Número de dimensiones.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ArrayShape.Sizes">
      <summary>Obtiene los tamaños de todas las dimensiones.</summary>
      <returns>Matriz de tamaños.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyDefinition" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinition.GetAssemblyName" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinition.GetDeclarativeSecurityAttributes" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Culture" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Flags" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.HashAlgorithm" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Name" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.PublicKey" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Version" />
    <member name="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.Equals(System.Reflection.Metadata.AssemblyDefinitionHandle)">
      <summary>Indica si el objeto actual es igual a otro objeto del mismo tipo.</summary>
      <param name="other">Objeto que se va a comparar con este objeto.</param>
      <returns>
        <see langword="true" /> si el objeto actual es igual al parámetro <paramref name="other" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Equality(System.Reflection.Metadata.AssemblyDefinitionHandle,System.Reflection.Metadata.AssemblyDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.AssemblyDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.AssemblyDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Implicit(System.Reflection.Metadata.AssemblyDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Implicit(System.Reflection.Metadata.AssemblyDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Inequality(System.Reflection.Metadata.AssemblyDefinitionHandle,System.Reflection.Metadata.AssemblyDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.AssemblyFile" />
    <member name="M:System.Reflection.Metadata.AssemblyFile.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.AssemblyFile.ContainsMetadata">
      <summary>Obtiene un valor que indica si el archivo contiene metadatos.</summary>
      <returns>
        <see langword="true" /> Si el archivo contiene metadatos; de <see langword="false" /> lo contrario,.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFile.HashValue">
      <summary>Obtiene el valor de hash del contenido del archivo que se calcula con <see cref="P:System.Reflection.Metadata.AssemblyDefinition.HashAlgorithm" />.</summary>
      <returns>
        <see cref="T:System.Reflection.Metadata.BlobHandle" />Instancia de que representa el valor hash del contenido del archivo.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFile.Name">
      <summary>Obtiene el nombre del archivo, incluida su extensión.</summary>
      <returns>
        <see cref="T:System.Reflection.Metadata.StringHandle" />Instancia de que representa el nombre de archivo con su extensión.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyFileHandle" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.Equals(System.Reflection.Metadata.AssemblyFileHandle)">
      <summary>Indica si el objeto actual es igual a otro objeto del mismo tipo.</summary>
      <param name="other">Objeto que se va a comparar con este objeto.</param>
      <returns>
        <see langword="true" /> si el objeto actual es igual al parámetro <paramref name="other" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Equality(System.Reflection.Metadata.AssemblyFileHandle,System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.AssemblyFileHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.AssemblyFileHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Implicit(System.Reflection.Metadata.AssemblyFileHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Implicit(System.Reflection.Metadata.AssemblyFileHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Inequality(System.Reflection.Metadata.AssemblyFileHandle,System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFileHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.AssemblyFileHandleCollection">
      <summary>Representa una colección de <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#AssemblyFileHandle}#GetEnumerator">
      <summary>Devuelve un enumerador que procesa una iteración en la colección.</summary>
      <returns>Enumerador que se puede utilizar para recorrer en iteración la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Devuelve un enumerador que recorre en iteración una colección.</summary>
      <returns>Objeto <see cref="T:System.Collections.IEnumerator" /> que puede usarse para recorrer en iteración la colección.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFileHandleCollection.Count">
      <summary>Obtiene el número de elementos de la colección.</summary>
      <returns>Número de elementos de la colección.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.MoveNext">
      <summary>Desplaza el enumerador al siguiente elemento de la colección.</summary>
      <returns>Es <see langword="true" /> si el enumerador avanzó con éxito hasta el siguiente elemento; es <see langword="false" /> si el enumerador alcanzó el final de la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Establece el enumerador en su posición inicial (antes del primer elemento de la colección).</summary>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tareas definidas por la aplicación asociadas a la liberación o al restablecimiento de recursos no administrados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyReference" />
    <member name="M:System.Reflection.Metadata.AssemblyReference.GetAssemblyName" />
    <member name="M:System.Reflection.Metadata.AssemblyReference.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Culture" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Flags" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.HashValue" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Name" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.PublicKeyOrToken" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Version" />
    <member name="T:System.Reflection.Metadata.AssemblyReferenceHandle" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.Equals(System.Reflection.Metadata.AssemblyReferenceHandle)">
      <summary>Indica si el objeto actual es igual a otro objeto del mismo tipo.</summary>
      <param name="other">Objeto que se va a comparar con este objeto.</param>
      <returns>
        <see langword="true" /> si el objeto actual es igual al parámetro <paramref name="other" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Equality(System.Reflection.Metadata.AssemblyReferenceHandle,System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.AssemblyReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.AssemblyReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Implicit(System.Reflection.Metadata.AssemblyReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Implicit(System.Reflection.Metadata.AssemblyReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Inequality(System.Reflection.Metadata.AssemblyReferenceHandle,System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.AssemblyReferenceHandleCollection">
      <summary>Colección de referencias del ensamblado.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#AssemblyReferenceHandle}#GetEnumerator">
      <summary>Devuelve un enumerador que procesa una iteración en la colección.</summary>
      <returns>Enumerador que se puede utilizar para recorrer en iteración la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Devuelve un enumerador que recorre en iteración una colección.</summary>
      <returns>Objeto <see cref="T:System.Collections.IEnumerator" /> que puede usarse para recorrer en iteración la colección.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Count">
      <summary>Obtiene el número de elementos de la colección.</summary>
      <returns>Número de elementos de la colección.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.MoveNext">
      <summary>Desplaza el enumerador al siguiente elemento de la colección.</summary>
      <returns>Es <see langword="true" /> si el enumerador avanzó con éxito hasta el siguiente elemento; es <see langword="false" /> si el enumerador alcanzó el final de la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Establece el enumerador en su posición inicial (antes del primer elemento de la colección).</summary>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tareas definidas por la aplicación asociadas a la liberación o al restablecimiento de recursos no administrados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Blob" />
    <member name="M:System.Reflection.Metadata.Blob.GetBytes" />
    <member name="P:System.Reflection.Metadata.Blob.IsDefault" />
    <member name="P:System.Reflection.Metadata.Blob.Length" />
    <member name="T:System.Reflection.Metadata.BlobBuilder" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.#ctor(System.Int32)">
      <param name="capacity" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Align(System.Int32)">
      <param name="alignment" />
      <exception cref="T:System.InvalidOperationException">El generador no es modificable; se ha vinculado con otro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.AllocateChunk(System.Int32)">
      <param name="minimalSize" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Clear" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.ContentEquals(System.Reflection.Metadata.BlobBuilder)">
      <summary>Compara el contenido actual de este sistema de escritura con otro.</summary>
      <param name="other">Instancia de <see cref="T:System.Reflection.Metadata.BlobBuilder" /> para compararla con esta.</param>
      <exception cref="T:System.InvalidOperationException">El contenido no está disponible; el generador se ha vinculado con otro.</exception>
      <returns>
        <see langword="true" /> si son iguales; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Free" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.FreeChunk" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.GetBlobs">
      <summary>Devuelve una secuencia de todos los blobs que representan el contenido del generador.</summary>
      <exception cref="T:System.InvalidOperationException">El contenido no está disponible; el generador se ha vinculado con otro.</exception>
      <returns>Secuencia de blobs.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.LinkPrefix(System.Reflection.Metadata.BlobBuilder)">
      <param name="prefix" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="prefix" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">El generador no es modificable; se ha vinculado con otro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.LinkSuffix(System.Reflection.Metadata.BlobBuilder)">
      <param name="suffix" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="suffix" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">El generador no es modificable; se ha vinculado con otro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.PadTo(System.Int32)">
      <param name="position" />
      <exception cref="T:System.InvalidOperationException">El generador no es modificable; se ha vinculado con otro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ReserveBytes(System.Int32)">
      <summary>Reserva un bloque contiguo de bytes.</summary>
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> es negativo.</exception>
      <exception cref="T:System.InvalidOperationException">El generador no es modificable; se ha vinculado con otro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToArray">
      <exception cref="T:System.InvalidOperationException">El contenido no está disponible; el generador se ha vinculado con otro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToArray(System.Int32,System.Int32)">
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">El intervalo especificado por <paramref name="start" /> y <paramref name="byteCount" /> está fuera de los límites del contenido del búfer.</exception>
      <exception cref="T:System.InvalidOperationException">El contenido no está disponible; el generador se ha vinculado con otro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToImmutableArray">
      <exception cref="T:System.InvalidOperationException">El contenido no está disponible; el generador se ha vinculado con otro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToImmutableArray(System.Int32,System.Int32)">
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">El intervalo especificado por <paramref name="start" /> y <paramref name="byteCount" /> está fuera de los límites del contenido del búfer.</exception>
      <exception cref="T:System.InvalidOperationException">El contenido no está disponible; el generador se ha vinculado con otro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.TryWriteBytes(System.IO.Stream,System.Int32)">
      <summary>Intenta escribir una secuencia de bytes en el generador. Un valor devuelto indica el número de bytes escritos correctamente.</summary>
      <param name="source" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> es negativo.</exception>
      <exception cref="T:System.InvalidOperationException">El generador no es modificable; se ha vinculado con otro.</exception>
      <returns>Número de bytes escritos correctamente desde <paramref name="source" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBoolean(System.Boolean)">
      <summary>Escribe un valor <see cref="T:System.Boolean" /> en el generador.</summary>
      <param name="value">Valor que se va a escribir.</param>
      <exception cref="T:System.InvalidOperationException">El generador no es modificable; se ha vinculado con otro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteByte(System.Byte)">
      <summary>Escribe un valor <see cref="T:System.Byte" /> en el generador.</summary>
      <param name="value">Valor que se va a escribir.</param>
      <exception cref="T:System.InvalidOperationException">El generador no es modificable; se ha vinculado con otro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte*,System.Int32)">
      <summary>Escribe un número especificado de bytes desde un búfer en el generador.</summary>
      <param name="buffer" />
      <param name="byteCount">Número de bytes que se van a escribir.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> es negativo.</exception>
      <exception cref="T:System.InvalidOperationException">El generador no es modificable, se ha vinculado con otro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte,System.Int32)">
      <summary>Escribe un número especificado de apariciones de un valor de bytes en el generador.</summary>
      <param name="value" />
      <param name="byteCount">Número de repeticiones de <paramref name="value" /> que se va a escribir.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> es negativo.</exception>
      <exception cref="T:System.InvalidOperationException">El generador no es modificable, se ha vinculado con otro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte[])">
      <summary>Escribe el contenido de una matriz de bytes en el generador.</summary>
      <param name="buffer">Matriz de bytes que se va a escribir.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">El generador no es modificable; se ha vinculado con otro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte[],System.Int32,System.Int32)">
      <summary>Escribe un número especificado de bytes a partir de un índice especificado en una matriz de bytes en el generador.</summary>
      <param name="buffer" />
      <param name="start" />
      <param name="byteCount">Número de bytes que se van a escribir.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">El intervalo especificado por <paramref name="start" /> y <paramref name="byteCount" /> está fuera de los límites de <paramref name="buffer" />.</exception>
      <exception cref="T:System.InvalidOperationException">El generador no es modificable; se ha vinculado con otro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>Escribe el contenido de una matriz de bytes inmutable en el generador.</summary>
      <param name="buffer">Matriz que se va a escribir.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">El generador no es modificable; se ha vinculado con otro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte},System.Int32,System.Int32)">
      <summary>Escribe un número especificado de bytes a partir de un índice especificado de una matriz inmutable en el generador.</summary>
      <param name="buffer" />
      <param name="start" />
      <param name="byteCount">Número de bytes que se van a escribir.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">El intervalo especificado por <paramref name="start" /> y <paramref name="byteCount" /> está fuera de los límites de <paramref name="buffer" />.</exception>
      <exception cref="T:System.InvalidOperationException">El generador no es modificable; se ha vinculado con otro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteCompressedInteger(System.Int32)">
      <summary>Implementa la codificación de enteros sin signo comprimidos tal y como se define en el capítulo 23,2 de ECMA-335-II: blobs y firmas.</summary>
      <param name="value">Valor que se va a escribir.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="value" /> no se puede representar como un entero sin signo comprimido.</exception>
      <exception cref="T:System.InvalidOperationException">El generador no es modificable; se ha vinculado con otro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteCompressedSignedInteger(System.Int32)">
      <summary>Implementa la codificación de enteros con signo comprimidos tal y como se define en el capítulo 23,2 de ECMA-335-II: blobs y firmas.</summary>
      <param name="value">Valor que se va a escribir.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="value" /> no se puede representar como un entero con signo comprimido.</exception>
      <exception cref="T:System.InvalidOperationException">El generador no es modificable; se ha vinculado con otro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteConstant(System.Object)">
      <summary>Escribe un valor constante (vea la sección 22.9 de ECMA-335 Partition II) en la posición actual.</summary>
      <param name="value">Valor constante que se va a escribir.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="value" /> no es un tipo constante.</exception>
      <exception cref="T:System.InvalidOperationException">El generador no es modificable; se ha vinculado con otro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteContentTo(System.IO.Stream)">
      <param name="destination" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="destination" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">El contenido no está disponible, el generador se ha vinculado con otro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteContentTo(System.Reflection.Metadata.BlobBuilder)">
      <param name="destination" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="destination" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">El contenido no está disponible, el generador se ha vinculado con otro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteContentTo(System.Reflection.Metadata.BlobWriter@)">
      <param name="destination" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="destination" /> es el valor predeterminado (<see cref="T:System.Reflection.Metadata.BlobWriter" />).</exception>
      <exception cref="T:System.InvalidOperationException">El contenido no está disponible, el generador se ha vinculado con otro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteDateTime(System.DateTime)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">El generador no es modificable, se ha vinculado con otro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteDecimal(System.Decimal)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">El generador no es modificable, se ha vinculado con otro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteDouble(System.Double)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">El generador no es modificable, se ha vinculado con otro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteGuid(System.Guid)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">El generador no es modificable, se ha vinculado con otro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt16(System.Int16)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">El generador no es modificable, se ha vinculado con otro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt16BE(System.Int16)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">El generador no es modificable, se ha vinculado con otro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt32(System.Int32)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">El generador no es modificable, se ha vinculado con otro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt32BE(System.Int32)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">El generador no es modificable, se ha vinculado con otro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt64(System.Int64)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">El generador no es modificable, se ha vinculado con otro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteReference(System.Int32,System.Boolean)">
      <summary>Escribe una referencia en un montón (desplazamiento de montón) o una tabla (número de fila).</summary>
      <param name="reference">Número de fila de tabla o desplazamiento de montón.</param>
      <param name="isSmall">
        <see langword="true" /> para codificar la referencia como un entero de 16 bits; <see langword="false" /> para codificarla como un entero de 32 bits.</param>
      <exception cref="T:System.InvalidOperationException">El generador no es modificable, se ha vinculado con otro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteSByte(System.SByte)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">El generador no es modificable, se ha vinculado con otro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteSerializedString(System.String)">
      <summary>Escribe una cadena en formato SerString (vea ECMA-335-II 23.3 Custom attributes).</summary>
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">El generador no es modificable, se ha vinculado con otro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteSingle(System.Single)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">El generador no es modificable, se ha vinculado con otro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt16(System.UInt16)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">El generador no es modificable, se ha vinculado con otro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt16BE(System.UInt16)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">El generador no es modificable, se ha vinculado con otro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt32(System.UInt32)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">El generador no es modificable, se ha vinculado con otro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt32BE(System.UInt32)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">El generador no es modificable, se ha vinculado con otro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt64(System.UInt64)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">El generador no es modificable, se ha vinculado con otro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUserString(System.String)">
      <summary>Escribe una cadena en formato de montón de cadena de usuario (#US) (vea ECMA-335-II 24.2.4 #US and #Blob heaps).</summary>
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">El generador no es modificable, se ha vinculado con otro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUTF16(System.Char[])">
      <summary>Escribe una matriz de caracteres codificados en UTF16 (little-endian) en la posición actual.</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">El generador no es modificable, se ha vinculado con otro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUTF16(System.String)">
      <summary>Escribe una cadena codificada en UTF16 (little-endian) en la posición actual.</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">El generador no es modificable, se ha vinculado con otro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUTF8(System.String,System.Boolean)">
      <summary>Escribe una cadena codificada en UTF8 en la posición actual.</summary>
      <param name="value">Valor constante.</param>
      <param name="allowUnpairedSurrogates">
        <see langword="true" /> para codificar suplentes sin asociar tal como se especifica; <see langword="false" /> para reemplazarlos por un carácter U+FFFD.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">El generador no es modificable, se ha vinculado con otro.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.BlobBuilder.ChunkCapacity" />
    <member name="P:System.Reflection.Metadata.BlobBuilder.Count" />
    <member name="P:System.Reflection.Metadata.BlobBuilder.FreeBytes" />
    <member name="T:System.Reflection.Metadata.BlobBuilder.Blobs" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.MoveNext">
      <summary>Desplaza el enumerador al siguiente elemento de la colección.</summary>
      <returns>Es <see langword="true" /> si el enumerador avanzó con éxito hasta el siguiente elemento; es <see langword="false" /> si el enumerador alcanzó el final de la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.Reset">
      <summary>Establece el enumerador en su posición inicial (antes del primer elemento de la colección).</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#Blob}#GetEnumerator">
      <summary>Devuelve un enumerador que procesa una iteración en la colección.</summary>
      <returns>Enumerador que se puede utilizar para recorrer en iteración la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.System#Collections#IEnumerable#GetEnumerator">
      <summary>Devuelve un enumerador que recorre en iteración una colección.</summary>
      <returns>Objeto <see cref="T:System.Collections.IEnumerator" /> que puede usarse para recorrer en iteración la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.System#IDisposable#Dispose">
      <summary>Realiza tareas definidas por la aplicación asociadas a la liberación o al restablecimiento de recursos no administrados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.BlobBuilder.Blobs.Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.BlobBuilder.Blobs.System#Collections#IEnumerator#Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.BlobContentId" />
    <member name="M:System.Reflection.Metadata.BlobContentId.#ctor(System.Byte[])">
      <param name="id" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.#ctor(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="id" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.#ctor(System.Guid,System.UInt32)">
      <param name="guid" />
      <param name="stamp" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.Equals(System.Reflection.Metadata.BlobContentId)">
      <summary>Indica si el objeto actual es igual a otro objeto del mismo tipo.</summary>
      <param name="other">Objeto que se va a comparar con este objeto.</param>
      <returns>
        <see langword="true" /> si el objeto actual es igual al parámetro <paramref name="other" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.FromHash(System.Byte[])">
      <param name="hashCode" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.FromHash(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="hashCode" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.GetHashCode" />
    <member name="M:System.Reflection.Metadata.BlobContentId.GetTimeBasedProvider" />
    <member name="M:System.Reflection.Metadata.BlobContentId.op_Equality(System.Reflection.Metadata.BlobContentId,System.Reflection.Metadata.BlobContentId)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.op_Inequality(System.Reflection.Metadata.BlobContentId,System.Reflection.Metadata.BlobContentId)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.BlobContentId.Guid" />
    <member name="P:System.Reflection.Metadata.BlobContentId.IsDefault" />
    <member name="P:System.Reflection.Metadata.BlobContentId.Stamp" />
    <member name="T:System.Reflection.Metadata.BlobHandle" />
    <member name="M:System.Reflection.Metadata.BlobHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.Equals(System.Reflection.Metadata.BlobHandle)">
      <summary>Indica si el objeto actual es igual a otro objeto del mismo tipo.</summary>
      <param name="other">Objeto que se va a comparar con este objeto.</param>
      <returns>
        <see langword="true" /> si el objeto actual es igual al parámetro <paramref name="other" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Equality(System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.BlobHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.BlobHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Implicit(System.Reflection.Metadata.BlobHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Inequality(System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.BlobHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.BlobHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.BlobReader" />
    <member name="M:System.Reflection.Metadata.BlobReader.#ctor(System.Byte*,System.Int32)">
      <summary>Crea un lector del bloque de memoria especificado.</summary>
      <param name="buffer">Puntero al inicio del bloque de memoria.</param>
      <param name="length">Longitud en bytes del bloque de memoria.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> es <see langword="null" /> y <paramref name="length" /> es mayor que cero.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" /> es negativo.</exception>
      <exception cref="T:System.PlatformNotSupportedException">La plataforma actual no es little-endian.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.Align(System.Byte)">
      <summary>Cambia de posición del lector hacia adelante según el número de bytes necesarios para satisfacer la alineación especificada.</summary>
      <param name="alignment" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.IndexOf(System.Byte)">
      <summary>Busca un byte especificado en el blob siguiente a la posición actual.</summary>
      <param name="value">Valor del byte que se buscará.</param>
      <returns>Índice relativo a la posición actual, o -1 si el byte no se encuentra en el blob siguiente a la posición actual.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBlobHandle">
      <summary>Lee un controlador de montón de blobs codificado como un entero comprimido.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBoolean" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadByte" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBytes(System.Int32)">
      <summary>Lee los bytes a partir de la posición actual.</summary>
      <param name="byteCount">Número de bytes que se va a leer.</param>
      <exception cref="T:System.BadImageFormatException">
        <paramref name="byteCount" /> bytes no están disponibles.</exception>
      <returns>Matriz de bytes.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBytes(System.Int32,System.Byte[],System.Int32)">
      <summary>Lee los bytes a partir de la posición actual y los escribe en el búfer especificado, comenzando en el desplazamiento especificado.</summary>
      <param name="byteCount">Número de bytes que se va a leer.</param>
      <param name="buffer">Búfer de destino en el que se escribirán los bytes leídos.</param>
      <param name="bufferOffset">Desplazamiento en el búfer de destino donde se escribirán los bytes leídos.</param>
      <exception cref="T:System.BadImageFormatException">
        <paramref name="byteCount" /> bytes no están disponibles.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadChar" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadCompressedInteger">
      <summary>Lee un valor entero comprimido sin signo. Consulte la sección II. 23.2 de la especificación de metadatos: blobs y firmas.</summary>
      <exception cref="T:System.BadImageFormatException">Los datos en la posición actual no son un entero comprimido válido.</exception>
      <returns>Valor del entero comprimido que se ha leído.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadCompressedSignedInteger">
      <summary>Lee un valor entero comprimido con signo. Consulte la sección II. 23.2 de la especificación de metadatos: blobs y firmas.</summary>
      <exception cref="T:System.BadImageFormatException">Los datos en la posición actual no son un entero comprimido válido.</exception>
      <returns>Valor del entero comprimido que se ha leído.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadConstant(System.Reflection.Metadata.ConstantTypeCode)">
      <summary>Lee un valor constante (consulte la sección 22.9 de ECMA-335 Partition II) desde la posición actual.</summary>
      <param name="typeCode" />
      <exception cref="T:System.BadImageFormatException">Error al leer el blob.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="typeCode" /> no es un <see cref="T:System.Reflection.Metadata.ConstantTypeCode" /> válido.</exception>
      <returns>Valor constante con conversión boxing. Para evitar la asignación el use métodos Read* directamente.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadDateTime" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadDecimal">
      <summary>Lee un número <see cref="T:System.Decimal" />.</summary>
      <exception cref="T:System.BadImageFormatException">Los datos en la posición actual no eran un número <see cref="T:System.Decimal" /> válido.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadDouble" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadGuid" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadInt16" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadInt32" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadInt64" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSByte" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSerializationTypeCode">
      <summary>Lee un código de tipo codificado en un valor de atributo personalizado serializado.</summary>
      <returns>
        <see cref="F:System.Reflection.Metadata.SerializationTypeCode.Invalid" /> si la codificación no es válida.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSerializedString">
      <summary>Lee una cadena codificada como un entero comprimido que contiene su longitud seguido de su contenido en UTF8. Las cadenas nulas se codifican como un solo byte de 0xFF.</summary>
      <exception cref="T:System.BadImageFormatException">La codificación no es válida.</exception>
      <returns>Valor de cadena o <see langword="null" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSignatureHeader" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSignatureTypeCode">
      <summary>Lee un código de tipo que se codifica en una firma.</summary>
      <returns>Código de tipo codificado en el valor del atributo personalizado serializado si la codificación es válida, o <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Invalid" /> si la codificación no es válida.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSingle" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadTypeHandle">
      <summary>Lee un controlador de tipo codificado en una firma como TypeDefOrRefOrSpecEncoded (consulte ECMA-335 II.23.2.8).</summary>
      <returns>Controlador cuando la codificación es válida. En caso contrario, controlador donde la propiedad <see cref="P:System.Reflection.Metadata.EntityHandle.IsNil" /> es <see langword="true" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUInt16" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUInt32" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUInt64" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUTF16(System.Int32)">
      <summary>Lee una cadena codificada en UTF16 (little-endian) a partir de la posición actual.</summary>
      <param name="byteCount">Número de bytes que se va a leer.</param>
      <exception cref="T:System.BadImageFormatException">
        <paramref name="byteCount" /> bytes no están disponibles.</exception>
      <returns>La cadena.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUTF8(System.Int32)">
      <summary>Lee una cadena codificada en UTF8 a partir de la posición actual.</summary>
      <param name="byteCount">Número de bytes que se va a leer.</param>
      <exception cref="T:System.BadImageFormatException">
        <paramref name="byteCount" /> bytes no están disponibles.</exception>
      <returns>La cadena.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.Reset">
      <summary>Cambia la posición del lector al inicio del bloque de memoria subyacente.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.TryReadCompressedInteger(System.Int32@)">
      <summary>Lee un valor entero comprimido sin signo. Consulte la sección II. 23.2 de la especificación de metadatos: blobs y firmas.</summary>
      <param name="value">Valor del entero comprimido que se ha leído.</param>
      <returns>
        <see langword="true" /> si el valor se leyó correctamente. <see langword="false" /> si los datos en la posición actual no son un entero comprimido válido.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.TryReadCompressedSignedInteger(System.Int32@)">
      <summary>Lee un valor entero comprimido con signo. Consulte la sección II. 23.2 de la especificación de metadatos: blobs y firmas.</summary>
      <param name="value">Valor del entero comprimido que se ha leído.</param>
      <returns>
        <see langword="true" /> si el valor se leyó correctamente. <see langword="false" /> si los datos en la posición actual no son un entero comprimido válido.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.CurrentPointer">
      <summary>Obtiene un puntero al byte en la posición actual del lector.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.Length">
      <summary>Obtiene la longitud total del bloque de memoria subyacente.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.Offset">
      <summary>Obtiene o establece el desplazamiento desde el principio del blob hasta la posición actual.</summary>
      <exception cref="T:System.BadImageFormatException">El desplazamiento se establece fuera de los límites del lector subyacente.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.RemainingBytes">
      <summary>Obtiene el número de bytes restantes desde la posición actual hasta el final del bloque de memoria subyacente.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.StartPointer">
      <summary>Obtiene un puntero al byte al inicio del bloque de memoria subyacente.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.BlobWriter" />
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Byte[])">
      <param name="buffer" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Byte[],System.Int32,System.Int32)">
      <param name="buffer" />
      <param name="start" />
      <param name="count" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Int32)">
      <param name="size" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Reflection.Metadata.Blob)">
      <param name="blob" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.Align(System.Int32)">
      <param name="alignment" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.Clear" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ContentEquals(System.Reflection.Metadata.BlobWriter)">
      <summary>Compara el contenido actual de este sistema de escritura con otro.</summary>
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.PadTo(System.Int32)">
      <param name="offset" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.ToArray" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ToArray(System.Int32,System.Int32)">
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">El intervalo especificado por <paramref name="start" /> y <paramref name="byteCount" /> está fuera de los límites del contenido del búfer.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.ToImmutableArray" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ToImmutableArray(System.Int32,System.Int32)">
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">Intervalo especificado por <paramref name="start" /> y <paramref name="byteCount" /> fuera de los límites del contenido del búfer.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBoolean(System.Boolean)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteByte(System.Byte)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte*,System.Int32)">
      <param name="buffer" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> es negativo.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte,System.Int32)">
      <param name="value" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> es negativo.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte[])">
      <param name="buffer" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte[],System.Int32,System.Int32)">
      <param name="buffer" />
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Intervalo especificado por <paramref name="start" /> y <paramref name="byteCount" /> fuera de los límites de <paramref name="buffer" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="buffer" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte},System.Int32,System.Int32)">
      <param name="buffer" />
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Intervalo especificado por <paramref name="start" /> y <paramref name="byteCount" /> fuera de los límites de <paramref name="buffer" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.IO.Stream,System.Int32)">
      <param name="source" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> es negativo.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Reflection.Metadata.BlobBuilder)">
      <param name="source" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteCompressedInteger(System.Int32)">
      <summary>Implementa la codificación de enteros sin signo comprimidos tal y como se define en el capítulo 23,2 de ECMA-335-II: blobs y firmas.</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="value" /> no se puede representar como un entero sin signo comprimido.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteCompressedSignedInteger(System.Int32)">
      <summary>Implementa la codificación de enteros con signo comprimidos tal y como se define en el capítulo 23,2 de ECMA-335-II: blobs y firmas.</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="value" /> no se puede representar como un entero con signo comprimido.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteConstant(System.Object)">
      <summary>Escribe un valor constante (vea la sección 22.9 de ECMA-335 Partition II) en la posición actual.</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentException">
        <paramref name="value" /> no es un tipo constante.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteDateTime(System.DateTime)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteDecimal(System.Decimal)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteDouble(System.Double)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteGuid(System.Guid)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt16(System.Int16)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt16BE(System.Int16)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt32(System.Int32)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt32BE(System.Int32)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt64(System.Int64)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteReference(System.Int32,System.Boolean)">
      <summary>Escribe una referencia en un montón (desplazamiento de montón) o una tabla (número de fila).</summary>
      <param name="reference">Número de fila de tabla o desplazamiento de montón.</param>
      <param name="isSmall">
        <see langword="true" /> para codificar la referencia como entero de 16 bits, <see langword="false" /> para codificarla como entero de 32 bits.</param>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteSByte(System.SByte)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteSerializedString(System.String)">
      <summary>Escribe una cadena en formato SerString (vea ECMA-335-II 23.3 Custom attributes).</summary>
      <param name="str" />
      <exception cref="T:System.InvalidOperationException">El generador no es modificable; se ha vinculado con otro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteSingle(System.Single)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt16(System.UInt16)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt16BE(System.UInt16)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt32(System.UInt32)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt32BE(System.UInt32)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt64(System.UInt64)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUserString(System.String)">
      <summary>Escribe una cadena en formato de montón de cadena de usuario (#US) (vea ECMA-335-II 24.2.4 #US and #Blob heaps).</summary>
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">El generador no es modificable, se ha vinculado con otro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUTF16(System.Char[])">
      <summary>Escribe una cadena codificada en UTF16 (little-endian) en la posición actual.</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUTF16(System.String)">
      <summary>Escribe una cadena codificada en UTF16 (little-endian) en la posición actual.</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUTF8(System.String,System.Boolean)">
      <summary>Escribe una cadena codificada en UTF8 en la posición actual.</summary>
      <param name="value" />
      <param name="allowUnpairedSurrogates" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> es <see langword="null" />.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.BlobWriter.Blob" />
    <member name="P:System.Reflection.Metadata.BlobWriter.Length" />
    <member name="P:System.Reflection.Metadata.BlobWriter.Offset" />
    <member name="P:System.Reflection.Metadata.BlobWriter.RemainingBytes" />
    <member name="T:System.Reflection.Metadata.Constant" />
    <member name="P:System.Reflection.Metadata.Constant.Parent">
      <summary>Obtiene el manipulador principal (<see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" /> o <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />).</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Constant.TypeCode">
      <summary>Obtiene un código de tipo que identifica el tipo del valor constante.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Constant.Value">
      <summary>Obtiene el valor constante.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ConstantHandle" />
    <member name="M:System.Reflection.Metadata.ConstantHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.Equals(System.Reflection.Metadata.ConstantHandle)">
      <summary>Indica si el objeto actual es igual a otro objeto del mismo tipo.</summary>
      <param name="other">Objeto que se va a comparar con este objeto.</param>
      <returns>
        <see langword="true" /> si el objeto actual es igual al parámetro <paramref name="other" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Equality(System.Reflection.Metadata.ConstantHandle,System.Reflection.Metadata.ConstantHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ConstantHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ConstantHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Implicit(System.Reflection.Metadata.ConstantHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Implicit(System.Reflection.Metadata.ConstantHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Inequality(System.Reflection.Metadata.ConstantHandle,System.Reflection.Metadata.ConstantHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.ConstantHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ConstantTypeCode">
      <summary>Especifica valores que representan tipos de constantes de metadatos.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Boolean">
      <summary>Tipo Boolean.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Byte">
      <summary>Entero de 1 bit sin signo.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Char">
      <summary>Tipo de carácter.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Double">
      <summary>Tipo de punto flotante de 8 bytes.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Int16">
      <summary>Tipo entero de 2 bytes con signo.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Int32">
      <summary>Tipo entero de 4 bytes con signo.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Int64">
      <summary>Tipo entero de 8 bytes con signo.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Invalid">
      <summary>Tipo no válido.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.NullReference">
      <summary>Referencia nula.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.SByte">
      <summary>Tipo entero de 1 byte con signo.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Single">
      <summary>Tipo de punto flotante de 4 bytes.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.String">
      <summary>Tipo <see cref="T:System.String" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.UInt16">
      <summary>Tipo entero de 2 bytes sin signo.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.UInt32">
      <summary>Tipo entero de 4 bytes sin signo.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.UInt64">
      <summary>Tipo entero de 8 bytes sin signo.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttribute" />
    <member name="M:System.Reflection.Metadata.CustomAttribute.DecodeValue``1(System.Reflection.Metadata.ICustomAttributeTypeProvider{``0})">
      <summary>Descodifica los argumentos codificados en el blob del valor.</summary>
      <param name="provider" />
      <typeparam name="TType" />
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttribute.Constructor">
      <summary>Obtiene el constructor (<see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> o <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />) del tipo de atributo personalizado.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttribute.Parent">
      <summary>Obtiene el controlador de la entidad de los metadatos donde se aplica el atributo.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttribute.Value">
      <summary>Obtiene el valor del atributo.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeHandle" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.Equals(System.Reflection.Metadata.CustomAttributeHandle)">
      <summary>Indica si el objeto actual es igual a otro objeto del mismo tipo.</summary>
      <param name="other">Objeto que se va a comparar con este objeto.</param>
      <returns>
        <see langword="true" /> si el objeto actual es igual al parámetro <paramref name="other" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Equality(System.Reflection.Metadata.CustomAttributeHandle,System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.CustomAttributeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.CustomAttributeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Implicit(System.Reflection.Metadata.CustomAttributeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Implicit(System.Reflection.Metadata.CustomAttributeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Inequality(System.Reflection.Metadata.CustomAttributeHandle,System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.CustomAttributeHandleCollection" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#CustomAttributeHandle}#GetEnumerator">
      <summary>Devuelve un enumerador que procesa una iteración en la colección.</summary>
      <returns>Enumerador que se puede utilizar para recorrer en iteración la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Devuelve un enumerador que recorre en iteración una colección.</summary>
      <returns>Objeto <see cref="T:System.Collections.IEnumerator" /> que puede usarse para recorrer en iteración la colección.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeHandleCollection.Count">
      <summary>Obtiene el número de elementos de la colección.</summary>
      <returns>Número de elementos de la colección.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.MoveNext">
      <summary>Desplaza el enumerador al siguiente elemento de la colección.</summary>
      <returns>Es <see langword="true" /> si el enumerador avanzó con éxito hasta el siguiente elemento; es <see langword="false" /> si el enumerador alcanzó el final de la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Establece el enumerador en su posición inicial (antes del primer elemento de la colección).</summary>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tareas definidas por la aplicación asociadas a la liberación o al restablecimiento de recursos no administrados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeNamedArgument`1">
      <summary>Representa un argumento con nombre descodificado a partir de una firma de atributos personalizados.</summary>
      <typeparam name="TType">Tipo que se usa para representar tipos de valores descodificados de la firma de atributo personalizado.</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeNamedArgument`1.#ctor(System.String,System.Reflection.Metadata.CustomAttributeNamedArgumentKind,`0,System.Object)">
      <summary>Inicializa una nueva instancia de la estructura <see cref="T:System.Reflection.Metadata.CustomAttributeNamedArgument`1" /> mediante el nombre, tipo y valor especificados.</summary>
      <param name="name">El nombre del argumento.</param>
      <param name="kind">Tipo del argumento.</param>
      <param name="type">Tipo del argumento.</param>
      <param name="value">Valor del argumento.</param>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Kind">
      <summary>Obtiene el tipo de un argumento.</summary>
      <returns>El tipo de argumento.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Name">
      <summary>Obtiene el nombre del argumento.</summary>
      <returns>El nombre del argumento.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Type">
      <summary>Obtiene el tipo del argumento.</summary>
      <returns>Tipo de argumento.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Value">
      <summary>Obtiene el valor del argumento.</summary>
      <returns>Objeto que contiene el valor del argumento.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeNamedArgumentKind">
      <summary>Especifica las constantes que definen los tipos de argumentos en una firma de atributos personalizados.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.CustomAttributeNamedArgumentKind.Field">
      <summary>Argumento de campo.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.CustomAttributeNamedArgumentKind.Property">
      <summary>Argumento de propiedad.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeTypedArgument`1">
      <summary>Representa un argumento con tipo para un atributo de metadatos personalizado.</summary>
      <typeparam name="TType">Tipo del argumento.</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeTypedArgument`1.#ctor(`0,System.Object)">
      <summary>Inicializa una nueva instancia de la estructura <see cref="T:System.Reflection.Metadata.CustomAttributeTypedArgument`1" /> mediante el valor y tipo de argumento especificados.</summary>
      <param name="type">Tipo del argumento.</param>
      <param name="value">El valor de argumento.</param>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeTypedArgument`1.Type">
      <summary>Obtiene el tipo del argumento.</summary>
      <returns>Tipo de argumento.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeTypedArgument`1.Value">
      <summary>Obtiene el valor del argumento.</summary>
      <returns>El valor de argumento.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeValue`1">
      <summary>Representa un atributo personalizado del tipo especificado por <paramref name="TType" />.</summary>
      <typeparam name="TType">Tipo de atributo.</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeValue`1.#ctor(System.Collections.Immutable.ImmutableArray{System.Reflection.Metadata.CustomAttributeTypedArgument{`0}},System.Collections.Immutable.ImmutableArray{System.Reflection.Metadata.CustomAttributeNamedArgument{`0}})">
      <summary>Inicializa una nueva instancia de la estructura <see cref="T:System.Reflection.Metadata.CustomAttributeValue`1" /> mediante los argumentos fijos y los argumentos con nombre especificados.</summary>
      <param name="fixedArguments">Argumentos fijos.</param>
      <param name="namedArguments">Argumentos con nombre.</param>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeValue`1.FixedArguments">
      <summary>Obtiene los argumentos fijos para el atributo personalizado.</summary>
      <returns>Matriz inmutable de argumentos.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeValue`1.NamedArguments">
      <summary>Obtiene los argumentos con nombre para el valor del atributo personalizado.</summary>
      <returns>Matriz inmutable de argumentos.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomDebugInformation" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformation.Kind" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformation.Parent" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformation.Value" />
    <member name="T:System.Reflection.Metadata.CustomDebugInformationHandle" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.Equals(System.Reflection.Metadata.CustomDebugInformationHandle)">
      <summary>Indica si el objeto actual es igual a otro objeto del mismo tipo.</summary>
      <param name="other">Objeto que se va a comparar con este objeto.</param>
      <returns>
        <see langword="true" /> si el objeto actual es igual al parámetro <paramref name="other" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Equality(System.Reflection.Metadata.CustomDebugInformationHandle,System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.CustomDebugInformationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.CustomDebugInformationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Implicit(System.Reflection.Metadata.CustomDebugInformationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Implicit(System.Reflection.Metadata.CustomDebugInformationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Inequality(System.Reflection.Metadata.CustomDebugInformationHandle,System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.CustomDebugInformationHandleCollection" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#CustomDebugInformationHandle}#GetEnumerator">
      <summary>Devuelve un enumerador que procesa una iteración en la colección.</summary>
      <returns>Enumerador que se puede utilizar para recorrer en iteración la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Devuelve un enumerador que recorre en iteración una colección.</summary>
      <returns>Objeto <see cref="T:System.Collections.IEnumerator" /> que puede usarse para recorrer en iteración la colección.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Count">
      <summary>Obtiene el número de elementos de la colección.</summary>
      <returns>Número de elementos de la colección.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.MoveNext">
      <summary>Desplaza el enumerador al siguiente elemento de la colección.</summary>
      <returns>Es <see langword="true" /> si el enumerador avanzó con éxito hasta el siguiente elemento; es <see langword="false" /> si el enumerador alcanzó el final de la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Establece el enumerador en su posición inicial (antes del primer elemento de la colección).</summary>
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tareas definidas por la aplicación asociadas a la liberación o al restablecimiento de recursos no administrados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.DebugMetadataHeader" />
    <member name="P:System.Reflection.Metadata.DebugMetadataHeader.EntryPoint" />
    <member name="P:System.Reflection.Metadata.DebugMetadataHeader.Id" />
    <member name="P:System.Reflection.Metadata.DebugMetadataHeader.IdStartOffset">
      <summary>Obtiene el desplazamiento (en bytes) desde el inicio del BLOB de metadatos hasta el inicio del BLOB <see cref="P:System.Reflection.Metadata.DebugMetadataHeader.Id" />.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttribute" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttribute.Action" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttribute.Parent" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttribute.PermissionSet" />
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.Equals(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <summary>Indica si el objeto actual es igual a otro objeto del mismo tipo.</summary>
      <param name="other">Objeto que se va a comparar con este objeto.</param>
      <returns>
        <see langword="true" /> si el objeto actual es igual al parámetro <paramref name="other" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Equality(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle,System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.DeclarativeSecurityAttributeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.DeclarativeSecurityAttributeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Implicit(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Implicit(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Inequality(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle,System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#DeclarativeSecurityAttributeHandle}#GetEnumerator">
      <summary>Devuelve un enumerador que procesa una iteración en la colección.</summary>
      <returns>Enumerador que se puede utilizar para recorrer en iteración la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Devuelve un enumerador que recorre en iteración una colección.</summary>
      <returns>Objeto <see cref="T:System.Collections.IEnumerator" /> que puede usarse para recorrer en iteración la colección.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Count">
      <summary>Obtiene el número de elementos de la colección.</summary>
      <returns>Número de elementos de la colección.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.MoveNext">
      <summary>Desplaza el enumerador al siguiente elemento de la colección.</summary>
      <returns>Es <see langword="true" /> si el enumerador avanzó con éxito hasta el siguiente elemento; es <see langword="false" /> si el enumerador alcanzó el final de la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Establece el enumerador en su posición inicial (antes del primer elemento de la colección).</summary>
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tareas definidas por la aplicación asociadas a la liberación o al restablecimiento de recursos no administrados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Document">
      <summary>Documento de origen en los metadatos de depuración.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.Hash">
      <summary>Obtiene el hash de contenido del documento.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.HashAlgorithm">
      <summary>Obtiene el algoritmo hash usado para calcular <see cref="P:System.Reflection.Metadata.Document.Hash" /> (SHA1, SHA256, etc.).</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.Language">
      <summary>Obtiene el lenguaje de código fuente (C#, VB, F#, etc.).</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.Name">
      <summary>Obtiene el blob de nombre de documento.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.DocumentHandle" />
    <member name="M:System.Reflection.Metadata.DocumentHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.Equals(System.Reflection.Metadata.DocumentHandle)">
      <summary>Indica si el objeto actual es igual a otro objeto del mismo tipo.</summary>
      <param name="other">Objeto que se va a comparar con este objeto.</param>
      <returns>
        <see langword="true" /> si el objeto actual es igual al parámetro <paramref name="other" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Equality(System.Reflection.Metadata.DocumentHandle,System.Reflection.Metadata.DocumentHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.DocumentHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.DocumentHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Implicit(System.Reflection.Metadata.DocumentHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Implicit(System.Reflection.Metadata.DocumentHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Inequality(System.Reflection.Metadata.DocumentHandle,System.Reflection.Metadata.DocumentHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.DocumentHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.DocumentHandleCollection" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#DocumentHandle}#GetEnumerator">
      <summary>Devuelve un enumerador que procesa una iteración en la colección.</summary>
      <returns>Enumerador que se puede utilizar para recorrer en iteración la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Devuelve un enumerador que recorre en iteración una colección.</summary>
      <returns>Objeto <see cref="T:System.Collections.IEnumerator" /> que puede usarse para recorrer en iteración la colección.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.DocumentHandleCollection.Count">
      <summary>Obtiene el número de elementos de la colección.</summary>
      <returns>Número de elementos de la colección.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.DocumentHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.MoveNext">
      <summary>Desplaza el enumerador al siguiente elemento de la colección.</summary>
      <returns>Es <see langword="true" /> si el enumerador avanzó con éxito hasta el siguiente elemento; es <see langword="false" /> si el enumerador alcanzó el final de la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Establece el enumerador en su posición inicial (antes del primer elemento de la colección).</summary>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tareas definidas por la aplicación asociadas a la liberación o al restablecimiento de recursos no administrados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.DocumentNameBlobHandle">
      <summary>
        <see cref="T:System.Reflection.Metadata.BlobHandle" /> que representa un blob en el montón #Blob del PDB portátil estructurado como nombre de documento.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.Equals(System.Reflection.Metadata.DocumentNameBlobHandle)">
      <summary>Indica si el objeto actual es igual a otro objeto del mismo tipo.</summary>
      <param name="other">Objeto que se va a comparar con este objeto.</param>
      <returns>
        <see langword="true" /> si el objeto actual es igual al parámetro <paramref name="other" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Equality(System.Reflection.Metadata.DocumentNameBlobHandle,System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Explicit(System.Reflection.Metadata.BlobHandle)~System.Reflection.Metadata.DocumentNameBlobHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Implicit(System.Reflection.Metadata.DocumentNameBlobHandle)~System.Reflection.Metadata.BlobHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Inequality(System.Reflection.Metadata.DocumentNameBlobHandle,System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.DocumentNameBlobHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder.Shape(System.Int32,System.Collections.Immutable.ImmutableArray{System.Int32},System.Collections.Immutable.ImmutableArray{System.Int32})">
      <summary>Codifica la forma de matriz.</summary>
      <param name="rank">El número de dimensiones de la matriz (debe ser 1 o más).</param>
      <param name="sizes">Tamaños de dimensión. La matriz puede ser más corta que <paramref name="rank" />, pero no más larga.</param>
      <param name="lowerBounds">Límites inferiores de la dimensión o el valor predeterminado (<see cref="T:System.Collections.Immutable.ImmutableArray`1" />) para establecer todos los límites inferiores a <paramref name="rank" /> en 0.
La matriz puede ser más corta que <paramref name="rank" />, pero no más larga.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="rank" /> está fuera del intervalo [1, 0xffff] o es menor que <see langword="sizes.Length" /> o que <see langword="lowerBounds.Length" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="sizes" /> es <see langword="null" />.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.BlobEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.CustomAttributeSignature(System.Action{System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder},System.Action{System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder})">
      <summary>Codifica el blob de firma de atributo personalizado.</summary>
      <param name="fixedArguments">Se llama primero para codificar los argumentos fijos.</param>
      <param name="namedArguments">Se llama segundo para codificar los argumentos con nombre.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="fixedArguments" /> o <paramref name="namedArguments" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.CustomAttributeSignature(System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder@,System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder@)">
      <summary>Codifica el blob de firma de atributo personalizado.
Devuelve un par de codificadores que se deben usar en el orden en que aparecen en la lista de parámetros.</summary>
      <param name="fixedArguments">Se usa primero para codificar los argumentos fijos.</param>
      <param name="namedArguments">Se usa segundo para codificar los argumentos con nombre.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.FieldSignature">
      <summary>Codifica el blob de la firma del campo.</summary>
      <returns>Codificador del tipo de campo.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.LocalVariableSignature(System.Int32)">
      <summary>Firma de la variable local.</summary>
      <param name="variableCount">Número de variables locales.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="variableCount" /> no está en el intervalo [0, 0x1fffffff].</exception>
      <returns>Codificador de una secuencia de variables locales.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.MethodSignature(System.Reflection.Metadata.SignatureCallingConvention,System.Int32,System.Boolean)">
      <summary>Codifica el blob de la firma del método.</summary>
      <param name="convention">Convención de llamada</param>
      <param name="genericParameterCount">Número de parámetros genéricos.</param>
      <param name="isInstanceMethod">
        <see langword="true" /> para codificar una firma de método de instancia, <see langword="false" /> para codificar una firma de método estático.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="genericParameterCount" /> no está en el intervalo [0, 0xffff].</exception>
      <returns>Un codificador del resto de la firma, incluidos el valor devuelto y los parámetros.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.MethodSpecificationSignature(System.Int32)">
      <summary>Codifica un blob de firma de especificación de método.</summary>
      <param name="genericArgumentCount">Número de argumentos genéricos.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="genericArgumentCount" /> no está en el intervalo [0, 0xffff].</exception>
      <returns>Codificador de argumentos genéricos.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.PermissionSetArguments(System.Int32)">
      <summary>Codifica los argumentos del conjunto de permisos.</summary>
      <param name="argumentCount">Número de argumentos del conjunto.</param>
      <returns>Codificador de los argumentos del conjunto.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.PermissionSetBlob(System.Int32)">
      <summary>Codifica un blob del conjunto de permisos.</summary>
      <param name="attributeCount">Número de atributos del conjunto.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="attributeCount" /> no está en el intervalo [0, 0x1fffffff].</exception>
      <returns>Codificador del conjunto de permisos.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.PropertySignature(System.Boolean)">
      <summary>Codifica el blob de la firma de la propiedad.</summary>
      <param name="isInstanceProperty">
        <see langword="true" /> para codificar una firma de propiedad de instancia, <see langword="false" /> para codificar una firma de propiedad estática.</param>
      <returns>Un codificador del resto de la firma, incluidos el valor y los parámetros devueltos, que tiene la misma estructura que la firma del método.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.TypeSpecificationSignature">
      <summary>Codifica la firma de especificación de tipo.</summary>
      <returns>Codificador de tipo del tipo estructurado representado por la especificación de tipo (no debe codificar un tipo primitivo).</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.BlobEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.CodedIndex" />
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.CustomAttributeType(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcula un índice codificado CustomAttributeType para el controlador especificado.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> o <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" /></param>
      <exception cref="T:System.ArgumentException">El tipo de identificador es inesperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasConstant(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcula un índice codificado HasConstant para el controlador especificado.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />o <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" /></param>
      <exception cref="T:System.ArgumentException">El tipo de identificador es inesperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasCustomAttribute(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcula un índice codificado HasCustomAttribute para el controlador especificado.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />, <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />, <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />, <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" /> o <see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />.</param>
      <exception cref="T:System.ArgumentException">El tipo de identificador es inesperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasCustomDebugInformation(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcula un índice codificado HasCustomDebugInformation para el controlador especificado.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />, <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />, <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />, <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" />, <see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.DocumentHandle" />, <see cref="T:System.Reflection.Metadata.LocalScopeHandle" />, <see cref="T:System.Reflection.Metadata.LocalVariableHandle" />, <see cref="T:System.Reflection.Metadata.LocalConstantHandle" /> o <see cref="T:System.Reflection.Metadata.ImportScopeHandle" />.</param>
      <exception cref="T:System.ArgumentException">El tipo de identificador es inesperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasDeclSecurity(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcula un índice codificado HasDeclSecurity para el controlador especificado.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />o <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" /></param>
      <exception cref="T:System.ArgumentException">El tipo de identificador es inesperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasFieldMarshal(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcula un índice codificado HasFieldMarshal para el controlador especificado.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.ParameterHandle" /> o <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" /></param>
      <exception cref="T:System.ArgumentException">El tipo de identificador es inesperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasSemantics(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcula un índice codificado HasSemantics para el controlador especificado.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" /> o <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" /></param>
      <exception cref="T:System.ArgumentException">El tipo de identificador es inesperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.Implementation(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcula un índice codificado de una implementación para el controlador especificado.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" /> o <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" /></param>
      <exception cref="T:System.ArgumentException">El tipo de identificador es inesperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.MemberForwarded(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcula un índice codificado MemberForwarded para el controlador especificado.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.FieldDefinition" />, <see cref="T:System.Reflection.Metadata.MethodDefinition" /></param>
      <exception cref="T:System.ArgumentException">El tipo de identificador es inesperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.MemberRefParent(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcula un índice codificado MemberRefParent para el controlador especificado.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />, o <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <exception cref="T:System.ArgumentException">El tipo de identificador es inesperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.MethodDefOrRef(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcula un índice codificado MethodDefOrRef para el controlador especificado.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> o <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" /></param>
      <exception cref="T:System.ArgumentException">El tipo de identificador es inesperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.ResolutionScope(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcula un índice codificado ResolutionScope para el controlador especificado.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" /> o <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /></param>
      <exception cref="T:System.ArgumentException">El tipo de identificador es inesperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.TypeDefOrRef(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcula un índice codificado TypeDefOrRef para el controlador especificado.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> o <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /></param>
      <exception cref="T:System.ArgumentException">El tipo de identificador es inesperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.TypeDefOrRefOrSpec(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcula un índice codificado TypeDefOrRefOrSpec para el controlador especificado.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> o <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /></param>
      <exception cref="T:System.ArgumentException">El tipo de identificador es inesperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.TypeOrMethodDef(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcula un índice codificado TypeOrMethodDef para el controlador especificado.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> o <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /></param>
      <exception cref="T:System.ArgumentException">El tipo de identificador es inesperado.</exception>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.ControlFlowBuilder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.#ctor" />
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddCatchRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>Agrega la región catch.</summary>
      <param name="tryStart">Etiqueta que marca la primera instrucción del bloque try.</param>
      <param name="tryEnd">Etiqueta que marca la instrucción inmediatamente después del bloque try.</param>
      <param name="handlerStart">Etiqueta que marca la primera instrucción del controlador.</param>
      <param name="handlerEnd">Etiqueta que marca la instrucción inmediatamente después del controlador.</param>
      <param name="catchType">Tipo de excepción que se va a detectar: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> o <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <exception cref="T:System.ArgumentException">Una etiqueta no definida por un codificador de instrucciones al que está asociado este generador.

o bien

<paramref name="catchType" /> no es un identificador de tipo válido.</exception>
      <exception cref="T:System.ArgumentNullException">Una etiqueta tiene un valor predeterminado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddFaultRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary>Agrega una región fault.</summary>
      <param name="tryStart">Etiqueta que marca la primera instrucción del bloque try.</param>
      <param name="tryEnd">Etiqueta que marca la instrucción inmediatamente después del bloque try.</param>
      <param name="handlerStart">Etiqueta que marca la primera instrucción del controlador.</param>
      <param name="handlerEnd">Etiqueta que marca la instrucción inmediatamente después del controlador.</param>
      <exception cref="T:System.ArgumentException">Una etiqueta no definida por un codificador de instrucciones al que está asociado este generador.</exception>
      <exception cref="T:System.ArgumentNullException">Una etiqueta tiene un valor predeterminado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddFilterRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary>Agrega la región catch.</summary>
      <param name="tryStart">Etiqueta que marca la primera instrucción del bloque try.</param>
      <param name="tryEnd">Etiqueta que marca la instrucción inmediatamente después del bloque try.</param>
      <param name="handlerStart">Etiqueta que marca la primera instrucción del controlador.</param>
      <param name="handlerEnd">Etiqueta que marca la instrucción inmediatamente después del controlador.</param>
      <param name="filterStart">Etiqueta que marca la primera instrucción del bloque de filtro.</param>
      <exception cref="T:System.ArgumentException">Una etiqueta no definida por un codificador de instrucciones al que está asociado este generador.</exception>
      <exception cref="T:System.ArgumentNullException">Una etiqueta tiene un valor predeterminado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddFinallyRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary>Agrega la región finally.</summary>
      <param name="tryStart">Etiqueta que marca la primera instrucción del bloque try.</param>
      <param name="tryEnd">Etiqueta que marca la instrucción inmediatamente después del bloque try.</param>
      <param name="handlerStart">Etiqueta que marca la primera instrucción del controlador.</param>
      <param name="handlerEnd">Etiqueta que marca la instrucción inmediatamente después del controlador.</param>
      <exception cref="T:System.ArgumentException">Una etiqueta no definida por un codificador de instrucciones al que está asociado este generador.</exception>
      <exception cref="T:System.ArgumentNullException">Una etiqueta tiene un valor predeterminado.</exception>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.ElementType" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.ObjectArray" />
    <member name="P:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Boolean" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Byte" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Char" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Double" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Enum(System.String)">
      <param name="enumTypeName" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Int16" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Int32" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Int64" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.PrimitiveType(System.Reflection.Metadata.PrimitiveSerializationTypeCode)">
      <param name="type" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.SByte" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Single" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.String" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.SystemType" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.UInt16" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.UInt32" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.UInt64" />
    <member name="P:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder.Count(System.Int32)">
      <param name="count" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder.AddModifier(System.Reflection.Metadata.EntityHandle,System.Boolean)">
      <summary>Codifica un modificador personalizado.</summary>
      <param name="type">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> o <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <param name="isOptional">Es un modificador opcional.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="type" /> es <see langword="null" /> o de un tipo inesperado.</exception>
      <returns>Codificador de modificadores subsiguientes.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry" />
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.#ctor(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.Ecma335.EditAndContinueOperation)">
      <param name="handle" />
      <param name="operation" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Equals(System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry)">
      <summary>Indica si el objeto actual es igual a otro objeto del mismo tipo.</summary>
      <param name="other">Objeto que se va a comparar con este objeto.</param>
      <returns>
        <see langword="true" /> si el objeto actual es igual al parámetro <paramref name="other" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.GetHashCode" />
    <member name="P:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Handle" />
    <member name="P:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Operation" />
    <member name="T:System.Reflection.Metadata.Ecma335.EditAndContinueOperation" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddEvent" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddField" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddMethod" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddParameter" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddProperty" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.Default" />
    <member name="T:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.Add(System.Reflection.Metadata.ExceptionRegionKind,System.Int32,System.Int32,System.Int32,System.Int32,System.Reflection.Metadata.EntityHandle,System.Int32)">
      <summary>Agrega una cláusula de excepción.</summary>
      <param name="kind">Tipo de cláusula.</param>
      <param name="tryOffset">Desplazamiento del inicio del bloque try.</param>
      <param name="tryLength">Longitud del bloque try.</param>
      <param name="handlerOffset">Desplazamiento del inicio del controlador.</param>
      <param name="handlerLength">Longitud del controlador.</param>
      <param name="catchType">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> o <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, o nil si <paramref name="kind" /> no es <see cref="F:System.Reflection.Metadata.ExceptionRegionKind.Catch" /></param>
      <param name="filterOffset">Desplazamiento del bloque de filtro, o 0 si <paramref name="kind" /> no es <see cref="F:System.Reflection.Metadata.ExceptionRegionKind.Filter" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="catchType" /> no es válido.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="kind" /> tiene un valor no válido.
          
o bien

<paramref name="tryOffset" />, <paramref name="tryLength" />, <paramref name="handlerOffset" /> o <paramref name="handlerLength" /> están fuera del intervalo.</exception>
      <exception cref="T:System.InvalidOperationException">El cuerpo del método no se declaró para tener regiones de excepción.</exception>
      <returns>Codificador para la siguiente cláusula.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddCatch(System.Int32,System.Int32,System.Int32,System.Int32,System.Reflection.Metadata.EntityHandle)">
      <summary>Agrega una cláusula fault.</summary>
      <param name="tryOffset">Desplazamiento del inicio del bloque try.</param>
      <param name="tryLength">Longitud del bloque try.</param>
      <param name="handlerOffset">Desplazamiento del inicio del controlador.</param>
      <param name="handlerLength">Longitud del controlador.</param>
      <param name="catchType">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> o <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="catchType" /> no es válido.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="tryOffset" />, <paramref name="tryLength" />, <paramref name="handlerOffset" /> o <paramref name="handlerLength" /> están fuera del intervalo.</exception>
      <exception cref="T:System.InvalidOperationException">El cuerpo del método no se declaró para tener regiones de excepción.</exception>
      <returns>Codificador para la siguiente cláusula.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddFault(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>Agrega una cláusula fault.</summary>
      <param name="tryOffset">Desplazamiento del inicio del bloque try.</param>
      <param name="tryLength">Longitud del bloque try.</param>
      <param name="handlerOffset">Desplazamiento del inicio del controlador.</param>
      <param name="handlerLength">Longitud del controlador.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="tryOffset" />, <paramref name="tryLength" />, <paramref name="handlerOffset" /> o <paramref name="handlerLength" /> están fuera del intervalo.</exception>
      <exception cref="T:System.InvalidOperationException">El cuerpo del método no se declaró para tener regiones de excepción.</exception>
      <returns>Codificador para la siguiente cláusula.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddFilter(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>Agrega una cláusula fault.</summary>
      <param name="tryOffset">Desplazamiento del inicio del bloque try.</param>
      <param name="tryLength">Longitud del bloque try.</param>
      <param name="handlerOffset">Desplazamiento del inicio del controlador.</param>
      <param name="handlerLength">Longitud del controlador.</param>
      <param name="filterOffset">Desplazamiento del bloque de filtro.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="tryOffset" />, <paramref name="tryLength" />, <paramref name="handlerOffset" /> o <paramref name="handlerLength" /> están fuera del intervalo.</exception>
      <exception cref="T:System.InvalidOperationException">El cuerpo del método no se declaró para tener regiones de excepción.</exception>
      <returns>Codificador para la siguiente cláusula.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddFinally(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>Agrega una cláusula finally.</summary>
      <param name="tryOffset">Desplazamiento del inicio del bloque try.</param>
      <param name="tryLength">Longitud del bloque try.</param>
      <param name="handlerOffset">Desplazamiento del inicio del controlador.</param>
      <param name="handlerLength">Longitud del controlador.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="tryOffset" />, <paramref name="tryLength" />, <paramref name="handlerOffset" /> o <paramref name="handlerLength" /> están fuera del intervalo.</exception>
      <exception cref="T:System.InvalidOperationException">El cuerpo del método no se declaró para tener regiones de excepción.</exception>
      <returns>Codificador para la siguiente cláusula.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.IsSmallExceptionRegion(System.Int32,System.Int32)">
      <summary>Devuelve <see langword="true" /> si la región se ajusta al formato pequeño.</summary>
      <param name="startOffset">Desplazamiento inicial de la región.</param>
      <param name="length">Longitud de la región.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.IsSmallRegionCount(System.Int32)">
      <summary>Devuelve <see langword="true" /> si el número de regiones exception se ajusta al formato pequeño.</summary>
      <param name="exceptionRegionCount">Número de regiones exception.</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.Builder">
      <summary>Generador subyacente.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.HasSmallFormat">
      <summary>
        <see langword="true" /> si el codificador usa el formato pequeño.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.ExportedTypeExtensions">
      <summary>Proporciona un método de extensión para acceder a la columna TypeDefinitionId de la tabla ExportedType.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExportedTypeExtensions.GetTypeDefinitionId(System.Reflection.Metadata.ExportedType)">
      <summary>Obtiene una sugerencia en el número de fila probable del tipo de destino en la tabla TypeDef de su módulo.
Si los espacios de nombres y los nombres no coinciden, la resolución recurre a una búsqueda completa de la tabla TypeDef de destino. Se omite y debe ser cero si <see cref="P:System.Reflection.Metadata.ExportedType.IsForwarder" /> es <see langword="true" />.</summary>
      <param name="exportedType" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder.AddArgument" />
    <member name="P:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes" />
    <member name="F:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes.HasExplicitThis" />
    <member name="F:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes.HasThis" />
    <member name="F:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes.None" />
    <member name="T:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder.AddArgument" />
    <member name="P:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.HeapIndex" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.Blob" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.Guid" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.String" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.UserString" />
    <member name="T:System.Reflection.Metadata.Ecma335.InstructionEncoder">
      <summary>Codifica instrucciones.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.#ctor(System.Reflection.Metadata.BlobBuilder,System.Reflection.Metadata.Ecma335.ControlFlowBuilder)">
      <summary>Crea un codificador respaldado por los generadores de código y de flujo de control.</summary>
      <param name="codeBuilder">Generador en el que se van a escribir las instrucciones codificadas.</param>
      <param name="controlFlowBuilder">Controladores de excepciones, bifurcaciones y etiquetas de seguimiento del generador.
Debe especificarse para poder usar algunos de los métodos de fábrica de flujo de control de <see cref="T:System.Reflection.Metadata.Ecma335.InstructionEncoder" />, como <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Branch(System.Reflection.Metadata.ILOpCode,System.Reflection.Metadata.Ecma335.LabelHandle)" />, <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.DefineLabel" /> y <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.MarkLabel(System.Reflection.Metadata.Ecma335.LabelHandle)" />, entre otros.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Branch(System.Reflection.Metadata.ILOpCode,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary>Codifica una instrucción de bifurcación.</summary>
      <param name="code">Instrucción de bifurcación que se va a codificar.</param>
      <param name="label">Etiqueta de la ubicación de destino en el flujo de instrucciones.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="code" /> no es una instrucción de bifurcación.

o bien 
<paramref name="label" /> no lo definió este codificador.</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="label" /> tiene un valor predeterminado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.EntityHandle)">
      <summary>Codifica la instrucción <c>call</c> y su operando.</summary>
      <param name="methodHandle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.MemberReferenceHandle)">
      <summary>Codifica la instrucción <c>call</c> y su operando.</summary>
      <param name="methodHandle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary>Codifica la instrucción <c>call</c> y su operando.</summary>
      <param name="methodHandle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.MethodSpecificationHandle)">
      <summary>Codifica la instrucción <c>call</c> y su operando.</summary>
      <param name="methodHandle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.CallIndirect(System.Reflection.Metadata.StandaloneSignatureHandle)">
      <summary>Codifica la instrucción <c>calli</c> y su operando.</summary>
      <param name="signature" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.DefineLabel">
      <summary>Define una etiqueta que se puede usar más adelante para marcar y hacer referencia a una ubicación en la secuencia de instrucciones.</summary>
      <exception cref="T:System.InvalidOperationException">
        <see cref="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder" /> es <see langword="null" />.</exception>
      <returns>Controlador de etiqueta.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadArgument(System.Int32)">
      <summary>Codifica la instrucción de carga de los argumentos.</summary>
      <param name="argumentIndex">Índice del argumento.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="argumentIndex" /> es negativo.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadArgumentAddress(System.Int32)">
      <summary>Codifica la instrucción de carga de direcciones de argumento.</summary>
      <param name="argumentIndex">Índice del argumento.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="argumentIndex" /> es negativo.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantI4(System.Int32)">
      <summary>Codifica la instrucción de carga constante <see cref="T:System.Int32" />.</summary>
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantI8(System.Int64)">
      <summary>Codifica la instrucción de carga constante <see cref="T:System.Int64" />.</summary>
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantR4(System.Single)">
      <summary>Codifica la instrucción de carga constante <see cref="T:System.Single" />.</summary>
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantR8(System.Double)">
      <summary>Codifica la instrucción de carga constante <see cref="T:System.Double" />.</summary>
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadLocal(System.Int32)">
      <summary>Codifica la instrucción de carga de variables locales.</summary>
      <param name="slotIndex">Índice de la ranura de la variable local.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="slotIndex" /> es negativo.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadLocalAddress(System.Int32)">
      <summary>Codifica la instrucción de carga de direcciones de variables locales.</summary>
      <param name="slotIndex">Índice de la ranura de la variable local.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="slotIndex" /> es negativo.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)">
      <summary>Codifica la instrucción <c>ldstr</c> y su operando.</summary>
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.MarkLabel(System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary>Asocia la etiqueta especificada con el desplazamiento IL actual.</summary>
      <param name="label">Etiqueta que se va a marcar.</param>
      <exception cref="T:System.InvalidOperationException">
        <see cref="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="label" /> no lo definió este codificador.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="label" /> tiene un valor predeterminado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.OpCode(System.Reflection.Metadata.ILOpCode)">
      <summary>Codifica el código de operación especificado.</summary>
      <param name="code" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.StoreArgument(System.Int32)">
      <summary>Codifica la instrucción del almacén de argumentos.</summary>
      <param name="argumentIndex">Índice del argumento.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="argumentIndex" /> es negativo.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.StoreLocal(System.Int32)">
      <summary>Codifica la instrucción del almacén de variables local.</summary>
      <param name="slotIndex">Índice de la ranura de la variable local.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="slotIndex" /> es negativo.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Token(System.Int32)">
      <summary>Codifica un token.</summary>
      <param name="token" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Token(System.Reflection.Metadata.EntityHandle)">
      <summary>Codifica un token.</summary>
      <param name="handle" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.CodeBuilder">
      <summary>Generador subyacente en el que se escriben las instrucciones codificadas.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder">
      <summary>Controladores de excepciones, bifurcaciones y etiquetas de seguimiento del generador.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.Offset">
      <summary>Desplazamiento de la siguiente instrucción codificada.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.LabelHandle" />
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.Equals(System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary>Indica si el objeto actual es igual a otro objeto del mismo tipo.</summary>
      <param name="other">Objeto que se va a comparar con este objeto.</param>
      <returns>
        <see langword="true" /> si el objeto actual es igual al parámetro <paramref name="other" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.op_Equality(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.op_Inequality(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.LabelHandle.Id">
      <summary>Identificador de base 1 que identifica la etiqueta en el contexto de un elemento <see cref="T:System.Reflection.Metadata.Ecma335.ControlFlowBuilder" />.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.LabelHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.Ecma335.LiteralEncoder">
      <summary>Proporciona métodos para codificar literales.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder">Crea una instancia de la clase <see cref="T:System.Reflection.Metadata.Ecma335.LiteralEncoder" /> con el generador de blobs especificado.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.Scalar">
      <summary>Devuelve el codificador que se usa para codificar el valor del literal.</summary>
      <returns>El codificador del valor del literal.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedScalar(System.Action{System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.ScalarEncoder})">
      <summary>Codifica el tipo y el valor de un literal mediante los delegados especificados.</summary>
      <param name="type">Un delegado que se usa para codificar el tipo del literal. Este método lo llama en primer lugar.</param>
      <param name="scalar">Un delegado que se usa para codificar el valor del literal. Este método lo llama en segundo lugar.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> o <paramref name="scalar" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedScalar(System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder@,System.Reflection.Metadata.Ecma335.ScalarEncoder@)">
      <summary>Devuelve un par de codificadores que se deben usar para codificar el tipo y el valor de un literal en el orden en que aparecen en la lista de parámetros.</summary>
      <param name="type">Cuando este método devuelve un valor, es un codificador de tipo de elemento de atributo personalizado que se usa para codificar el tipo del literal.</param>
      <param name="scalar">Cuando este método devuelve un valor, es un valor escalar codificado que se usa para codificar el valor del literal.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedVector(System.Action{System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.VectorEncoder})">
      <summary>Codifica el tipo y los elementos de un literal de vector mediante los delegados especificados.</summary>
      <param name="arrayType">Un delegado que se usa para codificar el tipo del vector. Este método lo llama en primer lugar.</param>
      <param name="vector">Un delegado que se usa para codificar los elementos del vector. Este método lo llama en segundo lugar.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="arrayType" /> o <paramref name="vector" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedVector(System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder@,System.Reflection.Metadata.Ecma335.VectorEncoder@)">
      <summary>Devuelve un par de codificadores que se deben usar para codificar el tipo y los elementos de un literal de vector en el orden en que aparecen en la lista de parámetros.</summary>
      <param name="arrayType">Cuando este método devuelve un valor, es un codificador de tipo de matriz de atributo personalizado que se usa para codificar el tipo del vector.</param>
      <param name="vector">Cuando este método devuelve un valor, es un codificador de vector que se usa para codificar los elementos del vector.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.Vector">
      <summary>Obtiene un codificador de vector que se usa para codificar los elementos de un vector.</summary>
      <returns>Un codificador de vector que se usa para codificar los elementos de un vector.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.LiteralEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.LiteralsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralsEncoder.AddLiteral" />
    <member name="P:System.Reflection.Metadata.Ecma335.LiteralsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder.AddVariable" />
    <member name="P:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.CustomModifiers" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.Type(System.Boolean,System.Boolean)">
      <param name="isByRef" />
      <param name="isPinned" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.TypedReference" />
    <member name="P:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataAggregator" />
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataAggregator.#ctor(System.Collections.Generic.IReadOnlyList{System.Int32},System.Collections.Generic.IReadOnlyList{System.Int32},System.Collections.Generic.IReadOnlyList{System.Reflection.Metadata.MetadataReader})">
      <param name="baseTableRowCounts" />
      <param name="baseHeapSizes" />
      <param name="deltaReaders" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataAggregator.#ctor(System.Reflection.Metadata.MetadataReader,System.Collections.Generic.IReadOnlyList{System.Reflection.Metadata.MetadataReader})">
      <param name="baseReader" />
      <param name="deltaReaders" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataAggregator.GetGenerationHandle(System.Reflection.Metadata.Handle,System.Int32@)">
      <summary>Calcula el identificador de la entidad dentro de la generación de metadatos en la que se define, dado un identificador de una entidad en los metadatos de un agregado.</summary>
      <param name="handle">Identificador de una entidad en los metadatos de un agregado.</param>
      <param name="generation">La generación en la que se define la entidad.</param>
      <returns>Identificador de la entidad en los metadatos de <paramref name="generation" />.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataBuilder">
      <summary>La clase MetadataBuilder lee y escribe para un ensamblado de forma muy eficaz. Está diseñada para su uso por parte de compiladores y otras herramientas de generación de ensamblados.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>Crea un generador para las tablas de metadatos y los montones.</summary>
      <param name="userStringHeapStartOffset">El desplazamiento inicial del montón de cadena de usuario. El tamaño acumulado de los montones de cadena de usuario de todas las generaciones de EnC anteriores debe ser 0 a menos que los metadatos sean metadatos delta.</param>
      <param name="stringHeapStartOffset">El desplazamiento inicial del montón de cadena. El tamaño acumulado de los montones de cadena de todas las generaciones de EnC anteriores debe ser 0 a menos que los metadatos sean metadatos delta.</param>
      <param name="blobHeapStartOffset">El desplazamiento inicial del montón blob. El tamaño acumulado de los montones blob de todas las generaciones de EnC anteriores debe ser 0 a menos que los metadatos sean metadatos delta.</param>
      <param name="guidHeapStartOffset">El desplazamiento inicial del montón GUID. El tamaño acumulado de los montones GUID de todas las generaciones de EnC anteriores debe ser 0 a menos que los metadatos sean metadatos delta.</param>
      <exception cref="T:System.Reflection.Metadata.ImageFormatLimitationException">El desplazamiento es demasiado grande.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">El desplazamiento es negativo.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="guidHeapStartOffset" /> no es un múltiplo del tamaño del GUID.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddAssembly(System.Reflection.Metadata.StringHandle,System.Version,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Reflection.AssemblyFlags,System.Reflection.AssemblyHashAlgorithm)">
      <param name="name" />
      <param name="version" />
      <param name="culture" />
      <param name="publicKey" />
      <param name="flags" />
      <param name="hashAlgorithm" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddAssemblyFile(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Boolean)">
      <param name="name" />
      <param name="hashValue" />
      <param name="containsMetadata" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddAssemblyReference(System.Reflection.Metadata.StringHandle,System.Version,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Reflection.AssemblyFlags,System.Reflection.Metadata.BlobHandle)">
      <param name="name" />
      <param name="version" />
      <param name="culture" />
      <param name="publicKeyOrToken" />
      <param name="flags" />
      <param name="hashValue" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddConstant(System.Reflection.Metadata.EntityHandle,System.Object)">
      <summary>Agrega un valor predeterminado para un parámetro, un campo o una propiedad.</summary>
      <param name="parent">El identificador de la entidad primaria, que puede ser uno de los siguientes: <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" /> o <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />.</param>
      <param name="value">Valor constante.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" /> no tiene el tipo de identificador esperado.</exception>
      <returns>Un identificador de la constante agregada.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddCustomAttribute(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Agrega un atributo personalizado.</summary>
      <param name="parent">Una entidad a la que se va a asociar el atributo personalizado: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />, <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />, <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />, <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" />, o bien <see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />.</param>
      <param name="constructor">Un constructor de atributos personalizados: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> o <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />.</param>
      <param name="value">Un blob de valor de atributo personalizado.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" /> no tiene el tipo de identificador esperado.</exception>
      <returns>Un identificador del atributo personalizado agregado.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddCustomDebugInformation(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Agrega información de depuración personalizada.</summary>
      <param name="parent">Una entidad a la que se va a adjuntar la información de depuración: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />, <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />, <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />, <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" />, <see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.DocumentHandle" />, <see cref="T:System.Reflection.Metadata.LocalScopeHandle" />, <see cref="T:System.Reflection.Metadata.LocalVariableHandle" />, <see cref="T:System.Reflection.Metadata.LocalConstantHandle" />, o bien <see cref="T:System.Reflection.Metadata.ImportScopeHandle" />.</param>
      <param name="kind">El tipo de información. Determina la estructura del blob <paramref name="value" />.</param>
      <param name="value">El blob de información de depuración personalizada.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" /> no tiene el tipo de identificador esperado.</exception>
      <returns>Un identificador de la información de depuración personalizada agregada.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddDeclarativeSecurityAttribute(System.Reflection.Metadata.EntityHandle,System.Reflection.DeclarativeSecurityAction,System.Reflection.Metadata.BlobHandle)">
      <summary>Agrega un atributo de seguridad declarativa a un tipo, un método o un ensamblado.</summary>
      <param name="parent">El identificador de la entidad primaria, que puede ser uno de los siguientes: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> o <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />.</param>
      <param name="action">Una acción de seguridad declarativa.</param>
      <param name="permissionSet">El blob del conjunto de permisos.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" /> no tiene el tipo de identificador esperado.</exception>
      <returns>Un identificador del atributo de seguridad declarativa agregado.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddDocument(System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.GuidHandle)">
      <summary>Agrega información de depuración del documento.</summary>
      <param name="name">El blob de nombre de documento.</param>
      <param name="hashAlgorithm">El GUID del algoritmo hash usado para calcular el valor de <paramref name="hash" />.</param>
      <param name="hash">El hash de contenido del documento.</param>
      <param name="language">El GUID del lenguaje.</param>
      <returns>Un identificador del documento agregado.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEncLogEntry(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.Ecma335.EditAndContinueOperation)">
      <param name="entity" />
      <param name="code" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEncMapEntry(System.Reflection.Metadata.EntityHandle)">
      <param name="entity" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEvent(System.Reflection.EventAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>Agrega una definición de evento.</summary>
      <param name="attributes">Los atributos del evento.</param>
      <param name="name">Nombre del evento.</param>
      <param name="type">El tipo del evento: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> o <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="type" /> no tiene el tipo de identificador esperado.</exception>
      <returns>Un identificador de la definición de evento agregada.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEventMap(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="declaringType" />
      <param name="eventList" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddExportedType(System.Reflection.TypeAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle,System.Int32)">
      <summary>Agrega un tipo exportado.</summary>
      <param name="attributes">Los atributos del tipo.</param>
      <param name="namespace">El espacio de nombres del tipo.</param>
      <param name="name">Nombre del tipo.</param>
      <param name="implementation">El identificador de la entidad de implementación, que puede ser uno de los siguientes: <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" /> o <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />.</param>
      <param name="typeDefinitionId">El id. de definición de tipo.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="implementation" /> no tiene el tipo de identificador esperado.</exception>
      <returns>Un identificador del tipo exportado agregado.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddFieldDefinition(System.Reflection.FieldAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Agrega una definición de campo.</summary>
      <param name="attributes">Los atributos del campo.</param>
      <param name="name">Nombre de campo.</param>
      <param name="signature">Firma del campo. Use <see cref="M:System.Reflection.Metadata.Ecma335.BlobEncoder.FieldSignature" /> para construir el blob.</param>
      <returns>Un identificador de la definición de campo agregada.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddFieldLayout(System.Reflection.Metadata.FieldDefinitionHandle,System.Int32)">
      <summary>Define un diseño de campo de una definición de campo.</summary>
      <param name="field">El identificador de la definición de tipo.</param>
      <param name="offset">El desplazamiento en bytes del campo dentro de la instancia de tipo declarativo.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddFieldRelativeVirtualAddress(System.Reflection.Metadata.FieldDefinitionHandle,System.Int32)">
      <summary>Agrega una asignación de un campo a su valor inicial almacenado en la imagen de PE.</summary>
      <param name="field">El identificador de la definición de tipo.</param>
      <param name="offset">El desplazamiento en el bloque de la imagen de PE que almacena los valores iniciales de los campos asignados (normalmente en la sección .text).</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="offset" /> es negativo.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddGenericParameter(System.Reflection.Metadata.EntityHandle,System.Reflection.GenericParameterAttributes,System.Reflection.Metadata.StringHandle,System.Int32)">
      <summary>Agrega una definición de parámetro genérico.</summary>
      <param name="parent">El identificador de la entidad primaria, que puede ser <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> o <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />.</param>
      <param name="attributes">Los atributos de parámetro genéricos.</param>
      <param name="name">Nombre del parámetro.</param>
      <param name="index">El índice de parámetro con base cero.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" /> no tiene el tipo de identificador esperado.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> es mayor que <see cref="F:System.UInt16.MaxValue" />.</exception>
      <returns>Un identificador del parámetro genérico agregado.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddGenericParameterConstraint(System.Reflection.Metadata.GenericParameterHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>Agrega una restricción de tipo a un parámetro genérico.</summary>
      <param name="genericParameter">El parámetro genérico que se va a restringir.</param>
      <param name="constraint">La restricción de tipo, que puede ser una de las siguientes: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> o <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="genericParameter" /> no tiene el tipo de identificador esperado.</exception>
      <returns>Un identificador de la restricción de parámetro genérico agregada.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddImportScope(System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Agrega información de depuración del ámbito local.</summary>
      <param name="parentScope">El identificador del ámbito principal.</param>
      <param name="imports">El identificador del ámbito de importación.</param>
      <returns>Un identificador del ámbito de importación agregado.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddInterfaceImplementation(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>Agrega una implementación de interfaz a un tipo.</summary>
      <param name="type">El tipo que implementa la interfaz.</param>
      <param name="implementedInterface">La interfaz que se implementa, que puede ser una de las siguientes: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> o <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="implementedInterface" /> no tiene el tipo de identificador esperado.</exception>
      <returns>Un identificador de la implementación de interfaz agregada.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddLocalConstant(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Agrega información de depuración de constante local.</summary>
      <param name="name">Nombre de la variable.</param>
      <param name="signature">El blob LocalConstantSig.</param>
      <returns>Un identificador de la constante local agregada.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddLocalScope(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.LocalVariableHandle,System.Reflection.Metadata.LocalConstantHandle,System.Int32,System.Int32)">
      <summary>Agrega información de depuración del ámbito local.</summary>
      <param name="method">El método contenedor.</param>
      <param name="importScope">El identificador del ámbito de importación asociado.</param>
      <param name="variableList">Si el ámbito declara variables, establézcalo en el identificador de la primera. De lo contrario, establézcalo en el identificador de la primera variable declarada por la definición de ámbito siguiente. Si ningún ámbito define variables, <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.LocalVariableHandle(1)" />.</param>
      <param name="constantList">Si el ámbito declara constantes, establézcalo en el identificador de la primera. De lo contrario, establézcalo en el identificador de la primera constante declarada por la definición de ámbito siguiente. Si ningún ámbito define constantes, <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.LocalConstantHandle(1)" />.</param>
      <param name="startOffset">El desplazamiento de la primera instrucción incluida en el ámbito.</param>
      <param name="length">La longitud (en bytes) del bloque ámbito.</param>
      <returns>Un identificador del ámbito local agregado.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddLocalVariable(System.Reflection.Metadata.LocalVariableAttributes,System.Int32,System.Reflection.Metadata.StringHandle)">
      <summary>Agrega información de depuración de la variable local.</summary>
      <param name="attributes">Los atributos de la variable local.</param>
      <param name="index">El índice de base cero de la variable local en la firma local.</param>
      <param name="name">Nombre de la variable.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> es mayor que <see cref="F:System.UInt16.MaxValue" />.</exception>
      <returns>Un identificador de la variable local agregada.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddManifestResource(System.Reflection.ManifestResourceAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle,System.UInt32)">
      <summary>Agrega un recurso de manifiesto.</summary>
      <param name="attributes">Los atributos del recurso de manifiesto.</param>
      <param name="name">El nombre del recurso de manifiesto.</param>
      <param name="implementation">El identificador de la entidad de implementación, que puede ser uno de los siguientes: <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" /> o <see langword="null" />.</param>
      <param name="offset">Especifica el desplazamiento de bytes en el archivo al que se hace referencia en el que comienza este registro de recursos.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="implementation" /> no tiene el tipo de identificador esperado.</exception>
      <returns>Un identificador del recurso de manifiesto agregado.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMarshallingDescriptor(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Agrega información de serialización a un campo o un parámetro.</summary>
      <param name="parent">El identificador de la entidad primaria, que puede ser uno de los siguientes: <see cref="T:System.Reflection.Metadata.ParameterHandle" /> o <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />.</param>
      <param name="descriptor">El blob del descriptor.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" /> no tiene el tipo de identificador esperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMemberReference(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Agrega una fila de la tabla MemberRef.</summary>
      <param name="parent">La entidad contenedora, que puede ser una de las siguientes: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> o <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <param name="name">El nombre del miembro.</param>
      <param name="signature">La firma del miembro.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" /> no tiene el tipo de identificador esperado.</exception>
      <returns>Un identificador de la referencia de miembro agregada.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodDebugInformation(System.Reflection.Metadata.DocumentHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Agrega información de depuración de métodos.</summary>
      <param name="document">El identificador de un único documento que contiene todos los puntos de secuencia del método, o bien <see langword="null" /> si el método no tiene puntos de secuencia o abarca varios documentos.</param>
      <param name="sequencePoints">El blob de puntos de secuencia, o bien <see langword="null" /> si el método no tiene puntos de secuencia.</param>
      <returns>Un identificador de la información de depuración de métodos agregada.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodDefinition(System.Reflection.MethodAttributes,System.Reflection.MethodImplAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Int32,System.Reflection.Metadata.ParameterHandle)">
      <summary>Agrega una definición de método.</summary>
      <param name="attributes">Los atributos del método.</param>
      <param name="implAttributes">Los atributos de implementación del método.</param>
      <param name="name">El nombre del método.</param>
      <param name="signature">Firma del método.</param>
      <param name="bodyOffset">Desplazamiento en el bloque de la imagen de PE que almacena los cuerpos de método (la secuencia de IL), o bien -1 si el método no tiene un cuerpo.</param>
      <param name="parameterList">Si el método declara los parámetros en la tabla Params, establézcalo en el identificador del primero. De lo contrario, establézcalo en el identificador del primer parámetro declarado por la definición de método siguiente. Si en el módulo no se declaran parámetros, <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.ParameterHandle(1)" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="bodyOffset" /> es menor que 1.</exception>
      <returns>Un identificador de la definición de método agregada.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodImplementation(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>Define una implementación para una declaración de método dentro de un tipo.</summary>
      <param name="type">Definición de tipo.</param>
      <param name="methodBody">El identificador de la entidad de cuerpo del método, que puede ser uno de los siguientes: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> o <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />.</param>
      <param name="methodDeclaration">El identificador de la entidad de declaración del método, que puede ser uno de los siguientes: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> o <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="methodBody" /> o <paramref name="methodDeclaration" /> no tienen el tipo de identificador esperado.</exception>
      <returns>Un identificador de la implementación de método agregada.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodImport(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.MethodImportAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.ModuleReferenceHandle)">
      <summary>Agrega información de importación a una definición de método.</summary>
      <param name="method">El identificador de la definición del método.</param>
      <param name="attributes">Los atributos de importación del método.</param>
      <param name="name">El nombre del método no administrado.</param>
      <param name="module">El módulo que contiene el método no administrado.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodSemantics(System.Reflection.Metadata.EntityHandle,System.Reflection.MethodSemanticsAttributes,System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary>Asocia un método (un captador, un establecedor, un agregador, etc.) a una propiedad o un evento.</summary>
      <param name="association">El identificador de la entidad de asociación, que puede ser uno de los siguientes: <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" /> o <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />.</param>
      <param name="semantics">Los atributos semánticos del método.</param>
      <param name="methodDefinition">Definición del método.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="association" /> no tiene el tipo de identificador esperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodSpecification(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Agrega una especificación de método (una creación de instancias).</summary>
      <param name="method">El identificador de la entidad de método genérico, que puede ser uno de los siguientes: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> o <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />.</param>
      <param name="instantiation">El blob de creación de instancias que codifica los argumentos genéricos del método.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no tiene el tipo de identificador esperado.</exception>
      <returns>Un identificador de la especificación de método agregada.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddModule(System.Int32,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle)">
      <param name="generation" />
      <param name="moduleName" />
      <param name="mvid" />
      <param name="encId" />
      <param name="encBaseId" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddModuleReference(System.Reflection.Metadata.StringHandle)">
      <param name="moduleName" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddNestedType(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.TypeDefinitionHandle)">
      <summary>Define una relación de anidamiento con las definiciones de tipo especificadas.</summary>
      <param name="type">El manipulador de la definición de tipo anidado.</param>
      <param name="enclosingType">El manipulador de la definición de tipo envolvente.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddParameter(System.Reflection.ParameterAttributes,System.Reflection.Metadata.StringHandle,System.Int32)">
      <summary>Agrega una definición de parámetro.</summary>
      <param name="attributes">Los atributos del parámetro.</param>
      <param name="name">Opcional. Nombre del parámetro.</param>
      <param name="sequenceNumber">El número de secuencia del parámetro. Un valor de 0 hace referencia al tipo de valor devuelto del método propietario; después, sus parámetros se numeran de 1 en adelante.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="sequenceNumber" /> es mayor que <see cref="F:System.UInt16.MaxValue" />.</exception>
      <returns>Un identificador del parámetro agregado.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddProperty(System.Reflection.PropertyAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Agrega una definición de propiedad.</summary>
      <param name="attributes">Los atributos de la propiedad.</param>
      <param name="name">Nombre de la propiedad.</param>
      <param name="signature">La firma de la propiedad.</param>
      <returns>Un identificador de la definición de propiedad agregada.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddPropertyMap(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="declaringType" />
      <param name="propertyList" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddStandaloneSignature(System.Reflection.Metadata.BlobHandle)">
      <param name="signature" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddStateMachineMethod(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary>Agrega información de depuración del método de equipo de estado.</summary>
      <param name="moveNextMethod">El identificador del método <see langword="MoveNext" /> del equipo de estado (el método generado por el compilador).</param>
      <param name="kickoffMethod">El identificador del método de puesta en marcha (el método de iterador o asincrónico definido por el usuario).</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeDefinition(System.Reflection.TypeAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.FieldDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary>Agrega una definición de tipo.</summary>
      <param name="attributes">Los atributos del tipo.</param>
      <param name="namespace">El espacio de nombres del tipo.</param>
      <param name="name">Nombre del tipo.</param>
      <param name="baseType">El identificador de la entidad de tipo base, que puede ser uno de los siguientes: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /> o <see langword="null" />.</param>
      <param name="fieldList">Si el tipo declara campos, establézcalo en el identificador del primero. De lo contrario, establézcalo en el identificador del primer campo declarado por la definición de tipo siguiente. Si ningún tipo define campos en el módulo, <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.FieldDefinitionHandle(1)" />.</param>
      <param name="methodList">Si el tipo declara métodos, es el identificador del primero. De lo contrario, es el identificador del primer método declarado por la definición de tipo siguiente. Si ningún tipo define métodos en el módulo, <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDefinitionHandle(1)" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="baseType" /> no tiene el tipo de identificador esperado.</exception>
      <returns>Un identificador de la definición de tipo agregada.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeLayout(System.Reflection.Metadata.TypeDefinitionHandle,System.UInt16,System.UInt32)">
      <summary>Define un diseño de tipo de una definición de tipo.</summary>
      <param name="type">Definición de tipo.</param>
      <param name="packingSize">Especifica que los campos se deben colocar en la instancia de tipo en direcciones de byte que son un múltiplo de <paramref name="packingSize" />, o bien en la alineación natural de ese tipo de campo, lo que sea menor. Su valor debe ser uno de los siguientes: 0, 1, 2, 4, 8, 16, 32, 64 o 128. Un valor de cero indica que el tamaño de empaquetado utilizado debe coincidir con el valor predeterminado de la plataforma actual.</param>
      <param name="size">Indica un tamaño mínimo de la instancia de tipo y está pensado para permitir el relleno. La cantidad de memoria asignada es el máximo del tamaño calculado a partir del diseño y <paramref name="size" />. Tenga en cuenta que si esta directiva se aplica a un tipo de valor, el tamaño será inferior a 1 MB.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeReference(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle)">
      <summary>Agrega una referencia de tipo.</summary>
      <param name="resolutionScope">La entidad que declara el tipo de destino, que puede ser uno de los siguientes: <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> o <see langword="null" />.</param>
      <param name="namespace">El espacio de nombres de la referencia de tipo.</param>
      <param name="name">El nombre de la referencia de tipo.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="resolutionScope" /> no tiene el tipo de identificador esperado.</exception>
      <returns>Un identificador de la referencia de tipo agregada.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeSpecification(System.Reflection.Metadata.BlobHandle)">
      <param name="signature" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlob(System.Byte[])">
      <summary>Agrega el blob especificado al montón blob, si aún no lo está.</summary>
      <param name="value">La matriz que contiene el blob.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> es <see langword="null" />.</exception>
      <returns>Un identificador del blob agregado o existente.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlob(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>Agrega el blob especificado desde una matriz de bytes al montón blob, si aún no lo está.</summary>
      <param name="value">La matriz que contiene el blob.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> es <see langword="null" />.</exception>
      <returns>Un identificador del blob agregado o existente.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlob(System.Reflection.Metadata.BlobBuilder)">
      <summary>Agrega el blob especificado desde una matriz de bytes inmutable al montón blob, si aún no lo está.</summary>
      <param name="value">La instancia del generador de blobs que contiene el blob.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> es <see langword="null" />.</exception>
      <returns>Un identificador del blob agregado o existente.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlobUTF16(System.String)">
      <summary>Codifica una cadena mediante la codificación UTF16 en un blob y lo agrega al montón blob, si aún no lo está.</summary>
      <param name="value">Cadena que se va a agregar.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> es <see langword="null" />.</exception>
      <returns>Un identificador del blob agregado o existente.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlobUTF8(System.String,System.Boolean)">
      <summary>Codifica una cadena mediante la codificación UTF8 en un blob y lo agrega al montón blob, si aún no lo está.</summary>
      <param name="value">El valor que se va a agregar.</param>
      <param name="allowUnpairedSurrogates">
        <see langword="true" /> para codificar suplentes sin asociar como se ha especificado; <see langword="false" /> para reemplazarlos por el carácter U+FFFD.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> es <see langword="null" />.</exception>
      <returns>Un identificador del blob agregado o existente.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddConstantBlob(System.Object)">
      <summary>Codifica un valor constante en un blob y lo agrega al montón blob, si aún no lo está. Usa UTF16 para codificar las constantes de cadena.</summary>
      <param name="value">El valor constante que se va a agregar.</param>
      <returns>Un identificador del blob agregado o existente.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddDocumentName(System.String)">
      <summary>Codifica un nombre de documento de depuración y lo agrega al montón blob, si aún no lo está.</summary>
      <param name="value">El nombre de documento que se va a agregar.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> es <see langword="null" />.</exception>
      <returns>Un identificador del blob de nombre de documento agregado o existente.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddGuid(System.Guid)">
      <summary>Agrega el GUID especificado al montón GUID, si aún no lo está.</summary>
      <param name="guid">El GUID que se va a agregar.</param>
      <returns>Un identificador del GUID agregado o existente.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddString(System.String)">
      <summary>Agrega la cadena especificada al montón de cadenas, si aún no lo está.</summary>
      <param name="value">Cadena que se va a agregar.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> es <see langword="null" />.</exception>
      <returns>Un identificador de la cadena agregada o existente.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddUserString(System.String)">
      <summary>Agrega la cadena especificada al montón de usuario, si aún no lo está.</summary>
      <param name="value">Cadena que se va a agregar.</param>
      <exception cref="T:System.Reflection.Metadata.ImageFormatLimitationException">El espacio restante del montón es demasiado pequeño para ajustarse a la cadena.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> es <see langword="null" />.</exception>
      <returns>Un identificador de la cadena agregada o existente. Este valor se puede usar en <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetRowCount(System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary>Devuelve el número de elementos actuales de la tabla especificada.</summary>
      <param name="table">El índice de tabla.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="table" /> no es un índice de tabla válido.</exception>
      <returns>El número de elementos en la tabla.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetRowCounts">
      <summary>Devuelve el número de elementos actuales de cada tabla.</summary>
      <returns>Una matriz de tamaño <see cref="F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount" />, con cada elemento rellenado con el recuento de filas actual de la tabla correspondiente.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.ReserveGuid">
      <summary>Reserva espacio en el montón GUID para un GUID.</summary>
      <exception cref="T:System.Reflection.Metadata.ImageFormatLimitationException">El espacio restante del montón es demasiado pequeño para ajustarse a la cadena.</exception>
      <returns>Un identificador del GUID reservado y un elemento <see cref="T:System.Reflection.Metadata.Blob" /> que representa el blob de GUID tal y como está almacenado en el montón.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.ReserveUserString(System.Int32)">
      <summary>Reserva espacio en el montón de cadenas de usuario para una cadena de la longitud especificada.</summary>
      <param name="length">El número de caracteres que se van a reservar.</param>
      <exception cref="T:System.Reflection.Metadata.ImageFormatLimitationException">El espacio restante del montón es demasiado pequeño para ajustarse a la cadena.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" /> es negativo.</exception>
      <returns>Un identificador de la cadena de usuario reservada y un elemento <see cref="T:System.Reflection.Metadata.Blob" /> que representa el blob de cadena de usuario completo (incluida su longitud y el carácter de terminal). El identificador se puede usar en <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)" />.
Use <see cref="M:System.Reflection.Metadata.BlobWriter.WriteUserString(System.String)" /> para rellenar el contenido del blob.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.SetCapacity(System.Reflection.Metadata.Ecma335.HeapIndex,System.Int32)">
      <summary>Establece la capacidad del montón especificado.</summary>
      <param name="heap">El índice del montón.</param>
      <param name="byteCount">Número de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="heap" /> no es un índice de montón válido.

o bien

<paramref name="byteCount" /> es negativo.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.SetCapacity(System.Reflection.Metadata.Ecma335.TableIndex,System.Int32)">
      <summary>Establece la capacidad de la tabla especificada.</summary>
      <param name="table">El índice de tabla.</param>
      <param name="rowCount">Número de filas de la tabla.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="table" /> no es un índice de tabla válido.

o bien

<paramref name="rowCount" /> es negativo.</exception>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions">
      <summary>Proporciona métodos de extensión para trabajar con determinados elementos sin procesar de las tablas de metadatos y los montones de ECMA-335.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetEditAndContinueLogEntries(System.Reflection.Metadata.MetadataReader)">
      <summary>Enumera las entradas del registro de EnC.</summary>
      <param name="reader" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetEditAndContinueMapEntries(System.Reflection.Metadata.MetadataReader)">
      <summary>Enumera las entradas del mapa de EnC.</summary>
      <param name="reader" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetHeapMetadataOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.HeapIndex)">
      <summary>Devuelve el desplazamiento desde el inicio de los metadatos hasta el montón especificado.</summary>
      <param name="reader" />
      <param name="heapIndex" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="heapIndex" /> no es un índice de montón válido.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetHeapSize(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.HeapIndex)">
      <summary>Devuelve el tamaño del montón especificado.</summary>
      <param name="reader" />
      <param name="heapIndex" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="heapIndex" /> no es un índice de montón válido.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.BlobHandle)">
      <summary>Devuelve el identificador del elemento <see cref="T:System.Reflection.Metadata.Blob" /> que sigue al especificado en el montón de <see cref="T:System.Reflection.Metadata.Blob" /> o un identificador nulo si es el último.</summary>
      <param name="reader" />
      <param name="handle" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.StringHandle)">
      <summary>Devuelve el identificador de la cadena que sigue a la especificada en el montón de cadenas, o bien un identificador nulo si es la última.</summary>
      <param name="reader" />
      <param name="handle" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.UserStringHandle)">
      <summary>Devuelve el identificador del elemento UserString que sigue al especificado en el montón de UserString, o bien un identificador nulo si es el último.</summary>
      <param name="reader" />
      <param name="handle" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableMetadataOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary>Devuelve el desplazamiento desde el inicio de los metadatos hasta la tabla especificada.</summary>
      <param name="reader" />
      <param name="tableIndex" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="tableIndex" /> no es un índice de tabla válido.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableRowCount(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary>Devuelve el número de filas de la tabla especificada.</summary>
      <param name="reader" />
      <param name="tableIndex" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="tableIndex" /> no es un índice de tabla válido.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableRowSize(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary>Devuelve el tamaño de una fila de la tabla especificada.</summary>
      <param name="reader" />
      <param name="tableIndex" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="tableIndex" /> no es un índice de tabla válido.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTypesWithEvents(System.Reflection.Metadata.MetadataReader)">
      <summary>Enumera los tipos que definen uno o varios eventos.</summary>
      <param name="reader" />
      <returns>La secuencia resultante corresponde exactamente a las entradas de la tabla EventMap, es decir, el valor <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> número N devuelto se almacena en la fila número N de EventMap.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTypesWithProperties(System.Reflection.Metadata.MetadataReader)">
      <summary>Enumera los tipos que definen una o varias propiedades.</summary>
      <param name="reader" />
      <returns>La secuencia resultante corresponde exactamente a las entradas de la tabla de mapa de propiedades, es decir, el valor <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> número N devuelto se almacena en la fila número N del mapa de propiedades.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)">
      <summary>Dado un identificador de tipo y una clase de tipo sin formato en un blob de firma, determina si el tipo de destino es un tipo de valor o de referencia.</summary>
      <param name="reader" />
      <param name="typeHandle" />
      <param name="rawTypeKind" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataRootBuilder">
      <summary>Generador de una raíz de metadatos que se va a insertar en una imagen ejecutable portable.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.#ctor(System.Reflection.Metadata.Ecma335.MetadataBuilder,System.String,System.Boolean)">
      <summary>Crea un generador de una raíz de metadatos.</summary>
      <param name="tablesAndHeaps">Un generador rellenado con entidades de metadatos almacenadas en tablas y valores almacenados en montones. Las entidades y los valores se enumerarán al serializar la raíz de metadatos.</param>
      <param name="metadataVersion">La cadena de versión escrita en el encabezado de los metadatos. El valor predeterminado es "v4.0.30319".</param>
      <param name="suppressValidation">
        <see langword="true" /> para suprimir la validación básica de las tablas de metadatos durante la serialización; de lo contrario, <paramref name="false" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="tablesAndHeaps" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="metadataVersion" /> es demasiado largo (el número de bytes cuando la codificación UTF8 debe ser inferior a 255).</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.Serialize(System.Reflection.Metadata.BlobBuilder,System.Int32,System.Int32)">
      <summary>Serializa el contenido de la raíz de los metadatos en el objeto <see cref="T:System.Reflection.Metadata.BlobBuilder" /> dado.</summary>
      <param name="builder">Generador en el que se va a escribir.</param>
      <param name="methodBodyStreamRva">La dirección virtual relativa del inicio de la secuencia del cuerpo del método. Se usa para calcular el valor final de los campos RVA de la tabla MethodDef.</param>
      <param name="mappedFieldDataStreamRva">La dirección virtual relativa del inicio de la secuencia de datos de inicialización de campos. Se usa para calcular el valor final de los campos RVA de la tabla FieldRVA.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="builder" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="methodBodyStreamRva" /> o <paramref name="mappedFieldDataStreamRva" /> es negativo.</exception>
      <exception cref="T:System.InvalidOperationException">Una tabla de metadatos no está ordenada según lo requiera la especificación, y <see cref="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.SuppressValidation" /> es <see langword="false" />.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.MetadataVersion">
      <summary>La versión de los metadatos.</summary>
      <returns>Cadena que representa la versión de los metadatos.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.Sizes">
      <summary>Devuelve los tamaños de varias estructuras de metadatos.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.SuppressValidation">
      <summary>Determina si se debe suprimir la validación básica de las tablas de metadatos. La validación comprueba que las entradas de las tablas se han agregado en el orden requerido por la especificación ECMA. No aplica todos los requisitos de especificación en las tablas de metadatos.</summary>
      <returns>
        <see langword="true" /> para suprimir la validación básica de las tablas de metadatos; en caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataSizes">
      <summary>Proporciona información sobre los tamaños de diversas estructuras de metadatos.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataSizes.GetAlignedHeapSize(System.Reflection.Metadata.Ecma335.HeapIndex)">
      <summary>Devuelve el tamaño alineado del montón especificado.</summary>
      <param name="index" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataSizes.ExternalRowCounts">
      <summary>Recuento de filas de la tabla externa.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataSizes.HeapSizes">
      <summary>Tamaños de montón exactos (sin alinear).</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataSizes.RowCounts">
      <summary>Recuentos de filas de tabla.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataTokens" />
    <member name="F:System.Reflection.Metadata.Ecma335.MetadataTokens.HeapCount">
      <summary>Número máximo de tablas que pueden estar presentes en los metadatos de Ecma335.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount">
      <summary>Número máximo de tablas que pueden estar presentes en los metadatos de Ecma335.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.AssemblyFileHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.AssemblyReferenceHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.BlobHandle(System.Int32)">
      <param name="offset" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ConstantHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.CustomAttributeHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.CustomDebugInformationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.DeclarativeSecurityAttributeHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.DocumentHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.DocumentNameBlobHandle(System.Int32)">
      <param name="offset" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.EntityHandle(System.Int32)">
      <summary>Crea un identificador de entidad a partir de un valor de token.</summary>
      <param name="token" />
      <exception cref="T:System.ArgumentException">
        <paramref name="token" /> no es un token de entidad de metadatos válido.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.EntityHandle(System.Reflection.Metadata.Ecma335.TableIndex,System.Int32)">
      <summary>Crea una instancia de <see cref="T:System.Reflection.Metadata.EntityHandle" /> a partir de un valor de token.</summary>
      <param name="tableIndex" />
      <param name="rowNumber" />
      <exception cref="T:System.ArgumentException">
        <paramref name="tableIndex" /> no es un índice de tabla válido.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.EventDefinitionHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ExportedTypeHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.FieldDefinitionHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GenericParameterConstraintHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GenericParameterHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.BlobHandle)">
      <summary>Obtiene el desplazamiento de los datos del montón de metadatos correspondiente al elemento <paramref name="handle" /> especificado.</summary>
      <param name="handle" />
      <returns>Desplazamiento de base 0, o bien -1 si <paramref name="handle" /> solo se puede interpretar en un contexto de un elemento <see cref="T:System.Reflection.Metadata.MetadataReader" /> o <see cref="T:System.Reflection.Metadata.Ecma335.MetadataBuilder" /> específico.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.GuidHandle)">
      <summary>Obtiene el desplazamiento de los datos del montón de metadatos correspondiente al elemento <paramref name="handle" /> especificado.</summary>
      <param name="handle" />
      <returns>Índice de base 1 en el montón #Guid. A diferencia de otros montones, que son esencialmente matrices de bytes, el montón #Guid es una matriz de GUID de 16 bytes.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.Handle)">
      <summary>Obtiene el desplazamiento de los datos del montón de metadatos correspondiente al elemento <paramref name="handle" /> especificado.</summary>
      <param name="handle" />
      <returns>Un desplazamiento en el montón correspondiente, o bien -1 si <paramref name="handle" /> solo se puede interpretar en un contexto de un elemento <see cref="T:System.Reflection.Metadata.MetadataReader" /> o <see cref="T:System.Reflection.Metadata.Ecma335.MetadataBuilder" /> específico.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Handle)">
      <summary>Obtiene el desplazamiento de los datos del montón de metadatos correspondiente al elemento <paramref name="handle" /> especificado en el contexto de <paramref name="reader" />.</summary>
      <param name="reader" />
      <param name="handle" />
      <exception cref="T:System.NotSupportedException">No se permite la operación para el parámetro <paramref name="handle" /> especificado.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="handle" /> no es válido.</exception>
      <returns>Desplazamiento de base 0, o -1 si <paramref name="handle" /> no es un identificador de montón de metadatos.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.StringHandle)">
      <summary>Obtiene el desplazamiento de los datos del montón de metadatos correspondiente al elemento <paramref name="handle" /> especificado.</summary>
      <param name="handle" />
      <returns>Un desplazamiento de base 0, o bien -1 si <paramref name="handle" /> solo se puede interpretar en un contexto de un elemento <see cref="T:System.Reflection.Metadata.MetadataReader" /> o <see cref="T:System.Reflection.Metadata.Ecma335.MetadataBuilder" /> específico.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.UserStringHandle)">
      <summary>Obtiene el desplazamiento de los datos del montón de metadatos correspondiente al elemento <paramref name="handle" /> especificado.</summary>
      <param name="handle" />
      <returns>Desplazamiento de base cero.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.EntityHandle)">
      <summary>Obtiene el número de fila de una entrada de la tabla de metadatos que corresponde al elemento <paramref name="handle" /> especificado.</summary>
      <param name="handle" />
      <returns>Número de fila de base 1, o bien -1 si <paramref name="handle" /> solo se puede interpretar en un contexto de un elemento <see cref="T:System.Reflection.Metadata.MetadataReader" /> específico.
Vea <see cref="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)">
      <summary>Obtiene el número de fila de una entrada de la tabla de metadatos que corresponde al elemento <paramref name="handle" /> especificado en el contexto de <paramref name="reader" />.</summary>
      <param name="reader" />
      <param name="handle" />
      <exception cref="T:System.ArgumentException">El parámetro <paramref name="handle" /> no es un identificador de tabla de metadatos válido.</exception>
      <returns>Número de fila de base 1.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.EntityHandle)">
      <summary>Obtiene el token de metadatos del elemento <paramref name="handle" /> especificado.</summary>
      <param name="handle" />
      <returns>Token de metadatos, o bien 0 si <paramref name="handle" /> solo se puede interpretar en un contexto de un elemento <see cref="T:System.Reflection.Metadata.MetadataReader" /> específico.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.Handle)">
      <summary>Obtiene el token de metadatos del elemento <paramref name="handle" /> especificado.</summary>
      <param name="handle" />
      <exception cref="T:System.ArgumentException">Handle representa una entidad de metadatos que no tiene un token.
Un token solo se puede recuperar para un identificador de tabla de metadatos o un identificador de montón de tipo <see cref="F:System.Reflection.Metadata.HandleKind.UserString" />.</exception>
      <returns>Token de metadatos, o bien 0 si <paramref name="handle" /> solo se puede interpretar en un contexto de un elemento <see cref="T:System.Reflection.Metadata.MetadataReader" /> específico.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)">
      <summary>Obtiene el token de metadatos del elemento <paramref name="handle" /> especificado en el contexto de <paramref name="reader" />.</summary>
      <param name="reader" />
      <param name="handle" />
      <exception cref="T:System.NotSupportedException">No se permite la operación para el parámetro <paramref name="handle" /> especificado.</exception>
      <returns>Token de metadatos.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Handle)">
      <summary>Obtiene el token de metadatos del elemento <paramref name="handle" /> especificado en el contexto de <paramref name="reader" />.</summary>
      <param name="reader" />
      <param name="handle" />
      <exception cref="T:System.ArgumentException">Handle representa una entidad de metadatos que no tiene un token.
Un token solo se puede recuperar para un identificador de tabla de metadatos o un identificador de montón de tipo <see cref="F:System.Reflection.Metadata.HandleKind.UserString" />.</exception>
      <exception cref="T:System.NotSupportedException">No se permite la operación para el parámetro <paramref name="handle" /> especificado.</exception>
      <returns>Token de metadatos.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GuidHandle(System.Int32)">
      <param name="offset" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.Handle(System.Int32)">
      <summary>Crea un identificador a partir de un valor de token.</summary>
      <param name="token" />
      <exception cref="T:System.ArgumentException">
        <paramref name="token" /> no es un token de metadatos válido.
Debe codificar una entidad de tabla de metadatos o un desplazamiento en el montón de <see cref="F:System.Reflection.Metadata.HandleKind.UserString" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.Handle(System.Reflection.Metadata.Ecma335.TableIndex,System.Int32)">
      <summary>Crea una instancia de <see cref="T:System.Reflection.Metadata.EntityHandle" /> a partir de un valor de token.</summary>
      <param name="tableIndex" />
      <param name="rowNumber" />
      <exception cref="T:System.ArgumentException">
        <paramref name="tableIndex" /> no es un índice de tabla válido.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ImportScopeHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.InterfaceImplementationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.LocalConstantHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.LocalScopeHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.LocalVariableHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ManifestResourceHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MemberReferenceHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDebugInformationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDefinitionHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodImplementationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodSpecificationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ModuleReferenceHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ParameterHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.PropertyDefinitionHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.StandaloneSignatureHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.StringHandle(System.Int32)">
      <param name="offset" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TryGetHeapIndex(System.Reflection.Metadata.HandleKind,System.Reflection.Metadata.Ecma335.HeapIndex@)">
      <summary>Obtiene el elemento <see cref="T:System.Reflection.Metadata.Ecma335.HeapIndex" /> del montón correspondiente al elemento <see cref="T:System.Reflection.Metadata.HandleKind" /> especificado.</summary>
      <param name="type">Tipo de identificador.</param>
      <param name="index">Índice del montón.</param>
      <returns>
        <see langword="true" /> si el tipo de identificador corresponde a un montón de Ecma335; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TryGetTableIndex(System.Reflection.Metadata.HandleKind,System.Reflection.Metadata.Ecma335.TableIndex@)">
      <summary>Obtiene el elemento <see cref="T:System.Reflection.Metadata.Ecma335.TableIndex" /> de la tabla correspondiente al elemento <see cref="T:System.Reflection.Metadata.HandleKind" /> especificado.</summary>
      <param name="type">Tipo de identificador.</param>
      <param name="index">Índice de la tabla.</param>
      <returns>
        <see langword="true" /> si el tipo de identificador corresponde a una tabla de Ecma335 o PDB portátil; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TypeDefinitionHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TypeReferenceHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TypeSpecificationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.UserStringHandle(System.Int32)">
      <param name="offset" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MethodBodyAttributes">
      <summary>Define los atributos del cuerpo de método.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MethodBodyAttributes.InitLocals">
      <summary>Inicializa las variables locales que el método define como cero y asigna dinámicamente la memoria local.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MethodBodyAttributes.None">
      <summary>No realiza ninguna inicialización de la memoria local.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder">
      <summary>Proporciona un codificador para una secuencia de cuerpo de método.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Int32,System.Int32,System.Int32,System.Boolean,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes)">
      <summary>Codifica un cuerpo de método y lo agrega a la secuencia de cuerpo de método mediante el tamaño de código proporcionado, el tamaño de pila máximo, el número de regiones de excepción, el identificador de firma de las variables locales y los atributos de cuerpo de método, y permite indicar si las regiones de excepción deben codificarse en formato pequeño o no.</summary>
      <param name="codeSize">Número de bytes que se van a reservar para instrucciones.</param>
      <param name="maxStack">Tamaño de pila máximo.</param>
      <param name="exceptionRegionCount">Número de regiones de excepción.</param>
      <param name="hasSmallExceptionRegions">
        <see langword="true" /> Si las regiones de excepción se deben codificar en formato pequeño; en caso contrario, <see langword="false" />.</param>
      <param name="localVariablesSignature">Identificador de firma de las variables locales.</param>
      <param name="attributes">Atributos del cuerpo de método.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="codeSize" />, <paramref name="exceptionRegionCount" /> o <paramref name="maxStack" /> están fuera del intervalo permitido.</exception>
      <returns>Desplazamiento del cuerpo codificado en la secuencia del cuerpo de método.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Int32,System.Int32,System.Int32,System.Boolean,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes,System.Boolean)">
      <summary>Codifica un cuerpo de método y lo agrega a la secuencia de cuerpo de método mediante el tamaño de código proporcionado, el tamaño de pila máximo, el número de regiones de excepción, el identificador de firma de las variables locales y los atributos de cuerpo de método, y permite indicar si las regiones de excepción deben codificarse en formato pequeño o no; también, permite indicar si el método se debe asignar desde el grupo de memoria local dinámica o no.</summary>
      <param name="codeSize">Número de bytes que se van a reservar para instrucciones.</param>
      <param name="maxStack">Tamaño de pila máximo.</param>
      <param name="exceptionRegionCount">Número de regiones de excepción.</param>
      <param name="hasSmallExceptionRegions">
        <see langword="true" /> Si las regiones de excepción se deben codificar en formato pequeño; en caso contrario, <see langword="false" />.</param>
      <param name="localVariablesSignature">Identificador de firma de las variables locales.</param>
      <param name="attributes">Atributos del cuerpo de método.</param>
      <param name="hasDynamicStackAllocation">
        <see langword="true" /> Si el método se asigna desde el grupo de memoria local dinámica (la instrucción <see langword="localloc" />); en caso contrario, <see langword="false" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="codeSize" />, <paramref name="exceptionRegionCount" /> o <paramref name="maxStack" /> están fuera del intervalo permitido.</exception>
      <returns>Desplazamiento del cuerpo codificado en la secuencia del cuerpo de método.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Reflection.Metadata.Ecma335.InstructionEncoder,System.Int32,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes)">
      <summary>Codifica un cuerpo de método y lo agrega a la secuencia de cuerpo de método.</summary>
      <param name="instructionEncoder">Codificador de instrucciones.</param>
      <param name="maxStack">Tamaño de pila máximo.</param>
      <param name="localVariablesSignature">Identificador de firma de las variables locales.</param>
      <param name="attributes">Atributos del cuerpo de método.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="instructionEncoder" /> tiene un valor predeterminado.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="maxStack" /> está fuera del intervalo [0, <see cref="F:System.UInt16.MaxValue" />].</exception>
      <exception cref="T:System.InvalidOperationException">No se ha marcado una etiqueta como destino de una bifurcación en la secuencia de instrucciones, o la distancia entre una instrucción de bifurcación y la etiqueta de destino no se ajusta al tamaño del operando de la instrucción.</exception>
      <returns>Desplazamiento del cuerpo codificado en la secuencia del cuerpo de método.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Reflection.Metadata.Ecma335.InstructionEncoder,System.Int32,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes,System.Boolean)">
      <summary>Codifica un cuerpo de método y lo agrega a la secuencia de cuerpo de método mediante el codificador de instrucciones proporcionado, el tamaño de pila máximo, el identificador de firma de las variables locales y los atributos de cuerpo de método, y permite indicar si el método debe asignarse desde el grupo de memoria local dinámica o no.</summary>
      <param name="instructionEncoder">Codificador de instrucciones.</param>
      <param name="maxStack">Tamaño de pila máximo.</param>
      <param name="localVariablesSignature">Identificador de firma de las variables locales.</param>
      <param name="attributes">Atributos del cuerpo de método.</param>
      <param name="hasDynamicStackAllocation">
        <see langword="true" /> Si el método se asigna desde el grupo de memoria local dinámica (el IL contiene la instrucción <see langword="localloc" />); en caso contrario, <see langword="false" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="instructionEncoder" /> tiene un valor predeterminado.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="maxStack" /> está fuera del intervalo [0, <see cref="F:System.UInt16.MaxValue" />].</exception>
      <exception cref="T:System.InvalidOperationException">No se ha marcado una etiqueta como destino de una bifurcación en la secuencia de instrucciones, o la distancia entre una instrucción de bifurcación y la etiqueta de destino no se ajusta al tamaño del operando de la instrucción.</exception>
      <returns>Desplazamiento del cuerpo codificado en la secuencia del cuerpo de método.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody">
      <summary>Describe un cuerpo de método. Esta clase está pensada para usarse junto con la clase <see cref="T:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder" />.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody.ExceptionRegions">
      <summary>Obtiene un objeto de codificador que se puede usar para codificar regiones de excepción en el cuerpo de método.</summary>
      <returns>Instancia del codificador de la región de excepción.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody.Instructions">
      <summary>Obtiene un blob reservado para instrucciones.</summary>
      <returns>Un BLOB reservado para las instrucciones.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody.Offset">
      <summary>Obtiene el desplazamiento del cuerpo de método codificado en la secuencia de cuerpo de método.</summary>
      <returns>Desplazamiento del cuerpo del método codificado en la secuencia del cuerpo del método.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder">
      <summary>Proporciona un codificador para las signaturas de método.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.#ctor(System.Reflection.Metadata.BlobBuilder,System.Boolean)">
      <param name="builder" />
      <param name="hasVarArgs" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.Parameters(System.Int32,System.Action{System.Reflection.Metadata.Ecma335.ReturnTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.ParametersEncoder})">
      <summary>Codifica el tipo de valor devuelto y los parámetros proporcionados.</summary>
      <param name="parameterCount">Número de parámetros.</param>
      <param name="returnType">El método al que se llama primero para codificar el tipo de valor devuelto.</param>
      <param name="parameters">El método al que se llama en segundo lugar para codificar los parámetros.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="returnType" /> o <paramref name="parameters" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.Parameters(System.Int32,System.Reflection.Metadata.Ecma335.ReturnTypeEncoder@,System.Reflection.Metadata.Ecma335.ParametersEncoder@)">
      <summary>Codifica el tipo de valor devuelto y los parámetros proporcionados, que se deben usar en el orden en que aparecen en la lista de parámetros.</summary>
      <param name="parameterCount">Número de parámetros.</param>
      <param name="returnType">Método al que se llama primero para codificar los tipos de valor devuelto.</param>
      <param name="parameters">El método al que se llama en segundo lugar para codificar los parámetros.</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.Builder" />
    <member name="P:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.HasVarArgs" />
    <member name="T:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <summary>Inicializa una nueva instancia de la estructura <see cref="T:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder" />.</summary>
      <param name="builder">Generador para codificar el argumento con nombre.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.AddArgument(System.Boolean,System.Action{System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.NameEncoder},System.Action{System.Reflection.Metadata.Ecma335.LiteralEncoder})">
      <summary>Codifica un argumento con nombre (un campo o una propiedad).</summary>
      <param name="isField">
        <see langword="true" /> para codificar un campo, <see langword="false" /> para codificar una propiedad.</param>
      <param name="type">Método al que se llama primero para codificar el tipo del argumento.</param>
      <param name="name">Método al que se llama en segundo lugar para codificar el nombre del campo o de la propiedad.</param>
      <param name="literal">Método al que se llama en tercer lugar para codificar el valor literal del argumento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" />, <paramref name="name" /> o <paramref name="literal" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.AddArgument(System.Boolean,System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder@,System.Reflection.Metadata.Ecma335.NameEncoder@,System.Reflection.Metadata.Ecma335.LiteralEncoder@)">
      <summary>Codifica un argumento con nombre (un campo o una propiedad) y devuelve tres codificadores que deben usarse en el orden en que aparecen en la lista de parámetros.</summary>
      <param name="isField">
        <see langword="true" /> para codificar un campo, <see langword="false" /> para codificar una propiedad.</param>
      <param name="type">Método al que se llama primero para codificar el tipo del argumento.</param>
      <param name="name">Método al que se llama en segundo lugar para codificar el nombre del campo o de la propiedad.</param>
      <param name="literal">Método al que se llama en tercer lugar para codificar el valor literal del argumento.</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.Object" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.ScalarType" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.SZArray" />
    <member name="P:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.NameEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NameEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.NameEncoder.Name(System.String)">
      <param name="name" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.NameEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.ParametersEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParametersEncoder.#ctor(System.Reflection.Metadata.BlobBuilder,System.Boolean)">
      <param name="builder" />
      <param name="hasVarArgs" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ParametersEncoder.AddParameter" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParametersEncoder.StartVarArgs" />
    <member name="P:System.Reflection.Metadata.Ecma335.ParametersEncoder.Builder" />
    <member name="P:System.Reflection.Metadata.Ecma335.ParametersEncoder.HasVarArgs" />
    <member name="T:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.CustomModifiers" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.Type(System.Boolean)">
      <param name="isByRef" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.TypedReference" />
    <member name="P:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.PermissionSetEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.AddPermission(System.String,System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="typeName" />
      <param name="encodedArguments" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.AddPermission(System.String,System.Reflection.Metadata.BlobBuilder)">
      <param name="typeName" />
      <param name="encodedArguments" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.PortablePdbBuilder">
      <summary>Representa el generador de una imagen PDB portable.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.#ctor(System.Reflection.Metadata.Ecma335.MetadataBuilder,System.Collections.Immutable.ImmutableArray{System.Int32},System.Reflection.Metadata.MethodDefinitionHandle,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Reflection.Metadata.BlobContentId})">
      <summary>Crea un generador de una imagen PDB portable.</summary>
      <param name="tablesAndHeaps">Un generador rellenado con entidades de metadatos de depuración almacenadas en tablas y valores almacenados en montones. Las entidades y los valores se enumeran al serializar la imagen PDB portable.</param>
      <param name="typeSystemRowCounts">Recuentos de filas de todas las tablas que contienen los metadatos del sistema de tipos asociados. Cada ranura de la matriz corresponde a una tabla (<see cref="T:System.Reflection.Metadata.Ecma335.TableIndex" />). La longitud de la matriz debe ser igual a <see cref="F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount" />.</param>
      <param name="entryPoint">Identificador de definición del método de punto de entrada.</param>
      <param name="idProvider">Función que calcula el identificador de contenido representado como una secuencia de blobs. Si no se especifica, se usa una función predeterminada que omite el contenido y devuelve un identificador de contenido basado en la hora actual (<see cref="M:System.Reflection.Metadata.BlobContentId.GetTimeBasedProvider" />). Debe especificar una función determinista para generar una imagen PDB portable determinista.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="tablesAndHeaps" /> o <paramref name="typeSystemRowCounts" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.Serialize(System.Reflection.Metadata.BlobBuilder)">
      <summary>Serializa el contenido del PDB portable en el objeto <see cref="T:System.Reflection.Metadata.BlobBuilder" /> dado.</summary>
      <param name="builder">Generador en el que se va a escribir.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="builder" /> es <see langword="null" />.</exception>
      <returns>Identificador del contenido serializado.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.FormatVersion" />
    <member name="P:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.IdProvider" />
    <member name="P:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.MetadataVersion" />
    <member name="T:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.CustomModifiers" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.Type(System.Boolean)">
      <param name="isByRef" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.TypedReference" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.Void" />
    <member name="P:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.ScalarEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.Constant(System.Object)">
      <summary>Codifica un literal constante.</summary>
      <param name="value">Constante de tipo <see cref="T:System.Boolean" />, <see cref="T:System.Byte" />, <see cref="T:System.SByte" />, <see cref="T:System.Int16" />, <see cref="T:System.UInt16" />, <see cref="T:System.Int32" />, <see cref="T:System.UInt32" />, <see cref="T:System.Int64" />, <see cref="T:System.UInt64" />, <see cref="T:System.Single" />, <see cref="T:System.Double" />, <see cref="T:System.Char" /> (codificado como un carácter Unicode de dos bytes), <see cref="T:System.String" /> (codificado como SerString) o <see cref="T:System.Enum" /> (codificado como un valor entero subyacente).</param>
      <exception cref="T:System.ArgumentException">Tipo de constante no esperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.NullArray">
      <summary>Codifica un literal <see langword="null" /> de tipo <see cref="T:System.Array" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.SystemType(System.String)">
      <summary>Codifica un literal de tipo <see cref="T:System.Type" /> (que puede ser <see langword="null" />).</summary>
      <param name="serializedTypeName">Nombre del tipo o <see langword="null" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="serializedTypeName" /> está vacía.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ScalarEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.SignatureDecoder`2">
      <summary>Descodifica los blobs de signatura.</summary>
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.#ctor(System.Reflection.Metadata.ISignatureTypeProvider{`0,`1},System.Reflection.Metadata.MetadataReader,`1)">
      <summary>Crea un nuevo <see cref="T:System.Reflection.Metadata.Ecma335.SignatureDecoder`2" />.</summary>
      <param name="provider">Proveedor usado para obtener símbolos de tipo cuando se descodifica la signatura.</param>
      <param name="metadataReader">Lector de metadatos del que se obtuvo la signatura. Puede ser <see langword="null" /> si el proveedor dado lo permite.</param>
      <param name="genericContext">Contexto adicional necesario para resolver parámetros genéricos.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeFieldSignature(System.Reflection.Metadata.BlobReader@)">
      <summary>Descodifica un blob de signatura de campo y hace avanzar el lector después de la signatura.</summary>
      <param name="blobReader">Lector de blobs colocado en una signatura de campo.</param>
      <returns>Tipo de campo descodificado.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeLocalSignature(System.Reflection.Metadata.BlobReader@)">
      <summary>Descodifica un blob de signatura de variable local y hace avanzar el lector después de la signatura.</summary>
      <param name="blobReader">Lector de blobs colocado en una signatura de variable local.</param>
      <exception cref="T:System.BadImageFormatException">La firma de la variable local no es válida.</exception>
      <returns>Tipos de variable local.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeMethodSignature(System.Reflection.Metadata.BlobReader@)">
      <summary>Representa un método (definición, referencia o independiente) o un blob de signatura de propiedad.</summary>
      <param name="blobReader">Lector de blobs colocado en una signatura de método.</param>
      <exception cref="T:System.BadImageFormatException">La firma del método no es válida.</exception>
      <returns>Signatura del método descodificado.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeMethodSpecificationSignature(System.Reflection.Metadata.BlobReader@)">
      <summary>Descodifica un blob de signatura de especificación de método y hace avanzar el lector después de la signatura.</summary>
      <param name="blobReader">Lector de blobs colocado en una signatura de especificación de método válida.</param>
      <returns>Tipos usados para crear una instancia de un método genérico mediante la especificación del método.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeType(System.Reflection.Metadata.BlobReader@,System.Boolean)">
      <summary>Descodifica un tipo insertado en una signatura y hace avanzar el lector después del tipo.</summary>
      <param name="blobReader">Lector de blobs colocado en el objeto <see cref="T:System.Reflection.Metadata.SignatureTypeCode" /> inicial.</param>
      <param name="allowTypeSpecifications">
        <see langword="true" /> para permitir que un objeto <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /> siga un elemento (CLASS | VALUETYPE) en la signatura; en caso contrario, <see langword="false" />.</param>
      <exception cref="T:System.BadImageFormatException">El lector no se colocó en un tipo de firma válido.</exception>
      <returns>Tipo descodificado.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Array(System.Action{System.Reflection.Metadata.Ecma335.SignatureTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.ArrayShapeEncoder})">
      <summary>Codifica un tipo de matriz.</summary>
      <param name="elementType">Se llama en primer lugar para codificar el tipo del elemento.</param>
      <param name="arrayShape">Se llama en segundo lugar para codificar la forma de la matriz.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="elementType" /> o <paramref name="arrayShape" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Array(System.Reflection.Metadata.Ecma335.SignatureTypeEncoder@,System.Reflection.Metadata.Ecma335.ArrayShapeEncoder@)">
      <summary>Codifica un tipo de matriz. Devuelve un par de codificadores que se deben usar en el orden en que aparecen en la lista de parámetros.</summary>
      <param name="elementType">Se usa en primer lugar para codificar el tipo del elemento.</param>
      <param name="arrayShape">Se usa en segundo lugar para codificar la forma de la matriz.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Boolean" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Byte" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Char" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.CustomModifiers">
      <summary>Inicia una signatura de un tipo con modificadores personalizados.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Double" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.FunctionPointer(System.Reflection.Metadata.SignatureCallingConvention,System.Reflection.Metadata.Ecma335.FunctionPointerAttributes,System.Int32)">
      <summary>Inicia una signatura de puntero de función.</summary>
      <param name="convention">Convención de llamada</param>
      <param name="attributes">Atributos de puntero de función.</param>
      <param name="genericParameterCount">Recuento de parámetros genéricos.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="attributes" /> no es válido.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="genericParameterCount" /> no está en el intervalo [0, 0xffff].</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.GenericInstantiation(System.Reflection.Metadata.EntityHandle,System.Int32,System.Boolean)">
      <summary>Inicia una signatura de creación de instancias genérica.</summary>
      <param name="genericType">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> o <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />.</param>
      <param name="genericArgumentCount">Recuento de argumentos genéricos.</param>
      <param name="isValueType">
        <see langword="true" /> para marcar el tipo como tipo de valor, <see langword="false" /> para marcarlo como un tipo de referencia en la signatura.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="genericType" /> no tiene el tipo de identificador esperado.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="genericArgumentCount" /> no está en el intervalo [1, 0xffff].</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.GenericMethodTypeParameter(System.Int32)">
      <summary>Codifica una referencia al parámetro de tipo de un método genérico contenedor.</summary>
      <param name="parameterIndex">Índice del parámetro.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="parameterIndex" /> no está en el intervalo [0, 0xffff].</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.GenericTypeParameter(System.Int32)">
      <summary>Codifica una referencia al parámetro de tipo de un tipo genérico contenedor.</summary>
      <param name="parameterIndex">Índice del parámetro.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="parameterIndex" /> no está en el intervalo [0, 0xffff].</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Int16" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Int32" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Int64" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.IntPtr" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Object" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Pointer">
      <summary>Inicia la signatura de puntero.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.PrimitiveType(System.Reflection.Metadata.PrimitiveTypeCode)">
      <summary>Escribe código de tipo primitivo.</summary>
      <param name="type">Cualquier código de tipo primitivo excepto <see cref="F:System.Reflection.Metadata.PrimitiveTypeCode.TypedReference" /> y <see cref="F:System.Reflection.Metadata.PrimitiveTypeCode.Void" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="type" /> no es válido en este contexto.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.SByte" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Single" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.String" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.SZArray">
      <summary>Inicia la signatura de matriz SZ (vector).</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Type(System.Reflection.Metadata.EntityHandle,System.Boolean)">
      <summary>Representa una referencia a un tipo.</summary>
      <param name="type">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> o <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />.</param>
      <param name="isValueType">
        <see langword="true" /> para marcar el tipo como tipo de valor, <see langword="false" /> para marcarlo como un tipo de referencia en la signatura.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="type" /> no tiene el tipo de identificador esperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UInt16" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UInt32" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UInt64" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UIntPtr" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.VoidPointer">
      <summary>Codifica un puntero nulo (<c>void*</c>).</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.TableIndex" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Assembly" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyOS" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyProcessor" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyRefOS" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyRefProcessor" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ClassLayout" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Constant" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.CustomAttribute" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.CustomDebugInformation" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.DeclSecurity" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Document" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EncLog" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EncMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Event" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EventMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EventPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ExportedType" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Field" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldLayout" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldMarshal" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldRva" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.File" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.GenericParam" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.GenericParamConstraint" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ImplMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ImportScope" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.InterfaceImpl" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.LocalConstant" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.LocalScope" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.LocalVariable" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ManifestResource" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MemberRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodDebugInformation" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodDef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodImpl" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodSemantics" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodSpec" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Module" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ModuleRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.NestedClass" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Param" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ParamPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Property" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.PropertyMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.PropertyPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.StandAloneSig" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.StateMachineMethod" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.TypeDef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.TypeRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.TypeSpec" />
    <member name="T:System.Reflection.Metadata.Ecma335.VectorEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.VectorEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.VectorEncoder.Count(System.Int32)">
      <param name="count" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.VectorEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.EntityHandle">
      <summary>Representa una entidad de metadatos (por ejemplo, una referencia de tipo, una definición de tipo, una especificación de tipo, una definición de método o un atributo personalizado).</summary>
    </member>
    <member name="F:System.Reflection.Metadata.EntityHandle.AssemblyDefinition" />
    <member name="F:System.Reflection.Metadata.EntityHandle.ModuleDefinition" />
    <member name="M:System.Reflection.Metadata.EntityHandle.Equals(System.Object)">
      <summary>Devuelve un valor que indica si la instancia actual y el objeto especificado son iguales.</summary>
      <param name="obj">Objeto que se va a comparar con la instancia actual.</param>
      <returns>
        <see langword="true" /> si <paramref name="obj" /> es <see cref="T:System.Reflection.Metadata.EntityHandle" /> y es igual a la instancia actual; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.Equals(System.Reflection.Metadata.EntityHandle)">
      <summary>Devuelve un valor que indica si la instancia actual y el objeto <see cref="T:System.Reflection.Metadata.EntityHandle" /> especificado son iguales.</summary>
      <param name="other">El valor que se va a comparar con la instancia actual.</param>
      <returns>
        <see langword="true" /> si la instancia actual y <paramref name="other" /> son iguales; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.GetHashCode">
      <summary>Devuelve el código hash de esta instancia.</summary>
      <returns>Código hash de esta instancia.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Equality(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Implicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Inequality(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.EntityHandle.IsNil" />
    <member name="P:System.Reflection.Metadata.EntityHandle.Kind" />
    <member name="T:System.Reflection.Metadata.EventAccessors" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Adder" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Others" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Raiser" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Remover" />
    <member name="T:System.Reflection.Metadata.EventDefinition" />
    <member name="M:System.Reflection.Metadata.EventDefinition.GetAccessors" />
    <member name="M:System.Reflection.Metadata.EventDefinition.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.EventDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.EventDefinition.Name" />
    <member name="P:System.Reflection.Metadata.EventDefinition.Type" />
    <member name="T:System.Reflection.Metadata.EventDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.Equals(System.Reflection.Metadata.EventDefinitionHandle)">
      <summary>Indica si el objeto actual es igual a otro objeto del mismo tipo.</summary>
      <param name="other">Objeto que se va a comparar con este objeto.</param>
      <returns>
        <see langword="true" /> si el objeto actual es igual al parámetro <paramref name="other" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Equality(System.Reflection.Metadata.EventDefinitionHandle,System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.EventDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.EventDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Implicit(System.Reflection.Metadata.EventDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Implicit(System.Reflection.Metadata.EventDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Inequality(System.Reflection.Metadata.EventDefinitionHandle,System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.EventDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.EventDefinitionHandleCollection" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#EventDefinitionHandle}#GetEnumerator">
      <summary>Devuelve un enumerador que procesa una iteración en la colección.</summary>
      <returns>Enumerador que se puede utilizar para recorrer en iteración la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Devuelve un enumerador que recorre en iteración una colección.</summary>
      <returns>Objeto <see cref="T:System.Collections.IEnumerator" /> que puede usarse para recorrer en iteración la colección.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.EventDefinitionHandleCollection.Count">
      <summary>Obtiene el número de elementos de la colección.</summary>
      <returns>Número de elementos de la colección.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.MoveNext">
      <summary>Desplaza el enumerador al siguiente elemento de la colección.</summary>
      <returns>Es <see langword="true" /> si el enumerador avanzó con éxito hasta el siguiente elemento; es <see langword="false" /> si el enumerador alcanzó el final de la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Establece el enumerador en su posición inicial (antes del primer elemento de la colección).</summary>
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tareas definidas por la aplicación asociadas a la liberación o al restablecimiento de recursos no administrados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ExceptionRegion" />
    <member name="P:System.Reflection.Metadata.ExceptionRegion.CatchType">
      <summary>Obtiene un controlador TypeRef, TypeDef o TypeSpec si la región representa una captura o, de lo contrario, un token nulo (<see langword="default" />(<see cref="T:System.Reflection.Metadata.EntityHandle" />)).</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.FilterOffset">
      <summary>Obtiene el desplazamiento IL del principio del bloque de filtros, o -1 si la región no es un filtro.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.HandlerLength">
      <summary>Obtiene la longitud del controlador de excepciones en bytes.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.HandlerOffset">
      <summary>Obtiene el desplazamiento IL inicial del controlador de excepciones.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.Kind" />
    <member name="P:System.Reflection.Metadata.ExceptionRegion.TryLength">
      <summary>Obtiene la longitud en bytes del bloque try.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.TryOffset">
      <summary>Obtiene el desplazamiento IL inicial del bloque try.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ExceptionRegionKind" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Catch" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Fault" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Filter" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Finally" />
    <member name="T:System.Reflection.Metadata.ExportedType" />
    <member name="M:System.Reflection.Metadata.ExportedType.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ExportedType.Attributes" />
    <member name="P:System.Reflection.Metadata.ExportedType.Implementation">
      <summary>Obtiene un controlador para resolver la implementación del tipo de destino.</summary>
      <returns>
        <list type="bullet">
          <item>
            <description>
              <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" /> que representa otro módulo en el ensamblado.</description>
          </item>
          <item>
            <description>
              <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" /> que representa otro ensamblado si <see cref="P:System.Reflection.Metadata.ExportedType.IsForwarder" /> es <see langword="true" /> .</description>
          </item>
          <item>
            <description>
              <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" /> que representa el tipo exportado que declara en el que está anidado.</description>
          </item>
        </list>
      </returns>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedType.IsForwarder" />
    <member name="P:System.Reflection.Metadata.ExportedType.Name">
      <summary>Obtiene el nombre del tipo de destino, o <see langword="default" /> si el tipo está anidado o definido en un espacio de nombres raíz.</summary>
      <returns>
        <see cref="T:System.Reflection.Metadata.StringHandle" />Instancia de struct.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedType.Namespace">
      <summary>Obtiene el nombre completo del espacio de nombres que contiene el tipo de destino, o <see langword="default" /> si el tipo está anidado o definido en un espacio de nombres raíz.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedType.NamespaceDefinition">
      <summary>Obtiene el controlador de definición del espacio de nombres donde se define el tipo de destino, o <see langword="default" /> si el tipo está anidado o definido en un espacio de nombres raíz.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ExportedTypeHandle" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.Equals(System.Reflection.Metadata.ExportedTypeHandle)">
      <summary>Indica si el objeto actual es igual a otro objeto del mismo tipo.</summary>
      <param name="other">Objeto que se va a comparar con este objeto.</param>
      <returns>
        <see langword="true" /> si el objeto actual es igual al parámetro <paramref name="other" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Equality(System.Reflection.Metadata.ExportedTypeHandle,System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ExportedTypeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ExportedTypeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Implicit(System.Reflection.Metadata.ExportedTypeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Implicit(System.Reflection.Metadata.ExportedTypeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Inequality(System.Reflection.Metadata.ExportedTypeHandle,System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.ExportedTypeHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ExportedTypeHandleCollection">
      <summary>Representa una colección de instancias de <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ExportedTypeHandle}#GetEnumerator">
      <summary>Devuelve un enumerador que procesa una iteración en la colección.</summary>
      <returns>Enumerador que se puede utilizar para recorrer en iteración la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Devuelve un enumerador que recorre en iteración una colección.</summary>
      <returns>Objeto <see cref="T:System.Collections.IEnumerator" /> que puede usarse para recorrer en iteración la colección.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedTypeHandleCollection.Count">
      <summary>Obtiene el número de elementos de la colección.</summary>
      <returns>Número de elementos de la colección.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.MoveNext">
      <summary>Desplaza el enumerador al siguiente elemento de la colección.</summary>
      <returns>Es <see langword="true" /> si el enumerador avanzó con éxito hasta el siguiente elemento; es <see langword="false" /> si el enumerador alcanzó el final de la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Establece el enumerador en su posición inicial (antes del primer elemento de la colección).</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tareas definidas por la aplicación asociadas a la liberación o al restablecimiento de recursos no administrados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.FieldDefinition" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetDeclaringType" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetDefaultValue" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetMarshallingDescriptor" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetOffset">
      <summary>Devuelve el desplazamiento de diseño de campo, o bien -1 si no está disponible.</summary>
      <returns>Desplazamiento de diseño de campo, o bien -1 si no está disponible.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetRelativeVirtualAddress" />
    <member name="P:System.Reflection.Metadata.FieldDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.FieldDefinition.Name" />
    <member name="P:System.Reflection.Metadata.FieldDefinition.Signature" />
    <member name="T:System.Reflection.Metadata.FieldDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.Equals(System.Reflection.Metadata.FieldDefinitionHandle)">
      <summary>Indica si el objeto actual es igual a otro objeto del mismo tipo.</summary>
      <param name="other">Objeto que se va a comparar con este objeto.</param>
      <returns>
        <see langword="true" /> si el objeto actual es igual al parámetro <paramref name="other" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Equality(System.Reflection.Metadata.FieldDefinitionHandle,System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.FieldDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.FieldDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Implicit(System.Reflection.Metadata.FieldDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Implicit(System.Reflection.Metadata.FieldDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Inequality(System.Reflection.Metadata.FieldDefinitionHandle,System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.FieldDefinitionHandleCollection" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#FieldDefinitionHandle}#GetEnumerator">
      <summary>Devuelve un enumerador que procesa una iteración en la colección.</summary>
      <returns>Enumerador que se puede utilizar para recorrer en iteración la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Devuelve un enumerador que recorre en iteración una colección.</summary>
      <returns>Objeto <see cref="T:System.Collections.IEnumerator" /> que puede usarse para recorrer en iteración la colección.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandleCollection.Count">
      <summary>Obtiene el número de elementos de la colección.</summary>
      <returns>Número de elementos de la colección.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.MoveNext">
      <summary>Desplaza el enumerador al siguiente elemento de la colección.</summary>
      <returns>Es <see langword="true" /> si el enumerador avanzó con éxito hasta el siguiente elemento; es <see langword="false" /> si el enumerador alcanzó el final de la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Establece el enumerador en su posición inicial (antes del primer elemento de la colección).</summary>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tareas definidas por la aplicación asociadas a la liberación o al restablecimiento de recursos no administrados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameter" />
    <member name="M:System.Reflection.Metadata.GenericParameter.GetConstraints" />
    <member name="M:System.Reflection.Metadata.GenericParameter.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.GenericParameter.Attributes">
      <summary>Obtiene los atributos que especifican la varianza y las restricciones.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameter.Index">
      <summary>Obtiene el índice de base cero del parámetro dentro de la declaración de tipo o método genérico.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameter.Name">
      <summary>Obtiene el nombre del parámetro genérico.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameter.Parent">
      <summary>Obtiene un objeto <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> o <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> que representa el elemento primario de este parámetro genérico.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterConstraint" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraint.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.GenericParameterConstraint.Parameter">
      <summary>Obtiene el objeto <see cref="T:System.Reflection.Metadata.GenericParameterHandle" /> restringido.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraint.Type">
      <summary>Obtiene un identificador (<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> o <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />) que especifica el tipo concreto que este parámetro genérico puede derivar, o bien la interfaz concreta que puede implementar.</summary>
      <returns>Instancia de <see cref="T:System.Reflection.Metadata.EntityHandle" />.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterConstraintHandle" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.Equals(System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <summary>Indica si el objeto actual es igual a otro objeto del mismo tipo.</summary>
      <param name="other">Objeto que se va a comparar con este objeto.</param>
      <returns>
        <see langword="true" /> si el objeto actual es igual al parámetro <paramref name="other" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Equality(System.Reflection.Metadata.GenericParameterConstraintHandle,System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.GenericParameterConstraintHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.GenericParameterConstraintHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Implicit(System.Reflection.Metadata.GenericParameterConstraintHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Implicit(System.Reflection.Metadata.GenericParameterConstraintHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Inequality(System.Reflection.Metadata.GenericParameterConstraintHandle,System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.GenericParameterConstraintHandleCollection">
      <summary>Representa una colección de restricciones de un parámetro de tipo genérico.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#GenericParameterConstraintHandle}#GetEnumerator">
      <summary>Devuelve un enumerador que procesa una iteración en la colección.</summary>
      <returns>Enumerador que se puede utilizar para recorrer en iteración la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Devuelve un enumerador que recorre en iteración una colección.</summary>
      <returns>Objeto <see cref="T:System.Collections.IEnumerator" /> que puede usarse para recorrer en iteración la colección.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Count">
      <summary>Obtiene el número de elementos de la colección.</summary>
      <returns>Número de elementos de la colección.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Item(System.Int32)">
      <summary>Obtiene el elemento en el índice especificado en la lista de solo lectura.</summary>
      <param name="index">Índice de base cero del elemento que se va a obtener.</param>
      <returns>Elemento en el índice especificado en la lista de solo lectura.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.MoveNext">
      <summary>Desplaza el enumerador al siguiente elemento de la colección.</summary>
      <returns>Es <see langword="true" /> si el enumerador avanzó con éxito hasta el siguiente elemento; es <see langword="false" /> si el enumerador alcanzó el final de la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Establece el enumerador en su posición inicial (antes del primer elemento de la colección).</summary>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tareas definidas por la aplicación asociadas a la liberación o al restablecimiento de recursos no administrados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterHandle" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.Equals(System.Reflection.Metadata.GenericParameterHandle)">
      <summary>Indica si el objeto actual es igual a otro objeto del mismo tipo.</summary>
      <param name="other">Objeto que se va a comparar con este objeto.</param>
      <returns>
        <see langword="true" /> si el objeto actual es igual al parámetro <paramref name="other" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Equality(System.Reflection.Metadata.GenericParameterHandle,System.Reflection.Metadata.GenericParameterHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.GenericParameterHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.GenericParameterHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Implicit(System.Reflection.Metadata.GenericParameterHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Implicit(System.Reflection.Metadata.GenericParameterHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Inequality(System.Reflection.Metadata.GenericParameterHandle,System.Reflection.Metadata.GenericParameterHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.GenericParameterHandleCollection">
      <summary>Representa una colección de parámetros de tipo genérico de un método o tipo.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#GenericParameterHandle}#GetEnumerator">
      <summary>Devuelve un enumerador que procesa una iteración en la colección.</summary>
      <returns>Enumerador que se puede utilizar para recorrer en iteración la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Devuelve un enumerador que recorre en iteración una colección.</summary>
      <returns>Objeto <see cref="T:System.Collections.IEnumerator" /> que puede usarse para recorrer en iteración la colección.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Count">
      <summary>Obtiene el número de elementos de la colección.</summary>
      <returns>Número de elementos de la colección.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Item(System.Int32)">
      <summary>Obtiene el elemento en el índice especificado en la lista de solo lectura.</summary>
      <param name="index">Índice de base cero del elemento que se va a obtener.</param>
      <returns>Elemento en el índice especificado en la lista de solo lectura.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.MoveNext">
      <summary>Desplaza el enumerador al siguiente elemento de la colección.</summary>
      <returns>Es <see langword="true" /> si el enumerador avanzó con éxito hasta el siguiente elemento; es <see langword="false" /> si el enumerador alcanzó el final de la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Establece el enumerador en su posición inicial (antes del primer elemento de la colección).</summary>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tareas definidas por la aplicación asociadas a la liberación o al restablecimiento de recursos no administrados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GuidHandle" />
    <member name="M:System.Reflection.Metadata.GuidHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.Equals(System.Reflection.Metadata.GuidHandle)">
      <summary>Indica si el objeto actual es igual a otro objeto del mismo tipo.</summary>
      <param name="other">Objeto que se va a comparar con este objeto.</param>
      <returns>
        <see langword="true" /> si el objeto actual es igual al parámetro <paramref name="other" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Equality(System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.GuidHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Implicit(System.Reflection.Metadata.GuidHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Inequality(System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.GuidHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.Handle">
      <summary>Representa cualquier entidad de metadatos (como una referencia de tipo, una definición de tipo, una especificación de tipo, una definición de método o un atributo personalizado) o un valor (una cadena, un blob, un GUID o una cadena de usuario).</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Handle.AssemblyDefinition" />
    <member name="F:System.Reflection.Metadata.Handle.ModuleDefinition" />
    <member name="M:System.Reflection.Metadata.Handle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.Handle.Equals(System.Reflection.Metadata.Handle)">
      <summary>Indica si el objeto actual es igual que otro objeto del mismo tipo.</summary>
      <param name="other">Objeto que se va a comparar con este objeto.</param>
      <returns>
        <see langword="true" /> si el objeto actual es igual al parámetro <paramref name="other" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Handle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.Handle.op_Equality(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.Handle.op_Inequality(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.Handle.IsNil" />
    <member name="P:System.Reflection.Metadata.Handle.Kind" />
    <member name="T:System.Reflection.Metadata.HandleComparer" />
    <member name="M:System.Reflection.Metadata.HandleComparer.Compare(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>Compara dos identificadores de entidad.</summary>
      <param name="x">El primer identificador de entidad que se va a comparar.</param>
      <param name="y">El segundo identificador de entidad que se va a comparar.</param>
      <returns>Cero si los identificadores de entidad son iguales y un valor distinto de cero si no lo son.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.Compare(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <summary>Compara dos identificadores.</summary>
      <param name="x">Primer identificador que se va a comparar.</param>
      <param name="y">Segundo identificador que se va a comparar.</param>
      <returns>Cero si los identificadores son iguales y un valor distinto de cero si no lo son.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.Equals(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>Determina si los objetos especificados son iguales.</summary>
      <param name="x">Primer objeto de tipo <paramref name="T" /> que se va a comparar.</param>
      <param name="y">Segundo objeto de tipo <paramref name="T" /> que se va a comparar.</param>
      <returns>
        <see langword="true" /> si los objetos especificados son iguales; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.Equals(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <summary>Determina si los objetos especificados son iguales.</summary>
      <param name="x">Primer objeto de tipo <paramref name="T" /> que se va a comparar.</param>
      <param name="y">Segundo objeto de tipo <paramref name="T" /> que se va a comparar.</param>
      <returns>
        <see langword="true" /> si los objetos especificados son iguales; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.GetHashCode(System.Reflection.Metadata.EntityHandle)">
      <summary>Devuelve un código hash para el objeto especificado.</summary>
      <param name="obj">
        <see cref="T:System.Object" /> para el que se va a devolver un código hash.</param>
      <returns>Código hash para el objeto especificado.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.GetHashCode(System.Reflection.Metadata.Handle)">
      <summary>Devuelve un código hash para el objeto especificado.</summary>
      <param name="obj">
        <see cref="T:System.Object" /> para el que se va a devolver un código hash.</param>
      <returns>Código hash para el objeto especificado.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.HandleComparer.Default" />
    <member name="T:System.Reflection.Metadata.HandleKind" />
    <member name="F:System.Reflection.Metadata.HandleKind.AssemblyDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.AssemblyFile" />
    <member name="F:System.Reflection.Metadata.HandleKind.AssemblyReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.Blob" />
    <member name="F:System.Reflection.Metadata.HandleKind.Constant" />
    <member name="F:System.Reflection.Metadata.HandleKind.CustomAttribute" />
    <member name="F:System.Reflection.Metadata.HandleKind.CustomDebugInformation" />
    <member name="F:System.Reflection.Metadata.HandleKind.DeclarativeSecurityAttribute" />
    <member name="F:System.Reflection.Metadata.HandleKind.Document" />
    <member name="F:System.Reflection.Metadata.HandleKind.EventDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.ExportedType" />
    <member name="F:System.Reflection.Metadata.HandleKind.FieldDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.GenericParameter" />
    <member name="F:System.Reflection.Metadata.HandleKind.GenericParameterConstraint" />
    <member name="F:System.Reflection.Metadata.HandleKind.Guid" />
    <member name="F:System.Reflection.Metadata.HandleKind.ImportScope" />
    <member name="F:System.Reflection.Metadata.HandleKind.InterfaceImplementation" />
    <member name="F:System.Reflection.Metadata.HandleKind.LocalConstant" />
    <member name="F:System.Reflection.Metadata.HandleKind.LocalScope" />
    <member name="F:System.Reflection.Metadata.HandleKind.LocalVariable" />
    <member name="F:System.Reflection.Metadata.HandleKind.ManifestResource" />
    <member name="F:System.Reflection.Metadata.HandleKind.MemberReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodDebugInformation" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodImplementation" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodSpecification" />
    <member name="F:System.Reflection.Metadata.HandleKind.ModuleDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.ModuleReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.NamespaceDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.Parameter" />
    <member name="F:System.Reflection.Metadata.HandleKind.PropertyDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.StandaloneSignature" />
    <member name="F:System.Reflection.Metadata.HandleKind.String" />
    <member name="F:System.Reflection.Metadata.HandleKind.TypeDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.TypeReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.TypeSpecification" />
    <member name="F:System.Reflection.Metadata.HandleKind.UserString" />
    <member name="T:System.Reflection.Metadata.IConstructedTypeProvider`1">
      <typeparam name="TType" />
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetArrayType(`0,System.Reflection.Metadata.ArrayShape)">
      <summary>Obtiene el símbolo de tipo para una matriz generalizada del tipo y forma del elemento especificado.</summary>
      <param name="elementType">Tipo de los elementos de la matriz.</param>
      <param name="shape">Forma (rango, tamaños y límites inferiores) de la matriz.</param>
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetByReferenceType(`0)">
      <summary>Obtiene el símbolo de tipo para un puntero administrado al tipo de elemento especificado.</summary>
      <param name="elementType" />
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetGenericInstantiation(`0,System.Collections.Immutable.ImmutableArray{`0})">
      <summary>Obtiene el símbolo de tipo para una creación de instancias genérica del tipo genérico especificado con los argumentos de tipo especificados.</summary>
      <param name="genericType" />
      <param name="typeArguments" />
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetPointerType(`0)">
      <summary>Obtiene el símbolo de tipo para un puntero no administrado al tipo de elemento especificado.</summary>
      <param name="elementType" />
    </member>
    <member name="T:System.Reflection.Metadata.ICustomAttributeTypeProvider`1">
      <typeparam name="TType" />
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.GetSystemType">
      <summary>Obtiene la representación de <typeparamref name="TType" /> para <see cref="T:System.Type" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.GetTypeFromSerializedName(System.String)">
      <summary>Obtiene el tipo de símbolo para el nombre del tipo serializado especificado.</summary>
      <param name="name">Nombre de tipo serializado en el denominado formato de "notación de reflexión" (según lo entiende el método <see cref="M:System.Type.GetType(System.String)" />).</param>
      <exception cref="T:System.BadImageFormatException">El nombre es incorrecto.</exception>
      <returns>Instancia de <typeparamref name="TType" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.GetUnderlyingEnumType(`0)">
      <summary>Obtiene el tipo subyacente del símbolo de tipo de enumeración especificado.</summary>
      <param name="type">Tipo de enumeración.</param>
      <exception cref="T:System.BadImageFormatException">El símbolo de tipo especificado no representa una enumeración.</exception>
      <returns>Código de tipo que indica el tipo subyacente de la enumeración.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.IsSystemType(`0)">
      <summary>Comprueba si el tipo especificado representa <see cref="T:System.Type" />.</summary>
      <param name="type">Tipo que se va a comprobar.</param>
      <returns>
        <see langword="true" /> si el tipo especificado es un objeto <see cref="T:System.Type" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ILOpCode" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Add" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Add_ovf" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Add_ovf_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.And" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Arglist" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Beq" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Beq_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bne_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bne_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Box" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Br" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Br_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Break" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brfalse" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brfalse_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brtrue" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brtrue_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Call" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Calli" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Callvirt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Castclass" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ceq" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cgt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cgt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ckfinite" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Clt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Clt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Constrained" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i1_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i2_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i4_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i8_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u1_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u2_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u4_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u8_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_r_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cpblk" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cpobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Div" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Div_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Dup" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Endfilter" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Endfinally" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Initblk" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Initobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Isinst" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Jmp" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarga" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarga_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_5" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_6" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_7" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_m1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelema" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldflda" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldftn" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldlen" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloca" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloca_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldnull" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldsfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldsflda" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldstr" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldtoken" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldvirtftn" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Leave" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Leave_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Localloc" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mkrefany" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mul" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mul_ovf" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mul_ovf_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Neg" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Newarr" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Newobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Nop" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Not" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Or" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Pop" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Readonly" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Refanytype" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Refanyval" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Rem" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Rem_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ret" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Rethrow" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Shl" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Shr" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Shr_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sizeof" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Starg" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Starg_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stsfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sub" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sub_ovf" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sub_ovf_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Switch" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Tail" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Throw" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Unaligned" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Unbox" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Unbox_any" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Volatile" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Xor" />
    <member name="T:System.Reflection.Metadata.ILOpCodeExtensions" />
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.GetBranchOperandSize(System.Reflection.Metadata.ILOpCode)">
      <summary>Calcula el tamaño del operando de instrucción de rama especificado.</summary>
      <param name="opCode">El código de operación de la rama.</param>
      <exception cref="T:System.ArgumentException">El parámetro <paramref name="opCode" /> especificado no es un código de operación de la rama.</exception>
      <returns>1 si <paramref name="opCode" /> es una rama corta o 4 si es larga.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.GetLongBranch(System.Reflection.Metadata.ILOpCode)">
      <summary>Obtiene un formato largo del código de operación de la rama especificado.</summary>
      <param name="opCode">El código de operación de la rama.</param>
      <exception cref="T:System.ArgumentException">El parámetro <paramref name="opCode" /> especificado no es un código de operación de la rama.</exception>
      <returns>Formato largo del código de operación de la rama.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.GetShortBranch(System.Reflection.Metadata.ILOpCode)">
      <summary>Obtiene un formato corto del código de operación de la rama especificado.</summary>
      <param name="opCode">El código de operación de la rama.</param>
      <exception cref="T:System.ArgumentException">El parámetro <paramref name="opCode" /> especificado no es un código de operación de la rama.</exception>
      <returns>Formato corto del código de operación de la rama.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.IsBranch(System.Reflection.Metadata.ILOpCode)">
      <summary>Comprueba si el código de operación especificado es una rama de una etiqueta.</summary>
      <param name="opCode" />
      <returns>
        <see langword="true" /> si el código de operación especificado es una rama de una etiqueta; <see langword="false" /> en caso contrario.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImageFormatLimitationException">
      <summary>Excepción que se produce cuando un intento de escribir metadatos supera un límite dado por la especificación de formato. Por ejemplo, cuando se supera el límite de tamaño del montón.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" /> con datos serializados.</summary>
      <param name="info">Objeto que contiene los datos del objeto serializados.</param>
      <param name="context">Información contextual acerca del origen o del destino.</param>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor(System.String)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" /> con el mensaje de error especificado.</summary>
      <param name="message">Mensaje de error que explica la razón de esta excepción.</param>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor(System.String,System.Exception)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" /> con el mensaje de error especificado y la excepción que causó esta excepción.</summary>
      <param name="message">Mensaje de error que explica la razón de esta excepción.</param>
      <param name="innerException">La excepción que es la causa de la excepción actual o <see langword="null" /> si no se especifica ninguna excepción interna.</param>
    </member>
    <member name="T:System.Reflection.Metadata.ImportDefinition" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.Alias" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.Kind" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.TargetAssembly" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.TargetNamespace" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.TargetType" />
    <member name="T:System.Reflection.Metadata.ImportDefinitionCollection" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ImportDefinition}#GetEnumerator">
      <summary>Devuelve un enumerador que procesa una iteración en la colección.</summary>
      <returns>Enumerador que se puede utilizar para recorrer en iteración la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Devuelve un enumerador que recorre en iteración una colección.</summary>
      <returns>Objeto <see cref="T:System.Collections.IEnumerator" /> que puede usarse para recorrer en iteración la colección.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.MoveNext">
      <summary>Desplaza el enumerador al siguiente elemento de la colección.</summary>
      <exception cref="T:System.BadImageFormatException">Formato de blob no válido.</exception>
      <returns>Es <see langword="true" /> si el enumerador avanzó con éxito hasta el siguiente elemento; es <see langword="false" /> si el enumerador alcanzó el final de la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.Reset">
      <summary>Establece el enumerador en su posición inicial (antes del primer elemento de la colección).</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tareas definidas por la aplicación asociadas a la liberación o al restablecimiento de recursos no administrados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImportDefinitionKind" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasAssemblyNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasAssemblyReference" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasType" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportAssemblyNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportAssemblyReferenceAlias" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportType" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportXmlNamespace" />
    <member name="T:System.Reflection.Metadata.ImportScope">
      <summary>Proporciona información sobre el ámbito léxico en el que un grupo de importaciones está disponible. Esta información se almacena en los metadatos de depuración.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScope.GetImports" />
    <member name="P:System.Reflection.Metadata.ImportScope.ImportsBlob" />
    <member name="P:System.Reflection.Metadata.ImportScope.Parent" />
    <member name="T:System.Reflection.Metadata.ImportScopeCollection" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ImportScopeHandle}#GetEnumerator">
      <summary>Devuelve un enumerador que procesa una iteración en la colección.</summary>
      <returns>Enumerador que se puede utilizar para recorrer en iteración la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Devuelve un enumerador que recorre en iteración una colección.</summary>
      <returns>Objeto <see cref="T:System.Collections.IEnumerator" /> que puede usarse para recorrer en iteración la colección.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ImportScopeCollection.Count">
      <summary>Obtiene el número de elementos de la colección.</summary>
      <returns>Número de elementos de la colección.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImportScopeCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.Enumerator.MoveNext">
      <summary>Desplaza el enumerador al siguiente elemento de la colección.</summary>
      <returns>Es <see langword="true" /> si el enumerador avanzó con éxito hasta el siguiente elemento; es <see langword="false" /> si el enumerador alcanzó el final de la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Establece el enumerador en su posición inicial (antes del primer elemento de la colección).</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tareas definidas por la aplicación asociadas a la liberación o al restablecimiento de recursos no administrados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ImportScopeCollection.Enumerator.Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ImportScopeCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImportScopeHandle" />
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.Equals(System.Reflection.Metadata.ImportScopeHandle)">
      <summary>Indica si el objeto actual es igual a otro objeto del mismo tipo.</summary>
      <param name="other">Objeto que se va a comparar con este objeto.</param>
      <returns>
        <see langword="true" /> si el objeto actual es igual al parámetro <paramref name="other" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Equality(System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.ImportScopeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ImportScopeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ImportScopeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Implicit(System.Reflection.Metadata.ImportScopeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Implicit(System.Reflection.Metadata.ImportScopeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Inequality(System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.ImportScopeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.ImportScopeHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.InterfaceImplementation" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementation.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.InterfaceImplementation.Interface">
      <summary>Obtiene la interfaz que se implementa (<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> o <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />).</summary>
    </member>
    <member name="T:System.Reflection.Metadata.InterfaceImplementationHandle" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.Equals(System.Reflection.Metadata.InterfaceImplementationHandle)">
      <summary>Indica si el objeto actual es igual a otro objeto del mismo tipo.</summary>
      <param name="other">Objeto que se va a comparar con este objeto.</param>
      <returns>
        <see langword="true" /> si el objeto actual es igual al parámetro <paramref name="other" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Equality(System.Reflection.Metadata.InterfaceImplementationHandle,System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.InterfaceImplementationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.InterfaceImplementationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Implicit(System.Reflection.Metadata.InterfaceImplementationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Implicit(System.Reflection.Metadata.InterfaceImplementationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Inequality(System.Reflection.Metadata.InterfaceImplementationHandle,System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.InterfaceImplementationHandleCollection" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#InterfaceImplementationHandle}#GetEnumerator">
      <summary>Devuelve un enumerador que procesa una iteración en la colección.</summary>
      <returns>Enumerador que se puede utilizar para recorrer en iteración la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Devuelve un enumerador que recorre en iteración una colección.</summary>
      <returns>Objeto <see cref="T:System.Collections.IEnumerator" /> que puede usarse para recorrer en iteración la colección.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Count">
      <summary>Obtiene el número de elementos de la colección.</summary>
      <returns>Número de elementos de la colección.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.MoveNext">
      <summary>Desplaza el enumerador al siguiente elemento de la colección.</summary>
      <returns>Es <see langword="true" /> si el enumerador avanzó con éxito hasta el siguiente elemento; es <see langword="false" /> si el enumerador alcanzó el final de la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Establece el enumerador en su posición inicial (antes del primer elemento de la colección).</summary>
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tareas definidas por la aplicación asociadas a la liberación o al restablecimiento de recursos no administrados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ISignatureTypeProvider`2">
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetFunctionPointerType(System.Reflection.Metadata.MethodSignature{`0})">
      <summary>Obtiene el símbolo de tipo para el tipo de puntero de función del método <paramref name="signature" /> especificado.</summary>
      <param name="signature" />
      <returns>Símbolo de tipo para el tipo de puntero de función.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetGenericMethodParameter(`1,System.Int32)">
      <summary>Obtiene el símbolo de tipo para el parámetro de método genérico en el objeto <paramref name="index" /> de base cero especificado.</summary>
      <param name="genericContext" />
      <param name="index" />
      <returns>Símbolo de tipo para el parámetro de método genérico en el objeto <paramref name="index" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetGenericTypeParameter(`1,System.Int32)">
      <summary>Obtiene el símbolo de tipo para el parámetro de tipo genérico en el objeto <paramref name="index" /> de base cero especificado.</summary>
      <param name="genericContext" />
      <param name="index" />
      <returns>Símbolo de tipo para el parámetro de tipo genérico en el objeto <paramref name="index" /> de base cero especificado.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetModifiedType(`0,`0,System.Boolean)">
      <summary>Obtiene el símbolo de tipo para un tipo con un modificador personalizado aplicado.</summary>
      <param name="modifier">Tipo de modificador aplicado.</param>
      <param name="unmodifiedType">Símbolo de tipo del tipo subyacente sin modificadores aplicados.</param>
      <param name="isRequired">
        <see langword="true" /> si el modificador es necesario, <see langword="false" /> si es opcional.</param>
      <returns>Símbolo de tipo.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetPinnedType(`0)">
      <summary>Obtiene el símbolo de tipo para un tipo de variable local que está marcado como anclado.</summary>
      <param name="elementType" />
      <returns>Símbolo de tipo para el tipo de variable local.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetTypeFromSpecification(System.Reflection.Metadata.MetadataReader,`1,System.Reflection.Metadata.TypeSpecificationHandle,System.Byte)">
      <summary>Obtiene el símbolo de tipo para una especificación de tipo.</summary>
      <param name="reader">Lector de metadatos que se ha pasado al descodificador de firma. Puede ser <see langword="null" />.</param>
      <param name="genericContext">Contexto que se ha pasado al descodificador de firma.</param>
      <param name="handle">Manipulador de especificación de tipo.</param>
      <param name="rawTypeKind">Clase del tipo, como se especifica en la firma. Para interpretar este valor, use <see cref="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)" />.</param>
      <returns>Símbolo de tipo para la especificación de tipo.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ISimpleTypeProvider`1">
      <typeparam name="TType" />
    </member>
    <member name="M:System.Reflection.Metadata.ISimpleTypeProvider`1.GetPrimitiveType(System.Reflection.Metadata.PrimitiveTypeCode)">
      <summary>Obtiene el símbolo de tipo para un tipo primitivo.</summary>
      <param name="typeCode" />
      <returns>Símbolo de tipo para <param name="typeCode" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISimpleTypeProvider`1.GetTypeFromDefinition(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.TypeDefinitionHandle,System.Byte)">
      <summary>Obtiene el símbolo de tipo para una definición de tipo.</summary>
      <param name="reader">Lector de metadatos que se ha pasado al descodificador de firma. Puede ser <see langword="null" />.</param>
      <param name="handle">Manipulador de la definición de tipo.</param>
      <param name="rawTypeKind">Clase del tipo, como se especifica en la firma. Para interpretar este valor, use <see cref="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)" />.</param>
      <returns>Símbolo de tipo.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISimpleTypeProvider`1.GetTypeFromReference(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.TypeReferenceHandle,System.Byte)">
      <summary>Obtiene el símbolo de tipo para una referencia de tipo.</summary>
      <param name="reader">Lector de metadatos que se ha pasado al descodificador de firma. Puede ser <see langword="null" />.</param>
      <param name="handle">Manipulador de la definición de tipo.</param>
      <param name="rawTypeKind">Clase del tipo, como se especifica en la firma. Para interpretar este valor, use <see cref="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)" />.</param>
      <returns>Símbolo de tipo.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ISZArrayTypeProvider`1">
      <typeparam name="TType" />
    </member>
    <member name="M:System.Reflection.Metadata.ISZArrayTypeProvider`1.GetSZArrayType(`0)">
      <summary>Obtiene el símbolo de tipo para una matriz unidimensional del tipo de elemento especificado con un límite inferior de cero.</summary>
      <param name="elementType" />
      <returns>Instancia de <typeparamref name="TType" />.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalConstant">
      <summary>Proporciona información sobre las constantes locales. Esta información se almacena en los metadatos de depuración.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstant.Name" />
    <member name="P:System.Reflection.Metadata.LocalConstant.Signature">
      <summary>Obtiene la firma de la constante.</summary>
      <returns>Firma de la constante.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalConstantHandle" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.Equals(System.Reflection.Metadata.LocalConstantHandle)">
      <summary>Indica si el objeto actual es igual a otro objeto del mismo tipo.</summary>
      <param name="other">Objeto que se va a comparar con este objeto.</param>
      <returns>
        <see langword="true" /> si el objeto actual es igual al parámetro <paramref name="other" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Equality(System.Reflection.Metadata.LocalConstantHandle,System.Reflection.Metadata.LocalConstantHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.LocalConstantHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.LocalConstantHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Implicit(System.Reflection.Metadata.LocalConstantHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Implicit(System.Reflection.Metadata.LocalConstantHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Inequality(System.Reflection.Metadata.LocalConstantHandle,System.Reflection.Metadata.LocalConstantHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstantHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.LocalConstantHandleCollection" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#LocalConstantHandle}#GetEnumerator">
      <summary>Devuelve un enumerador que procesa una iteración en la colección.</summary>
      <returns>Enumerador que se puede utilizar para recorrer en iteración la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Devuelve un enumerador que recorre en iteración una colección.</summary>
      <returns>Objeto <see cref="T:System.Collections.IEnumerator" /> que puede usarse para recorrer en iteración la colección.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstantHandleCollection.Count">
      <summary>Obtiene el número de elementos de la colección.</summary>
      <returns>Número de elementos de la colección.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.MoveNext">
      <summary>Desplaza el enumerador al siguiente elemento de la colección.</summary>
      <returns>Es <see langword="true" /> si el enumerador avanzó con éxito hasta el siguiente elemento; es <see langword="false" /> si el enumerador alcanzó el final de la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Establece el enumerador en su posición inicial (antes del primer elemento de la colección).</summary>
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tareas definidas por la aplicación asociadas a la liberación o al restablecimiento de recursos no administrados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalScope">
      <summary>Proporciona información sobre el ámbito de las variables locales y las constantes. Esta información se almacena en los metadatos de depuración.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScope.GetChildren" />
    <member name="M:System.Reflection.Metadata.LocalScope.GetLocalConstants" />
    <member name="M:System.Reflection.Metadata.LocalScope.GetLocalVariables" />
    <member name="P:System.Reflection.Metadata.LocalScope.EndOffset" />
    <member name="P:System.Reflection.Metadata.LocalScope.ImportScope" />
    <member name="P:System.Reflection.Metadata.LocalScope.Length" />
    <member name="P:System.Reflection.Metadata.LocalScope.Method" />
    <member name="P:System.Reflection.Metadata.LocalScope.StartOffset" />
    <member name="T:System.Reflection.Metadata.LocalScopeHandle" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.Equals(System.Reflection.Metadata.LocalScopeHandle)">
      <summary>Indica si el objeto actual es igual a otro objeto del mismo tipo.</summary>
      <param name="other">Objeto que se va a comparar con este objeto.</param>
      <returns>
        <see langword="true" /> si el objeto actual es igual al parámetro <paramref name="other" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Equality(System.Reflection.Metadata.LocalScopeHandle,System.Reflection.Metadata.LocalScopeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.LocalScopeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.LocalScopeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Implicit(System.Reflection.Metadata.LocalScopeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Implicit(System.Reflection.Metadata.LocalScopeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Inequality(System.Reflection.Metadata.LocalScopeHandle,System.Reflection.Metadata.LocalScopeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.LocalScopeHandleCollection" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#LocalScopeHandle}#GetEnumerator">
      <summary>Devuelve un enumerador que procesa una iteración en la colección.</summary>
      <returns>Enumerador que se puede utilizar para recorrer en iteración la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Devuelve un enumerador que recorre en iteración una colección.</summary>
      <returns>Objeto <see cref="T:System.Collections.IEnumerator" /> que puede usarse para recorrer en iteración la colección.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.Count">
      <summary>Obtiene el número de elementos de la colección.</summary>
      <returns>Número de elementos de la colección.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.MoveNext">
      <summary>Desplaza el enumerador al siguiente elemento de la colección.</summary>
      <returns>Es <see langword="true" /> si el enumerador avanzó con éxito hasta el siguiente elemento; es <see langword="false" /> si el enumerador alcanzó el final de la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.System#Collections#IEnumerator#Reset">
      <summary>Establece el enumerador en su posición inicial (antes del primer elemento de la colección).</summary>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.System#IDisposable#Dispose">
      <summary>Realiza tareas definidas por la aplicación asociadas a la liberación o al restablecimiento de recursos no administrados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.System#Collections#IEnumerator#Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.MoveNext">
      <summary>Desplaza el enumerador al siguiente elemento de la colección.</summary>
      <returns>Es <see langword="true" /> si el enumerador avanzó con éxito hasta el siguiente elemento; es <see langword="false" /> si el enumerador alcanzó el final de la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Establece el enumerador en su posición inicial (antes del primer elemento de la colección).</summary>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tareas definidas por la aplicación asociadas a la liberación o al restablecimiento de recursos no administrados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalVariable">
      <summary>Proporciona información sobre las variables locales. Esta información se almacena en los metadatos de depuración.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariable.Attributes" />
    <member name="P:System.Reflection.Metadata.LocalVariable.Index" />
    <member name="P:System.Reflection.Metadata.LocalVariable.Name" />
    <member name="T:System.Reflection.Metadata.LocalVariableAttributes" />
    <member name="F:System.Reflection.Metadata.LocalVariableAttributes.DebuggerHidden" />
    <member name="F:System.Reflection.Metadata.LocalVariableAttributes.None" />
    <member name="T:System.Reflection.Metadata.LocalVariableHandle" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.Equals(System.Reflection.Metadata.LocalVariableHandle)">
      <summary>Indica si el objeto actual es igual a otro objeto del mismo tipo.</summary>
      <param name="other">Objeto que se va a comparar con este objeto.</param>
      <returns>
        <see langword="true" /> si el objeto actual es igual al parámetro <paramref name="other" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Equality(System.Reflection.Metadata.LocalVariableHandle,System.Reflection.Metadata.LocalVariableHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.LocalVariableHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.LocalVariableHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Implicit(System.Reflection.Metadata.LocalVariableHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Implicit(System.Reflection.Metadata.LocalVariableHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Inequality(System.Reflection.Metadata.LocalVariableHandle,System.Reflection.Metadata.LocalVariableHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariableHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.LocalVariableHandleCollection" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#LocalVariableHandle}#GetEnumerator">
      <summary>Devuelve un enumerador que procesa una iteración en la colección.</summary>
      <returns>Enumerador que se puede utilizar para recorrer en iteración la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Devuelve un enumerador que recorre en iteración una colección.</summary>
      <returns>Objeto <see cref="T:System.Collections.IEnumerator" /> que puede usarse para recorrer en iteración la colección.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariableHandleCollection.Count">
      <summary>Obtiene el número de elementos de la colección.</summary>
      <returns>Número de elementos de la colección.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.MoveNext">
      <summary>Desplaza el enumerador al siguiente elemento de la colección.</summary>
      <returns>Es <see langword="true" /> si el enumerador avanzó con éxito hasta el siguiente elemento; es <see langword="false" /> si el enumerador alcanzó el final de la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Establece el enumerador en su posición inicial (antes del primer elemento de la colección).</summary>
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tareas definidas por la aplicación asociadas a la liberación o al restablecimiento de recursos no administrados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ManifestResource" />
    <member name="M:System.Reflection.Metadata.ManifestResource.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ManifestResource.Attributes">
      <summary>Obtiene los atributos del recurso del manifiesto.</summary>
      <returns>Combinación bit a bit de los valores de enumeración que especifican los atributos de recurso de manifiesto.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResource.Implementation">
      <summary>Obtiene el controlador de la entidad de la implementación.</summary>
      <returns>Instancia de EntityHandle. Si la <see cref="P:System.Reflection.Metadata.EntityHandle.IsNil" /> propiedad es <see langword="true" /> , el identificador devuelto tendrá valores predeterminados.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResource.Name">
      <summary>Obtiene el nombre del recurso.</summary>
      <returns>Nombre del recurso.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResource.Offset">
      <summary>Obtiene el desplazamiento de bytes en el archivo al que se hace referencia en el que comienza este registro de recursos.</summary>
      <returns>El desplazamiento de bytes dentro del archivo al que se hace referencia en el que comienza este registro de recursos.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ManifestResourceHandle" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.Equals(System.Reflection.Metadata.ManifestResourceHandle)">
      <summary>Indica si el objeto actual es igual a otro objeto del mismo tipo.</summary>
      <param name="other">Objeto que se va a comparar con este objeto.</param>
      <returns>
        <see langword="true" /> si el objeto actual es igual al parámetro <paramref name="other" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Equality(System.Reflection.Metadata.ManifestResourceHandle,System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ManifestResourceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ManifestResourceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Implicit(System.Reflection.Metadata.ManifestResourceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Implicit(System.Reflection.Metadata.ManifestResourceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Inequality(System.Reflection.Metadata.ManifestResourceHandle,System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResourceHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ManifestResourceHandleCollection">
      <summary>Representa una colección de instancias de <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ManifestResourceHandle}#GetEnumerator">
      <summary>Devuelve un enumerador que procesa una iteración en la colección.</summary>
      <returns>Enumerador que se puede utilizar para recorrer en iteración la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Devuelve un enumerador que recorre en iteración una colección.</summary>
      <returns>Objeto <see cref="T:System.Collections.IEnumerator" /> que puede usarse para recorrer en iteración la colección.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResourceHandleCollection.Count">
      <summary>Obtiene el número de elementos de la colección.</summary>
      <returns>Número de elementos de la colección.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.MoveNext">
      <summary>Desplaza el enumerador al siguiente elemento de la colección.</summary>
      <returns>Es <see langword="true" /> si el enumerador avanzó con éxito hasta el siguiente elemento; es <see langword="false" /> si el enumerador alcanzó el final de la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Establece el enumerador en su posición inicial (antes del primer elemento de la colección).</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tareas definidas por la aplicación asociadas a la liberación o al restablecimiento de recursos no administrados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MemberReference" />
    <member name="M:System.Reflection.Metadata.MemberReference.DecodeFieldSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReference.DecodeMethodSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReference.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.MemberReference.GetKind">
      <summary>Determina si la referencia de miembro es un método o un campo.</summary>
      <exception cref="T:System.BadImageFormatException">La firma de la referencia de miembro no es válida.</exception>
      <returns>Uno de los valores de enumeración que indica el tipo de referencia de miembro.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReference.Name" />
    <member name="P:System.Reflection.Metadata.MemberReference.Parent">
      <summary>Obtiene el controlador de la entidad primaria.</summary>
      <returns>Instancia de identificador de entidad. Si la <see cref="P:System.Reflection.Metadata.EntityHandle.IsNil" /> propiedad es <see langword="true" /> , el identificador devuelto tendrá valores predeterminados.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReference.Signature">
      <summary>Obtiene un identificador al blob de firma.</summary>
      <returns>Identificador del objeto binario de firma.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MemberReferenceHandle" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.Equals(System.Reflection.Metadata.MemberReferenceHandle)">
      <summary>Indica si el objeto actual es igual a otro objeto del mismo tipo.</summary>
      <param name="other">Objeto que se va a comparar con este objeto.</param>
      <returns>
        <see langword="true" /> si el objeto actual es igual al parámetro <paramref name="other" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Equality(System.Reflection.Metadata.MemberReferenceHandle,System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MemberReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MemberReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Implicit(System.Reflection.Metadata.MemberReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Implicit(System.Reflection.Metadata.MemberReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Inequality(System.Reflection.Metadata.MemberReferenceHandle,System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.MemberReferenceHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.MemberReferenceHandleCollection">
      <summary>Representa una colección de instancias de <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MemberReferenceHandle}#GetEnumerator">
      <summary>Devuelve un enumerador que procesa una iteración en la colección.</summary>
      <returns>Enumerador que se puede utilizar para recorrer en iteración la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Devuelve un enumerador que recorre en iteración una colección.</summary>
      <returns>Objeto <see cref="T:System.Collections.IEnumerator" /> que puede usarse para recorrer en iteración la colección.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReferenceHandleCollection.Count">
      <summary>Obtiene el número de elementos de la colección.</summary>
      <returns>Número de elementos de la colección.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.MoveNext">
      <summary>Desplaza el enumerador al siguiente elemento de la colección.</summary>
      <returns>Es <see langword="true" /> si el enumerador avanzó con éxito hasta el siguiente elemento; es <see langword="false" /> si el enumerador alcanzó el final de la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Establece el enumerador en su posición inicial (antes del primer elemento de la colección).</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tareas definidas por la aplicación asociadas a la liberación o al restablecimiento de recursos no administrados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MemberReferenceKind">
      <summary>Especifica las constantes que indican si <see cref="T:System.Reflection.Metadata.MemberReference" /> hace referencia a un método o campo.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MemberReferenceKind.Field">
      <summary>
        <see cref="T:System.Reflection.Metadata.MemberReference" /> hace referencia a un campo.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MemberReferenceKind.Method">
      <summary>
        <see cref="T:System.Reflection.Metadata.MemberReference" /> hace referencia a un método.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataKind" />
    <member name="F:System.Reflection.Metadata.MetadataKind.Ecma335">
      <summary>Metadatos de CLI.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataKind.ManagedWindowsMetadata">
      <summary>Metadatos de Windows generados por compiladores administrados.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataKind.WindowsMetadata">
      <summary>Metadatos de Windows.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataReader">
      <summary>Lee los metadatos tal y como se define en la especificación ECMA 335 de la CLI.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Reflection.Metadata.MetadataReader" /> a partir de los metadatos almacenados en la ubicación de memoria especificada.</summary>
      <param name="metadata">Un puntero al primer byte de un bloque de metadatos.</param>
      <param name="length">El número de bytes en el bloque.</param>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32,System.Reflection.Metadata.MetadataReaderOptions)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Reflection.Metadata.MetadataReader" /> a partir de los metadatos almacenados en la ubicación de memoria especificada.</summary>
      <param name="metadata" />
      <param name="length" />
      <param name="options" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32,System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Reflection.Metadata.MetadataReader" /> a partir de los metadatos almacenados en la ubicación de memoria especificada.</summary>
      <param name="metadata" />
      <param name="length" />
      <param name="options" />
      <param name="utf8Decoder" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" /> no tiene un valor positivo.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="metadata" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">La codificación de <paramref name="utf8Decoder" /> no es <see cref="T:System.Text.UTF8Encoding" />.</exception>
      <exception cref="T:System.PlatformNotSupportedException">La plataforma actual es big endian.</exception>
      <exception cref="T:System.BadImageFormatException">El encabezado de los metadatos no es correcto.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetAssemblyDefinition" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetAssemblyFile(System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetAssemblyReference(System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobBytes(System.Reflection.Metadata.BlobHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobContent(System.Reflection.Metadata.BlobHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobReader(System.Reflection.Metadata.BlobHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobReader(System.Reflection.Metadata.StringHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetConstant(System.Reflection.Metadata.ConstantHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomAttribute(System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomAttributes(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomDebugInformation(System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomDebugInformation(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetDeclarativeSecurityAttribute(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetDocument(System.Reflection.Metadata.DocumentHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetEventDefinition(System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetExportedType(System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetFieldDefinition(System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetGenericParameter(System.Reflection.Metadata.GenericParameterHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetGenericParameterConstraint(System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetGuid(System.Reflection.Metadata.GuidHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetImportScope(System.Reflection.Metadata.ImportScopeHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetInterfaceImplementation(System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalConstant(System.Reflection.Metadata.LocalConstantHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalScope(System.Reflection.Metadata.LocalScopeHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalScopes(System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalScopes(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalVariable(System.Reflection.Metadata.LocalVariableHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetManifestResource(System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMemberReference(System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodDebugInformation(System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodDebugInformation(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodDefinition(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodImplementation(System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodSpecification(System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetModuleDefinition" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetModuleReference(System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetNamespaceDefinition(System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetNamespaceDefinitionRoot" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetParameter(System.Reflection.Metadata.ParameterHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetPropertyDefinition(System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetStandaloneSignature(System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetString(System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetString(System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetString(System.Reflection.Metadata.StringHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetTypeDefinition(System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetTypeReference(System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetTypeSpecification(System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetUserString(System.Reflection.Metadata.UserStringHandle)">
      <param name="handle" />
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.AssemblyFiles" />
    <member name="P:System.Reflection.Metadata.MetadataReader.AssemblyReferences" />
    <member name="P:System.Reflection.Metadata.MetadataReader.CustomAttributes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.CustomDebugInformation" />
    <member name="P:System.Reflection.Metadata.MetadataReader.DebugMetadataHeader">
      <summary>Obtiene la información descodificada de la secuencia de #Pdb, o <see langword="null" /> si la secuencia no está presente.</summary>
      <returns>Información descodificada de #Pdb secuencia o <see langword="null" /> si la secuencia no está presente.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.DeclarativeSecurityAttributes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.Documents" />
    <member name="P:System.Reflection.Metadata.MetadataReader.EventDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.ExportedTypes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.FieldDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.ImportScopes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.IsAssembly">
      <summary>Obtiene un valor que indica si los metadatos representan un ensamblado.</summary>
      <returns>
        <see langword="true" /> Si los metadatos representan un ensamblado; en caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.LocalConstants" />
    <member name="P:System.Reflection.Metadata.MetadataReader.LocalScopes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.LocalVariables" />
    <member name="P:System.Reflection.Metadata.MetadataReader.ManifestResources" />
    <member name="P:System.Reflection.Metadata.MetadataReader.MemberReferences" />
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataKind">
      <summary>Obtiene el tipo de los metadatos.</summary>
      <returns>Uno de los valores de enumeración que especifica el tipo de metadatos.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataLength">
      <summary>Obtiene la longitud de los datos subyacentes.</summary>
      <returns>Longitud de los datos subyacentes.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataPointer">
      <summary>Obtiene el puntero a los datos subyacentes.</summary>
      <returns>Puntero a los datos subyacentes.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataVersion">
      <summary>Obtiene la lectura de la cadena de versión del encabezado de los metadatos.</summary>
      <returns>Cadena de versión leída del encabezado de metadatos.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MethodDebugInformation" />
    <member name="P:System.Reflection.Metadata.MetadataReader.MethodDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.Options">
      <summary>Obtiene el objeto <see cref="T:System.Reflection.Metadata.MetadataReaderOptions" /> que se pasa al constructor.</summary>
      <returns>Combinación bit a bit de los valores de enumeración que describe el <see cref="T:System.Reflection.Metadata.MetadataReaderOptions" /> valor de enumeración.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.PropertyDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.StringComparer">
      <summary>Obtiene al comparador que se usa para comparar las cadenas almacenadas en los metadatos.</summary>
      <returns>Comparador que se usa para comparar cadenas almacenadas en metadatos.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.TypeDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.TypeReferences" />
    <member name="P:System.Reflection.Metadata.MetadataReader.UTF8Decoder">
      <summary>Obtiene el decodificador que usa el lector para generar instancias de cadenas de secuencias de bytes con codificación UTF8.</summary>
      <returns>Descodificador utilizado por el lector para generar instancias de cadena a partir de secuencias de bytes codificadas en UTF8.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataReaderOptions" />
    <member name="F:System.Reflection.Metadata.MetadataReaderOptions.ApplyWindowsRuntimeProjections">
      <summary>Las proyecciones de Windows Runtime están habilitadas (activadas de forma predeterminada).</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataReaderOptions.Default">
      <summary>Opciones que se usan cuando <see cref="T:System.Reflection.Metadata.MetadataReader" /> se obtiene a través de una sobrecarga que no toma un argumento <see cref="T:System.Reflection.Metadata.MetadataReaderOptions" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataReaderOptions.None">
      <summary>Todas las opciones están deshabilitadas.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataReaderProvider">
      <summary>Proporciona un objeto <see cref="T:System.Reflection.Metadata.MetadataReader" /> para los metadatos almacenados en una matriz de bytes, un bloque de memoria o una secuencia.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.Dispose">
      <summary>Elimina toda la memoria asignada por el lector.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromMetadataImage(System.Byte*,System.Int32)">
      <summary>Crea un proveedor de metadatos sobre una imagen almacenada en memoria.</summary>
      <param name="start">Puntero al principio del blob de metadatos.</param>
      <param name="size">Tamaño del blob de metadatos.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="start" /> es <see cref="F:System.IntPtr.Zero" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> es negativo.</exception>
      <returns>Nuevo proveedor de metadatos.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromMetadataImage(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>Crea un proveedor sobre una matriz de bytes.</summary>
      <param name="image">Imagen de metadatos.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="image" /> es <see langword="null" />.</exception>
      <returns>Nuevo proveedor.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromMetadataStream(System.IO.Stream,System.Reflection.Metadata.MetadataStreamOptions,System.Int32)">
      <summary>Crea un proveedor para una secuencia del tamaño especificado que comienza en su posición actual.</summary>
      <param name="stream">Instancia de <see cref="T:System.IO.Stream" />.</param>
      <param name="options">Opciones que especifican cómo se leen las secciones de la imagen de la secuencia.</param>
      <param name="size">Tamaño del blob de metadatos en la secuencia. Si no se especifica, se supone que el blob de metadatos abarca hasta el final de la secuencia.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="stream" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="stream" /> no admite las operaciones de lectura y búsqueda.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">El tamaño es negativo o se extiende más allá del final de la secuencia.</exception>
      <exception cref="T:System.IO.IOException">Error al leer la secuencia (solo cuando se especifica <see cref="F:System.Reflection.Metadata.MetadataStreamOptions.PrefetchMetadata" />).</exception>
      <returns>Nuevo proveedor.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromPortablePdbImage(System.Byte*,System.Int32)">
      <summary>Crea un proveedor de metadatos de PDB portátil sobre un blob almacenado en memoria.</summary>
      <param name="start">Puntero al inicio del blob de PDB portátil.</param>
      <param name="size">Tamaño del blob de PDB portátil.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="start" /> es <see cref="F:System.IntPtr.Zero" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> es negativo.</exception>
      <returns>Nuevo proveedor de metadatos de PDB portátil.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromPortablePdbImage(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>Crea un proveedor de metadatos de PDB portátil sobre una matriz de bytes.</summary>
      <param name="image">Imagen de PDB portátil.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="image" /> es <see langword="null" />.</exception>
      <returns>Nuevo proveedor de metadatos de PDB portátil.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromPortablePdbStream(System.IO.Stream,System.Reflection.Metadata.MetadataStreamOptions,System.Int32)">
      <summary>Crea un proveedor para una secuencia del tamaño especificado que comienza en su posición actual.</summary>
      <param name="stream">Flujo.</param>
      <param name="options">Opciones que especifican cómo se leen las secciones de la imagen de la secuencia.</param>
      <param name="size">Tamaño del blob de metadatos en la secuencia. Si no se especifica, se supone que el blob de metadatos abarca hasta el final de la secuencia.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="stream" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="stream" /> no admite las operaciones de lectura y búsqueda.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">El tamaño es negativo o se extiende más allá del final de la secuencia.</exception>
      <returns>Instancia de <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.GetMetadataReader(System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)">
      <summary>Obtiene una propiedad <see cref="T:System.Reflection.Metadata.MetadataReader" /> de una clase <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />.</summary>
      <param name="options">Combinación bit a bit de los valores de la enumeración que representan la configuración al leer los metadatos.</param>
      <param name="utf8Decoder">La codificación que se va a utilizar.</param>
      <exception cref="T:System.ArgumentException">La codificación de <paramref name="utf8Decoder" /> no es <see cref="T:System.Text.UTF8Encoding" />.</exception>
      <exception cref="T:System.PlatformNotSupportedException">La plataforma actual es big endian.</exception>
      <exception cref="T:System.IO.IOException">Error de E/S al leer la secuencia subyacente.</exception>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado el proveedor.</exception>
      <returns>Instancia de <see cref="T:System.Reflection.Metadata.MetadataReader" />.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataStreamOptions" />
    <member name="F:System.Reflection.Metadata.MetadataStreamOptions.Default">
      <summary>De forma predeterminada, la secuencia se desecha cuando se elimina <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> y las secciones de la imagen PE se leen de forma diferida.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataStreamOptions.LeaveOpen">
      <summary>Mantiene la secuencia abierta cuando se elimina <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataStreamOptions.PrefetchMetadata">
      <summary>
        <para>Lee los metadatos PDB en memoria inmediatamente.</para>
        <para>Después de que se construya <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />, se puede cerrar e incluso eliminar el archivo subyacente. <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> cierra la secuencia de forma automática cuando vuelve el constructor, a menos que se especifique <see cref="F:System.Reflection.Metadata.MetadataStreamOptions.LeaveOpen" />.</para>
      </summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataStringComparer">
      <summary>Proporciona aplicaciones auxiliares de comparación de cadenas para consultar cadenas en metadatos y evitar la asignación si es posible.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.DocumentNameBlobHandle,System.String)">
      <param name="handle" />
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.DocumentNameBlobHandle,System.String,System.Boolean)">
      <param name="handle" />
      <param name="value" />
      <param name="ignoreCase" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.NamespaceDefinitionHandle,System.String)">
      <param name="handle" />
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.NamespaceDefinitionHandle,System.String,System.Boolean)">
      <param name="handle" />
      <param name="value" />
      <param name="ignoreCase" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.StringHandle,System.String)">
      <param name="handle" />
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.StringHandle,System.String,System.Boolean)">
      <param name="handle" />
      <param name="value" />
      <param name="ignoreCase" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.StartsWith(System.Reflection.Metadata.StringHandle,System.String)">
      <param name="handle" />
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.StartsWith(System.Reflection.Metadata.StringHandle,System.String,System.Boolean)">
      <param name="handle" />
      <param name="value" />
      <param name="ignoreCase" />
    </member>
    <member name="T:System.Reflection.Metadata.MetadataStringDecoder">
      <summary>Proporciona a <see cref="T:System.Reflection.Metadata.MetadataReader" /> un mecanismo personalizado para descodificar secuencias de bytes en metadatos que representan texto.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringDecoder.#ctor(System.Text.Encoding)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Reflection.Metadata.MetadataStringDecoder" /> usando la codificación especificada.</summary>
      <param name="encoding">La codificación que se va a utilizar.</param>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringDecoder.GetString(System.Byte*,System.Int32)">
      <summary>Obtiene las cadenas para secuencias de bytes en los metadatos. Invalide esto para almacenar las cadenas en caché si es necesario. En caso contrario, se implementa mediante el reenvío directo a <see cref="P:System.Reflection.Metadata.MetadataStringDecoder.Encoding" />; todas las llamadas asignarán una nueva cadena.</summary>
      <param name="bytes">Puntero a los bytes que se van a descodificar.</param>
      <param name="byteCount">Número de bytes que se van a descodificar.</param>
      <returns>La cadena descodificada.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataStringDecoder.DefaultUTF8">
      <summary>Obtiene el decodificador predeterminado que usa <see cref="T:System.Reflection.Metadata.MetadataReader" /> para descodificar UTF-8 cuando no se proporciona ningún descodificador al constructor.</summary>
      <returns>Descodificador predeterminado utilizado por <see cref="T:System.Reflection.Metadata.MetadataReader" /> para descodificar UTF-8.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataStringDecoder.Encoding">
      <summary>Obtiene la codificación que usa esta instancia.</summary>
      <returns>Codificación usada por esta instancia.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodBodyBlock" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.Create(System.Reflection.Metadata.BlobReader)">
      <param name="reader" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.GetILBytes" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.GetILContent" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.GetILReader" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.ExceptionRegions" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.LocalSignature" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.LocalVariablesInitialized" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.MaxStack" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.Size">
      <summary>Obtiene el tamaño del cuerpo del método, incluidas las regiones de encabezado, IL y excepciones.</summary>
      <returns>Tamaño del cuerpo del método.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDebugInformation">
      <summary>Proporciona información de depuración asociada a una definición de método. Esta información se almacena en los metadatos de depuración.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformation.GetSequencePoints">
      <summary>Devuelve una colección de puntos de secuencia descodificados desde <see cref="P:System.Reflection.Metadata.MethodDebugInformation.SequencePointsBlob" />.</summary>
      <returns>Colección de puntos de secuencia.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformation.GetStateMachineKickoffMethod">
      <summary>Devuelve el método de puesta en marcha de la máquina de estados.</summary>
      <returns>Método de puesta en marcha de la máquina de estados, si el método es un método <c>MoveNext</c> de una máquina de estados. De lo contrario, devuelve un identificador cuya propiedad <see cref="P:System.Reflection.Metadata.MethodDefinitionHandle.IsNil" /> es <see langword="true" />.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformation.Document">
      <summary>Obtiene el identificador del documento único que contiene todos los puntos de secuencia del método.</summary>
      <returns>Identificador del único documento que contiene todos los puntos de secuencia del método o un identificador cuya <see cref="P:System.Reflection.Metadata.DocumentHandle.IsNil" /> propiedad es <see langword="true" /> si el método no tiene puntos de secuencia o abarca varios documentos.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformation.LocalSignature">
      <summary>Devuelve un identificador de firma local.</summary>
      <returns>Un identificador de firma local o un identificador cuya <see cref="P:System.Reflection.Metadata.StandaloneSignatureHandle.IsNil" /> propiedad es <see langword="true" /> si el método no define ninguna variable local.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformation.SequencePointsBlob">
      <summary>Devuelve un blob de codificación de puntos de secuencia.</summary>
      <returns>Los puntos de secuencia de codificación de blobs o un identificador cuya <see cref="P:System.Reflection.Metadata.BlobHandle.IsNil" /> propiedad es <see langword="true" /> si el método no tiene puntos de secuencia.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDebugInformationHandle" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.Equals(System.Reflection.Metadata.MethodDebugInformationHandle)">
      <summary>Indica si el objeto actual es igual a otro objeto del mismo tipo.</summary>
      <param name="other">Objeto que se va a comparar con este objeto.</param>
      <returns>
        <see langword="true" /> si el objeto actual es igual al parámetro <paramref name="other" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Equality(System.Reflection.Metadata.MethodDebugInformationHandle,System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodDebugInformationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodDebugInformationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Implicit(System.Reflection.Metadata.MethodDebugInformationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Implicit(System.Reflection.Metadata.MethodDebugInformationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Inequality(System.Reflection.Metadata.MethodDebugInformationHandle,System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.ToDefinitionHandle">
      <summary>Devuelve un identificador a un objeto <see cref="T:System.Reflection.Metadata.MethodDefinition" /> que se corresponde a este identificador.</summary>
      <returns>Identificador de definición de método que se corresponde a este identificador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.MethodDebugInformationHandleCollection" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MethodDebugInformationHandle}#GetEnumerator">
      <summary>Devuelve un enumerador que procesa una iteración en la colección.</summary>
      <returns>Enumerador que se puede utilizar para recorrer en iteración la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Devuelve un enumerador que recorre en iteración una colección.</summary>
      <returns>Objeto <see cref="T:System.Collections.IEnumerator" /> que puede usarse para recorrer en iteración la colección.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Count">
      <summary>Obtiene el número de elementos de la colección.</summary>
      <returns>Número de elementos de la colección.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.MoveNext">
      <summary>Desplaza el enumerador al siguiente elemento de la colección.</summary>
      <returns>Es <see langword="true" /> si el enumerador avanzó con éxito hasta el siguiente elemento; es <see langword="false" /> si el enumerador alcanzó el final de la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Establece el enumerador en su posición inicial (antes del primer elemento de la colección).</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tareas definidas por la aplicación asociadas a la liberación o al restablecimiento de recursos no administrados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDefinition" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetDeclarativeSecurityAttributes" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetDeclaringType" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetGenericParameters" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetImport" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetParameters" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.ImplAttributes" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.Name" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.RelativeVirtualAddress" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.Signature" />
    <member name="T:System.Reflection.Metadata.MethodDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.Equals(System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary>Indica si el objeto actual es igual a otro objeto del mismo tipo.</summary>
      <param name="other">Objeto que se va a comparar con este objeto.</param>
      <returns>
        <see langword="true" /> si el objeto actual es igual al parámetro <paramref name="other" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Equality(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Implicit(System.Reflection.Metadata.MethodDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Implicit(System.Reflection.Metadata.MethodDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Inequality(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.ToDebugInformationHandle">
      <summary>Devuelve un identificador a un objeto <see cref="T:System.Reflection.Metadata.MethodDebugInformation" /> que se corresponde a este identificador.</summary>
      <returns>Un identificador de información de depuración de método que se corresponde a este identificador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.MethodDefinitionHandleCollection" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MethodDefinitionHandle}#GetEnumerator">
      <summary>Devuelve un enumerador que procesa una iteración en la colección.</summary>
      <returns>Enumerador que se puede utilizar para recorrer en iteración la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Devuelve un enumerador que recorre en iteración una colección.</summary>
      <returns>Objeto <see cref="T:System.Collections.IEnumerator" /> que puede usarse para recorrer en iteración la colección.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandleCollection.Count">
      <summary>Obtiene el número de elementos de la colección.</summary>
      <returns>Número de elementos de la colección.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.MoveNext">
      <summary>Desplaza el enumerador al siguiente elemento de la colección.</summary>
      <returns>Es <see langword="true" /> si el enumerador avanzó con éxito hasta el siguiente elemento; es <see langword="false" /> si el enumerador alcanzó el final de la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Establece el enumerador en su posición inicial (antes del primer elemento de la colección).</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tareas definidas por la aplicación asociadas a la liberación o al restablecimiento de recursos no administrados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodImplementation" />
    <member name="M:System.Reflection.Metadata.MethodImplementation.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.MethodImplementation.MethodBody" />
    <member name="P:System.Reflection.Metadata.MethodImplementation.MethodDeclaration" />
    <member name="P:System.Reflection.Metadata.MethodImplementation.Type" />
    <member name="T:System.Reflection.Metadata.MethodImplementationHandle" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.Equals(System.Reflection.Metadata.MethodImplementationHandle)">
      <summary>Indica si el objeto actual es igual a otro objeto del mismo tipo.</summary>
      <param name="other">Objeto que se va a comparar con este objeto.</param>
      <returns>
        <see langword="true" /> si el objeto actual es igual al parámetro <paramref name="other" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Equality(System.Reflection.Metadata.MethodImplementationHandle,System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodImplementationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodImplementationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Implicit(System.Reflection.Metadata.MethodImplementationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Implicit(System.Reflection.Metadata.MethodImplementationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Inequality(System.Reflection.Metadata.MethodImplementationHandle,System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.MethodImplementationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.MethodImplementationHandleCollection" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MethodImplementationHandle}#GetEnumerator">
      <summary>Devuelve un enumerador que procesa una iteración en la colección.</summary>
      <returns>Enumerador que se puede utilizar para recorrer en iteración la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Devuelve un enumerador que recorre en iteración una colección.</summary>
      <returns>Objeto <see cref="T:System.Collections.IEnumerator" /> que puede usarse para recorrer en iteración la colección.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodImplementationHandleCollection.Count">
      <summary>Obtiene el número de elementos de la colección.</summary>
      <returns>Número de elementos de la colección.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.MoveNext">
      <summary>Desplaza el enumerador al siguiente elemento de la colección.</summary>
      <returns>Es <see langword="true" /> si el enumerador avanzó con éxito hasta el siguiente elemento; es <see langword="false" /> si el enumerador alcanzó el final de la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Establece el enumerador en su posición inicial (antes del primer elemento de la colección).</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tareas definidas por la aplicación asociadas a la liberación o al restablecimiento de recursos no administrados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodImport" />
    <member name="P:System.Reflection.Metadata.MethodImport.Attributes" />
    <member name="P:System.Reflection.Metadata.MethodImport.Module" />
    <member name="P:System.Reflection.Metadata.MethodImport.Name" />
    <member name="T:System.Reflection.Metadata.MethodSignature`1">
      <summary>Representa un método (definición, referencia o independiente) o una firma de propiedad. En el caso de las propiedades, la firma coincide con la de un captador con un <see cref="T:System.Reflection.Metadata.SignatureHeader" /> distintivo.</summary>
      <typeparam name="TType">Tipo de método.</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.MethodSignature`1.#ctor(System.Reflection.Metadata.SignatureHeader,`0,System.Int32,System.Int32,System.Collections.Immutable.ImmutableArray{`0})">
      <summary>Inicializa una nueva instancia de la estructura <see cref="T:System.Reflection.Metadata.MethodSignature`1" /> mediante la información de encabezado, tipo de valor devuelto y parámetros especificada.</summary>
      <param name="header">Información del byte inicial de la firma (tipo, convención de llamada, marcas).</param>
      <param name="returnType">Tipo devuelto del método.</param>
      <param name="requiredParameterCount">Número de parámetros necesarios.</param>
      <param name="genericParameterCount">Número de parámetros de tipo genérico.</param>
      <param name="parameterTypes">Tipos de parámetros.</param>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.GenericParameterCount">
      <summary>Obtiene el número de parámetros de tipo genérico para el método.</summary>
      <returns>El número de parámetros de tipo genérico, o 0 para métodos no genéricos.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.Header">
      <summary>Obtiene la información del byte inicial de la firma (tipo, convención de llamada, marcas).</summary>
      <returns>Firma del encabezado.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.ParameterTypes">
      <summary>Obtiene los tipos de parámetro del método.</summary>
      <returns>Colección inmutable de tipos de parámetro.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.RequiredParameterCount">
      <summary>Obtiene el número de parámetros que son necesarios para el método.</summary>
      <returns>Número de parámetros necesarios.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.ReturnType">
      <summary>Obtiene el tipo de valor devuelto del método.</summary>
      <returns>Tipo de valor devuelto.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodSpecification" />
    <member name="M:System.Reflection.Metadata.MethodSpecification.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecification.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.MethodSpecification.Method">
      <summary>Obtiene un identificador de <see langword="MethodDef" /> o <see langword="MemberRef" /> que especifica a qué método genérico hace referencia esta instancia (es decir, de qué método genérico es una instancia).</summary>
      <returns>Un <see langword="MethodDef" /><see langword="MemberRef" /> identificador o que especifica a qué método genérico hace referencia esta instancia.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSpecification.Signature">
      <summary>Obtiene un identificador al blob de firma.</summary>
      <returns>Identificador del objeto binario de firma.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodSpecificationHandle" />
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.Equals(System.Reflection.Metadata.MethodSpecificationHandle)">
      <summary>Indica si el objeto actual es igual a otro objeto del mismo tipo.</summary>
      <param name="other">Objeto que se va a comparar con este objeto.</param>
      <returns>
        <see langword="true" /> si el objeto actual es igual al parámetro <paramref name="other" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Equality(System.Reflection.Metadata.MethodSpecificationHandle,System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodSpecificationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodSpecificationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Implicit(System.Reflection.Metadata.MethodSpecificationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Implicit(System.Reflection.Metadata.MethodSpecificationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Inequality(System.Reflection.Metadata.MethodSpecificationHandle,System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.MethodSpecificationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ModuleDefinition" />
    <member name="M:System.Reflection.Metadata.ModuleDefinition.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.BaseGenerationId" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.Generation" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.GenerationId" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.Mvid" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.Name" />
    <member name="T:System.Reflection.Metadata.ModuleDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.Equals(System.Reflection.Metadata.ModuleDefinitionHandle)">
      <summary>Indica si el objeto actual es igual a otro objeto del mismo tipo.</summary>
      <param name="other">Objeto que se va a comparar con este objeto.</param>
      <returns>
        <see langword="true" /> si el objeto actual es igual al parámetro <paramref name="other" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Equality(System.Reflection.Metadata.ModuleDefinitionHandle,System.Reflection.Metadata.ModuleDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ModuleDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ModuleDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Implicit(System.Reflection.Metadata.ModuleDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Implicit(System.Reflection.Metadata.ModuleDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Inequality(System.Reflection.Metadata.ModuleDefinitionHandle,System.Reflection.Metadata.ModuleDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.ModuleDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ModuleReference" />
    <member name="M:System.Reflection.Metadata.ModuleReference.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ModuleReference.Name" />
    <member name="T:System.Reflection.Metadata.ModuleReferenceHandle" />
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.Equals(System.Reflection.Metadata.ModuleReferenceHandle)">
      <summary>Indica si el objeto actual es igual a otro objeto del mismo tipo.</summary>
      <param name="other">Objeto que se va a comparar con este objeto.</param>
      <returns>
        <see langword="true" /> si el objeto actual es igual al parámetro <paramref name="other" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Equality(System.Reflection.Metadata.ModuleReferenceHandle,System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ModuleReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ModuleReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Implicit(System.Reflection.Metadata.ModuleReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Implicit(System.Reflection.Metadata.ModuleReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Inequality(System.Reflection.Metadata.ModuleReferenceHandle,System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.ModuleReferenceHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.NamespaceDefinition" />
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.ExportedTypes">
      <summary>Obtiene todos los tipos exportados que residen directamente en un espacio de nombres.</summary>
      <returns>Matriz inmutable de identificadores de tipo exportados.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.Name">
      <summary>Obtiene el nombre incompleto de la definición de espacio de nombres.</summary>
      <returns>Nombre no completo de la definición del espacio de nombres.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.NamespaceDefinitions">
      <summary>Obtiene las definiciones de espacio de nombres que son elementos secundarios directos de la definición de espacio de nombres actual.</summary>
      <returns>Matriz inmutable de definiciones de espacio de nombres que son elementos secundarios directos de la definición del espacio de nombres actual.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.Parent">
      <summary>Obtiene el espacio de nombres primario.</summary>
      <returns>Espacio de nombres primario.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.TypeDefinitions">
      <summary>Obtiene todas las definiciones de tipo que residen directamente en un espacio de nombres.</summary>
      <returns>Matriz inmutable de identificadores de definición de tipo.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.NamespaceDefinitionHandle">
      <summary>Proporciona un identificador para una definición de espacio de nombres.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.Equals(System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <summary>Indica si el objeto actual es igual a otro objeto del mismo tipo.</summary>
      <param name="other">Objeto que se va a comparar con este objeto.</param>
      <returns>
        <see langword="true" /> si el objeto actual es igual al parámetro <paramref name="other" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Equality(System.Reflection.Metadata.NamespaceDefinitionHandle,System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.NamespaceDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Implicit(System.Reflection.Metadata.NamespaceDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Inequality(System.Reflection.Metadata.NamespaceDefinitionHandle,System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.Parameter" />
    <member name="M:System.Reflection.Metadata.Parameter.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.Parameter.GetDefaultValue" />
    <member name="M:System.Reflection.Metadata.Parameter.GetMarshallingDescriptor" />
    <member name="P:System.Reflection.Metadata.Parameter.Attributes" />
    <member name="P:System.Reflection.Metadata.Parameter.Name" />
    <member name="P:System.Reflection.Metadata.Parameter.SequenceNumber" />
    <member name="T:System.Reflection.Metadata.ParameterHandle" />
    <member name="M:System.Reflection.Metadata.ParameterHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.Equals(System.Reflection.Metadata.ParameterHandle)">
      <summary>Indica si el objeto actual es igual a otro objeto del mismo tipo.</summary>
      <param name="other">Objeto que se va a comparar con este objeto.</param>
      <returns>
        <see langword="true" /> si el objeto actual es igual al parámetro <paramref name="other" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Equality(System.Reflection.Metadata.ParameterHandle,System.Reflection.Metadata.ParameterHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ParameterHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ParameterHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Implicit(System.Reflection.Metadata.ParameterHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Implicit(System.Reflection.Metadata.ParameterHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Inequality(System.Reflection.Metadata.ParameterHandle,System.Reflection.Metadata.ParameterHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.ParameterHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ParameterHandleCollection">
      <summary>Contiene una colección de parámetros de un método especificado.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ParameterHandle}#GetEnumerator">
      <summary>Devuelve un enumerador que procesa una iteración en la colección.</summary>
      <returns>Enumerador que se puede utilizar para recorrer en iteración la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Devuelve un enumerador que recorre en iteración una colección.</summary>
      <returns>Objeto <see cref="T:System.Collections.IEnumerator" /> que puede usarse para recorrer en iteración la colección.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ParameterHandleCollection.Count">
      <summary>Obtiene el número de elementos de la colección.</summary>
      <returns>Número de elementos de la colección.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ParameterHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.MoveNext">
      <summary>Desplaza el enumerador al siguiente elemento de la colección.</summary>
      <returns>Es <see langword="true" /> si el enumerador avanzó con éxito hasta el siguiente elemento; es <see langword="false" /> si el enumerador alcanzó el final de la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Establece el enumerador en su posición inicial (antes del primer elemento de la colección).</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tareas definidas por la aplicación asociadas a la liberación o al restablecimiento de recursos no administrados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.PEReaderExtensions" />
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader)">
      <summary>Obtiene una propiedad <see cref="T:System.Reflection.Metadata.MetadataReader" /> de una clase <see cref="T:System.Reflection.PortableExecutable.PEReader" />.</summary>
      <param name="peReader">Instancia de <see cref="T:System.Reflection.PortableExecutable.PEReader" /> actual.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peReader" /> es <see langword="null" />.</exception>
      <exception cref="T:System.PlatformNotSupportedException">La plataforma actual es big endian.</exception>
      <exception cref="T:System.IO.IOException">Error de E/S al leer la secuencia subyacente.</exception>
      <returns>Lector de metadatos.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader,System.Reflection.Metadata.MetadataReaderOptions)">
      <summary>Obtiene un lector de metadatos con la configuración de lectura de metadatos especificada a partir de un objeto <see cref="T:System.Reflection.PortableExecutable.PEReader" />.</summary>
      <param name="peReader">Instancia de <see cref="T:System.Reflection.PortableExecutable.PEReader" /> actual.</param>
      <param name="options">Valor de enumeración que indica la configuración de lectura de metadatos.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peReader" /> es <see langword="null" />.</exception>
      <exception cref="T:System.PlatformNotSupportedException">La plataforma actual es big endian.</exception>
      <exception cref="T:System.IO.IOException">Error de E/S al leer la secuencia subyacente.</exception>
      <returns>Lector de metadatos con la configuración de lectura de metadatos especificada.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader,System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)">
      <summary>Obtiene un lector de metadatos con la configuración de lectura de metadatos especificada y la configuración de codificación a partir de un objeto <see cref="T:System.Reflection.PortableExecutable.PEReader" />.</summary>
      <param name="peReader">Instancia de <see cref="T:System.Reflection.PortableExecutable.PEReader" /> actual.</param>
      <param name="options">Valor de enumeración que indica la configuración de lectura de metadatos.</param>
      <param name="utf8Decoder">Descodificador de cadena de metadatos con la configuración de codificación.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peReader" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">La codificación de <paramref name="utf8Decoder" /> no es <see cref="T:System.Text.UTF8Encoding" />.</exception>
      <exception cref="T:System.PlatformNotSupportedException">La plataforma actual es big endian.</exception>
      <exception cref="T:System.IO.IOException">Error de E/S al leer la secuencia subyacente.</exception>
      <returns>&gt;Lector de metadatos con la configuración de lectura de metadatos especificada y la configuración de codificación.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMethodBody(System.Reflection.PortableExecutable.PEReader,System.Int32)">
      <summary>Devuelve un bloque de cuerpo de un método con la dirección relativa virtual (RVA) especificada;</summary>
      <param name="peReader">Instancia de <see cref="T:System.Reflection.PortableExecutable.PEReader" /> actual.</param>
      <param name="relativeVirtualAddress">Dirección relativa virtual (RVA).</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peReader" /> es <see langword="null" />.</exception>
      <exception cref="T:System.BadImageFormatException">El cuerpo no se encuentra en los metadatos o no es válido.</exception>
      <exception cref="T:System.InvalidOperationException">La sección donde se almacena el método no está disponible.</exception>
      <exception cref="T:System.IO.IOException">Error de E/S producido al leer desde la secuencia subyacente.</exception>
      <returns>Instancia de cuerpo de bloque de método.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.PrimitiveSerializationTypeCode">
      <summary>Especifica las constantes que definen los códigos de tipo que se usan para codificar los tipos de valores primitivos en un blob de valor <see cref="T:System.Reflection.Metadata.CustomAttribute" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Boolean">
      <summary>Tipo <see cref="T:System.Boolean" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Byte">
      <summary>Tipo entero de 1 byte sin signo.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Char">
      <summary>Tipo <see cref="T:System.Char" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Double">
      <summary>Tipo de punto flotante de 8 bytes.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Int16">
      <summary>Tipo entero de 2 bytes con signo.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Int32">
      <summary>Tipo entero de 4 bytes con signo.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Int64">
      <summary>Tipo entero de 8 bytes con signo.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.SByte">
      <summary>Tipo entero de 1 byte con signo.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Single">
      <summary>Tipo de punto flotante de 4 bytes.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.String">
      <summary>Tipo <see cref="T:System.String" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.UInt16">
      <summary>Tipo entero de 2 bytes sin signo.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.UInt32">
      <summary>Tipo entero de 4 bytes sin signo.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.UInt64">
      <summary>Tipo entero de 8 bytes sin signo.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.PrimitiveTypeCode">
      <summary>Especifica las constantes que definen los tipos primitivos que se encuentran en las firmas de metadatos.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Boolean">
      <summary>Tipo <see cref="T:System.Boolean" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Byte">
      <summary>Tipo <see cref="T:System.Byte" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Char">
      <summary>Tipo <see cref="T:System.Char" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Double">
      <summary>Tipo <see cref="T:System.Double" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Int16">
      <summary>Tipo <see cref="T:System.Int16" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Int32">
      <summary>Tipo <see cref="T:System.Int32" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Int64">
      <summary>Tipo <see cref="T:System.Int64" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.IntPtr">
      <summary>Tipo <see cref="T:System.IntPtr" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Object">
      <summary>Tipo <see cref="T:System.Object" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.SByte">
      <summary>Tipo <see cref="T:System.SByte" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Single">
      <summary>Tipo <see cref="T:System.Single" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.String">
      <summary>Tipo <see cref="T:System.String" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.TypedReference">
      <summary>Referencia con tipo.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UInt16">
      <summary>Tipo <see cref="T:System.UInt16" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UInt32">
      <summary>Tipo <see cref="T:System.UInt32" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UInt64">
      <summary>Tipo <see cref="T:System.UInt64" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UIntPtr">
      <summary>Tipo <see cref="T:System.UIntPtr" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Void">
      <summary>Tipo <see cref="T:System.Void" />.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.PropertyAccessors" />
    <member name="P:System.Reflection.Metadata.PropertyAccessors.Getter" />
    <member name="P:System.Reflection.Metadata.PropertyAccessors.Others" />
    <member name="P:System.Reflection.Metadata.PropertyAccessors.Setter" />
    <member name="T:System.Reflection.Metadata.PropertyDefinition" />
    <member name="M:System.Reflection.Metadata.PropertyDefinition.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinition.GetAccessors" />
    <member name="M:System.Reflection.Metadata.PropertyDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.PropertyDefinition.GetDefaultValue" />
    <member name="P:System.Reflection.Metadata.PropertyDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.PropertyDefinition.Name" />
    <member name="P:System.Reflection.Metadata.PropertyDefinition.Signature" />
    <member name="T:System.Reflection.Metadata.PropertyDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.Equals(System.Reflection.Metadata.PropertyDefinitionHandle)">
      <summary>Indica si el objeto actual es igual a otro objeto del mismo tipo.</summary>
      <param name="other">Objeto que se va a comparar con este objeto.</param>
      <returns>
        <see langword="true" /> si el objeto actual es igual al parámetro <paramref name="other" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Equality(System.Reflection.Metadata.PropertyDefinitionHandle,System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.PropertyDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.PropertyDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Implicit(System.Reflection.Metadata.PropertyDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Implicit(System.Reflection.Metadata.PropertyDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Inequality(System.Reflection.Metadata.PropertyDefinitionHandle,System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.PropertyDefinitionHandleCollection" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#PropertyDefinitionHandle}#GetEnumerator">
      <summary>Devuelve un enumerador que procesa una iteración en la colección.</summary>
      <returns>Enumerador que se puede utilizar para recorrer en iteración la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Devuelve un enumerador que recorre en iteración una colección.</summary>
      <returns>Objeto <see cref="T:System.Collections.IEnumerator" /> que puede usarse para recorrer en iteración la colección.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Count">
      <summary>Obtiene el número de elementos de la colección.</summary>
      <returns>Número de elementos de la colección.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.MoveNext">
      <summary>Desplaza el enumerador al siguiente elemento de la colección.</summary>
      <returns>Es <see langword="true" /> si el enumerador avanzó con éxito hasta el siguiente elemento; es <see langword="false" /> si el enumerador alcanzó el final de la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Establece el enumerador en su posición inicial (antes del primer elemento de la colección).</summary>
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tareas definidas por la aplicación asociadas a la liberación o al restablecimiento de recursos no administrados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ReservedBlob`1">
      <summary>Representa un identificador y un blob correspondiente en un montón de metadatos que se ha reservado para futuras actualizaciones de contenido.</summary>
      <typeparam name="THandle" />
    </member>
    <member name="M:System.Reflection.Metadata.ReservedBlob`1.CreateWriter">
      <summary>Devuelve un objeto <see cref="T:System.Reflection.Metadata.BlobWriter" /> que se usará para actualizar el contenido.</summary>
      <returns>Escritor de blob que se va a usar para actualizar el contenido.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ReservedBlob`1.Content" />
    <member name="P:System.Reflection.Metadata.ReservedBlob`1.Handle">
      <summary>Obtiene el identificador de blob reservado.</summary>
      <returns>Identificador de bloquear reservado.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.SequencePoint" />
    <member name="F:System.Reflection.Metadata.SequencePoint.HiddenLine" />
    <member name="M:System.Reflection.Metadata.SequencePoint.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.SequencePoint.Equals(System.Reflection.Metadata.SequencePoint)">
      <summary>Indica si el objeto actual es igual a otro objeto del mismo tipo.</summary>
      <param name="other">Objeto que se va a comparar con este objeto.</param>
      <returns>
        <see langword="true" /> si el objeto actual es igual al parámetro <paramref name="other" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SequencePoint.GetHashCode" />
    <member name="P:System.Reflection.Metadata.SequencePoint.Document" />
    <member name="P:System.Reflection.Metadata.SequencePoint.EndColumn" />
    <member name="P:System.Reflection.Metadata.SequencePoint.EndLine" />
    <member name="P:System.Reflection.Metadata.SequencePoint.IsHidden" />
    <member name="P:System.Reflection.Metadata.SequencePoint.Offset" />
    <member name="P:System.Reflection.Metadata.SequencePoint.StartColumn" />
    <member name="P:System.Reflection.Metadata.SequencePoint.StartLine" />
    <member name="T:System.Reflection.Metadata.SequencePointCollection" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#SequencePoint}#GetEnumerator">
      <summary>Devuelve un enumerador que procesa una iteración en la colección.</summary>
      <returns>Enumerador que se puede utilizar para recorrer en iteración la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SequencePointCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Devuelve un enumerador que recorre en iteración una colección.</summary>
      <returns>Objeto <see cref="T:System.Collections.IEnumerator" /> que puede usarse para recorrer en iteración la colección.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.SequencePointCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.Enumerator.MoveNext">
      <summary>Desplaza el enumerador al siguiente elemento de la colección.</summary>
      <returns>Es <see langword="true" /> si el enumerador avanzó con éxito hasta el siguiente elemento; es <see langword="false" /> si el enumerador alcanzó el final de la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SequencePointCollection.Enumerator.Reset">
      <summary>Establece el enumerador en su posición inicial (antes del primer elemento de la colección).</summary>
    </member>
    <member name="M:System.Reflection.Metadata.SequencePointCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tareas definidas por la aplicación asociadas a la liberación o al restablecimiento de recursos no administrados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.SequencePointCollection.Enumerator.Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SequencePointCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.SerializationTypeCode">
      <summary>Especifica los códigos de tipo que se usan para codificar los tipos de valores en un blob <see cref="T:System.Reflection.Metadata.CustomAttributeValue`1" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Boolean">
      <summary>Valor equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Boolean" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Byte">
      <summary>Valor equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Byte" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Char">
      <summary>Valor equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Char" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Double">
      <summary>Valor equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Double" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Enum">
      <summary>El argumento de atributo es una instancia de enumeración.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int16">
      <summary>Valor equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int16" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int32">
      <summary>Valor equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int32" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int64">
      <summary>Valor equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int64" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Invalid">
      <summary>Valor equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Invalid" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.SByte">
      <summary>Valor equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.SByte" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Single">
      <summary>Valor equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Single" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.String">
      <summary>Valor equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.String" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.SZArray">
      <summary>Valor equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.SZArray" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.TaggedObject">
      <summary>Se aplica la "conversión boxing" al argumento de atributo (se pasa a un parámetro, campo o propiedad del objeto de tipo) y se transmite la información del tipo en el blob de atributo.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Type">
      <summary>El argumento de atributo es una instancia de <see cref="T:System.Type" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt16">
      <summary>Valor equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt16" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt32">
      <summary>Valor equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt32" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt64">
      <summary>Valor equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt64" />.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureAttributes">
      <summary>Especifica las marcas adicionales que se pueden aplicar a las firmas de método. Los valores subyacentes de los campos de este tipo se corresponden a la representación en el byte inicial de firma representado por una estructura <see cref="T:System.Reflection.Metadata.SignatureHeader" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis">
      <summary>Indica el primer parámetro declarado explícitamente que representa el puntero de la instancia.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.Generic">
      <summary>Un método genérico.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.Instance">
      <summary>Un método de instancia.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.None">
      <summary>Sin marcas.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureCallingConvention">
      <summary>Especifica cómo se pasan los argumentos de una firma determinada desde el autor de la llamada al destinatario. Los valores subyacentes de los campos de este tipo se corresponden a la representación en el byte inicial de firma representado por una estructura <see cref="T:System.Reflection.Metadata.SignatureHeader" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.CDecl">
      <summary>Una convención de llamada de estilo de C o C++ no administrada en la que el autor de la llamada limpia la pila de llamadas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.Default">
      <summary>Una convención de llamada administrada con una lista de argumentos de longitud fija.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.FastCall">
      <summary>Una convención de llamada no administrada donde los argumentos se pasan en registros siempre que es posible.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.StdCall">
      <summary>Una convención de llamada no administrada en la que el destinatario limpia la pila de llamadas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.ThisCall">
      <summary>Una convención de llamada de estilo de C++ no administrada para llamar a funciones miembro de instancia con una lista de argumentos fijos.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.Unmanaged">
      <summary>Indica que los detalles de la convención de llamada no administrada se codifican como modopts.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.VarArgs">
      <summary>Una convención de llamada administrada para pasar argumentos adicionales.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureHeader">
      <summary>Representa las características de firma especificadas por el byte inicial de los blobs de firma.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureHeader.CallingConventionOrKindMask">
      <summary>Obtiene el valor de máscara para la convención de llamada o el tipo de firma. El valor <see cref="F:System.Reflection.Metadata.SignatureHeader.CallingConventionOrKindMask" /> predeterminado es 15 (0x0F).</summary>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.#ctor(System.Byte)">
      <summary>Inicializa una nueva instancia de la estructura <see cref="T:System.Reflection.Metadata.SignatureHeader" /> utilizando el valor de bytes especificado.</summary>
      <param name="rawValue">El byte.</param>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.#ctor(System.Reflection.Metadata.SignatureKind,System.Reflection.Metadata.SignatureCallingConvention,System.Reflection.Metadata.SignatureAttributes)">
      <summary>Inicializa una nueva instancia de la estructura <see cref="T:System.Reflection.Metadata.SignatureHeader" /> con el tipo de firma especificado, la convención de llamada y los atributos de firma.</summary>
      <param name="kind">Tipo de firma.</param>
      <param name="convention">Convención de llamada.</param>
      <param name="attributes">Atributos de la firma.</param>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.Equals(System.Object)">
      <summary>Compara el objeto especificado con este <see cref="T:System.Reflection.Metadata.SignatureHeader" /> para ver si son iguales.</summary>
      <param name="obj">Objeto que se va a comparar.</param>
      <returns>
        <see langword="true" /> si los objetos son iguales; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.Equals(System.Reflection.Metadata.SignatureHeader)">
      <summary>Compara dos valores de <see cref="T:System.Reflection.Metadata.SignatureHeader" /> para determinar si son iguales.</summary>
      <param name="other">Valor que se va comparar.</param>
      <returns>Es <see langword="true" /> si los valores son iguales; en caso contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.GetHashCode">
      <summary>Obtiene un código hash para el objeto actual.</summary>
      <returns>Código hash para el objeto actual.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.op_Equality(System.Reflection.Metadata.SignatureHeader,System.Reflection.Metadata.SignatureHeader)">
      <summary>Compara dos valores de <see cref="T:System.Reflection.Metadata.SignatureHeader" /> para determinar si son iguales.</summary>
      <param name="left">Primer valor que se va a comparar.</param>
      <param name="right">Segundo valor que se va a comparar.</param>
      <returns>Es <see langword="true" /> si los valores son iguales; en caso contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.op_Inequality(System.Reflection.Metadata.SignatureHeader,System.Reflection.Metadata.SignatureHeader)">
      <summary>Determina si dos valores <see cref="T:System.Reflection.Metadata.SignatureHeader" /> son desiguales.</summary>
      <param name="left">Primer valor que se va a comparar.</param>
      <param name="right">Segundo valor que se va a comparar.</param>
      <returns>
        <see langword="true" /> si los valores son desiguales; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.ToString">
      <summary>Devuelve una cadena que representa el objeto actual.</summary>
      <returns>Una cadena que representa el objeto actual.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.Attributes">
      <summary>Obtiene los atributos de la firma.</summary>
      <returns>Atributos.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.CallingConvention">
      <summary>Obtiene la convención de llamada.</summary>
      <returns>Convención de llamada.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.HasExplicitThis">
      <summary>Obtiene un valor que indica si esta estructura <see cref="T:System.Reflection.Metadata.SignatureHeader" /> tiene el atributo de firma <see cref="F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis" />.</summary>
      <returns>
        <see langword="true" /> Si el <see cref="F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis" /> atributo está presente; en caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.IsGeneric">
      <summary>Obtiene un valor que indica si esta estructura <see cref="T:System.Reflection.Metadata.SignatureHeader" /> tiene el atributo de firma <see cref="F:System.Reflection.Metadata.SignatureAttributes.Generic" />.</summary>
      <returns>
        <see langword="true" /> Si el <see cref="F:System.Reflection.Metadata.SignatureAttributes.Generic" /> atributo está presente; en caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.IsInstance">
      <summary>Obtiene un valor que indica si esta estructura <see cref="T:System.Reflection.Metadata.SignatureHeader" /> tiene el atributo de firma <see cref="F:System.Reflection.Metadata.SignatureAttributes.Instance" />.</summary>
      <returns>
        <see langword="true" /> Si el <see cref="F:System.Reflection.Metadata.SignatureAttributes.Instance" /> atributo está presente; en caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.Kind">
      <summary>Obtiene el tipo de firma.</summary>
      <returns>Tipo de firma.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.RawValue">
      <summary>Obtiene el valor sin formato del byte de encabezado.</summary>
      <returns>Valor sin formato del byte del encabezado.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureKind">
      <summary>Especifica el tipo de firma. Los valores subyacentes de los campos de este tipo se corresponden a la representación en el byte inicial de firma representado por una estructura <see cref="T:System.Reflection.Metadata.SignatureHeader" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.Field">
      <summary>Una firma de campo.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.LocalVariables">
      <summary>Una firma de las variables locales.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.Method">
      <summary>Una referencia de método, definición de método o firma de método independiente.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.MethodSpecification">
      <summary>Una firma de especificación de método.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.Property">
      <summary>Una firma de propiedad.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureTypeCode">
      <summary>Especifica las constantes que definen los códigos de tipo que se usan en la codificación de firma.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Array">
      <summary>Representa una matriz <see cref="T:System.Array" /> generalizada en las firmas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Boolean">
      <summary>Representa un <see cref="T:System.Boolean" /> en las firmas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.ByReference">
      <summary>Representa los punteros administrados (valores y parámetros devueltos de byref) en las firmas. Se sigue en el blob con la codificación de firma del tipo subyacente.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Byte">
      <summary>Representa un <see cref="T:System.Byte" /> en las firmas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Char">
      <summary>Representa un <see cref="T:System.Char" /> en las firmas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Double">
      <summary>Representa un <see cref="T:System.Double" /> en las firmas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.FunctionPointer">
      <summary>Representa los tipos de puntero de función en las firmas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericMethodParameter">
      <summary>Representa un parámetro de método genérico usado dentro de una firma.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericTypeInstance">
      <summary>Representa la creación de instancias de un tipo genérico en las firmas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericTypeParameter">
      <summary>Representa un parámetro de tipo genérico usado dentro de una firma.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int16">
      <summary>Representa un <see cref="T:System.Int16" /> en las firmas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int32">
      <summary>Representa un <see cref="T:System.Int32" /> en las firmas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int64">
      <summary>Representa un <see cref="T:System.Int64" /> en las firmas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.IntPtr">
      <summary>Representa un <see cref="T:System.IntPtr" /> en las firmas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Invalid">
      <summary>Representa un código de tipo no válido o no inicializado. No aparecerá en las firmas válidas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Object">
      <summary>Representa un <see cref="T:System.Object" /> en las firmas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.OptionalModifier">
      <summary>Representa un modificador personalizado aplicado a un tipo dentro de una firma que el autor de la llamada puede ignorar.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Pinned">
      <summary>Representa una variable local que está anclada por el recolector de elementos no utilizados.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Pointer">
      <summary>Representa un puntero no administrado en las firmas. Se sigue en el blob con la codificación de firma del tipo subyacente.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.RequiredModifier">
      <summary>Representa un modificador personalizado aplicado a un tipo dentro de una firma que el autor de la llamada debe entender.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.SByte">
      <summary>Representa un <see cref="T:System.SByte" /> en las firmas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Sentinel">
      <summary>Representa un marcador para indicar el final de los argumentos fijos y el principio de los argumentos variables.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Single">
      <summary>Representa un <see cref="T:System.Single" /> en las firmas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.String">
      <summary>Representa un <see cref="T:System.String" /> en las firmas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.SZArray">
      <summary>Representa una matriz <see cref="T:System.Array" /> de una sola dimensión con un límite inferior de 0.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.TypedReference">
      <summary>Representa una referencia con tipo en las firmas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.TypeHandle">
      <summary>Precede a un tipo <see cref="T:System.Reflection.Metadata.EntityHandle" /> en las firmas. En los metadatos sin formato, se codifica como ELEMENT_TYPE_CLASS (0x12) para los tipos de referencia, o bien como ELEMENT_TYPE_VALUETYPE (0x11) para los tipos de valor. Se contrae en un único código porque las proyecciones de Windows Runtime pueden proyectar desde la clase al tipo de valor o viceversa, y el código sin procesar es confuso en esos casos.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt16">
      <summary>Representa un <see cref="T:System.UInt16" /> en las firmas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt32">
      <summary>Representa un <see cref="T:System.UInt32" /> en las firmas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt64">
      <summary>Representa un <see cref="T:System.UInt64" /> en las firmas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UIntPtr">
      <summary>Representa un <see cref="T:System.UIntPtr" /> en las firmas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Void">
      <summary>Representa <see cref="T:System.Void" /> en las firmas.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureTypeKind">
      <summary>Indica la definición de tipo de la firma.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeKind.Class">
      <summary>La definición o referencia del tipo hace referencia a una clase.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeKind.Unknown">
      <summary>En el contexto actual se desconoce si la definición o referencia del tipo es una clase o tipo de valor.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeKind.ValueType">
      <summary>La definición o referencia del tipo hace referencia a un tipo de valor.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.StandaloneSignature" />
    <member name="M:System.Reflection.Metadata.StandaloneSignature.DecodeLocalSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignature.DecodeMethodSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignature.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.StandaloneSignature.GetKind">
      <summary>Determina el tipo de firma, que puede ser <see cref="F:System.Reflection.Metadata.SignatureKind.Method" /> o <see cref="F:System.Reflection.Metadata.SignatureKind.LocalVariables" />.</summary>
      <exception cref="T:System.BadImageFormatException">La firma no es válida.</exception>
      <returns>Valor de enumeración que indica el tipo de firma.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.StandaloneSignature.Signature">
      <summary>Obtiene un identificador al blob de firma.</summary>
      <returns>Identificador del objeto binario de firma.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.StandaloneSignatureHandle" />
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.Equals(System.Reflection.Metadata.StandaloneSignatureHandle)">
      <summary>Indica si el objeto actual es igual a otro objeto del mismo tipo.</summary>
      <param name="other">Objeto que se va a comparar con este objeto.</param>
      <returns>
        <see langword="true" /> si el objeto actual es igual al parámetro <paramref name="other" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Equality(System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.StandaloneSignatureHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.StandaloneSignatureHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Implicit(System.Reflection.Metadata.StandaloneSignatureHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Implicit(System.Reflection.Metadata.StandaloneSignatureHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Inequality(System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.StandaloneSignatureHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.StandaloneSignatureKind">
      <summary>Indica si <see cref="T:System.Reflection.Metadata.StandaloneSignature" /> representa un método independiente o una firma de variable local.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.StandaloneSignatureKind.LocalVariables">
      <summary>
        <see cref="T:System.Reflection.Metadata.MemberReference" /> hace referencia a una firma de variable local.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.StandaloneSignatureKind.Method">
      <summary>
        <see cref="T:System.Reflection.Metadata.StandaloneSignature" /> representa una firma de método independiente.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.StringHandle" />
    <member name="M:System.Reflection.Metadata.StringHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.Equals(System.Reflection.Metadata.StringHandle)">
      <summary>Indica si el objeto actual es igual a otro objeto del mismo tipo.</summary>
      <param name="other">Objeto que se va a comparar con este objeto.</param>
      <returns>
        <see langword="true" /> si el objeto actual es igual al parámetro <paramref name="other" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.StringHandle.op_Equality(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.StringHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.op_Implicit(System.Reflection.Metadata.StringHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.op_Inequality(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.StringHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.TypeDefinition" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetDeclarativeSecurityAttributes" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetDeclaringType">
      <summary>Devuelve el tipo envolvente de un tipo anidado especificado.</summary>
      <returns>El tipo envolvente del tipo anidado especificado, o bien un identificador cuya propiedad <see cref="P:System.Reflection.Metadata.TypeDefinitionHandle.IsNil" /> es <see langword="true" /> si el tipo no está anidado.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetEvents" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetFields" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetGenericParameters" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetInterfaceImplementations" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetLayout" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetMethodImplementations" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetMethods" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetNestedTypes">
      <summary>Devuelve una matriz de tipos anidados en el tipo especificado.</summary>
      <returns>Una matriz inmutable de identificadores de definición de tipo que representan los tipos anidados en el tipo especificado.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetProperties" />
    <member name="P:System.Reflection.Metadata.TypeDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.TypeDefinition.BaseType">
      <summary>Obtiene el tipo base de la definición de tipo: puede ser <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> o <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />.</summary>
      <returns>Tipo base de la definición de tipo.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.IsNested">
      <summary>Obtiene un valor que indica si este es un tipo anidado.</summary>
      <returns>
        <see langword="true" /> Si es un tipo anidado; de <see langword="false" /> lo contrario,.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.Name">
      <summary>Obtiene el nombre del tipo.</summary>
      <returns>Nombre del tipo.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.Namespace">
      <summary>Obtiene el nombre completo del espacio de nombres donde se define el tipo.</summary>
      <returns>Nombre completo del espacio de nombres donde se define el tipo o un identificador cuya <see cref="P:System.Reflection.Metadata.StringHandle.IsNil" /> propiedad es <see langword="true" /> si el tipo está anidado o definido en un espacio de nombres raíz.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.NamespaceDefinition">
      <summary>Obtiene el identificador de la definición del espacio de nombres donde se define el tipo.</summary>
      <returns>Identificador de definición del espacio de nombres donde se define el tipo, o un identificador cuya <see cref="P:System.Reflection.Metadata.NamespaceDefinitionHandle.IsNil" /> propiedad es <see langword="true" />  si el tipo está anidado o definido en un espacio de nombres raíz.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.Equals(System.Reflection.Metadata.TypeDefinitionHandle)">
      <summary>Indica si el objeto actual es igual a otro objeto del mismo tipo.</summary>
      <param name="other">Objeto que se va a comparar con este objeto.</param>
      <returns>
        <see langword="true" /> si el objeto actual es igual al parámetro <paramref name="other" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Equality(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.TypeDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.TypeDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Implicit(System.Reflection.Metadata.TypeDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Implicit(System.Reflection.Metadata.TypeDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Inequality(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.TypeDefinitionHandleCollection">
      <summary>Contiene una colección de instancias de <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#TypeDefinitionHandle}#GetEnumerator">
      <summary>Devuelve un enumerador que procesa una iteración en la colección.</summary>
      <returns>Enumerador que se puede utilizar para recorrer en iteración la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Devuelve un enumerador que recorre en iteración una colección.</summary>
      <returns>Objeto <see cref="T:System.Collections.IEnumerator" /> que puede usarse para recorrer en iteración la colección.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandleCollection.Count">
      <summary>Obtiene el número de elementos de la colección.</summary>
      <returns>Número de elementos de la colección.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.MoveNext">
      <summary>Desplaza el enumerador al siguiente elemento de la colección.</summary>
      <returns>Es <see langword="true" /> si el enumerador avanzó con éxito hasta el siguiente elemento; es <see langword="false" /> si el enumerador alcanzó el final de la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Establece el enumerador en su posición inicial (antes del primer elemento de la colección).</summary>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tareas definidas por la aplicación asociadas a la liberación o al restablecimiento de recursos no administrados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeLayout" />
    <member name="M:System.Reflection.Metadata.TypeLayout.#ctor(System.Int32,System.Int32)">
      <param name="size" />
      <param name="packingSize" />
    </member>
    <member name="P:System.Reflection.Metadata.TypeLayout.IsDefault" />
    <member name="P:System.Reflection.Metadata.TypeLayout.PackingSize" />
    <member name="P:System.Reflection.Metadata.TypeLayout.Size" />
    <member name="T:System.Reflection.Metadata.TypeReference" />
    <member name="P:System.Reflection.Metadata.TypeReference.Name">
      <summary>Obtiene el nombre del tipo de destino.</summary>
      <returns>El nombre del tipo de destino.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReference.Namespace">
      <summary>Obtiene el nombre completo del espacio de nombres donde se define el tipo de destino.</summary>
      <returns>Nombre completo del espacio de nombres donde se define el tipo de destino o un identificador cuya <see cref="P:System.Reflection.Metadata.StringHandle.IsNil" /> propiedad es <see langword="true" /> si el tipo está anidado o definido en un espacio de nombres raíz,</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReference.ResolutionScope">
      <summary>Obtiene el ámbito de resolución en el que se define el tipo de destino y se identifica de forma exclusiva por los objetos <see cref="P:System.Reflection.Metadata.TypeReference.Namespace" /> y <see cref="P:System.Reflection.Metadata.TypeReference.Name" /> especificados.</summary>
      <returns>El ámbito de resolución en el que el tipo de destino se define de forma única.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeReferenceHandle" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.Equals(System.Reflection.Metadata.TypeReferenceHandle)">
      <summary>Indica si el objeto actual es igual a otro objeto del mismo tipo.</summary>
      <param name="other">Objeto que se va a comparar con este objeto.</param>
      <returns>
        <see langword="true" /> si el objeto actual es igual al parámetro <paramref name="other" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Equality(System.Reflection.Metadata.TypeReferenceHandle,System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.TypeReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.TypeReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Implicit(System.Reflection.Metadata.TypeReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Implicit(System.Reflection.Metadata.TypeReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Inequality(System.Reflection.Metadata.TypeReferenceHandle,System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.TypeReferenceHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.TypeReferenceHandleCollection">
      <summary>Contiene una colección de instancias de <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#TypeReferenceHandle}#GetEnumerator">
      <summary>Devuelve un enumerador que procesa una iteración en la colección.</summary>
      <returns>Enumerador que se puede utilizar para recorrer en iteración la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Devuelve un enumerador que recorre en iteración una colección.</summary>
      <returns>Objeto <see cref="T:System.Collections.IEnumerator" /> que puede usarse para recorrer en iteración la colección.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReferenceHandleCollection.Count">
      <summary>Obtiene el número de elementos de la colección.</summary>
      <returns>Número de elementos de la colección.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.MoveNext">
      <summary>Desplaza el enumerador al siguiente elemento de la colección.</summary>
      <returns>Es <see langword="true" /> si el enumerador avanzó con éxito hasta el siguiente elemento; es <see langword="false" /> si el enumerador alcanzó el final de la colección.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Establece el enumerador en su posición inicial (antes del primer elemento de la colección).</summary>
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tareas definidas por la aplicación asociadas a la liberación o al restablecimiento de recursos no administrados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeSpecification" />
    <member name="M:System.Reflection.Metadata.TypeSpecification.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecification.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.TypeSpecification.Signature" />
    <member name="T:System.Reflection.Metadata.TypeSpecificationHandle" />
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.Equals(System.Reflection.Metadata.TypeSpecificationHandle)">
      <summary>Indica si el objeto actual es igual a otro objeto del mismo tipo.</summary>
      <param name="other">Objeto que se va a comparar con este objeto.</param>
      <returns>
        <see langword="true" /> si el objeto actual es igual al parámetro <paramref name="other" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Equality(System.Reflection.Metadata.TypeSpecificationHandle,System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.TypeSpecificationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.TypeSpecificationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Implicit(System.Reflection.Metadata.TypeSpecificationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Implicit(System.Reflection.Metadata.TypeSpecificationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Inequality(System.Reflection.Metadata.TypeSpecificationHandle,System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.TypeSpecificationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.UserStringHandle">
      <summary>Representa un identificador para el montón de cadena de usuario.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.Equals(System.Reflection.Metadata.UserStringHandle)">
      <summary>Indica si el objeto actual es igual a otro objeto del mismo tipo.</summary>
      <param name="other">Objeto que se va a comparar con este objeto.</param>
      <returns>
        <see langword="true" /> si el objeto actual es igual al parámetro <paramref name="other" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Equality(System.Reflection.Metadata.UserStringHandle,System.Reflection.Metadata.UserStringHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.UserStringHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Implicit(System.Reflection.Metadata.UserStringHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Inequality(System.Reflection.Metadata.UserStringHandle,System.Reflection.Metadata.UserStringHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.UserStringHandle.IsNil" />
    <member name="T:System.Reflection.MethodImportAttributes" />
    <member name="F:System.Reflection.MethodImportAttributes.BestFitMappingDisable" />
    <member name="F:System.Reflection.MethodImportAttributes.BestFitMappingEnable" />
    <member name="F:System.Reflection.MethodImportAttributes.BestFitMappingMask" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionCDecl" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionFastCall" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionMask" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionStdCall" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionThisCall" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionWinApi" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetAnsi" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetAuto" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetMask" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetUnicode" />
    <member name="F:System.Reflection.MethodImportAttributes.ExactSpelling" />
    <member name="F:System.Reflection.MethodImportAttributes.None" />
    <member name="F:System.Reflection.MethodImportAttributes.SetLastError" />
    <member name="F:System.Reflection.MethodImportAttributes.ThrowOnUnmappableCharDisable" />
    <member name="F:System.Reflection.MethodImportAttributes.ThrowOnUnmappableCharEnable" />
    <member name="F:System.Reflection.MethodImportAttributes.ThrowOnUnmappableCharMask" />
    <member name="T:System.Reflection.MethodSemanticsAttributes" />
    <member name="F:System.Reflection.MethodSemanticsAttributes.Adder">
      <summary>
        <para>Se usa para agregar un controlador para un evento. Corresponde a la marca <see langword="AddOn" /> en la especificación de la CLI de ECMA 335.</para>
        <para>Los agregadores conformes a CLS se denominan con el prefijo <see langword="add_" />.</para>
      </summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Getter">
      <summary>
        <para>Lee el valor de la propiedad.</para>
        <para>Los captadores conformes a CLS se denominan con el prefijo get_.</para>
      </summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Other">
      <summary>Otro método para una propiedad (no un captador ni un establecedor) o un evento (no un agregador, un eliminador o un desencadenador).</summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Raiser">
      <summary>
        <para>Se usa para indicar que se ha producido un evento. Corresponde a la marca <see langword="Fire" /> en la especificación de la CLI de ECMA 335.</para>
        <para> Los desencadenadores conformes a CLS se denominan con el prefijo <see langword="raise_" />.</para>
      </summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Remover">
      <summary>
        <para>Se usa para quitar un controlador de un evento. Corresponde a la marca <see langword="RemoveOn" /> en la especificación de la CLI de ECMA 335.</para>
        <para>Los eliminadores conformes a CLS se denominan con el prefijo <see langword="remove_" />.</para>
      </summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Setter">
      <summary>
        <para>Se usa para modificar el valor de la propiedad.</para>
        <para>Los establecedores conformes a CLS se denominan con el prefijo <see langword="set_" />.</para>
      </summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.Characteristics" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.AggressiveWSTrim" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.Bit32Machine" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.BytesReversedHi" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.BytesReversedLo" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.DebugStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.Dll" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.ExecutableImage" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.LargeAddressAware" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.LineNumsStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.LocalSymsStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.NetRunFromSwap" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.RelocsStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.RemovableRunFromSwap" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.System" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.UpSystemOnly" />
    <member name="T:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData">
      <summary>Proporciona información sobre un archivo de base de datos de depuración de programa (PDB).</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData.Age">
      <summary>Iteración del PDB. La primera iteración es 1. La iteración se incrementa cada vez que aumenta el contenido de PDB.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData.Guid">
      <summary>Identificador único global (GUID) del PDB asociado.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData.Path">
      <summary>Ruta de acceso al archivo .pdb que contiene información de depuración del archivo PE/COFF.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.CoffHeader">
      <summary>Representa el encabezado de un archivo COFF.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.Characteristics">
      <summary>Obtiene las marcas que indican los atributos del archivo.</summary>
      <returns>Marcas que indican los atributos del archivo.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.Machine">
      <summary>Obtiene el tipo de la máquina de destino.</summary>
      <returns>Tipo del equipo de destino.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.NumberOfSections">
      <summary>Obtiene el número de secciones. Esto indica el tamaño de la tabla de la secciones, que sigue inmediatamente a los encabezados.</summary>
      <returns>Número de secciones.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.NumberOfSymbols">
      <summary>Obtiene el número de entradas de la tabla de símbolos. Estos datos se pueden usar para buscar la tabla de cadenas, que sigue inmediatamente a la tabla de símbolos. Este valor debe ser cero para una imagen PE.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.PointerToSymbolTable">
      <summary>Obtiene el puntero de archivo a la tabla de símbolos COFF.</summary>
      <returns>El puntero de archivo a la tabla de símbolos COFF o cero si no hay ninguna tabla de símbolos COFF. Este valor debe ser cero para una imagen PE.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.SizeOfOptionalHeader">
      <summary>Obtiene el tamaño del encabezado opcional, que es necesario para los archivos ejecutables pero no para los archivos objeto. Este valor debe ser cero para un archivo objeto.</summary>
      <returns>Tamaño del encabezado opcional.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.TimeDateStamp">
      <summary>Obtiene un valor que indica cuándo se creó el archivo.</summary>
      <returns>Los bits 32 bajos del número de segundos desde el 00:00 de enero de 1970, que indica cuándo se creó el archivo.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.CorFlags">
      <summary>COR20Flags</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.CorFlags.ILLibrary" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.ILOnly" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.NativeEntryPoint" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.Prefers32Bit" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.Requires32Bit" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.StrongNameSigned" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.TrackDebugData" />
    <member name="T:System.Reflection.PortableExecutable.CorHeader" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.CodeManagerTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.EntryPointTokenOrRelativeVirtualAddress" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.ExportAddressTableJumpsDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.Flags" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.MajorRuntimeVersion" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.ManagedNativeHeaderDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.MetadataDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.MinorRuntimeVersion" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.ResourcesDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.StrongNameSignatureDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.VtableFixupsDirectory" />
    <member name="T:System.Reflection.PortableExecutable.DebugDirectoryBuilder" />
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Reflection.PortableExecutable.DebugDirectoryBuilder" />.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddCodeViewEntry(System.String,System.Reflection.Metadata.BlobContentId,System.UInt16)">
      <summary>Agrega una entrada CodeView.</summary>
      <param name="pdbPath">La ruta de acceso al archivo PDB. No debe estar vacía.</param>
      <param name="pdbContentId">El identificador único del contenido del archivo PDB.</param>
      <param name="portablePdbVersion">La versión del formato PDB portable (por ejemplo, 0x0100 para 1.0), o bien 0 si el archivo PDB no es portable.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="pdbPath" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="pdbPath" /> contiene un carácter nulo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="portablePdbVersion" /> es menor que 0x0100.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddEmbeddedPortablePdbEntry(System.Reflection.Metadata.BlobBuilder,System.UInt16)">
      <summary>Agrega una entrada de archivo PDB portable insertada.</summary>
      <param name="debugMetadata">Un generador de metadatos PDB portátil.</param>
      <param name="portablePdbVersion">La versión del formato PDB portable (por ejemplo, 0x0100 para 1.0).</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="debugMetadata" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="portablePdbVersion" /> es menor que 0x0100.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddEntry(System.Reflection.PortableExecutable.DebugDirectoryEntryType,System.UInt32,System.UInt32)">
      <summary>Agrega una entrada del tipo especificado.</summary>
      <param name="type">El tipo de entrada.</param>
      <param name="version">La versión de la entrada.</param>
      <param name="stamp">La marca de la entrada.</param>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddEntry``1(System.Reflection.PortableExecutable.DebugDirectoryEntryType,System.UInt32,System.UInt32,``0,System.Action{System.Reflection.Metadata.BlobBuilder,``0})">
      <summary>Agrega una entrada del tipo especificado y serializa sus datos.</summary>
      <param name="type">El tipo de entrada.</param>
      <param name="version">La versión de la entrada.</param>
      <param name="stamp">La marca de la entrada.</param>
      <param name="data">Los datos que se van a pasar a <paramref name="dataSerializer" />.</param>
      <param name="dataSerializer">Un serializador para serializar los datos en una instancia de <see cref="T:System.Reflection.Metadata.BlobBuilder" />.</param>
      <typeparam name="TData">Tipo de los datos pasados a <paramref name="dataSerializer" /> .</typeparam>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddPdbChecksumEntry(System.String,System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>Agrega la entrada de suma de comprobación de PDB.</summary>
      <param name="algorithmName">El nombre del algoritmo hash (por ejemplo, "SHA256").</param>
      <param name="checksum">Suma de comprobación.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="algorithmName" /> o <paramref name="checksum" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="algorithmName" /> o <paramref name="checksum" /> está vacía.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddReproducibleEntry">
      <summary>Agrega una entrada reproducible.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.DebugDirectoryEntry">
      <summary>Identifica la ubicación, el tamaño y el formato de un bloque de información de depuración.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryEntry.#ctor(System.UInt32,System.UInt16,System.UInt16,System.Reflection.PortableExecutable.DebugDirectoryEntryType,System.Int32,System.Int32,System.Int32)">
      <summary>Inicializa una nueva instancia de la estructura <see cref="T:System.Reflection.PortableExecutable.DebugDirectoryEntry" />.</summary>
      <param name="stamp" />
      <param name="majorVersion" />
      <param name="minorVersion" />
      <param name="type" />
      <param name="dataSize" />
      <param name="dataRelativeVirtualAddress" />
      <param name="dataPointer" />
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.DataPointer">
      <summary>Obtiene el puntero de archivo a los datos de depuración.</summary>
      <returns>Puntero de archivo a los datos de depuración.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.DataRelativeVirtualAddress">
      <summary>Obtiene la dirección de los datos de depuración cuando se cargan, relativa a la base de la imagen.</summary>
      <returns>La dirección de los datos de depuración relativa a la base de la imagen.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.DataSize">
      <summary>Obtiene el tamaño de los datos de depuración (sin incluir el propio directorio de depuración).</summary>
      <returns>tamaño de los datos de depuración (sin incluir el directorio de depuración).</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.IsPortableCodeView">
      <summary>Obtiene un valor que indica si la entrada es una entrada <see cref="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView" /> que señala a un archivo PDB portable.</summary>
      <returns>
        <see langword="true" /> Si la entrada es una <see cref="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView" /> entrada que señala a un archivo PDB portable; de lo contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.MajorVersion">
      <summary>Obtiene el número de versión principal del formato de datos de depuración.</summary>
      <returns>Número de versión principal del formato de datos de depuración.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.MinorVersion">
      <summary>Obtiene el número de versión secundaria del formato de datos de depuración.</summary>
      <returns>Número de versión secundaria del formato de datos de depuración.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.Stamp">
      <summary>Obtiene la fecha y hora en que se crearon los datos de depuración si el archivo PE/COFF no es determinista; de lo contrario, obtiene un valor basado en el hash del contenido.</summary>
      <returns>para un archivo PE/COFF no determinista, la fecha y la hora en que se crearon los datos de depuración; de lo contrario, un valor basado en el hash del contenido.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.Type">
      <summary>Obtiene el formato de la información de depuración.</summary>
      <returns>Formato de la información de depuración.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.DebugDirectoryEntryType">
      <summary>Una enumeración que describe el formato de la información de depuración de <see cref="T:System.Reflection.PortableExecutable.DebugDirectoryEntry" />.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView">
      <summary>Descripción del archivo PDB asociado.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Coff">
      <summary>La información de depuración de COFF (números de línea, tabla de símbolos y tabla de cadenas). Los campos de los encabezados de archivo también señalan a este tipo de información de depuración.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.EmbeddedPortablePdb">
      <summary>
        <para>La entrada apunta a un blob que contiene un archivo PDB portable insertado. El blob del archivo PDB portable insertado tiene el formato siguiente:</para>
        <para>- blob ::= uncompressed-size data</para>
        <para>- Los datos abarcan el resto del blob y contienen un archivo PDB portable comprimido con Deflate.</para>
      </summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.PdbChecksum">
      <summary>La entrada almacena un hash de cifrado del contenido del archivo de símbolos con el que se ha compilado el archivo PE/COFF. El hash se puede usar para validar que un archivo PDB determinado se ha compilado con el archivo PE/COFF y no se ha modificado de ningún modo. Puede haber más de una entrada si se han generado varios archivos PDB durante la compilación del archivo PE/COFF (por ejemplo, símbolos privados y públicos).</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Reproducible">
      <summary>La presencia de esta entrada indica un archivo PE/COFF determinista. Vea la sección Comentarios para obtener más información.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Unknown">
      <summary>Un valor desconocido que deben omitir todas las herramientas.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.DirectoryEntry" />
    <member name="F:System.Reflection.PortableExecutable.DirectoryEntry.RelativeVirtualAddress" />
    <member name="F:System.Reflection.PortableExecutable.DirectoryEntry.Size" />
    <member name="M:System.Reflection.PortableExecutable.DirectoryEntry.#ctor(System.Int32,System.Int32)">
      <param name="relativeVirtualAddress" />
      <param name="size" />
    </member>
    <member name="T:System.Reflection.PortableExecutable.DllCharacteristics">
      <summary>Describe las características de una biblioteca de vínculos dinámicos.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.AppContainer">
      <summary>La imagen se debe ejecutar dentro de un objeto AppContainer.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.DynamicBase">
      <summary>El archivo DLL se puede reubicar.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.HighEntropyVirtualAddressSpace">
      <summary>La imagen puede controlar un espacio de direcciones virtuales de alta entropía de 64 bits.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NoBind">
      <summary>No enlace esta imagen.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NoIsolation">
      <summary>La imagen entiende el aislamiento y lo rechaza.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NoSeh">
      <summary>La imagen no usa SEH. Esta imagen no puede contener ningún controlador SE.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NxCompatible">
      <summary>La imagen es compatible con NX.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ProcessInit">
      <summary>Reservado.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ProcessTerm">
      <summary>Reservado.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.TerminalServerAware">
      <summary>La imagen es compatible con Terminal Server.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ThreadInit">
      <summary>Reservado.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ThreadTerm">
      <summary>Reservado.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.WdmDriver">
      <summary>El controlador usa el modelo WDM.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.Machine">
      <summary>Especifica la arquitectura de CPU de la máquina de destino.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Alpha">
      <summary>Alpha.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Alpha64">
      <summary>ALPHA64.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.AM33">
      <summary>Matsushita AM33.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Amd64">
      <summary>AMD64 (K8).</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Arm">
      <summary>ARM little endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Arm64">
      <summary>ARM64.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.ArmThumb2">
      <summary>ARM Thumb-2 little endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Ebc">
      <summary>EFI Byte Code.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.I386">
      <summary>Intel 386.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.IA64">
      <summary>Intel 64.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.M32R">
      <summary>M32R little-endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.MIPS16">
      <summary>MIPS.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.MipsFpu">
      <summary>MIPS con FPU.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.MipsFpu16">
      <summary>MIPS16 con FPU.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.PowerPC">
      <summary>IBM PowerPC little endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.PowerPCFP">
      <summary>PowerPCFP.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH3">
      <summary>Hitachi SH3 little endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH3Dsp">
      <summary>Hitachi SH3 DSP.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH3E">
      <summary>Hitachi SH3 little endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH4">
      <summary>Hitachi SH4 little endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH5">
      <summary>Hitachi SH5.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Thumb">
      <summary>Thumb.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Tricore">
      <summary>Infineon.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Unknown">
      <summary>La CPU de destino es desconocida o no se ha especificado.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.WceMipsV2">
      <summary>MIPS little-endian WCE v2.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.ManagedPEBuilder" />
    <member name="F:System.Reflection.PortableExecutable.ManagedPEBuilder.ManagedResourcesDataAlignment" />
    <member name="F:System.Reflection.PortableExecutable.ManagedPEBuilder.MappedFieldDataAlignment" />
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.#ctor(System.Reflection.PortableExecutable.PEHeaderBuilder,System.Reflection.Metadata.Ecma335.MetadataRootBuilder,System.Reflection.Metadata.BlobBuilder,System.Reflection.Metadata.BlobBuilder,System.Reflection.Metadata.BlobBuilder,System.Reflection.PortableExecutable.ResourceSectionBuilder,System.Reflection.PortableExecutable.DebugDirectoryBuilder,System.Int32,System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.PortableExecutable.CorFlags,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Reflection.Metadata.BlobContentId})">
      <param name="header" />
      <param name="metadataRootBuilder" />
      <param name="ilStream" />
      <param name="mappedFieldData" />
      <param name="managedResources" />
      <param name="nativeResources" />
      <param name="debugDirectoryBuilder" />
      <param name="strongNameSignatureSize" />
      <param name="entryPoint" />
      <param name="flags" />
      <param name="deterministicIdProvider" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.CreateSections" />
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.GetDirectories" />
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.SerializeSection(System.String,System.Reflection.PortableExecutable.SectionLocation)">
      <param name="name" />
      <param name="location" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.Sign(System.Reflection.Metadata.BlobBuilder,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Byte[]})">
      <param name="peImage" />
      <param name="signatureProvider" />
    </member>
    <member name="T:System.Reflection.PortableExecutable.PdbChecksumDebugDirectoryData">
      <summary>Representa una entrada del directorio de depuración de suma de comprobación de PDB.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PdbChecksumDebugDirectoryData.AlgorithmName">
      <summary>Nombre del algoritmo hash criptográfico usado para calcular la suma de comprobación.</summary>
      <returns>Cadena que representa el nombre del algoritmo hash criptográfico utilizado para calcular la suma de comprobación.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PdbChecksumDebugDirectoryData.Checksum">
      <summary>La suma de comprobación del contenido de PDB.</summary>
      <returns>Matriz inmutable de bytes que representa la suma de comprobación del contenido de PDB.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEBuilder" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.#ctor(System.Reflection.PortableExecutable.PEHeaderBuilder,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Reflection.Metadata.BlobContentId})">
      <param name="header" />
      <param name="deterministicIdProvider" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.CreateSections" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.GetDirectories" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.GetSections" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.Serialize(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.SerializeSection(System.String,System.Reflection.PortableExecutable.SectionLocation)">
      <param name="name" />
      <param name="location" />
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEBuilder.Header" />
    <member name="P:System.Reflection.PortableExecutable.PEBuilder.IdProvider" />
    <member name="P:System.Reflection.PortableExecutable.PEBuilder.IsDeterministic" />
    <member name="T:System.Reflection.PortableExecutable.PEBuilder.Section" />
    <member name="F:System.Reflection.PortableExecutable.PEBuilder.Section.Characteristics" />
    <member name="F:System.Reflection.PortableExecutable.PEBuilder.Section.Name" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.Section.#ctor(System.String,System.Reflection.PortableExecutable.SectionCharacteristics)">
      <param name="name" />
      <param name="characteristics" />
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEDirectoriesBuilder">
      <summary>Crea directorios de PE.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEDirectoriesBuilder.#ctor">
      <summary>Inicializa una instancia de la clase <see cref="T:System.Reflection.PortableExecutable.PEDirectoriesBuilder" />.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.AddressOfEntryPoint">
      <summary>La dirección del punto de entrada relativa a la base de la imagen cuando el archivo PE se carga en la memoria.</summary>
      <returns>En el caso de las imágenes de programa, esta es la dirección de inicio. En el caso de los controladores de dispositivos, se trata de la dirección de la función de inicialización. Un punto de entrada es opcional para los archivos dll. Cuando no hay ningún punto de entrada presente, este campo debe ser cero.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.BaseRelocationTable">
      <summary>La entrada de directorio de la imagen de tabla de reubicación base.</summary>
      <returns>Instancia de entrada de directorio.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.BoundImportTable">
      <summary>La entrada de directorio de la imagen de importación enlazada.</summary>
      <returns>Instancia de entrada de directorio.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.CopyrightTable">
      <summary>La entrada de directorio de la imagen de copyright o arquitectura.</summary>
      <returns>Instancia de entrada de directorio.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.CorHeaderTable">
      <summary>La entrada de directorio de la imagen de tabla de descriptores de COM.</summary>
      <returns>Instancia de entrada de directorio.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.DebugTable">
      <summary>La entrada de directorio de la imagen de tabla de depuración.</summary>
      <returns>Instancia de entrada de directorio.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.DelayImportTable">
      <summary>La entrada de directorio de la imagen de tabla de importación de retardo.</summary>
      <returns>Instancia de entrada de directorio.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ExceptionTable">
      <summary>La entrada de directorio de la imagen de tabla de excepción.</summary>
      <returns>Instancia de entrada de directorio.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ExportTable">
      <summary>La entrada de directorio de la imagen de tabla de exportación.</summary>
      <returns>Instancia de entrada de directorio.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.GlobalPointerTable">
      <summary>La entrada de directorio de la imagen de tabla de punteros globales.</summary>
      <returns>Instancia de entrada de directorio.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ImportAddressTable">
      <summary>La entrada de directorio de la imagen de la tabla de direcciones de importación (IAT).</summary>
      <returns>Instancia de entrada de directorio.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ImportTable">
      <summary>La entrada de directorio de la imagen de tabla de importación.</summary>
      <returns>Instancia de entrada de directorio.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.LoadConfigTable">
      <summary>La entrada de directorio de la imagen de tabla de configuración de carga.</summary>
      <returns>Instancia de entrada de directorio.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ResourceTable">
      <summary>La entrada de directorio de la imagen de tabla de recursos.</summary>
      <returns>Instancia de entrada de directorio.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ThreadLocalStorageTable">
      <summary>La entrada de directorio de la imagen de la tabla de almacenamiento local de subprocesos (TLS).</summary>
      <returns>Instancia de entrada de directorio.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEHeader" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.AddressOfEntryPoint">
      <summary>Obtiene la dirección del punto de entrada relativa a la base de la imagen cuando el archivo PE se carga en la memoria.</summary>
      <returns>Dirección del punto de entrada relativa a la base de la imagen.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BaseOfCode">
      <summary>Obtiene la dirección de la sección de principio de código relativa a la base de la imagen cuando la imagen se carga en la memoria.</summary>
      <returns>Dirección de la sección de principio de código relativa a la base de la imagen.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BaseOfData">
      <summary>Obtiene la dirección de la sección de inicio de datos relativa a la base de la imagen cuando la imagen se carga en la memoria.</summary>
      <returns>Dirección de la sección de inicio de datos relativa a la base de la imagen.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BaseRelocationTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BoundImportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CertificateTableDirectory">
      <summary>Obtiene la entrada de la tabla de certificados, que apunta a una tabla de certificados de atributos.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CheckSum">
      <summary>Obtiene la suma de comprobación del archivo de imagen.</summary>
      <returns>Suma de comprobación del archivo de imagen.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CopyrightTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CorHeaderTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.DebugTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.DelayImportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.DllCharacteristics" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ExceptionTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ExportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.FileAlignment">
      <summary>Obtiene el factor de alineación (en bytes) que se usa para alinear los datos sin procesar de las secciones del archivo de imagen.</summary>
      <returns>Una potencia de 2 entre 512 y 64K, ambos incluidos. El valor predeterminado es 512.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.GlobalPointerTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ImageBase">
      <summary>Obtiene la dirección preferida del primer byte de la imagen cuando se carga en la memoria.</summary>
      <returns>La dirección preferida, que es un múltiplo de 64 KB.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ImportAddressTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ImportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.LoadConfigTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.Magic">
      <summary>Obtiene un valor que identifica el formato del archivo de imagen.</summary>
      <returns>Formato del archivo de imagen.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorImageVersion">
      <summary>Obtiene el número de versión principal de la imagen.</summary>
      <returns>El número de versión principal de la imagen.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorLinkerVersion">
      <summary>Obtiene el número de versión principal del enlazador.</summary>
      <returns>El número de versión principal del enlazador.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorOperatingSystemVersion">
      <summary>Obtiene el número de versión principal del sistema operativo obligatorio.</summary>
      <returns>El número de versión principal del sistema operativo obligatorio.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorSubsystemVersion">
      <summary>Obtiene el número de versión principal del subsistema.</summary>
      <returns>El número de versión principal del subsistema.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorImageVersion">
      <summary>Obtiene el número de versión secundaria de la imagen.</summary>
      <returns>El número de versión secundaria de la imagen.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorLinkerVersion">
      <summary>Obtiene el número de versión secundaria del enlazador.</summary>
      <returns>El número de versión secundaria del enlazador.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorOperatingSystemVersion">
      <summary>Obtiene el número de versión secundaria del sistema operativo obligatorio.</summary>
      <returns>El número de versión secundaria del sistema operativo obligatorio.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorSubsystemVersion">
      <summary>Obtiene el número de versión secundaria del subsistema.</summary>
      <returns>El número de versión secundaria del subsistema.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.NumberOfRvaAndSizes">
      <summary>Obtiene el número de entradas del directorio de datos en el resto de <see cref="T:System.Reflection.PortableExecutable.PEHeader" />. Cada una describe una ubicación y un tamaño.</summary>
      <returns>El número de entradas del directorio de datos en el resto de <see cref="T:System.Reflection.PortableExecutable.PEHeader" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ResourceTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SectionAlignment">
      <summary>Obtiene la alineación (en bytes) de las secciones cuando se cargan en la memoria.</summary>
      <returns>Número mayor o igual que <see cref="P:System.Reflection.PortableExecutable.PEHeader.FileAlignment" /> . El valor predeterminado es el tamaño de página de la arquitectura.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfCode">
      <summary>Obtiene el tamaño de la sección de código (texto), o bien la suma de todas las secciones de código si hay varias secciones.</summary>
      <returns>tamaño de la sección de código (texto) o la suma de todas las secciones de código si hay varias secciones.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeaders">
      <summary>Obtiene el tamaño combinado de un código auxiliar de MS DOS, un encabezado PE y encabezados de sección redondeados a un múltiplo de FileAlignment.</summary>
      <returns>El tamaño combinado de un código auxiliar de MS DOS, un encabezado PE y encabezados de sección se redondea a un múltiplo de FileAlignment.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapCommit">
      <summary>Obtiene el tamaño del espacio de montón local que se va a confirmar.</summary>
      <returns>tamaño del espacio de montón local que se va a confirmar.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapReserve">
      <summary>Obtiene el tamaño del espacio de montón local que se va a reservar. Solo se confirma <see cref="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapCommit" />; el resto se pone a disposición una página a la vez hasta que se alcanza el tamaño de reserva.</summary>
      <returns>El tamaño del espacio de montón local que se va a reservar.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfImage">
      <summary>Obtiene el tamaño (en bytes) de la imagen, incluidos todos los encabezados, a medida que la imagen se carga en la memoria.</summary>
      <returns>Tamaño (en bytes) de la imagen, que es un múltiplo de <see cref="P:System.Reflection.PortableExecutable.PEHeader.SectionAlignment" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfInitializedData">
      <summary>Obtiene el tamaño de la sección de datos inicializados, o bien la suma de todas esas secciones si hay varias secciones de datos.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackCommit">
      <summary>Obtiene el tamaño de la pila que se va a confirmar.</summary>
      <returns>El tamaño de la pila que se va a confirmar.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackReserve">
      <summary>Obtiene el tamaño de la pila que se va a reservar. Solo se confirma <see cref="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackCommit" />; el resto se pone a disposición una página a la vez hasta que se alcanza el tamaño de reserva.</summary>
      <returns>El tamaño de la pila que se va a reservar.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfUninitializedData">
      <summary>Obtiene el tamaño de la sección de datos no inicializados (BSS), o bien la suma de todas esas secciones si hay varias secciones BSS.</summary>
      <returns>El tamaño de la sección de datos no inicializados (BSS) o la suma de todas estas secciones.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.Subsystem">
      <summary>Obtiene el nombre del subsistema necesario para ejecutar esta imagen.</summary>
      <returns>nombre del subsistema necesario para ejecutar esta imagen.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ThreadLocalStorageTableDirectory" />
    <member name="T:System.Reflection.PortableExecutable.PEHeaderBuilder">
      <summary>Define el encabezado de un archivo portable ejecutable (PE).</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaderBuilder.#ctor(System.Reflection.PortableExecutable.Machine,System.Int32,System.Int32,System.UInt64,System.Byte,System.Byte,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.Reflection.PortableExecutable.Subsystem,System.Reflection.PortableExecutable.DllCharacteristics,System.Reflection.PortableExecutable.Characteristics,System.UInt64,System.UInt64,System.UInt64,System.UInt64)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Reflection.PortableExecutable.PEHeader" />.</summary>
      <param name="machine">La arquitectura de CPU del equipo de destino.</param>
      <param name="sectionAlignment">La alineación (en bytes) de las secciones cuando se cargan en la memoria. Debe ser mayor o igual que <paramref name="fileAlignment" />. El valor predeterminado es el tamaño de página de la arquitectura.</param>
      <param name="fileAlignment">El factor de alineación (en bytes) que se usa para alinear los datos sin procesar de las secciones del archivo de imagen. El valor debe ser una potencia de 2 entre 512 y 64K, inclusive. El valor predeterminado es 512. Si <paramref name="sectionAlignment" /> es menor que el tamaño de página de la arquitectura, <paramref name="fileAlignment" /> debe coincidir con <paramref name="sectionAlignment" />.</param>
      <param name="imageBase">La dirección preferida del primer byte de la imagen cuando se carga en la memoria; debe ser un múltiplo de 64K.</param>
      <param name="majorLinkerVersion">El número de versión principal del enlazador.</param>
      <param name="minorLinkerVersion">El número de versión secundaria del enlazador.</param>
      <param name="majorOperatingSystemVersion">El número de versión principal del sistema operativo obligatorio.</param>
      <param name="minorOperatingSystemVersion">El número de versión secundaria del sistema operativo obligatorio.</param>
      <param name="majorImageVersion">El número de versión principal de la imagen.</param>
      <param name="minorImageVersion">El número de versión secundaria de la imagen.</param>
      <param name="majorSubsystemVersion">El número de versión principal del subsistema.</param>
      <param name="minorSubsystemVersion">El número de versión secundaria del subsistema.</param>
      <param name="subsystem">El subsistema necesario para ejecutar la imagen.</param>
      <param name="dllCharacteristics">Un objeto que describe las características de la biblioteca de vínculos dinámicos.</param>
      <param name="imageCharacteristics">Un objeto que describe las características de la imagen.</param>
      <param name="sizeOfStackReserve">El tamaño de la pila que se va a reservar. Solo se confirma <paramref name="sizeOfStackCommit" />; el resto se pone a disposición una página a la vez hasta que se alcanza el tamaño de reserva.</param>
      <param name="sizeOfStackCommit">El tamaño de la pila que se va a confirmar.</param>
      <param name="sizeOfHeapReserve">El tamaño del espacio de montón local que se va a reservar. Solo se confirma <paramref name="sizeOfHeapCommit" />; el resto se pone a disposición una página a la vez hasta que se alcanza el tamaño de reserva.</param>
      <param name="sizeOfHeapCommit">El tamaño del espacio de montón local que se va a confirmar.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="fileAlignment" /> no es una potencia de 2 comprendida entre 512 y 64K.
o bien

<paramref name="sectionAlignment" /> no es una potencia de 2.

o bien

<paramref name="sectionAlignment" /> es menor que <paramref name="fileAlignment" />.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaderBuilder.CreateExecutableHeader">
      <summary>Crea un encabezado ejecutable.</summary>
      <returns>Una instancia de <see cref="T:System.Reflection.PortableExecutable.PEHeaderBuilder" /> que representa el encabezado ejecutable.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaderBuilder.CreateLibraryHeader">
      <summary>Crea un encabezado de biblioteca.</summary>
      <returns>Una instancia de <see cref="T:System.Reflection.PortableExecutable.PEHeaderBuilder" /> que representa el encabezado de biblioteca.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.DllCharacteristics">
      <summary>Devuelve las características de la biblioteca del enlazador dinámico.</summary>
      <returns>Objeto que describe las características de la biblioteca del vinculador dinámico.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.FileAlignment">
      <summary>El factor de alineación (en bytes) que se usa para alinear los datos sin procesar de las secciones del archivo de imagen. El valor debe ser una potencia de 2 entre 512 y 64K, inclusive. El valor predeterminado es 512. Si la alineación de la sección es menor que el tamaño de página de la arquitectura, la alineación de archivo debe coincidir con la de la sección.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.ImageBase">
      <summary>La dirección preferida del primer byte de la imagen cuando se carga en la memoria; debe ser un múltiplo de 64K.</summary>
      <returns>Número que representa la dirección preferida del primer byte de la imagen cuando se carga en la memoria.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.ImageCharacteristics">
      <summary>Devuelve las características de la imagen.</summary>
      <returns>Objeto que representa las características de la imagen.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.Machine">
      <summary>La arquitectura de CPU del equipo de destino.</summary>
      <returns>Uno de los valores de enumeración que representa las distintas arquitecturas de CPU.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorImageVersion">
      <summary>El número de versión principal de la imagen.</summary>
      <returns>Número del tamaño de un objeto <see cref="T:System.UInt16" /> que representa el número de versión principal de la imagen.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorLinkerVersion">
      <summary>El número de versión principal del enlazador.</summary>
      <returns>Número del tamaño de un objeto <see cref="T:System.Byte" /> que representa el número de versión principal del enlazador.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorOperatingSystemVersion">
      <summary>El número de versión principal del sistema operativo obligatorio.</summary>
      <returns>Número del tamaño de un objeto <see cref="T:System.UInt16" /> que representa el número de versión principal del sistema operativo requerido.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorSubsystemVersion">
      <summary>El número de versión principal del subsistema.</summary>
      <returns>Número del tamaño de un objeto <see cref="T:System.UInt16" /> que representa el número de versión principal del subsistema.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorImageVersion">
      <summary>El número de versión secundaria de la imagen.</summary>
      <returns>Número del tamaño de un objeto <see cref="T:System.UInt16" /> que representa el número de versión secundaria de la imagen.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorLinkerVersion">
      <summary>El número de versión secundaria del enlazador.</summary>
      <returns>Número del tamaño de un objeto <see cref="T:System.Byte" /> que representa el número de versión secundaria del enlazador.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorOperatingSystemVersion">
      <summary>El número de versión secundaria del sistema operativo obligatorio.</summary>
      <returns>Número del tamaño de un valor de tipo <see cref="T:System.UInt16" /> que representa el número de versión secundaria del sistema operativo requerido.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorSubsystemVersion">
      <summary>El número de versión secundaria del subsistema.</summary>
      <returns>Número del tamaño de un objeto <see cref="T:System.UInt16" /> que representa el número de versión secundaria del subsistema.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SectionAlignment">
      <summary>La alineación (en bytes) de las secciones cuando se cargan en la memoria.</summary>
      <returns>Número que representa la alineación (en bytes) de las secciones cuando se cargan en la memoria. Debe ser mayor o igual que la alineación del archivo. El valor predeterminado es el tamaño de página de la arquitectura.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfHeapCommit">
      <summary>El tamaño del espacio de montón local que se va a confirmar.</summary>
      <returns>Número que representa el tamaño del espacio de montón local que se va a confirmar.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfHeapReserve">
      <summary>El tamaño del espacio de montón local que se va a reservar. Solo se confirma <see cref="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfHeapCommit" />; el resto se pone a disposición una página a la vez hasta que se alcanza el tamaño de reserva.</summary>
      <returns>Número que representa el tamaño del espacio de montón local que se va a reservar.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfStackCommit">
      <summary>El tamaño de la pila que se va a confirmar.</summary>
      <returns>Número que representa el tamaño de la pila que se va a confirmar.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfStackReserve">
      <summary>El tamaño de la pila que se va a reservar. Solo se confirma <see cref="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfStackCommit" />; el resto se pone a disposición una página a la vez hasta que se alcanza el tamaño de reserva.</summary>
      <returns>Número que representa el tamaño de la pila que se va a reservar.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.Subsystem">
      <summary>El subsistema necesario para ejecutar esta imagen.</summary>
      <returns>Instancia de <see cref="T:System.Reflection.PortableExecutable.Subsystem" />.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEHeaders">
      <summary>Define un tipo que lee los encabezados PE (portable ejecutable) y COFF (formato de archivo de objeto común) de una secuencia.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream)">
      <summary>Crea una instancia de la clase <see cref="T:System.Reflection.PortableExecutable.PEHeaders" /> que lee los encabezados PE de la ubicación actual en la secuencia especificada.</summary>
      <param name="peStream">Una secuencia que contiene la imagen de PE que comienza en la posición actual de la secuencia y termina al final de ella.</param>
      <exception cref="T:System.BadImageFormatException">Los datos leídos del flujo tienen un formato no válido.</exception>
      <exception cref="T:System.IO.IOException">Error al leer de la secuencia.</exception>
      <exception cref="T:System.ArgumentException">La secuencia no admite operaciones de búsqueda.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peStream" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream,System.Int32)">
      <summary>Crea una instancia de la clase <see cref="T:System.Reflection.PortableExecutable.PEHeaders" /> que lee los encabezados PE desde una secuencia que representa una imagen de PE de un tamaño especificado.</summary>
      <param name="peStream">Una secuencia que contiene la imagen PE del tamaño especificado a partir de su posición actual.</param>
      <param name="size">El tamaño de la imagen de PE.</param>
      <exception cref="T:System.BadImageFormatException">Los datos leídos del flujo tienen un formato no válido.</exception>
      <exception cref="T:System.IO.IOException">Error al leer de la secuencia.</exception>
      <exception cref="T:System.ArgumentException">La secuencia no admite operaciones de búsqueda.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peStream" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> es negativo o se extiende más allá del final de la secuencia.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream,System.Int32,System.Boolean)">
      <summary>Crea una instancia de la clase <see cref="T:System.Reflection.PortableExecutable.PEHeaders" /> que lee los encabezados PE desde una secuencia que representa una imagen de PE de un tamaño especificado e indica si la imagen de PE se ha cargado en memoria.</summary>
      <param name="peStream">La secuencia que contiene la imagen PE del tamaño especificado a partir de su posición actual.</param>
      <param name="size">El tamaño de la imagen de PE.</param>
      <param name="isLoadedImage">
        <see langword="true" /> si el cargador del sistema operativo ha cargado en la memoria la imagen de PE subyacente; en caso contrario, <see langword="false" />.</param>
      <exception cref="T:System.BadImageFormatException">Los datos leídos de la secuencia tienen un formato no válido.</exception>
      <exception cref="T:System.IO.IOException">Error al leer de la secuencia.</exception>
      <exception cref="T:System.ArgumentException">La secuencia no admite operaciones de búsqueda.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peStream" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> es negativo o se extiende más allá del final de la secuencia.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.GetContainingSectionIndex(System.Int32)">
      <summary>Busca en las secciones de la imagen de PE la sección que contiene la dirección virtual relativa especificada.</summary>
      <param name="relativeVirtualAddress">La dirección relativa virtual que se va a buscar.</param>
      <returns>El índice de la sección que contiene <paramref name="relativeVirtualAddress" />, o bien -1 si la búsqueda no se realiza correctamente.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.TryGetDirectoryOffset(System.Reflection.PortableExecutable.DirectoryEntry,System.Int32@)">
      <summary>Obtiene el desplazamiento (en bytes) desde el inicio de la imagen hasta los datos de directorio proporcionados.</summary>
      <param name="directory">La entrada de directorio de PE.</param>
      <param name="offset">Cuando el método vuelve, contiene el desplazamiento desde el inicio de la imagen a los datos de directorio proporcionados.</param>
      <returns>
        <see langword="true" /> si se encuentran los datos de directorio; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CoffHeader">
      <summary>Obtiene el encabezado COFF de la imagen.</summary>
      <returns>El encabezado COFF de la imagen.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CoffHeaderStartOffset">
      <summary>Obtiene el desplazamiento de bytes desde el inicio de la imagen de PE hasta el inicio del encabezado COFF.</summary>
      <returns>El desplazamiento de bytes desde el inicio de la imagen de PE hasta el inicio del encabezado COFF.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CorHeader">
      <summary>Obtiene el encabezado COR.</summary>
      <returns>El encabezado COR o <see langword="null" /> si la imagen no tiene uno.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CorHeaderStartOffset">
      <summary>Obtiene el desplazamiento de bytes desde el inicio de la imagen hasta el encabezado COR.</summary>
      <returns>El desplazamiento de bytes desde el inicio de la imagen hasta el encabezado COR o-1 si la imagen no tiene un encabezado COR.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsCoffOnly">
      <summary>Obtiene un valor que indica si la imagen es solo COFF.</summary>
      <returns>
        <see langword="true" /> Si la imagen es solo COFF; en caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsConsoleApplication">
      <summary>Obtiene un valor que indica si la imagen representa una aplicación de consola de Windows.</summary>
      <returns>
        <see langword="true" /> Si la imagen es una aplicación de consola de Windows; en caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsDll">
      <summary>Obtiene un valor que indica si la imagen representa una biblioteca de vínculos dinámicos.</summary>
      <returns>
        <see langword="true" /> Si la imagen es un archivo DLL; en caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsExe">
      <summary>Obtiene un valor que indica si la imagen representa un archivo ejecutable.</summary>
      <returns>
        <see langword="true" /> Si la imagen es un archivo ejecutable; en caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.MetadataSize">
      <summary>Obtiene el tamaño de los metadatos de la CLI.</summary>
      <returns>el tamaño de los metadatos de la CLI, o 0 si la imagen no contiene metadatos.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.MetadataStartOffset">
      <summary>Obtiene el desplazamiento (en bytes) desde el inicio de la imagen de PE hasta el inicio de los metadatos de la CLI.</summary>
      <returns>Desplazamiento (en bytes) desde el inicio de la imagen de PE hasta el inicio de los metadatos de la CLI, o-1 si la imagen no contiene metadatos.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.PEHeader">
      <summary>Obtiene el encabezado PE de la imagen.</summary>
      <returns>El encabezado PE de la imagen o <see langword="null" /> si la imagen es solo COFF.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.PEHeaderStartOffset">
      <summary>Obtiene el desplazamiento de bytes del encabezado desde el inicio de la imagen.</summary>
      <returns>Desplazamiento de bytes del encabezado desde el inicio de la imagen.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.SectionHeaders">
      <summary>Obtiene los encabezados de la sección de PE.</summary>
      <returns>Una matriz que contiene los encabezados de la sección de PE.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEMagic" />
    <member name="F:System.Reflection.PortableExecutable.PEMagic.PE32" />
    <member name="F:System.Reflection.PortableExecutable.PEMagic.PE32Plus" />
    <member name="T:System.Reflection.PortableExecutable.PEMemoryBlock" />
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetContent">
      <summary>Lee el contenido del bloque completo en una matriz.</summary>
      <returns>Una matriz de bytes inmutable.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetContent(System.Int32,System.Int32)">
      <summary>Lee el contenido de una parte del bloque en una matriz.</summary>
      <param name="start">La posición inicial en el bloque.</param>
      <param name="length">Número de bytes que se va a leer.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">El intervalo especificado no se incluye en el bloque.</exception>
      <returns>Una matriz inmutable de bytes.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetReader">
      <summary>Crea una instancia de <see cref="T:System.Reflection.Metadata.BlobReader" /> para un blob que abarca todo el bloque.</summary>
      <returns>Un lector para un blob que abarca todo el bloque.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetReader(System.Int32,System.Int32)">
      <summary>Crea una instancia de <see cref="T:System.Reflection.Metadata.BlobReader" /> para un blob que abarca una parte del bloque.</summary>
      <param name="start">La posición inicial en el bloque.</param>
      <param name="length">El número de bytes en la parte del bloque.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">El intervalo especificado no se incluye en el bloque.</exception>
      <returns>Un lector para un blob que abarca una parte del bloque.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEMemoryBlock.Length">
      <summary>Obtiene la longitud del bloque.</summary>
      <returns>Longitud del bloque.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEMemoryBlock.Pointer">
      <summary>Obtiene un puntero al primer byte del bloque.</summary>
      <returns>Puntero al primer byte del bloque.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEReader">
      <summary>Proporciona un lector para los archivos de formato portable ejecutable (PE).</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.Byte*,System.Int32)">
      <summary>Crea un lector portable ejecutable sobre una imagen de PE almacenada en memoria.</summary>
      <param name="peImage">Un puntero al inicio de la imagen de PE.</param>
      <param name="size">El tamaño de la imagen de PE.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peImage" /> es <see cref="F:System.IntPtr.Zero" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> es negativo.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.Byte*,System.Int32,System.Boolean)">
      <summary>Crea un lector portable ejecutable sobre una imagen de PE almacenada en memoria. Una marca indica si la imagen ya se ha cargado en la memoria.</summary>
      <param name="peImage">Un puntero al inicio de la imagen de PE.</param>
      <param name="size">El tamaño de la imagen de PE.</param>
      <param name="isLoadedImage">
        <see langword="true" /> si el cargador del sistema operativo ha cargado en la memoria la imagen de PE subyacente; en caso contrario, <see langword="false" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peImage" /> es <see cref="F:System.IntPtr.Zero" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> es negativo.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>Crea un lector portable ejecutable en una imagen de PE almacenada en una matriz de bytes.</summary>
      <param name="peImage">Una matriz inmutable de bytes que representa la imagen de PE.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peImage" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream)">
      <summary>Crea un lector portable ejecutable sobre una imagen de PE almacenada en una secuencia.</summary>
      <param name="peStream">Secuencia de la imagen de PE.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peStream" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream,System.Reflection.PortableExecutable.PEStreamOptions)">
      <summary>Crea un lector portable ejecutable sobre una imagen de PE almacenada en una secuencia que comienza en su posición actual y termina al final de la secuencia.</summary>
      <param name="peStream">Una secuencia de la imagen de PE.</param>
      <param name="options">Opciones que especifican cómo se leen las secciones de la imagen de PE de la secuencia.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peStream" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="options" /> tiene un valor no válido.</exception>
      <exception cref="T:System.IO.IOException">Error al leer de la secuencia (solo cuando se realiza la captura previa de los datos).</exception>
      <exception cref="T:System.BadImageFormatException">
        <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata" /> se especifica y los encabezados de PE de la imagen no son válidos.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream,System.Reflection.PortableExecutable.PEStreamOptions,System.Int32)">
      <summary>Crea un lector portable ejecutable sobre una imagen de PE del tamaño especificado que comienza en la posición actual de la secuencia.</summary>
      <param name="peStream">Una secuencia de la imagen de PE.</param>
      <param name="options">Opciones que especifican cómo se leen las secciones de la imagen de PE de la secuencia.</param>
      <param name="size">El tamaño de la imagen de PE.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> es negativo o se extiende más allá del final de la secuencia.</exception>
      <exception cref="T:System.IO.IOException">Error al leer de la secuencia (solo cuando se realiza la captura previa de los datos).</exception>
      <exception cref="T:System.BadImageFormatException">
        <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata" /> se especifica y los encabezados de PE de la imagen no son válidos.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.Dispose">
      <summary>Elimina toda la memoria asignada por el lector.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetEntireImage">
      <summary>Obtiene un objeto <see cref="T:System.Reflection.PortableExecutable.PEMemoryBlock" /> que contiene la imagen de PE completa.</summary>
      <exception cref="T:System.InvalidOperationException">La imagen de PE completa no está disponible.</exception>
      <returns>Un bloque de memoria que contiene la imagen de PE completa.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetMetadata">
      <summary>Carga una sección de PE que contiene los metadatos de la CLI.</summary>
      <exception cref="T:System.InvalidOperationException">La imagen de PE no contiene metadatos (<see cref="P:System.Reflection.PortableExecutable.PEReader.HasMetadata" /> devuelve <see langword="false" />).</exception>
      <exception cref="T:System.BadImageFormatException">Los encabezados de PE contienen datos no válidos.</exception>
      <exception cref="T:System.IO.IOException">Error de E/S al leer la secuencia subyacente.</exception>
      <returns>Un bloque de memoria que contiene los metadatos de la CLI.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetSectionData(System.Int32)">
      <summary>Carga en la memoria la sección de PE que contiene la dirección virtual relativa especificada y devuelve un bloque de memoria que comienza en esa dirección y termina al final de la sección contenedora.</summary>
      <param name="relativeVirtualAddress">La dirección virtual relativa de los datos que se van a leer.</param>
      <exception cref="T:System.BadImageFormatException">Los encabezados de PE contienen datos no válidos.</exception>
      <exception cref="T:System.IO.IOException">Se ha producido un error de E/S al leer desde la secuencia subyacente.</exception>
      <exception cref="T:System.InvalidOperationException">La imagen de PE no está disponible.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="relativeVirtualAddress" /> es negativo.</exception>
      <returns>Un bloque de memoria que comienza en <paramref name="relativeVirtualAddress" /> y termina al final de la sección contenedora, o bien un bloque vacío si <paramref name="relativeVirtualAddress" /> no representa una ubicación en ninguna de las secciones PE de esta imagen de PE.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetSectionData(System.String)">
      <summary>Carga en la memoria la sección de PE con el nombre especificado y devuelve un bloque de memoria que abarca la sección.</summary>
      <param name="sectionName">El nombre de la sección.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="sectionName" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">La imagen de PE no está disponible.</exception>
      <returns>Un bloque de memoria que abarca la sección, o bien un bloque vacío si no existe ninguna sección del <paramref name="sectionName" /> especificado en esta imagen de PE.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadCodeViewDebugDirectoryData(System.Reflection.PortableExecutable.DebugDirectoryEntry)">
      <summary>Lee los datos a los que apunta la entrada del directorio de depuración especificada y los interpreta como CodeView.</summary>
      <param name="entry">Una instancia de entrada del directorio de depuración.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="entry" /> no es una entrada CodeView.</exception>
      <exception cref="T:System.BadImageFormatException">Formato incorrecto de los datos.</exception>
      <exception cref="T:System.IO.IOException">Error de E/S al leer la secuencia subyacente.</exception>
      <exception cref="T:System.InvalidOperationException">La imagen de PE no está disponible.</exception>
      <returns>Una instancia de datos del directorio de depuración de vista de código.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadDebugDirectory">
      <summary>Lee todas las entradas de la tabla de directorio de depuración.</summary>
      <exception cref="T:System.BadImageFormatException">Formato incorrecto de la entrada.</exception>
      <exception cref="T:System.IO.IOException">Error de E/S al leer la secuencia subyacente.</exception>
      <exception cref="T:System.InvalidOperationException">La imagen de PE no está disponible.</exception>
      <returns>Una matriz de entradas de la tabla de directorio de depuración.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadEmbeddedPortablePdbDebugDirectoryData(System.Reflection.PortableExecutable.DebugDirectoryEntry)">
      <summary>Lee los datos a los que apunta la entrada del directorio de depuración especificada y los interpreta como un blob PDB portable insertado.</summary>
      <param name="entry">La entrada del directorio de depuración cuyos datos se van a leer.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="entry" /> no es una entrada <see cref="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.EmbeddedPortablePdb" />.</exception>
      <exception cref="T:System.BadImageFormatException">Formato incorrecto de los datos.</exception>
      <exception cref="T:System.InvalidOperationException">La imagen de PE no está disponible.</exception>
      <returns>El proveedor de un lector de metadatos para leer una imagen de PDB portable.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadPdbChecksumDebugDirectoryData(System.Reflection.PortableExecutable.DebugDirectoryEntry)">
      <summary>Lee los datos a los que apunta la entrada del directorio de depuración especificado y los interpreta como una entrada de suma de comprobación de PDB.</summary>
      <param name="entry">La entrada del directorio de depuración cuyos datos se van a leer.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="entry" /> no es una entrada de suma de comprobación de PDB.</exception>
      <exception cref="T:System.BadImageFormatException">Formato incorrecto de los datos.</exception>
      <exception cref="T:System.IO.IOException">Error de E/S al leer la secuencia subyacente.</exception>
      <exception cref="T:System.InvalidOperationException">La imagen de PE no está disponible.</exception>
      <returns>La entrada de suma de comprobación de PDB.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.TryOpenAssociatedPortablePdb(System.String,System.Func{System.String,System.IO.Stream},System.Reflection.Metadata.MetadataReaderProvider@,System.String@)">
      <summary>Abre un archivo PDB portable asociado a esta imagen de PE.</summary>
      <param name="peImagePath">La ruta de acceso a la imagen de PE. La ruta de acceso se usa para buscar el archivo PDB ubicado en el directorio que contiene el archivo PE.</param>
      <param name="pdbFileStreamProvider">Si se especifica, se llama para abrir un objeto <see cref="T:System.IO.Stream" /> para una ruta de acceso de archivo determinada. Se espera que el proveedor devuelva una instancia de <see cref="T:System.IO.Stream" /> legible y en la que se puedan realizar búsquedas, o bien <see langword="null" /> si el archivo de destino no existe o se debe omitir por algún motivo. El proveedor debe iniciar una excepción <see cref="T:System.IO.IOException" /> si no puede abrir el archivo debido a un error de E/S inesperado.</param>
      <param name="pdbReaderProvider">Si es correcto, se usa una nueva instancia de <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> para leer el archivo PDB portable.</param>
      <param name="pdbPath">Si es correcto y el archivo PDB se encuentra en un archivo, la ruta de acceso al archivo o <see langword="null" /> si el archivo PDB está insertado en la imagen de PE.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peImagePath" /> o <paramref name="pdbFileStreamProvider" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">La secuencia devuelta desde <paramref name="pdbFileStreamProvider" /> no admite operaciones de lectura y búsqueda.</exception>
      <exception cref="T:System.BadImageFormatException">No se encontró ningún archivo PDB coincidente debido a un error: la imagen de PE o PDB no son válidos.</exception>
      <exception cref="T:System.IO.IOException">No se encontró ningún archivo PDB coincidente debido a un error: se produjo un error de e/s al leer la imagen de PE o PDB.</exception>
      <returns>
        <see langword="true" /> si la imagen de PE tiene un archivo PDB asociado y el archivo PDB se ha abierto correctamente; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.HasMetadata">
      <summary>Obtiene un valor que indica si la imagen de PE contiene metadatos de la CLI.</summary>
      <exception cref="T:System.BadImageFormatException">Los encabezados de PE contienen datos no válidos.</exception>
      <exception cref="T:System.IO.IOException">Error al leer desde la secuencia subyacente.</exception>
      <returns>
        <see langword="true" /> Si la imagen de PE contiene metadatos de la CLI; en caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.IsEntireImageAvailable">
      <summary>Obtiene un valor que indica si el lector puede acceder a la imagen de PE completa.</summary>
      <returns>
        <see langword="true" /> Si el lector puede tener acceso a toda la imagen de PE; en caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.IsLoadedImage">
      <summary>Obtiene un valor que indica si el cargador del sistema operativo ha cargado en la memoria la imagen de PE.</summary>
      <returns>
        <see langword="true" /> si el cargador del sistema operativo ha cargado en la memoria la imagen de PE subyacente; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.PEHeaders">
      <summary>Obtiene los encabezados de PE.</summary>
      <exception cref="T:System.BadImageFormatException">Los encabezados contienen datos no válidos.</exception>
      <exception cref="T:System.IO.IOException">Error al leer de la secuencia.</exception>
      <returns>Encabezados de PE para esta imagen de PE.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEStreamOptions">
      <summary>Proporciona opciones que especifican cómo se leen las secciones de una imagen PE desde una secuencia.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.Default">
      <summary>De forma predeterminada, la secuencia se desecha cuando se elimina <see cref="T:System.Reflection.PortableExecutable.PEReader" /> y las secciones de la imagen PE se leen de forma diferida.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.IsLoadedImage">
      <summary>Indica que el cargador del sistema operativo ha cargado en la memoria la imagen de PE subyacente.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen">
      <summary>Mantiene la secuencia abierta cuando se elimina <see cref="T:System.Reflection.PortableExecutable.PEReader" />.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchEntireImage">
      <summary>Lee la imagen completa en memoria inmediatamente. <see cref="T:System.Reflection.PortableExecutable.PEReader" /> cierra la secuencia de forma automática cuando vuelve el constructor, a menos que se especifique <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen" />.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata">
      <summary>
        <para>Lee la sección de metadatos en memoria inmediatamente.</para>
        <para>No se permite la lectura desde otras secciones del archivo (<see cref="T:System.Reflection.PortableExecutable.PEReader" /> inicia una excepción <see cref="T:System.InvalidOperationException" />).</para>
        <para>
          <see cref="T:System.Reflection.PortableExecutable.PEReader" /> cierra la secuencia de forma automática cuando vuelve el constructor, a menos que se especifique <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen" />. Después de que se construya <see cref="T:System.Reflection.PortableExecutable.PEReader" />, se puede cerrar e incluso eliminar el archivo subyacente.</para>
      </summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.ResourceSectionBuilder">
      <summary>Define la clase base para un generador de secciones de recursos de PE. Se deriva de <see cref="T:System.Reflection.PortableExecutable.ResourceSectionBuilder" /> para proporcionar la lógica de serialización para los recursos nativos.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.ResourceSectionBuilder.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Reflection.PortableExecutable.ResourceSectionBuilder" />.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.ResourceSectionBuilder.Serialize(System.Reflection.Metadata.BlobBuilder,System.Reflection.PortableExecutable.SectionLocation)">
      <summary>Serializa el recurso especificado.</summary>
      <param name="builder">Un blob que contiene los datos que se van a serializar.</param>
      <param name="location">La ubicación en la que se va a serializar <paramref name="builder" />.</param>
    </member>
    <member name="T:System.Reflection.PortableExecutable.SectionCharacteristics" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align1024Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align128Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align16Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align1Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align2048Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align256Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align2Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align32Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align4096Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align4Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align512Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align64Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align8192Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align8Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.AlignMask" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.ContainsCode" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.ContainsInitializedData" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.ContainsUninitializedData" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.GPRel" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerComdat" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerInfo" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerNRelocOvfl" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerOther" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerRemove" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Mem16Bit" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemDiscardable" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemExecute" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemFardata" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemLocked" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemNotCached" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemNotPaged" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemPreload" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemProtected" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemPurgeable" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemRead" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemShared" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemSysheap" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemWrite" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.NoDeferSpecExc" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeCopy" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeDSect" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeGroup" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeNoLoad" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeNoPad" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeOver" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeReg" />
    <member name="T:System.Reflection.PortableExecutable.SectionHeader">
      <summary>Proporciona información sobre el encabezado de sección de un archivo PE/COFF.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.Name">
      <summary>Obtiene el nombre de la sección.</summary>
      <returns>El nombre de la sección.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.NumberOfLineNumbers">
      <summary>Obtiene el número de entradas de número de línea de la sección.</summary>
      <returns>Número de entradas de número de línea de la sección.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.NumberOfRelocations">
      <summary>Obtiene el número de entradas de reubicación de la sección.</summary>
      <returns>El número de entradas de reubicación para la sección. Su valor es cero para las imágenes PE.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToLineNumbers">
      <summary>Obtiene el puntero de archivo al principio de las entradas de número de línea de la sección.</summary>
      <returns>El puntero de archivo al principio de las entradas de número de línea de la sección, o bien, cero si no hay números de línea COFF.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToRawData">
      <summary>Obtiene el puntero de archivo a la primera página de la sección dentro del archivo COFF.</summary>
      <returns>Puntero de archivo a la primera página de la sección dentro del archivo COFF.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToRelocations">
      <summary>Obtiene el puntero de archivo al principio de las entradas de reubicación de la sección.</summary>
      <returns>Puntero de archivo al principio de las entradas de reubicación de la sección. Se establece en cero para las imágenes PE o si no hay reubicaciones.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.SectionCharacteristics">
      <summary>Obtiene las marcas que describen las características de la sección.</summary>
      <returns>Marcas que describen las características de la sección.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.SizeOfRawData">
      <summary>Obtiene el tamaño de la sección (para archivos de objeto) o el tamaño de los datos inicializados en disco (para archivos de imagen).</summary>
      <returns>El tamaño de la sección (para archivos objeto) o el tamaño de los datos inicializados en disco (para archivos de imagen).</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.VirtualAddress">
      <summary>Obtiene la dirección virtual de la sección.</summary>
      <returns>Dirección virtual de la sección.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.VirtualSize">
      <summary>Obtiene el tamaño total de la sección cuando se carga en la memoria.</summary>
      <returns>Tamaño total de la sección cuando se carga en la memoria.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.SectionLocation" />
    <member name="M:System.Reflection.PortableExecutable.SectionLocation.#ctor(System.Int32,System.Int32)">
      <param name="relativeVirtualAddress" />
      <param name="pointerToRawData" />
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionLocation.PointerToRawData" />
    <member name="P:System.Reflection.PortableExecutable.SectionLocation.RelativeVirtualAddress" />
    <member name="T:System.Reflection.PortableExecutable.Subsystem">
      <summary>Describe el requisito de subsistema para la imagen.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiApplication">
      <summary>Aplicación Extensible Firmware Interface (EFI).</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiBootServiceDriver">
      <summary>Controlador EFI con servicios de arranque.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiRom">
      <summary>Imagen de EFI ROM.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiRuntimeDriver">
      <summary>Controlador EFI con servicios en tiempo de ejecución.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.Native">
      <summary>La imagen no requiere un subsistema.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.NativeWindows">
      <summary>La imagen es un controlador de Win9x nativo.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.OS2Cui">
      <summary>La imagen se ejecuta en el subsistema de caracteres de OS/2.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.PosixCui">
      <summary>La imagen se ejecuta en el subsistema de caracteres de Posix.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.Unknown">
      <summary>Subsistema desconocido.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsBootApplication">
      <summary>Aplicación de arranque.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsCEGui">
      <summary>La imagen se ejecuta en el subsistema de caracteres de Windows CE.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsCui">
      <summary>La imagen se ejecuta en el subsistema de caracteres de Windows.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsGui">
      <summary>La imagen se ejecuta en el subsistema GUI de Windows.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.Xbox">
      <summary>Sistema Xbox.</summary>
    </member>
  </members>
</doc>